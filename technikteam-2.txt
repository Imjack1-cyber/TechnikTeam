
========================================================================
FILE: src\main\resources\db\migration\V8__Populate_wiki_data_part3.sql
========================================================================

-- Flyway migration V8, Part 3

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/dao/RoleDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO provides read-only access to the user roles defined in the `roles` table. It features a simple caching mechanism using Caffeine to avoid repeatedly querying the database for the list of roles, which changes very infrequently.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `AdminUserServlet` to populate the roles dropdown in the user editing modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   **Caffeine (`com.github.benmanes.caffeine.cache.LoadingCache`)**: A high-performance caching library used to cache the list of roles in memory.\n\n4.  **In-Depth Breakdown**\n\n    *   **`RoleDAO(DatabaseManager dbManager)` (Constructor)**: Initializes the Caffeine `LoadingCache`. The cache is configured to expire after one hour and to hold only one entry (the list of all roles). The `build` method provides the loader function (`fetchAllRolesFromDb`) that is called automatically on a cache miss.\n    *   **`getAllRoles()`**: The main public method. It retrieves the list of all roles from the cache using `roleCache.get(ALL_ROLES_KEY)`. If the cache is empty or expired, the loader function is automatically triggered.\n    *   **`fetchAllRolesFromDb()`**: A private method that performs the actual database query to get all roles. This method is only called when the cache needs to be populated.'),
('src/main/java/de/technikteam/dao/StatisticsDAO.java', '1.  **File Overview & Purpose**\n\n    This is a specialized, read-only DAO for retrieving simple statistical counts from the database. It is used to quickly fetch aggregate numbers for display on the admin dashboard without the overhead of more complex reporting queries.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `AdminDashboardServlet` to gather high-level metrics about the system''s state.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getUserCount()`**: Executes a `SELECT COUNT(*)` query on the `users` table to get the total number of registered users.\n    *   **`getActiveEventCount()`**: Executes a `SELECT COUNT(*)` query on the `events` table to count events that have not yet finished.\n    *   **`getCount(String sql)`**: A private helper method that takes a SQL `COUNT` query as a string, executes it, and returns the integer result, reducing code duplication.'),
('src/main/java/de/technikteam/dao/StorageDAO.java', '1.  **File Overview & Purpose**\n\n    This is the primary DAO for managing the inventory, handling all database operations for the `storage_items` table. It provides comprehensive CRUD functionality, methods for handling defective and repaired items, and transactional logic for checking items in and out.\n\n2.  **Architectural Role**\n\n    This class is a cornerstone of the **DAO (Data Access) Tier**. It is used extensively by the `StorageService` to perform transactional operations and by various servlets (`StorageServlet`, `AdminStorageServlet`, `AdminDefectServlet`) to display and manage inventory data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `StorageItem` (Model): The data model for an inventory item.\n\n4.  **In-Depth Breakdown**\n\n    *   **Listing Methods (`getAllItemsGroupedByLocation`, `getAllItems`, `getDefectiveItems`, `getLowStockItems`)**: Provide different views of the inventory data, tailored for specific pages like the public lager view or admin dashboard widgets.\n    *   **CRUD Operations (`createItem`, `getItemById`, `updateItem`, `deleteItem`)**: Standard methods for managing the lifecycle of `StorageItem` records. The `updateItem` method is particularly comprehensive, updating nearly every column.\n    *   **Transactional Methods (`performCheckout`, `performCheckin`)**: These methods are designed to be called within a transaction managed by the `StorageService`. They update an item''s `quantity`, `status`, and `current_holder_user_id` atomically. The `performCheckout` query includes a `WHERE` clause to prevent checking out more items than are available.\n    *   **Defect & Repair Management (`updateDefectiveStatus`, `permanentlyReduceQuantities`, `repairItems`)**:\n        *   `updateDefectiveStatus`: Increases the `defective_quantity` for an item.\n        *   `permanentlyReduceQuantities`: Decreases both `quantity` and `defective_quantity`, effectively removing an unrepairable item from the total stock.\n        *   `repairItems`: Decreases the `defective_quantity`, moving an item back into the available pool.\n    *   **`mapResultSetToStorageItem(ResultSet rs)`**: A private helper method to construct a `StorageItem` object from a database query result.'),
('src/main/java/de/technikteam/dao/StorageLogDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all interactions with the `storage_log` table. Its purpose is to create transaction records when inventory items are checked in or out, and to retrieve the history of these transactions for a specific item.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `StorageService` to log transactions and by the `StorageItemDetailsServlet` to display an item''s history.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `StorageLogEntry` (Model): The data model for a log entry.\n\n4.  **In-Depth Breakdown**\n\n    *   **`logTransaction(...)`**: Inserts a new transaction record into the `storage_log` table. This method takes a `Connection` object as a parameter because it is designed to be called from within a larger transaction managed by the `StorageService`.\n    *   **`getHistoryForItem(int itemId)`**: Retrieves the complete transaction history for a single item, ordered from newest to oldest. It joins with the `users` table to include the username of the person who performed each transaction.'),
('src/main/java/de/technikteam/dao/TodoDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations for the administrative To-Do list feature. It handles CRUD for both categories (`todo_categories`) and tasks (`todo_tasks`), and includes methods for batch-updating their display order to support drag-and-drop functionality.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used exclusively by the `TodoService` to persist and retrieve all To-Do list data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `TodoCategory`, `TodoTask` (Models).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllCategoriesWithTasks()`**: The main retrieval method. It fetches all categories and, using a `LEFT JOIN`, also fetches all their associated tasks in a single query. It then uses a `LinkedHashMap` to aggregate the flat result set into a structured list of `TodoCategory` objects, each containing its list of `TodoTask` objects.\n    *   **`createCategory(...)` / `createTask(...)`**: These methods use a subquery (`SELECT COALESCE(MAX(display_order), -1) + 1 FROM ...`) to automatically assign the new item the next available display order index, ensuring it appears at the bottom of the list.\n    *   **`updateCategoryOrder(...)` / `updateTaskOrders(...)`**: These methods are crucial for the drag-and-drop feature. They accept a list of IDs in their new order and perform a batch `UPDATE` to efficiently persist the new sorting to the database within a single transaction.'),
('src/main/java/de/technikteam/dao/UserDAO.java', '1.  **File Overview & Purpose**\n\n    This is the central DAO for managing user accounts. It handles all database operations for the `users` table, including credential validation, CRUD operations, password changes, and managing the user-permission relationship in the `user_permissions` table.\n\n2.  **Architectural Role**\n\n    This is a critical class in the **DAO (Data Access) Tier**. It is used by the `LoginServlet` for authentication, by the `UserService` for transactional updates, and by numerous other servlets and DAOs to retrieve user information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   **Spring Security Crypto (`BCryptPasswordEncoder`)**: The library used for securely hashing and verifying passwords.\n    *   `PermissionDAO`: Used to fetch the permissions for a user.\n\n4.  **In-Depth Breakdown**\n\n    *   **`validateUser(String username, String password)`**: The core authentication method. It fetches the user''s `password_hash` from the database and uses `passwordEncoder.matches()` to securely compare it with the provided password. If validation is successful, it fetches the user''s permissions and returns a fully populated `User` object.\n    *   **`getPermissionsForUser(int userId)`**: Retrieves all permission keys for a given user.\n    *   **`updateUserPermissions(int userId, String[] permissionIds, Connection conn)`**: A transactional method that first deletes all of a user''s existing permissions and then batch-inserts the new set.\n    *   **`createUser(...)` / `updateUser(...)`**: Standard CRUD methods. `createUser` hashes the provided password before storing it.\n    *   **`changePassword(...)`**: Securely updates a user''s password by hashing the new password before saving it.'),
('src/main/java/de/technikteam/dao/UserQualificationsDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages the `user_qualifications` table, which links users to the courses they have attended or completed. It is the persistence layer for tracking user skills and qualifications.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `MatrixServlet` and `AdminAttendanceServlet` to update qualifications based on meeting attendance, and by the `ProfileServlet` to display a user''s qualifications.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `UserQualification` (Model).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getQualificationsForUser(int userId)`**: Retrieves all qualifications for a single user.\n    *   **`getAllQualifications()`**: Fetches all qualification records for all users, primarily for building the data structures needed by the Qualification Matrix.\n    *   **`updateQualificationStatus(...)`**: The core update method. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` statement (an \"upsert\") to create or update a qualification record. It also contains special logic: if the new status is `\"NICHT BESUCHT\"`, it deletes the record entirely instead of updating it.'),
('src/main/java/de/technikteam/dao/WikiDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all database interactions with the `wiki_documentation` table. It provides full CRUD (Create, Read, Update, Delete) operations for managing the content of the technical documentation wiki pages.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `WikiService` to load the documentation into its cache at startup, and by the various `Wiki` action classes to display and save changes to the wiki content.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `WikiEntry` (Model): The data model object that this DAO creates and populates.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getWikiEntryById(int id)`**: Retrieves a single wiki page by its primary key.\n    *   **`getAllWikiEntries()`**: Fetches all wiki pages from the database, ordered by their file path. This is used by the `WikiService` to populate its initial cache.\n    *   **`updateWikiContent(int id, String content)`**: Updates the `content` field for a specific wiki entry.\n    *   **`createWikiEntry(WikiEntry entry)`**: Inserts a new documentation record into the database and returns the created object with its new ID.\n    *   **`deleteWikiEntry(int id)`**: Deletes a wiki documentation record from the database by its primary key.'),
('src/main/java/de/technikteam/service/AchievementService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for checking and granting achievements to users based on specific trigger events. It decouples the achievement logic from the DAOs and the servlets where the triggering actions occur.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by other components (like `AdminEventServlet` after an event is marked as ''ABGESCHLOSSEN'') to evaluate a user''s progress and potentially award new achievements. It coordinates between the `AchievementDAO` and other DAOs (`EventDAO`) to gather the necessary data for its checks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AchievementDAO` and `EventDAO`.\n    *   `AchievementDAO`: Used to check if a user already has an achievement and to grant new ones.\n    *   `EventDAO`: Used to fetch data about a user''s event history (participation count, leadership count).\n\n4.  **In-Depth Breakdown**\n\n    *   **`checkAndGrantAchievements(User user, String triggerType)`**\n        *   **Method Signature:** `public void checkAndGrantAchievements(User user, String triggerType)`\n        *   **Purpose:** The main entry point for the service. It acts as a router, calling specific check methods based on the `triggerType`.\n        *   **Parameters:**\n            *   `user` (User): The user whose achievements should be checked.\n            *   `triggerType` (String): A string identifying the event that triggered the check (e.g., \"EVENT_COMPLETED\").\n        *   **Side Effects:** Can lead to database writes via the `achievementDAO.grantAchievementToUser` method.\n\n    *   **`checkEventParticipationAchievements(User user)`**\n        *   **Method Signature:** `private void checkEventParticipationAchievements(User user)`\n        *   **Purpose:** Checks if the user has met the criteria for event participation achievements (e.g., 1, 5, or 10 completed events).\n        *   **Logic:** It fetches the number of completed events for the user from the `EventDAO` and then calls `achievementDAO.grantAchievementToUser` for each milestone the user has reached.\n        *   **Side Effects:** Database writes.\n\n    *   **`checkEventLeaderAchievements(User user)`**\n        *   **Method Signature:** `private void checkEventLeaderAchievements(User user)`\n        *   **Purpose:** Checks if the user has met the criteria for event leadership achievements.\n        *   **Logic:** It calculates the number of completed events where the user was the leader and grants the corresponding achievement if the criteria are met.\n        *   **Side Effects:** Database writes.'),
('src/main/java/de/technikteam/service/AdminDashboardService.java', '1.  **File Overview & Purpose**\n\n    This service class is responsible for aggregating all the data required for the administrative dashboard. It acts as a facade, coordinating calls to various DAOs to collect information for the different dashboard widgets (Upcoming Events, Low Stock, Recent Logs, Event Trend) and assembling it into a single `DashboardDataDTO`.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It encapsulates the business logic for what data should be displayed on the admin dashboard. It is called by the `AdminDashboardApiServlet` to provide the data needed for the dynamic, client-side rendering of the dashboard.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO`, `StorageDAO`, `AdminLogDAO`, and `ReportDAO`.\n    *   `EventDAO`: Used to fetch upcoming events.\n    *   `StorageDAO`: Used to fetch items with low stock levels.\n    *   `AdminLogDAO`: Used to fetch the most recent log entries.\n    *   `ReportDAO`: Used to fetch the time-series data for the event trend chart.\n    *   `DashboardDataDTO` (Model): The Data Transfer Object this service populates and returns.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getDashboardData()`**\n        *   **Method Signature:** `public DashboardDataDTO getDashboardData()`\n        *   **Purpose:** The single public method of this service. It orchestrates the data retrieval for the entire admin dashboard.\n        *   **Parameters:** None.\n        *   **Returns:** A fully populated `DashboardDataDTO` object containing all the data required by the dashboard''s widgets.\n        *   **Side Effects:** Performs multiple read operations on the database via the injected DAOs. It uses a `WIDGET_LIMIT` constant to control the number of items fetched for list-based widgets.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V9__Populate_wiki_data_part4.sql
========================================================================

-- Flyway migration V9, Part 4

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/service/AdminLogService.java', '1.  **File Overview & Purpose**\n\n    This service provides a centralized and safe way to create audit log entries. It acts as an abstraction layer over the `AdminLogDAO`, adding input sanitization and structured logging to ensure that all administrative actions are reliably recorded in both the database and the application logs.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting concern that belongs to the **Service Tier**. It is injected into and used by numerous other services and servlets throughout the administrative side of the application whenever a state-changing action is performed.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AdminLogDAO`.\n    *   `AdminLogDAO`: The DAO used to persist the log entries.\n    *   `Log4j`: Used to write the audit message to the main application log file in addition to the database.\n\n4.  **In-Depth Breakdown**\n\n    *   **`log(String adminUsername, String actionType, String details)`**\n        *   **Method Signature:** `public void log(String adminUsername, String actionType, String details)`\n        *   **Purpose:** Creates and persists a new audit log entry.\n        *   **Parameters:**\n            *   `adminUsername` (String): The username of the admin performing the action.\n            *   `actionType` (String): A short, standardized key for the action (e.g., \"CREATE_USER\").\n            *   `details` (String): A human-readable description of the action.\n        *   **Returns:** void.\n        *   **Side Effects:**\n            1.  **Sanitization:** It first sanitizes all input strings to remove newlines, preventing log injection or formatting issues.\n            2.  **Application Logging:** It logs the audit event to the application''s main log file at the `INFO` level with a clear `[AUDIT]` prefix.\n            3.  **Database Logging:** It creates an `AdminLog` model object and passes it to the `AdminLogDAO` to be written to the database.\n            4.  **Error Handling:** It wraps the entire process in a `try-catch` block to ensure that a failure in the logging mechanism (e.g., a database connection issue) does not crash the primary operation that was being logged. A critical error is logged if this happens.'),
('src/main/java/de/technikteam/service/AuthorizationService.java', '1.  **File Overview & Purpose**\n\n    This service provides a centralized mechanism for performing permission checks. It encapsulates the logic for determining whether a given user has the authority to perform a specific action, based on the set of permissions associated with their user object.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting concern that belongs to the **Service Tier**. It is used by servlets and action classes in the **Web/Controller Tier** to enforce fine-grained access control before executing sensitive operations.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `User` (Model): The object containing the user''s set of permissions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`checkPermission(User user, String permissionKey)`**\n        *   **Method Signature:** `public boolean checkPermission(User user, String permissionKey)`\n        *   **Purpose:** Determines if a user has a specific permission.\n        *   **Parameters:**\n            *   `user` (User): The user object to check.\n            *   `permissionKey` (String): The string key of the permission to verify (e.g., \"USER_CREATE\").\n        *   **Returns:** `true` if the user has the permission, `false` otherwise.\n        *   **Logic:**\n            1.  It first performs null checks on the user and their permissions set.\n            2.  It implements a \"superuser\" check: if the user has the `ACCESS_ADMIN_PANEL` permission, the method immediately returns `true`, granting access to any action.\n            3.  Otherwise, it checks if the user''s `permissions` set contains the requested `permissionKey`.'),
('src/main/java/de/technikteam/service/ConfigurationService.java', '1.  **File Overview & Purpose**\n\n    This service is responsible for loading and providing access to the application''s configuration settings from the `config.properties` file. As a Guice Singleton, it ensures that the properties file is read only once at application startup, and the settings are then available globally.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure/Configuration** component that supports all other tiers. It is injected into any class that needs access to configuration parameters, such as the `DatabaseManager` (for DB credentials) and file handling servlets (for the upload directory path).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.Properties`: The standard Java class used to load and store the key-value pairs from the `.properties` file.\n\n4.  **In-Depth Breakdown**\n\n    *   **`ConfigurationService()` (Constructor)**\n        *   **Purpose:** Loads the `config.properties` file from the classpath when the application starts.\n        *   **Side Effects:** Reads the properties file and populates the internal `Properties` object. If the file cannot be found or read, it logs a fatal error and throws a `RuntimeException`, preventing the application from starting in a misconfigured state.\n\n    *   **`getProperty(String key)`**\n        *   **Method Signature:** `public String getProperty(String key)`\n        *   **Purpose:** Retrieves the value for a given configuration key.\n        *   **Parameters:**\n            *   `key` (String): The name of the property to retrieve.\n        *   **Returns:** The property value as a `String`, or `null` if the key is not found.\n\n    *   **`getProperty(String key, String defaultValue)`**\n        *   **Method Signature:** `public String getProperty(String key, String defaultValue)`\n        *   **Purpose:** Retrieves the value for a given configuration key, returning a default value if the key is not found.\n        *   **Parameters:**\n            *   `key` (String): The name of the property to retrieve.\n            *   `defaultValue` (String): The value to return if the key is not present in the properties file.\n        *   **Returns:** The property value or the default value.'),
('src/main/java/de/technikteam/service/EventService.java', '1.  **File Overview & Purpose**\n\n    This service class orchestrates the complex business logic for creating and updating events. It manages the transactional saving of an event and all its related data (skill requirements, material reservations, custom fields, attachments) in a single, atomic operation.\n\n2.  **Architectural Role**\n\n    This class is a key component of the **Service Tier**. It is called by the `AdminEventServlet` to handle form submissions for creating or editing events. It coordinates multiple DAOs (`EventDAO`, `AttachmentDAO`, `EventCustomFieldDAO`) within a single database transaction to ensure data integrity.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the various DAOs, `DatabaseManager`, `ConfigurationService`, and `AdminLogService`.\n    *   `EventDAO`: For managing the core event record and its direct relationships.\n    *   `AttachmentDAO`: For saving new file attachment records.\n    *   `EventCustomFieldDAO`: For saving custom field definitions.\n    *   `DatabaseManager`: Used to get a connection and manage the transaction (`setAutoCommit`, `commit`, `rollback`).\n\n4.  **In-Depth Breakdown**\n\n    *   **`createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, HttpServletRequest request)`**\n        *   **Method Signature:** `public int createOrUpdateEvent(...)`\n        *   **Purpose:** The main method of the service. It handles the entire process of saving an event and its associated data within a single database transaction.\n        *   **Parameters:**\n            *   `event` (Event): The core event object to save.\n            *   `isUpdate` (boolean): A flag to determine if this is a new event (`INSERT`) or an existing one (`UPDATE`).\n            *   `adminUser` (User): The administrator performing the action, for logging purposes.\n            *   `request` (HttpServletRequest): The request object, used to retrieve arrays of related data like skill requirements, item reservations, and uploaded files.\n        *   **Returns:** The ID of the created or updated event, or `0` on failure.\n        *   **Side Effects:**\n            1.  **Transaction Management:** It gets a connection from the `DatabaseManager` and sets `autoCommit` to `false`.\n            2.  **Core Event Save:** It calls either `eventDAO.createEvent` or `eventDAO.updateEvent`.\n            3.  **Associated Data Save:** It calls the respective DAOs to save skill requirements, reservations, and custom fields, all using the same `Connection` object.\n            4.  **File Upload:** It handles any uploaded file (`Part`) by saving it to disk and creating a corresponding record in the `attachments` table.\n            5.  **Commit/Rollback:** If all operations succeed, it calls `conn.commit()`. If any exception occurs, it calls `conn.rollback()` to undo all changes, ensuring the database remains in a consistent state.\n\n    *   **`signOffUserFromRunningEvent(...)`**: Contains the logic to sign a user off and send a notification to the event leader.'),
('src/main/java/de/technikteam/service/NotificationService.java', '1.  **File Overview & Purpose**\n\n    This service implements a server-side push notification system using Server-Sent Events (SSE). It manages persistent HTTP connections with clients, allowing the server to push real-time updates to the frontend. It is implemented as a thread-safe Singleton to provide a single, global point for broadcasting messages.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Infrastructure/Service Tier** component. It is called by various other services and servlets (e.g., `EventService`, `AdminUserServlet`, `EventChatSocket`) whenever a state change occurs that needs to be reflected in real-time on other users'' browsers. The `NotificationServlet` is the client-facing entry point that registers clients with this service.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.AsyncContext`)**: Used to manage the long-lived asynchronous connections required for SSE.\n    *   **Gson**: Used to serialize notification payloads into JSON strings before sending them to the client.\n\n4.  **In-Depth Breakdown**\n\n    *   **Singleton Implementation**: The service uses a private constructor and a static `INSTANCE` field with a `getInstance()` method to ensure only one instance exists for the entire application.\n    *   **`contextsByUser` (Map<Integer, List<AsyncContext>>)**: A thread-safe `ConcurrentHashMap` that is the core of the service. It maps a `userId` to a list of all active SSE connections for that user (a user can have multiple browser tabs open).\n    *   **`register(HttpServletRequest request)`**: Called by the `NotificationServlet` when a client connects. It starts an `AsyncContext`, sets its timeout to infinite, and adds it to the `contextsByUser` map.\n    *   **`broadcastGenericMessage(String message)`**: Sends a simple text message to *all* connected clients.\n    *   **`broadcastUIUpdate(String type, Object payload)`**: Sends a structured update message to *all* connected clients, indicating a specific type of UI change (e.g., \"user_updated\") and providing the relevant data.\n    *   **`sendNotificationToUser(int userId, Map<String, Object> payload)`**: Sends a targeted notification to all active sessions for a *single* user. This is used for user-specific alerts like mentions or invitations.\n    *   **`sendEventInvitation(...)`**: A specialized convenience method that constructs and sends an event invitation notification.\n    *   **`sendMessageToContext(...)`**: A private helper method that handles the actual writing of the SSE-formatted data (`data: ...\\n\\n`) to a client''s response stream. It includes robust error handling to detect and remove disconnected clients, preventing memory leaks.'),
('src/main/java/de/technikteam/service/PasskeyService.java', '1.  **File Overview & Purpose**\n\n    This service class encapsulates the server-side business logic for WebAuthn/Passkey authentication. It handles the start and finish of both the registration and authentication ceremonies. **Note: The current implementation is a placeholder/simulation** and does not perform the actual cryptographic operations required for a secure WebAuthn flow. It demonstrates the API structure and interaction with the DAO layer.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by the Passkey API servlets (`RegistrationStartServlet`, `AuthenticationFinishServlet`, etc.) to process passkey-related requests. It coordinates between the client-side WebAuthn API and the `PasskeyDAO` for credential storage.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyDAO` and `UserDAO`.\n    *   `PasskeyDAO`: Used to store and retrieve passkey credential data.\n    *   `UserDAO`: Used to retrieve user information during the ceremonies.\n\n4.  **In-Depth Breakdown**\n\n    *   **`startRegistration(User user)`**\n        *   **Purpose:** Generates the initial challenge and options required by the browser to start the passkey creation process.\n        *   **Logic (Simulated):** Generates a random challenge string and constructs a JSON object containing the Relying Party (RP) information, user details, and public key parameters. In a real implementation, this would use a library like `webauthn-server-core` to generate a cryptographically secure challenge and store it in the session.\n        *   **Returns:** A JSON string with the `PublicKeyCredentialCreationOptions`.\n\n    *   **`finishRegistration(int userId, String credentialData, String deviceName)`**\n        *   **Purpose:** Receives the response from the browser''s `navigator.credentials.create()` call and saves the new credential.\n        *   **Logic (Simulated):** It does not validate the `credentialData`. Instead, it creates a new `PasskeyCredential` object with simulated data (random user handle, credential ID, and a placeholder public key) and saves it via the `PasskeyDAO`.\n        *   **Returns:** `true` on successful save.\n\n    *   **`startAuthentication(String username)`**\n        *   **Purpose:** Generates the challenge and options for the browser to start the passkey authentication process.\n        *   **Logic (Simulated):** Generates a random challenge. In a real implementation, it would also fetch the `credentialId`s for the given username from the DAO to include in the `allowCredentials` list.\n        *   **Returns:** A JSON string with the `PublicKeyCredentialRequestOptions`.\n\n    *   **`finishAuthentication(String credentialData)`**\n        *   **Purpose:** Receives the response from the browser''s `navigator.credentials.get()` call, verifies it, and logs the user in.\n        *   **Logic (Simulated):** This is the most significant simulation. It **does not perform any cryptographic verification**. It simply fetches a hardcoded user (admin user with ID 1) from the `UserDAO` and returns it, effectively logging them in. In a real implementation, this method would be the most complex, involving fetching the stored public key, verifying the signature against the challenge, and updating the signature counter.'),
('src/main/java/de/technikteam/service/StorageService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for all inventory-related state changes. It provides transactional methods for processing check-ins/check-outs and for managing the status of defective items, ensuring that all related database updates and logging occur as a single, atomic operation.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by the `StorageTransactionServlet` and `AdminStorageServlet` to execute inventory operations. It coordinates multiple DAOs (`StorageDAO`, `StorageLogDAO`, `EventDAO`) and the `AdminLogService` within a database transaction.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the DAOs, `DatabaseManager`, and `AdminLogService`.\n    *   `DatabaseManager`: Used to manage database connections and transactions.\n    *   `StorageDAO`: For updating the `storage_items` table.\n    *   `StorageLogDAO`: For creating entries in the `storage_log` table.\n    *   `AdminLogService`: For creating entries in the `admin_logs` table.\n\n4.  **In-Depth Breakdown**\n\n    *   **`processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes)`**\n        *   **Method Signature:** `public boolean processTransaction(...)`\n        *   **Purpose:** Handles the check-out and check-in of inventory items within a database transaction.\n        *   **Logic:**\n            1.  Opens a database connection and disables auto-commit.\n            2.  Retrieves the `StorageItem` to perform validation checks (e.g., sufficient stock for checkout).\n            3.  Calls the appropriate method on `StorageDAO` (`performCheckout` or `performCheckin`).\n            4.  If the DAO operation is successful, it calls `StorageLogDAO.logTransaction` to record the event.\n            5.  It then calls `AdminLogService.log` to create an audit trail.\n            6.  If all steps succeed, it calls `conn.commit()`.\n            7.  If any step fails, it calls `conn.rollback()` and logs the error, ensuring the database remains in a consistent state.\n        *   **Returns:** `true` if the entire transaction was successful, `false` otherwise.\n\n    *   **`updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser)`**\n        *   **Method Signature:** `public boolean updateDefectiveItemStatus(...)`\n        *   **Purpose:** Manages the process of marking items as defective or unrepairable within a transaction.\n        *   **Logic:** Similar to `processTransaction`, it wraps the database operations in a transaction.\n            *   If `status` is `\"UNREPAIRABLE\"`, it calls `storageDAO.permanentlyReduceQuantities`, which decreases both the total and defective counts.\n            *   If `status` is `\"DEFECT\"`, it calls `storageDAO.updateDefectiveStatus`, which increases the defective count.\n            *   It logs the action to the `admin_logs` table.\n        *   **Returns:** `true` on success, `false` on failure.'),
('src/main/java/de/technikteam/service/SystemInfoService.java', '1.  **File Overview & Purpose**\n\n    This service is responsible for gathering and formatting live system statistics from the host operating system. It uses Java''s Management Extensions (JMX) and, for Linux-specific data like uptime and battery, reads directly from the `/proc` and `/sys` filesystems to provide a snapshot of the server''s health.\n\n2.  **Architectural Role**\n\n    This is a specialized **Service Tier** component. It is called by the `SystemStatsApiServlet` to provide real-time data for the admin system status page. It is designed to be platform-aware, providing graceful fallbacks for metrics that are not available on non-Linux systems.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **JMX (`com.sun.management.OperatingSystemMXBean`)**: The core Java API for accessing operating system-level metrics like CPU load and memory usage.\n    *   `java.nio.file.Files`: Used to read system files for Linux-specific stats.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getSystemStats()`**\n        *   **Method Signature:** `public SystemStatsDTO getSystemStats()`\n        *   **Purpose:** The main public method that collects all system metrics.\n        *   **Logic:**\n            1.  Gets an instance of `OperatingSystemMXBean`.\n            2.  Retrieves CPU load (`getSystemCpuLoad`), total and free physical memory.\n            3.  Retrieves total and usable disk space for the root partition (`/`).\n            4.  Calls the private helper methods `getSystemUptime()` and `getBatteryPercentage()`.\n            5.  Populates and returns a `SystemStatsDTO` with the collected data, converting byte values to Gigabytes where appropriate.\n        *   **Returns:** A `SystemStatsDTO` object.\n\n    *   **`getSystemUptime()`**: A private helper that reads the uptime in seconds from `/proc/uptime` on Linux and formats it into a human-readable \"days, hours, minutes\" string. It returns \"Nicht verfügbar\" on non-Linux systems or if the file cannot be read.\n\n    *   **`getBatteryPercentage()`**: A private helper that reads the battery capacity from `/sys/class/power_supply/BAT0/capacity` on Linux. It returns `-1` if the file doesn''t exist (e.g., on a desktop or non-Linux system), which signals the UI to hide the battery widget.'),
('src/main/java/de/technikteam/service/TodoService.java', '1.  **File Overview & Purpose**\n\n    This service class encapsulates the business logic for the administrative To-Do list feature. It provides transactional methods for creating, updating, reordering, and deleting To-Do categories and tasks, ensuring that both the database operations and the corresponding audit logs are handled correctly.\n\n2.  **Architectural Role**\n\n    This class is part of the **Service Tier**. It is used exclusively by the `AdminTodoApiServlet` to perform all state-changing operations on the To-Do list. It coordinates the `TodoDAO` and `AdminLogService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`, `TodoDAO`, and `AdminLogService`.\n    *   `DatabaseManager`: Used for managing database transactions.\n    *   `TodoDAO`: The DAO for all To-Do list database operations.\n    *   `AdminLogService`: Used to create an audit trail for every action performed.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllTodos()`**: A simple pass-through method to retrieve all categories and their tasks from the DAO.\n    *   **`createCategory(String name, User admin)`**: Creates a new To-Do category and logs the action.\n    *   **`createTask(int categoryId, String content, User admin)`**: Creates a new task within a category and logs the action.\n    *   **`updateTask(int taskId, String content, Boolean isCompleted, User admin)`**: A transactional method to update a task''s content and/or completion status. It logs the specific action performed.\n    *   **`deleteTask(int taskId, User admin)`**: Deletes a task and logs the action.\n    *   **`deleteCategory(int categoryId, User admin)`**: Deletes a category (which cascades to its tasks) and logs the action.\n    *   **`reorder(Map<String, List<Integer>> reorderData, User admin)`**\n        *   **Method Signature:** `public boolean reorder(Map<String, List<Integer>> reorderData, User admin)`\n        *   **Purpose:** A transactional method to handle complex reordering operations from the drag-and-drop UI.\n        *   **Logic:** It opens a transaction and calls the DAO''s batch update methods to persist the new order of categories and the new order/category assignment of tasks. It commits the transaction if successful and logs a single \"reorder\" event.\n        *   **Returns:** `true` on success, `false` on failure.'),
('src/main/java/de/technikteam/service/UserService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for user management operations that require database transactions. It orchestrates the creation and updating of users and their associated permissions as a single, atomic operation to ensure data integrity.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is used by the `Action` classes (`CreateUserAction`, `UpdateUserAction`) which are invoked by the `FrontControllerServlet`. It provides a higher-level abstraction over the `UserDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`, `UserDAO`, and `AdminLogService`.\n    *   `DatabaseManager`: Used to obtain a connection and manage transactions.\n    *   `UserDAO`: The DAO for performing the actual user and permission database operations.\n    *   `AdminLogService`: Used to create an audit log entry for the actions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername)`**\n        *   **Method Signature:** `public int createUserWithPermissions(...)`\n        *   **Purpose:** Creates a new user and assigns their initial permissions within a single database transaction.\n        *   **Logic:**\n            1.  Begins a transaction by disabling auto-commit.\n            2.  Calls `userDAO.createUser()` to insert the new user record.\n            3.  If the user is created successfully (returns a new ID), it calls `userDAO.updateUserPermissions()` to set their permissions.\n            4.  If both operations succeed, it commits the transaction.\n            5.  It then logs the successful creation event to the admin log.\n            6.  If any step fails, it rolls back the transaction.\n        *   **Returns:** The ID of the newly created user, or `0` on failure.\n\n    *   **`updateUserWithPermissions(User user, String[] permissionIds)`**\n        *   **Method Signature:** `public boolean updateUserWithPermissions(...)`\n        *   **Purpose:** Updates a user''s profile information and their set of permissions within a single database transaction.\n        *   **Logic:**\n            1.  Begins a transaction.\n            2.  Calls `userDAO.updateUser()` to save changes to the user''s profile.\n            3.  Calls `userDAO.updateUserPermissions()` to overwrite the user''s existing permissions with the new set.\n            4.  Commits the transaction if both operations succeed, otherwise rolls back.\n        *   **Returns:** `true` if the transaction was successful, `false` otherwise.'),
('src/main/java/de/technikteam/filter/AdminFilter.java', '1.  **File Overview & Purpose**\n\n    This servlet filter acts as a security gate for all administrative sections of the application. It intercepts every request to URLs matching `/admin/*` and `/api/admin/*` to ensure that only authenticated users with appropriate administrative permissions can access them.\n\n2.  **Architectural Role**\n\n    This class is a core component of the **Web/Controller Tier**. It enforces access control at the entry point of the application, before any admin servlet or API endpoint is executed. It relies on the `User` object stored in the session, which is populated by the `AuthenticationFilter`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.Filter`)**: The core interface for implementing a web filter.\n    *   `User` (Model): The object representing the logged-in user, retrieved from the `HttpSession`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`init(FilterConfig filterConfig)`**: Called once by the servlet container on startup. It logs a confirmation message that the filter has been initialized.\n\n    *   **`doFilter(ServletRequest req, ServletResponse res, FilterChain chain)`**\n        *   **Method Signature:** `public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException`\n        *   **Purpose:** This is the main logic of the filter, executed for every matching request.\n        *   **Parameters:**\n            *   `req` (ServletRequest): The incoming request.\n            *   `res` (ServletResponse): The outgoing response.\n            *   `chain` (FilterChain): An object that allows the filter to pass the request along to the next entity in the chain (another filter or the target servlet).\n        *   **Logic:**\n            1.  It first checks if a user session exists and if a `User` object is present. If not, it redirects the user to the `/login` page.\n            2.  If a user is logged in, it calls the `user.hasAdminAccess()` method. This method centrally determines if the user has any permission that qualifies them for admin access.\n            3.  If `hasAdminAccess()` returns `true`, it calls `chain.doFilter()`, allowing the request to proceed to the requested admin page or API.\n            4.  If `hasAdminAccess()` returns `false`, it logs a warning, sets a user-facing error message in the session, and sends an HTTP 403 (Forbidden) error back to the client.\n\n    *   **`destroy()`**: Called when the application is shut down. Logs a confirmation message.'),
('src/main/java/de/technikteam/filter/AuthenticationFilter.java', '1.  **File Overview & Purpose**\n\n    This is the primary authentication filter for the entire application. It intercepts every single request (`/*`) to determine if the user is authenticated. It protects all resources except for a defined set of public paths and resource prefixes.\n\n2.  **Architectural Role**\n\n    This class is a fundamental component of the **Web/Controller Tier**. It acts as the first line of defense, ensuring that unauthenticated users cannot access any protected part of the application.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.Filter`)**: The interface it implements.\n    *   `User` (Model): The object it looks for in the `HttpSession` to verify authentication.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Fields:**\n        *   `PUBLIC_PATHS`: A `Set` containing specific URL paths that do not require authentication (e.g., `/login`, `/logout`).\n        *   `PUBLIC_RESOURCE_PREFIXES`: A `Set` containing URL prefixes for static resources (like CSS, JS, images) and the passkey authentication API (`/api/auth`) that must be publicly accessible.\n    *   **`doFilter(ServletRequest req, ServletResponse res, FilterChain chain)`**:\n        *   **Purpose:** The core filter logic.\n        *   **Logic:**\n            1.  It retrieves the current `HttpSession` (without creating one if it doesn''t exist).\n            2.  It extracts the request path and sanitizes it by removing any `jsessionid` path parameters.\n            3.  It checks if a `User` object exists in the session to determine the `isLoggedIn` status.\n            4.  It checks if the requested path is in the `PUBLIC_PATHS` set or starts with any of the `PUBLIC_RESOURCE_PREFIXES`.\n            5.  If the user is logged in OR the resource is public, it calls `chain.doFilter()` to allow the request to proceed.\n            6.  If the user is not logged in AND the resource is not public, it logs a warning and redirects the user to the `/login` page.');
COMMIT;