
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventDebriefing.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class EventDebriefing {
	private int id;
	private int eventId;
	private int authorUserId;
	private LocalDateTime submittedAt;
	private String whatWentWell;
	private String whatToImprove;
	private String equipmentNotes;
	private String standoutCrewMembers; // Stored as JSON string of user IDs

	// Transient fields for display
	private String eventName;
	private String authorUsername;
	private List<User> standoutCrewDetails; // Populated in service/resource layer

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getAuthorUserId() {
		return authorUserId;
	}

	public void setAuthorUserId(int authorUserId) {
		this.authorUserId = authorUserId;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getWhatWentWell() {
		return whatWentWell;
	}

	public void setWhatWentWell(String whatWentWell) {
		this.whatWentWell = whatWentWell;
	}

	public String getWhatToImprove() {
		return whatToImprove;
	}

	public void setWhatToImprove(String whatToImprove) {
		this.whatToImprove = whatToImprove;
	}

	public String getEquipmentNotes() {
		return equipmentNotes;
	}

	public void setEquipmentNotes(String equipmentNotes) {
		this.equipmentNotes = equipmentNotes;
	}

	public String getStandoutCrewMembers() {
		return standoutCrewMembers;
	}

	public void setStandoutCrewMembers(String standoutCrewMembers) {
		this.standoutCrewMembers = standoutCrewMembers;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public String getAuthorUsername() {
		return authorUsername;
	}

	public void setAuthorUsername(String authorUsername) {
		this.authorUsername = authorUsername;
	}

	public List<User> getStandoutCrewDetails() {
		return standoutCrewDetails;
	}

	public void setStandoutCrewDetails(List<User> standoutCrewDetails) {
		this.standoutCrewDetails = standoutCrewDetails;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventPhoto.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class EventPhoto {
	private int id;
	private int eventId;
	private int fileId;
	private int uploaderUserId;
	private String caption;
	private LocalDateTime uploadedAt;

	// Transient fields from JOINs
	private String filepath;
	private String uploaderUsername;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getFileId() {
		return fileId;
	}

	public void setFileId(int fileId) {
		this.fileId = fileId;
	}

	public int getUploaderUserId() {
		return uploaderUserId;
	}

	public void setUploaderUserId(int uploaderUserId) {
		this.uploaderUserId = uploaderUserId;
	}

	public String getCaption() {
		return caption;
	}

	public void setCaption(String caption) {
		this.caption = caption;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public String getUploaderUsername() {
		return uploaderUsername;
	}

	public void setUploaderUsername(String uploaderUsername) {
		this.uploaderUsername = uploaderUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventRole.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class EventRole {
	private int id;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details;
	private String status;
	private String eventName;
	private LocalDateTime updatedAt;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers = new ArrayList<>();
	private List<StorageItem> requiredItems = new ArrayList<>();
	private List<InventoryKit> requiredKits = new ArrayList<>();
	private List<EventTask> dependsOn = new ArrayList<>(); // Tasks that must be completed before this one
	private List<EventTask> dependencyFor = new ArrayList<>(); // Tasks that depend on this one

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getUpdatedAt() {
		return updatedAt;
	}

	public void setUpdatedAt(LocalDateTime updatedAt) {
		this.updatedAt = updatedAt;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}

	public List<EventTask> getDependsOn() {
		return dependsOn;
	}

	public void setDependsOn(List<EventTask> dependsOn) {
		this.dependsOn = dependsOn;
	}

	public List<EventTask> getDependencyFor() {
		return dependencyFor;
	}

	public void setDependencyFor(List<EventTask> dependencyFor) {
		this.dependencyFor = dependencyFor;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackSubmission.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single feedback submission from a user. Corresponds to the
 * `feedback_submissions` table.
 */
public class FeedbackSubmission {
	private int id;
	private int userId;
	private String username; 
	private String subject;
	private String displayTitle; 
	private String content;
	private LocalDateTime submittedAt;
	private String status;
	private int displayOrder;

	public String getFormattedSubmittedAt() {
		return DateFormatter.formatDateTime(this.submittedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public String getDisplayTitle() {
		return displayTitle;
	}

	public void setDisplayTitle(String displayTitle) {
		this.displayTitle = displayTitle;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private Integer categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;
	private boolean needsWarning;
	private String content;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public Integer getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(Integer categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}

	public boolean isNeedsWarning() {
		return needsWarning;
	}

	public void setNeedsWarning(boolean needsWarning) {
		this.needsWarning = needsWarning;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\PageDocumentation.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class PageDocumentation {
	private int id;
	private String pageKey;
	private String title;
	private String pagePath;
	private String features;
	private String relatedPages; // Stored as JSON
	private boolean adminOnly;
	private Integer wikiEntryId;
	private String category; // New field
	private LocalDateTime createdAt;
	private LocalDateTime updatedAt;
	private String wikiLink; // Transient field

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPageKey() {
		return pageKey;
	}

	public void setPageKey(String pageKey) {
		this.pageKey = pageKey;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getPagePath() {
		return pagePath;
	}

	public void setPagePath(String pagePath) {
		this.pagePath = pagePath;
	}

	public String getFeatures() {
		return features;
	}

	public void setFeatures(String features) {
		this.features = features;
	}

	public String getRelatedPages() {
		return relatedPages;
	}

	public void setRelatedPages(String relatedPages) {
		this.relatedPages = relatedPages;
	}

	public boolean isAdminOnly() {
		return adminOnly;
	}

	public void setAdminOnly(boolean adminOnly) {
		this.adminOnly = adminOnly;
	}

	public Integer getWikiEntryId() {
		return wikiEntryId;
	}

	public void setWikiEntryId(Integer wikiEntryId) {
		this.wikiEntryId = wikiEntryId;
	}

	public String getCategory() {
		return category;
	}

	public void setCategory(String category) {
		this.category = category;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public LocalDateTime getUpdatedAt() {
		return updatedAt;
	}

	public void setUpdatedAt(LocalDateTime updatedAt) {
		this.updatedAt = updatedAt;
	}

	public String getWikiLink() {
		return wikiLink;
	}

	public void setWikiLink(String wikiLink) {
		this.wikiLink = wikiLink;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\PasskeyCredential.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a WebAuthn/Passkey credential stored in the `user_passkeys` table.
 */
public class PasskeyCredential {
	private int id;
	private int userId;
	private String name;
	private String userHandle;
	private String credentialId;
	private String publicKey;
	private long signatureCount;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getUserHandle() {
		return userHandle;
	}

	public void setUserHandle(String userHandle) {
		this.userHandle = userHandle;
	}

	public String getCredentialId() {
		return credentialId;
	}

	public void setCredentialId(String credentialId) {
		this.credentialId = credentialId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public void setPublicKey(String publicKey) {
		this.publicKey = publicKey;
	}

	public long getSignatureCount() {
		return signatureCount;
	}

	public void setSignatureCount(long signatureCount) {
		this.signatureCount = signatureCount;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ProfileChangeRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single request from a user to change their profile data.
 * Corresponds to the `profile_change_requests` table.
 */
public class ProfileChangeRequest {
	private int id;
	private int userId;
	private String username; 
	private String requestedChanges; 
	private String status;
	private LocalDateTime requestedAt;
	private Integer reviewedByAdminId;
	private String reviewedByAdminName; 
	private LocalDateTime reviewedAt;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRequestedChanges() {
		return requestedChanges;
	}

	public void setRequestedChanges(String requestedChanges) {
		this.requestedChanges = requestedChanges;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getRequestedAt() {
		return requestedAt;
	}

	public void setRequestedAt(LocalDateTime requestedAt) {
		this.requestedAt = requestedAt;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public String getReviewedByAdminName() {
		return reviewedByAdminName;
	}

	public void setReviewedByAdminName(String reviewedByAdminName) {
		this.reviewedByAdminName = reviewedByAdminName;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\ScheduledNotification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ScheduledNotification {
	private int id;
	private int targetUserId;
	private String notificationType;
	private int relatedEntityId;
	private LocalDateTime sendAt;
	private String title;
	private String description;
	private String url;
	private String status;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getTargetUserId() {
		return targetUserId;
	}

	public void setTargetUserId(int targetUserId) {
		this.targetUserId = targetUserId;
	}

	public String getNotificationType() {
		return notificationType;
	}

	public void setNotificationType(String notificationType) {
		this.notificationType = notificationType;
	}

	public int getRelatedEntityId() {
		return relatedEntityId;
	}

	public void setRelatedEntityId(int relatedEntityId) {
		this.relatedEntityId = relatedEntityId;
	}

	public LocalDateTime getSendAt() {
		return sendAt;
	}

	public void setSendAt(LocalDateTime sendAt) {
		this.sendAt = sendAt;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SearchResultDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) to represent a single, generic search result.
 * This is used to combine results from different database tables (events,
 * storage, etc.) into a unified list for the API response.
 */
public class SearchResultDTO {
	private String type; // e.g., "Veranstaltung", "Lagerartikel", "Dokumentation"
	private String title;
	private String url;
	private String snippet;

	public SearchResultDTO(String type, String title, String url, String snippet) {
		this.type = type;
		this.title = title;
		this.url = url;
		this.snippet = snippet;
	}

	// Getters and Setters
	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public String getSnippet() {
		return snippet;
	}

	public void setSnippet(String snippet) {
		this.snippet = snippet;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;
	private String category;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "Vergriffen";
		}
		if (maxQuantity == 0) {
			return "Auf Lager";
		}
		if (available >= maxQuantity) {
			return "Vollständig";
		}
		if ((double) available / maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "status-danger";
		}
		if (maxQuantity > 0 && (double) available / maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getCategory() {
		return category;
	}

	public void setCategory(String category) {
		this.category = category;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoCategory.java
========================================================================

package de.technikteam.model;

import java.util.ArrayList;
import java.util.List;

public class TodoCategory {
	private int id;
	private String name;
	private int displayOrder;
	private List<TodoTask> tasks = new ArrayList<>();

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public List<TodoTask> getTasks() {
		return tasks;
	}

	public void setTasks(List<TodoTask> tasks) {
		this.tasks = tasks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoTask.java
========================================================================

package de.technikteam.model;

public class TodoTask {
	private int id;
	private int categoryId;
	private String content;
	private boolean isCompleted;
	private int displayOrder;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCompleted(boolean completed) {
		isCompleted = completed;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TrainingRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class TrainingRequest {
	private int id;
	private String topic;
	private int requesterUserId;
	private String requesterUsername; // Transient
	private LocalDateTime createdAt;
	private int interestCount; // Transient

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTopic() {
		return topic;
	}

	public void setTopic(String topic) {
		this.topic = topic;
	}

	public int getRequesterUserId() {
		return requesterUserId;
	}

	public void setRequesterUserId(int requesterUserId) {
		this.requesterUserId = requesterUserId;
	}

	public String getRequesterUsername() {
		return requesterUsername;
	}

	public void setRequesterUsername(String requesterUsername) {
		this.requesterUsername = requesterUsername;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getInterestCount() {
		return interestCount;
	}

	public void setInterestCount(int interestCount) {
		this.interestCount = interestCount;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;
	private String profileIconClass;
	private String adminNotes;
	private String dashboardLayout; // JSON string
	private String assignedEventRole; // Transient field for event details

	@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
	private String passwordHash;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	public boolean hasAdminAccess() {
		// With granular permissions removed, admin access is determined solely by role.
		return "ADMIN".equals(this.roleName);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getProfileIconClass() {
		return profileIconClass;
	}

	public void setProfileIconClass(String profileIconClass) {
		this.profileIconClass = profileIconClass;
	}

	public String getAdminNotes() {
		return adminNotes;
	}

	public void setAdminNotes(String adminNotes) {
		this.adminNotes = adminNotes;
	}

	public String getDashboardLayout() {
		return dashboardLayout;
	}

	public void setDashboardLayout(String dashboardLayout) {
		this.dashboardLayout = dashboardLayout;
	}

	public String getAssignedEventRole() {
		return assignedEventRole;
	}

	public void setAssignedEventRole(String assignedEventRole) {
		this.assignedEventRole = assignedEventRole;
	}

	public String getPasswordHash() {
		return passwordHash;
	}

	public void setPasswordHash(String passwordHash) {
		this.passwordHash = passwordHash;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Venue.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class Venue {
	private int id;
	private String name;
	private String address;
	private String notes;
	private String mapImagePath;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public String getMapImagePath() {
		return mapImagePath;
	}

	public void setMapImagePath(String mapImagePath) {
		this.mapImagePath = mapImagePath;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\WikiEntry.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single documentation entry from the `wiki_documentation` table.
 */
public class WikiEntry {
	private int id;
	private String filePath;
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilePath() {
		return filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\DevCsrfCookieFilter.java
========================================================================

package de.technikteam.security;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.Collection;

@Component
public class DevCsrfCookieFilter implements Filter {

	private final boolean isDev;

	public DevCsrfCookieFilter(Environment environment) {
		// Enable this filter only in 'dev' or no active profile
		String[] profiles = environment.getActiveProfiles();
		this.isDev = profiles.length == 0 || java.util.Arrays.asList(profiles).contains("dev");
	}

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		chain.doFilter(request, response);

		if (!isDev || !(response instanceof HttpServletResponse)) {
			return;
		}

		HttpServletResponse httpResp = (HttpServletResponse) response;
		Collection<String> headers = httpResp.getHeaders("Set-Cookie");

		boolean first = true;
		for (String header : headers) {
			if (header.startsWith("XSRF-TOKEN=") && header.contains("Secure")) {
				String modified = header.replace("; Secure", "");
				if (first) {
					httpResp.setHeader("Set-Cookie", modified);
					first = false;
				} else {
					httpResp.addHeader("Set-Cookie", modified);
				}
			}
		}
	}
}

========================================================================
FILE: src\main\java\de\technikteam\security\JwtAuthFilter.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.AuthService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

	private final AuthService authService;

	@Autowired
	public JwtAuthFilter(AuthService authService) {
		this.authService = authService;
	}

	@Override
	protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull FilterChain filterChain) throws ServletException, IOException {

		if (request.getCookies() == null) {
			filterChain.doFilter(request, response);
			return;
		}

		final String token = Arrays.stream(request.getCookies())
				.filter(cookie -> AuthService.AUTH_COOKIE_NAME.equals(cookie.getName())).map(Cookie::getValue)
				.findFirst().orElse(null);

		if (token == null) {
			filterChain.doFilter(request, response);
			return;
		}

		UserDetails userDetails = authService.validateTokenAndGetUser(token);

		if (userDetails != null && SecurityContextHolder.getContext().getAuthentication() == null) {
			UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null,
					userDetails.getAuthorities());
			authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
			SecurityContextHolder.getContext().setAuthentication(authToken);
		}

		filterChain.doFilter(request, response);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\RateLimitingInterceptor.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.RateLimitingService;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.concurrent.TimeUnit;

@Component
public class RateLimitingInterceptor implements HandlerInterceptor {

	private final RateLimitingService rateLimitingService;

	@Autowired
	public RateLimitingInterceptor(RateLimitingService rateLimitingService) {
		this.rateLimitingService = rateLimitingService;
	}

	@Override
	public boolean preHandle(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull Object handler) throws Exception {
		String ipAddress = getClientIp(request);
		Bucket bucket = rateLimitingService.resolveBucket(ipAddress);
		ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

		if (probe.isConsumed()) {
			response.addHeader("X-Rate-Limit-Remaining", String.valueOf(probe.getRemainingTokens()));
			return true;
		} else {
			long waitForRefill = TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill());
			response.addHeader("X-Rate-Limit-Retry-After-Seconds", String.valueOf(waitForRefill));
			response.sendError(HttpStatus.TOO_MANY_REQUESTS.value(),
					"Sie haben Ihr API-Anfragekontingent ausgeschöpft. Bitte versuchen Sie es später erneut.");
			return false;
		}
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityConfig.java
========================================================================

package de.technikteam.security;

import de.technikteam.dao.UserDAO;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig {

	private final JwtAuthFilter jwtAuthFilter;
	private final UserDAO userDAO;

	public SecurityConfig(JwtAuthFilter jwtAuthFilter, UserDAO userDAO) {
		this.jwtAuthFilter = jwtAuthFilter;
		this.userDAO = userDAO;
	}

	@Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(
                    "/api/v1/auth/**",
                    "/api/v1/public/**", // alle public-Endpoints
                    "/api/v1/admin/notifications/sse", // SSE vorerst offen
                    "/ws/**", // WS-Verbindungen offen
                    "/swagger-ui.html", "/swagger-ui/**", "/v3/api-docs/**"
                ).permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

	@Bean
	public UserDetailsService userDetailsService() {
		return username -> {
			de.technikteam.model.User user = userDAO.getUserByUsername(username);
			if (user == null) {
				throw new UsernameNotFoundException("User not found: " + username);
			}
			return new SecurityUser(user);
		};
	}
	
	@Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityUser.java
========================================================================

package de.technikteam.security;

import de.technikteam.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serializable;
import java.util.Collection;
import java.util.stream.Collectors;

public class SecurityUser implements UserDetails, Serializable {

	private static final long serialVersionUID = 1L;
	private final User user;

	public SecurityUser(User user) {
		this.user = user;
	}

	public User getUser() {
		return user;
	}

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		// Convert the user's permission strings into Spring Security GrantedAuthority
		// objects.
		return user.getPermissions().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());
	}

	@Override
	public String getPassword() {
		return user.getPasswordHash();
	}

	@Override
	public String getUsername() {
		return user.getUsername();
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);

	private final AchievementDAO achievementDAO;
	private final EventDAO eventDAO;

	@Autowired
	public AchievementService(AchievementDAO achievementDAO, EventDAO eventDAO) {
		this.achievementDAO = achievementDAO;
		this.eventDAO = eventDAO;
	}

	@Transactional
	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// Placeholder for future implementation
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminDashboardService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.ReportDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.DashboardDataDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminDashboardService {
	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final AdminLogDAO adminLogDAO;
	private final ReportDAO reportDAO;

	private static final int WIDGET_LIMIT = 5;
	private static final int TREND_MONTHS = 12;

	@Autowired
	public AdminDashboardService(EventDAO eventDAO, StorageDAO storageDAO, AdminLogDAO adminLogDAO,
			ReportDAO reportDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.adminLogDAO = adminLogDAO;
		this.reportDAO = reportDAO;
	}

	public DashboardDataDTO getDashboardData() {
		DashboardDataDTO dto = new DashboardDataDTO();
		dto.setUpcomingEvents(eventDAO.getUpcomingEvents(WIDGET_LIMIT));
		dto.setLowStockItems(storageDAO.getLowStockItems(WIDGET_LIMIT));
		dto.setRecentLogs(adminLogDAO.getRecentLogs(WIDGET_LIMIT));
		dto.setEventTrendData(reportDAO.getEventCountByMonth(TREND_MONTHS));
		return dto;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private final AdminLogDAO logDAO;

	@Autowired
	public AdminLogService(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	private String sanitize(String input) {
		if (input == null) {
			return "";
		}
		// Replace newlines and carriage returns to prevent log injection
		return input.replace('\n', '_').replace('\r', '_');
	}

	public void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);
			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);
			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error(
					"KRITISCH: Fehler beim Schreiben in das Admin-Audit-Log! Daten: [Benutzer: {}, Aktion: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AnnouncementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AnnouncementDAO;
import de.technikteam.model.Announcement;
import de.technikteam.model.User;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class AnnouncementService {

	private final AnnouncementDAO announcementDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public AnnouncementService(AnnouncementDAO announcementDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.announcementDAO = announcementDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	public List<Announcement> findAll() {
		return announcementDAO.findAll();
	}

	@Transactional
	public Announcement create(Announcement announcement, User author) {
		announcement.setAuthorUserId(author.getId());
		announcement.setTitle(richTextPolicy.sanitize(announcement.getTitle()));
		announcement.setContent(richTextPolicy.sanitize(announcement.getContent()));

		Announcement created = announcementDAO.create(announcement);
		adminLogService.log(author.getUsername(), "ANNOUNCEMENT_CREATE", "Created announcement: " + created.getTitle());
		return created;
	}

	@Transactional
	public Announcement update(Announcement announcement, User editor) {
		Optional<Announcement> existingOpt = announcementDAO.findById(announcement.getId());
		if (existingOpt.isPresent()) {
			Announcement existing = existingOpt.get();
			existing.setTitle(richTextPolicy.sanitize(announcement.getTitle()));
			existing.setContent(richTextPolicy.sanitize(announcement.getContent()));
			Announcement updated = announcementDAO.update(existing);
			adminLogService.log(editor.getUsername(), "ANNOUNCEMENT_UPDATE",
					"Updated announcement: " + updated.getTitle());
			return updated;
		}
		return null;
	}

	@Transactional
	public boolean delete(int id, User adminUser) {
		Optional<Announcement> announcementOpt = announcementDAO.findById(id);
		if (announcementOpt.isPresent()) {
			boolean success = announcementDAO.delete(id);
			if (success) {
				adminLogService.log(adminUser.getUsername(), "ANNOUNCEMENT_DELETE",
						"Deleted announcement: " + announcementOpt.get().getTitle() + " (ID: " + id + ")");
			}
			return success;
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AuthService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;

@Service
public class AuthService {
	private static final Logger logger = LogManager.getLogger(AuthService.class);
	private static final String JWT_ISSUER = "TechnikTeamApp";
	public static final String AUTH_COOKIE_NAME = "TT_AUTH_TOKEN";
	private static final int COOKIE_MAX_AGE_SECONDS = 8 * 60 * 60; // 8 hours

	private final SecretKey secretKey;
	private final UserDAO userDAO;

	@Autowired
	public AuthService(UserDAO userDAO, ConfigurationService configService) {
		this.userDAO = userDAO;
		// TODO: SECURITY-AUDIT-FIX (CWE-547)
		// Loading secrets from properties files committed to version control is
		// insecure.
		// REMEDIATION: Refactor to read the JWT secret from an environment variable
		// (e.g., System.getenv("JWT_SECRET")) or a dedicated secrets management
		// service.
		String secret = configService.getProperty("jwt.secret");
		if (secret == null || secret.isBlank() || secret.length() < 32) {
			logger.fatal(
					"JWT-Secret ist nicht konfiguriert oder zu kurz (muss mindestens 32 Zeichen lang sein). Die Anwendung kann nicht sicher gestartet werden.");
			throw new RuntimeException("JWT-Secret ist nicht konfiguriert oder unsicher.");
		}
		this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
	}

	public String generateToken(User user) {
		Instant now = Instant.now();
		Instant expiry = now.plus(COOKIE_MAX_AGE_SECONDS, ChronoUnit.SECONDS);

		return Jwts.builder().issuer(JWT_ISSUER).subject(String.valueOf(user.getId())).issuedAt(Date.from(now))
				.expiration(Date.from(expiry)).signWith(secretKey).compact();
	}

	public void addJwtCookie(User user, HttpServletResponse response) {
		String token = generateToken(user);
		String header = String.format("%s=%s; Path=/; Max-Age=%d; HttpOnly; Secure; SameSite=Strict", AUTH_COOKIE_NAME,
				token, COOKIE_MAX_AGE_SECONDS);
		response.addHeader(HttpHeaders.SET_COOKIE, header);
	}

	public void clearJwtCookie(HttpServletResponse response) {
		// Construct a Set-Cookie header that expires the cookie immediately.
		// It's crucial to include the same attributes (Path, HttpOnly, Secure,
		// SameSite) as
		// the original cookie to ensure the browser overwrites it correctly.
		String header = String.format("%s=; Path=/; Max-Age=0; HttpOnly; Secure; SameSite=Strict", AUTH_COOKIE_NAME);
		response.addHeader(HttpHeaders.SET_COOKIE, header);
	}

	public UserDetails validateTokenAndGetUser(String token) {
		try {
			Claims claims = Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload();

			int userId = Integer.parseInt(claims.getSubject());
			User user = userDAO.getUserById(userId);

			if (user == null) {
				logger.warn("JWT-Validierung erfolgreich, aber Benutzer mit ID {} existiert nicht mehr.", userId);
				return null;
			}
			return new SecurityUser(user);
		} catch (Exception e) {
			logger.warn("JWT-Verifizierung fehlgeschlagen: {}", e.getMessage());
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ChangelogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.ChangelogDAO;
import de.technikteam.model.Changelog;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class ChangelogService {

	private final ChangelogDAO changelogDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public ChangelogService(ChangelogDAO changelogDAO, AdminLogService adminLogService) {
		this.changelogDAO = changelogDAO;
		this.adminLogService = adminLogService;
	}

	public List<Changelog> findAll() {
		return changelogDAO.findAll();
	}

	@Transactional
	public boolean create(Changelog changelog, User adminUser) {
		boolean success = changelogDAO.create(changelog);
		if (success) {
			adminLogService.log(adminUser.getUsername(), "CHANGELOG_CREATE",
					"Created changelog for version: " + changelog.getVersion());
		}
		return success;
	}

	@Transactional
	public boolean update(Changelog changelog, User adminUser) {
		boolean success = changelogDAO.update(changelog);
		if (success) {
			adminLogService.log(adminUser.getUsername(), "CHANGELOG_UPDATE",
					"Updated changelog for version: " + changelog.getVersion());
		}
		return success;
	}

	@Transactional
	public boolean delete(int id, User adminUser) {
		Optional<Changelog> changelogOpt = changelogDAO.findById(id);
		if (changelogOpt.isPresent()) {
			boolean success = changelogDAO.delete(id);
			if (success) {
				adminLogService.log(adminUser.getUsername(), "CHANGELOG_DELETE",
						"Deleted changelog for version: " + changelogOpt.get().getVersion() + " (ID: " + id + ")");
			}
			return success;
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ConfigurationService.java
========================================================================

package de.technikteam.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConfigurationService {
	private static final Logger logger = LogManager.getLogger(ConfigurationService.class);

	@Value("${server.servlet.context-path:#{''}}")
	private String contextPath;

	@Value("${spring.datasource.url}")
	private String dbUrl;

	@Value("${spring.datasource.username}")
	private String dbUser;

	@Value("${spring.datasource.password}")
	private String dbPassword;

	@Value("${jwt.secret}")
	private String jwtSecret;

	@Value("${upload.directory}")
	private String uploadDirectory;

	public String getProperty(String key) {
		switch (key) {
		case "context.path":
			return contextPath;
		case "db.url":
			return dbUrl;
		case "db.user":
			return dbUser;
		case "db.password":
			return dbPassword;
		case "jwt.secret":
			return jwtSecret;
		case "upload.directory":
			return uploadDirectory;
		default:
			logger.warn("Attempted to access unknown property key: {}", key);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventDebriefingService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.EventDebriefingDTO;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventDebriefingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventDebriefing;
import de.technikteam.model.User;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class EventDebriefingService {

	private final EventDebriefingDAO debriefingDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final PolicyFactory richTextPolicy;
	private final Gson gson = new Gson();

	@Autowired
	public EventDebriefingService(EventDebriefingDAO debriefingDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.debriefingDAO = debriefingDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public EventDebriefing saveDebriefing(int eventId, EventDebriefingDTO dto, User author) {
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			throw new IllegalArgumentException("Event not found.");
		}
		if (!"ABGESCHLOSSEN".equals(event.getStatus())) {
			throw new IllegalStateException("Debriefings can only be submitted for completed events.");
		}

		EventDebriefing debriefing = debriefingDAO.findByEventId(eventId).orElse(new EventDebriefing());
		debriefing.setEventId(eventId);
		debriefing.setAuthorUserId(author.getId());
		debriefing.setWhatWentWell(richTextPolicy.sanitize(dto.whatWentWell()));
		debriefing.setWhatToImprove(richTextPolicy.sanitize(dto.whatToImprove()));
		debriefing.setEquipmentNotes(richTextPolicy.sanitize(dto.equipmentNotes()));
		debriefing.setStandoutCrewMembers(gson.toJson(dto.standoutCrewMemberIds()));

		EventDebriefing savedDebriefing = debriefingDAO.save(debriefing);
		adminLogService.log(author.getUsername(), "SUBMIT_DEBRIEFING",
				"Debriefing for event '" + event.getName() + "' submitted/updated.");

		// Placeholder for achievement logic based on being a "standout crew member"
		// for (Integer userId : dto.standoutCrewMemberIds()) { ... }

		// Notify admins with permission that a new debriefing is available
		List<Integer> adminIds = userDAO.findUserIdsByPermission(Permissions.EVENT_DEBRIEFING_VIEW);
		String title = "Neues Event-Debriefing";
		String description = String.format("Ein Debriefing für das Event '%s' wurde von %s eingereicht.",
				event.getName(), author.getUsername());
		for (Integer adminId : adminIds) {
			if (adminId != author.getId()) { // Don't notify the author
				Map<String, Object> payload = Map.of("title", title, "description", description, "level",
						"Informational", "url", "/admin/debriefings");
				notificationService.sendNotificationToUser(adminId, payload);
			}
		}
		return enrichDebriefing(savedDebriefing);
	}

	public EventDebriefing enrichDebriefing(EventDebriefing debriefing) {
		if (debriefing == null)
			return null;
		if (debriefing.getStandoutCrewMembers() != null && !debriefing.getStandoutCrewMembers().isBlank()) {
			List<Integer> userIds = gson.fromJson(debriefing.getStandoutCrewMembers(), List.class);
			List<User> userDetails = userIds.stream().map(id -> userDAO.getUserById(id.intValue()))
					.filter(java.util.Objects::nonNull).collect(Collectors.toList());
			debriefing.setStandoutCrewDetails(userDetails);
		}
		return debriefing;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventGalleryService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventPhotoDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventPhoto;
import de.technikteam.model.File;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

@Service
public class EventGalleryService {

	private final EventPhotoDAO eventPhotoDAO;
	private final EventDAO eventDAO;
	private final FileService fileService;

	@Autowired
	public EventGalleryService(EventPhotoDAO eventPhotoDAO, EventDAO eventDAO, FileService fileService) {
		this.eventPhotoDAO = eventPhotoDAO;
		this.eventDAO = eventDAO;
		this.fileService = fileService;
	}

	public List<EventPhoto> findPhotosByEventId(int eventId) {
		return eventPhotoDAO.findByEventId(eventId);
	}

	@Transactional
	public EventPhoto addPhotoToGallery(int eventId, MultipartFile multipartFile, String caption, User uploader)
			throws IOException {
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			throw new IllegalArgumentException("Event not found.");
		}
		if (!"ABGESCHLOSSEN".equals(event.getStatus())) {
			throw new SecurityException("Photos can only be added to completed events.");
		}
		if (!eventDAO.isUserAssociatedWithEvent(eventId, uploader.getId())) {
			throw new SecurityException("Only event participants can upload photos.");
		}

		// Store the file using FileService
		File savedFile = fileService.storeFile(multipartFile, null, "NUTZER", uploader, "event_galleries/" + eventId);

		// Create the gallery record
		EventPhoto photo = new EventPhoto();
		photo.setEventId(eventId);
		photo.setFileId(savedFile.getId());
		photo.setUploaderUserId(uploader.getId());
		photo.setCaption(caption);

		EventPhoto createdPhoto = eventPhotoDAO.create(photo);
		// Enrich with data for immediate frontend display
		createdPhoto.setFilepath(savedFile.getFilepath());
		createdPhoto.setUploaderUsername(uploader.getUsername());
		return createdPhoto;
	}

	@Transactional
	public void deletePhoto(int photoId, User currentUser) throws IOException {
		EventPhoto photo = eventPhotoDAO.findById(photoId)
				.orElseThrow(() -> new IllegalArgumentException("Photo not found."));

		Event event = eventDAO.getEventById(photo.getEventId());
		boolean isEventLeader = event != null && event.getLeaderUserId() == currentUser.getId();

		// Authorization check: User can delete their own photo, or an admin/event
		// leader can delete any.
		if (photo.getUploaderUserId() != currentUser.getId() && !currentUser.hasAdminAccess() && !isEventLeader) {
			throw new SecurityException("You do not have permission to delete this photo.");
		}

		// Delete the database record first
		eventPhotoDAO.delete(photoId);

		// Then delete the physical file
		fileService.deleteFile(photo.getFileId(), currentUser);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import de.technikteam.dao.*;
import de.technikteam.model.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class EventService {
	private static final Logger logger = LogManager.getLogger(EventService.class);

	private final EventDAO eventDAO;
	private final EventTaskDAO taskDAO;
	private final MeetingDAO meetingDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final ChecklistDAO checklistDAO;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ScheduledNotificationDAO scheduledNotificationDAO;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public EventService(EventDAO eventDAO, EventTaskDAO taskDAO, MeetingDAO meetingDAO, AttachmentDAO attachmentDAO,
			EventCustomFieldDAO customFieldDAO, ChecklistDAO checklistDAO, ConfigurationService configService,
			AdminLogService adminLogService, NotificationService notificationService,
			ScheduledNotificationDAO scheduledNotificationDAO,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.eventDAO = eventDAO;
		this.taskDAO = taskDAO;
		this.meetingDAO = meetingDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.checklistDAO = checklistDAO;
		this.configService = configService;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.scheduledNotificationDAO = scheduledNotificationDAO;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public int createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, String[] requiredCourseIds,
			String[] requiredPersons, String[] itemIds, String[] quantities, List<EventCustomField> customFields,
			MultipartFile file, String requiredRole, int reminderMinutes) throws SQLException, IOException {

		// Sanitize HTML content before saving
		if (event.getDescription() != null) {
			String sanitizedDescription = richTextPolicy.sanitize(event.getDescription());
			event.setDescription(sanitizedDescription);
		}

		int eventId;
		if (isUpdate) {
			eventDAO.updateEvent(event);
			eventId = event.getId();
			adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
		} else {
			eventId = eventDAO.createEvent(event);
			event.setId(eventId);
			adminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
		}

		eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);
		eventDAO.saveReservations(eventId, itemIds, quantities);
		checklistDAO.generateChecklistFromReservations(eventId); // Generate/update checklist
		if (customFields != null) {
			customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
		}

		if (file != null && !file.isEmpty()) {
			handleAttachmentUpload(file, eventId, requiredRole, adminUser);
		}

		// Handle scheduled reminder
		List<Integer> participantIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
				.collect(Collectors.toList());
		LocalDateTime sendAt = reminderMinutes > 0 ? event.getEventDateTime().minusMinutes(reminderMinutes) : null;
		if (sendAt != null && sendAt.isAfter(LocalDateTime.now())) {
			scheduledNotificationDAO.createOrUpdateReminder("EVENT_REMINDER", eventId, participantIds, sendAt,
					"Erinnerung: " + event.getName(), "Diese Veranstaltung beginnt bald.",
					"/veranstaltungen/details/" + eventId);
		} else {
			// Delete existing reminder if it's no longer needed
			scheduledNotificationDAO.deleteReminders("EVENT_REMINDER", eventId);
		}

		logger.info("Transaction for event ID {} committed successfully.", eventId);
		return eventId;
	}

	public void assignUsersToEventAndNotify(int eventId, String[] userIds, User adminUser) {
		eventDAO.assignUsersToEvent(eventId, userIds);
		Event event = eventDAO.getEventById(eventId);
		String logDetails = String.format("Benutzer %s zu Event '%s' zugewiesen.", Arrays.toString(userIds),
				event.getName());
		adminLogService.log(adminUser.getUsername(), "ASSIGN_USERS_EVENT", logDetails);

		for (String userIdStr : userIds) {
			int userId = Integer.parseInt(userIdStr);
			String notificationMessage = String.format("Du wurdest zum Event '%s' zugewiesen.", event.getName());
			Map<String, Object> payload = Map.of("type", "assignment", "title", "Neue Zuweisung", "description",
					notificationMessage, "level", "Important", "url", "/veranstaltungen/details/" + eventId);
			notificationService.sendNotificationToUser(userId, payload);
		}
	}

	public void signOffUserFromRunningEvent(int userId, String username, int eventId, String reason) {
		eventDAO.signOffFromEvent(userId, eventId);
		Event event = eventDAO.getEventById(eventId);
		if (event != null && event.getLeaderUserId() > 0) {
			String notificationMessage = String.format("%s hat sich vom laufenden Event '%s' abgemeldet. Grund: %s",
					username, event.getName(), reason);

			Map<String, Object> payload = Map.of("type", "alert", "payload",
					Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + eventId));

			notificationService.sendNotificationToUser(event.getLeaderUserId(), payload);
			logger.info("Sent sign-off notification to event leader (ID: {}) for event '{}'", event.getLeaderUserId(),
					event.getName());
		}
	}

	@Transactional
	public Event cloneEvent(int originalEventId, User adminUser) {
		Event originalEvent = eventDAO.getEventById(originalEventId);
		if (originalEvent == null) {
			throw new IllegalArgumentException("Original event not found.");
		}

		// Create a copy with a new name and future date
		Event clonedEvent = new Event();
		clonedEvent.setName(originalEvent.getName() + " (Kopie)");
		clonedEvent.setDescription(originalEvent.getDescription());
		clonedEvent.setLocation(originalEvent.getLocation());
		clonedEvent.setLeaderUserId(originalEvent.getLeaderUserId());
		clonedEvent.setEventDateTime(LocalDateTime.now().plus(7, ChronoUnit.DAYS).withHour(18).withMinute(0));

		int newEventId = eventDAO.createEvent(clonedEvent);
		clonedEvent.setId(newEventId);

		// Copy skill requirements
		List<SkillRequirement> skills = eventDAO.getSkillRequirementsForEvent(originalEventId);
		String[] courseIds = skills.stream().map(s -> String.valueOf(s.getRequiredCourseId())).toArray(String[]::new);
		String[] persons = skills.stream().map(s -> String.valueOf(s.getRequiredPersons())).toArray(String[]::new);
		eventDAO.saveSkillRequirements(newEventId, courseIds, persons);

		// Copy item reservations
		List<StorageItem> items = eventDAO.getReservedItemsForEvent(originalEventId);
		String[] itemIds = items.stream().map(i -> String.valueOf(i.getId())).toArray(String[]::new);
		String[] quantities = items.stream().map(i -> String.valueOf(i.getQuantity())).toArray(String[]::new);
		eventDAO.saveReservations(newEventId, itemIds, quantities);
		checklistDAO.generateChecklistFromReservations(newEventId);

		// Copy tasks (without assignments)
		List<EventTask> tasks = taskDAO.getTasksForEvent(originalEventId);
		for (EventTask task : tasks) {
			task.setEventId(newEventId);
			task.setStatus("OFFEN");
			taskDAO.saveTask(task, new int[0], new String[0], new String[0], new String[0], new int[0]);
		}

		adminLogService.log(adminUser.getUsername(), "CLONE_EVENT", "Event '" + originalEvent.getName() + "' (ID: "
				+ originalEventId + ") zu '" + clonedEvent.getName() + "' (ID: " + newEventId + ") geklont.");

		return clonedEvent;
	}

	@Transactional
	public Meeting cloneMeeting(int originalMeetingId, User adminUser) {
		Meeting originalMeeting = meetingDAO.getMeetingById(originalMeetingId);
		if (originalMeeting == null) {
			throw new IllegalArgumentException("Original meeting not found.");
		}

		Meeting clonedMeeting = new Meeting();
		clonedMeeting.setCourseId(originalMeeting.getCourseId());
		clonedMeeting.setName(originalMeeting.getName() + " (Kopie)");
		clonedMeeting.setDescription(originalMeeting.getDescription());
		clonedMeeting.setLocation(originalMeeting.getLocation());
		clonedMeeting.setLeaderUserId(originalMeeting.getLeaderUserId());
		clonedMeeting.setMeetingDateTime(LocalDateTime.now().plus(7, ChronoUnit.DAYS).withHour(19).withMinute(0));

		int newMeetingId = meetingDAO.createMeeting(clonedMeeting);
		clonedMeeting.setId(newMeetingId);

		adminLogService.log(adminUser.getUsername(), "CLONE_MEETING",
				"Meeting '" + originalMeeting.getName() + "' (ID: " + originalMeetingId + ") zu '"
						+ clonedMeeting.getName() + "' (ID: " + newMeetingId + ") geklont.");

		return clonedMeeting;
	}

	private void handleAttachmentUpload(MultipartFile file, int eventId, String requiredRole, User adminUser)
			throws IOException {
		String uploadDir = configService.getProperty("upload.directory");
		String originalFileName = Paths.get(file.getOriginalFilename()).getFileName().toString();
		String uniqueFileName = UUID.randomUUID() + "-" + originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");

		Path targetPath = Paths.get(uploadDir, "events", uniqueFileName);
		Files.createDirectories(targetPath.getParent());
		Files.copy(file.getInputStream(), targetPath);

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(originalFileName);
		attachment.setFilepath("events/" + uniqueFileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			adminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + originalFileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Fehler beim Speichern des Anhangs in der Datenbank.");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventTaskService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Service
public class EventTaskService {

	private final EventTaskDAO taskDAO;
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final NotificationService notificationService;
	private final PolicyFactory richTextPolicy;
	private static final Logger logger = LogManager.getLogger(EventTaskService.class);

	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	@Autowired
	public EventTaskService(EventTaskDAO taskDAO, UserDAO userDAO, EventDAO eventDAO,
			NotificationService notificationService, @Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.taskDAO = taskDAO;
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.notificationService = notificationService;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public int saveTaskAndHandleMentions(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities,
			String[] kitIds, int[] dependencyIds, User currentUser) {

		logger.debug("Service: Saving task '{}'", task.getDescription());
		if (task.getDetails() != null) {
			String sanitizedDetails = richTextPolicy.sanitize(task.getDetails());
			logger.trace("Sanitized task details from '{}' to '{}'", task.getDetails(), sanitizedDetails);
			task.setDetails(sanitizedDetails);
		}

		String originalDetails = "";
		if (task.getId() > 0) {
			// This is not perfectly efficient, but good enough for this purpose.
			// A better solution would be to get the task from a service layer cache.
			EventTask existingTask = taskDAO.getTasksForEvent(task.getEventId()).stream()
					.filter(t -> t.getId() == task.getId()).findFirst().orElse(null);
			if (existingTask != null) {
				originalDetails = existingTask.getDetails();
			}
		}

		logger.debug("Calling DAO to save task. Is update: {}", (task.getId() > 0));
		int taskId = taskDAO.saveTask(task, userIds != null ? userIds : new int[0], itemIds, itemQuantities, kitIds,
				dependencyIds);
		task.setId(taskId); // Ensure the task object has the ID for mention handling
		logger.debug("DAO returned task ID: {}", taskId);

		// Handle mentions only if the details have changed
		if (task.getDetails() != null && !task.getDetails().equals(originalDetails)) {
			handleMentions(currentUser, task);
		}

		// Notify newly assigned users
		if (userIds != null) {
			notifyAssignedUsers(task, userIds, currentUser);
		}

		// Broadcast a general UI update to all clients to indicate that the event data
		// has changed.
		notificationService.broadcastUIUpdate("EVENT_UPDATED", Map.of("eventId", task.getEventId()));
		logger.debug("Broadcasted EVENT_UPDATED notification for eventId: {}", task.getEventId());

		return taskId;
	}

	private void notifyAssignedUsers(EventTask task, int[] assignedUserIds, User currentUser) {
		Event event = eventDAO.getEventById(task.getEventId());
		if (event == null) {
			logger.warn("Cannot notify assigned users for task {} because parent event {} was not found.", task.getId(),
					task.getEventId());
			return;
		}

		for (int userId : assignedUserIds) {
			if (userId != currentUser.getId()) {
				String title = String.format("Neue Aufgabe in '%s'", event.getName());
				String description = String.format("%s hat Ihnen die Aufgabe '%s' zugewiesen.",
						currentUser.getUsername(), task.getDescription());
				Map<String, Object> payload = Map.of("title", title, "description", description, "level",
						"Informational", "url", "/veranstaltungen/details/" + event.getId());
				notificationService.sendNotificationToUser(userId, payload);
			}
		}
	}

	private void handleMentions(User currentUser, EventTask task) {
		Event event = eventDAO.getEventById(task.getEventId());
		if (event == null || task.getDetails() == null) {
			if (event == null)
				logger.warn("Cannot handle mentions for task {} because parent event {} was not found.", task.getId(),
						task.getEventId());
			return;
		}

		Set<String> mentionedUsernames = new HashSet<>();
		Matcher matcher = MENTION_PATTERN.matcher(task.getDetails());
		while (matcher.find()) {
			mentionedUsernames.add(matcher.group(1));
		}

		if (!mentionedUsernames.isEmpty()) {
			logger.debug("Found mentions for users: {}", mentionedUsernames);
		}

		for (String username : mentionedUsernames) {
			User mentionedUser = userDAO.getUserByUsername(username);
			if (mentionedUser != null && mentionedUser.getId() != currentUser.getId()) {
				String title = String.format("Erwähnung in Aufgabe für '%s'", event.getName());
				String description = String.format("%s hat Sie in der Aufgabe '%s' erwähnt.", currentUser.getUsername(),
						task.getDescription());

				Map<String, Object> payload = Map.of("title", title, "description", description, "level",
						"Informational", "url", "/veranstaltungen/details/" + event.getId());
				notificationService.sendNotificationToUser(mentionedUser.getId(), payload);
			}
		}
	}

	@Transactional
	public void performUserTaskAction(int eventId, int taskId, String action, String newStatus, User currentUser) {
		Event event = eventDAO.getEventById(eventId);
		if (event == null)
			throw new IllegalArgumentException("Event not found.");

		EventTask task = event.getEventTasks().stream().filter(t -> t.getId() == taskId).findFirst()
				.orElseThrow(() -> new IllegalArgumentException("Task not found."));

		boolean isAssigned = task.getAssignedUsers().stream().anyMatch(u -> u.getId() == currentUser.getId());
		boolean isParticipant = eventDAO.isUserAssociatedWithEvent(eventId, currentUser.getId());
		boolean canManage = currentUser.hasAdminAccess() || event.getLeaderUserId() == currentUser.getId();

		switch (action) {
		case "updateStatus":
			if (!canManage && !isAssigned) {
				throw new SecurityException("You are not authorized to update the status of this task.");
			}
			if (newStatus == null || !List.of("OFFEN", "IN_ARBEIT", "ERLEDIGT").contains(newStatus)) {
				throw new IllegalArgumentException("Invalid status provided.");
			}
			taskDAO.updateTaskStatus(taskId, newStatus);
			break;

		case "claim":
			if (!task.getAssignedUsers().isEmpty()) {
				throw new IllegalStateException("Task is already assigned.");
			}
			if (!isParticipant) {
				throw new SecurityException("You must be a participant of the event to claim tasks.");
			}
			taskDAO.assignUserToTask(taskId, currentUser.getId());
			break;

		case "unclaim":
			if (!isAssigned) {
				throw new SecurityException("You can only un-claim tasks assigned to you.");
			}
			taskDAO.unassignUserFromTask(taskId, currentUser.getId());
			break;

		default:
			throw new IllegalArgumentException("Invalid action: " + action);
		}

		notificationService.broadcastUIUpdate("EVENT_UPDATED", Map.of("eventId", eventId));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\FileService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
public class FileService {

	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;
	private final Path fileStorageLocation;
	private static final Logger logger = LogManager.getLogger(FileService.class);

	private static final long MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10 MB

	@Autowired
	public FileService(FileDAO fileDAO, ConfigurationService configService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser) throws IOException {
		return storeFile(multipartFile, categoryId, requiredRole, adminUser, "docs");
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser, String subDirectory) throws IOException {
		logger.debug("Starting file storage process. User: {}, CategoryID: {}, Role: {}, SubDir: {}",
				adminUser.getUsername(), categoryId, requiredRole, subDirectory);

		// Security Validations
		if (multipartFile.getSize() > MAX_FILE_SIZE_BYTES) {
			logger.warn("File upload blocked for user {}: File size {} exceeds limit of {} bytes.",
					adminUser.getUsername(), multipartFile.getSize(), MAX_FILE_SIZE_BYTES);
			throw new IOException("Dateigröße überschreitet das Limit von 10MB.");
		}
		logger.trace("File size check passed: {} bytes.", multipartFile.getSize());

		FileSignatureValidator.FileTypeValidationResult validationResult = FileSignatureValidator
				.validateFileType(multipartFile);
		if (validationResult == FileSignatureValidator.FileTypeValidationResult.DISALLOWED) {
			logger.warn("File upload blocked for user {}: Invalid or disallowed file type detected. MIME: {}",
					adminUser.getUsername(), multipartFile.getContentType());
			throw new IOException("Ungültiger oder nicht erlaubter Dateityp erkannt.");
		}
		boolean needsWarning = validationResult == FileSignatureValidator.FileTypeValidationResult.ALLOWED_WITH_WARNING;
		logger.trace("File signature validation passed. Needs warning: {}", needsWarning);

		String originalFileName = FilenameUtils.getName(multipartFile.getOriginalFilename());
		String sanitizedFileName = originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");
		String uniqueFileName = UUID.randomUUID() + "-" + sanitizedFileName;
		logger.trace("Original filename: '{}', Sanitized and unique filename: '{}'", originalFileName, uniqueFileName);

		Path targetDirectory = this.fileStorageLocation.resolve(subDirectory);
		Path targetPath = targetDirectory.resolve(uniqueFileName);
		Files.createDirectories(targetDirectory);
		Files.copy(multipartFile.getInputStream(), targetPath);
		logger.debug("File successfully copied to physical path: {}", targetPath);

		de.technikteam.model.File file = new de.technikteam.model.File();
		file.setFilename(originalFileName);
		file.setFilepath(subDirectory + "/" + uniqueFileName);
		file.setCategoryId(categoryId);
		file.setRequiredRole(requiredRole);
		file.setNeedsWarning(needsWarning);

		logger.debug("Prepared file model for database insertion: {}", file);

		int newFileId = fileDAO.createFile(file);
		if (newFileId > 0) {
			adminLogService.log(adminUser.getUsername(), "UPLOAD_FILE",
					"Datei '" + originalFileName + "' hochgeladen.");
			de.technikteam.model.File savedFile = fileDAO.getFileById(newFileId);
			logger.info("File '{}' successfully stored and saved to database with ID {}.", originalFileName, newFileId);
			logger.debug("Final saved file data from DB: {}", savedFile);
			return savedFile;
		} else {
			Files.deleteIfExists(targetPath);
			logger.error("Failed to save file metadata to database for '{}'. Physical file has been rolled back.",
					originalFileName);
			throw new RuntimeException("Fehler beim Speichern der Datei-Metadaten in der Datenbank.");
		}
	}

	public boolean deleteFile(int fileId, User adminUser) throws IOException {
		de.technikteam.model.File file = fileDAO.getFileById(fileId);
		if (file == null) {
			return false;
		}

		boolean success = fileDAO.deleteFile(fileId);
		if (success) {
			Path filePath = this.fileStorageLocation.resolve(file.getFilepath()).normalize();
			Files.deleteIfExists(filePath);
			adminLogService.log(adminUser.getUsername(), "DELETE_FILE",
					"Datei '" + file.getFilename() + "' (ID: " + fileId + ") gelöscht.");
		}
		return success;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\LoginAttemptService.java
========================================================================

package de.technikteam.service;

// TODO: SECURITY-AUDIT-FIX (CWE-307)
// The current lockout mechanism is based solely on username, which makes it vulnerable
// to targeted Denial of Service attacks where an attacker can lock out any known user.
// REMEDIATION: This service should be refactored to be primarily IP-based.
// 1. A database migration is required to change the login_attempts table to track failures by IP address.
// 2. The logic in isLockedOut() and recordFailedLogin() must be updated to use the client's IP address
//    as the key for tracking and enforcing lockouts.

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.LocalDateTime;

@Service
public class LoginAttemptService {
	private static final Logger logger = LogManager.getLogger(LoginAttemptService.class);
	private static final int MAX_ATTEMPTS = 5;
	private static final int LOCKOUT_MINUTES = 30;

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public LoginAttemptService(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean isLockedOut(String username, String ipAddress) {
		String sql = "SELECT last_attempt, attempts FROM login_attempts WHERE username = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				LocalDateTime lastAttempt = rs.getTimestamp("last_attempt").toLocalDateTime();
				int attempts = rs.getInt("attempts");
				if (attempts >= MAX_ATTEMPTS
						&& lastAttempt.isAfter(LocalDateTime.now().minusMinutes(LOCKOUT_MINUTES))) {
					return true;
				}
				// If lockout period expired, clear attempts and allow login
				clearLoginAttempts(username);
				return false;
			}, username);
		} catch (Exception e) {
			return false; // No record means not locked out
		}
	}

	public void recordFailedLogin(String username, String ipAddress) {
		String sql = "INSERT INTO login_attempts (username, attempts, last_attempt) VALUES (?, 1, ?) "
				+ "ON DUPLICATE KEY UPDATE attempts = attempts + 1, last_attempt = ?";
		Timestamp now = Timestamp.valueOf(LocalDateTime.now());
		jdbcTemplate.update(sql, username, now, now);

		String checkSql = "SELECT attempts FROM login_attempts WHERE username = ?";
		try {
			Integer currentAttempts = jdbcTemplate.queryForObject(checkSql, Integer.class, username);
			if (currentAttempts != null && currentAttempts >= MAX_ATTEMPTS) {
				logger.warn("Locking out user '{}' (from IP {}) due to {} failed login attempts.", username, ipAddress,
						currentAttempts);
			}
		} catch (Exception e) {
			logger.error("Could not check login attempts for user '{}' after failed login.", username, e);
		}
	}

	public void clearLoginAttempts(String username) {
		String sql = "DELETE FROM login_attempts WHERE username = ?";
		jdbcTemplate.update(sql, username);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationScheduler.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.ScheduledNotificationDAO;
import de.technikteam.model.ScheduledNotification;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
@EnableScheduling
public class NotificationScheduler {

	private static final Logger logger = LogManager.getLogger(NotificationScheduler.class);

	private final ScheduledNotificationDAO notificationDAO;
	private final NotificationService notificationService;

	@Autowired
	public NotificationScheduler(ScheduledNotificationDAO notificationDAO, NotificationService notificationService) {
		this.notificationDAO = notificationDAO;
		this.notificationService = notificationService;
	}

	@Scheduled(fixedRate = 60000) // Run every 60 seconds
	public void sendPendingNotifications() {
		logger.debug("Running scheduled notification task...");
		List<ScheduledNotification> pending = notificationDAO.findPendingNotifications();

		if (pending.isEmpty()) {
			logger.debug("No pending notifications to send.");
			return;
		}

		logger.info("Found {} pending notifications to send.", pending.size());
		for (ScheduledNotification notification : pending) {
			Map<String, Object> payload = Map.of("title", notification.getTitle(), "description",
					notification.getDescription(), "level", "Important", // Reminders are always important
					"url", notification.getUrl());
			notificationService.sendNotificationToUser(notification.getTargetUserId(), payload);
		}

		List<Integer> sentIds = pending.stream().map(ScheduledNotification::getId).collect(Collectors.toList());
		notificationDAO.markAsSent(sentIds);
		logger.info("Successfully sent and marked {} notifications.", sentIds.size());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.api.v1.dto.NotificationRequest;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

@Service
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);

	private final Map<Integer, List<SseEmitter>> emittersByUser = new ConcurrentHashMap<>();
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;

	public NotificationService(UserDAO userDAO, EventDAO eventDAO, MeetingDAO meetingDAO,
			AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	public SseEmitter register(User user) {
		if (user == null) {
			logger.warn("Versuch, Benachrichtigungen für eine nicht authentifizierte Sitzung zu registrieren.");
			return null;
		}

		// Timeout set to a very long value. The connection will be kept alive by
		// heartbeats.
		SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		int userId = user.getId();

		emitter.onCompletion(() -> {
			logger.info("SSE Emitter für Benutzer {} beendet.", userId);
			removeEmitter(userId, emitter);
		});
		emitter.onTimeout(() -> {
			logger.warn("SSE Emitter für Benutzer {} hat Zeitüberschreitung.", userId);
			emitter.complete();
		});
		emitter.onError(e -> {
			// This often logs benign client-side disconnects, so we log at debug level.
			logger.debug("SSE Emitter Fehler für Benutzer {}: {}", userId, e.getMessage());
			// The emitter is completed by the container/Spring, no need to call complete()
			// here.
		});

		emittersByUser.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);

		logger.info(
				"Neuer Client für SSE-Benachrichtigungen für Benutzer-ID {} registriert. Gesamtzahl der Clients für Benutzer: {}",
				userId, emittersByUser.get(userId).size());

		// Send a confirmation event
		try {
			emitter.send(SseEmitter.event().name("connected").data("Verbindung hergestellt"));
		} catch (IOException e) {
			logger.error("Fehler beim Senden der Verbindungsbestätigung an Benutzer {}", userId, e);
			emitter.complete();
		}

		return emitter;
	}

	public void broadcastUIUpdate(String type, Object payload) {
		logger.info("Sende UI-Update vom Typ '{}' an alle Clients.", type);
		Map<String, Object> message = Map.of("updateType", type, "data", payload);
		SseEmitter.SseEventBuilder event = SseEmitter.event().name("ui_update").data(message);

		emittersByUser.values().forEach(emitterList -> emitterList.forEach(emitter -> {
			try {
				emitter.send(event);
			} catch (Exception e) {
				logger.warn("Fehler beim Senden an einen Client (wahrscheinlich getrennt), wird entfernt. Fehler: {}",
						e.getMessage());
				// Do not complete the emitter here, let its own lifecycle handlers manage it.
			}
		}));
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null && !userEmitters.isEmpty()) {
			SseEmitter.SseEventBuilder event = SseEmitter.event().name("notification").data(payload);
			logger.info("Sende gezielte Benachrichtigung an Benutzer-ID {}: {}", userId, payload);

			userEmitters.forEach(emitter -> {
				try {
					emitter.send(event);
				} catch (Exception e) {
					logger.warn(
							"Fehler beim Senden der gezielten Benachrichtigung an Benutzer {} (Client wahrscheinlich getrennt), wird entfernt. Fehler: {}",
							userId, e.getMessage());
					// Do not complete the emitter here, let its own lifecycle handlers manage it.
				}
			});
		} else {
			logger.debug("Keine aktiven SSE-Clients für Benutzer-ID {} gefunden, um Benachrichtigung zu senden.",
					userId);
		}
	}

	public int sendBroadcastNotification(NotificationRequest request, User adminUser) {
		List<User> targetUsers;
		String targetDescription;

		switch (request.targetType()) {
		case "ALL":
			targetUsers = userDAO.getAllUsers();
			targetDescription = "alle Benutzer";
			break;
		case "EVENT":
			if (request.targetId() == null)
				throw new IllegalArgumentException("Event-ID ist erforderlich.");
			targetUsers = eventDAO.getAssignedUsersForEvent(request.targetId());
			targetDescription = "Teilnehmer des Events ID " + request.targetId();
			break;
		case "MEETING":
			if (request.targetId() == null)
				throw new IllegalArgumentException("Meeting-ID ist erforderlich.");
			targetUsers = meetingDAO.getParticipantUsersForMeeting(request.targetId());
			targetDescription = "Teilnehmer des Meetings ID " + request.targetId();
			break;
		default:
			throw new IllegalArgumentException("Ungültiger Zieltyp: " + request.targetType());
		}

		if (targetUsers.isEmpty()) {
			logger.warn("Keine Empfänger für die Benachrichtigung gefunden (Ziel: {}).", targetDescription);
			return 0;
		}

		Map<String, Object> payload = Map.of("title", request.title(), "description", request.description(), "level",
				request.level());

		for (User targetUser : targetUsers) {
			sendNotificationToUser(targetUser.getId(), payload);
		}

		String logDetails = String.format("Benachrichtigung gesendet an '%s'. Titel: %s, Stufe: %s", targetDescription,
				request.title(), request.level());
		adminLogService.log(adminUser.getUsername(), "SEND_NOTIFICATION", logDetails);

		return targetUsers.size();
	}

	private void removeEmitter(int userId, SseEmitter emitter) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null) {
			userEmitters.remove(emitter);
			if (userEmitters.isEmpty()) {
				emittersByUser.remove(userId);
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\PageDocumentationService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.PageDocumentationDAO;
import de.technikteam.model.PageDocumentation;
import de.technikteam.model.User;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PageDocumentationService {

	private final PageDocumentationDAO documentationDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public PageDocumentationService(PageDocumentationDAO documentationDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.documentationDAO = documentationDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	public List<PageDocumentation> findAll(boolean isAdmin) {
		return documentationDAO.findAll(isAdmin).stream().peek(this::enrichWithWikiLink).collect(Collectors.toList());
	}

	public Optional<PageDocumentation> findByKey(String pageKey) {
		Optional<PageDocumentation> docOpt = documentationDAO.findByKey(pageKey);
		docOpt.ifPresent(this::enrichWithWikiLink);
		return docOpt;
	}

	@Transactional
	public PageDocumentation create(PageDocumentation doc, User adminUser) {
		doc.setFeatures(richTextPolicy.sanitize(doc.getFeatures()));
		PageDocumentation createdDoc = documentationDAO.create(doc);
		adminLogService.log(adminUser.getUsername(), "DOCS_CREATE", "Created documentation page: " + doc.getTitle());
		return createdDoc;
	}

	@Transactional
	public PageDocumentation update(PageDocumentation doc, User adminUser) {
		doc.setFeatures(richTextPolicy.sanitize(doc.getFeatures()));
		PageDocumentation updatedDoc = documentationDAO.update(doc);
		adminLogService.log(adminUser.getUsername(), "DOCS_UPDATE", "Updated documentation page: " + doc.getTitle());
		return updatedDoc;
	}

	@Transactional
	public boolean delete(int id, User adminUser) {
		Optional<PageDocumentation> docOpt = documentationDAO.findById(id); // Assuming findById exists
		if (docOpt.isPresent()) {
			boolean success = documentationDAO.delete(id);
			if (success) {
				adminLogService.log(adminUser.getUsername(), "DOCS_DELETE",
						"Deleted documentation page: " + docOpt.get().getTitle());
			}
			return success;
		}
		return false;
	}

	private void enrichWithWikiLink(PageDocumentation doc) {
		if (doc.getWikiEntryId() != null && doc.getWikiEntryId() > 0) {
			// The frontend knows how to handle this link.
			doc.setWikiLink("/admin/wiki");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ProfileRequestService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Service
public class ProfileRequestService {
	private static final Logger logger = LogManager.getLogger(ProfileRequestService.class);

	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;

	@Autowired
	public ProfileRequestService(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService,
			NotificationService notificationService) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
	}

	@Transactional
	public void createChangeRequest(User currentUser, ProfileChangeRequestDTO requestDTO) throws IOException {
		Map<String, String> changes = new HashMap<>();
		if (requestDTO.email() != null && !Objects.equals(currentUser.getEmail(), requestDTO.email())) {
			changes.put("email", requestDTO.email());
		}
		if (requestDTO.classYear() != null && currentUser.getClassYear() != requestDTO.classYear()) {
			changes.put("classYear", String.valueOf(requestDTO.classYear()));
		}
		if (requestDTO.className() != null && !Objects.equals(currentUser.getClassName(), requestDTO.className())) {
			changes.put("className", requestDTO.className());
		}
		if (requestDTO.profileIconClass() != null
				&& !Objects.equals(currentUser.getProfileIconClass(), requestDTO.profileIconClass())) {
			changes.put("profileIconClass", requestDTO.profileIconClass());
		}

		if (changes.isEmpty()) {
			return; // No changes to request
		}

		ProfileChangeRequest pcr = new ProfileChangeRequest();
		pcr.setUserId(currentUser.getId());
		pcr.setRequestedChanges(new Gson().toJson(changes));

		if (!requestDAO.createRequest(pcr)) {
			throw new IOException("Ihr Antrag konnte nicht in der Datenbank gespeichert werden.");
		}
	}

	@Transactional
	public boolean approveRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		User userToUpdate = userDAO.getUserById(pcr.getUserId());
		if (userToUpdate == null) {
			requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
			throw new IllegalStateException(
					"Der zugehörige Benutzer existiert nicht mehr. Der Antrag wurde abgelehnt.");
		}

		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = new Gson().fromJson(pcr.getRequestedChanges(), type);

		for (Map.Entry<String, String> entry : changes.entrySet()) {
			String field = entry.getKey();
			String value = entry.getValue();
			switch (field) {
			case "email":
				// Prevent unique constraint violation for empty strings
				userToUpdate.setEmail("".equals(value) ? null : value);
				break;
			case "classYear":
				userToUpdate.setClassYear(Integer.parseInt(value));
				break;
			case "className":
				userToUpdate.setClassName(value);
				break;
			case "profileIconClass":
				userToUpdate.setProfileIconClass(value);
				break;
			}
		}
		try {
			if (userDAO.updateUser(userToUpdate)
					&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED_API", "Profile change for '"
						+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") approved via API.");

				String notificationMessage = "Your profile change has been approved.";
				Map<String, Object> payload = Map.of("type", "alert", "payload",
						Map.of("message", notificationMessage));
				notificationService.sendNotificationToUser(userToUpdate.getId(), payload);

				return true;
			}
		} catch (DuplicateKeyException e) {
			logger.warn("Failed to approve request {}: {}", requestId, e.getMessage());
			throw new IllegalStateException(
					"Die Genehmigung ist fehlgeschlagen, da die angeforderte E-Mail-Adresse bereits von einem anderen Konto verwendet wird.");
		}
		return false;
	}

	@Transactional
	public boolean denyRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED_API", "Profile change for user ID "
					+ pcr.getUserId() + " (Request ID: " + requestId + ") denied via API.");
			return true;
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\RateLimitingService.java
========================================================================

package de.technikteam.service;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RateLimitingService {

	private final Map<String, Bucket> cache = new ConcurrentHashMap<>();

	public Bucket resolveBucket(String apiKey) {
		return cache.computeIfAbsent(apiKey, this::newBucket);
	}

	private Bucket newBucket(String apiKey) {
		// Example: 10 requests per minute
		Bandwidth limit = Bandwidth.simple(10, Duration.ofMinutes(1));
		return Bucket.builder().addLimit(limit).build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SearchService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import de.technikteam.model.SearchResultDTO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class SearchService {

	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final MeetingDAO meetingDAO;
	private final WikiDAO wikiDAO;

	@Autowired
	public SearchService(EventDAO eventDAO, StorageDAO storageDAO, MeetingDAO meetingDAO, WikiDAO wikiDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.meetingDAO = meetingDAO;
		this.wikiDAO = wikiDAO;
	}

	public List<SearchResultDTO> performSearch(String query, User user) {
		// Since security is frontend-only, we don't need to filter results based on the
		// user object here.
		// In a secure app, we would pass the user to each DAO method.

		List<SearchResultDTO> eventResults = eventDAO.search(query).stream().map(this::mapEventToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> itemResults = storageDAO.search(query).stream().map(this::mapStorageItemToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> meetingResults = meetingDAO.search(query).stream().map(this::mapMeetingToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> wikiResults = new ArrayList<>();
		// Only search wiki if user is an admin
		if (user != null && user.hasAdminAccess()) {
			wikiResults = wikiDAO.search(query).stream().map(this::mapWikiEntryToSearchResult)
					.collect(Collectors.toList());
		}

		return Stream.of(eventResults, itemResults, meetingResults, wikiResults).flatMap(List::stream)
				.collect(Collectors.toList());
	}

	private SearchResultDTO mapEventToSearchResult(Event event) {
		String url = "/veranstaltungen/details/" + event.getId();
		return new SearchResultDTO("Veranstaltung", event.getName(), url, event.getLocation());
	}

	private SearchResultDTO mapStorageItemToSearchResult(StorageItem item) {
		String url = "/lager/details/" + item.getId();
		return new SearchResultDTO("Lagerartikel", item.getName(), url, item.getLocation());
	}

	private SearchResultDTO mapMeetingToSearchResult(Meeting meeting) {
		String url = "/lehrgaenge/details/" + meeting.getId();
		String title = meeting.getParentCourseName() + ": " + meeting.getName();
		return new SearchResultDTO("Lehrgang", title, url, meeting.getLocation());
	}

	private SearchResultDTO mapWikiEntryToSearchResult(WikiEntry entry) {
		// Note: The Wiki is admin-only, so this URL will only work for admins.
		String url = "/admin/wiki"; // The wiki is a single page app, we can't link to a sub-page directly
		return new SearchResultDTO("Dokumentation", entry.getFilePath(), url, "Wiki-Eintrag");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\StorageItemRelationService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.StorageItemRelationDAO;
import de.technikteam.model.StorageItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class StorageItemRelationService {

	private final StorageItemRelationDAO relationDAO;

	@Autowired
	public StorageItemRelationService(StorageItemRelationDAO relationDAO) {
		this.relationDAO = relationDAO;
	}

	public List<StorageItem> findRelatedItems(int itemId) {
		return relationDAO.findRelatedItems(itemId);
	}

	@Transactional
	public void updateRelations(int itemId, List<Integer> relatedItemIds) {
		relationDAO.updateRelations(itemId, relatedItemIds);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\StorageService.java
========================================================================

package de.technikteam.service;

import de.technikteam.config.Permissions;
import de.technikteam.dao.*;
import de.technikteam.model.DamageReport;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class StorageService {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final DamageReportDAO damageReportDAO;
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final MaintenanceLogDAO maintenanceLogDAO;

	@Autowired
	public StorageService(StorageDAO storageDAO, StorageLogDAO storageLogDAO, DamageReportDAO damageReportDAO,
			UserDAO userDAO, EventDAO eventDAO, AdminLogService adminLogService,
			NotificationService notificationService, MaintenanceLogDAO maintenanceLogDAO) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.damageReportDAO = damageReportDAO;
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.maintenanceLogDAO = maintenanceLogDAO;
	}

	@Transactional
	public boolean processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null)
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");

		if ("checkout".equals(type)) {
			if (item.getAvailableQuantity() < quantity)
				throw new IllegalStateException("Nicht genügend Artikel zum Entnehmen verfügbar.");
			item.setQuantity(item.getQuantity() - quantity);
			item.setStatus("CHECKED_OUT");
			item.setCurrentHolderUserId(user.getId());
			item.setAssignedEventId(eventId != null ? eventId : 0);
		} else if ("checkin".equals(type)) {
			if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
				throw new IllegalStateException("Nicht genügend Platz, um diese Menge einzuräumen.");
			}
			item.setQuantity(item.getQuantity() + quantity);
			if (item.getQuantity() >= item.getMaxQuantity()) {
				item.setStatus("IN_STORAGE");
				item.setCurrentHolderUserId(0);
				item.setAssignedEventId(0);
			}
		} else {
			throw new IllegalArgumentException("Ungültiger Transaktionstyp: " + type);
		}

		storageDAO.updateItem(item);

		String finalNotes = notes;
		if ("checkout".equals(type) && eventId != null) {
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				String autoNote = "Für Event: " + event.getName();
				finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes : autoNote;
			}
		}
		int quantityChange = "checkin".equals(type) ? quantity : -quantity;
		storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes, eventId != null ? eventId : 0);

		String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
		String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, item.getName(), itemId, action,
				finalNotes);
		adminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

		return true;
	}

	@Transactional
	public void handleItemStatusUpdate(int itemId, Map<String, Object> payload, User adminUser) {
		String action = (String) payload.get("action");
		if (action == null) {
			throw new IllegalArgumentException("Action is required.");
		}

		switch (action) {
		case "report_defect":
		case "report_unrepairable":
			int defectiveQuantity = ((Number) payload.get("quantity")).intValue();
			String reason = (String) payload.get("reason");
			String status = "report_unrepairable".equals(action) ? "UNREPAIRABLE" : "DEFECT";
			updateDefectiveItemStatus(itemId, status, defectiveQuantity, reason, adminUser);
			break;
		case "repair":
			int repairedQuantity = ((Number) payload.get("quantity")).intValue();
			String notes = (String) payload.get("notes");
			repairItems(itemId, repairedQuantity, notes, adminUser);
			break;
		default:
			throw new IllegalArgumentException("Unknown action: " + action);
		}
	}

	@Transactional
	public boolean updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");
		}

		String logDetails;

		if ("UNREPAIRABLE".equals(status)) {
			if (item.getQuantity() < quantity || item.getDefectiveQuantity() < quantity) {
				throw new IllegalStateException(
						"Es können nicht mehr Artikel als irreparabel markiert werden, als vorhanden oder defekt sind.");
			}
			item.setQuantity(item.getQuantity() - quantity);
			item.setDefectiveQuantity(item.getDefectiveQuantity() - quantity);
			item.setDefectReason(reason);
			logDetails = String.format("Permanently removed %d x '%s' (ID: %d) from stock (unrepairable). Reason: %s",
					quantity, item.getName(), itemId, reason);
			adminLogService.log(adminUser.getUsername(), "ITEM_UNREPAIRABLE", logDetails);
		} else {
			int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
			if (item.getQuantity() < newDefectiveTotal) {
				throw new IllegalStateException(
						"Die Gesamtzahl der defekten Artikel kann die Gesamtmenge nicht überschreiten.");
			}
			item.setDefectiveQuantity(newDefectiveTotal);
			item.setDefectReason(reason);
			logDetails = String.format("Defect status for '%s' (ID: %d) updated: %d defective. Reason: %s",
					item.getName(), itemId, newDefectiveTotal, reason);
			adminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS", logDetails);
		}

		storageDAO.updateItem(item);
		return true;
	}

	@Transactional
	public void repairItems(int itemId, int quantity, String notes, User adminUser) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Item not found.");
		}
		if (quantity > item.getDefectiveQuantity()) {
			throw new IllegalStateException("Cannot repair more items than are marked as defective.");
		}
		item.setDefectiveQuantity(item.getDefectiveQuantity() - quantity);
		storageDAO.updateItem(item);
		// Log maintenance action
		adminLogService.log(adminUser.getUsername(), "ITEM_REPAIRED",
				String.format("Repaired %d x '%s' (ID: %d). Notes: %s", quantity, item.getName(), itemId, notes));
	}

	@Transactional
	public DamageReport createDamageReport(int itemId, int reporterId, String description) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Der zu meldende Artikel existiert nicht.");
		}
		DamageReport report = damageReportDAO.createReport(itemId, reporterId, description);

		// Notify admins
		List<Integer> adminIds = userDAO.findUserIdsByPermission(Permissions.DAMAGE_REPORT_MANAGE);
		User reporter = userDAO.getUserById(reporterId);
		String title = "Neue Schadensmeldung";
		String notificationDescription = String.format("%s hat einen Schaden für '%s' gemeldet.",
				reporter.getUsername(), item.getName());

		for (Integer adminId : adminIds) {
			Map<String, Object> payload = Map.of("title", title, "description", notificationDescription, "level",
					"Important", "url", "/admin/damage-reports");
			notificationService.sendNotificationToUser(adminId, payload);
		}

		return report;
	}

	@Transactional
	public void confirmDamageReport(int reportId, int quantity, User adminUser) {
		DamageReport report = damageReportDAO.getReportById(reportId)
				.orElseThrow(() -> new IllegalArgumentException("Bericht nicht gefunden."));

		if (!"PENDING".equals(report.getStatus())) {
			throw new IllegalStateException("Dieser Bericht wurde bereits bearbeitet.");
		}

		// Update the storage item
		StorageItem item = storageDAO.getItemById(report.getItemId());
		int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
		if (item.getQuantity() < newDefectiveTotal) {
			throw new IllegalStateException(
					"Die Gesamtzahl der defekten Artikel kann die Gesamtmenge nicht überschreiten.");
		}
		item.setDefectiveQuantity(newDefectiveTotal);
		if (item.getDefectReason() == null || item.getDefectReason().isBlank()) {
			item.setDefectReason(report.getReportDescription());
		} else {
			item.setDefectReason(item.getDefectReason() + " | Gemeldet: " + report.getReportDescription());
		}
		storageDAO.updateItem(item);

		// Update the report status
		damageReportDAO.updateStatus(reportId, "CONFIRMED", adminUser.getId(), "Bestätigt und als defekt verbucht.");

		// Log the admin action
		adminLogService.log(adminUser.getUsername(), "DAMAGE_REPORT_CONFIRMED",
				String.format("Schadensmeldung #%d für '%s' bestätigt.", reportId, item.getName()));
	}

	@Transactional
	public void rejectDamageReport(int reportId, String adminNotes, User adminUser) {
		DamageReport report = damageReportDAO.getReportById(reportId)
				.orElseThrow(() -> new IllegalArgumentException("Bericht nicht gefunden."));

		if (!"PENDING".equals(report.getStatus())) {
			throw new IllegalStateException("Dieser Bericht wurde bereits bearbeitet.");
		}

		damageReportDAO.updateStatus(reportId, "REJECTED", adminUser.getId(), adminNotes);

		adminLogService.log(adminUser.getUsername(), "DAMAGE_REPORT_REJECTED", String.format(
				"Schadensmeldung #%d für '%s' abgelehnt. Grund: %s", reportId, report.getItemName(), adminNotes));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

@Service
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getCpuLoad() * 100.0);

		long totalMemoryBytes = Runtime.getRuntime().totalMemory();
		long freeMemoryBytes = Runtime.getRuntime().freeMemory();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\TodoService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.TodoDAO;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class TodoService {
	private static final Logger logger = LogManager.getLogger(TodoService.class);
	private final TodoDAO todoDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public TodoService(TodoDAO todoDAO, AdminLogService adminLogService) {
		this.todoDAO = todoDAO;
		this.adminLogService = adminLogService;
	}

	public List<TodoCategory> getAllTodos() {
		return todoDAO.getAllCategoriesWithTasks();
	}

	@Transactional
	public TodoCategory createCategory(String name, User admin) {
		try {
			TodoCategory newCategory = todoDAO.createCategory(name);
			if (newCategory != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_CATEGORY",
						"To-Do Kategorie '" + name + "' erstellt.");
			}
			return newCategory;
		} catch (Exception e) {
			logger.error("Service error creating To-Do category '{}'", name, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public TodoTask createTask(int categoryId, String content, User admin) {
		try {
			TodoTask newTask = todoDAO.createTask(categoryId, content);
			if (newTask != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_TASK",
						"To-Do Aufgabe '" + content + "' in Kategorie ID " + categoryId + " erstellt.");
			}
			return newTask;
		} catch (Exception e) {
			logger.error("Service error creating To-Do task in category {}", categoryId, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public boolean updateTask(int taskId, String content, Boolean isCompleted, User admin) {
		boolean success = false;
		if (content != null) {
			success = todoDAO.updateTaskContent(taskId, content);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_TASK", "Aufgabe ID " + taskId + " aktualisiert.");
		}
		if (isCompleted != null) {
			success = todoDAO.updateTaskStatus(taskId, isCompleted);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_STATUS",
						"Status für Aufgabe ID " + taskId + " auf '" + isCompleted + "' gesetzt.");
		}
		return success;
	}

	@Transactional
	public boolean deleteTask(int taskId, User admin) {
		if (todoDAO.deleteTask(taskId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_TASK", "Aufgabe ID " + taskId + " gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean deleteCategory(int categoryId, User admin) {
		if (todoDAO.deleteCategory(categoryId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_CATEGORY",
					"Kategorie ID " + categoryId + " und alle zugehörigen Aufgaben gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean reorder(Map<String, List<Integer>> reorderData, User admin) {
		List<Integer> categoryOrder = reorderData.get("categoryOrder");
		if (categoryOrder != null) {
			todoDAO.updateCategoryOrder(categoryOrder);
		}

		for (Map.Entry<String, List<Integer>> entry : reorderData.entrySet()) {
			if (entry.getKey().startsWith("category-")) {
				int categoryId = Integer.parseInt(entry.getKey().substring("category-".length()));
				todoDAO.updateTaskOrders(entry.getValue(), categoryId);
			}
		}
		adminLogService.log(admin.getUsername(), "TODO_REORDER", "To-Do-Listen neu sortiert.");
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\TrainingRequestService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.TrainingRequestDAO;
import de.technikteam.model.TrainingRequest;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
public class TrainingRequestService {

	private final TrainingRequestDAO trainingRequestDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public TrainingRequestService(TrainingRequestDAO trainingRequestDAO, AdminLogService adminLogService) {
		this.trainingRequestDAO = trainingRequestDAO;
		this.adminLogService = adminLogService;
	}

	public List<TrainingRequest> findAllWithInterestCount() {
		return trainingRequestDAO.findAllWithInterestCount();
	}

	@Transactional
	public TrainingRequest create(String topic, User requester) {
		TrainingRequest newRequest = trainingRequestDAO.create(topic, requester.getId());
		// Automatically register interest for the user who created the request
		trainingRequestDAO.addInterest(newRequest.getId(), requester.getId());
		return newRequest;
	}

	public boolean registerInterest(int requestId, int userId) {
		return trainingRequestDAO.addInterest(requestId, userId);
	}

	@Transactional
	public boolean delete(int id, User adminUser) {
		Optional<TrainingRequest> requestOpt = trainingRequestDAO.findById(id);
		if (requestOpt.isPresent()) {
			boolean success = trainingRequestDAO.delete(id);
			if (success) {
				adminLogService.log(adminUser.getUsername(), "TRAINING_REQUEST_DELETE",
						"Deleted training request: " + requestOpt.get().getTopic() + " (ID: " + id + ")");
			}
			return success;
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\UserService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
	private static final Logger logger = LogManager.getLogger(UserService.class);

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public UserService(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public int createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername) {
		int newUserId = userDAO.createUser(user, password);
		if (newUserId > 0) {
			userDAO.updateUserPermissions(newUserId, permissionIds);
			logger.info("Transaction for creating user '{}' committed successfully.", user.getUsername());

			String logDetails = String.format(
					"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %s) erstellt und Berechtigungen zugewiesen.",
					user.getUsername(), newUserId, user.getRoleId(), user.getClassName());
			adminLogService.log(adminUsername, "CREATE_USER", logDetails);

			return newUserId;
		} else {
			throw new RuntimeException("Benutzererstellung lieferte eine ungültige ID zurück.");
		}
	}

	@Transactional
	public boolean updateUserWithPermissions(User user, String[] permissionIds) {
		boolean profileUpdated = userDAO.updateUser(user);
		boolean permissionsUpdated = userDAO.updateUserPermissions(user.getId(), permissionIds);
		logger.info("Transaction for updating user '{}' committed successfully.", user.getUsername());
		return profileUpdated || permissionsUpdated;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\WikiService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.WikiDAO;
import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Service
public class WikiService {
	private static final Logger logger = LogManager.getLogger(WikiService.class);
	private final WikiDAO wikiDAO;

	@Autowired
	public WikiService(WikiDAO wikiDAO) {
		this.wikiDAO = wikiDAO;
	}

	/**
	 * Fetches all wiki entries and organizes them into a hierarchical tree
	 * structure. The structure is a map of maps, where the final value is a
	 * WikiEntry object.
	 *
	 * @return A Map representing the root of the file tree.
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getWikiTreeAsData() {
		List<WikiEntry> allEntries = wikiDAO.getAllWikiEntries();
		Map<String, Object> rootNode = new LinkedHashMap<>();

		for (WikiEntry entry : allEntries) {
			String[] pathParts = entry.getFilePath().split("/");
			Map<String, Object> currentNode = rootNode;

			for (int i = 0; i < pathParts.length - 1; i++) {
				String part = pathParts[i];
				// This cast is safe within this algorithm as we are intentionally building a
				// nested map structure.
				currentNode = (Map<String, Object>) currentNode.computeIfAbsent(part,
						k -> new LinkedHashMap<String, Object>());
			}

			String fileName = pathParts[pathParts.length - 1];
			if (!fileName.isEmpty()) {
				currentNode.put(fileName, entry);
			}
		}
		logger.debug("Successfully built wiki tree with {} root elements.", rootNode.size());
		return rootNode;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\FileSignatureValidator.java
========================================================================

package de.technikteam.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FileSignatureValidator {
	private static final Logger logger = LogManager.getLogger(FileSignatureValidator.class);

	public enum FileTypeValidationResult {
		ALLOWED, ALLOWED_WITH_WARNING, DISALLOWED
	}

	private static final Map<String, List<byte[]>> ALLOWED_SIGNATURES = new HashMap<>();
	private static final Map<String, List<byte[]>> WARNING_SIGNATURES = new HashMap<>();

	static {
		// Secure, common types
		ALLOWED_SIGNATURES.put("image/jpeg", List.of(new byte[] { (byte) 0xFF, (byte) 0xD8, (byte) 0xFF }));
		ALLOWED_SIGNATURES.put("image/png", List.of(new byte[] { (byte) 0x89, (byte) 0x50, (byte) 0x4E, (byte) 0x47 }));
		ALLOWED_SIGNATURES.put("image/gif", List.of(new byte[] { (byte) 0x47, (byte) 0x49, (byte) 0x46, (byte) 0x38 }));
		ALLOWED_SIGNATURES.put("application/pdf",
				List.of(new byte[] { (byte) 0x25, (byte) 0x50, (byte) 0x44, (byte) 0x46 }));
		List<byte[]> pkzip = List.of(new byte[] { (byte) 0x50, (byte) 0x4B, (byte) 0x03, (byte) 0x04 });
		ALLOWED_SIGNATURES.put("application/vnd.openxmlformats-officedocument.wordprocessingml.document", pkzip);
		ALLOWED_SIGNATURES.put("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", pkzip);
		ALLOWED_SIGNATURES.put("application/vnd.openxmlformats-officedocument.presentationml.presentation", pkzip);

		// Potentially risky types that are allowed but should trigger a warning on
		// download
		WARNING_SIGNATURES.put("application/javascript", List.of()); // JS files have no reliable magic number, so we
																		// allow them by MIME type but flag for warning.
		WARNING_SIGNATURES.put("text/html", List.of()); // HTML files also lack a consistent magic number.
		WARNING_SIGNATURES.put("application/zip", pkzip);
	}

	private static final int MAX_HEADER_SIZE = 8;

	public static FileTypeValidationResult validateFileType(MultipartFile file) {
		if (file == null || file.isEmpty()) {
			return FileTypeValidationResult.DISALLOWED;
		}
		String declaredMimeType = file.getContentType();

		// Check if it's an explicitly allowed type
		List<byte[]> allowedSignatures = ALLOWED_SIGNATURES.get(declaredMimeType);
		if (allowedSignatures != null) {
			if (verifySignature(file, allowedSignatures)) {
				return FileTypeValidationResult.ALLOWED;
			} else {
				logger.warn("File signature mismatch for allowed type. Declared: {}, but magic bytes do not match.",
						declaredMimeType);
				return FileTypeValidationResult.DISALLOWED;
			}
		}

		// Check if it's a type that is allowed but needs a warning
		List<byte[]> warningSignatures = WARNING_SIGNATURES.get(declaredMimeType);
		if (warningSignatures != null) {
			if (verifySignature(file, warningSignatures)) {
				return FileTypeValidationResult.ALLOWED_WITH_WARNING;
			} else {
				logger.warn("File signature mismatch for warning type. Declared: {}, but magic bytes do not match.",
						declaredMimeType);
				return FileTypeValidationResult.DISALLOWED;
			}
		}

		logger.warn("File upload blocked for undeclared MIME type: {}", declaredMimeType);
		return FileTypeValidationResult.DISALLOWED;
	}

	private static boolean verifySignature(MultipartFile file, List<byte[]> expectedSignatures) {
		// If the signature list is empty, it means we are trusting the MIME type alone
		// for this category.
		if (expectedSignatures.isEmpty()) {
			return true;
		}

		try (InputStream is = file.getInputStream()) {
			byte[] header = new byte[MAX_HEADER_SIZE];
			int bytesRead = is.read(header);
			if (bytesRead < 1)
				return false;

			byte[] actualHeader = Arrays.copyOf(header, bytesRead);

			for (byte[] signature : expectedSignatures) {
				if (actualHeader.length >= signature.length) {
					byte[] headerToCompare = Arrays.copyOf(actualHeader, signature.length);
					if (Arrays.equals(headerToCompare, signature)) {
						return true; // Match found
					}
				}
			}
		} catch (IOException e) {
			logger.error("Could not read file header for validation", e);
			return false;
		}

		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

/**
 * DEPRECATED: This class is no longer used for security-sensitive sanitization.
 * The OWASP Java HTML Sanitizer is now used instead to provide robust
 * protection against Cross-Site Scripting (XSS) attacks. This class is retained
 * for historical purposes or non-security-related transformations if needed.
 */
public final class MarkdownUtil {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private MarkdownUtil() {
	}

	/**
	 * A simple, non-security-focused method to perform basic transformations.
	 *
	 * @param markdown The raw string.
	 * @return The transformed string.
	 */
	public static String transform(String markdown) {
		if (markdown == null || markdown.isEmpty()) {
			return markdown;
		}
		// Example transformation: none, as this is deprecated for security.
		return markdown;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Anschlagbrett", "/bulletin-board", "fa-thumbtack", null));
		ALL_ITEMS.add(new NavigationItem("Team", "/team", "fa-users", null));
		ALL_ITEMS.add(new NavigationItem("Chat", "/chat", "fa-comments", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Feedback", "/feedback", "fa-lightbulb", null));
		ALL_ITEMS.add(new NavigationItem("Changelogs", "/changelogs", "fa-history", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgänge & Skills", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Inhalte & System", "/admin/content", "fa-desktop", Permissions.FILE_MANAGE));
		ALL_ITEMS.add(new NavigationItem("Berichte & Logs", "/admin/reports", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(
				new NavigationItem("Technische Wiki", "/admin/wiki", "fa-book-reader", Permissions.ACCESS_ADMIN_PANEL));
		ALL_ITEMS.add(new NavigationItem("API Docs", "/swagger-ui.html", "fa-code", Permissions.ACCESS_ADMIN_PANEL));
	}

	private NavigationRegistry() {
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null) {
			return new ArrayList<>();
		}

		final boolean isAdmin = user.hasAdminAccess();
		final Set<String> userPermissions = user.getPermissions() != null ? user.getPermissions() : Set.of();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items (no permission required) are always visible to any authenticated
			// user.
			if (requiredPerm == null) {
				return true;
			}

			// For admin links, check if the user is an admin or has the specific permission
			if (isAdmin) {
				return true;
			}

			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms as a thread-safe
 * Spring Component. It maps event IDs to a set of active sessions, allowing for
 * targeted broadcasting of messages.
 */
@Component
public class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByEvent = new ConcurrentHashMap<>();

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, WebSocketSession session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatWebSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.ChatDAO;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.ChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class ChatWebSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(ChatWebSocketHandler.class);
	private final ChatDAO chatDAO;
	private final ChatWebSocketSessionManager sessionManager;
	private final NotificationService notificationService;
	private final Gson gson;

	@Autowired
	public ChatWebSocketHandler(ChatDAO chatDAO, ChatWebSocketSessionManager sessionManager,
			NotificationService notificationService) {
		this.chatDAO = chatDAO;
		this.sessionManager = sessionManager;
		this.notificationService = notificationService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String conversationId = getConversationId(session);

		if (user == null || conversationId == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Missing user or conversation ID."));
			return;
		}

		if (!chatDAO.isUserInConversation(Integer.parseInt(conversationId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Unauthorized for this conversation."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("conversationId", conversationId);
		sessionManager.addSession(conversationId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		User user = (User) session.getAttributes().get("user");
		String conversationIdStr = (String) session.getAttributes().get("conversationId");
		if (user == null || conversationIdStr == null)
			return;
		int conversationId = Integer.parseInt(conversationIdStr);

		try {
			Map<String, Object> payload = gson.fromJson(message.getPayload(), new TypeToken<Map<String, Object>>() {
			}.getType());
			String type = (String) payload.get("type");
			// The actual data might be nested inside a 'payload' object or be at the top
			// level
			Map<String, Object> data = (Map<String, Object>) payload.get("payload");
			if (data == null) {
				data = payload; // Fallback for messages like `new_message` which might not have a nested
								// payload
			}

			switch (type) {
			case "new_message":
				handleNewMessage(user, conversationId, (String) data.get("messageText"));
				break;
			case "mark_as_read":
				if (data.get("messageIds") instanceof List) {
					handleMarkAsRead(user, conversationId, (List<Double>) data.get("messageIds"));
				}
				break;
			case "update_message":
				handleUpdateMessage(user, conversationId, data);
				break;
			case "delete_message":
				handleDeleteMessage(user, conversationId, data);
				break;
			}
		} catch (JsonSyntaxException | ClassCastException | NullPointerException e) {
			logger.warn("Bad payload from {}: {}", user.getUsername(), e.getMessage());
		}
	}

	private void handleNewMessage(User user, int conversationId, String text) {
		if (text != null && !text.isBlank()) {
			ChatMessage chatMessage = new ChatMessage();
			chatMessage.setConversationId(conversationId);
			chatMessage.setSenderId(user.getId());
			chatMessage.setMessageText(text);

			ChatMessage savedMessage = chatDAO.createMessage(chatMessage);
			ChatMessage fullMessage = chatDAO.getMessageById(savedMessage.getId());

			sessionManager.broadcast(String.valueOf(conversationId),
					gson.toJson(Map.of("type", "new_message", "payload", fullMessage)));
			notifyParticipants(fullMessage, user);
		}
	}

	private void handleMarkAsRead(User user, int conversationId, List<Double> messageIdsDouble) {
		if (messageIdsDouble == null || messageIdsDouble.isEmpty())
			return;
		List<Long> messageIds = messageIdsDouble.stream().map(Double::longValue).collect(Collectors.toList());

		boolean updated = chatDAO.updateMessagesStatusToRead(messageIds, conversationId, user.getId());
		if (updated) {
			Map<String, Object> updatePayload = Map.of("type", "messages_status_updated", "payload",
					Map.of("messageIds", messageIds, "newStatus", "READ"));
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(updatePayload));
		}
	}

	private void handleUpdateMessage(User user, int conversationId, Map<String, Object> data) {
		if (data == null || !(data.get("messageId") instanceof Number))
			return;
		long messageId = ((Number) data.get("messageId")).longValue();
		String newText = (String) data.get("newText");

		if (chatDAO.updateMessage(messageId, user.getId(), newText)) {
			ChatMessage updatedMessage = chatDAO.getMessageById(messageId);
			if (updatedMessage == null)
				return;

			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload", updatedMessage);
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, int conversationId, Map<String, Object> data) {
		if (data == null || !(data.get("messageId") instanceof Number))
			return;
		long messageId = ((Number) data.get("messageId")).longValue();
		ChatConversation conversation = chatDAO.getConversationById(conversationId);
		boolean isAdmin = conversation != null && conversation.isGroupChat() && conversation.getCreatorId() != null
				&& conversation.getCreatorId() == user.getId();

		if (chatDAO.deleteMessage(messageId, user.getId(), isAdmin)) {
			ChatMessage deletedMessage = chatDAO.getMessageById(messageId);
			if (deletedMessage == null)
				return;

			Map<String, Object> broadcastPayload = Map.of("type", "message_deleted", "payload", deletedMessage);
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(broadcastPayload));
		}
	}

	private void notifyParticipants(ChatMessage message, User sender) {
		ChatConversation conversation = chatDAO.getConversationById(message.getConversationId());
		if (conversation == null)
			return;

		List<User> participants = conversation.getParticipants();
		for (User participant : participants) {
			if (participant.getId() != sender.getId()) { // Don't notify the sender
				String messageSnippet = message.getMessageText();
				if (messageSnippet.length() > 50) {
					messageSnippet = messageSnippet.substring(0, 47) + "...";
				}

				String title = conversation.isGroupChat() ? "Neue Nachricht in \"" + conversation.getName() + "\""
						: "Neue Nachricht von " + sender.getUsername();

				Map<String, Object> payload = Map.of("type", "new_message", "title", title, "description",
						messageSnippet, "level", "Informational", "url", "/chat/" + message.getConversationId());
				notificationService.sendNotificationToUser(participant.getId(), payload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		String conversationId = (String) session.getAttributes().get("conversationId");
		if (conversationId != null) {
			sessionManager.removeSession(conversationId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication auth) {
			if (auth.getPrincipal() instanceof SecurityUser securityUser) {
				return securityUser.getUser();
			}
		}
		return null;
	}

	private String getConversationId(WebSocketSession session) {
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatWebSocketSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

@Component
public class ChatWebSocketSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatWebSocketSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByConversation = new ConcurrentHashMap<>();

	public void addSession(String conversationId, WebSocketSession session) {
		sessionsByConversation.computeIfAbsent(conversationId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for direct message chat [{}].", session.getId(), conversationId);
	}

	public void removeSession(String conversationId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByConversation.get(conversationId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from direct message chat [{}].", session.getId(), conversationId);
			if (sessions.isEmpty()) {
				sessionsByConversation.remove(conversationId);
				logger.info("Direct message chat room [{}] is now empty and has been removed.", conversationId);
			}
		}
	}

	public void broadcast(String conversationId, String message) {
		Set<WebSocketSession> sessions = sessionsByConversation.get(conversationId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in direct message chat [{}].", sessions.size(), conversationId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChecklistWebSocketHandler.java
========================================================================

package de.technikteam.websocket;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

@Component
public class ChecklistWebSocketHandler extends TextWebSocketHandler {

	private final EventDAO eventDAO;
	private final ChatSessionManager sessionManager; // Reusing this manager

	@Autowired
	public ChecklistWebSocketHandler(EventDAO eventDAO, ChatSessionManager sessionManager) {
		this.eventDAO = eventDAO;
		this.sessionManager = sessionManager;
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String eventId = getEventId(session);

		if (user == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Authentifizierung erforderlich."));
			return;
		}

		if (eventId == null || !eventDAO.isUserAssociatedWithEvent(Integer.parseInt(eventId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Keine Berechtigung für diese Event-Checkliste."));
			return;
		}

		session.getAttributes().put("eventId", eventId);
		sessionManager.addSession(eventId, session);
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		String eventId = (String) session.getAttributes().get("eventId");
		if (eventId != null) {
			sessionManager.removeSession(eventId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication auth) {
			if (auth.getPrincipal() instanceof SecurityUser securityUser) {
				return securityUser.getUser();
			}
		}
		return null;
	}

	private String getEventId(WebSocketSession session) {
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\EventChatSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class EventChatSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(EventChatSocketHandler.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private final EventChatDAO chatDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ChatSessionManager sessionManager;
	private final Gson gson;
	private final PolicyFactory inlineFormattingPolicy;

	@Autowired
	public EventChatSocketHandler(EventChatDAO chatDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService, ChatSessionManager sessionManager,
			@Qualifier("inlineFormattingPolicy") PolicyFactory inlineFormattingPolicy) {
		this.chatDAO = chatDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.sessionManager = sessionManager;
		this.inlineFormattingPolicy = inlineFormattingPolicy;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String eventId = getEventId(session);

		if (user == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Authentifizierung erforderlich."));
			return;
		}

		if (eventId == null || !eventDAO.isUserAssociatedWithEvent(Integer.parseInt(eventId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Keine Berechtigung für diesen Event-Chat."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("eventId", eventId);
		sessionManager.addSession(eventId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) {
		User user = (User) session.getAttributes().get("user");
		String eventId = (String) session.getAttributes().get("eventId");
		if (user == null || eventId == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message.getPayload(), Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = inlineFormattingPolicy.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = inlineFormattingPolicy.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			EventChatMessage updatedMessage = chatDAO.getMessageById(messageId);
			if (updatedMessage == null)
				return;
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload", updatedMessage);
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			EventChatMessage deletedMessage = chatDAO.getMessageById(messageId);
			if (deletedMessage == null)
				return;
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload", deletedMessage);
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + event.getId()));
				notificationService.sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
		String eventId = (String) session.getAttributes().get("eventId");
		if (eventId != null) {
			sessionManager.removeSession(eventId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication) {
			Authentication auth = (Authentication) session.getPrincipal();
			if (auth.getPrincipal() instanceof SecurityUser) {
				return ((SecurityUser) auth.getPrincipal()).getUser();
			}
		}
		return null;
	}

	private String getEventId(WebSocketSession session) {
		// URI pattern is /ws/chat/{eventId}
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\WebSocketConfig.java
========================================================================

package de.technikteam.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	private final EventChatSocketHandler eventChatSocketHandler;
	private final ChatWebSocketHandler chatWebSocketHandler;
	private final ChecklistWebSocketHandler checklistWebSocketHandler;

	@Autowired
	public WebSocketConfig(EventChatSocketHandler eventChatSocketHandler, ChatWebSocketHandler chatWebSocketHandler,
			ChecklistWebSocketHandler checklistWebSocketHandler) {
		this.eventChatSocketHandler = eventChatSocketHandler;
		this.chatWebSocketHandler = chatWebSocketHandler;
		this.checklistWebSocketHandler = checklistWebSocketHandler;
	}

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(eventChatSocketHandler, "/ws/chat/{eventId}").setAllowedOrigins("*");
		registry.addHandler(chatWebSocketHandler, "/ws/dm/{conversationId}").setAllowedOrigins("*");
		registry.addHandler(checklistWebSocketHandler, "/ws/checklist/{eventId}").setAllowedOrigins("*");
	}
}
========================================================================
FILE: src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<!-- For development, use a human-readable pattern -->
			<!-- <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} 
				- %msg%n"/> -->

			<!-- For production/structured logging, use JSON Template Layout -->
			<JsonTemplateLayout
				eventTemplateUri="classpath:Log4j2JsonTemplate.json" />
		</Console>
	</Appenders>
	<Loggers>
		<Root level="info">
			<AppenderRef ref="Console" />
		</Root>
		<!-- Set a more verbose level for our application's packages during development -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
		</Logger>
	</Loggers>
</Configuration>