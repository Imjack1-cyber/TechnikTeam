
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
@MultipartConfig // CORRECTED: Added annotation for robust multipart request handling.
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);

	private final MeetingDAO meetingDAO;
	private final CourseDAO courseDAO;
	private final AttachmentDAO attachmentDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final Gson gson;

	@Inject
	public AdminMeetingServlet(MeetingDAO meetingDAO, CourseDAO courseDAO, AttachmentDAO attachmentDAO, UserDAO userDAO,
			AdminLogService adminLogService, ConfigurationService configService) {
		this.meetingDAO = meetingDAO;
		this.courseDAO = courseDAO;
		this.attachmentDAO = attachmentDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}
		String action = req.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			resp.sendRedirect(req.getContextPath() + "/admin/meetings");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();
		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);
		req.getRequestDispatcher("/views/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<Attachment> attachments = attachmentDAO.getAttachmentsForParent("MEETING", meetingId, "ADMIN");
				Map<String, Object> responseData = new HashMap<>();
				responseData.put("meetingData", meeting);
				responseData.put("attachmentsData", attachments);
				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(req.getParameter("name"));
			meeting.setDescription(req.getParameter("description"));
			meeting.setLocation(req.getParameter("location"));

			String leaderIdStr = req.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}
			String startDateTimeStr = req.getParameter("meetingDateTime");
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = req.getParameter("endDateTime");
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(req.getParameter("id"));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					adminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Meetings.");
				}
			} else {
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					adminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Erstellen des Meetings.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = req.getParameter("requiredRole");
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}
		} catch (DateTimeParseException | NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			adminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(configService.getProperty("upload.directory"), attachment.getFilepath());
			if (physicalFile.exists()) {
				physicalFile.delete();
			}
			if (attachmentDAO.deleteAttachment(attachmentId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
						+ "' von Meeting ID " + attachment.getParentId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = configService.getProperty("upload.directory") + File.separator + "meetings";
		new File(uploadDir).mkdirs();
		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());
		Attachment attachment = new Attachment();
		attachment.setParentId(meetingId);
		attachment.setParentType("MEETING");
		attachment.setFilename(fileName);
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			adminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminReportServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ReportDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class AdminReportServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminReportServlet.class);
	private final ReportDAO reportDAO;
	private final Gson gson = new Gson();

	@Inject
	public AdminReportServlet(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String reportType = request.getParameter("report");
		String exportType = request.getParameter("export");

		if (reportType != null && !reportType.isEmpty()) {
			handleSpecificReport(request, response, reportType, exportType);
			return;
		}

		List<Map<String, Object>> eventTrendData = reportDAO.getEventCountByMonth(12);
		List<Map<String, Object>> userActivityData = reportDAO.getUserParticipationStats(10);
		request.setAttribute("eventTrendDataJson", gson.toJson(eventTrendData));
		request.setAttribute("userActivityDataJson", gson.toJson(userActivityData));
		request.setAttribute("totalInventoryValue", reportDAO.getTotalInventoryValue());
		request.getRequestDispatcher("/views/admin/admin_reports.jsp").forward(request, response);
	}

	private void handleSpecificReport(HttpServletRequest request, HttpServletResponse response, String reportType,
			String exportType) throws IOException, ServletException {
		List<Map<String, Object>> reportData;
		String reportTitle;
		switch (reportType) {
		case "user_activity":
			reportData = reportDAO.getUserActivityStats();
			reportTitle = "Benutzeraktivitäts-Bericht";
			break;
		case "event_participation":
			reportData = reportDAO.getEventParticipationSummary();
			reportTitle = "Event-Teilnahme-Bericht";
			break;
		case "inventory_usage":
			reportData = reportDAO.getInventoryUsageFrequency();
			reportTitle = "Lagernutzungs-Bericht";
			break;
		default:
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Unbekannter Berichtstyp.");
			return;
		}

		if ("csv".equalsIgnoreCase(exportType)) {
			exportToCsv(response, reportData, reportType + "_report.csv");
		} else {
			request.setAttribute("reportData", reportData);
			request.setAttribute("reportTitle", reportTitle);
			request.getRequestDispatcher("/views/admin/report_display.jsp").forward(request, response);
		}
	}

	private void exportToCsv(HttpServletResponse response, List<Map<String, Object>> data, String filename)
			throws IOException {
		response.setContentType("text/csv");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
		if (data == null || data.isEmpty()) {
			response.getWriter().write("No data available to export.");
			return;
		}
		try (PrintWriter writer = response.getWriter()) {
			String header = String.join(",", data.get(0).keySet());
			writer.println(header);
			for (Map<String, Object> row : data) {
				String line = row.values().stream().map(this::escapeCsvField).collect(Collectors.joining(","));
				writer.println(line);
			}
		}
	}

	private String escapeCsvField(Object field) {
		if (field == null)
			return "";
		String fieldStr = field.toString();
		if (fieldStr.contains(",") || fieldStr.contains("\"") || fieldStr.contains("\n")) {
			return "\"" + fieldStr.replace("\"", "\"\"") + "\"";
		}
		return fieldStr;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.service.StorageService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.List;

@Singleton
@MultipartConfig // CORRECTED: Added annotation for robust multipart request handling.
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class);
	private final StorageDAO storageDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final StorageService storageService;
	private final Gson gson = new Gson();

	@Inject
	public AdminStorageServlet(StorageDAO storageDAO, MaintenanceLogDAO maintenanceLogDAO,
			AdminLogService adminLogService, ConfigurationService configService, StorageService storageService) {
		this.storageDAO = storageDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.storageService = storageService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		List<StorageItem> storageList = storageDAO.getAllItems();
		request.setAttribute("storageList", storageList);
		request.getRequestDispatcher("/views/admin/admin_storage_list.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response);
			break;
		case "delete":
			handleDelete(request, response);
			break;
		case "updateDefectStatus":
			handleDefectStatusUpdate(request, response);
			break;
		case "updateStatus":
			handleStatusUpdate(request, response);
			break;
		case "repair":
			handleRepair(request, response);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/lager");
			break;
		}
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(request.getParameter("action"));

		try {
			StorageItem item = new StorageItem();
			item.setName(request.getParameter("name"));
			item.setLocation(request.getParameter("location"));
			item.setCabinet(request.getParameter("cabinet"));
			item.setCompartment(request.getParameter("compartment"));
			item.setQuantity(Integer.parseInt(request.getParameter("quantity")));
			item.setMaxQuantity(Integer.parseInt(request.getParameter("maxQuantity")));
			String weightStr = request.getParameter("weight_kg");
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = request.getParameter("price_eur");
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(request.getParameter("id"));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
					item.setStatus(originalItem.getStatus());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(configService.getProperty("upload.directory"), "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				adminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDefectStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String status = request.getParameter("status"); // "DEFECT" or "UNREPAIRABLE"
			int quantity = Integer.parseInt(request.getParameter("quantity"));
			String reason = request.getParameter("reason");

			boolean success = storageService.updateDefectiveItemStatus(itemId, status, quantity, reason, adminUser);

			if (success) {
				request.getSession().setAttribute("successMessage", "Defekt-Status erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Status konnte nicht aktualisiert werden. Überprüfen Sie die Bestandsmengen.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(configService.getProperty("upload.directory"), "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String newStatus = request.getParameter("status");
			String notes = request.getParameter("notes");
			storageDAO.updateItemStatus(itemId, newStatus);
			MaintenanceLogEntry log = new MaintenanceLogEntry();
			log.setItemId(itemId);
			log.setUserId(adminUser.getId());
			log.setNotes(notes);
			String logAction = "MAINTENANCE".equals(newStatus) ? "Marked for Maintenance" : "Returned to Service";
			log.setAction(logAction);
			maintenanceLogDAO.createLog(log);
			adminLogService.log(adminUser.getUsername(), "UPDATE_ITEM_STATUS",
					"Status für Artikel-ID " + itemId + " auf '" + newStatus + "' gesetzt. Notiz: " + notes);
			request.getSession().setAttribute("successMessage", "Artikelstatus erfolgreich aktualisiert.");
		} catch (Exception e) {
			logger.error("Error updating item status", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Status.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleRepair(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int repairedQty = Integer.parseInt(request.getParameter("repaired_quantity"));
			String notes = request.getParameter("repair_notes");
			if (storageDAO.repairItems(itemId, repairedQty)) {
				MaintenanceLogEntry log = new MaintenanceLogEntry();
				log.setItemId(itemId);
				log.setUserId(adminUser.getId());
				log.setAction(repairedQty + " Stück repariert");
				log.setNotes(notes);
				maintenanceLogDAO.createLog(log);
				adminLogService.log(adminUser.getUsername(), "REPAIR_ITEM", String.format(
						"%d Stück von Artikel-ID %d als repariert markiert. Notiz: %s", repairedQty, itemId, notes));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich als repariert markiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Reparatur konnte nicht verbucht werden (vielleicht nicht genug defekte Artikel?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		}
		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import com.google.inject.Singleton;

@Singleton
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/admin/admin_system.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;
	private final Gson gson;

	@Inject
	public AdminUserServlet(UserDAO userDAO, EventDAO eventDAO, RoleDAO roleDAO, PermissionDAO permissionDAO) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		if (!currentUser.getPermissions().contains("USER_READ") && !currentUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			case "getUserData":
				getUserDataAsJson(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige ID angegeben.");
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<User> userList = userDAO.getAllUsers();
		List<Role> allRoles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			int underscoreIndex = key.indexOf('_');
			return (underscoreIndex != -1) ? key.substring(0, underscoreIndex) : "ALLGEMEIN";
		}, LinkedHashMap::new, Collectors.toList()));

		request.setAttribute("userList", userList);
		request.setAttribute("allRoles", allRoles);
		request.setAttribute("groupedPermissionsJson", gson.toJson(groupedPermissions));
		request.getRequestDispatcher("/views/admin/admin_users.jsp").forward(request, response);
	}

	private void getUserDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int userId = Integer.parseInt(req.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user != null) {
			Set<Integer> permissionIds = permissionDAO.getPermissionIdsForUser(userId);
			Map<String, Object> responseData = new HashMap<>();
			responseData.put("user", user);
			responseData.put("permissionIds", permissionIds);

			String userJson = gson.toJson(responseData);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(userJson);
		} else {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
		}
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);
		request.setAttribute("userToView", user);
		request.setAttribute("eventHistory", eventHistory);
		request.getRequestDispatcher("/views/admin/admin_user_details.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminWikiDetailsServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.Permissions;
import de.technikteam.model.User;
import de.technikteam.service.WikiService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class AdminWikiDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminWikiDetailsServlet.class);

	private final WikiService wikiService;

	@Inject
	public AdminWikiDetailsServlet(WikiService wikiService) {
		this.wikiService = wikiService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		if (user == null || !user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL)) {
			logger.warn("Unauthorized access attempt to admin wiki details by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "You do not have permission to view this page.");
			return;
		}

		String filePath = request.getParameter("file");
		if (filePath == null || filePath.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "File parameter is missing.");
			return;
		}

		String wikiContent = wikiService.getFileDocumentation(filePath);

		request.setAttribute("filePath", filePath);
		request.setAttribute("wikiContent", wikiContent);
		request.getRequestDispatcher("/views/admin/admin_wiki_details.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminWikiServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.Permissions;
import de.technikteam.model.User;
import de.technikteam.service.WikiService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class AdminWikiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminWikiServlet.class);

	private final WikiService wikiService;

	@Inject
	public AdminWikiServlet(WikiService wikiService) {
		this.wikiService = wikiService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		if (user == null || !user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL)) {
			logger.warn("Unauthorized access attempt to admin wiki by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "You do not have permission to view this page.");
			return;
		}

		request.setAttribute("projectTreeHtml", wikiService.getProjectTreeHtml());
		request.getRequestDispatcher("/views/admin/admin_wiki_index.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\FrontControllerServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.servlet.admin.action.*;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Singleton
// CORRECTED: Removed @MultipartConfig as no actions handled by this controller process file uploads.
public class FrontControllerServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FrontControllerServlet.class);
	private final Map<String, Action> actions = new HashMap<>();
	private final Gson gson;

	@Inject
	public FrontControllerServlet(CreateUserAction createUserAction, UpdateUserAction updateUserAction,
			DeleteUserAction deleteUserAction, ResetPasswordAction resetPasswordAction,
			UnlockUserAction unlockUserAction, ApproveChangeAction approveChangeAction,
			DenyChangeAction denyChangeAction, UpdateFeedbackStatusAction updateFeedbackStatusAction,
			UpdateFeedbackOrderAction updateFeedbackOrderAction, DeleteFeedbackAction deleteFeedbackAction,
			GetFeedbackDetailsAction getFeedbackDetailsAction) {

		actions.put("user.create", createUserAction);
		actions.put("user.update", updateUserAction);
		actions.put("user.delete", deleteUserAction);
		actions.put("user.resetPassword", resetPasswordAction);
		actions.put("user.unlock", unlockUserAction);
		actions.put("request.approve", approveChangeAction);
		actions.put("request.deny", denyChangeAction);
		actions.put("feedback.updateStatus", updateFeedbackStatusAction);
		actions.put("feedback.reorder", updateFeedbackOrderAction);
		actions.put("feedback.delete", deleteFeedbackAction);
		actions.put("feedback.getDetails", getFeedbackDetailsAction);

		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String pathInfo = request.getPathInfo();
		String actionName = request.getParameter("action");

		if (pathInfo == null || pathInfo.equals("/") || actionName == null || actionName.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid action request.");
			return;
		}

		String entity = pathInfo.substring(1);
		String actionKey = entity + "." + actionName;

		Action action = actions.get(actionKey);

		if (action == null) {
			logger.error("No action found for key: '{}'", actionKey);
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Action not found.");
			return;
		}

		logger.debug("Executing action for key: '{}'", actionKey);
		ApiResponse apiResponse = action.execute(request, response);

		if (apiResponse == null) {
			return;
		}

		if (apiResponse.isSuccess()) {
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
		}

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		try (PrintWriter out = response.getWriter()) {
			out.print(gson.toJson(apiResponse));
			out.flush();
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Singleton
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;

	@Inject
	public MatrixServlet(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		request.getRequestDispatcher("/views/admin/admin_matrix.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\Action.java
========================================================================

package de.technikteam.servlet.admin.action;

import de.technikteam.model.ApiResponse;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

/**
 * Represents a single, executable action within the Front Controller pattern.
 * Each implementation handles a specific business operation and returns a standardized API response.
 */
public interface Action {

	/**
	 * Executes the business logic for a specific action.
	 *
	 * @param request  The HttpServletRequest object.
	 * @param response The HttpServletResponse object.
	 * @return An ApiResponse object containing the result of the action (success/fail, message, data).
	 * @throws ServletException If a servlet-specific error occurs.
	 * @throws IOException      If an I/O error occurs.
	 */
	ApiResponse execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\ApproveChangeAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.servlet.http.SessionManager;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.Map;

@Singleton
public class ApproveChangeAction implements Action {
	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final Gson gson = new Gson();

	@Inject
	public ApproveChangeAction(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int requestId = Integer.parseInt(request.getParameter("requestId"));
			ProfileChangeRequest req = requestDAO.getRequestById(requestId);
			if (req == null || !"PENDING".equals(req.getStatus())) {
				return ApiResponse.error("Anfrage nicht gefunden oder bereits bearbeitet.");
			}

			User userToUpdate = userDAO.getUserById(req.getUserId());
			if (userToUpdate == null) {
				requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
				return ApiResponse.error("Der zugehörige Benutzer existiert nicht mehr. Anfrage abgelehnt.");
			}

			Type type = new TypeToken<Map<String, String>>() {
			}.getType();
			Map<String, String> changes = gson.fromJson(req.getRequestedChanges(), type);

			changes.forEach((field, value) -> {
				switch (field) {
				case "email":
					userToUpdate.setEmail(value);
					break;
				case "classYear":
					userToUpdate.setClassYear(Integer.parseInt(value));
					break;
				case "className":
					userToUpdate.setClassName(value);
					break;
				}
			});

			// CORRECTED: Call the version of updateUser that does not require a Connection
			// object.
			if (userDAO.updateUser(userToUpdate)
					&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED", "Profiländerung für '"
						+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") genehmigt.");

				String notificationMessage = "Ihre Profiländerung wurde genehmigt. Sie werden zur Sicherheit abgemeldet. Bitte loggen Sie sich erneut ein.";
				Map<String, Object> payload = Map.of("type", "logout_notification", "payload",
						Map.of("message", notificationMessage));
				NotificationService.getInstance().sendNotificationToUser(userToUpdate.getId(), payload);

				SessionManager.invalidateSessionsForUser(userToUpdate.getId());

				return ApiResponse.success("Änderungsanfrage genehmigt.", Map.of("requestId", requestId));
			} else {
				return ApiResponse.error("Fehler beim Anwenden der Änderungen oder beim Aktualisieren der Anfrage.");
			}

		} catch (Exception e) {
			return ApiResponse.error("Ein interner Fehler ist aufgetreten: " + e.getMessage());
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\CreateUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import de.technikteam.util.PasswordPolicyValidator;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;

@Singleton
public class CreateUserAction implements Action {

	private final UserService userService;
	private final RoleDAO roleDAO;

	@Inject
	public CreateUserAction(UserService userService, RoleDAO roleDAO) {
		this.userService = userService;
		this.roleDAO = roleDAO;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_CREATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		String username = request.getParameter("username");
		String pass = request.getParameter("password");

		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator.validate(pass);
		if (!validationResult.isValid()) {
			return ApiResponse.error("Fehler beim Erstellen des Benutzers: " + validationResult.getMessage());
		}

		int roleId = Integer.parseInt(request.getParameter("roleId"));
		String[] permissionIds = request.getParameterValues("permissionIds");

		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRoleId(roleId);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0);
		}
		newUser.setClassName(request.getParameter("className"));

		String email = request.getParameter("email");
		newUser.setEmail(email != null && !email.trim().isEmpty() ? email.trim() : null);

		int newUserId = userService.createUserWithPermissions(newUser, pass, permissionIds, adminUser.getUsername());
		if (newUserId > 0) {
			newUser.setId(newUserId);
			// Enrich with role name for the JSON response
			roleDAO.getAllRoles().stream().filter(role -> role.getId() == newUser.getRoleId()).findFirst()
					.ifPresent(role -> newUser.setRoleName(role.getRoleName()));

			return ApiResponse.success("Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.", newUser);
		} else {
			return ApiResponse
					.error("Benutzer konnte nicht erstellt werden (ggf. existiert der Name oder die E-Mail bereits).");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DeleteFeedbackAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DeleteFeedbackAction implements Action {
	private final FeedbackSubmissionDAO submissionDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DeleteFeedbackAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService) {
		this.submissionDAO = submissionDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			if (submissionDAO.deleteSubmission(submissionId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_FEEDBACK",
						"Feedback-Eintrag mit ID " + submissionId + " gelöscht.");
				NotificationService.getInstance().broadcastUIUpdate("feedback_deleted",
						Map.of("submissionId", submissionId));
				return ApiResponse.success("Feedback erfolgreich gelöscht.", Map.of("deletedId", submissionId));
			} else {
				return ApiResponse.error("Fehler beim Löschen des Feedbacks.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DeleteUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DeleteUserAction implements Action {
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DeleteUserAction(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) session.getAttribute("user");

		if (!loggedInAdmin.getPermissions().contains("USER_DELETE") && !loggedInAdmin.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		if (loggedInAdmin.getId() == userIdToDelete) {
			return ApiResponse.error("Sie können sich nicht selbst löschen.");
		}

		User userToDelete = userDAO.getUserById(userIdToDelete);
		if (userToDelete == null) {
			return ApiResponse.error("Benutzer mit ID " + userIdToDelete + " nicht gefunden.");
		}

		if (userToDelete.getPermissions().contains("ACCESS_ADMIN_PANEL")
				&& !loggedInAdmin.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			return ApiResponse.error("Sie haben keine Berechtigung, einen Haupt-Administrator zu löschen.");
		}

		String deletedUsername = userToDelete.getUsername();
		String deletedRoleName = userToDelete.getRoleName();

		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.", deletedUsername,
					userIdToDelete, deletedRoleName);
			adminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);

			NotificationService.getInstance().broadcastUIUpdate("user_deleted", Map.of("userId", userIdToDelete));

			return ApiResponse.success("Benutzer erfolgreich gelöscht.", Map.of("deletedUserId", userIdToDelete));
		} else {
			return ApiResponse.error("Benutzer konnte nicht gelöscht werden.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DenyChangeAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DenyChangeAction implements Action {
	private final ProfileChangeRequestDAO requestDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DenyChangeAction(ProfileChangeRequestDAO requestDAO, AdminLogService adminLogService) {
		this.requestDAO = requestDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int requestId = Integer.parseInt(request.getParameter("requestId"));
			ProfileChangeRequest req = requestDAO.getRequestById(requestId);
			if (req == null || !"PENDING".equals(req.getStatus())) {
				return ApiResponse.error("Anfrage nicht gefunden oder bereits bearbeitet.");
			}

			if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED", "Profiländerung für Benutzer-ID "
						+ req.getUserId() + " (Request ID: " + requestId + ") abgelehnt.");
				return ApiResponse.success("Änderungsanfrage abgelehnt.", Map.of("requestId", requestId));
			} else {
				return ApiResponse.error("Fehler beim Ablehnen der Anfrage.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Anfrage-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\GetFeedbackDetailsAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class GetFeedbackDetailsAction implements Action {

	private final FeedbackSubmissionDAO submissionDAO;

	@Inject
	public GetFeedbackDetailsAction(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			FeedbackSubmission submission = submissionDAO.getSubmissionById(submissionId);
			if (submission != null) {
				return ApiResponse.success("Details erfolgreich geladen.", submission);
			} else {
				return ApiResponse.error("Feedback-Eintrag nicht gefunden.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\ResetPasswordAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class ResetPasswordAction implements Action {

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Inject
	public ResetPasswordAction(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_PASSWORD_RESET") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		int userId = Integer.parseInt(request.getParameter("userId"));
		User userToReset = userDAO.getUserById(userId);

		if (userToReset == null) {
			return ApiResponse.error("Benutzer zum Zurücksetzen nicht gefunden.");
		} else {
			String newPassword = generateRandomPassword(12);
			if (userDAO.changePassword(userId, newPassword)) {
				String logDetails = String.format("Passwort für Benutzer '%s' (ID: %d) zurückgesetzt.",
						userToReset.getUsername(), userId);
				adminLogService.log(adminUser.getUsername(), "RESET_PASSWORD", logDetails);

				return ApiResponse.success(
						"Passwort für " + userToReset.getUsername() + " zurückgesetzt auf: " + newPassword,
						Map.of("username", userToReset.getUsername(), "newPassword", newPassword));
			} else {
				return ApiResponse.error("Passwort konnte nicht zurückgesetzt werden.");
			}
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UnlockUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.servlet.LoginServlet;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Map;

@Singleton
public class UnlockUserAction implements Action {

	private final AdminLogService adminLogService;

	@Inject
	public UnlockUserAction(AdminLogService adminLogService) {
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.hasAdminAccess()) { // Only admins can unlock
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		String usernameToUnlock = request.getParameter("username");
		if (usernameToUnlock != null && !usernameToUnlock.isEmpty()) {
			LoginServlet.LoginAttemptManager.clearLoginAttempts(usernameToUnlock);
			adminLogService.log(adminUser.getUsername(), "UNLOCK_USER_ACCOUNT",
					"Benutzerkonto '" + usernameToUnlock + "' manuell entsperrt.");
			return ApiResponse.success("Benutzerkonto '" + usernameToUnlock + "' wurde erfolgreich entsperrt.",
					Map.of("unlockedUsername", usernameToUnlock));
		} else {
			return ApiResponse.error("Benutzername zum Entsperren wurde nicht angegeben.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateFeedbackOrderAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.DatabaseManager;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class UpdateFeedbackOrderAction implements Action {
    private static final Logger logger = LogManager.getLogger(UpdateFeedbackOrderAction.class);
    private final FeedbackSubmissionDAO submissionDAO;
    private final AdminLogService adminLogService;
    private final DatabaseManager dbManager;
    private final Gson gson = new Gson();

    @Inject
    public UpdateFeedbackOrderAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService, DatabaseManager dbManager) {
        this.submissionDAO = submissionDAO;
        this.adminLogService = adminLogService;
        this.dbManager = dbManager;
    }

    @Override
    public ApiResponse execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        User adminUser = (User) request.getSession().getAttribute("user");
        if (!adminUser.hasAdminAccess()) {
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
            return null;
        }

        String jsonPayload = request.getParameter("reorderData");
        if (jsonPayload == null) {
            return ApiResponse.error("Missing reorder data.");
        }

        try (Connection conn = dbManager.getConnection()) {
            conn.setAutoCommit(false);
            try {
                Type type = new TypeToken<Map<String, Object>>() {}.getType();
                Map<String, Object> data = gson.fromJson(jsonPayload, type);
                
                int submissionId = (int) Double.parseDouble(String.valueOf(data.get("submissionId")));
                String newStatus = (String) data.get("newStatus");

                @SuppressWarnings("unchecked")
                List<Double> orderedIdsDouble = (List<Double>) data.get("orderedIds");
                if (orderedIdsDouble == null) {
                	throw new IllegalArgumentException("orderedIds list is missing in the payload.");
                }
                List<Integer> orderedIds = orderedIdsDouble.stream().map(Double::intValue).collect(Collectors.toList());

                // 1. Update the status of the moved item
                submissionDAO.updateStatus(submissionId, newStatus, conn);

                // 2. Update the display order for all items in that column
                submissionDAO.updateOrderForStatus(orderedIds, conn);
                
                conn.commit();
                
                adminLogService.log(adminUser.getUsername(), "UPDATE_FEEDBACK_ORDER",
						"Feedback ID " + submissionId + " status auf '" + newStatus + "' gesetzt und Liste neu sortiert.");
                return ApiResponse.success("Feedback-Status und Sortierung aktualisiert.");
                
            } catch (Exception e) {
                conn.rollback();
                throw e; // Re-throw to be caught by the outer catch block
            }
        } catch (Exception e) {
            logger.error("Error processing feedback reorder request", e);
            return ApiResponse.error("Serverfehler beim Verarbeiten der Anfrage: " + e.getMessage());
        }
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateFeedbackStatusAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class UpdateFeedbackStatusAction implements Action {
	private final FeedbackSubmissionDAO submissionDAO;
	private final AdminLogService adminLogService;

	@Inject
	public UpdateFeedbackStatusAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService) {
		this.submissionDAO = submissionDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			String newStatus = request.getParameter("status");
			String displayTitle = request.getParameter("displayTitle");

			if (submissionDAO.updateStatusAndTitle(submissionId, newStatus, displayTitle)) {
				adminLogService.log(adminUser.getUsername(), "UPDATE_FEEDBACK_STATUS",
						"Status für Feedback ID " + submissionId + " auf '" + newStatus + "' gesetzt.");

				NotificationService.getInstance().broadcastUIUpdate("feedback_status_updated",
						Map.of("submissionId", submissionId, "newStatus", newStatus, "displayTitle", displayTitle));

				return ApiResponse.success("Status erfolgreich aktualisiert.");
			} else {
				return ApiResponse.error("Fehler beim Aktualisieren des Status.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.service.UserService;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Objects;

@Singleton
public class UpdateUserAction implements Action {
	private final UserDAO userDAO;
	private final RoleDAO roleDAO;
	private final UserService userService;
	private final AdminLogService adminLogService;

	@Inject
	public UpdateUserAction(UserDAO userDAO, RoleDAO roleDAO, UserService userService,
			AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.roleDAO = roleDAO;
		this.userService = userService;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		int userId = Integer.parseInt(request.getParameter("userId"));
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		User originalUser = userDAO.getUserById(userId);
		if (originalUser == null) {
			return ApiResponse.error("Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
		}

		// Capture changes for logging
		StringBuilder changes = new StringBuilder();

		User updatedUser = new User();
		updatedUser.setId(userId);

		String newUsername = request.getParameter("username").trim();
		if (!Objects.equals(originalUser.getUsername(), newUsername)) {
			changes.append(String.format("Benutzername von '%s' zu '%s', ", originalUser.getUsername(), newUsername));
		}
		updatedUser.setUsername(newUsername);

		int roleId = Integer.parseInt(request.getParameter("roleId"));
		if (originalUser.getRoleId() != roleId) {
			changes.append(String.format("Rolle-ID von '%d' zu '%d', ", originalUser.getRoleId(), roleId));
		}
		updatedUser.setRoleId(roleId);

		String newClassName = request.getParameter("className");
		if (!Objects.equals(originalUser.getClassName(), newClassName)) {
			changes.append(String.format("Klasse von '%s' zu '%s', ", originalUser.getClassName(), newClassName));
		}
		updatedUser.setClassName(newClassName);

		String newEmail = request.getParameter("email");
		newEmail = (newEmail != null && !newEmail.trim().isEmpty()) ? newEmail.trim() : null;
		if (!Objects.equals(originalUser.getEmail(), newEmail)) {
			changes.append("E-Mail geändert, ");
		}
		updatedUser.setEmail(newEmail);

		try {
			int newClassYear = Integer.parseInt(request.getParameter("classYear"));
			if (originalUser.getClassYear() != newClassYear) {
				changes.append(String.format("Jahrgang von '%d' zu '%d', ", originalUser.getClassYear(), newClassYear));
			}
			updatedUser.setClassYear(newClassYear);
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		String[] permissionIds = request.getParameterValues("permissionIds");

		boolean success = userService.updateUserWithPermissions(updatedUser, permissionIds);

		if (success) {
			User refreshedUser = userDAO.getUserById(userId);
			roleDAO.getAllRoles().stream().filter(role -> role.getId() == refreshedUser.getRoleId()).findFirst()
					.ifPresent(role -> refreshedUser.setRoleName(role.getRoleName()));

			if (adminUser.getId() == userId) {
				refreshedUser.setPermissions(userDAO.getPermissionsForUser(userId));
				session.setAttribute("user", refreshedUser);
				session.setAttribute("navigationItems", NavigationRegistry.getNavigationItemsForUser(refreshedUser));
			}

			String logDetails = String.format("Benutzer '%s' (ID: %d) aktualisiert.", originalUser.getUsername(),
					userId);
			if (changes.length() > 2) {
				logDetails += " Änderungen: " + changes.substring(0, changes.length() - 2) + ".";
			}

			adminLogService.log(adminUser.getUsername(), "UPDATE_USER", logDetails);

			NotificationService.getInstance().broadcastUIUpdate("user_updated", refreshedUser);

			return ApiResponse.success("Benutzerdaten erfolgreich aktualisiert.", refreshedUser);
		} else {
			return ApiResponse
					.error("Keine Änderungen an den Benutzerdaten vorgenommen oder ein Fehler ist aufgetreten.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\api\AdminTodoApiServlet.java
========================================================================

package de.technikteam.servlet.admin.api;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import de.technikteam.service.TodoService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class AdminTodoApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final TodoService todoService;
	private final Gson gson = new Gson();

	@Inject
	public AdminTodoApiServlet(TodoService todoService) {
		this.todoService = todoService;
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		List<TodoCategory> todos = todoService.getAllTodos();
		sendJsonResponse(resp, HttpServletResponse.SC_OK, todos);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");

		switch (action) {
		case "createCategory":
			String categoryName = req.getParameter("name");
			TodoCategory newCategory = todoService.createCategory(categoryName, admin);
			if (newCategory != null) {
				sendJsonResponse(resp, HttpServletResponse.SC_CREATED,
						ApiResponse.success("Kategorie erstellt.", newCategory));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Kategorie konnte nicht erstellt werden."));
			}
			break;
		case "createTask":
			int categoryId = Integer.parseInt(req.getParameter("categoryId"));
			String content = req.getParameter("content");
			TodoTask newTask = todoService.createTask(categoryId, content, admin);
			if (newTask != null) {
				sendJsonResponse(resp, HttpServletResponse.SC_CREATED,
						ApiResponse.success("Aufgabe erstellt.", newTask));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht erstellt werden."));
			}
			break;
		default:
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Unbekannte Aktion."));
		}
	}

	@Override
	protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");
		String jsonPayload = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		Type type = new TypeToken<Map<String, Object>>() {
		}.getType();
		Map<String, Object> data = gson.fromJson(jsonPayload, type);
		String action = (String) data.get("action");

		switch (action) {
		case "updateTask":
			int taskId = ((Double) data.get("taskId")).intValue();
			String content = (String) data.get("content");
			Boolean isCompleted = (Boolean) data.get("isCompleted");
			if (todoService.updateTask(taskId, content, isCompleted, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Aufgabe aktualisiert."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht aktualisiert werden."));
			}
			break;
		case "reorder":
			Type reorderType = new TypeToken<Map<String, List<Integer>>>() {
			}.getType();
			Map<String, List<Integer>> reorderData = gson.fromJson(gson.toJson(data.get("orderData")), reorderType);
			if (todoService.reorder(reorderData, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Sortierung gespeichert."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Sortierung konnte nicht gespeichert werden."));
			}
			break;
		default:
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Unbekannte Aktion."));
		}
	}

	@Override
	protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");

		if (req.getParameter("taskId") != null) {
			int taskId = Integer.parseInt(req.getParameter("taskId"));
			if (todoService.deleteTask(taskId, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Aufgabe gelöscht."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht gelöscht werden."));
			}
		} else if (req.getParameter("categoryId") != null) {
			int categoryId = Integer.parseInt(req.getParameter("categoryId"));
			if (todoService.deleteCategory(categoryId, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Kategorie gelöscht."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Kategorie konnte nicht gelöscht werden."));
			}
		} else {
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Keine ID angegeben."));
		}
	}

	private void sendJsonResponse(HttpServletResponse response, int status, Object data) throws IOException {
		response.setStatus(status);
		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(gson.toJson(data));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\api\CrewFinderApiServlet.java
========================================================================

package de.technikteam.servlet.admin.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class CrewFinderApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(CrewFinderApiServlet.class);
	private final EventDAO eventDAO;
	private final Gson gson;

	@Inject
	public CrewFinderApiServlet(EventDAO eventDAO) {
		this.eventDAO = eventDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		String eventIdParam = request.getParameter("eventId");

		if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing eventId parameter.");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			Event event = eventDAO.getEventById(eventId);
			if (event == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event not found.");
				return;
			}

			boolean hasPermission = currentUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS")
					|| currentUser.hasAdminAccess() || currentUser.getId() == event.getLeaderUserId();

			if (!hasPermission) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}

			List<User> qualifiedUsers = eventDAO.getQualifiedAndAvailableUsersForEvent(eventId);
			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(gson.toJson(qualifiedUsers));

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid eventId format.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\AdminDashboardApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.DashboardDataDTO;
import de.technikteam.service.AdminDashboardService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;

@Singleton
public class AdminDashboardApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final AdminDashboardService dashboardService;
	private final Gson gson;

	@Inject
	public AdminDashboardApiServlet(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		DashboardDataDTO data = dashboardService.getDashboardData();
		String jsonResponse = gson.toJson(data);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\MarkdownApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class MarkdownApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MarkdownApiServlet.class);
	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;

	@Inject
	public MarkdownApiServlet(FileDAO fileDAO, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "User not authenticated.");
			return;
		}

		User user = (User) session.getAttribute("user");
		if (!user.getPermissions().contains("FILE_UPDATE") && !user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			logger.warn("User '{}' tried to save markdown file without FILE_UPDATE permission.", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token.");
			return;
		}

		String fileIdParam = request.getParameter("fileId");
		String content = request.getParameter("content");

		if (fileIdParam == null || content == null) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required parameters.");
			return;
		}

		try {
			int fileId = Integer.parseInt(fileIdParam);
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);

			if (dbFile == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "File not found.");
				return;
			}

			boolean contentUpdated = fileDAO.updateFileContent(dbFile.getFilepath(), content);
			boolean recordTouched = fileDAO.touchFileRecord(fileId);

			if (contentUpdated && recordTouched) {
				adminLogService.log(user.getUsername(), "UPDATE_MARKDOWN_FILE",
						"Inhalt der Datei '" + dbFile.getFilename() + "' (ID: " + fileId + ") aktualisiert.");
				session.setAttribute("successMessage", "Änderungen erfolgreich gespeichert.");
			} else {
				session.setAttribute("errorMessage", "Fehler beim Speichern der Datei.");
			}

			response.sendRedirect(request.getContextPath() + "/editor?fileId=" + fileId);

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid fileId format.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\StorageHistoryApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class StorageHistoryApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageHistoryApiServlet.class);
	private final StorageLogDAO logDAO;
	private final Gson gson;

	@Inject
	public StorageHistoryApiServlet(StorageLogDAO logDAO) {
		this.logDAO = logDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			logger.debug("API request for storage history for item ID: {}", itemId);
			List<StorageLogEntry> history = logDAO.getHistoryForItem(itemId);

			String jsonResponse = gson.toJson(history);
			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);

		} catch (NumberFormatException e) {
			logger.warn("Bad request to storage history API: invalid or missing itemId");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing itemId.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\SystemStatsApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class SystemStatsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final SystemInfoService systemInfoService;
	private final Gson gson;

	@Inject
	public SystemStatsApiServlet(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
		this.gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		String jsonResponse = gson.toJson(stats);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\UserPreferencesApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Set;

@Singleton
public class UserPreferencesApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(UserPreferencesApiServlet.class);
	private static final Set<String> VALID_THEMES = Set.of("light", "dark");
	private final UserDAO userDAO;

	@Inject
	public UserPreferencesApiServlet(UserDAO userDAO) {
		this.userDAO = userDAO;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "User not authenticated.");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token.");
			return;
		}

		User user = (User) session.getAttribute("user");
		String theme = request.getParameter("theme");

		if (theme == null || !VALID_THEMES.contains(theme)) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid theme value.");
			return;
		}

		if (userDAO.updateUserTheme(user.getId(), theme)) {
			user.setTheme(theme);
			session.setAttribute("user", user);
			logger.info("Updated theme for user '{}' to '{}'.", user.getUsername(), theme);
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update theme for user '{}' in database.", user.getUsername());
			response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Could not save theme preference.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\AuthenticationFinishServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
public class AuthenticationFinishServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;
	private final Gson gson;

	@Inject
	public AuthenticationFinishServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String credentialJson = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

		User user = passkeyService.finishAuthentication(credentialJson);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");

		if (user != null) {
			HttpSession session = request.getSession(true);
			session.setAttribute("user", user);
			CSRFUtil.storeToken(session);
			List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(user);
			session.setAttribute("navigationItems", navigationItems);

			response.getWriter().write(gson.toJson(ApiResponse.success("Login successful!", user)));
		} else {
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			response.getWriter().write(gson.toJson(ApiResponse.error("Passkey authentication failed.")));
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\AuthenticationStartServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class AuthenticationStartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;

	@Inject
	public AuthenticationStartServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String username = request.getParameter("username");
		String challengeJson = passkeyService.startAuthentication(username);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(challengeJson);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\RegistrationFinishServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@Singleton
public class RegistrationFinishServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;
	private final Gson gson;

	@Inject
	public RegistrationFinishServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		String deviceName = request.getParameter("deviceName");
		String credentialJson = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

		boolean success = passkeyService.finishRegistration(user.getId(), credentialJson, deviceName);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");

		if (success) {
			response.getWriter().write(gson.toJson(ApiResponse.success("Device registered successfully!")));
		} else {
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
			response.getWriter().write(gson.toJson(ApiResponse.error("Failed to register device.")));
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\RegistrationStartServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class RegistrationStartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;

	@Inject
	public RegistrationStartServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		String challengeJson = passkeyService.startRegistration(user);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(challengeJson);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\http\SessionManager.java
========================================================================

package de.technikteam.servlet.http;

import jakarta.servlet.http.HttpSession;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * A simple, centralized manager for active HttpSession objects. This allows
 * other parts of the application to find and invalidate a specific user's
 * session.
 */
public class SessionManager {

	private static final Map<String, HttpSession> SESSIONS = new ConcurrentHashMap<>();

	public static void addSession(HttpSession session) {
		SESSIONS.put(session.getId(), session);
	}

	public static void removeSession(HttpSession session) {
		SESSIONS.remove(session.getId());
	}

	/**
	 * Finds and invalidates all active sessions for a given user ID. This is useful
	 * for forcing a user to re-authenticate after critical profile changes.
	 * 
	 * @param userId The ID of the user whose sessions should be invalidated.
	 */
	public static void invalidateSessionsForUser(int userId) {
		SESSIONS.values().stream().filter(session -> {
			try {
				de.technikteam.model.User user = (de.technikteam.model.User) session.getAttribute("user");
				return user != null && user.getId() == userId;
			} catch (IllegalStateException e) {
				// Session might already be invalid, safe to ignore and remove
				return false;
			}
		}).forEach(session -> {
			try {
				session.invalidate();
			} catch (IllegalStateException e) {
				// Session was already invalidated, no action needed
			}
		});
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\CSRFUtil.java
========================================================================

package de.technikteam.util;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.security.SecureRandom;
import java.util.Base64;
import java.util.Objects;

/**
 * A utility class for Cross-Site Request Forgery (CSRF) protection. It provides
 * methods to generate, store, and validate session-bound tokens.
 */
public final class CSRFUtil {

	private static final Logger logger = LogManager.getLogger(CSRFUtil.class);
	private static final String CSRF_TOKEN_SESSION_ATTR = "csrfToken";
	private static final String CSRF_TOKEN_PARAM_NAME = "csrfToken";

	private CSRFUtil() {
	}

	public static void storeToken(HttpSession session) {
		if (session != null) {
			String token = generateToken();
			session.setAttribute(CSRF_TOKEN_SESSION_ATTR, token);
			logger.trace("Stored new CSRF token in session {}", session.getId());
		}
	}

	private static String generateToken() {
		SecureRandom random = new SecureRandom();
		byte[] tokenBytes = new byte[32];
		random.nextBytes(tokenBytes);
		return Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
	}

	/**
	 * Validates the CSRF token from a request parameter against the one stored in
	 * the session. This method is intended for standard
	 * 'application/x-www-form-urlencoded' requests. For multipart requests, the
	 * token must be extracted manually first by the servlet.
	 *
	 * @param request The HttpServletRequest containing the token.
	 * @return true if the token is valid and matches the session token, false
	 *         otherwise.
	 */
	public static boolean isTokenValid(HttpServletRequest request) {
		String requestToken = request.getParameter(CSRF_TOKEN_PARAM_NAME);
		return isTokenValid(request.getSession(false), requestToken);
	}

	/**
	 * Validates a given request token against the one stored in the session. This
	 * is the primary validation method, useful for multipart requests where the
	 * token is extracted manually by the servlet.
	 *
	 * @param session      The current HttpSession.
	 * @param requestToken The token submitted with the request.
	 * @return true if the token is valid and matches the session token, false
	 *         otherwise.
	 */
	public static boolean isTokenValid(HttpSession session, String requestToken) {
		if (session == null) {
			logger.warn("CSRF check failed: No session exists.");
			return false;
		}

		String sessionToken = (String) session.getAttribute(CSRF_TOKEN_SESSION_ATTR);

		if (sessionToken == null || requestToken == null || requestToken.isEmpty()) {
			logger.warn(
					"CSRF check failed: Session or request token is missing. Session-Token-Present: {}, Request-Token-Present: {}",
					sessionToken != null, requestToken != null && !requestToken.isEmpty());
			return false;
		}

		boolean isValid = Objects.equals(sessionToken, requestToken);
		if (!isValid) {
			logger.warn("CSRF token mismatch! Session: [{}], Request: [{}]", sessionToken, requestToken);
		}

		return isValid;
	}

	public static String getCsrfInputField(HttpSession session) {
		if (session != null) {
			String token = (String) session.getAttribute(CSRF_TOKEN_SESSION_ATTR);
			if (token != null) {
				return "<input type=\"hidden\" name=\"" + CSRF_TOKEN_PARAM_NAME + "\" value=\"" + token + "\">";
			}
		}
		return "";
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

import java.util.regex.Pattern;

/**
 * A utility class for sanitizing user-provided Markdown content to prevent
 * Cross-Site Scripting (XSS) attacks. It strips dangerous HTML tags and
 * attributes before the content is stored or rendered.
 */
public final class MarkdownUtil {

    // Pattern to find and remove <script>...</script> blocks, case-insensitive and multiline.
    private static final Pattern SCRIPT_PATTERN = Pattern.compile("<script.*?>.*?</script>",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);

    // Pattern to find and remove attributes like onclick, onmouseover, etc.
    private static final Pattern ON_ATTRIBUTE_PATTERN = Pattern.compile("\\s(on\\w+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|[^\\s>]+)",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    // Pattern to find and remove href/src attributes with "javascript:..." URIs.
    private static final Pattern JAVASCRIPT_URI_PATTERN = Pattern.compile("(href|src)\\s*=\\s*(\"|')\\s*javascript:",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    /**
     * Private constructor to prevent instantiation of this utility class.
     */
    private MarkdownUtil() {
    }

    /**
     * Sanitizes a string containing Markdown and potentially malicious HTML. This
     * method should be called on any user-supplied content before it is stored in
     * the database or broadcast to other clients.
     *
     * @param markdown The raw Markdown string from the user.
     * @return A sanitized string with dangerous HTML elements and attributes removed.
     */
    public static String sanitize(String markdown) {
        if (markdown == null || markdown.isEmpty()) {
            return markdown;
        }

        String sanitized = markdown;

        // Remove <script> tags completely
        sanitized = SCRIPT_PATTERN.matcher(sanitized).replaceAll("");

        // Remove on... attributes (onclick, onmouseover, etc.)
        sanitized = ON_ATTRIBUTE_PATTERN.matcher(sanitized).replaceAll("");

        // Remove javascript:... in href/src attributes
        sanitized = JAVASCRIPT_URI_PATTERN.matcher(sanitized).replaceAll("$1='#'");

        return sanitized;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();

	// Defines all possible navigation links, their icons, and the permission
	// required to see them.
	// A null permission means the link is public to all authenticated users.
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Mein Feedback", "/my-feedback", "fa-comment-dots", null));
		ALL_ITEMS.add(new NavigationItem("Feedback geben", "/feedback", "fa-lightbulb", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(new NavigationItem("Anträge", "/admin/requests", "fa-inbox", Permissions.USER_UPDATE));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/admin/dateien", "fa-file-upload", Permissions.FILE_MANAGE));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgangs-Vorlagen", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Kit-Verwaltung", "/admin/kits", "fa-box-open", Permissions.KIT_READ));
		ALL_ITEMS
				.add(new NavigationItem("Feedback", "/admin/feedback", "fa-inbox", Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Abzeichen", "/admin/achievements", "fa-award", Permissions.ACHIEVEMENT_VIEW));
		ALL_ITEMS.add(new NavigationItem("Defekte Artikel", "/admin/defekte", "fa-wrench", Permissions.STORAGE_READ));
		ALL_ITEMS
				.add(new NavigationItem("Quali-Matrix", "/admin/matrix", "fa-th-list", Permissions.QUALIFICATION_READ));
		ALL_ITEMS.add(new NavigationItem("Berichte", "/admin/berichte", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(new NavigationItem("Aktions-Log", "/admin/log", "fa-clipboard-list", Permissions.LOG_READ));
		ALL_ITEMS.add(new NavigationItem("System", "/admin/system", "fa-server", Permissions.SYSTEM_READ));
		ALL_ITEMS.add(new NavigationItem("Wiki", "/admin/wiki", "fa-book-reader", Permissions.ACCESS_ADMIN_PANEL));
	}

	private NavigationRegistry() {
		// Private constructor to prevent instantiation.
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null || user.getPermissions() == null) {
			return new ArrayList<>();
		}

		final Set<String> userPermissions = user.getPermissions();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items are always visible
			if (requiredPerm == null) {
				return true;
			}

			// Super-admins see all admin items
			if (userPermissions.contains(Permissions.ACCESS_ADMIN_PANEL)) {
				return true;
			}

			// Special case: The "Admin Dashboard" link is visible if the user has *any*
			// admin-level access.
			if (Permissions.ADMIN_DASHBOARD_ACCESS.equals(requiredPerm)) {
				return user.hasAdminAccess();
			}

			// Special case: The "Abzeichen" link is visible if user can perform any
			// achievement action.
			if (Permissions.ACHIEVEMENT_VIEW.equals(requiredPerm)) {
				return userPermissions.contains(Permissions.ACHIEVEMENT_CREATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_UPDATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_DELETE);
			}

			// Standard permission check for all other items
			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import jakarta.websocket.Session;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms using a thread-safe
 * Singleton pattern. It maps event IDs to a set of active sessions, allowing
 * for targeted broadcasting of messages.
 */
public final class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);
	private static final ChatSessionManager INSTANCE = new ChatSessionManager();

	// A map where the key is the event ID and the value is a thread-safe set of
	// sessions for that event.
	private final Map<String, Set<Session>> sessionsByEvent = new ConcurrentHashMap<>();

	private ChatSessionManager() {
	}

	/**
	 * Gets the singleton instance of the ChatSessionManager.
	 *
	 * @return The single instance of this class.
	 */
	public static ChatSessionManager getInstance() {
		return INSTANCE;
	}

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, Session session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, Session session) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			for (Session session : sessions) {
				if (session.isOpen()) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
						// Consider removing the session here if an error occurs
					}
				}
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in an event chat room, except for
	 * the originating session.
	 *
	 * @param eventId        The ID of the event chat room.
	 * @param message        The message to broadcast.
	 * @param excludeSession The session to exclude from the broadcast.
	 */
	public void broadcastExcept(String eventId, String message, Session excludeSession) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			for (Session session : sessions) {
				if (session.isOpen() && !session.getId().equals(excludeSession.getId())) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting (except self) to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\DocumentEditorSocket.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Inject;
import de.technikteam.config.Permissions;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.MarkdownUtil;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;

@ServerEndpoint(value = "/ws/editor/{fileId}", configurator = GuiceAwareServerEndpointConfigurator.class)
public class DocumentEditorSocket {

	private static final Logger logger = LogManager.getLogger(DocumentEditorSocket.class);
	private static FileDAO fileDAO;
	private static final Gson gson = new Gson();

	@Inject
	public static void setDependencies(FileDAO fileDAO) {
		DocumentEditorSocket.fileDAO = fileDAO;
	}

	@OnOpen
	public void onOpen(Session session, @PathParam("fileId") String fileId, EndpointConfig config) throws IOException {
		User user = (User) config.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);

		if (user == null || (!user.getPermissions().contains(Permissions.FILE_UPDATE)
				&& !user.getPermissions().contains("ACCESS_ADMIN_PANEL"))) {
			session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Permission denied."));
			return;
		}

		session.getUserProperties().put(GetHttpSessionConfigurator.USER_PROPERTY_KEY, user);
		DocumentSessionManager.getInstance().addSession(fileId, session);
	}

	@OnMessage
	public void onMessage(Session session, String message, @PathParam("fileId") String fileId) {
		User user = (User) session.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);
		if (user == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, String> messageMap = gson.fromJson(message, Map.class);
			String type = messageMap.get("type");
			String content = messageMap.get("payload");

			if ("content_update".equals(type)) {
				handleContentUpdate(session, fileId, content);
			}
		} catch (JsonSyntaxException e) {
			logger.error("Invalid JSON received from user '{}' for file ID {}: {}", user.getUsername(), fileId, message,
					e);
		}
	}

	private void handleContentUpdate(Session originSession, String fileIdStr, String content) {
		try {
			int fileId = Integer.parseInt(fileIdStr);
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);

			if (dbFile != null) {
				String sanitizedContent = MarkdownUtil.sanitize(content);
				if (fileDAO.updateFileContent(dbFile.getFilepath(), sanitizedContent)) {
					fileDAO.touchFileRecord(fileId);
					Map<String, String> broadcastPayload = Map.of("type", "content_update", "payload",
							sanitizedContent);
					DocumentSessionManager.getInstance().broadcastExcept(fileIdStr, gson.toJson(broadcastPayload),
							originSession);
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid fileId '{}' received in WebSocket message.", fileIdStr);
		}
	}

	@OnClose
	public void onClose(Session session, @PathParam("fileId") String fileId) {
		DocumentSessionManager.getInstance().removeSession(fileId, session);
	}

	@OnError
	public void onError(Session session, Throwable throwable, @PathParam("fileId") String fileId) {
		logger.error("WebSocket ERROR in editor for file [{}], session [{}]:", fileId, session.getId(), throwable);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\DocumentSessionManager.java
========================================================================

package de.technikteam.websocket;

import jakarta.websocket.Session;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for document-specific editing rooms using a
 * thread-safe Singleton pattern. It maps file IDs to a set of active sessions,
 * allowing for targeted broadcasting of document updates.
 */
public final class DocumentSessionManager {
	private static final Logger logger = LogManager.getLogger(DocumentSessionManager.class);
	private static final DocumentSessionManager INSTANCE = new DocumentSessionManager();

	// A map where the key is the file ID and the value is a thread-safe set of
	// sessions for that document.
	private final Map<String, Set<Session>> sessionsByFile = new ConcurrentHashMap<>();

	private DocumentSessionManager() {
	}

	public static DocumentSessionManager getInstance() {
		return INSTANCE;
	}

	public void addSession(String fileId, Session session) {
		sessionsByFile.computeIfAbsent(fileId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Editor session {} registered for file [{}].", session.getId(), fileId);
	}

	public void removeSession(String fileId, Session session) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Editor session {} removed from file [{}].", session.getId(), fileId);
			if (sessions.isEmpty()) {
				sessionsByFile.remove(fileId);
				logger.info("Editing room for file [{}] is now empty and has been removed.", fileId);
			}
		}
	}

	public int getSessionsCount(String fileId) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		return sessions != null ? sessions.size() : 0;
	}

	public void broadcastExcept(String fileId, String message, Session excludeSession) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		if (sessions != null) {
			for (Session session : sessions) {
				if (session.isOpen() && !session.getId().equals(excludeSession.getId())) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting document update to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\EventChatSocket.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Inject;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.FileDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.util.MarkdownUtil;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@ServerEndpoint(value = "/ws/chat/{eventId}", configurator = GuiceAwareServerEndpointConfigurator.class)
public class EventChatSocket {

	private static final Logger logger = LogManager.getLogger(EventChatSocket.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private static EventChatDAO chatDAO;
	private static EventDAO eventDAO;
	private static UserDAO userDAO;
	private static FileDAO fileDAO;
	private static AdminLogService adminLogService;
	private static Gson gson;

	@Inject
	public static void setDependencies(EventChatDAO injectedChatDAO, EventDAO injectedEventDAO, UserDAO injectedUserDAO,
			FileDAO injectedFileDAO, AdminLogService injectedAdminLogService) {
		chatDAO = injectedChatDAO;
		eventDAO = injectedEventDAO;
		userDAO = injectedUserDAO;
		fileDAO = injectedFileDAO;
		adminLogService = injectedAdminLogService;
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@OnOpen
	public void onOpen(Session session, @PathParam("eventId") String eventIdStr, EndpointConfig config)
			throws IOException {
		User user = (User) config.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);

		if (user == null) {
			session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Authentication required."));
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdStr);
			if (!eventDAO.isUserAssociatedWithEvent(eventId, user.getId())) {
				session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Permission denied."));
				return;
			}

			session.getUserProperties().put(GetHttpSessionConfigurator.USER_PROPERTY_KEY, user);
			ChatSessionManager.getInstance().addSession(eventIdStr, session);

		} catch (NumberFormatException e) {
			session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, "Invalid event ID format."));
		}
	}

	@OnMessage
	public void onMessage(Session session, String message, @PathParam("eventId") String eventId) {
		User user = (User) session.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);
		if (user == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message, Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = MarkdownUtil.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details?id=" + event.getId()));
				NotificationService.getInstance().sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload",
					Map.of("messageId", messageId, "originalUsername", payload.get("originalUsername"),
							"deletedByUsername", user.getUsername()));
			ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = MarkdownUtil.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload",
					Map.of("messageId", messageId, "newText", sanitizedText));
			ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	@OnClose
	public void onClose(Session session, @PathParam("eventId") String eventId) {
		ChatSessionManager.getInstance().removeSession(eventId, session);
	}

	@OnError
	public void onError(Session session, Throwable throwable) {
		logger.error("WebSocket ERROR in session [{}]:", session.getId(), throwable);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\GetHttpSessionConfigurator.java
========================================================================

package de.technikteam.websocket;

import de.technikteam.model.User;
import jakarta.servlet.ServletContext;
import jakarta.servlet.http.HttpSession;
import jakarta.websocket.HandshakeResponse;
import jakarta.websocket.server.HandshakeRequest;
import jakarta.websocket.server.ServerEndpointConfig;

public class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {

	public static final String USER_PROPERTY_KEY = "user";
	private static volatile ServletContext servletContext;

	@Override
	public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
		HttpSession httpSession = (HttpSession) request.getHttpSession();
		if (httpSession != null) {
			// Store ServletContext if it's not already stored.
			if (servletContext == null) {
				servletContext = httpSession.getServletContext();
			}

			User user = (User) httpSession.getAttribute(USER_PROPERTY_KEY);
			if (user != null) {
				sec.getUserProperties().put(USER_PROPERTY_KEY, user);
			}
		}
	}

	public static ServletContext getServletContext() {
		return servletContext;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\GuiceAwareServerEndpointConfigurator.java
========================================================================

package de.technikteam.websocket;

import com.google.inject.Injector;
import jakarta.servlet.ServletContext;
import jakarta.websocket.HandshakeResponse;
import jakarta.websocket.server.HandshakeRequest;
import jakarta.websocket.server.ServerEndpointConfig;

public class GuiceAwareServerEndpointConfigurator extends ServerEndpointConfig.Configurator {

	@Override
	public <T> T getEndpointInstance(Class<T> endpointClass) throws InstantiationException {
		ServletContext servletContext = GetHttpSessionConfigurator.getServletContext();
		if (servletContext == null) {
			throw new IllegalStateException("ServletContext is not available. Cannot find Guice Injector.");
		}

		Injector injector = (Injector) servletContext.getAttribute(Injector.class.getName());
		if (injector == null) {
			throw new IllegalStateException(
					"Guice Injector not found in ServletContext. Is GuiceConfig configured correctly in web.xml?");
		}

		// Guice creates the instance and injects its constructor dependencies (if any).
		// For WebSockets, we often use a static injection pattern, so we get the
		// instance
		// first and then ask Guice to inject its members (including static ones if
		// configured).
		T instance = injector.getInstance(endpointClass);
		injector.injectMembers(instance); // This is the key part for member injection.

		return instance;
	}

	@Override
	public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
		// Also perform the HttpSession capture
		super.modifyHandshake(sec, request, response);
		new GetHttpSessionConfigurator().modifyHandshake(sec, request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\config.properties
========================================================================

# Database Connection Details
db.url=jdbc:mysql://localhost:3306/technik_team_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false

# CORRECTED: Replaced placeholder credentials with your actual credentials.
db.user=technik_user
db.password=X32MYaaD

# File Upload Configuration
upload.directory=C:/dev/eclipse/workspace/TechnikTeam/resources/uploads

# Collabora Integration
collabora.server.url=http://localhost:9980
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\db.properties
========================================================================

# Database configuration for local development.
# IMPORTANT: Add this file to your .gitignore to avoid committing credentials.
db.user=technik
db.password=X32MYaaD
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<!-- For development, use a human-readable pattern -->
			<!-- <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} 
				- %msg%n"/> -->

			<!-- For production/structured logging, use JSON Template Layout -->
			<JsonTemplateLayout
				eventTemplateUri="classpath:Log4j2JsonTemplate.json" />
		</Console>
	</Appenders>
	<Loggers>
		<Root level="info">
			<AppenderRef ref="Console" />
		</Root>
		<!-- Set a more verbose level for our application's packages during development -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
		</Logger>
	</Loggers>
</Configuration>
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\Log4j2JsonTemplate.json
========================================================================

{
	"timestamp": {
		"$resolver": "timestamp",
		"pattern": {
			"format": "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",
			"timeZone": "UTC"
		}
	},
	"level": {
		"$resolver": "level",
		"field": "name"
	},
	"loggerName": {
		"$resolver": "logger",
		"field": "name"
	},
	"threadName": {
		"$resolver": "thread",
		"field": "name"
	},
	"message": {
		"$resolver": "message",
		"stringified": true
	},
	"thrown": {
		"$resolver": "exception",
		"field": "stackTrace",
		"stringified": true
	},
	"context": {
		"$resolver": "mdc"
	}
}