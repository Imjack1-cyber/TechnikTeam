
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);

	private final MeetingDAO meetingDAO;
	private final CourseDAO courseDAO;
	private final AttachmentDAO attachmentDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final Gson gson;

	@Inject
	public AdminMeetingServlet(MeetingDAO meetingDAO, CourseDAO courseDAO, AttachmentDAO attachmentDAO, UserDAO userDAO,
			AdminLogService adminLogService, ConfigurationService configService) {
		this.meetingDAO = meetingDAO;
		this.courseDAO = courseDAO;
		this.attachmentDAO = attachmentDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}
		String action = req.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			resp.sendRedirect(req.getContextPath() + "/admin/meetings");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();
		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);
		req.getRequestDispatcher("/views/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<Attachment> attachments = attachmentDAO.getAttachmentsForParent("MEETING", meetingId, "ADMIN");
				Map<String, Object> responseData = new HashMap<>();
				responseData.put("meetingData", meeting);
				responseData.put("attachmentsData", attachments);
				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(req.getParameter("name"));
			meeting.setDescription(req.getParameter("description"));
			meeting.setLocation(req.getParameter("location"));

			String leaderIdStr = req.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}
			String startDateTimeStr = req.getParameter("meetingDateTime");
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = req.getParameter("endDateTime");
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(req.getParameter("id"));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					adminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Meetings.");
				}
			} else {
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					adminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Erstellen des Meetings.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = req.getParameter("requiredRole");
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}
		} catch (DateTimeParseException | NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			adminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(configService.getProperty("upload.directory"), attachment.getFilepath());
			if (physicalFile.exists()) {
				physicalFile.delete();
			}
			if (attachmentDAO.deleteAttachment(attachmentId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
						+ "' von Meeting ID " + attachment.getParentId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = configService.getProperty("upload.directory") + File.separator + "meetings";
		new File(uploadDir).mkdirs();
		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());
		Attachment attachment = new Attachment();
		attachment.setParentId(meetingId);
		attachment.setParentType("MEETING");
		attachment.setFilename(fileName);
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			adminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminReportServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ReportDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class AdminReportServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminReportServlet.class);
	private final ReportDAO reportDAO;
	private final Gson gson = new Gson();

	@Inject
	public AdminReportServlet(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String reportType = request.getParameter("report");
		String exportType = request.getParameter("export");

		if (reportType != null && !reportType.isEmpty()) {
			handleSpecificReport(request, response, reportType, exportType);
			return;
		}

		List<Map<String, Object>> eventTrendData = reportDAO.getEventCountByMonth(12);
		List<Map<String, Object>> userActivityData = reportDAO.getUserParticipationStats(10);
		request.setAttribute("eventTrendDataJson", gson.toJson(eventTrendData));
		request.setAttribute("userActivityDataJson", gson.toJson(userActivityData));
		request.setAttribute("totalInventoryValue", reportDAO.getTotalInventoryValue());
		request.getRequestDispatcher("/views/admin/admin_reports.jsp").forward(request, response);
	}

	private void handleSpecificReport(HttpServletRequest request, HttpServletResponse response, String reportType,
			String exportType) throws IOException, ServletException {
		List<Map<String, Object>> reportData;
		String reportTitle;
		switch (reportType) {
		case "user_activity":
			reportData = reportDAO.getUserActivityStats();
			reportTitle = "Benutzeraktivitäts-Bericht";
			break;
		case "event_participation":
			reportData = reportDAO.getEventParticipationSummary();
			reportTitle = "Event-Teilnahme-Bericht";
			break;
		case "inventory_usage":
			reportData = reportDAO.getInventoryUsageFrequency();
			reportTitle = "Lagernutzungs-Bericht";
			break;
		default:
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Unbekannter Berichtstyp.");
			return;
		}

		if ("csv".equalsIgnoreCase(exportType)) {
			exportToCsv(response, reportData, reportType + "_report.csv");
		} else {
			request.setAttribute("reportData", reportData);
			request.setAttribute("reportTitle", reportTitle);
			request.getRequestDispatcher("/views/admin/report_display.jsp").forward(request, response);
		}
	}

	private void exportToCsv(HttpServletResponse response, List<Map<String, Object>> data, String filename)
			throws IOException {
		response.setContentType("text/csv");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
		if (data == null || data.isEmpty()) {
			response.getWriter().write("No data available to export.");
			return;
		}
		try (PrintWriter writer = response.getWriter()) {
			String header = String.join(",", data.get(0).keySet());
			writer.println(header);
			for (Map<String, Object> row : data) {
				String line = row.values().stream().map(this::escapeCsvField).collect(Collectors.joining(","));
				writer.println(line);
			}
		}
	}

	private String escapeCsvField(Object field) {
		if (field == null)
			return "";
		String fieldStr = field.toString();
		if (fieldStr.contains(",") || fieldStr.contains("\"") || fieldStr.contains("\n")) {
			return "\"" + fieldStr.replace("\"", "\"\"") + "\"";
		}
		return fieldStr;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.service.StorageService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.List;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class);
	private final StorageDAO storageDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final StorageService storageService;
	private final Gson gson = new Gson();

	@Inject
	public AdminStorageServlet(StorageDAO storageDAO, MaintenanceLogDAO maintenanceLogDAO,
			AdminLogService adminLogService, ConfigurationService configService, StorageService storageService) {
		this.storageDAO = storageDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.storageService = storageService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		List<StorageItem> storageList = storageDAO.getAllItems();
		request.setAttribute("storageList", storageList);
		request.getRequestDispatcher("/views/admin/admin_storage_list.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response);
			break;
		case "delete":
			handleDelete(request, response);
			break;
		case "updateDefectStatus":
			handleDefectStatusUpdate(request, response);
			break;
		case "updateStatus":
			handleStatusUpdate(request, response);
			break;
		case "repair":
			handleRepair(request, response);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/lager");
			break;
		}
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(request.getParameter("action"));

		try {
			StorageItem item = new StorageItem();
			item.setName(request.getParameter("name"));
			item.setLocation(request.getParameter("location"));
			item.setCabinet(request.getParameter("cabinet"));
			item.setCompartment(request.getParameter("compartment"));
			item.setQuantity(Integer.parseInt(request.getParameter("quantity")));
			item.setMaxQuantity(Integer.parseInt(request.getParameter("maxQuantity")));
			String weightStr = request.getParameter("weight_kg");
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = request.getParameter("price_eur");
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(request.getParameter("id"));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
					item.setStatus(originalItem.getStatus());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(configService.getProperty("upload.directory"), "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				adminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDefectStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
        User adminUser = (User) request.getSession().getAttribute("user");
        try {
            int itemId = Integer.parseInt(request.getParameter("id"));
            String status = request.getParameter("status"); // "DEFECT" or "UNREPAIRABLE"
            int quantity = Integer.parseInt(request.getParameter("quantity"));
            String reason = request.getParameter("reason");

            boolean success = storageService.updateDefectiveItemStatus(itemId, status, quantity, reason, adminUser);

            if (success) {
                request.getSession().setAttribute("successMessage", "Defekt-Status erfolgreich aktualisiert.");
            } else {
                request.getSession().setAttribute("errorMessage", "Status konnte nicht aktualisiert werden. Überprüfen Sie die Bestandsmengen.");
            }
        } catch (NumberFormatException e) {
            request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
        }
        response.sendRedirect(request.getContextPath() + "/admin/lager");
    }

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(configService.getProperty("upload.directory"), "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String newStatus = request.getParameter("status");
			String notes = request.getParameter("notes");
			storageDAO.updateItemStatus(itemId, newStatus);
			MaintenanceLogEntry log = new MaintenanceLogEntry();
			log.setItemId(itemId);
			log.setUserId(adminUser.getId());
			log.setNotes(notes);
			String logAction = "MAINTENANCE".equals(newStatus) ? "Marked for Maintenance" : "Returned to Service";
			log.setAction(logAction);
			maintenanceLogDAO.createLog(log);
			adminLogService.log(adminUser.getUsername(), "UPDATE_ITEM_STATUS",
					"Status für Artikel-ID " + itemId + " auf '" + newStatus + "' gesetzt. Notiz: " + notes);
			request.getSession().setAttribute("successMessage", "Artikelstatus erfolgreich aktualisiert.");
		} catch (Exception e) {
			logger.error("Error updating item status", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Status.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleRepair(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int repairedQty = Integer.parseInt(request.getParameter("repaired_quantity"));
			String notes = request.getParameter("repair_notes");
			if (storageDAO.repairItems(itemId, repairedQty)) {
				MaintenanceLogEntry log = new MaintenanceLogEntry();
				log.setItemId(itemId);
				log.setUserId(adminUser.getId());
				log.setAction(repairedQty + " Stück repariert");
				log.setNotes(notes);
				maintenanceLogDAO.createLog(log);
				adminLogService.log(adminUser.getUsername(), "REPAIR_ITEM", String.format(
						"%d Stück von Artikel-ID %d als repariert markiert. Notiz: %s", repairedQty, itemId, notes));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich als repariert markiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Reparatur konnte nicht verbucht werden (vielleicht nicht genug defekte Artikel?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		}
		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import com.google.inject.Singleton;

@Singleton
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/admin/admin_system.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;
	private final Gson gson;

	@Inject
	public AdminUserServlet(UserDAO userDAO, EventDAO eventDAO, RoleDAO roleDAO, PermissionDAO permissionDAO) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		if (!currentUser.getPermissions().contains("USER_READ") && !currentUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			case "getUserData":
				getUserDataAsJson(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige ID angegeben.");
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<User> userList = userDAO.getAllUsers();
		List<Role> allRoles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			int underscoreIndex = key.indexOf('_');
			return (underscoreIndex != -1) ? key.substring(0, underscoreIndex) : "ALLGEMEIN";
		}, LinkedHashMap::new, Collectors.toList()));

		request.setAttribute("userList", userList);
		request.setAttribute("allRoles", allRoles);
		request.setAttribute("groupedPermissionsJson", gson.toJson(groupedPermissions));
		request.getRequestDispatcher("/views/admin/admin_users.jsp").forward(request, response);
	}

	private void getUserDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int userId = Integer.parseInt(req.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user != null) {
			Set<Integer> permissionIds = permissionDAO.getPermissionIdsForUser(userId);
			Map<String, Object> responseData = new HashMap<>();
			responseData.put("user", user);
			responseData.put("permissionIds", permissionIds);

			String userJson = gson.toJson(responseData);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(userJson);
		} else {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
		}
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);
		request.setAttribute("userToView", user);
		request.setAttribute("eventHistory", eventHistory);
		request.getRequestDispatcher("/views/admin/admin_user_details.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\FrontControllerServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.servlet.admin.action.*;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Singleton
@MultipartConfig
public class FrontControllerServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FrontControllerServlet.class);
	private final Map<String, Action> actions = new HashMap<>();
	private final Gson gson;

	@Inject
	public FrontControllerServlet(CreateUserAction createUserAction, UpdateUserAction updateUserAction,
			DeleteUserAction deleteUserAction, ResetPasswordAction resetPasswordAction,
			UnlockUserAction unlockUserAction, ApproveChangeAction approveChangeAction,
			DenyChangeAction denyChangeAction, UpdateFeedbackStatusAction updateFeedbackStatusAction,
			UpdateFeedbackOrderAction updateFeedbackOrderAction, DeleteFeedbackAction deleteFeedbackAction,
			GetFeedbackDetailsAction getFeedbackDetailsAction) {

		actions.put("user.create", createUserAction);
		actions.put("user.update", updateUserAction);
		actions.put("user.delete", deleteUserAction);
		actions.put("user.resetPassword", resetPasswordAction);
		actions.put("user.unlock", unlockUserAction);
		actions.put("request.approve", approveChangeAction);
		actions.put("request.deny", denyChangeAction);
		actions.put("feedback.updateStatus", updateFeedbackStatusAction);
		actions.put("feedback.reorder", updateFeedbackOrderAction);
		actions.put("feedback.delete", deleteFeedbackAction);
		actions.put("feedback.getDetails", getFeedbackDetailsAction);

		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String pathInfo = request.getPathInfo();
		String actionName = request.getParameter("action");

		if (pathInfo == null || pathInfo.equals("/") || actionName == null || actionName.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid action request.");
			return;
		}

		String entity = pathInfo.substring(1);
		String actionKey = entity + "." + actionName;

		Action action = actions.get(actionKey);

		if (action == null) {
			logger.error("No action found for key: '{}'", actionKey);
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Action not found.");
			return;
		}

		logger.debug("Executing action for key: '{}'", actionKey);
		ApiResponse apiResponse = action.execute(request, response);

		if (apiResponse == null) {
			return;
		}

		if (apiResponse.isSuccess()) {
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
		}

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		try (PrintWriter out = response.getWriter()) {
			out.print(gson.toJson(apiResponse));
			out.flush();
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Singleton
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;

	@Inject
	public MatrixServlet(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		request.getRequestDispatcher("/views/admin/admin_matrix.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\Action.java
========================================================================

package de.technikteam.servlet.admin.action;

import de.technikteam.model.ApiResponse;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

/**
 * Represents a single, executable action within the Front Controller pattern.
 * Each implementation handles a specific business operation and returns a standardized API response.
 */
public interface Action {

	/**
	 * Executes the business logic for a specific action.
	 *
	 * @param request  The HttpServletRequest object.
	 * @param response The HttpServletResponse object.
	 * @return An ApiResponse object containing the result of the action (success/fail, message, data).
	 * @throws ServletException If a servlet-specific error occurs.
	 * @throws IOException      If an I/O error occurs.
	 */
	ApiResponse execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException;
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\ApproveChangeAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.servlet.http.SessionManager;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.Map;

@Singleton
public class ApproveChangeAction implements Action {
	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final Gson gson = new Gson();

	@Inject
	public ApproveChangeAction(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int requestId = Integer.parseInt(request.getParameter("requestId"));
			ProfileChangeRequest req = requestDAO.getRequestById(requestId);
			if (req == null || !"PENDING".equals(req.getStatus())) {
				return ApiResponse.error("Anfrage nicht gefunden oder bereits bearbeitet.");
			}

			User userToUpdate = userDAO.getUserById(req.getUserId());
			if (userToUpdate == null) {
				requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
				return ApiResponse.error("Der zugehörige Benutzer existiert nicht mehr. Anfrage abgelehnt.");
			}

			Type type = new TypeToken<Map<String, String>>() {
			}.getType();
			Map<String, String> changes = gson.fromJson(req.getRequestedChanges(), type);

			changes.forEach((field, value) -> {
				switch (field) {
				case "email":
					userToUpdate.setEmail(value);
					break;
				case "classYear":
					userToUpdate.setClassYear(Integer.parseInt(value));
					break;
				case "className":
					userToUpdate.setClassName(value);
					break;
				}
			});

			// CORRECTED: Call the version of updateUser that does not require a Connection
			// object.
			if (userDAO.updateUser(userToUpdate)
					&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED", "Profiländerung für '"
						+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") genehmigt.");

				String notificationMessage = "Ihre Profiländerung wurde genehmigt. Sie werden zur Sicherheit abgemeldet. Bitte loggen Sie sich erneut ein.";
				Map<String, Object> payload = Map.of("type", "logout_notification", "payload",
						Map.of("message", notificationMessage));
				NotificationService.getInstance().sendNotificationToUser(userToUpdate.getId(), payload);

				SessionManager.invalidateSessionsForUser(userToUpdate.getId());

				return ApiResponse.success("Änderungsanfrage genehmigt.", Map.of("requestId", requestId));
			} else {
				return ApiResponse.error("Fehler beim Anwenden der Änderungen oder beim Aktualisieren der Anfrage.");
			}

		} catch (Exception e) {
			return ApiResponse.error("Ein interner Fehler ist aufgetreten: " + e.getMessage());
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\CreateUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import de.technikteam.util.PasswordPolicyValidator;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;

@Singleton
public class CreateUserAction implements Action {

	private final UserService userService;
	private final RoleDAO roleDAO;

	@Inject
	public CreateUserAction(UserService userService, RoleDAO roleDAO) {
		this.userService = userService;
		this.roleDAO = roleDAO;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_CREATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		String username = request.getParameter("username");
		String pass = request.getParameter("password");

		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator.validate(pass);
		if (!validationResult.isValid()) {
			return ApiResponse.error("Fehler beim Erstellen des Benutzers: " + validationResult.getMessage());
		}

		int roleId = Integer.parseInt(request.getParameter("roleId"));
		String[] permissionIds = request.getParameterValues("permissionIds");

		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRoleId(roleId);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0);
		}
		newUser.setClassName(request.getParameter("className"));

		String email = request.getParameter("email");
		newUser.setEmail(email != null && !email.trim().isEmpty() ? email.trim() : null);

		int newUserId = userService.createUserWithPermissions(newUser, pass, permissionIds, adminUser.getUsername());
		if (newUserId > 0) {
			newUser.setId(newUserId);
			// Enrich with role name for the JSON response
			roleDAO.getAllRoles().stream().filter(role -> role.getId() == newUser.getRoleId()).findFirst()
					.ifPresent(role -> newUser.setRoleName(role.getRoleName()));

			return ApiResponse.success("Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.", newUser);
		} else {
			return ApiResponse
					.error("Benutzer konnte nicht erstellt werden (ggf. existiert der Name oder die E-Mail bereits).");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DeleteFeedbackAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DeleteFeedbackAction implements Action {
	private final FeedbackSubmissionDAO submissionDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DeleteFeedbackAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService) {
		this.submissionDAO = submissionDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			if (submissionDAO.deleteSubmission(submissionId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_FEEDBACK",
						"Feedback-Eintrag mit ID " + submissionId + " gelöscht.");
				NotificationService.getInstance().broadcastUIUpdate("feedback_deleted",
						Map.of("submissionId", submissionId));
				return ApiResponse.success("Feedback erfolgreich gelöscht.", Map.of("deletedId", submissionId));
			} else {
				return ApiResponse.error("Fehler beim Löschen des Feedbacks.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DeleteUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DeleteUserAction implements Action {
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DeleteUserAction(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) session.getAttribute("user");

		if (!loggedInAdmin.getPermissions().contains("USER_DELETE") && !loggedInAdmin.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		if (loggedInAdmin.getId() == userIdToDelete) {
			return ApiResponse.error("Sie können sich nicht selbst löschen.");
		}

		User userToDelete = userDAO.getUserById(userIdToDelete);
		if (userToDelete == null) {
			return ApiResponse.error("Benutzer mit ID " + userIdToDelete + " nicht gefunden.");
		}

		if (userToDelete.getPermissions().contains("ACCESS_ADMIN_PANEL")
				&& !loggedInAdmin.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			return ApiResponse.error("Sie haben keine Berechtigung, einen Haupt-Administrator zu löschen.");
		}

		String deletedUsername = userToDelete.getUsername();
		String deletedRoleName = userToDelete.getRoleName();

		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.", deletedUsername,
					userIdToDelete, deletedRoleName);
			adminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);

			NotificationService.getInstance().broadcastUIUpdate("user_deleted", Map.of("userId", userIdToDelete));

			return ApiResponse.success("Benutzer erfolgreich gelöscht.", Map.of("deletedUserId", userIdToDelete));
		} else {
			return ApiResponse.error("Benutzer konnte nicht gelöscht werden.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\DenyChangeAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class DenyChangeAction implements Action {
	private final ProfileChangeRequestDAO requestDAO;
	private final AdminLogService adminLogService;

	@Inject
	public DenyChangeAction(ProfileChangeRequestDAO requestDAO, AdminLogService adminLogService) {
		this.requestDAO = requestDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int requestId = Integer.parseInt(request.getParameter("requestId"));
			ProfileChangeRequest req = requestDAO.getRequestById(requestId);
			if (req == null || !"PENDING".equals(req.getStatus())) {
				return ApiResponse.error("Anfrage nicht gefunden oder bereits bearbeitet.");
			}

			if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED", "Profiländerung für Benutzer-ID "
						+ req.getUserId() + " (Request ID: " + requestId + ") abgelehnt.");
				return ApiResponse.success("Änderungsanfrage abgelehnt.", Map.of("requestId", requestId));
			} else {
				return ApiResponse.error("Fehler beim Ablehnen der Anfrage.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Anfrage-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\GetFeedbackDetailsAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class GetFeedbackDetailsAction implements Action {

	private final FeedbackSubmissionDAO submissionDAO;

	@Inject
	public GetFeedbackDetailsAction(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			FeedbackSubmission submission = submissionDAO.getSubmissionById(submissionId);
			if (submission != null) {
				return ApiResponse.success("Details erfolgreich geladen.", submission);
			} else {
				return ApiResponse.error("Feedback-Eintrag nicht gefunden.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\ResetPasswordAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class ResetPasswordAction implements Action {

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Inject
	public ResetPasswordAction(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_PASSWORD_RESET") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		int userId = Integer.parseInt(request.getParameter("userId"));
		User userToReset = userDAO.getUserById(userId);

		if (userToReset == null) {
			return ApiResponse.error("Benutzer zum Zurücksetzen nicht gefunden.");
		} else {
			String newPassword = generateRandomPassword(12);
			if (userDAO.changePassword(userId, newPassword)) {
				String logDetails = String.format("Passwort für Benutzer '%s' (ID: %d) zurückgesetzt.",
						userToReset.getUsername(), userId);
				adminLogService.log(adminUser.getUsername(), "RESET_PASSWORD", logDetails);

				return ApiResponse.success(
						"Passwort für " + userToReset.getUsername() + " zurückgesetzt auf: " + newPassword,
						Map.of("username", userToReset.getUsername(), "newPassword", newPassword));
			} else {
				return ApiResponse.error("Passwort konnte nicht zurückgesetzt werden.");
			}
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UnlockUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.servlet.LoginServlet;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Map;

@Singleton
public class UnlockUserAction implements Action {

	private final AdminLogService adminLogService;

	@Inject
	public UnlockUserAction(AdminLogService adminLogService) {
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.hasAdminAccess()) { // Only admins can unlock
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		String usernameToUnlock = request.getParameter("username");
		if (usernameToUnlock != null && !usernameToUnlock.isEmpty()) {
			LoginServlet.LoginAttemptManager.clearLoginAttempts(usernameToUnlock);
			adminLogService.log(adminUser.getUsername(), "UNLOCK_USER_ACCOUNT",
					"Benutzerkonto '" + usernameToUnlock + "' manuell entsperrt.");
			return ApiResponse.success("Benutzerkonto '" + usernameToUnlock + "' wurde erfolgreich entsperrt.",
					Map.of("unlockedUsername", usernameToUnlock));
		} else {
			return ApiResponse.error("Benutzername zum Entsperren wurde nicht angegeben.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateFeedbackOrderAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.DatabaseManager;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class UpdateFeedbackOrderAction implements Action {
    private static final Logger logger = LogManager.getLogger(UpdateFeedbackOrderAction.class);
    private final FeedbackSubmissionDAO submissionDAO;
    private final AdminLogService adminLogService;
    private final DatabaseManager dbManager;
    private final Gson gson = new Gson();

    @Inject
    public UpdateFeedbackOrderAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService, DatabaseManager dbManager) {
        this.submissionDAO = submissionDAO;
        this.adminLogService = adminLogService;
        this.dbManager = dbManager;
    }

    @Override
    public ApiResponse execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        User adminUser = (User) request.getSession().getAttribute("user");
        if (!adminUser.hasAdminAccess()) {
            response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
            return null;
        }

        String jsonPayload = request.getParameter("reorderData");
        if (jsonPayload == null) {
            return ApiResponse.error("Missing reorder data.");
        }

        try (Connection conn = dbManager.getConnection()) {
            conn.setAutoCommit(false);
            try {
                Type type = new TypeToken<Map<String, Object>>() {}.getType();
                Map<String, Object> data = gson.fromJson(jsonPayload, type);
                
                int submissionId = (int) Double.parseDouble(String.valueOf(data.get("submissionId")));
                String newStatus = (String) data.get("newStatus");

                @SuppressWarnings("unchecked")
                List<Double> orderedIdsDouble = (List<Double>) data.get("orderedIds");
                if (orderedIdsDouble == null) {
                	throw new IllegalArgumentException("orderedIds list is missing in the payload.");
                }
                List<Integer> orderedIds = orderedIdsDouble.stream().map(Double::intValue).collect(Collectors.toList());

                // 1. Update the status of the moved item
                submissionDAO.updateStatus(submissionId, newStatus, conn);

                // 2. Update the display order for all items in that column
                submissionDAO.updateOrderForStatus(orderedIds, conn);
                
                conn.commit();
                
                adminLogService.log(adminUser.getUsername(), "UPDATE_FEEDBACK_ORDER",
						"Feedback ID " + submissionId + " status auf '" + newStatus + "' gesetzt und Liste neu sortiert.");
                return ApiResponse.success("Feedback-Status und Sortierung aktualisiert.");
                
            } catch (Exception e) {
                conn.rollback();
                throw e; // Re-throw to be caught by the outer catch block
            }
        } catch (Exception e) {
            logger.error("Error processing feedback reorder request", e);
            return ApiResponse.error("Serverfehler beim Verarbeiten der Anfrage: " + e.getMessage());
        }
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateFeedbackStatusAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.Map;

@Singleton
public class UpdateFeedbackStatusAction implements Action {
	private final FeedbackSubmissionDAO submissionDAO;
	private final AdminLogService adminLogService;

	@Inject
	public UpdateFeedbackStatusAction(FeedbackSubmissionDAO submissionDAO, AdminLogService adminLogService) {
		this.submissionDAO = submissionDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		try {
			int submissionId = Integer.parseInt(request.getParameter("submissionId"));
			String newStatus = request.getParameter("status");
			String displayTitle = request.getParameter("displayTitle");

			if (submissionDAO.updateStatusAndTitle(submissionId, newStatus, displayTitle)) {
				adminLogService.log(adminUser.getUsername(), "UPDATE_FEEDBACK_STATUS",
						"Status für Feedback ID " + submissionId + " auf '" + newStatus + "' gesetzt.");

				NotificationService.getInstance().broadcastUIUpdate("feedback_status_updated",
						Map.of("submissionId", submissionId, "newStatus", newStatus, "displayTitle", displayTitle));

				return ApiResponse.success("Status erfolgreich aktualisiert.");
			} else {
				return ApiResponse.error("Fehler beim Aktualisieren des Status.");
			}
		} catch (NumberFormatException e) {
			return ApiResponse.error("Ungültige Feedback-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\action\UpdateUserAction.java
========================================================================

package de.technikteam.servlet.admin.action;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.service.UserService;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.Objects;

@Singleton
public class UpdateUserAction implements Action {
	private final UserDAO userDAO;
	private final RoleDAO roleDAO;
	private final UserService userService;
	private final AdminLogService adminLogService;

	@Inject
	public UpdateUserAction(UserDAO userDAO, RoleDAO roleDAO, UserService userService,
			AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.roleDAO = roleDAO;
		this.userService = userService;
		this.adminLogService = adminLogService;
	}

	@Override
	public ApiResponse execute(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		int userId = Integer.parseInt(request.getParameter("userId"));
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return null;
		}

		User originalUser = userDAO.getUserById(userId);
		if (originalUser == null) {
			return ApiResponse.error("Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
		}

		// Capture changes for logging
		StringBuilder changes = new StringBuilder();

		User updatedUser = new User();
		updatedUser.setId(userId);

		String newUsername = request.getParameter("username").trim();
		if (!Objects.equals(originalUser.getUsername(), newUsername)) {
			changes.append(String.format("Benutzername von '%s' zu '%s', ", originalUser.getUsername(), newUsername));
		}
		updatedUser.setUsername(newUsername);

		int roleId = Integer.parseInt(request.getParameter("roleId"));
		if (originalUser.getRoleId() != roleId) {
			changes.append(String.format("Rolle-ID von '%d' zu '%d', ", originalUser.getRoleId(), roleId));
		}
		updatedUser.setRoleId(roleId);

		String newClassName = request.getParameter("className");
		if (!Objects.equals(originalUser.getClassName(), newClassName)) {
			changes.append(String.format("Klasse von '%s' zu '%s', ", originalUser.getClassName(), newClassName));
		}
		updatedUser.setClassName(newClassName);

		String newEmail = request.getParameter("email");
		newEmail = (newEmail != null && !newEmail.trim().isEmpty()) ? newEmail.trim() : null;
		if (!Objects.equals(originalUser.getEmail(), newEmail)) {
			changes.append("E-Mail geändert, ");
		}
		updatedUser.setEmail(newEmail);

		try {
			int newClassYear = Integer.parseInt(request.getParameter("classYear"));
			if (originalUser.getClassYear() != newClassYear) {
				changes.append(String.format("Jahrgang von '%d' zu '%d', ", originalUser.getClassYear(), newClassYear));
			}
			updatedUser.setClassYear(newClassYear);
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		String[] permissionIds = request.getParameterValues("permissionIds");

		boolean success = userService.updateUserWithPermissions(updatedUser, permissionIds);

		if (success) {
			User refreshedUser = userDAO.getUserById(userId);
			roleDAO.getAllRoles().stream().filter(role -> role.getId() == refreshedUser.getRoleId()).findFirst()
					.ifPresent(role -> refreshedUser.setRoleName(role.getRoleName()));

			if (adminUser.getId() == userId) {
				refreshedUser.setPermissions(userDAO.getPermissionsForUser(userId));
				session.setAttribute("user", refreshedUser);
				session.setAttribute("navigationItems", NavigationRegistry.getNavigationItemsForUser(refreshedUser));
			}

			String logDetails = String.format("Benutzer '%s' (ID: %d) aktualisiert.", originalUser.getUsername(),
					userId);
			if (changes.length() > 2) {
				logDetails += " Änderungen: " + changes.substring(0, changes.length() - 2) + ".";
			}

			adminLogService.log(adminUser.getUsername(), "UPDATE_USER", logDetails);

			NotificationService.getInstance().broadcastUIUpdate("user_updated", refreshedUser);

			return ApiResponse.success("Benutzerdaten erfolgreich aktualisiert.", refreshedUser);
		} else {
			return ApiResponse
					.error("Keine Änderungen an den Benutzerdaten vorgenommen oder ein Fehler ist aufgetreten.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\api\AdminTodoApiServlet.java
========================================================================

package de.technikteam.servlet.admin.api;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import de.technikteam.service.TodoService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class AdminTodoApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final TodoService todoService;
	private final Gson gson = new Gson();

	@Inject
	public AdminTodoApiServlet(TodoService todoService) {
		this.todoService = todoService;
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		List<TodoCategory> todos = todoService.getAllTodos();
		sendJsonResponse(resp, HttpServletResponse.SC_OK, todos);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");

		switch (action) {
		case "createCategory":
			String categoryName = req.getParameter("name");
			TodoCategory newCategory = todoService.createCategory(categoryName, admin);
			if (newCategory != null) {
				sendJsonResponse(resp, HttpServletResponse.SC_CREATED,
						ApiResponse.success("Kategorie erstellt.", newCategory));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Kategorie konnte nicht erstellt werden."));
			}
			break;
		case "createTask":
			int categoryId = Integer.parseInt(req.getParameter("categoryId"));
			String content = req.getParameter("content");
			TodoTask newTask = todoService.createTask(categoryId, content, admin);
			if (newTask != null) {
				sendJsonResponse(resp, HttpServletResponse.SC_CREATED,
						ApiResponse.success("Aufgabe erstellt.", newTask));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht erstellt werden."));
			}
			break;
		default:
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Unbekannte Aktion."));
		}
	}

	@Override
	protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");
		String jsonPayload = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		Type type = new TypeToken<Map<String, Object>>() {
		}.getType();
		Map<String, Object> data = gson.fromJson(jsonPayload, type);
		String action = (String) data.get("action");

		switch (action) {
		case "updateTask":
			int taskId = ((Double) data.get("taskId")).intValue();
			String content = (String) data.get("content");
			Boolean isCompleted = (Boolean) data.get("isCompleted");
			if (todoService.updateTask(taskId, content, isCompleted, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Aufgabe aktualisiert."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht aktualisiert werden."));
			}
			break;
		case "reorder":
			Type reorderType = new TypeToken<Map<String, List<Integer>>>() {
			}.getType();
			Map<String, List<Integer>> reorderData = gson.fromJson(gson.toJson(data.get("orderData")), reorderType);
			if (todoService.reorder(reorderData, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Sortierung gespeichert."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Sortierung konnte nicht gespeichert werden."));
			}
			break;
		default:
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Unbekannte Aktion."));
		}
	}

	@Override
	protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(req)) {
			sendJsonResponse(resp, HttpServletResponse.SC_FORBIDDEN, ApiResponse.error("Invalid CSRF Token"));
			return;
		}
		User admin = (User) req.getSession().getAttribute("user");

		if (req.getParameter("taskId") != null) {
			int taskId = Integer.parseInt(req.getParameter("taskId"));
			if (todoService.deleteTask(taskId, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Aufgabe gelöscht."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Aufgabe konnte nicht gelöscht werden."));
			}
		} else if (req.getParameter("categoryId") != null) {
			int categoryId = Integer.parseInt(req.getParameter("categoryId"));
			if (todoService.deleteCategory(categoryId, admin)) {
				sendJsonResponse(resp, HttpServletResponse.SC_OK, ApiResponse.success("Kategorie gelöscht."));
			} else {
				sendJsonResponse(resp, HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						ApiResponse.error("Kategorie konnte nicht gelöscht werden."));
			}
		} else {
			sendJsonResponse(resp, HttpServletResponse.SC_BAD_REQUEST, ApiResponse.error("Keine ID angegeben."));
		}
	}

	private void sendJsonResponse(HttpServletResponse response, int status, Object data) throws IOException {
		response.setStatus(status);
		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(gson.toJson(data));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\api\CrewFinderApiServlet.java
========================================================================

package de.technikteam.servlet.admin.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class CrewFinderApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(CrewFinderApiServlet.class);
	private final EventDAO eventDAO;
	private final Gson gson;

	@Inject
	public CrewFinderApiServlet(EventDAO eventDAO) {
		this.eventDAO = eventDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		String eventIdParam = request.getParameter("eventId");

		if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing eventId parameter.");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			Event event = eventDAO.getEventById(eventId);
			if (event == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event not found.");
				return;
			}

			boolean hasPermission = currentUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS")
					|| currentUser.hasAdminAccess() || currentUser.getId() == event.getLeaderUserId();

			if (!hasPermission) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}

			List<User> qualifiedUsers = eventDAO.getQualifiedAndAvailableUsersForEvent(eventId);
			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(gson.toJson(qualifiedUsers));

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid eventId format.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\AdminDashboardApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.DashboardDataDTO;
import de.technikteam.service.AdminDashboardService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;

@Singleton
public class AdminDashboardApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final AdminDashboardService dashboardService;
	private final Gson gson;

	@Inject
	public AdminDashboardApiServlet(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		DashboardDataDTO data = dashboardService.getDashboardData();
		String jsonResponse = gson.toJson(data);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\MarkdownApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class MarkdownApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MarkdownApiServlet.class);
	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;

	@Inject
	public MarkdownApiServlet(FileDAO fileDAO, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "User not authenticated.");
			return;
		}

		User user = (User) session.getAttribute("user");
		if (!user.getPermissions().contains("FILE_UPDATE") && !user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			logger.warn("User '{}' tried to save markdown file without FILE_UPDATE permission.", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token.");
			return;
		}

		String fileIdParam = request.getParameter("fileId");
		String content = request.getParameter("content");

		if (fileIdParam == null || content == null) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required parameters.");
			return;
		}

		try {
			int fileId = Integer.parseInt(fileIdParam);
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);

			if (dbFile == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "File not found.");
				return;
			}

			boolean contentUpdated = fileDAO.updateFileContent(dbFile.getFilepath(), content);
			boolean recordTouched = fileDAO.touchFileRecord(fileId);

			if (contentUpdated && recordTouched) {
				adminLogService.log(user.getUsername(), "UPDATE_MARKDOWN_FILE",
						"Inhalt der Datei '" + dbFile.getFilename() + "' (ID: " + fileId + ") aktualisiert.");
				session.setAttribute("successMessage", "Änderungen erfolgreich gespeichert.");
			} else {
				session.setAttribute("errorMessage", "Fehler beim Speichern der Datei.");
			}

			response.sendRedirect(request.getContextPath() + "/editor?fileId=" + fileId);

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid fileId format.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\StorageHistoryApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class StorageHistoryApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageHistoryApiServlet.class);
	private final StorageLogDAO logDAO;
	private final Gson gson;

	@Inject
	public StorageHistoryApiServlet(StorageLogDAO logDAO) {
		this.logDAO = logDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			logger.debug("API request for storage history for item ID: {}", itemId);
			List<StorageLogEntry> history = logDAO.getHistoryForItem(itemId);

			String jsonResponse = gson.toJson(history);
			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);

		} catch (NumberFormatException e) {
			logger.warn("Bad request to storage history API: invalid or missing itemId");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing itemId.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\SystemStatsApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class SystemStatsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final SystemInfoService systemInfoService;
	private final Gson gson;

	@Inject
	public SystemStatsApiServlet(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
		this.gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		String jsonResponse = gson.toJson(stats);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\UserPreferencesApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Set;

@Singleton
public class UserPreferencesApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(UserPreferencesApiServlet.class);
	private static final Set<String> VALID_THEMES = Set.of("light", "dark");
	private final UserDAO userDAO;

	@Inject
	public UserPreferencesApiServlet(UserDAO userDAO) {
		this.userDAO = userDAO;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "User not authenticated.");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token.");
			return;
		}

		User user = (User) session.getAttribute("user");
		String theme = request.getParameter("theme");

		if (theme == null || !VALID_THEMES.contains(theme)) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid theme value.");
			return;
		}

		if (userDAO.updateUserTheme(user.getId(), theme)) {
			user.setTheme(theme);
			session.setAttribute("user", user);
			logger.info("Updated theme for user '{}' to '{}'.", user.getUsername(), theme);
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update theme for user '{}' in database.", user.getUsername());
			response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Could not save theme preference.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\AuthenticationFinishServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
public class AuthenticationFinishServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;
	private final Gson gson;

	@Inject
	public AuthenticationFinishServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String credentialJson = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

		User user = passkeyService.finishAuthentication(credentialJson);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");

		if (user != null) {
			HttpSession session = request.getSession(true);
			session.setAttribute("user", user);
			CSRFUtil.storeToken(session);
			List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(user);
			session.setAttribute("navigationItems", navigationItems);

			response.getWriter().write(gson.toJson(ApiResponse.success("Login successful!", user)));
		} else {
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			response.getWriter().write(gson.toJson(ApiResponse.error("Passkey authentication failed.")));
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\AuthenticationStartServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class AuthenticationStartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;

	@Inject
	public AuthenticationStartServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String username = request.getParameter("username");
		String challengeJson = passkeyService.startAuthentication(username);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(challengeJson);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\RegistrationFinishServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

@Singleton
public class RegistrationFinishServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;
	private final Gson gson;

	@Inject
	public RegistrationFinishServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		String deviceName = request.getParameter("deviceName");
		String credentialJson = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

		boolean success = passkeyService.finishRegistration(user.getId(), credentialJson, deviceName);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");

		if (success) {
			response.getWriter().write(gson.toJson(ApiResponse.success("Device registered successfully!")));
		} else {
			response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
			response.getWriter().write(gson.toJson(ApiResponse.error("Failed to register device.")));
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\passkey\RegistrationStartServlet.java
========================================================================

package de.technikteam.servlet.api.passkey;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class RegistrationStartServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final PasskeyService passkeyService;

	@Inject
	public RegistrationStartServlet(PasskeyService passkeyService) {
		this.passkeyService = passkeyService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		String challengeJson = passkeyService.startRegistration(user);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(challengeJson);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\http\SessionManager.java
========================================================================

package de.technikteam.servlet.http;

import jakarta.servlet.http.HttpSession;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * A simple, centralized manager for active HttpSession objects. This allows
 * other parts of the application to find and invalidate a specific user's
 * session.
 */
public class SessionManager {

	private static final Map<String, HttpSession> SESSIONS = new ConcurrentHashMap<>();

	public static void addSession(HttpSession session) {
		SESSIONS.put(session.getId(), session);
	}

	public static void removeSession(HttpSession session) {
		SESSIONS.remove(session.getId());
	}

	/**
	 * Finds and invalidates all active sessions for a given user ID. This is useful
	 * for forcing a user to re-authenticate after critical profile changes.
	 * 
	 * @param userId The ID of the user whose sessions should be invalidated.
	 */
	public static void invalidateSessionsForUser(int userId) {
		SESSIONS.values().stream().filter(session -> {
			try {
				de.technikteam.model.User user = (de.technikteam.model.User) session.getAttribute("user");
				return user != null && user.getId() == userId;
			} catch (IllegalStateException e) {
				// Session might already be invalid, safe to ignore and remove
				return false;
			}
		}).forEach(session -> {
			try {
				session.invalidate();
			} catch (IllegalStateException e) {
				// Session was already invalidated, no action needed
			}
		});
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\CSRFUtil.java
========================================================================

package de.technikteam.util;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.security.SecureRandom;
import java.util.Base64;
import java.util.Objects;

/**
 * A utility class for Cross-Site Request Forgery (CSRF) protection. It provides
 * methods to generate, store, and validate session-bound tokens.
 */
public final class CSRFUtil {

	private static final Logger logger = LogManager.getLogger(CSRFUtil.class);
	private static final String CSRF_TOKEN_SESSION_ATTR = "csrfToken";
	private static final String CSRF_TOKEN_PARAM_NAME = "csrfToken";

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private CSRFUtil() {
	}

	/**
	 * Generates a new, cryptographically secure random token and stores it in the
	 * user's session. This should be called after a successful login or when a new
	 * session is created.
	 *
	 * @param session The HttpSession to store the token in.
	 */
	public static void storeToken(HttpSession session) {
		if (session != null) {
			String token = generateToken();
			session.setAttribute(CSRF_TOKEN_SESSION_ATTR, token);
			logger.trace("Stored new CSRF token in session {}", session.getId());
		}
	}

	/**
	 * Generates a new, cryptographically secure random token.
	 *
	 * @return A Base64-encoded random token string.
	 */
	private static String generateToken() {
		SecureRandom random = new SecureRandom();
		byte[] tokenBytes = new byte[32];
		random.nextBytes(tokenBytes);
		return Base64.getUrlEncoder().withoutPadding().encodeToString(tokenBytes);
	}

	/**
	 * Validates the CSRF token from a request parameter against the one stored in
	 * the session. This method should be called at the beginning of any
	 * state-changing POST/PUT/DELETE request handler.
	 *
	 * @param request The HttpServletRequest containing the token.
	 * @return true if the token is valid and matches the session token, false
	 *         otherwise.
	 */
	public static boolean isTokenValid(HttpServletRequest request) {
		HttpSession session = request.getSession(false);
		String requestToken = request.getParameter(CSRF_TOKEN_PARAM_NAME);
		return isTokenValid(session, requestToken);
	}

	/**
	 * Validates a given request token against the one stored in the session. This
	 * is a helper method, useful for multipart requests where the token is
	 * extracted manually.
	 *
	 * @param session      The current HttpSession.
	 * @param requestToken The token submitted with the request.
	 * @return true if the token is valid and matches the session token, false
	 *         otherwise.
	 */
	public static boolean isTokenValid(HttpSession session, String requestToken) {
		if (session == null) {
			logger.warn("CSRF check failed: No session exists.");
			return false;
		}

		String sessionToken = (String) session.getAttribute(CSRF_TOKEN_SESSION_ATTR);

		if (sessionToken == null || requestToken == null || requestToken.isEmpty()) {
			logger.warn(
					"CSRF check failed: Session or request token is missing. Session-Token-Present: {}, Request-Token-Present: {}",
					sessionToken != null, requestToken != null && !requestToken.isEmpty());
			return false;
		}

		boolean isValid = Objects.equals(sessionToken, requestToken);
		if (!isValid) {
			logger.warn("CSRF token mismatch! Session: [{}], Request: [{}]", sessionToken, requestToken);
		}

		return isValid;
	}

	/**
	 * Returns the HTML hidden input field for the CSRF token. This can be used in
	 * JSPs to easily include the token in forms.
	 *
	 * @param session The current HttpSession.
	 * @return An HTML string for the hidden input field.
	 */
	public static String getCsrfInputField(HttpSession session) {
		if (session != null) {
			String token = (String) session.getAttribute(CSRF_TOKEN_SESSION_ATTR);
			if (token != null) {
				return "<input type=\"hidden\" name=\"" + CSRF_TOKEN_PARAM_NAME + "\" value=\"" + token + "\">";
			}
		}
		return "";
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

import java.util.regex.Pattern;

/**
 * A utility class for sanitizing user-provided Markdown content to prevent
 * Cross-Site Scripting (XSS) attacks. It strips dangerous HTML tags and
 * attributes before the content is stored or rendered.
 */
public final class MarkdownUtil {

    // Pattern to find and remove <script>...</script> blocks, case-insensitive and multiline.
    private static final Pattern SCRIPT_PATTERN = Pattern.compile("<script.*?>.*?</script>",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE | Pattern.DOTALL);

    // Pattern to find and remove attributes like onclick, onmouseover, etc.
    private static final Pattern ON_ATTRIBUTE_PATTERN = Pattern.compile("\\s(on\\w+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|[^\\s>]+)",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    // Pattern to find and remove href/src attributes with "javascript:..." URIs.
    private static final Pattern JAVASCRIPT_URI_PATTERN = Pattern.compile("(href|src)\\s*=\\s*(\"|')\\s*javascript:",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    /**
     * Private constructor to prevent instantiation of this utility class.
     */
    private MarkdownUtil() {
    }

    /**
     * Sanitizes a string containing Markdown and potentially malicious HTML. This
     * method should be called on any user-supplied content before it is stored in
     * the database or broadcast to other clients.
     *
     * @param markdown The raw Markdown string from the user.
     * @return A sanitized string with dangerous HTML elements and attributes removed.
     */
    public static String sanitize(String markdown) {
        if (markdown == null || markdown.isEmpty()) {
            return markdown;
        }

        String sanitized = markdown;

        // Remove <script> tags completely
        sanitized = SCRIPT_PATTERN.matcher(sanitized).replaceAll("");

        // Remove on... attributes (onclick, onmouseover, etc.)
        sanitized = ON_ATTRIBUTE_PATTERN.matcher(sanitized).replaceAll("");

        // Remove javascript:... in href/src attributes
        sanitized = JAVASCRIPT_URI_PATTERN.matcher(sanitized).replaceAll("$1='#'");

        return sanitized;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();

	// Defines all possible navigation links, their icons, and the permission
	// required to see them.
	// A null permission means the link is public to all authenticated users.
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Mein Feedback", "/my-feedback", "fa-comment-dots", null));
		ALL_ITEMS.add(new NavigationItem("Feedback geben", "/feedback", "fa-lightbulb", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(new NavigationItem("Anträge", "/admin/requests", "fa-inbox", Permissions.USER_UPDATE));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/admin/dateien", "fa-file-upload", Permissions.FILE_MANAGE));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgangs-Vorlagen", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Kit-Verwaltung", "/admin/kits", "fa-box-open", Permissions.KIT_READ));
		ALL_ITEMS
				.add(new NavigationItem("Feedback", "/admin/feedback", "fa-inbox", Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Abzeichen", "/admin/achievements", "fa-award", Permissions.ACHIEVEMENT_VIEW));
		ALL_ITEMS.add(new NavigationItem("Defekte Artikel", "/admin/defekte", "fa-wrench", Permissions.STORAGE_READ));
		ALL_ITEMS
				.add(new NavigationItem("Quali-Matrix", "/admin/matrix", "fa-th-list", Permissions.QUALIFICATION_READ));
		ALL_ITEMS.add(new NavigationItem("Berichte", "/admin/berichte", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(new NavigationItem("Aktions-Log", "/admin/log", "fa-clipboard-list", Permissions.LOG_READ));
		ALL_ITEMS.add(new NavigationItem("System", "/admin/system", "fa-server", Permissions.SYSTEM_READ));
	}

	private NavigationRegistry() {
		// Private constructor to prevent instantiation.
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null || user.getPermissions() == null) {
			return new ArrayList<>();
		}

		final Set<String> userPermissions = user.getPermissions();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items are always visible
			if (requiredPerm == null) {
				return true;
			}

			// Super-admins see all admin items
			if (userPermissions.contains(Permissions.ACCESS_ADMIN_PANEL)) {
				return true;
			}

			// Special case: The "Admin Dashboard" link is visible if the user has *any*
			// admin-level access.
			if (Permissions.ADMIN_DASHBOARD_ACCESS.equals(requiredPerm)) {
				return user.hasAdminAccess();
			}

			// Special case: The "Abzeichen" link is visible if user can perform any
			// achievement action.
			if (Permissions.ACHIEVEMENT_VIEW.equals(requiredPerm)) {
				return userPermissions.contains(Permissions.ACHIEVEMENT_CREATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_UPDATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_DELETE);
			}

			// Standard permission check for all other items
			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import jakarta.websocket.Session;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms using a thread-safe
 * Singleton pattern. It maps event IDs to a set of active sessions, allowing
 * for targeted broadcasting of messages.
 */
public final class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);
	private static final ChatSessionManager INSTANCE = new ChatSessionManager();

	// A map where the key is the event ID and the value is a thread-safe set of
	// sessions for that event.
	private final Map<String, Set<Session>> sessionsByEvent = new ConcurrentHashMap<>();

	private ChatSessionManager() {
	}

	/**
	 * Gets the singleton instance of the ChatSessionManager.
	 *
	 * @return The single instance of this class.
	 */
	public static ChatSessionManager getInstance() {
		return INSTANCE;
	}

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, Session session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, Session session) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			for (Session session : sessions) {
				if (session.isOpen()) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
						// Consider removing the session here if an error occurs
					}
				}
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in an event chat room, except for
	 * the originating session.
	 *
	 * @param eventId        The ID of the event chat room.
	 * @param message        The message to broadcast.
	 * @param excludeSession The session to exclude from the broadcast.
	 */
	public void broadcastExcept(String eventId, String message, Session excludeSession) {
		Set<Session> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			for (Session session : sessions) {
				if (session.isOpen() && !session.getId().equals(excludeSession.getId())) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting (except self) to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\DocumentEditorSocket.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Inject;
import de.technikteam.config.Permissions;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.MarkdownUtil;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;

@ServerEndpoint(value = "/ws/editor/{fileId}", configurator = GuiceAwareServerEndpointConfigurator.class)
public class DocumentEditorSocket {

	private static final Logger logger = LogManager.getLogger(DocumentEditorSocket.class);
	private static FileDAO fileDAO;
	private static final Gson gson = new Gson();

	@Inject
	public static void setDependencies(FileDAO fileDAO) {
		DocumentEditorSocket.fileDAO = fileDAO;
	}

	@OnOpen
	public void onOpen(Session session, @PathParam("fileId") String fileId, EndpointConfig config) throws IOException {
		User user = (User) config.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);

		if (user == null || (!user.getPermissions().contains(Permissions.FILE_UPDATE)
				&& !user.getPermissions().contains("ACCESS_ADMIN_PANEL"))) {
			session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Permission denied."));
			return;
		}

		session.getUserProperties().put(GetHttpSessionConfigurator.USER_PROPERTY_KEY, user);
		DocumentSessionManager.getInstance().addSession(fileId, session);
	}

	@OnMessage
	public void onMessage(Session session, String message, @PathParam("fileId") String fileId) {
		User user = (User) session.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);
		if (user == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, String> messageMap = gson.fromJson(message, Map.class);
			String type = messageMap.get("type");
			String content = messageMap.get("payload");

			if ("content_update".equals(type)) {
				handleContentUpdate(session, fileId, content);
			}
		} catch (JsonSyntaxException e) {
			logger.error("Invalid JSON received from user '{}' for file ID {}: {}", user.getUsername(), fileId, message,
					e);
		}
	}

	private void handleContentUpdate(Session originSession, String fileIdStr, String content) {
		try {
			int fileId = Integer.parseInt(fileIdStr);
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);

			if (dbFile != null) {
				String sanitizedContent = MarkdownUtil.sanitize(content);
				if (fileDAO.updateFileContent(dbFile.getFilepath(), sanitizedContent)) {
					fileDAO.touchFileRecord(fileId);
					Map<String, String> broadcastPayload = Map.of("type", "content_update", "payload",
							sanitizedContent);
					DocumentSessionManager.getInstance().broadcastExcept(fileIdStr, gson.toJson(broadcastPayload),
							originSession);
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid fileId '{}' received in WebSocket message.", fileIdStr);
		}
	}

	@OnClose
	public void onClose(Session session, @PathParam("fileId") String fileId) {
		DocumentSessionManager.getInstance().removeSession(fileId, session);
	}

	@OnError
	public void onError(Session session, Throwable throwable, @PathParam("fileId") String fileId) {
		logger.error("WebSocket ERROR in editor for file [{}], session [{}]:", fileId, session.getId(), throwable);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\DocumentSessionManager.java
========================================================================

package de.technikteam.websocket;

import jakarta.websocket.Session;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for document-specific editing rooms using a
 * thread-safe Singleton pattern. It maps file IDs to a set of active sessions,
 * allowing for targeted broadcasting of document updates.
 */
public final class DocumentSessionManager {
	private static final Logger logger = LogManager.getLogger(DocumentSessionManager.class);
	private static final DocumentSessionManager INSTANCE = new DocumentSessionManager();

	// A map where the key is the file ID and the value is a thread-safe set of
	// sessions for that document.
	private final Map<String, Set<Session>> sessionsByFile = new ConcurrentHashMap<>();

	private DocumentSessionManager() {
	}

	public static DocumentSessionManager getInstance() {
		return INSTANCE;
	}

	public void addSession(String fileId, Session session) {
		sessionsByFile.computeIfAbsent(fileId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Editor session {} registered for file [{}].", session.getId(), fileId);
	}

	public void removeSession(String fileId, Session session) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Editor session {} removed from file [{}].", session.getId(), fileId);
			if (sessions.isEmpty()) {
				sessionsByFile.remove(fileId);
				logger.info("Editing room for file [{}] is now empty and has been removed.", fileId);
			}
		}
	}

	public int getSessionsCount(String fileId) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		return sessions != null ? sessions.size() : 0;
	}

	public void broadcastExcept(String fileId, String message, Session excludeSession) {
		Set<Session> sessions = sessionsByFile.get(fileId);
		if (sessions != null) {
			for (Session session : sessions) {
				if (session.isOpen() && !session.getId().equals(excludeSession.getId())) {
					try {
						session.getBasicRemote().sendText(message);
					} catch (IOException e) {
						logger.error("Error broadcasting document update to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\EventChatSocket.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Inject;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.FileDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import de.technikteam.util.MarkdownUtil;
import jakarta.websocket.*;
import jakarta.websocket.server.PathParam;
import jakarta.websocket.server.ServerEndpoint;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@ServerEndpoint(value = "/ws/chat/{eventId}", configurator = GuiceAwareServerEndpointConfigurator.class)
public class EventChatSocket {

	private static final Logger logger = LogManager.getLogger(EventChatSocket.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private static EventChatDAO chatDAO;
	private static EventDAO eventDAO;
	private static UserDAO userDAO;
	private static FileDAO fileDAO;
	private static AdminLogService adminLogService;
	private static Gson gson;

	@Inject
	public static void setDependencies(EventChatDAO injectedChatDAO, EventDAO injectedEventDAO, UserDAO injectedUserDAO,
			FileDAO injectedFileDAO, AdminLogService injectedAdminLogService) {
		chatDAO = injectedChatDAO;
		eventDAO = injectedEventDAO;
		userDAO = injectedUserDAO;
		fileDAO = injectedFileDAO;
		adminLogService = injectedAdminLogService;
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@OnOpen
	public void onOpen(Session session, @PathParam("eventId") String eventIdStr, EndpointConfig config)
			throws IOException {
		User user = (User) config.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);

		if (user == null) {
			session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Authentication required."));
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdStr);
			if (!eventDAO.isUserAssociatedWithEvent(eventId, user.getId())) {
				session.close(new CloseReason(CloseReason.CloseCodes.VIOLATED_POLICY, "Permission denied."));
				return;
			}

			session.getUserProperties().put(GetHttpSessionConfigurator.USER_PROPERTY_KEY, user);
			ChatSessionManager.getInstance().addSession(eventIdStr, session);

		} catch (NumberFormatException e) {
			session.close(new CloseReason(CloseReason.CloseCodes.UNEXPECTED_CONDITION, "Invalid event ID format."));
		}
	}

	@OnMessage
	public void onMessage(Session session, String message, @PathParam("eventId") String eventId) {
		User user = (User) session.getUserProperties().get(GetHttpSessionConfigurator.USER_PROPERTY_KEY);
		if (user == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message, Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = MarkdownUtil.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details?id=" + event.getId()));
				NotificationService.getInstance().sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload",
					Map.of("messageId", messageId, "originalUsername", payload.get("originalUsername"),
							"deletedByUsername", user.getUsername()));
			ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = MarkdownUtil.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload",
					Map.of("messageId", messageId, "newText", sanitizedText));
			ChatSessionManager.getInstance().broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	@OnClose
	public void onClose(Session session, @PathParam("eventId") String eventId) {
		ChatSessionManager.getInstance().removeSession(eventId, session);
	}

	@OnError
	public void onError(Session session, Throwable throwable) {
		logger.error("WebSocket ERROR in session [{}]:", session.getId(), throwable);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\GetHttpSessionConfigurator.java
========================================================================

package de.technikteam.websocket;

import de.technikteam.model.User;
import jakarta.servlet.ServletContext;
import jakarta.servlet.http.HttpSession;
import jakarta.websocket.HandshakeResponse;
import jakarta.websocket.server.HandshakeRequest;
import jakarta.websocket.server.ServerEndpointConfig;

public class GetHttpSessionConfigurator extends ServerEndpointConfig.Configurator {

	public static final String USER_PROPERTY_KEY = "user";
	private static volatile ServletContext servletContext;

	@Override
	public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
		HttpSession httpSession = (HttpSession) request.getHttpSession();
		if (httpSession != null) {
			// Store ServletContext if it's not already stored.
			if (servletContext == null) {
				servletContext = httpSession.getServletContext();
			}

			User user = (User) httpSession.getAttribute(USER_PROPERTY_KEY);
			if (user != null) {
				sec.getUserProperties().put(USER_PROPERTY_KEY, user);
			}
		}
	}

	public static ServletContext getServletContext() {
		return servletContext;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\websocket\GuiceAwareServerEndpointConfigurator.java
========================================================================

package de.technikteam.websocket;

import com.google.inject.Injector;
import jakarta.servlet.ServletContext;
import jakarta.websocket.HandshakeResponse;
import jakarta.websocket.server.HandshakeRequest;
import jakarta.websocket.server.ServerEndpointConfig;

public class GuiceAwareServerEndpointConfigurator extends ServerEndpointConfig.Configurator {

	@Override
	public <T> T getEndpointInstance(Class<T> endpointClass) throws InstantiationException {
		ServletContext servletContext = GetHttpSessionConfigurator.getServletContext();
		if (servletContext == null) {
			throw new IllegalStateException("ServletContext is not available. Cannot find Guice Injector.");
		}

		Injector injector = (Injector) servletContext.getAttribute(Injector.class.getName());
		if (injector == null) {
			throw new IllegalStateException(
					"Guice Injector not found in ServletContext. Is GuiceConfig configured correctly in web.xml?");
		}

		// Guice creates the instance and injects its constructor dependencies (if any).
		// For WebSockets, we often use a static injection pattern, so we get the
		// instance
		// first and then ask Guice to inject its members (including static ones if
		// configured).
		T instance = injector.getInstance(endpointClass);
		injector.injectMembers(instance); // This is the key part for member injection.

		return instance;
	}

	@Override
	public void modifyHandshake(ServerEndpointConfig sec, HandshakeRequest request, HandshakeResponse response) {
		// Also perform the HttpSession capture
		super.modifyHandshake(sec, request, response);
		new GetHttpSessionConfigurator().modifyHandshake(sec, request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\css\style.css
========================================================================

/* =================================================================== */
/*  TECHNIKTEAM DESIGN V3 (Component-Based & Modern)                   */
/* =================================================================== */

/* --- 1. THEME & COLOR PALETTE --- */
:root {
	--primary-color: #007bff;
	--primary-color-hover: #0056b3;
	--primary-color-light: rgba(0, 123, 255, 0.1);
	--bg-color: #f8f9fa;
	--surface-color: #ffffff;
	--text-color: #212529;
	--heading-color: #002B5B; /* Dark, rich blue for headings */
	--text-muted-color: #6c757d;
	--border-color: #dee2e6;
	--success-color: #28a745;
	--danger-color: #dc3545;
	--warning-color: #ffc107;
	--info-color: #0dcaf0;
	--shadow-sm: 0 1px 2px 0 rgb(0 0 0/ 0.05);
	--shadow-md: 0 4px 6px -1px rgb(0 0 0/ 0.1), 0 2px 4px -2px
		rgb(0 0 0/ 0.1);
	--shadow-lg: 0 10px 15px -3px rgb(0 0 0/ 0.1), 0 4px 6px -4px
		rgb(0 0 0/ 0.1);
	--sidebar-width: 260px;
	--header-height: 64px;
	--border-radius: 8px;
	--sidebar-bg: var(--surface-color);
	--sidebar-border: var(--border-color);
	--sidebar-text-color: #343a40;
	--sidebar-text-muted: #6c757d;
	--sidebar-icon-color: #6c757d;
	--sidebar-hover-bg: #e9ecef;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
}

[data-theme="dark"] {
	--primary-color: #58a6ff;
	--primary-color-hover: #80b6ff;
	--primary-color-light: rgba(88, 166, 255, 0.15);
	--bg-color: #0d1117;
	--surface-color: #161b22;
	--text-color: #c9d1d9;
	--heading-color: var(--primary-color);
	/* Vibrant blue for dark mode headings */
	--text-muted-color: #8b949e;
	--border-color: #30363d;
	--success-color: #56d364;
	--danger-color: #f87171;
	--warning-color: #f0b72f;
	--info-color: #67d4ed;
	--sidebar-bg: #161b22;
	--sidebar-border: #30363d;
	--sidebar-text-color: #c9d1d9;
	--sidebar-text-muted: #8b949e;
	--sidebar-icon-color: #8b949e;
	--sidebar-hover-bg: #21262d;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
}

/* --- 2. BASE & TYPOGRAPHY --- */
*, *::before, *::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html {
	scroll-behavior: smooth;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		"Helvetica Neue", Arial, sans-serif;
	background-color: var(--bg-color);
	color: var(--text-color);
	line-height: 1.6;
	transition: background-color 0.3s, color 0.3s;
}

h1, h2, h3, h4 {
	color: var(--heading-color);
	line-height: 1.3;
}

h1 {
	font-size: clamp(1.8rem, 5vw, 2.2rem);
	font-weight: 700;
	margin-bottom: 1rem;
}

h2 {
	font-size: clamp(1.2rem, 4vw, 1.5rem);
	margin-bottom: 1.25rem;
	padding-bottom: 0.75rem;
	border-bottom: 1px solid var(--border-color);
	font-weight: 600;
}

h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	font-weight: 600;
}

a {
	color: var(--primary-color);
	text-decoration: none;
	transition: color 0.2s;
}

a:hover {
	text-decoration: underline;
	color: var(--primary-color-hover);
}

.text-success {
	color: var(--success-color) !important;
}

.text-danger {
	color: var(--danger-color) !important;
}

/* --- 3. LAYOUT & CONTAINERS --- */
.main-content-wrapper {
	transition: margin-left 0.3s ease-in-out;
}

.main-content {
	padding: 1.5rem;
	max-width: 1600px;
	margin-left: auto;
	margin-right: auto;
}

.card {
	background: var(--surface-color);
	border-radius: var(--border-radius);
	padding: 1.5rem;
	margin-bottom: 1.5rem;
	box-shadow: var(--shadow-sm);
	border: 1px solid var(--border-color);
	transition: all .3s;
}

.card:hover {
	box-shadow: var(--shadow-md);
}

.card-title {
	border: none;
	padding: 0;
	margin-bottom: 1rem;
}

.dashboard-grid, .responsive-dashboard-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1.5rem;
}

.feedback-card {
    transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
}


@media (max-width: 767.98px) {
    .responsive-dashboard-grid {
        grid-template-columns: 1fr;
    }
}


/* --- 4. NAVIGATION --- */
.sidebar {
	position: fixed;
	top: 0;
	left: calc(-1 * var(--sidebar-width));
	width: var(--sidebar-width);
	height: 100%;
	background: var(--sidebar-bg);
	border-right: 1px solid var(--sidebar-border);
	z-index: 1010;
	transition: left 0.3s ease-in-out, background-color 0.3s, border-color
		0.3s;
	display: flex;
	flex-direction: column;
}

body.nav-open .sidebar {
	left: 0;
	box-shadow: var(--shadow-md);
}

.sidebar-header {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0 1.5rem;
	height: var(--header-height);
	flex-shrink: 0;
}

.sidebar-header .logo {
	font-size: 1.25rem;
	font-weight: 700;
	color: var(--heading-color);
	text-decoration: none;
}

.sidebar-header .logo i {
	color: var(--primary-color);
}

.sidebar-nav {
	list-style: none;
	flex-grow: 1;
	overflow-y: auto;
	padding: 0.5rem 0;
}

.sidebar-nav a {
	display: flex;
	align-items: center;
	gap: 1rem;
	padding: 0.9rem 1.5rem;
	color: var(--sidebar-text-muted);
	font-weight: 500;
	transition: all 0.2s;
	border-left: 4px solid transparent;
	white-space: nowrap;
	text-decoration: none;
}

.sidebar-nav a i.fa-fw {
	width: 20px;
	text-align: center;
	color: var(--sidebar-icon-color);
	transition: color 0.2s;
}

.sidebar-nav a:hover {
	color: var(--text-color);
	background-color: var(--sidebar-hover-bg);
}

.sidebar-nav a:hover i.fa-fw {
	color: var(--primary-color);
}

.sidebar-nav a.active-nav-link {
	color: var(--sidebar-active-text);
	font-weight: 600;
	border-left-color: var(--sidebar-active-border);
	background-color: var(--sidebar-active-bg);
}

.sidebar-nav a.active-nav-link i.fa-fw {
	color: var(--sidebar-active-icon);
}

.sidebar-nav .nav-section-title {
	padding: 1.5rem 1.5rem 0.5rem;
	font-size: 0.8rem;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
}

.user-actions {
	padding: 1rem 1.5rem;
	border-top: 1px solid var(--sidebar-border);
	flex-shrink: 0;
}

.user-info {
	font-weight: 500;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: var(--text-muted-color);
}

.user-info strong {
	color: var(--text-color);
}

.mobile-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	height: var(--header-height);
	background-color: var(--surface-color);
	padding: 0 1rem;
	position: sticky;
	top: 0;
	z-index: 1000;
	border-bottom: 1px solid var(--border-color);
}

.mobile-header-right {
    display: flex;
    align-items: center;
    gap: 1rem;
}


.mobile-nav-toggle {
	background: none;
	border: none;
	cursor: pointer;
	padding: 0.5rem;
	z-index: 1020;
}

.mobile-nav-toggle .line {
	width: 25px;
	height: 3px;
	background-color: var(--primary-color);
	margin: 5px 0;
	border-radius: 3px;
	transition: all 0.3s;
}

body.nav-open .mobile-nav-toggle .line-1 {
	transform: rotate(45deg) translate(5px, 6px);
}

body.nav-open .mobile-nav-toggle .line-2 {
	opacity: 0;
}

body.nav-open .mobile-nav-toggle .line-3 {
	transform: rotate(-45deg) translate(5px, -6px);
}

.mobile-logo {
	font-weight: 600;
	font-size: 1.2rem;
	color: var(--heading-color);
	text-decoration: none;
}

.page-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 1005;
}

body.nav-open .page-overlay {
	display: block;
}

@media ( min-width : 992px) {
	.mobile-header, .page-overlay {
		display: none !important;
	}
	.sidebar {
		left: 0;
	}
	.main-content-wrapper {
		margin-left: var(--sidebar-width);
	}
	.sidebar .mobile-only {
        display: none !important;
    }
}

@media ( max-width : 991.98px) {
    .sidebar .desktop-only {
        display: none !important;
    }
}

/* --- 5. COMPONENTS --- */

/* Buttons */
.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;
	padding: 0.6rem 1.2rem;
	background-color: var(--primary-color);
	color: #fff;
	border: 1px solid transparent;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s;
	text-align: center;
	text-decoration: none;
}

.btn:hover {
	background-color: var(--primary-color-hover);
	color: #fff;
	text-decoration: none;
	transform: translateY(-1px);
}

.btn:disabled {
	background-color: var(--text-muted-color);
	cursor: not-allowed;
	transform: none;
	opacity: 0.65;
}

.btn.btn-danger {
	background-color: var(--danger-color);
}

.btn.btn-danger-outline {
	background-color: transparent;
	border-color: var(--danger-color);
	color: var(--danger-color);
}

.btn.btn-danger-outline:hover {
	background-color: var(--danger-color);
	color: #fff;
}

.btn.btn-success {
	background-color: var(--success-color);
}

.btn.btn-secondary {
	background-color: var(--text-muted-color);
}

.btn-small {
	padding: 0.4rem 0.8rem;
	font-size: 0.875rem;
}

/* Messages & Banners */
.success-message, .error-message, .info-message, .password-reset-alert {
	padding: 1rem;
	margin-bottom: 1.5rem;
	border-radius: var(--border-radius);
	font-weight: 500;
	display: flex;
	align-items: center;
	gap: 0.75rem;
	color: #fff;
}

.success-message {
	background-color: var(--success-color);
}

.error-message {
	background-color: var(--danger-color);
}

.info-message, .password-reset-alert {
	background-color: var(--info-color);
	color: #000;
}

.password-reset-alert strong {
	cursor: pointer;
	text-decoration: underline;
}

/* Toast Notifications */
.toast {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background-color: var(--surface-color);
    color: var(--text-color);
    padding: 1rem 1.5rem;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow-lg);
    z-index: 9999;
    transform: translateY(150%);
    transition: transform 0.4s ease-in-out, opacity 0.4s;
    border-left: 5px solid var(--primary-color);
    opacity: 0;
}
.toast.toast-success { border-left-color: var(--success-color); }
.toast.toast-danger { border-left-color: var(--danger-color); }
.toast.toast-info { border-left-color: var(--info-color); }

.toast.show {
    transform: translateY(0);
    opacity: 1;
}


/* Forms & Inputs */
.form-group {
	margin-bottom: 1.25rem;
}

.form-group label {
	display: block;
	margin-bottom: 0.5rem;
	font-weight: 500;
	color: var(--text-muted-color);
}

.form-group input, .form-group select, .form-group textarea {
	width: 100%;
	padding: 0.75rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
	background-color: var(--surface-color);
	color: var(--text-color);
	font-size: 1rem;
	transition: border-color 0.2s, box-shadow 0.2s;
}

fieldset {
    border: none;
    padding: 0;
    margin: 0;
}

[data-theme="dark"] .form-group textarea,
[data-theme="dark"] #editor {
    color: var(--text-color);
    background-color: var(--surface-color);
}

.form-group input:focus, .form-group select:focus, .form-group textarea:focus
	{
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 3px var(--primary-color-light);
}

.form-group input[type="file"] {
	background-color: var(--bg-color);
}

.password-input-wrapper {
	position: relative;
	display: flex;
	align-items: center;
}

.password-input-wrapper input {
	padding-right: 40px; /* Make space for the icon */
}

.password-toggle-icon {
	position: absolute;
	right: 0;
	top: 0;
	height: 100%;
	width: 40px;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: var(--text-muted-color);
}


.file-size-warning {
	color: var(--danger-color);
	display: none;
	font-size: 0.875rem;
	margin-top: 0.5rem;
}

/* Modals */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.6);
	display: none;
	justify-content: center;
	align-items: center;
	z-index: 2000;
}

.modal-overlay.active {
	display: flex;
}

.modal-content {
	background-color: var(--surface-color);
	padding: 2rem;
	border-radius: var(--border-radius);
	width: 90%;
	max-width: 600px;
	max-height: 90vh;
	overflow-y: auto;
	position: relative;
	box-shadow: var(--shadow-lg);
}

.modal-close-btn {
	position: absolute;
	top: 1rem;
	right: 1rem;
	background: none;
	border: none;
	font-size: 1.5rem;
	cursor: pointer;
	color: var(--text-muted-color);
}

.modal-tabs {
	display: flex;
	border-bottom: 1px solid var(--border-color);
	margin-bottom: 1.5rem;
}

.modal-tab-button {
	padding: 0.75rem 1rem;
	border: none;
	background: none;
	cursor: pointer;
	font-size: 1rem;
	font-weight: 500;
	color: var(--text-muted-color);
	border-bottom: 3px solid transparent;
	transition: all 0.2s;
}

.modal-tab-button.active {
	color: var(--primary-color);
	border-bottom-color: var(--primary-color);
}

.modal-tab-content {
	display: none;
}

.modal-tab-content.active {
	display: block;
}

.dynamic-row {
	display: flex;
	gap: 0.5rem;
	align-items: center;
	margin-bottom: 0.5rem;
	flex-wrap: wrap; /* Allow wrapping on small screens */
}

.dynamic-row .form-group {
	flex-grow: 1;
	margin-bottom: 0;
}

.dynamic-row .btn-small {
	flex-shrink: 0;
}

/* --- 6. TABLES & RESPONSIVE LISTS --- */
.table-wrapper {
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	overflow-x: auto;
	background-color: var(--surface-color);
}

.data-table {
	width: 100%;
	border-collapse: collapse;
}

.data-table th, .data-table td {
	padding: 1rem;
	text-align: left;
	border-bottom: 1px solid var(--border-color);
	white-space: nowrap;
	vertical-align: middle;
}

/* FIX for admin requests table */
.data-table pre {
    white-space: pre-wrap;
    word-break: break-all;
    background-color: var(--bg-color);
    padding: 0.5rem;
    border-radius: 4px;
}

.data-table thead th {
	font-size: 0.8rem;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
	background-color: var(--bg-color);
}

.data-table tbody tr:hover {
	background-color: var(--bg-color);
}

.mobile-card-list {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.list-item-card {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	padding: 1rem;
	box-shadow: var(--shadow-sm);
}

.list-item-card .card-title {
	margin-bottom: 0.5rem;
	font-size: 1.1rem;
	border-bottom: none;
	padding-bottom: 0;
}

.card-row {
	display: flex;
	justify-content: space-between;
	align-items: center;
	font-size: 0.9rem;
	padding: 0.4rem 0;
	border-bottom: 1px solid var(--border-color);
}

.card-row:last-of-type {
	border-bottom: none;
}

.card-actions {
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	gap: 0.5rem;
}

.desktop-table-wrapper {
	display: none;
}

@media ( min-width : 992px) {
	.mobile-card-list {
		display: none !important;
	}
	.desktop-table-wrapper {
		display: block !important;
	}
}

/* --- 7. UTILITY & PAGE-SPECIFIC --- */

/* Login Page */
.login-page-container {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	min-height: 100vh;
	padding: 1rem;
	background: var(--bg-color);
}

.login-box {
	width: 100%;
	max-width: 400px;
	padding: 2.5rem;
	background-color: var(--surface-color);
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-md);
}

/* Table Controls */
.table-controls {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
}

/* Status Badges */
.status-badge {
	padding: 0.25em 0.6em;
	font-size: 0.8rem;
	font-weight: 600;
	border-radius: 20px;
	text-transform: uppercase;
}

.status-ok {
	background-color: var(--success-color);
	color: #fff;
}

.status-warn {
	background-color: var(--warning-color);
	color: #000;
}

.status-danger {
	background-color: var(--danger-color);
	color: #fff;
}

.status-info {
	background-color: var(--text-muted-color);
	color: #fff;
}

/* Details List (for User/Event Details) */
.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 0.5rem;
}

@media (max-width: 576px) {
    .details-list li {
        flex-direction: column;
        align-items: flex-start;
    }
}

.details-list li:last-child {
	border-bottom: none;
}

.details-subtitle {
	font-size: 1.1rem;
	color: var(--text-muted-color);
	margin-bottom: 1.5rem;
}

/* Star Rating (for Feedback Form) */
.star-rating {
	display: flex;
	flex-direction: row-reverse;
	justify-content: flex-end;
	font-size: 2em;
}

.star-rating input {
	display: none;
}

.star-rating label {
	color: #ccc;
	cursor: pointer;
	transition: color 0.2s;
}

.star-rating label:before {
	content: '★';
}

.star-rating input:checked ~ label, .star-rating:not(:checked)>label:hover,
	.star-rating:not(:checked)>label:hover ~ label {
	color: #ffc107;
}

/* File Manager (admin_files.jsp) */
.file-manager-layout {
	display: grid;
	gap: 1.5rem;
	grid-template-columns: 1fr;
}

@media ( min-width : 992px) {
	.file-manager-layout {
		grid-template-columns: 300px 1fr;
	}
}

.category-list {
	list-style: none;
	padding: 0;
}

.category-list li {
	padding: 0.75rem;
	cursor: pointer;
	border-radius: 6px;
	transition: background-color 0.2s;
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.category-list li.active {
	background-color: var(--primary-color-light);
	font-weight: 600;
	color: var(--primary-color);
}

.category-list li:hover:not(.active) {
	background-color: var(--bg-color);
}

.file-list {
	list-style: none;
	padding: 0;
}

.file-list li {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
}

.file-list li:last-child {
	border-bottom: none;
}

.file-info {
	flex-grow: 1;
}

.file-info .file-meta {
	display: block;
	font-size: 0.8rem;
	color: var(--text-muted-color);
}

.category-actions-grid {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1.5rem;
}

@media ( min-width : 768px) {
	.category-actions-grid {
		grid-template-columns: 1fr 1fr;
	}
}

/* QR Action Page */
.qr-action-body {
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: 100vh;
	background-color: var(--bg-color);
}

.qr-action-container {
	text-align: center;
	width: 90%;
	max-width: 400px;
}

.qr-action-item-name {
	font-size: 1.5rem;
	font-weight: bold;
	margin-bottom: 2rem;
}

.qr-action-buttons {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1rem;
}

.qr-action-btn {
	font-size: 1.2rem;
	padding: 1.5rem;
}

/* Lightbox */
.lightbox-overlay {
	display: none;
	position: fixed;
	z-index: 3000;
	padding: 1rem;
	justify-content: center;
	align-items: center;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	overflow: auto;
	background-color: rgba(0, 0, 0, 0.8);
}

.lightbox-content {
	margin: auto;
	display: block;
	width: auto;
	height: auto;
	max-width: 90vw;
	max-height: 90vh;
}

.lightbox-close {
	position: absolute;
	top: 15px;
	right: 35px;
	color: #f1f1f1;
	font-size: 40px;
	font-weight: bold;
	transition: 0.3s;
}

.lightbox-close:hover, .lightbox-close:focus {
	color: #bbb;
	text-decoration: none;
	cursor: pointer;
}

/* Matrix Table */
.data-table .sticky-header {
	position: sticky;
	top: 0;
	z-index: 10;
}

.data-table .sticky-col {
	position: sticky;
	left: 0;
	background-color: var(--surface-color);
	z-index: 5;
}

.data-table .qual-cell[data-attended="true"] {
	color: var(--success-color);
}

.horizontal-scroll-hint {
    display: none;
    text-align: center;
    padding: 0.5rem;
    background-color: var(--warning-color);
    color: #000;
    font-weight: 500;
    border-radius: var(--border-radius);
    margin-bottom: 1rem;
}

@media (max-width: 768px) {
    .horizontal-scroll-hint {
        display: block;
    }
}

/* Progress Bars (System Page) */
.progress-bar-container {
	width: 100%;
	background-color: var(--border-color);
	border-radius: 8px;
	overflow: hidden;
	height: 25px;
}

.progress-bar {
	height: 100%;
	background-color: var(--primary-color);
	transition: width 0.5s ease-in-out;
}

.progress-text {
	text-align: center;
	font-weight: 500;
	margin-top: 0.5rem;
}

/* NEW: Storage Page Redesign Styles */
.item-name-cell {
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.camera-btn {
	background: transparent;
	border: 1px solid var(--border-color);
	color: var(--text-muted-color);
	padding: 0.2rem 0.5rem;
	line-height: 1;
	border-radius: 4px;
}

.camera-btn:hover {
	background: var(--bg-color);
	color: var(--primary-color);
	border-color: var(--primary-color);
}

.inventory-details, .item-status-details {
	display: block;
	font-size: 0.85rem;
	color: var(--text-muted-color);
}

.kit-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    flex-wrap: wrap; /* Allow wrapping on mobile */
    gap: 1rem;
}

/* Custom Calendar List (Mobile) */
.termin-list {
    list-style: none;
    padding: 0;
}
.termin-item-link {
    text-decoration: none;
    color: inherit;
    display: block;
}
.termin-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    background-color: var(--surface-color);
    border-bottom: 1px solid var(--border-color);
    transition: background-color 0.2s;
}
.termin-item:hover {
    background-color: var(--bg-color);
}
.termin-list li:first-child {
    border-top: 1px solid var(--border-color);
}
.termin-month-header {
    margin-top: 2rem;
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-muted-color);
    border: none;
    padding: 0;
}
.termin-date {
    flex-shrink: 0;
    text-align: center;
    margin-right: 1.5rem;
    width: 60px;
}
.termin-date-day {
    font-size: 1.8rem;
    font-weight: 600;
    display: block;
    line-height: 1;
    color: var(--primary-color);
}
.termin-date-month {
    font-size: 0.9rem;
    text-transform: uppercase;
    font-weight: 500;
    display: block;
    color: var(--text-muted-color);
}
.termin-details {
    flex-grow: 1;
}
.termin-title {
    font-weight: 600;
    display: block;
    margin-bottom: 0.25rem;
}
.termin-type-event {
    background-color: var(--danger-color);
    color: white;
}
.termin-type-lehrgang {
    background-color: var(--primary-color);
    color: white;
}
.termin-arrow {
    color: var(--text-muted-color);
    margin-left: 1rem;
}

.mobile-list-view { display: block; }
.desktop-calendar-view { display: none; }

@media (min-width: 992px) {
    .mobile-list-view { display: none; }
    .desktop-calendar-view { display: block; }
}


/* --- 8. ERROR PAGES --- */
.error-page-container {
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	text-align: center;
	min-height: 70vh;
	padding: 2rem;
}

.error-code {
	font-size: 5rem;
	font-weight: 800;
	line-height: 1;
	margin: 0;
	color: var(--text-muted-color);
}

.error-page-container h2 {
	font-size: 1.75rem;
	border: none;
	margin: 0 0 1.5rem 0;
}

.error-message-text {
	max-width: 600px;
	font-size: 1.1rem;
	line-height: 1.6;
	margin-bottom: 2rem;
}

/* --- 9. KEYFRAME ANIMATIONS --- */
@keyframes blink { 50% {
	background-color: transparent;
}

}

/* =================================================================== */
/*  10. CHAT INTERFACE (Combined & Final)                              */
/* =================================================================== */
.chat-message-container {
	display: flex;
	align-items: center;
	margin-bottom: 0.75rem;
	position: relative;
	max-width: 90%; /* Prevent bubbles from taking the full width */
	align-self: flex-start; /* Default alignment for others' messages */
}

.chat-message-container.current-user {
	align-self: flex-end;
}

.chat-bubble {
	padding: 0.6rem 0.9rem;
	border-radius: 18px;
	word-wrap: break-word;
	border: 1px solid transparent;
}

.chat-bubble.current-user-bubble {
	background-color: var(--primary-color) !important;
	color: #fff !important;
	border-color: var(--primary-color) !important;
}

.chat-username {
	display: block;
	font-size: 0.8rem;
	font-weight: 700;
	margin-bottom: 0.2rem;
}

.chat-text {
	display: block;
	font-size: 1rem;
	line-height: 1.4;
}

.chat-timestamp {
	display: block;
	font-size: 0.75rem;
	margin-top: 0.3rem;
	text-align: right;
}

.chat-edited-marker {
	font-size: 0.7em;
	font-style: italic;
	color: inherit;
}

.chat-options {
	opacity: 0;
	transition: opacity 0.2s;
	display: flex;
	gap: 0.25rem;
	background-color: var(--surface-color);
	padding: 0.25rem;
	border-radius: 20px;
	box-shadow: var(--shadow-md);
	margin: 0 0.5rem;
}

.chat-message-container:hover .chat-options {
	opacity: 1;
}

.chat-message-container {
	flex-direction: row;
}

.chat-message-container.current-user {
	flex-direction: row-reverse;
}

.chat-option-btn {
	background: none;
	border: none;
	cursor: pointer;
	color: var(--text-muted-color);
	width: 28px;
	height: 28px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
}

.chat-option-btn:hover {
	background-color: var(--bg-color);
	color: var(--text-color);
}

.chat-edit-input {
	width: 100%;
	padding: 0.2rem 0.4rem;
	border: 1px solid var(--primary-color);
	border-radius: 4px;
	background: var(--surface-color);
	color: var(--text-color);
	font-family: inherit;
	font-size: 1rem;
}

.chat-bubble.deleted {
	font-style: italic;
	opacity: 0.7;
}

.chat-deleted-info {
	font-size: 0.9em;
}

#chat-box {
	display: flex;
	flex-direction: column;
}

/* =================================================================== */
/*  11. SIDEBAR CONTROLS & EDITOR STYLES                               */
/* =================================================================== */
.sidebar-controls {
	display: flex;
	justify-content: space-between;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1rem;
}

.sidebar-controls .btn {
	flex-grow: 1;
}

/* Theme & Mode Switcher Container Styles */
.theme-switcher, .mode-switcher {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	color: var(--text-muted-color);
}

/* Generic Toggle Switch Component */
.toggle-switch {
	position: relative;
	display: inline-block;
	width: 44px;
	height: 24px;
}

.toggle-switch input {
	opacity: 0;
	width: 0;
	height: 0;
}

.toggle-switch .slider {
	position: absolute;
	cursor: pointer;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: #ccc;
	transition: .4s;
	border-radius: 24px;
}

.toggle-switch .slider:before {
	position: absolute;
	content: "";
	height: 18px;
	width: 18px;
	left: 3px;
	bottom: 3px;
	background-color: white;
	transition: .4s;
	border-radius: 50%;
}

.toggle-switch input:checked + .slider {
	background-color: var(--primary-color);
}

.toggle-switch input:checked + .slider:before {
	transform: translateX(20px);
}


/* Editor Specific Styles */
#editor-page-wrapper {
    /* Make the wrapper take up all available vertical space */
    height: calc(100vh - var(--header-height)); /* Account for mobile header */
    display: flex;
    flex-direction: column;
}

@media (min-width: 992px) {
	#editor-page-wrapper {
		/* On desktop, the main header is gone, so just 100vh */
		height: 100vh;
	}
}

#editor-page-wrapper .main-content {
    flex-grow: 1; /* Allow main-content to fill remaining height */
    padding: 1rem; /* Consistent padding on all sides */
    max-width: none; /* Remove max-width constraint for full flexibility */
    margin: 0; /* Remove auto margins to allow full width */
    display: flex;
    flex-direction: column;
    min-height: 0; /* Important for flex container to properly shrink children */
}

#editor-page-container {
    display: flex;
    flex-direction: column;
    flex-grow: 1; /* Make it fill the remaining space */
    min-height: 0; /* Crucial for nested flex items */
}

.editor-header {
	flex-shrink: 0;
	margin-bottom: 1rem;
}
.editor-header h1 {
	margin-bottom: 0;
    font-size: 1.5rem;
}
.editor-controls {
	display: flex;
	align-items: center;
	gap: 1rem;
	flex-wrap: wrap;
}
.editor-container { /* This is the flex container for editor/preview panes */
	display: flex;
	flex-direction: column; /* Stack vertically on mobile */
	gap: 1.5rem; /* Space between panes */
    flex-grow: 1; /* Allow this container to fill available height */
    min-height: 0; /* Crucial for flex item inside a flex column */
	padding: 1.5rem; /* Padding *inside* the card, around the panes */
    margin: 0; /* Remove external margins */
    border: 1px solid var(--border-color);
    box-shadow: var(--shadow-sm);
    background: var(--surface-color);
    border-radius: var(--border-radius);
}

#editor, #markdown-preview {
	flex-grow: 1; /* Allow the element to grow and fill the flex container */
	width: 100%; /* Ensure it takes full width in mobile stack */
	border: none; /* Border is now on .editor-container */
	padding: 0; /* Padding is now on .editor-container */
	background: transparent; /* Background is now on .editor-container */
    overflow-y: auto; /* Internal scrolling within each pane */
    
    /* Unified typography for WYSIWYG feel */
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
	font-size: 1rem;
	line-height: 1.6;
    color: var(--text-color);
}

#editor {
	resize: none; /* Disable manual resizing */
}

@media (min-width: 992px) {
	.editor-container {
		flex-direction: row; /* Desktop: side-by-side */
	}
	#editor, #markdown-preview {
		flex-basis: 50%; /* Distribute space evenly */
	}
}


/* =================================================================== */
/*  12. MARKDOWN STYLES                                                */
/* =================================================================== */
.markdown-content {
    overflow-wrap: break-word;
    word-wrap: break-word; /* legacy */
}

.markdown-content h1, .markdown-content h2, .markdown-content h3,
.markdown-content h4, .markdown-content h5, .markdown-content h6 {
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    font-weight: 600;
    border: none;
    padding: 0;
}
.markdown-content p {
    margin-bottom: 1rem;
}
.markdown-content ul, .markdown-content ol {
    padding-left: 2rem;
    margin-bottom: 1rem;
}
.markdown-content blockquote {
    padding: 0.5rem 1rem;
    margin: 0 0 1rem;
    font-size: 1rem;
    border-left: 0.25rem solid var(--border-color);
    background-color: var(--bg-color);
    color: var(--text-muted-color);
}
.markdown-content blockquote > :first-child {
    margin-top: 0;
}
.markdown-content blockquote > :last-child {
    margin-bottom: 0;
}
.markdown-content code {
    padding: .2em .4em;
    margin: 0;
    font-size: 85%;
    background-color: var(--primary-color-light);
    border-radius: 6px;
    font-family: monospace;
}
.markdown-content pre {
    padding: 1rem;
    overflow: auto;
    font-size: 85%;
    line-height: 1.45;
    background-color: var(--bg-color);
    border-radius: 6px;
    margin-bottom: 1rem;
}
.markdown-content pre code {
    padding: 0;
    margin: 0;
    font-size: 100%;
    background-color: transparent;
    border-radius: 0;
}
.markdown-content table {
    width: 100%;
    margin-bottom: 1rem;
    border-collapse: collapse;
    display: block;
    overflow-x: auto;
}
.markdown-content th, .markdown-content td {
    padding: 0.75rem;
    border: 1px solid var(--border-color);
}
.markdown-content thead {
    background-color: var(--bg-color);
}
.markdown-content img {
    max-width: 100%;
    height: auto;
}

/* =================================================================== */
/*  13. PRINT STYLES                                                   */
/* =================================================================== */
@media print {
	.sidebar, .mobile-header, .no-print {
		display: none !important;
	}
	.main-content-wrapper, .main-content {
		margin-left: 0 !important;
		padding: 0 !important;
	}
	body {
		background-color: #fff;
		color: #000;
	}
	.card {
		box-shadow: none;
		border: 1px solid #ccc;
		page-break-inside: avoid;
	}
	a {
		text-decoration: none;
		color: #000;
	}
	h1, h2, h3 {
		color: #000;
	}
}

/* =================================================================== */
/*  14. CUSTOM CALENDAR STYLES (NEW)                                   */
/* =================================================================== */
.calendar-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    flex-wrap: wrap;
    gap: 1rem;
}
.calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    border-top: 1px solid var(--border-color);
    border-left: 1px solid var(--border-color);
}
.calendar-header, .calendar-day {
    border-right: 1px solid var(--border-color);
    border-bottom: 1px solid var(--border-color);
    padding: 0.5rem;
}
.calendar-header {
    text-align: center;
    font-weight: 600;
    background-color: var(--bg-color);
}
.calendar-day {
    min-height: 120px;
    position: relative;
}
.calendar-day.other-month .day-number {
    color: var(--text-muted-color);
    opacity: 0.5;
}
.calendar-day.today .day-number {
    background-color: var(--primary-color);
    color: white;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
}
.day-number {
    font-size: 0.9rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
}
.calendar-event, .calendar-meeting {
    display: block;
    font-size: 0.8rem;
    padding: 0.3rem 0.6rem;
    margin-bottom: 0.3rem;
    border-radius: 4px;
    color: #fff;
    text-decoration: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    transition: opacity 0.2s;
}
.calendar-event { background-color: var(--danger-color); }
.calendar-meeting { background-color: var(--primary-color); }
.calendar-event:hover, .calendar-meeting:hover {
    opacity: 0.8;
    color: #fff;
}
.calendar-week-grid {
    display: flex;
    border-top: 1px solid var(--border-color);
    border-left: 1px solid var(--border-color);
}
.calendar-week-day {
    flex: 1;
    border-right: 1px solid var(--border-color);
}
.calendar-week-day .events-container {
    padding: 0.5rem;
    min-height: 60vh;
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\main.js
========================================================================

/**
 * Main JavaScript file for the TechnikTeam application.
 * This file is included on every page and handles global user interface logic.
 */
document.addEventListener('DOMContentLoaded', () => {

	const contextPath = document.body.dataset.contextPath || '';
	const currentPage = document.body.dataset.page || '';

	// --- GLOBAL PASSWORD VISIBILITY TOGGLE ---
	document.body.addEventListener('click', (event) => {
		const toggle = event.target.closest('.password-toggle-icon');
		if (toggle) {
			const wrapper = toggle.closest('.password-input-wrapper');
			const input = wrapper.querySelector('input[type="password"], input[type="text"]');
			const icon = toggle.querySelector('i');
			if (input) {
				const isPassword = input.getAttribute('type') === 'password';
				input.setAttribute('type', isPassword ? 'text' : 'password');
				icon.classList.toggle('fa-eye', !isPassword);
				icon.classList.toggle('fa-eye-slash', isPassword);
			}
		}
	});

	// --- MOBILE NAVIGATION ---
	const navToggle = document.querySelector('.mobile-nav-toggle');
	const pageOverlay = document.querySelector('.page-overlay');
	if (navToggle) {
		navToggle.addEventListener('click', (event) => {
			event.stopPropagation();
			document.body.classList.toggle('nav-open');
		});
	}
	if (pageOverlay) {
		pageOverlay.addEventListener('click', () => {
			document.body.classList.remove('nav-open');
		});
	}

	// --- ACTIVE NAV LINK HIGHLIGHTING ---
	const currentPath = window.location.pathname;
	document.querySelectorAll('.sidebar-nav a').forEach(link => {
		const linkPath = link.getAttribute('href');
		if (linkPath === currentPath || (currentPath.startsWith(linkPath) && linkPath !== `${contextPath}/` && linkPath !== `${contextPath}` && currentPath.charAt(linkPath.length) === '/')) {
			link.classList.add('active-nav-link');
		}
	});

	// --- THEME SWITCHER (SYNCED) ---
	const themeSwitches = document.querySelectorAll('.theme-switcher input[type="checkbox"]');
	const currentTheme = document.documentElement.dataset.theme || localStorage.getItem('theme') || 'light';
	document.documentElement.setAttribute('data-theme', currentTheme);

	const updateSwitches = (isDark) => {
		themeSwitches.forEach(sw => {
			sw.checked = isDark;
		});
	};

	updateSwitches(currentTheme === 'dark');

	themeSwitches.forEach(sw => {
		sw.addEventListener('change', (event) => {
			const newTheme = event.target.checked ? 'dark' : 'light';
			document.documentElement.setAttribute('data-theme', newTheme);
			localStorage.setItem('theme', newTheme);
			updateSwitches(event.target.checked);

			const csrfToken = document.body.dataset.csrfToken;
			const formData = new URLSearchParams();
			formData.append('theme', newTheme);
			if (csrfToken) {
				formData.append('csrfToken', csrfToken);
			}
			fetch(`${contextPath}/api/user/preferences`, {
				method: 'POST',
				body: formData
			}).catch(err => console.error("Failed to sync theme with server:", err));
		});
	});

	// --- PERSISTENT SIDEBAR SCROLL POSITION ---
	const sidebarNav = document.querySelector('.sidebar-nav');
	const scrollPositionKey = 'sidebarScrollPosition';

	if (sidebarNav) {
		const savedPosition = sessionStorage.getItem(scrollPositionKey);
		if (savedPosition) {
			sidebarNav.scrollTop = parseInt(savedPosition, 10);
		}
		window.addEventListener('beforeunload', () => {
			sessionStorage.setItem(scrollPositionKey, sidebarNav.scrollTop);
		});
	}

	// --- GLOBAL CONFIRMATION MODAL ---
	const confirmationModalElement = document.createElement('div');
	confirmationModalElement.className = 'modal-overlay';
	confirmationModalElement.id = 'confirmation-modal';
	confirmationModalElement.innerHTML = `
        <div class="modal-content" style="max-width: 450px;">
            <h3 id="confirmation-title">Bestätigung erforderlich</h3>
            <p id="confirmation-message" style="margin: 1.5rem 0; font-size: 1.1rem;"></p>
            <div style="display: flex; justify-content: flex-end; gap: 1rem;">
                <button id="confirmation-btn-cancel" class="btn" style="background-color: var(--text-muted-color);">Abbrechen</button>
                <button id="confirmation-btn-confirm" class="btn btn-danger">Bestätigen</button>
            </div>
        </div>`;
	document.body.appendChild(confirmationModalElement);

	const messageElement = document.getElementById('confirmation-message');
	const confirmBtn = document.getElementById('confirmation-btn-confirm');
	const cancelBtn = document.getElementById('confirmation-btn-cancel');

	let onConfirmCallback = null;

	window.showConfirmationModal = (message, onConfirm) => {
		messageElement.textContent = message;
		onConfirmCallback = onConfirm;
		confirmationModalElement.classList.add('active');
	};

	const closeConfirmModal = () => {
		confirmationModalElement.classList.remove('active');
		onConfirmCallback = null;
	};

	confirmBtn.addEventListener('click', () => {
		if (typeof onConfirmCallback === 'function') onConfirmCallback();
		closeConfirmModal();
	});

	cancelBtn.addEventListener('click', closeConfirmModal);
	confirmationModalElement.addEventListener('click', (e) => {
		if (e.target === confirmationModalElement) closeConfirmModal();
	});

	const logoutLink = document.getElementById('logout-link');
	if (logoutLink) {
		logoutLink.addEventListener('click', (event) => {
			event.preventDefault();
			showConfirmationModal(
				'Möchten Sie sich wirklich ausloggen?',
				() => { window.location.href = logoutLink.href; }
			);
		});
	}

	// --- GLOBAL EVENT DELEGATION FOR MODALS & CONFIRMATIONS ---
	document.body.addEventListener('click', (event) => {
		const modalOpenTrigger = event.target.closest('[data-modal-target]');
		if (modalOpenTrigger) {
			event.preventDefault();
			const modalId = modalOpenTrigger.dataset.modalTarget;
			const modal = document.getElementById(modalId);
			if (modal) {
				modal.classList.add('active');
			}
		}

		const modalCloseTrigger = event.target.closest('[data-modal-close]');
		if (modalCloseTrigger) {
			event.preventDefault();
			const modal = modalCloseTrigger.closest('.modal-overlay');
			if (modal) {
				modal.classList.remove('active');
			}
		}
	});

	document.body.addEventListener('submit', (event) => {
		const form = event.target;
		if (form.matches('.js-confirm-form')) {
			event.preventDefault();
			const message = form.dataset.confirmMessage || 'Sind Sie sicher?';
			showConfirmationModal(message, () => form.submit());
		}
	});

	// --- GLOBAL TOAST NOTIFICATIONS ---
	window.showToast = (message, type = 'success') => {
		const toast = document.createElement('div');
		toast.className = `toast toast-${type}`;
		toast.innerHTML = `<p>${message}</p>`;
		document.body.appendChild(toast);
		setTimeout(() => { toast.classList.add('show'); }, 100);
		setTimeout(() => {
			toast.classList.remove('show');
			setTimeout(() => { toast.remove(); }, 500);
		}, 5000);
	};

	// --- SERVER-SENT EVENTS (SSE) NOTIFICATIONS & UI UPDATES ---
	if (document.body.dataset.isLoggedIn === 'true' && window.EventSource && currentPage !== 'editor') {
		const eventSource = new EventSource(`${contextPath}/notifications`);
		eventSource.onopen = () => console.log("SSE connection established.");
		eventSource.onmessage = (event) => {
			try {
				const data = JSON.parse(event.data);
				if (data.type === 'ui_update') {
					handleUIUpdate(data.payload);
				} else if (data.type === 'logout_notification') {
					showToast(data.payload.message, 'info');
					setTimeout(() => { window.location.href = `${contextPath}/logout`; }, 4000);
				} else {
					showBrowserNotification(data.payload);
				}
			} catch (e) {
				showBrowserNotification({ message: event.data });
			}
		};
		eventSource.onerror = (err) => {
			console.error("SSE connection error.", err);
			eventSource.close();
		};
	}

	const feedbackStatusOrder = { 'NEW': 0, 'VIEWED': 1, 'PLANNED': 2, 'COMPLETED': 3, 'REJECTED': 4 };

	// --- UI UPDATE HANDLER (COMPLETE & UNABBREVIATED) ---
	function handleUIUpdate(payload) {
		console.log("Handling UI update:", payload.updateType, payload.data);
		const getStatusBadgeClass = (status, prefix = 'status-') => {
			const classMap = {
				'LAUFEND': 'warn', 'ABGESCHLOSSEN': 'info', 'ABGESAGT': 'info',
				'GEPLANT': 'ok', 'KOMPLETT': 'ok',
				'NEW': 'info', 'VIEWED': 'info', 'PLANNED': 'warn',
				'COMPLETED': 'ok', 'REJECTED': 'danger'
			};
			return prefix + (classMap[status] || 'info');
		};

		switch (payload.updateType) {
			case 'user_updated':
				const user = payload.data;
				document.querySelectorAll(`[data-user-id="${user.id}"]`).forEach(el => {
					const usernameEl = el.querySelector('[data-field="username"]');
					const roleNameEl = el.querySelector('[data-field="roleName"]');
					if (usernameEl) usernameEl.textContent = user.username;
					if (roleNameEl) roleNameEl.textContent = user.roleName;
				});
				break;
			case 'user_deleted':
				document.querySelectorAll(`[data-user-id="${payload.data.userId}"]`).forEach(el => {
					el.style.transition = 'opacity 0.5s';
					el.style.opacity = '0';
					setTimeout(() => el.remove(), 500);
				});
				break;
			case 'event_status_updated':
				const { eventId, newStatus } = payload.data;
				document.querySelectorAll(`[data-event-id="${eventId}"]`).forEach(element => {
					const badge = element.querySelector('.status-badge');
					if (badge) {
						badge.textContent = newStatus;
						badge.className = `status-badge ${getStatusBadgeClass(newStatus)}`;
					}
				});
				break;
			case 'feedback_status_updated':
				const { submissionId, newStatus: newFeedbackStatus } = payload.data;
				const card = document.querySelector(`.feedback-card[data-submission-id="${submissionId}"]`);
				if (card) {
					// 1. Update the data attribute and badge
					card.dataset.status = newFeedbackStatus;
					const badge = card.querySelector('.status-badge');
					if (badge) {
						badge.textContent = newFeedbackStatus;
						badge.className = `status-badge ${getStatusBadgeClass(newFeedbackStatus)}`;
					}

					// 2. Re-sort the list
					const container = card.parentElement;
					const allCards = Array.from(container.querySelectorAll('.feedback-card'));

					allCards.sort((a, b) => {
						const statusA = feedbackStatusOrder[a.dataset.status] ?? 99;
						const statusB = feedbackStatusOrder[b.dataset.status] ?? 99;
						return statusA - statusB;
					});

					// 3. Re-append sorted cards
					allCards.forEach(c => container.appendChild(c));
				}
				break;
			case 'feedback_deleted':
				const cardToDelete = document.querySelector(`[data-submission-id="${payload.data.submissionId}"]`);
				if (cardToDelete) {
					cardToDelete.style.transition = 'opacity 0.5s';
					cardToDelete.style.opacity = '0';
					setTimeout(() => cardToDelete.remove(), 500);
				}
				break;
		}
	}

	// --- BROWSER NOTIFICATION HANDLER (COMPLETE & UNABBREVIATED) ---
	function showBrowserNotification(payload) {
		const message = payload.message || 'Neue Benachrichtigung';
		const url = payload.url;

		if (!("Notification" in window)) {
			console.warn("This browser does not support desktop notifications.");
			return;
		}

		const showNotification = () => {
			const notification = new Notification("Technik Team Update", {
				body: message,
				icon: `${contextPath}/images/favicon.ico`
			});

			if (url) {
				notification.onclick = (event) => {
					event.preventDefault();
					window.open(contextPath + url, '_blank');
					notification.close();
				};
			}
		};

		if (Notification.permission === "granted") {
			showNotification();
		} else if (Notification.permission !== "denied") {
			Notification.requestPermission().then((permission) => {
				if (permission === "granted") {
					showNotification();
				}
			});
		}
	}

	// --- GLOBAL MARKDOWN RENDERER ---
	window.renderMarkdown = (element) => {
		if (!element || typeof marked === 'undefined') return;
		const sanitizedHtml = marked.parse(element.textContent || '', { sanitize: true });
		element.innerHTML = sanitizedHtml;
	};

	document.querySelectorAll('.markdown-content').forEach(window.renderMarkdown);
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_achievements.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const modal = document.getElementById('achievement-modal');
	if (!modal) return;

	const form = document.getElementById('achievement-modal-form');
	const title = document.getElementById('achievement-modal-title');
	const actionInput = document.getElementById('achievement-modal-action');
	const idInput = document.getElementById('achievement-modal-id');
	const nameInput = document.getElementById('name-modal');
	const iconInput = document.getElementById('icon-modal');
	const descInput = document.getElementById('description-modal');

	// --- Key Builder Elements for Creating New Achievements ---
	const keyBuilderGroup = document.getElementById('key-builder-group');
	const keyTypeSelect = document.getElementById('key-type-select');
	const keySubtypeGroups = document.querySelectorAll('.key-subtype-group');
	const keyNumberGroup = document.getElementById('key-number-group');
	const keyValueInput = document.getElementById('key-value-input');
	const keyCourseGroup = document.getElementById('key-course-group');
	const keyCourseSelect = document.getElementById('key-course-select');
	const keyPreview = document.getElementById('generated-key-preview');
	const hiddenKeyInput = document.getElementById('achievement-key-hidden');

	/**
	 * Dynamically builds the programmatic key for the achievement based on user selections.
	 * This ensures a consistent key format.
	 */
	const updateKey = () => {
		const type = keyTypeSelect.value;
		let generatedKey = '';

		// Hide all subtype groups initially for a clean slate
		keySubtypeGroups.forEach(group => group.style.display = 'none');

		if (type === 'EVENT_PARTICIPANT' || type === 'EVENT_LEADER') {
			keyNumberGroup.style.display = 'block';
			const value = keyValueInput.value || '1';
			generatedKey = `${type}_${value}`;
		} else if (type === 'QUALIFICATION') {
			keyCourseGroup.style.display = 'block';
			const value = keyCourseSelect.value;
			if (value) {
				generatedKey = `${type}_${value}`;
			}
		}

		keyPreview.textContent = generatedKey || '-- Bitte eine Art wählen --';
		hiddenKeyInput.value = generatedKey;
	};

	if (keyTypeSelect) keyTypeSelect.addEventListener('change', updateKey);
	if (keyValueInput) keyValueInput.addEventListener('input', updateKey);
	if (keyCourseSelect) keyCourseSelect.addEventListener('change', updateKey);

	// --- Event Listeners for Buttons ---
	document.getElementById('new-achievement-btn').addEventListener('click', () => {
		form.reset();
		title.textContent = 'Neuen Erfolg anlegen';
		actionInput.value = 'create';
		idInput.value = '';
		keyBuilderGroup.style.display = 'block'; // Show key builder for new achievements
		updateKey(); // Initialize/reset the key builder state
	});

	document.querySelectorAll('.edit-achievement-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			const id = btn.dataset.id;
			try {
				const response = await fetch(`${contextPath}/admin/achievements?action=getAchievementData&id=${id}`);
				if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
				const data = await response.json();

				form.reset();
				title.textContent = 'Erfolg bearbeiten';
				actionInput.value = 'update';
				idInput.value = data.id;
				nameInput.value = data.name || '';
				iconInput.value = data.iconClass || 'fa-award';
				descInput.value = data.description || '';
				keyBuilderGroup.style.display = 'none'; // Hide key builder on edit, as the key is immutable

			} catch (error) {
				console.error('Failed to open edit modal:', error);
				alert("Fehler: Die Daten für diesen Erfolg konnten nicht geladen werden.");
			}
		});
	});

	// --- Generic Modal Closing ---
	modal.addEventListener('click', (e) => {
		if (e.target === modal) modal.classList.remove('active');
	});
	document.addEventListener('keydown', (e) => {
		if (e.key === 'Escape' && modal.classList.contains('active')) modal.classList.remove('active');
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_course_list.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	// --- Edit/Create Modal Logic ---
	const courseModal = document.getElementById('course-modal');
	if (courseModal) {
		const form = document.getElementById('course-modal-form');
		const title = document.getElementById('course-modal-title');
		const actionInput = document.getElementById('course-modal-action');
		const idInput = document.getElementById('course-modal-id');
		const nameInput = document.getElementById('name-modal');
		const abbrInput = document.getElementById('abbreviation-modal');
		const descInput = document.getElementById('description-modal');

		document.getElementById('new-course-btn')?.addEventListener('click', () => {
			form.reset();
			title.textContent = "Neue Lehrgangs-Vorlage anlegen";
			actionInput.value = "create";
			idInput.value = "";
		});

		document.querySelectorAll('.edit-course-btn').forEach(btn => {
			btn.addEventListener('click', async (e) => {
				form.reset();
				title.textContent = "Lehrgangs-Vorlage bearbeiten";
				actionInput.value = "update";
				const courseId = e.currentTarget.dataset.id;
				idInput.value = courseId;

				try {
					const response = await fetch(`${contextPath}/admin/lehrgaenge?action=getCourseData&id=${courseId}`);
					if (!response.ok) throw new Error('Could not fetch course data');
					const data = await response.json();

					nameInput.value = data.name || '';
					abbrInput.value = data.abbreviation || '';
					descInput.value = data.description || '';
				} catch (error) {
					console.error("Failed to open edit modal:", error);
					alert("Fehler beim Laden der Vorlagen-Daten.");
				}
			});
		});
	}

	// --- Grant Qualifications Modal Logic ---
	const grantQualsModal = document.getElementById('grant-quals-modal');
	if (grantQualsModal) {
		const modalTitle = document.getElementById('grant-quals-modal-title');
		const courseIdInput = document.getElementById('grant-quals-course-id');

		document.querySelectorAll('.grant-quals-btn').forEach(btn => {
			btn.addEventListener('click', (e) => {
				const button = e.currentTarget;
				modalTitle.textContent = `Qualifikationen für "${button.dataset.courseName}" vergeben`;
				courseIdInput.value = button.dataset.courseId;
			});
		});
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_dashboard.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	let eventChartInstance = null;

	const upcomingEventsContainer = document.getElementById('widget-upcoming-events');
	const lowStockContainer = document.getElementById('widget-low-stock');
	const recentLogsContainer = document.getElementById('widget-recent-logs');
	const eventTrendCanvas = document.getElementById('eventTrendChart');

	function formatDateTime(isoString) {
		if (!isoString) return 'N/A';
		const date = new Date(isoString);
		return date.toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
	}

	function createAlertBanner(message, type = 'info') {
		const banner = document.createElement('div');
		banner.className = `${type}-message`; // info-message, error-message, etc.
		const iconClass = type === 'danger' ? 'fa-exclamation-triangle' : 'fa-info-circle';
		banner.innerHTML = `<i class="fas ${iconClass}"></i> ${message}`;
		return banner;
	}

	function renderUpcomingEvents(events) {
		const header = '<h2><i class="fas fa-calendar-check"></i> Nächste Einsätze</h2>';
		if (!events || events.length === 0) {
			upcomingEventsContainer.innerHTML = header + '<p>Keine anstehenden Einsätze gefunden.</p>';
			return;
		}

		const list = events.map(event => `
            <li>
                <a href="${contextPath}/veranstaltungen/details?id=${event.id}">${event.name}</a>
                <small>${formatDateTime(event.eventDateTime)} Uhr</small>
            </li>
        `).join('');

		upcomingEventsContainer.innerHTML = header + `<ul class="details-list">${list}</ul>`;
	}

	function renderLowStockItems(items) {
		const header = '<h2><i class="fas fa-battery-quarter"></i> Niedriger Lagerbestand</h2>';

		let content = '';
		if (!items || items.length === 0) {
			content = '<p>Alle Artikel sind ausreichend vorhanden.</p>';
		} else {
			const list = items.map(item => {
				const percentage = item.maxQuantity > 0 ? ((item.quantity - item.defectiveQuantity) / item.maxQuantity * 100).toFixed(0) : 0;
				return `
                    <li>
                        <a href="${contextPath}/lager/details?id=${item.id}">${item.name}</a>
                        <span class="status-badge status-warn">${percentage}%</span>
                    </li>
                `;
			}).join('');
			content = `<ul class="details-list">${list}</ul>`;

			// Add an alert banner if there are low stock items
			const alertMessage = `Es gibt ${items.length} Artikel mit niedrigem Lagerbestand. <a href="${contextPath}/admin/lager">Jetzt prüfen</a>.`;
			const banner = createAlertBanner(alertMessage, 'danger');
			lowStockContainer.prepend(banner);
		}

		lowStockContainer.innerHTML = header + content;
	}

	function renderRecentLogs(logs) {
		const header = '<h2><i class="fas fa-history"></i> Letzte Aktivitäten</h2>';
		if (!logs || logs.length === 0) {
			recentLogsContainer.innerHTML = header + '<p>Keine aktuellen Aktivitäten protokolliert.</p>';
			return;
		}

		const list = logs.map(log => `
            <li>
                <div>
                    <strong>${log.actionType}</strong> von <em>${log.adminUsername}</em>
                    <small style="display: block; color: var(--text-muted-color);">${log.details}</small>
                </div>
                <small>${formatDateTime(log.actionTimestamp)}</small>
            </li>
        `).join('');

		recentLogsContainer.innerHTML = header + `<ul class="details-list">${list}</ul>`;
	}

	function renderEventTrendChart(trendData) {
		if (eventChartInstance) {
			eventChartInstance.destroy();
		}

		if (!trendData || trendData.length === 0) {
			return;
		}

		const labels = trendData.map(d => d.month);
		const data = trendData.map(d => d.count);

		const chartConfig = {
			type: 'line',
			data: {
				labels: labels,
				datasets: [{
					label: 'Anzahl Events pro Monat',
					data: data,
					fill: true,
					borderColor: 'rgb(0, 123, 255)',
					backgroundColor: 'rgba(0, 123, 255, 0.1)',
					tension: 0.1
				}]
			},
			options: {
				responsive: true,
				maintainAspectRatio: false,
				scales: {
					y: {
						beginAtZero: true,
						ticks: {
							stepSize: 1,
							precision: 0
						}
					}
				},
				plugins: {
					legend: {
						display: false
					}
				}
			}
		};

		eventChartInstance = new Chart(eventTrendCanvas.getContext('2d'), chartConfig);
	}

	async function fetchData() {
		try {
			const response = await fetch(`${contextPath}/api/admin/dashboard-data`);
			if (!response.ok) {
				throw new Error(`HTTP error! status: ${response.status}`);
			}
			const data = await response.json();

			renderUpcomingEvents(data.upcomingEvents);
			renderLowStockItems(data.lowStockItems);
			renderRecentLogs(data.recentLogs);
			renderEventTrendChart(data.eventTrendData);

		} catch (error) {
			console.error("Failed to fetch dashboard data:", error);
			upcomingEventsContainer.innerHTML = '<h2><i class="fas fa-calendar-check"></i> Nächste Einsätze</h2><p class="error-message">Fehler beim Laden der Daten.</p>';
			lowStockContainer.innerHTML = '<h2><i class="fas fa-battery-quarter"></i> Niedriger Lagerbestand</h2><p class="error-message">Fehler beim Laden der Daten.</p>';
			recentLogsContainer.innerHTML = '<h2><i class="fas fa-history"></i> Letzte Aktivitäten</h2><p class="error-message">Fehler beim Laden der Daten.</p>';
		}
	}

	fetchData();
	setInterval(fetchData, 60000); // Re-fetch every 60 seconds
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_defect_list.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const defectModal = document.getElementById('defect-modal');
	if (!defectModal) return;

	const modalTitle = document.getElementById('defect-modal-title');
	const itemIdInput = document.getElementById('defect-item-id');
	const defectQtyInput = document.getElementById('defective_quantity');
	const reasonInput = document.getElementById('defect_reason');

	/**
	 * Attaches an event listener to all "Status bearbeiten" buttons to open the defect modal.
	 */
	document.querySelectorAll('.defect-modal-btn').forEach(btn => {
		btn.addEventListener('click', () => {
			// Populate the modal with data from the clicked button's data attributes
			modalTitle.textContent = `Defekt-Status für "${btn.dataset.itemName}" bearbeiten`;
			itemIdInput.value = btn.dataset.itemId;
			defectQtyInput.value = btn.dataset.currentDefectQty;
			defectQtyInput.max = btn.dataset.maxQty; // Set max value to prevent invalid input
			reasonInput.value = btn.dataset.currentReason;
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_editor.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const editorContainer = document.getElementById('editor-page-container');
	if (!editorContainer) return;

	const fileId = editorContainer.dataset.fileId;
	const editor = document.getElementById('editor');
	const preview = document.getElementById('markdown-preview');
	const toggle = document.getElementById('mode-toggle');
	const statusIndicator = document.getElementById('save-status-indicator');

	let socket;
	let debounceTimer;

	// Function to render markdown content
	const renderMarkdown = (content) => {
		if (typeof marked !== 'undefined') {
			preview.innerHTML = marked.parse(content, { sanitize: true });
		}
	};

	// --- Status Indicator Logic ---
	const showStatus = (state, message) => {
		if (statusIndicator) {
			statusIndicator.style.display = 'inline-block';
			statusIndicator.className = `status-badge status-${state}`;
			statusIndicator.textContent = message;
		}
	};

	// --- WebSocket Connection Logic ---
	const connect = () => {
		const websocketProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
		const websocketUrl = `${websocketProtocol}//${window.location.host}${document.body.dataset.contextPath}/ws/editor/${fileId}`;

		socket = new WebSocket(websocketUrl);

		socket.onopen = () => {
			console.log('WebSocket connection established.');
			showStatus('ok', 'Verbunden');
		};

		socket.onmessage = (event) => {
			const data = JSON.parse(event.data);
			if (data.type === 'content_update') {
				console.log('Received content update from another client.');

				// Save cursor position before updating
				const cursorStart = editor.selectionStart;
				const cursorEnd = editor.selectionEnd;

				editor.value = data.payload;
				renderMarkdown(data.payload);

				// Restore cursor position
				editor.setSelectionRange(cursorStart, cursorEnd);
			}
		};

		socket.onclose = () => {
			console.warn('WebSocket connection closed.');
			showStatus('danger', 'Getrennt');
			setTimeout(connect, 5000); // Try to reconnect after 5 seconds
		};

		socket.onerror = (error) => {
			console.error('WebSocket error:', error);
			showStatus('danger', 'Verbindungsfehler');
		};
	};


	// --- Event Listeners ---
	if (editor.readOnly) {
		renderMarkdown(editor.value);
		return;
	}

	connect();
	renderMarkdown(editor.value);

	// Debounced function to send content updates
	const sendContentUpdate = () => {
		if (socket && socket.readyState === WebSocket.OPEN) {
			const payload = {
				type: 'content_update',
				payload: editor.value
			};
			socket.send(JSON.stringify(payload));
			showStatus('warn', 'Speichern...');
			// Give visual feedback that saving is complete
			setTimeout(() => {
				if (statusIndicator.textContent === 'Speichern...') {
					showStatus('ok', 'Gespeichert');
				}
			}, 1000);
		}
	};

	// Live preview and debounced saving on input
	editor.addEventListener('input', () => {
		renderMarkdown(editor.value);
		clearTimeout(debounceTimer);
		debounceTimer = setTimeout(sendContentUpdate, 500); // Send update 500ms after user stops typing
	});

	// Event listener for the toggle switch
	if (toggle) {
		toggle.addEventListener('change', () => {
			if (toggle.checked) { // Edit mode
				editor.style.display = 'block';
				preview.style.display = 'none';
			} else { // View mode
				renderMarkdown(editor.value);
				editor.style.display = 'none';
				preview.style.display = 'block';
			}
		});
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_events_list.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	document.querySelectorAll('.js-confirm-form').forEach(form => {
		form.addEventListener('submit', function(e) {
			e.preventDefault();
			showConfirmationModal(this.dataset.confirmMessage || 'Sind Sie sicher?', () => this.submit());
		});
	});

	// Client-side file size validation
	document.querySelectorAll('.file-input').forEach(input => {
		input.addEventListener('change', (e) => {
			const file = e.target.files[0];
			if (!file) return;

			const maxSize = parseInt(e.target.dataset.maxSize, 10);
			const warningElement = e.target.closest('.form-group').querySelector('.file-size-warning');

			if (file.size > maxSize) {
				if (warningElement) warningElement.style.display = 'block';
				e.target.value = ''; // Clear the invalid selection
			} else {
				if (warningElement) warningElement.style.display = 'none';
			}
		});
	});

	const assignModal = document.getElementById('assign-users-modal');
	const eventModal = document.getElementById('event-modal');
	const reqContainer = document.getElementById('modal-requirements-container');
	const resContainer = document.getElementById('modal-reservations-container');
	const cfContainer = document.getElementById('modal-custom-fields-container');
	const attachmentsList = document.getElementById('modal-attachments-list');
	const kitSelect = document.getElementById('kit-selection-modal');
	const findCrewBtn = document.getElementById('find-crew-btn');
	const findCrewModal = document.getElementById('find-crew-modal');

	const allCourses = JSON.parse(document.getElementById('allCoursesData').textContent);
	const allItems = JSON.parse(document.getElementById('allItemsData').textContent);

	const assignForm = document.getElementById('assign-users-form');
	const assignModalTitle = document.getElementById('assign-users-modal-title');
	const assignCheckboxes = document.getElementById('user-checkboxes-container');
	const assignEventIdInput = assignForm.querySelector('input[name="eventId"]');

	const openAssignModal = async (btn) => {
		const eventId = btn.dataset.eventId;
		const eventName = btn.dataset.eventName;
		assignModalTitle.textContent = `Team für "${eventName}" zuweisen`;
		assignEventIdInput.value = eventId;
		assignCheckboxes.innerHTML = '<p>Lade Benutzer...</p>';
		assignModal.classList.add('active');
		try {
			const response = await fetch(`${contextPath}/admin/veranstaltungen?action=getAssignmentData&id=${eventId}`);
			if (!response.ok) throw new Error('Could not fetch assignment data.');
			const data = await response.json();
			assignCheckboxes.innerHTML = '';
			if (data.signedUpUsers && data.signedUpUsers.length > 0) {
				data.signedUpUsers.forEach(user => {
					const isChecked = data.assignedUserIds.includes(user.id) ? 'checked' : '';
					assignCheckboxes.innerHTML += `
						<label class="checkbox-label">
							<input type="checkbox" name="userIds" value="${user.id}" ${isChecked}>
							${user.username}
						</label>`;
				});
			} else {
				assignCheckboxes.innerHTML = '<p>Es haben sich noch keine Benutzer für dieses Event angemeldet.</p>';
			}
		} catch (error) {
			assignCheckboxes.innerHTML = '<p class="error-message">Fehler beim Laden der Benutzerdaten.</p>';
			console.error('Error fetching assignment data:', error);
		}
	};
	document.querySelectorAll('.assign-users-btn').forEach(btn => btn.addEventListener('click', () => openAssignModal(btn)));
	assignModal.querySelector('.modal-close-btn').addEventListener('click', () => assignModal.classList.remove('active'));

	const createRow = (container) => {
		const newRow = document.createElement('div'); newRow.className = 'dynamic-row';
		const removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.className = 'btn-small btn-danger';
		removeBtn.innerHTML = '×'; removeBtn.onclick = () => newRow.remove();
		newRow.appendChild(removeBtn); container.appendChild(newRow);
		return newRow;
	};

	const addRequirementRow = (courseId = '', personCount = 1) => {
		const row = createRow(reqContainer);
		const select = document.createElement('select'); select.name = 'requiredCourseId'; select.className = 'form-group';
		select.innerHTML = '<option value="">-- Lehrgang --</option>' + allCourses.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
		select.value = courseId;
		const input = document.createElement('input'); input.type = 'number'; input.name = 'requiredPersons'; input.value = personCount; input.min = '1'; input.className = 'form-group';
		row.prepend(select, input);
	};

	const addReservationRow = (itemId = '', quantity = 1) => {
		const row = createRow(resContainer);
		const select = document.createElement('select'); select.name = 'itemId'; select.className = 'form-group';
		select.innerHTML = '<option value="">-- Material --</option>' + allItems.map(i => `<option value="${i.id}">${i.name}</option>`).join('');
		select.value = itemId;
		const input = document.createElement('input'); input.type = 'number'; input.name = 'itemQuantity'; input.value = quantity; input.min = '1'; input.className = 'form-group';
		row.prepend(select, input);
	};

	const addCustomFieldRow = (fieldName = '', fieldType = 'TEXT') => {
		const row = createRow(cfContainer);
		const nameInput = document.createElement('input');
		nameInput.type = 'text';
		nameInput.name = 'customFieldName';
		nameInput.placeholder = 'Frage eingeben (z.B. T-Shirt Größe)';
		nameInput.className = 'form-group';
		nameInput.style.flexGrow = '2';
		nameInput.value = fieldName;

		const typeSelect = document.createElement('select');
		typeSelect.name = 'customFieldType';
		typeSelect.className = 'form-group';
		typeSelect.innerHTML = `<option value="TEXT">Text</option><option value="BOOLEAN">Ja/Nein</option>`;
		typeSelect.value = fieldType;

		row.prepend(nameInput, typeSelect);
	};

	const addAttachmentRow = (id, filename, filepath) => {
		const li = document.createElement('li'); li.id = `attachment-item-${id}`;
		li.innerHTML = `<a href="${contextPath}/download?id=${id}" target="_blank">${filename}</a>`;
		const removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.className = 'btn btn-small btn-danger-outline';
		removeBtn.innerHTML = '×';
		removeBtn.onclick = () => {
			showConfirmationModal(`Anhang '${filename}' wirklich löschen?`, async () => {
				const formData = new FormData();
				formData.append('action', 'deleteAttachment');
				formData.append('id', id);
				formData.append('csrfToken', document.querySelector('#event-modal-form input[name="csrfToken"]').value);

				try {
					const response = await fetch(`${contextPath}/admin/veranstaltungen`, {
						method: 'POST',
						body: new URLSearchParams(formData)
					});
					if (response.ok) li.remove();
					else alert('Fehler beim Löschen des Anhangs.');
				} catch (e) {
					console.error('Error deleting attachment:', e);
					alert('Netzwerkfehler beim Löschen des Anhangs.');
				}
			});
		};
		li.appendChild(removeBtn); attachmentsList.appendChild(li);
	};

	if (kitSelect) {
		kitSelect.addEventListener('change', async () => {
			const kitId = kitSelect.value;
			if (!kitId) return;

			try {
				const response = await fetch(`${contextPath}/admin/kits?action=getKitItems&id=${kitId}`);
				if (!response.ok) throw new Error('Could not fetch kit items');
				const items = await response.json();
				items.forEach(item => addReservationRow(item.itemId, item.quantity));
			} catch (e) {
				console.error("Error fetching kit items:", e);
				alert("Fehler beim Laden der Kit-Inhalte.");
			}
			kitSelect.value = '';
		});
	}

	if (findCrewBtn) {
		findCrewBtn.addEventListener('click', async () => {
			const eventId = document.getElementById('event-modal-id').value;
			if (!eventId) {
				alert("Bitte speichern Sie das Event zuerst.");
				return;
			}
			const crewListContainer = document.getElementById('find-crew-list');
			crewListContainer.innerHTML = '<p>Suche nach qualifizierter Crew...</p>';
			findCrewModal.classList.add('active');
			try {
				const response = await fetch(`${contextPath}/api/admin/crew-finder?eventId=${eventId}`);
				if (!response.ok) throw new Error('Could not find crew members.');
				const users = await response.json();

				document.getElementById('find-crew-event-id').value = eventId;
				crewListContainer.innerHTML = '';

				if (users.length > 0) {
					users.forEach(user => {
						crewListContainer.innerHTML += `
							<label class="checkbox-label" style="padding: 0.5rem; border-bottom: 1px solid var(--border-color);">
								<input type="checkbox" name="userIds" value="${user.id}">
								${user.username}
							</label>`;
					});
				} else {
					crewListContainer.innerHTML = '<p>Keine passenden und verfügbaren Benutzer gefunden.</p>';
				}

			} catch (e) {
				console.error("Error finding crew:", e);
				crewListContainer.innerHTML = '<p class="error-message">Fehler bei der Crew-Suche.</p>';
			}
		});
		findCrewModal.querySelector('.modal-close-btn').addEventListener('click', () => findCrewModal.classList.remove('active'));
	}

	document.getElementById('modal-add-requirement-btn').addEventListener('click', () => addRequirementRow());
	document.getElementById('modal-add-reservation-btn').addEventListener('click', () => addReservationRow());
	document.getElementById('modal-add-custom-field-btn').addEventListener('click', () => addCustomFieldRow());

	const eventForm = document.getElementById('event-modal-form');
	const eventModalTitle = document.getElementById('event-modal-title');
	const actionInput = document.getElementById('event-modal-action');
	const idInput = document.getElementById('event-modal-id');

	const resetEventModal = () => {
		eventForm.reset();
		reqContainer.innerHTML = '';
		resContainer.innerHTML = '';
		cfContainer.innerHTML = '';
		attachmentsList.innerHTML = '';
		document.querySelectorAll('.file-size-warning').forEach(el => el.style.display = 'none');
	};

	const openEventModal = () => eventModal.classList.add('active');
	const closeEventModal = () => eventModal.classList.remove('active');
	eventModal.querySelector('.modal-close-btn').addEventListener('click', closeEventModal);
	eventModal.addEventListener('click', e => { if (e.target === eventModal) closeEventModal(); });

	document.getElementById('new-event-btn').addEventListener('click', () => {
		resetEventModal();
		eventModalTitle.textContent = "Neues Event anlegen";
		actionInput.value = "create";
		idInput.value = "";
		openEventModal();
	});

	document.querySelectorAll('.edit-event-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			const eventId = btn.dataset.eventId;
			try {
				const response = await fetch(`${contextPath}/admin/veranstaltungen?action=getEventData&id=${eventId}`);
				if (!response.ok) throw new Error('Event data could not be fetched.');
				const event = await response.json();
				resetEventModal();
				eventModalTitle.textContent = "Event bearbeiten";
				actionInput.value = "update";
				idInput.value = event.id;
				eventForm.querySelector('#name-modal').value = event.name || '';
				eventForm.querySelector('#location-modal').value = event.location || '';
				eventForm.querySelector('#leaderUserId-modal').value = event.leaderUserId || '';
				eventForm.querySelector('#eventDateTime-modal').value = event.eventDateTime ? event.eventDateTime.substring(0, 16) : '';
				eventForm.querySelector('#endDateTime-modal').value = event.endDateTime ? event.endDateTime.substring(0, 16) : '';
				eventForm.querySelector('#description-modal').value = event.description || '';

				event.skillRequirements?.forEach(req => addRequirementRow(req.requiredCourseId, req.requiredPersons));
				event.reservedItems?.forEach(res => addReservationRow(res.id, res.quantity));
				event.customFields?.forEach(cf => addCustomFieldRow(cf.fieldName, cf.fieldType));
				event.attachments?.forEach(att => addAttachmentRow(att.id, att.filename, att.filepath));

				openEventModal();
			} catch (error) {
				console.error('Error opening edit modal:', error);
				alert('Fehler beim Laden der Event-Daten.');
			}
		});
	});

	const tabButtons = eventModal.querySelectorAll('.modal-tab-button');
	const tabContents = eventModal.querySelectorAll('.modal-tab-content');
	tabButtons.forEach(button => {
		button.addEventListener('click', () => {
			tabButtons.forEach(btn => btn.classList.remove('active'));
			button.classList.add('active');
			tabContents.forEach(content => {
				content.classList.toggle('active', content.id === button.dataset.tab);
			});
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_feedback.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const csrfToken = document.body.dataset.csrfToken;

	const columns = document.querySelectorAll('.feedback-list');
	if (!columns.length || typeof Sortable === 'undefined') {
		if (typeof Sortable === 'undefined') {
			console.error("Sortable.js library not loaded. Drag & drop functionality will not be available.");
		}
		return;
	}

	const modal = document.getElementById('feedback-details-modal');
	const modalForm = document.getElementById('feedback-details-form');
	const modalIdInput = document.getElementById('feedback-modal-id');
	const modalOriginalSubject = document.getElementById('feedback-modal-original-subject');
	const modalDisplayTitle = document.getElementById('feedback-modal-display-title');
	const modalContent = document.getElementById('feedback-modal-content');
	const modalStatus = document.getElementById('feedback-modal-status');

	const api = {
		async getDetails(id) {
			const response = await fetch(`${contextPath}/admin/action/feedback?action=getDetails`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: new URLSearchParams({ submissionId: id, csrfToken: csrfToken })
			});
			if (!response.ok) throw new Error('Could not fetch feedback details.');
			return response.json();
		},
		async update(formData) {
			const response = await fetch(`${contextPath}/admin/action/feedback?action=updateStatus`, {
				method: 'POST',
				body: new URLSearchParams(formData)
			});
			return response.json();
		},
		async reorder(data) {
			const response = await fetch(`${contextPath}/admin/action/feedback?action=reorder`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				body: new URLSearchParams({
					csrfToken: csrfToken,
					reorderData: JSON.stringify(data)
				})
			});
			return response.json();
		}
	};

	document.querySelector('.feedback-board').addEventListener('click', async (e) => {
		const card = e.target.closest('.feedback-card-item');
		if (!card) return;

		try {
			const submissionId = card.dataset.id;
			const result = await api.getDetails(submissionId);
			if (!result.success) throw new Error(result.message);

			const submission = result.data;

			modalIdInput.value = submission.id;
			modalOriginalSubject.textContent = submission.subject;
			modalDisplayTitle.value = submission.displayTitle || '';
			modalContent.textContent = submission.content;
			if (window.renderMarkdown) window.renderMarkdown(modalContent);
			modalStatus.value = submission.status;

			modal.classList.add('active');
		} catch (error) {
			console.error(error);
			showToast('Details konnten nicht geladen werden.', 'danger');
		}
	});

	modalForm.addEventListener('submit', async (e) => {
		e.preventDefault();
		const formData = new FormData(modalForm);
		formData.append('csrfToken', csrfToken);

		try {
			const result = await api.update(formData);
			if (result.success) {
				showToast('Änderungen gespeichert.', 'success');
				modal.classList.remove('active');
				window.location.reload(); // Reload to reflect changes
			} else {
				throw new Error(result.message);
			}
		} catch (error) {
			showToast(error.message || 'Fehler beim Speichern.', 'danger');
		}
	});

	modal.querySelector('.modal-close-btn').addEventListener('click', () => modal.classList.remove('active'));
	modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('active'); });

	const handleReorder = async (evt) => {
		const item = evt.item;
		const toList = evt.to;
		const newStatus = toList.dataset.statusId;
		const submissionId = item.dataset.id;

		item.dataset.status = newStatus;

		const reorderData = {
			submissionId: parseInt(submissionId, 10),
			newStatus: newStatus,
			orderedIds: Array.from(toList.children).map(child => parseInt(child.dataset.id, 10))
		};

		try {
			const result = await api.reorder(reorderData);
			if (result.success) {
				showToast(result.message, 'success');
			} else {
				throw new Error(result.message);
			}
		} catch (error) {
			console.error('Error saving new order:', error);
			showToast(error.message || 'Sortierung konnte nicht gespeichert werden.', 'danger');
		}
	};

	columns.forEach(col => {
		new Sortable(col, {
			group: 'feedback',
			animation: 150,
			ghostClass: 'sortable-ghost',
			onEnd: handleReorder
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_files.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {

	// --- Upload New Version Modal Logic ---
	const uploadModal = document.getElementById('upload-version-modal');
	if (uploadModal) {
		const modalTitle = document.getElementById('upload-modal-title');
		const modalFileIdInput = document.getElementById('upload-file-id');
		const modalFileNameSpan = document.getElementById('upload-file-name');
		const fileInput = document.getElementById('new-file-version');
		const closeModalBtn = uploadModal.querySelector('.modal-close-btn');

		document.querySelectorAll('.upload-new-version-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				const fileId = btn.dataset.fileId;
				const fileName = btn.dataset.fileName;

				modalFileIdInput.value = fileId;
				modalFileNameSpan.textContent = fileName;
				fileInput.value = ''; // Reset file input
				uploadModal.classList.add('active');
			});
		});

		const closeModal = () => uploadModal.classList.remove('active');
		if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
		uploadModal.addEventListener('click', (e) => {
			if (e.target === uploadModal) closeModal();
		});
	}

	// --- Reassign File Modal Logic ---
	const reassignModal = document.getElementById('reassign-file-modal');
	if (reassignModal) {
		const modalFileIdInput = document.getElementById('reassign-file-id');
		const modalFileNameSpan = document.getElementById('reassign-file-name');
		const closeModalBtn = reassignModal.querySelector('.modal-close-btn');

		document.querySelectorAll('.reassign-file-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				modalFileIdInput.value = btn.dataset.fileId;
				modalFileNameSpan.textContent = btn.dataset.fileName;
				reassignModal.classList.add('active');
			});
		});

		const closeReassignModal = () => reassignModal.classList.remove('active');
		if (closeModalBtn) closeModalBtn.addEventListener('click', closeReassignModal);
		reassignModal.addEventListener('click', (e) => {
			if (e.target === reassignModal) closeReassignModal();
		});
	}

	// --- Generic File Input Size Validation ---
	document.querySelectorAll('.file-input').forEach(input => {
		input.addEventListener('change', (e) => {
			const file = e.target.files[0];
			if (!file) return;

			const maxSize = parseInt(e.target.dataset.maxSize, 10);
			const warningElement = e.target.closest('.form-group').querySelector('.file-size-warning');

			if (file.size > maxSize) {
				if (warningElement) warningElement.style.display = 'block';
				e.target.value = ''; // Clear the invalid selection
			} else {
				if (warningElement) warningElement.style.display = 'none';
			}
		});
	});

});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_kits.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	// --- Kit Create/Edit Modal ---
	const kitModal = document.getElementById('kit-modal');
	if (kitModal) {
		const form = kitModal.querySelector('form');
		const title = kitModal.querySelector('h3');
		const actionInput = form.querySelector('input[name="action"]');
		const idInput = form.querySelector('input[name="id"]');
		const nameInput = form.querySelector('#name-modal');
		const descInput = form.querySelector('#description-modal');
		const locationInput = form.querySelector('#location-modal');

		document.getElementById('new-kit-btn')?.addEventListener('click', () => {
			form.reset();
			title.textContent = 'Neues Kit anlegen';
			actionInput.value = 'create';
			idInput.value = '';
		});

		document.querySelectorAll('.edit-kit-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				form.reset();
				title.textContent = 'Kit bearbeiten';
				actionInput.value = 'update';
				idInput.value = btn.dataset.kitId;
				nameInput.value = btn.dataset.kitName;
				descInput.value = btn.dataset.kitDesc;
				locationInput.value = btn.dataset.kitLocation || '';
			});
		});
	}

	// --- Kit Content Management (Accordion & Dynamic Rows) ---
	const allItems = JSON.parse(document.getElementById('allItemsData').textContent || '[]');
	const allSelectableItems = JSON.parse(document.getElementById('allSelectableItemsData').textContent || '[]');

	// Toggle accordion for each kit
	document.querySelectorAll('.kit-header').forEach(header => {
		header.addEventListener('click', () => {
			const content = header.nextElementSibling;
			const icon = header.querySelector('.toggle-icon');
			const isOpening = content.style.display !== 'block';

			content.style.display = isOpening ? 'block' : 'none';
			icon.classList.toggle('fa-chevron-down', !isOpening);
			icon.classList.toggle('fa-chevron-up', isOpening);
		});
	});

	const updateMaxQuantity = (selectElement) => {
		const selectedId = parseInt(selectElement.value, 10);
		const quantityInput = selectElement.closest('.dynamic-row').querySelector('input[name="quantities"]');
		const selectedItem = allItems.find(item => item.id === selectedId);

		if (selectedItem) {
			quantityInput.max = selectedItem.availableQuantity;
			quantityInput.title = `Maximal verfügbar: ${selectedItem.availableQuantity}`;
			if (parseInt(quantityInput.value) > selectedItem.availableQuantity) {
				quantityInput.value = selectedItem.availableQuantity;
			}
		} else {
			quantityInput.removeAttribute('max');
			quantityInput.title = '';
		}
	};

	const createItemRow = (item = { id: '', quantity: 1 }) => {
		const row = document.createElement('div');
		row.className = 'dynamic-row';

		const select = document.createElement('select');
		select.name = 'itemIds';
		select.className = 'form-group';
		select.innerHTML = '<option value="">-- Artikel auswählen --</option>' +
			allSelectableItems.map(i => `<option value="${i.id}">${i.name}</option>`).join('');
		select.value = item.id;

		const quantityInput = document.createElement('input');
		quantityInput.type = 'number';
		quantityInput.name = 'quantities';
		quantityInput.value = item.quantity;
		quantityInput.min = '1';
		quantityInput.className = 'form-group';
		quantityInput.style.maxWidth = '100px';
		quantityInput.required = true;

		const removeBtn = document.createElement('button');
		removeBtn.type = 'button';
		removeBtn.className = 'btn btn-small btn-danger btn-remove-kit-item-row';
		removeBtn.title = 'Zeile entfernen';
		removeBtn.innerHTML = '×';

		row.appendChild(select);
		row.appendChild(quantityInput);
		row.appendChild(removeBtn);

		select.addEventListener('change', () => updateMaxQuantity(select));

		// Initial check in case the row is pre-populated
		if (item.id) {
			updateMaxQuantity(select);
		}

		return row;
	};

	document.querySelectorAll('.kit-content select[name="itemIds"]').forEach(select => {
		updateMaxQuantity(select);
	});

	// Event delegation for adding/removing item rows
	document.body.addEventListener('click', e => {
		const addBtn = e.target.closest('.btn-add-kit-item-row');
		const removeBtn = e.target.closest('.btn-remove-kit-item-row');

		if (addBtn) {
			e.preventDefault();
			const container = document.getElementById(addBtn.dataset.containerId);
			if (container) {
				const noItemsMsg = container.querySelector('.no-items-message');
				if (noItemsMsg) noItemsMsg.remove();
				container.appendChild(createItemRow());
			}
		} else if (removeBtn) {
			e.preventDefault();
			const row = removeBtn.closest('.dynamic-row');
			const container = row.parentElement;
			showConfirmationModal("Diesen Artikel wirklich aus dem Kit entfernen?", () => {
				row.remove();
				// If the container is now empty, show the placeholder message again.
				if (container && !container.querySelector('.dynamic-row')) {
					const p = document.createElement('p');
					p.className = 'no-items-message';
					p.textContent = 'Dieses Kit ist leer. Fügen Sie einen Artikel hinzu.';
					container.appendChild(p);
				}
			});
		}
	});

	// Enforce max value on quantity inputs
	document.body.addEventListener('input', e => {
		if (e.target.matches('input[name="quantities"]')) {
			const max = parseInt(e.target.max, 10);
			const value = parseInt(e.target.value, 10);
			if (!isNaN(max) && !isNaN(value) && value > max) {
				e.target.value = max;
			}
		}
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_matrix.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const modalOverlay = document.getElementById('attendance-modal');
	if (!modalOverlay) return;

	// Get references to all modal elements once
	const modalTitle = document.getElementById('modal-title');
	const modalUserId = document.getElementById('modal-user-id');
	const modalMeetingId = document.getElementById('modal-meeting-id');
	const modalAttended = document.getElementById('modal-attended');
	const modalRemarks = document.getElementById('modal-remarks');
	const closeBtn = modalOverlay.querySelector('.modal-close-btn');

	/**
	 * Opens the attendance modal and populates it with data from the clicked cell.
	 * @param {HTMLElement} cell The table cell that was clicked.
	 */
	const openModal = (cell) => {
		const userData = cell.dataset;
		modalTitle.textContent = `Nutzer: ${userData.userName} | Meeting: ${userData.meetingName}`;
		modalUserId.value = userData.userId;
		modalMeetingId.value = userData.meetingId;
		modalRemarks.value = userData.remarks;
		// The value from dataset is a string, so we need to compare it to 'true'
		modalAttended.checked = (userData.attended === 'true');
		modalOverlay.classList.add('active');
	};

	/**
	 * Closes the attendance modal.
	 */
	const closeModal = () => modalOverlay.classList.remove('active');

	// Attach click listener to all qualification cells to open the modal
	document.querySelectorAll('.qual-cell').forEach(cell => {
		cell.addEventListener('click', (e) => openModal(e.currentTarget));
	});

	// --- Modal Closing Listeners ---
	if (closeBtn) closeBtn.addEventListener('click', closeModal);

	// Close modal if the overlay background is clicked
	modalOverlay.addEventListener('click', (event) => {
		if (event.target === modalOverlay) closeModal();
	});

	// Close modal on Escape key press
	document.addEventListener('keydown', (event) => {
		if (event.key === 'Escape' && modalOverlay.classList.contains('active')) {
			closeModal();
		}
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_meeting_list.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	document.querySelectorAll('.js-confirm-form').forEach(form => {
		form.addEventListener('submit', function(e) {
			e.preventDefault();
			const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
			showConfirmationModal(message, () => this.submit());
		});
	});

	const modal = document.getElementById('meeting-modal');
	if (!modal) return;

	const form = document.getElementById('meeting-modal-form');
	const modalTitle = document.getElementById('meeting-modal-title');
	const actionInput = document.getElementById('meeting-action');
	const idInput = document.getElementById('meeting-id');
	const attachmentsList = document.getElementById('modal-attachments-list');
	const closeModalBtn = modal.querySelector('.modal-close-btn');

	const openModal = () => modal.classList.add('active');
	const closeModal = () => modal.classList.remove('active');

	const resetModal = () => {
		form.reset();
		attachmentsList.innerHTML = '';
	};

	const newMeetingBtn = document.getElementById('new-meeting-btn');
	if (newMeetingBtn) {
		newMeetingBtn.addEventListener('click', () => {
			resetModal();
			modalTitle.textContent = "Neues Meeting planen";
			actionInput.value = "create";
			idInput.value = "";
			openModal();
		});
	}

	const addAttachmentRow = (attachment, courseId) => {
		const li = document.createElement('li');
		li.id = `attachment-item-${attachment.id}`;
		li.innerHTML = `<a href="${contextPath}/download?id=${attachment.id}" target="_blank">${attachment.filename}</a> (Rolle: ${attachment.requiredRole})`;
		const removeBtn = document.createElement('button');
		removeBtn.type = 'button';
		removeBtn.className = 'btn btn-small btn-danger-outline';
		removeBtn.innerHTML = '×';
		removeBtn.onclick = () => {
			showConfirmationModal(`Anhang '${attachment.filename}' wirklich löschen?`, () => {
				const csrfToken = form.querySelector('input[name="csrfToken"]').value; // Get token from main form
				const deleteForm = document.createElement('form');
				deleteForm.method = 'post';
				deleteForm.action = `${contextPath}/admin/meetings`;
				deleteForm.innerHTML = `
					<input type="hidden" name="action" value="deleteAttachment">
					<input type="hidden" name="attachmentId" value="${attachment.id}">
					<input type="hidden" name="courseId" value="${courseId}">
					<input type="hidden" name="csrfToken" value="${csrfToken}">
				`;
				document.body.appendChild(deleteForm);
				deleteForm.submit();
			});
		};
		li.appendChild(removeBtn);
		attachmentsList.appendChild(li);
	};

	document.querySelectorAll('.edit-meeting-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			const meetingId = btn.dataset.meetingId;
			try {
				const response = await fetch(`${contextPath}/admin/meetings?action=getMeetingData&id=${meetingId}`);
				if (!response.ok) throw new Error('Meeting data could not be fetched.');
				const data = await response.json();
				const meeting = data.meetingData;
				const attachments = data.attachmentsData;

				resetModal();
				modalTitle.textContent = "Meeting bearbeiten";
				actionInput.value = "update";
				idInput.value = meeting.id;
				form.querySelector('#name-modal').value = meeting.name || '';
				form.querySelector('#location-modal').value = meeting.location || '';
				form.querySelector('#meetingDateTime-modal').value = meeting.meetingDateTime ? meeting.meetingDateTime.substring(0, 16) : '';
				form.querySelector('#endDateTime-modal').value = meeting.endDateTime ? meeting.endDateTime.substring(0, 16) : '';
				form.querySelector('#leader-modal').value = meeting.leaderUserId || '';
				form.querySelector('#description-modal').value = meeting.description || '';

				if (attachments && attachments.length > 0) {
					attachments.forEach(att => addAttachmentRow(att, meeting.courseId));
				} else {
					attachmentsList.innerHTML = '<li>Keine Anhänge vorhanden.</li>';
				}

				openModal();
			} catch (error) {
				console.error('Error fetching meeting data:', error);
				alert('Fehler beim Laden der Meeting-Daten.');
			}
		});
	});

	if (closeModalBtn) closeModalBtn.addEventListener('click', closeModal);
	modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
	document.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.classList.contains('active')) closeModal(); });

	document.querySelectorAll('.file-input').forEach(input => {
		input.addEventListener('change', (e) => {
			const file = e.target.files[0];
			const maxSize = parseInt(e.target.dataset.maxSize, 10);
			const warningElement = e.target.nextElementSibling;
			if (file && file.size > maxSize) {
				warningElement.style.display = 'block';
				e.target.value = '';
			} else if (warningElement) {
				warningElement.style.display = 'none';
			}
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_reports.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const eventTrendCanvas = document.getElementById('eventTrendChart');
	const userActivityCanvas = document.getElementById('userActivityChart');

	const getJsonData = (id) => {
		const element = document.getElementById(id);
		if (element) {
			try {
				return JSON.parse(element.textContent);
			} catch (e) {
				console.error(`Failed to parse JSON from #${id}`, e);
				return null;
			}
		}
		return null;
	};

	const eventTrendData = getJsonData('eventTrendData');
	const userActivityData = getJsonData('userActivityData');

	if (eventTrendCanvas && eventTrendData && eventTrendData.length > 0) {
		const labels = eventTrendData.map(d => d.month);
		const data = eventTrendData.map(d => d.count);

		new Chart(eventTrendCanvas.getContext('2d'), {
			type: 'line',
			data: {
				labels: labels,
				datasets: [{
					label: 'Anzahl Events pro Monat',
					data: data,
					fill: true,
					borderColor: 'rgb(0, 123, 255)',
					backgroundColor: 'rgba(0, 123, 255, 0.1)',
					tension: 0.1
				}]
			},
			options: {
				responsive: true,
				maintainAspectRatio: false,
				scales: {
					y: {
						beginAtZero: true,
						ticks: {
							stepSize: 1
						}
					}
				}
			}
		});
	} else if (eventTrendCanvas) {
		eventTrendCanvas.parentElement.innerHTML = '<p>Nicht genügend Daten für den Event-Trend vorhanden.</p>';
	}

	if (userActivityCanvas && userActivityData && userActivityData.length > 0) {
		const labels = userActivityData.map(d => d.username);
		const data = userActivityData.map(d => d.participation_count);

		new Chart(userActivityCanvas.getContext('2d'), {
			type: 'bar',
			data: {
				labels: labels,
				datasets: [{
					label: 'Anzahl zugewiesener Events',
					data: data,
					backgroundColor: 'rgba(0, 123, 255, 0.6)',
					borderColor: 'rgb(0, 123, 255)',
					borderWidth: 1
				}]
			},
			options: {
				indexAxis: 'y', 
				responsive: true,
				maintainAspectRatio: false,
				scales: {
					x: {
						beginAtZero: true,
						ticks: {
							stepSize: 1
						}
					}
				},
				plugins: {
					legend: {
						display: false
					}
				}
			}
		});
	} else if (userActivityCanvas) {
		userActivityCanvas.parentElement.innerHTML = '<p>Nicht genügend Daten für Benutzeraktivität vorhanden.</p>';
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_requests.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	const handleRequestAction = async (form) => {
		try {
			// FIX: Use URLSearchParams to ensure the correct Content-Type for the servlet.
			const formData = new URLSearchParams(new FormData(form));

			const response = await fetch(form.action, {
				method: 'POST',
				body: formData
			});
			const result = await response.json();

			if (response.ok && result.success) {
				showToast(result.message, 'success');
				const row = document.querySelector(`tr[data-request-id='${result.data.requestId}']`);
				if (row) {
					row.style.transition = 'opacity 0.5s';
					row.style.opacity = '0';
					setTimeout(() => row.remove(), 500);
				}
			} else {
				showToast(result.message || 'Ein Fehler ist aufgetreten.', 'danger');
			}
		} catch (error) {
			console.error('Error processing request action:', error);
			showToast('Ein Netzwerkfehler ist aufgetreten.', 'danger');
		}
	};

	document.querySelectorAll('.js-approve-request-form').forEach(form => {
		form.addEventListener('submit', (e) => {
			e.preventDefault();
			showConfirmationModal('Diese Änderungen wirklich genehmigen und anwenden?', () => handleRequestAction(form));
		});
	});

	document.querySelectorAll('.js-deny-request-form').forEach(form => {
		form.addEventListener('submit', (e) => {
			e.preventDefault();
			showConfirmationModal('Diese Änderungsanfrage wirklich ablehnen?', () => handleRequestAction(form));
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_roles.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const modal = document.getElementById('role-permissions-modal');
	if (!modal) return;

	const modalTitle = document.getElementById('role-modal-title');
	const roleIdInput = document.getElementById('modal-role-id');
	const roleNameInput = document.getElementById('modal-role-name');
	const checkboxContainer = document.getElementById('permissions-checkbox-container');
	const allPermissions = JSON.parse(document.getElementById('allPermissionsData').textContent || '[]');

	/**
	 * Opens the permissions modal and fetches the permissions for the selected role.
	 * @param {HTMLElement} btn The button that was clicked.
	 */
	const openModal = async (btn) => {
		const roleId = btn.dataset.roleId;
		const roleName = btn.dataset.roleName;

		modalTitle.textContent = `Berechtigungen für Rolle: ${roleName}`;
		roleIdInput.value = roleId;
		roleNameInput.value = roleName;
		checkboxContainer.innerHTML = '<p>Lade Berechtigungen...</p>';
		modal.classList.add('active');

		try {
			const response = await fetch(`${contextPath}/admin/roles?action=getRolePermissions&roleId=${roleId}`);
			if (!response.ok) throw new Error('Could not fetch role permissions');

			const data = await response.json();
			const assignedIds = new Set(data.permissionIds);

			checkboxContainer.innerHTML = ''; // Clear loading message

			// Group permissions for better UI
			const grouped = allPermissions.reduce((acc, p) => {
				const groupName = p.permissionKey.split('_')[0] || 'ALLGEMEIN';
				if (!acc[groupName]) acc[groupName] = [];
				acc[groupName].push(p);
				return acc;
			}, {});


			for (const groupName in grouped) {
				const details = document.createElement('details');
				details.open = true; // Default to open
				const summary = document.createElement('summary');
				summary.textContent = groupName;
				details.appendChild(summary);

				const groupDiv = document.createElement('div');
				groupDiv.className = 'permission-group';
				grouped[groupName].forEach(p => {
					const isChecked = assignedIds.has(p.id) ? 'checked' : '';
					// Prevent ADMIN role from having the main access permission removed to avoid lockouts.
					const isDisabled = p.permissionKey === 'ACCESS_ADMIN_PANEL' && roleName === 'ADMIN' ? 'disabled' : '';
					const label = document.createElement('label');
					label.className = 'checkbox-label';
					label.innerHTML = `
                        <input type="checkbox" name="permissionIds" value="${p.id}" ${isChecked} ${isDisabled}>
                        <span>
                            <strong>${p.permissionKey}</strong>
                            <small>${p.description}</small>
                        </span>
                    `;
					groupDiv.appendChild(label);
				});
				details.appendChild(groupDiv);
				checkboxContainer.appendChild(details);
			}

		} catch (error) {
			console.error("Error fetching role permissions:", error);
			checkboxContainer.innerHTML = '<p class="error-message">Fehler beim Laden der Berechtigungen.</p>';
		}
	};

	document.querySelectorAll('.edit-permissions-btn').forEach(btn => {
		btn.addEventListener('click', (e) => openModal(e.currentTarget));
	});

	const closeModal = () => modal.classList.remove('active');

	modal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
	modal.addEventListener('click', (e) => {
		if (e.target === modal) closeModal();
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_storage_list.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	document.querySelectorAll('.js-confirm-form').forEach(form => {
		form.addEventListener('submit', function(e) {
			e.preventDefault();
			const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
			showConfirmationModal(message, () => this.submit());
		});
	});

	const lightbox = document.getElementById('lightbox');
	if (lightbox) {
		const lightboxImage = document.getElementById('lightbox-image');
		const closeBtn = lightbox.querySelector('.lightbox-close');

		document.querySelectorAll('.lightbox-trigger').forEach(trigger => {
			trigger.addEventListener('click', (e) => {
				e.preventDefault();
				lightboxImage.src = trigger.dataset.src;
				lightbox.style.display = 'flex';
			});
		});

		const closeLightbox = () => {
			lightbox.style.display = 'none';
			lightboxImage.src = '';
		};

		if (closeBtn) closeBtn.addEventListener('click', closeLightbox);
		lightbox.addEventListener('click', (e) => {
			if (e.target === lightbox) {
				closeLightbox();
			}
		});
		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape' && lightbox.style.display === 'flex') {
				closeLightbox();
			}
		});
	}

	const itemModal = document.getElementById('item-modal');
	if (itemModal) {
		const form = itemModal.querySelector('form');
		const title = itemModal.querySelector('h3');
		const actionInput = form.querySelector('input[name="action"]');
		const idInput = form.querySelector('input[name="id"]');
		const closeModalBtn = itemModal.querySelector('.modal-close-btn');

		document.getElementById('new-item-btn').addEventListener('click', () => {
			form.reset();
			title.textContent = 'Neuen Lagerartikel anlegen';
			actionInput.value = 'create';
			itemModal.classList.add('active');
		});

		document.querySelectorAll('.edit-item-btn').forEach(btn => {
			btn.addEventListener('click', async () => {
				form.reset();
				const fetchUrl = btn.dataset.fetchUrl;
				try {
					const response = await fetch(fetchUrl);
					if (!response.ok) throw new Error('Could not fetch item data.');
					const itemData = await response.json();

					title.textContent = 'Lagerartikel bearbeiten';
					actionInput.value = 'update';
					idInput.value = itemData.id;
					form.querySelector('#name-modal').value = itemData.name || '';
					form.querySelector('#location-modal').value = itemData.location || '';
					form.querySelector('#cabinet-modal').value = itemData.cabinet || '';
					form.querySelector('#compartment-modal').value = itemData.compartment || '';
					form.querySelector('#quantity-modal').value = itemData.quantity;
					form.querySelector('#maxQuantity-modal').value = itemData.maxQuantity;
					form.querySelector('#weight_kg-modal').value = itemData.weightKg || '';
					form.querySelector('#price_eur-modal').value = itemData.priceEur || '';
					itemModal.classList.add('active');
				} catch (error) {
					console.error("Failed to open edit modal:", error);
					alert("Fehler beim Laden der Artikeldaten.");
				}
			});
		});
		closeModalBtn.addEventListener('click', () => itemModal.classList.remove('active'));
	}

	const defectModal = document.getElementById('defect-modal');
	if (defectModal) {
		const modalTitle = defectModal.querySelector('h3');
		const itemIdInput = defectModal.querySelector('#defect-item-id');
		const defectQtyInput = defectModal.querySelector('#defective_quantity');
		const reasonInput = defectModal.querySelector('#defect_reason');
		const closeModalBtn = defectModal.querySelector('.modal-close-btn');

		document.querySelectorAll('.defect-modal-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				modalTitle.textContent = `Defekt-Status für "${btn.dataset.itemName}" bearbeiten`;
				itemIdInput.value = btn.dataset.itemId;
				defectQtyInput.value = btn.dataset.currentDefectQty;
				defectQtyInput.max = btn.dataset.maxQty;
				reasonInput.value = btn.dataset.currentReason;
				defectModal.classList.add('active');
			});
		});
		closeModalBtn.addEventListener('click', () => defectModal.classList.remove('active'));
	}

	const repairModal = document.getElementById('repair-modal');
	if (repairModal) {
		const modalTitle = repairModal.querySelector('#repair-modal-title');
		const itemIdInput = repairModal.querySelector('#repair-item-id');
		const repairQtyInput = repairModal.querySelector('#repaired_quantity');
		const closeModalBtn = repairModal.querySelector('.modal-close-btn');

		document.querySelectorAll('.repair-modal-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				modalTitle.textContent = `Artikel "${btn.dataset.itemName}" repariert`;
				itemIdInput.value = btn.dataset.itemId;
				repairQtyInput.value = "1";
				repairQtyInput.max = btn.dataset.maxRepairQty;
				repairModal.classList.add('active');
			});
		});

		closeModalBtn.addEventListener('click', () => repairModal.classList.remove('active'));
		repairModal.addEventListener('click', (e) => {
			if (e.target === repairModal) repairModal.classList.remove('active');
		});
	}

	const maintenanceModal = document.getElementById('maintenance-modal');
	if (maintenanceModal) {
		const modalTitle = maintenanceModal.querySelector('h3');
		const itemIdInput = maintenanceModal.querySelector('#maintenance-item-id');
		const closeModalBtn = maintenanceModal.querySelector('.modal-close-btn');
		const statusSelect = maintenanceModal.querySelector('#maintenance-status');

		document.querySelectorAll('.maintenance-modal-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				modalTitle.textContent = `Wartungs-Status für "${btn.dataset.itemName}"`;
				itemIdInput.value = btn.dataset.itemId;
				statusSelect.value = btn.dataset.currentStatus;
				maintenanceModal.classList.add('active');
			});
		});

		closeModalBtn.addEventListener('click', () => maintenanceModal.classList.remove('active'));
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_system.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const apiUrl = `${contextPath}/api/admin/system-stats`;

	const cpuProgress = document.getElementById('cpu-progress');
	const cpuText = document.getElementById('cpu-text');
	const ramProgress = document.getElementById('ram-progress');
	const ramText = document.getElementById('ram-text');
	const diskProgress = document.getElementById('disk-progress');
	const diskText = document.getElementById('disk-text');
	const uptimeText = document.getElementById('uptime-text');
	const batteryCard = document.getElementById('battery-card');
	const batteryProgress = document.getElementById('battery-progress');
	const batteryText = document.getElementById('battery-text');

	const formatGigaBytes = (gb) => {
		if (gb === 0) return '0 GB';
		if (gb < 1) return `${(gb * 1024).toFixed(0)} MB`;
		return `${gb.toFixed(2)} GB`;
	};

	const updateUI = (stats) => {
		const cpuPercent = stats.cpuLoad.toFixed(1);
		cpuProgress.style.width = cpuPercent + '%';
		cpuText.textContent = cpuPercent + '%';

		if (stats.totalMemory > 0) {
			const ramPercent = (stats.usedMemory / stats.totalMemory) * 100;
			ramProgress.style.width = ramPercent.toFixed(1) + '%';
			ramText.textContent = `${formatGigaBytes(stats.usedMemory)} / ${formatGigaBytes(stats.totalMemory)}`;
		}

		if (stats.totalDiskSpace > 0) {
			const diskPercent = (stats.usedDiskSpace / stats.totalDiskSpace) * 100;
			diskProgress.style.width = diskPercent.toFixed(1) + '%';
			diskText.textContent = `${formatGigaBytes(stats.usedDiskSpace)} / ${formatGigaBytes(stats.totalDiskSpace)}`;
		}

        const uptimeCard = uptimeText.closest('.card');
		if (stats.uptime && stats.uptime !== 'Nicht verfügbar') {
            if(uptimeCard) uptimeCard.style.display = 'block';
			uptimeText.textContent = stats.uptime;
		} else {
			if(uptimeCard) uptimeCard.style.display = 'none';
		}

		if (stats.batteryPercentage >= 0) {
			batteryCard.style.display = 'block';
			const batteryPercent = stats.batteryPercentage;
			batteryProgress.style.width = batteryPercent + '%';
			batteryText.textContent = batteryPercent + '%';
		} else {
			batteryCard.style.display = 'none';
		}
	};

	const fetchStats = async () => {
		try {
			const response = await fetch(apiUrl);
			if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
			const data = await response.json();
			updateUI(data);
		} catch (error) {
			console.error("Could not fetch system stats:", error);
			cpuText.textContent = "Fehler";
			ramText.textContent = "Fehler";
			diskText.textContent = "Fehler";
			uptimeText.textContent = "Fehler";
		}
	};

	fetchStats();
	let intervalId = setInterval(fetchStats, 5000);

	document.addEventListener("visibilitychange", () => {
		if (document.hidden) {
			clearInterval(intervalId);
		} else {
			fetchStats();
			intervalId = setInterval(fetchStats, 5000);
		}
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\admin\admin_users.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	const modal = document.getElementById('user-modal');
	if (!modal) return;

	const form = document.getElementById('user-modal-form');
	const title = document.getElementById('user-modal-title');
	const actionInput = form.querySelector('#user-modal-action');
	const idInput = form.querySelector('#userId-modal');
	const usernameInput = form.querySelector('#username-modal');
	const passwordInput = form.querySelector('#password-modal');
	const passwordGroup = form.querySelector('#password-group');
	const roleInput = form.querySelector('#role-modal');
	const classYearInput = form.querySelector('#classYear-modal');
	const classNameInput = form.querySelector('#className-modal');
	const emailInput = form.querySelector('#email-modal');
	const permissionsContainer = document.getElementById('permissions-checkbox-container');
	const closeModalBtn = modal.querySelector('.modal-close-btn');

	const groupedPermissions = JSON.parse(document.getElementById('allPermissionsData').textContent);

	const closeModal = () => modal.classList.remove('active');

	const populatePermissions = (assignedIds = new Set()) => {
		permissionsContainer.innerHTML = '';

		for (const [groupName, permissionsInGroup] of Object.entries(groupedPermissions)) {
			const details = document.createElement('details');
			details.open = true;

			const summary = document.createElement('summary');
			summary.style.fontWeight = 'bold';
			summary.style.cursor = 'pointer';
			summary.style.padding = '0.5rem 0';
			summary.textContent = groupName;

			const groupDiv = document.createElement('div');
			groupDiv.style.paddingLeft = '1rem';

			permissionsInGroup.forEach(p => {
				const isChecked = assignedIds.has(p.id) ? 'checked' : '';
				const label = document.createElement('label');
				label.style.display = 'flex';
				label.style.alignItems = 'flex-start';
				label.style.marginBottom = '0.5rem';
				label.innerHTML = `
                    <input type="checkbox" name="permissionIds" value="${p.id}" ${isChecked} style="margin-top: 5px; margin-right: 10px;">
                    <div>
                        <strong>${p.permissionKey.replace(groupName + '_', '')}</strong>
                        <small style="display: block; color: var(--text-muted-color);">${p.description}</small>
                    </div>
                `;
				groupDiv.appendChild(label);
			});

			details.appendChild(summary);
			details.appendChild(groupDiv);
			permissionsContainer.appendChild(details);
		}
	};

	const newUserBtn = document.getElementById('new-user-btn');
	if (newUserBtn) {
		newUserBtn.addEventListener('click', () => {
			form.reset();
			title.textContent = "Neuen Benutzer anlegen";
			actionInput.value = "create";
			idInput.value = "";
			passwordInput.required = true;
			passwordGroup.style.display = 'block';
			roleInput.value = "3";
			populatePermissions();
			modal.classList.add('active');
			usernameInput.focus();
		});
	}

	document.querySelectorAll('.edit-user-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			form.reset();
			const fetchUrl = btn.dataset.fetchUrl;
			try {
				const response = await fetch(fetchUrl);
				if (!response.ok) throw new Error('Could not fetch user data');
				const data = await response.json();
				const user = data.user;
				const assignedPermissionIds = new Set(data.permissionIds);

				title.textContent = `Benutzer bearbeiten: ${user.username}`;
				actionInput.value = "update";
				idInput.value = user.id;
				usernameInput.value = user.username || '';
				roleInput.value = user.roleId || '3';
				classYearInput.value = user.classYear || '';
				classNameInput.value = user.className || '';
				emailInput.value = user.email || '';

				passwordInput.required = false;
				passwordGroup.style.display = 'none';

				populatePermissions(assignedPermissionIds);

				modal.classList.add('active');
			} catch (error) {
				console.error('Failed to open edit modal:', error);
				showToast('Benutzerdaten konnten nicht geladen werden.', 'danger');
			}
		});
	});

	const updateTableRow = (user) => {
		const row = document.querySelector(`tr[data-user-id='${user.id}']`);
		if (row) {
			row.querySelector("td[data-field='username']").textContent = user.username;
			row.querySelector("td[data-field='roleName']").textContent = user.roleName;
		}
		const card = document.querySelector(`.list-item-card[data-user-id='${user.id}']`);
		if (card) {
			card.querySelector("h3[data-field='username']").textContent = user.username;
			card.querySelector("strong[data-field='roleName']").textContent = user.roleName;
		}
	};

	const removeTableRow = (userId) => {
		document.querySelector(`tr[data-user-id='${userId}']`)?.remove();
		document.querySelector(`.list-item-card[data-user-id='${userId}']`)?.remove();
	};


	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		const action = actionInput.value;
		const formActionUrl = `${contextPath}/admin/action/user?action=${action}`;

		const formData = new URLSearchParams(new FormData(form));
		try {
			const response = await fetch(formActionUrl, {
				method: 'POST',
				body: formData
			});

			const result = await response.json();

			if (response.ok && result.success) {
				closeModal();
				showToast(result.message, 'success');
				if (action === 'create') {
					window.location.reload();
				} else if (action === 'update') {
					updateTableRow(result.data);
				}
			} else {
				showToast(result.message || 'Ein unbekannter Fehler ist aufgetreten.', 'danger');
			}
		} catch (error) {
			console.error('Error submitting form:', error);
			showToast('Ein Netzwerkfehler ist aufgetreten.', 'danger');
		}
	});

	const handleAjaxFormSubmit = async (formElement) => {
		const formData = new URLSearchParams(new FormData(formElement));
		const actionUrl = formElement.getAttribute('action');

		try {
			const response = await fetch(actionUrl, { method: 'POST', body: formData });
			const result = await response.json();

			if (response.ok && result.success) {
				if (result.data && result.data.newPassword) {
					const bannerContainer = document.querySelector('.main-content');
					document.querySelectorAll('.password-reset-alert, .info-message, .success-message, .error-message').forEach(el => el.remove());

					const banner = document.createElement('p');
					banner.className = 'password-reset-alert';
					banner.id = 'password-reset-alert';
					banner.innerHTML = `<i class="fas fa-key"></i> ${result.message}`;
					bannerContainer.prepend(banner);
				} else {
					showToast(result.message, 'success');
				}

				// FIX: Get the action from the form data itself, not by parsing a URL object.
				const action = formData.get('action');
				if (action === 'delete') {
					removeTableRow(result.data.deletedUserId);
				}
			} else {
				showToast(result.message || 'Ein Fehler ist aufgetreten.', 'danger');
			}
		} catch (error) {
			console.error('Error submitting form via AJAX:', error);
			showToast('Ein Netzwerkfehler ist aufgetreten.', 'danger');
		}
	};

	document.body.addEventListener('submit', (event) => {
		const form = event.target;
		if (form.matches('.js-confirm-delete-form, .js-reset-password-form, .js-unlock-form')) {
			event.preventDefault();
			const message = form.dataset.confirmMessage || 'Sind Sie sicher?';
			showConfirmationModal(message, () => handleAjaxFormSubmit(form));
		}
	});

	closeModalBtn.addEventListener('click', closeModal);
	modal.addEventListener('click', (event) => { if (event.target === modal) closeModal(); });
	document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && modal.classList.contains('active')) closeModal(); });

	const tabButtons = modal.querySelectorAll('.modal-tab-button');
	const tabContents = modal.querySelectorAll('.modal-tab-content');
	tabButtons.forEach(button => {
		button.addEventListener('click', () => {
			tabButtons.forEach(btn => btn.classList.remove('active'));
			button.classList.add('active');
			tabContents.forEach(content => {
				content.classList.toggle('active', content.id === button.dataset.tab);
			});
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\auth\login.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const lockoutTimer = document.getElementById('lockout-timer');
	if (lockoutTimer) {
		const endTime = parseInt(lockoutTimer.dataset.endTime, 10);
		const lockoutLevel = parseInt(lockoutTimer.dataset.lockoutLevel, 10);

		const durations = [60, 120, 300, 600, 1800]; // in seconds
		const duration = durations[Math.min(lockoutLevel, durations.length - 1)];

		const intervalId = setInterval(() => {
			const now = Date.now();
			const remainingSeconds = Math.max(0, Math.round((endTime + (duration * 1000) - now) / 1000));

			if (remainingSeconds <= 0) {
				clearInterval(intervalId);
				window.location.reload(); // Reload the page to clear the lockout message
			} else {
				const minutes = Math.floor(remainingSeconds / 60);
				const seconds = remainingSeconds % 60;
				lockoutTimer.textContent = `Bitte versuchen Sie es in ${minutes} Minute(n) und ${seconds.toString().padStart(2, '0')} Sekunde(n) erneut.`;
			}
		}, 1000);
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\auth\logout.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	setTimeout(function() {
		window.location.href = `${contextPath}/login`;
	}, 5000);
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\auth\passkey_auth.js
========================================================================

/**
 * Handles all client-side logic for WebAuthn (Passkey) authentication.
 */
document.addEventListener('DOMContentLoaded', () => {
    const contextPath = document.body.dataset.contextPath || '';
    const csrfToken = document.body.dataset.csrfToken;

    // --- UTILITY FUNCTIONS ---
    // These functions convert between ArrayBuffer and Base64URL strings
    const bufferDecode = (value) => Uint8Array.from(atob(value.replace(/_/g, '/').replace(/-/g, '+')), c => c.charCodeAt(0));
    const bufferEncode = (value) => btoa(String.fromCharCode.apply(null, new Uint8Array(value))).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

    // --- REGISTRATION LOGIC ---
    const registerPasskeyBtn = document.getElementById('register-passkey-btn');
    if (registerPasskeyBtn) {
        registerPasskeyBtn.addEventListener('click', async () => {
            try {
                // 1. Get challenge from server
                const createOptionsRes = await fetch(`${contextPath}/api/auth/passkey/register/start`);
                const createOptions = await createOptionsRes.json();
                
                // 2. Decode challenge and user handle
                createOptions.challenge = bufferDecode(createOptions.challenge);
                createOptions.user.id = bufferDecode(createOptions.user.id);
                
                // 3. Call browser's WebAuthn API
                const credential = await navigator.credentials.create({ publicKey: createOptions });

                // 4. Encode the response data to send to server
                const credentialForServer = {
                    id: credential.id,
                    rawId: bufferEncode(credential.rawId),
                    type: credential.type,
                    response: {
                        clientDataJSON: bufferEncode(credential.response.clientDataJSON),
                        attestationObject: bufferEncode(credential.response.attestationObject),
                    },
                };
                
                // 5. Prompt for a device name
                const deviceName = prompt('Bitte geben Sie einen Namen für dieses Gerät ein (z.B. "Mein Laptop"):', 'Mein Gerät');
                if (!deviceName) return; // User cancelled

                // 6. Send response to server to finish registration
                const finishRes = await fetch(`${contextPath}/api/auth/passkey/register/finish?deviceName=${encodeURIComponent(deviceName)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(credentialForServer)
                });

                const result = await finishRes.json();
                if (result.success) {
                    showToast('Gerät erfolgreich registriert!', 'success');
                    setTimeout(() => window.location.reload(), 1500);
                } else {
                    throw new Error(result.message || 'Registrierung fehlgeschlagen.');
                }
            } catch (err) {
                console.error('Passkey registration error:', err);
                showToast(`Fehler bei der Registrierung: ${err.message}`, 'danger');
            }
        });
    }
    
    // --- DELETE PASSKEY LOGIC ---
    document.querySelectorAll('.delete-passkey-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            const form = btn.closest('form');
            showConfirmationModal('Diesen Passkey wirklich entfernen?', () => form.submit());
        });
    });

    // --- LOGIN LOGIC ---
    const loginPasskeyBtn = document.getElementById('login-passkey-btn');
    if (loginPasskeyBtn) {
        loginPasskeyBtn.addEventListener('click', async () => {
            try {
                const username = document.getElementById('username').value;
                if (!username) {
                    showToast('Bitte geben Sie zuerst Ihren Benutzernamen ein.', 'info');
                    return;
                }
                
                // 1. Get challenge from server
                const getOptionsRes = await fetch(`${contextPath}/api/auth/passkey/login/start`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: `username=${encodeURIComponent(username)}`
                });
                const getOptions = await getOptionsRes.json();

                // 2. Decode challenge
                getOptions.challenge = bufferDecode(getOptions.challenge);
                
                // 3. Call browser's WebAuthn API
                const credential = await navigator.credentials.get({ publicKey: getOptions });

                // 4. Encode response data for server
                const credentialForServer = {
                    id: credential.id,
                    rawId: bufferEncode(credential.rawId),
                    type: credential.type,
                    response: {
                        clientDataJSON: bufferEncode(credential.response.clientDataJSON),
                        authenticatorData: bufferEncode(credential.response.authenticatorData),
                        signature: bufferEncode(credential.response.signature),
                        userHandle: credential.response.userHandle ? bufferEncode(credential.response.userHandle) : null,
                    },
                };
                
                // 5. Send to server for verification
                const finishRes = await fetch(`${contextPath}/api/auth/passkey/login/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(credentialForServer)
                });
                
                const result = await finishRes.json();
                if(result.success) {
                    showToast('Erfolgreich eingeloggt!', 'success');
                    window.location.href = `${contextPath}/home`;
                } else {
                    throw new Error(result.message || 'Login fehlgeschlagen.');
                }
            } catch (err) {
                console.error('Passkey login error:', err);
                showToast(`Fehler beim Login: ${err.message}`, 'danger');
            }
        });
    }
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error400.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const output = document.getElementById('droid-output');
	const redirectContainer = document.getElementById('redirect-container');
	const contentLength = document.body.dataset.contentLength || 'UNKNOWN';

	const lines = [
		'INITIATING DATASTREAM ANALYSIS...',
		`PACKET RECEIVED. SIZE: ${contentLength} BYTES.`,
		'PARSING HEADER... [OK]',
		'ANALYSING PAYLOAD...',
		'    > SCANNING FOR SYNTAX VIOLATIONS...',
		'    > ERROR! UNEXPECTED TOKEN OR MALFORMED PARAMETER DETECTED.',
		'    > CORRUPTION LEVEL: MODERATE.',
		'CONCLUSION: ANFRAGE NICHT VERARBEITBAR. DATENINTEGRITÄT KOMPROMITTIERT.',
		'EMPFEHLUNG: ZURÜCKKEHREN UND ANFRAGE NEU FORMULIEREN.',
		''
	];

	let lineIndex = 0;

	function printLine() {
		if (lineIndex < lines.length) {
			const p = document.createElement('p');
			p.textContent = lines[lineIndex];
			output.appendChild(p);
			output.scrollTop = output.scrollHeight;
			lineIndex++;
			setTimeout(printLine, Math.random() * 200 + 50);
		} else {
			redirectContainer.style.opacity = '1';
		}
	}

	printLine();
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error401.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
    const statusText = document.getElementById('scanner-status');
    const light = document.getElementById('scanner-light');
    const progress = document.getElementById('scanner-progress');
    const redirectContainer = document.getElementById('redirect-container');

    const steps = [
        { text: 'SCANNE...', color: '#ffc107', lightColor: '#ffc107', duration: 1500, progress: 50 },
        { text: 'KEINE ID', color: '#dc3545', lightColor: '#dc3545', duration: 1000, progress: 80 },
        { text: 'ZUGRIFF?', color: '#dc3545', lightColor: '#dc3545', duration: 800, progress: 100 },
        { text: 'VERWEIGERT', color: '#dc3545', lightColor: '#dc3545', duration: 2000, progress: 100 }
    ];

    let currentStep = 0;

    function runScan() {
        if(currentStep >= steps.length) {
            redirectContainer.style.opacity = '1';
            return;
        }

        const step = steps[currentStep];
        statusText.textContent = step.text;
        statusText.style.color = step.color;
        light.style.background = step.lightColor;
        light.style.boxShadow = `0 0 10px ${step.lightColor}`;
        progress.style.width = `${step.progress}%`;
        progress.style.backgroundColor = step.lightColor;

        currentStep++;
        setTimeout(runScan, step.duration);
    }

    setTimeout(runScan, 500); 
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error403.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const consoleBody = document.getElementById('console-body');
	const redirectContainer = document.getElementById('redirect-container');
	const username = document.body.dataset.username || 'unknown_user';
	const role = document.body.dataset.role || 'unknown_role';
	const requestUri = document.body.dataset.requestUri || '/';
	const contextPath = document.body.dataset.contextPath || '';

	let currentLine;

	async function type(text, delay = 25) {
		for (const char of text) {
			currentLine.innerHTML += char;
			consoleBody.scrollTop = consoleBody.scrollHeight;
			await new Promise(resolve => setTimeout(resolve, delay));
		}
		currentLine.innerHTML = currentLine.innerHTML.replace('<span class="cursor"></span>', '');
		consoleBody.innerHTML += '\n'; 
	}

	async function addLine(text, className = '') {
		currentLine = document.createElement('span');
		if (className) currentLine.className = className;
		consoleBody.appendChild(currentLine);
		await type(text + ' <span class="cursor"></span>');
	}

	async function runSequence() {
		await addLine('[INFO] Eingehender Request erkannt...', 'info');
		await new Promise(resolve => setTimeout(resolve, 300));
		await addLine(`[INFO] Ziel-Ressource: ${requestUri}`, 'info');
		await new Promise(resolve => setTimeout(resolve, 400));
		await addLine('[INFO] Starte Identitäts-Scan...', 'info');
		await new Promise(resolve => setTimeout(resolve, 500));
		await addLine(`[OK]   ... Subjekt identifiziert: "${username}"`, 'ok');
		await new Promise(resolve => setTimeout(resolve, 200));
		await addLine(`[OK]   ... Zugehörigkeit/Rolle: [${role}]`, 'ok');
		await new Promise(resolve => setTimeout(resolve, 400));
		await addLine('[WARN] Prüfe Berechtigungs-Matrix für Ziel-Ressource...', 'warn');
		await new Promise(resolve => setTimeout(resolve, 800));
		await addLine('[FAIL] >>> ZUGRIFF VERWEIGERT <<<', 'fail');
		await new Promise(resolve => setTimeout(resolve, 200));
		await addLine('[FAIL] >>> Erforderliche Berechtigung nicht im Token des Subjekts gefunden.', 'fail');
		await new Promise(resolve => setTimeout(resolve, 500));
		await addLine('[INFO] Aktion protokolliert. Sicherheits-Subsystem wird heruntergefahren.', 'info');

		currentLine = document.createElement('span');
		consoleBody.appendChild(currentLine);
		currentLine.innerHTML = '> <span class="cursor"></span>';

		redirectContainer.style.opacity = '1';

		setTimeout(() => {
			window.location.href = `${contextPath}/home`;
		}, 5000);
	}

	runSequence();
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error404.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const terminalBody = document.getElementById('terminal-body');
	const homeLinkContainer = document.getElementById('home-link-container');
	const contextPath = document.body.dataset.contextPath || '';
	const requestUri = document.body.dataset.requestUri || '/';

	async function type(text, element, delay = 50) {
		for (const char of text) {
			element.textContent += char;
			terminalBody.scrollTop = terminalBody.scrollHeight;
			await new Promise(resolve => setTimeout(resolve, delay));
		}
	}

	async function addLine(text, className, delay = 20) {
		const p = document.createElement('p');
		if (className) p.className = className;
		terminalBody.appendChild(p);
		await type(text, p, delay);
	}

	async function runSequence() {
		const p1 = document.createElement('p');
		terminalBody.appendChild(p1);

		const prompt1 = document.createElement('span');
		prompt1.className = 'prompt';
		await type('user@technik-team:~$ ', prompt1, 20);
		p1.appendChild(prompt1);

		const command1 = document.createElement('span');
		command1.className = 'command';
		await type('ls -l ' + requestUri, command1, 50);
		p1.appendChild(command1);

		await new Promise(resolve => setTimeout(resolve, 500));

		await addLine('ls: cannot access \'' + requestUri + '\': No such file or directory', 'error', 15);
		await new Promise(resolve => setTimeout(resolve, 800));

		await addLine('Tipp: Kehren Sie mit dem folgenden Befehl zur Startseite zurück:', 'info', 25);
		await new Promise(resolve => setTimeout(resolve, 300));

		const p_link = document.createElement('p');
		terminalBody.appendChild(p_link);

		const prompt2 = document.createElement('span');
		prompt2.className = 'prompt';
		await type('user@technik-team:~$ ', prompt2, 20);
		p_link.appendChild(prompt2);

		const homeLink = document.createElement('a');
		homeLink.href = `${contextPath}/home`;
		homeLink.className = 'link';
		p_link.appendChild(homeLink);
		await type('cd /home', homeLink, 80);

		const cursor = document.createElement('span');
		cursor.className = 'cursor';
		cursor.innerHTML = ' ';
		p_link.appendChild(cursor);

		homeLinkContainer.style.opacity = '1';
	}

	runSequence();
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error500.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const diagBtn = document.getElementById('diagnostic-btn');
	const output = document.getElementById('diagnostic-output');

	const steps = [
		{ text: 'Initialisiere Diagnose-Protokoll...', type: 'info', icon: 'fas fa-cogs' },
		{ text: 'Prüfe Speicher-Integrität...', type: 'info', icon: 'fas fa-memory' },
		{ text: '[OK] RAM Module antworten.', type: 'ok', icon: 'fas fa-check-circle' },
		{ text: 'Verbinde mit Kernel...', type: 'info', icon: 'fas fa-project-diagram' },
		{ text: '[WARN] Kernel antwortet langsam. Kaffee-Level kritisch.', type: 'warn', icon: 'fas fa-exclamation-triangle' },
		{ text: 'Lade KI-Logikmodule...', type: 'info', icon: 'fas fa-brain' },
		{ text: '[FAIL] Logikmodul "Hamster im Laufrad" hat die Arbeit niedergelegt.', type: 'fail', icon: 'fas fa-times-circle' },
		{ text: 'Versuche Workaround: Mehr Glitzer-Effekte laden...', type: 'warn', icon: 'fas fa-magic' },
		{ text: '[FAIL] Glitzer-Puffer übergelaufen.', type: 'fail', icon: 'fas fa-times-circle' },
		{ text: '--------------------------------', type: 'info', icon: '' },
		{ text: 'Diagnose abgeschlossen. Fehler gefunden.', type: 'fail', icon: 'fas fa-skull-crossbones' }
	];

	let isRunning = false;

	async function typeText(element, text, delay = 20) {
		for (let i = 0; i < text.length; i++) {
			element.innerHTML += text.charAt(i);
			output.scrollTop = output.scrollHeight;
			await new Promise(resolve => setTimeout(resolve, delay));
		}
	}

	diagBtn.addEventListener('click', async () => {
		if (isRunning) return;

		isRunning = true;
		diagBtn.disabled = true;
		diagBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Diagnose läuft...';
		output.innerHTML = ''; 

		for (const step of steps) {
			const line = document.createElement('p');
			line.className = step.type;
			const iconHtml = step.icon ? `<i class="${step.icon}" style="margin-right: 8px;"></i>` : '';
			line.innerHTML = `${iconHtml}`;
			output.appendChild(line);

			await typeText(line, step.text);

			await new Promise(resolve => setTimeout(resolve, 300)); 
		}

		const finalLine = document.createElement('p');
		finalLine.innerHTML = '> <span class="cursor"> </span>';
		output.appendChild(finalLine);
		output.scrollTop = output.scrollHeight;

		diagBtn.disabled = false;
		diagBtn.innerHTML = '<i class="fas fa-tasks"></i> Diagnose erneut starten';
		isRunning = false;
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\error\error503.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const output = document.getElementById('reboot-output');
	const progress = document.getElementById('reboot-progress');
	const contextPath = document.body.dataset.contextPath || '';

	const steps = [
		{ text: 'System check initiated...', delay: 100, progress: 10 },
		{ text: 'Checking memory modules... [OK]', delay: 300, progress: 20 },
		{ text: 'Checking CPU cores... [OK]', delay: 300, progress: 30 },
		{ text: 'Pinging gateway... [NO RESPONSE]', delay: 1000, progress: 40 },
		{ text: 'Server overload detected. Reason: Too many requests.', delay: 500, progress: 50 },
		{ text: 'Flushing request queue...', delay: 1500, progress: 70 },
		{ text: 'Initializing reboot sequence...', delay: 500, progress: 80 },
		{ text: 'System will be back online shortly.', delay: 1000, progress: 100 },
		{ text: 'Redirecting to login page...', delay: 2000, progress: 100 }
	];

	let stepIndex = 0;

	function runSequence() {
		if (stepIndex >= steps.length) {
			window.location.href = `${contextPath}/login`;
			return;
		}

		const step = steps[stepIndex];
		const p = document.createElement('p');
		p.textContent = step.text;
		output.appendChild(p);
		output.scrollTop = output.scrollHeight;

		progress.style.width = `${step.progress}%`;

		stepIndex++;
		setTimeout(runSequence, step.delay);
	}

	runSequence();
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\calendar.js
========================================================================

document.addEventListener('DOMContentLoaded', function() {
	const calendarEl = document.getElementById('calendar-container');
	const contextPath = document.body.dataset.contextPath || '';

	// FIX: The calendar must be initialized if the element exists.
	// CSS media queries are responsible for showing/hiding the container, not JS.
	// The previous getComputedStyle check was a race condition.
	if (calendarEl) {
		try {
			const calendar = new FullCalendar.Calendar(calendarEl, {
				initialView: 'dayGridMonth',
				locale: 'de',
				headerToolbar: {
					left: 'prev,next today',
					center: 'title',
					right: 'dayGridMonth,timeGridWeek,listWeek'
				},
				events: `${contextPath}/api/calendar/entries`,
				eventClick: function(info) {
					info.jsEvent.preventDefault();
					if (info.event.url) {
						window.location.href = info.event.url;
					}
				}
			});
			calendar.render();
		} catch (e) {
			console.error("FullCalendar failed to initialize. This is often caused by a corrupted library file.", e);
			calendarEl.innerHTML = `<div class="error-message">Kalender konnte nicht geladen werden. Möglicherweise ist eine Bibliotheksdatei beschädigt.</div>`;
		}
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\dateien.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const uploadModal = document.getElementById('upload-version-modal');
	if (!uploadModal) return;

	const modalTitle = document.getElementById('upload-modal-title');
	const modalFileIdInput = document.getElementById('upload-file-id');
	const modalFileNameSpan = document.getElementById('upload-file-name');
	const fileInput = document.getElementById('new-file-version');
	const closeModalBtn = uploadModal.querySelector('.modal-close-btn');

	document.querySelectorAll('.upload-new-version-btn').forEach(btn => {
		btn.addEventListener('click', () => {
			const fileId = btn.dataset.fileId;
			const fileName = btn.dataset.fileName;

			modalFileIdInput.value = fileId;
			modalFileNameSpan.textContent = fileName;
			fileInput.value = ''; // Reset file input
			uploadModal.classList.add('active');
		});
	});

	const closeModal = () => uploadModal.classList.remove('active');

	closeModalBtn.addEventListener('click', closeModal);
	uploadModal.addEventListener('click', (e) => {
		if (e.target === uploadModal) closeModal();
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\eventDetails.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const eventId = document.body.dataset.eventId || '';
	const currentUserId = document.body.dataset.userId || '';
	const isAdmin = document.body.dataset.isAdmin === 'true';

	const taskModal = document.getElementById('task-modal');
	if (taskModal) {
		const allUsers = JSON.parse(document.getElementById('allUsersData')?.textContent || '[]');
		const allItems = JSON.parse(document.getElementById('allItemsData')?.textContent || '[]');
		const allKits = JSON.parse(document.getElementById('allKitsData')?.textContent || '[]');
		const allTasks = JSON.parse(document.getElementById('allTasksData')?.textContent || '[]');

		const form = document.getElementById('task-modal-form');
		const title = document.getElementById('task-modal-title');
		const taskIdInput = document.getElementById('task-id-modal');
		const descInput = document.getElementById('task-description-modal');
		const detailsInput = document.getElementById('task-details-modal');
		const orderInput = document.getElementById('task-display-order-modal');
		const statusGroup = document.getElementById('task-status-group');
		const statusInput = document.getElementById('task-status-modal');
		const deleteBtn = document.getElementById('delete-task-btn');

		const assignmentTypeRadios = form.querySelectorAll('input[name="assignmentType"]');
		const directFields = document.getElementById('direct-assignment-fields');
		const poolFields = document.getElementById('pool-assignment-fields');
		const requiredPersonsInput = document.getElementById('task-required-persons-modal');
		const userCheckboxesContainer = document.getElementById('task-user-checkboxes');

		const itemsContainer = document.getElementById('task-items-container');
		const kitsContainer = document.getElementById('task-kits-container');

		const createRow = (container, onRemove) => {
			const row = document.createElement('div');
			row.className = 'dynamic-row';
			const removeBtn = document.createElement('button');
			removeBtn.type = 'button';
			removeBtn.className = 'btn-small btn-danger';
			removeBtn.innerHTML = '×';
			removeBtn.onclick = () => onRemove(row);
			row.appendChild(removeBtn);
			container.appendChild(row);
			return row;
		};

		const addItemRow = (item = { id: '', quantity: 1 }) => {
			const row = createRow(itemsContainer, r => r.remove());
			const select = document.createElement('select');
			select.name = 'itemIds[]';
			select.className = 'form-group';
			select.innerHTML = '<option value="">-- Material --</option>' + allItems.map(i => `<option value="${i.id}" data-max-qty="${i.availableQuantity}">${i.name}</option>`).join('');
			select.value = item.id;

			const input = document.createElement('input');
			input.type = 'number';
			input.name = 'itemQuantities[]';
			input.value = item.quantity;
			input.min = '1';
			input.className = 'form-group';
			input.style.maxWidth = '100px';

			select.addEventListener('change', () => {
				const selectedOption = select.options[select.selectedIndex];
				const maxQty = selectedOption.dataset.maxQty;
				input.max = maxQty || '';
				if (maxQty) input.title = `Maximal verfügbar: ${maxQty}`;
			});

			row.prepend(select, input);
		};

		const addKitRow = (kit = { id: '' }) => {
			const row = createRow(kitsContainer, r => r.remove());
			const select = document.createElement('select');
			select.name = 'kitIds[]';
			select.className = 'form-group';
			select.innerHTML = '<option value="">-- Kit --</option>' + allKits.map(k => `<option value="${k.id}">${k.name}</option>`).join('');
			select.value = kit.id;
			row.prepend(select);
		};

		const openModal = () => taskModal.classList.add('active');
		const closeModal = () => taskModal.classList.remove('active');

		const resetModal = () => {
			form.reset();
			taskIdInput.value = '';
			itemsContainer.innerHTML = '';
			kitsContainer.innerHTML = '';
			userCheckboxesContainer.innerHTML = '';
			statusGroup.style.display = 'none';
			deleteBtn.style.display = 'none';
			directFields.style.display = 'block';
			poolFields.style.display = 'none';
			form.querySelector('input[name="assignmentType"][value="direct"]').checked = true;
		};

		document.getElementById('new-task-btn')?.addEventListener('click', () => {
			resetModal();
			title.textContent = 'Neue Aufgabe erstellen';
			allUsers.forEach(user => {
				userCheckboxesContainer.innerHTML += `<label><input type="checkbox" name="userIds" value="${user.id}"> ${user.username}</label>`;
			});
			openModal();
		});

		document.querySelectorAll('.edit-task-btn').forEach(btn => {
			btn.addEventListener('click', () => {
				const taskId = parseInt(btn.dataset.taskId, 10);
				const task = allTasks.find(t => t.id === taskId);
				if (!task) return;

				resetModal();
				title.textContent = 'Aufgabe bearbeiten';
				statusGroup.style.display = 'block';
				deleteBtn.style.display = 'inline-block';

				taskIdInput.value = task.id;
				descInput.value = task.description;
				detailsInput.value = task.details || '';
				orderInput.value = task.displayOrder;
				statusInput.value = task.status;

				if (task.requiredPersons > 0) {
					form.querySelector('input[name="assignmentType"][value="pool"]').checked = true;
					poolFields.style.display = 'block';
					directFields.style.display = 'none';
					requiredPersonsInput.value = task.requiredPersons;
				} else {
					const assignedIds = new Set(task.assignedUsers.map(u => u.id));
					allUsers.forEach(user => {
						const isChecked = assignedIds.has(user.id) ? 'checked' : '';
						userCheckboxesContainer.innerHTML += `<label><input type="checkbox" name="userIds" value="${user.id}" ${isChecked}> ${user.username}</label>`;
					});
				}

				task.requiredItems?.forEach(item => addItemRow({ id: item.id, quantity: item.quantity }));
				task.requiredKits?.forEach(kit => addKitRow({ id: kit.id }));
				openModal();
			});
		});

		assignmentTypeRadios.forEach(radio => {
			radio.addEventListener('change', () => {
				directFields.style.display = radio.value === 'direct' ? 'block' : 'none';
				poolFields.style.display = radio.value === 'pool' ? 'block' : 'none';
			});
		});

		deleteBtn.addEventListener('click', () => {
			showConfirmationModal('Diese Aufgabe wirklich löschen?', () => {
				const csrfToken = form.querySelector('input[name="csrfToken"]').value;
				const deleteForm = document.createElement('form');
				deleteForm.method = 'post';
				deleteForm.action = `${contextPath}/task-action`;
				deleteForm.innerHTML = `
					<input type="hidden" name="action" value="delete">
					<input type="hidden" name="taskId" value="${taskIdInput.value}">
					<input type="hidden" name="eventId" value="${eventId}">
					<input type="hidden" name="csrfToken" value="${csrfToken}">`;
				document.body.appendChild(deleteForm);
				deleteForm.submit();
			});
		});

		// FIX: Use event delegation on the body to handle clicks on dynamically added elements
		document.body.addEventListener('click', e => {
			const addItemBtn = e.target.closest('#add-task-item-btn');
			const addKitBtn = e.target.closest('#add-task-kit-btn');

			if (addItemBtn) {
				addItemRow();
			}
			if (addKitBtn) {
				addKitRow();
			}
		});

		taskModal.querySelector('.modal-close-btn').addEventListener('click', closeModal);
	}

	const taskListContainer = document.getElementById('task-list-container');
	if (taskListContainer) {
		taskListContainer.addEventListener('click', (e) => {
			const markDoneBtn = e.target.closest('.mark-task-done-btn');
			if (markDoneBtn) {
				const taskId = markDoneBtn.dataset.taskId;
				const csrfToken = document.body.dataset.csrfToken;
				const params = new URLSearchParams();
				params.append('action', 'updateStatus');
				params.append('taskId', taskId);
				params.append('status', 'ERLEDIGT');
				if (csrfToken) {
					params.append('csrfToken', csrfToken);
				}

				fetch(`${contextPath}/task-action`, {
					method: 'POST',
					body: params
				})
					.then(response => {
						if (response.ok) window.location.reload();
						else alert('Fehler beim Aktualisieren der Aufgabe.');
					})
					.catch(error => {
						console.error("Error updating task status:", error);
						alert('Netzwerkfehler beim Aktualisieren der Aufgabe.');
					});
			}
		});
	}

	const chatBox = document.getElementById('chat-box');
	if (chatBox) {
		const chatForm = document.getElementById('chat-form');
		const chatInput = document.getElementById('chat-message-input');
		const websocketProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
		const websocketUrl = `${websocketProtocol}//${window.location.host}${contextPath}/ws/chat/${eventId}`;
		let socket;

		const connect = () => {
			socket = new WebSocket(websocketUrl);
			socket.onopen = () => fetchMessages();
			socket.onmessage = (event) => {
				const data = JSON.parse(event.data);
				switch (data.type) {
					case 'new_message':
						appendMessage(data.payload);
						break;
					case 'message_soft_deleted':
						handleSoftDelete(data.payload);
						break;
					case 'message_updated':
						const messageTextElement = document.getElementById(`message-text-${data.payload.messageId}`);
						const editedMarkerElement = document.getElementById(`message-edited-marker-${data.payload.messageId}`);
						if (messageTextElement) messageTextElement.innerHTML = marked.parse(data.payload.newText, { sanitize: true });;
						if (editedMarkerElement) editedMarkerElement.style.display = 'inline';
						break;
				}
			};
			socket.onclose = (event) => console.warn('WebSocket connection closed.', event);
			socket.onerror = (error) => console.error('WebSocket error:', error);
		};

		const getTextColorForBackground = (hexColor) => {
			if (!hexColor || hexColor.length < 7) return '#000000';
			const r = parseInt(hexColor.slice(1, 3), 16);
			const g = parseInt(hexColor.slice(3, 5), 16);
			const b = parseInt(hexColor.slice(5, 7), 16);
			const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
			return luminance > 0.5 ? '#000000' : '#FFFFFF';
		};

		const formatAsLocaleTime = (dateString) => {
			if (!dateString) return '';
			return new Date(dateString).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
		};

		const appendMessage = (message) => {
			const isCurrentUser = String(message.userId) === String(currentUserId);

			const container = document.createElement('div');
			container.className = 'chat-message-container';
			container.id = `message-container-${message.id}`;
			if (isCurrentUser) container.classList.add('current-user');

			const bubbleElement = document.createElement('div');
			bubbleElement.className = 'chat-bubble';
			bubbleElement.id = `chat-bubble-${message.id}`;

			const bubbleBackgroundColor = isCurrentUser ? 'var(--primary-color)' : (message.chatColor || '#E9ECEF');
			bubbleElement.style.backgroundColor = bubbleBackgroundColor;
			bubbleElement.style.borderColor = bubbleBackgroundColor;
			bubbleElement.style.color = getTextColorForBackground(bubbleBackgroundColor);

			if (message.isDeleted) {
				renderDeletedState(bubbleElement, message);
			} else {
				renderNormalState(bubbleElement, message, isCurrentUser);
				const optionsMenu = createOptionsMenu(message, isCurrentUser);
				container.appendChild(optionsMenu);
			}

			container.prepend(bubbleElement);
			chatBox.appendChild(container);
			chatBox.scrollTop = chatBox.scrollHeight;
		};

		const renderNormalState = (bubbleElement, message, isCurrentUser) => {
			if (!isCurrentUser) {
				const usernameElement = document.createElement('strong');
				usernameElement.className = 'chat-username';
				usernameElement.style.color = 'black';
				usernameElement.textContent = message.username;
				bubbleElement.appendChild(usernameElement);
			}

			const textElement = document.createElement('span');
			textElement.className = 'chat-text';
			textElement.id = `message-text-${message.id}`;
			textElement.innerHTML = marked.parse(message.messageText, { sanitize: true });

			const timeElement = document.createElement('span');
			timeElement.className = 'chat-timestamp';
			timeElement.textContent = formatAsLocaleTime(message.sentAt);
			timeElement.style.color = bubbleElement.style.color === '#FFFFFF' ? 'rgba(255,255,255,0.7)' : 'var(--text-muted-color)';

			const editedMarker = document.createElement('span');
			editedMarker.className = 'chat-edited-marker';
			editedMarker.id = `message-edited-marker-${message.id}`;
			editedMarker.textContent = ' (bearbeitet)';
			editedMarker.style.display = message.edited ? 'inline' : 'none';

			timeElement.prepend(editedMarker);
			bubbleElement.appendChild(textElement);
			bubbleElement.appendChild(timeElement);
		};

		const renderDeletedState = (bubbleElement, message) => {
			let deletedText;
			const deletedByEl = document.createElement('span');
			deletedByEl.textContent = message.deletedByUsername;

			const originalUserEl = document.createElement('span');
			originalUserEl.textContent = message.username;

			const infoSpan = document.createElement('span');
			infoSpan.className = 'chat-deleted-info';

			if (message.username === message.deletedByUsername) {
				infoSpan.textContent = `Nachricht wurde von ${originalUserEl.textContent} gelöscht`;
			} else {
				infoSpan.textContent = `Nachricht von ${originalUserEl.textContent} wurde von ${deletedByEl.textContent} gelöscht`;
			}
			bubbleElement.appendChild(infoSpan);
			bubbleElement.classList.add('deleted');
		};

		const createOptionsMenu = (message, isCurrentUser) => {
			const optionsMenu = document.createElement('div');
			optionsMenu.className = 'chat-options';
			if (isCurrentUser) {
				const editButton = document.createElement('button');
				editButton.className = 'chat-option-btn';
				editButton.innerHTML = '<i class="fas fa-pencil-alt"></i>';
				editButton.onclick = () => handleEdit(message.id);
				optionsMenu.appendChild(editButton);
			}
			if (isAdmin || isCurrentUser) {
				const deleteButton = document.createElement('button');
				deleteButton.className = 'chat-option-btn';
				deleteButton.innerHTML = '<i class="fas fa-trash-alt"></i>';
				deleteButton.onclick = () => handleDelete(message.id, message.userId, message.username);
				optionsMenu.appendChild(deleteButton);
			}
			return optionsMenu;
		};

		const handleDelete = (messageId, originalUserId, originalUsername) => {
			showConfirmationModal("Nachricht wirklich löschen?", () => {
				socket.send(JSON.stringify({ type: 'delete_message', payload: { messageId, originalUserId, originalUsername } }));
			});
		};

		const handleSoftDelete = (payload) => {
			const bubbleElement = document.getElementById(`chat-bubble-${payload.messageId}`);
			const containerElement = document.getElementById(`message-container-${payload.messageId}`);
			if (bubbleElement && containerElement) {
				containerElement.querySelector('.chat-options')?.remove();

				const deletedByEl = document.createElement('span');
				deletedByEl.textContent = payload.deletedByUsername;

				const originalUserEl = document.createElement('span');
				originalUserEl.textContent = payload.originalUsername;

				const infoSpan = document.createElement('span');
				infoSpan.className = 'chat-deleted-info';

				if (payload.originalUsername === payload.deletedByUsername) {
					infoSpan.textContent = `Nachricht von ${originalUserEl.textContent} gelöscht`;
				} else {
					infoSpan.textContent = `Nachricht von ${originalUserEl.textContent} wurde von ${deletedByEl.textContent} gelöscht`;
				}

				bubbleElement.innerHTML = ''; // Clear existing content
				bubbleElement.appendChild(infoSpan);
				bubbleElement.classList.add('deleted');
			}
		};

		const handleEdit = (messageId) => {
			const textElement = document.getElementById(`message-text-${messageId}`);
			const currentText = textElement.textContent;
			const editInput = document.createElement('input');
			editInput.type = 'text';
			editInput.value = currentText;
			editInput.className = 'chat-edit-input';

			editInput.onkeydown = (keyboardEvent) => {
				if (keyboardEvent.key === 'Enter') {
					if (editInput.value.trim() && editInput.value !== currentText) {
						socket.send(JSON.stringify({ type: 'update_message', payload: { messageId, newText: editInput.value } }));
					}
					textElement.style.display = 'block';
					editInput.replaceWith(textElement);
				} else if (keyboardEvent.key === 'Escape') {
					textElement.style.display = 'block';
					editInput.replaceWith(textElement);
				}
			};

			textElement.style.display = 'none';
			textElement.parentElement.insertBefore(editInput, textElement);
			editInput.focus();
		};

		const fetchMessages = () => {
			fetch(`${contextPath}/api/event-chat?eventId=${eventId}`)
				.then(response => response.json())
				.then(messages => {
					chatBox.innerHTML = '';
					if (messages && messages.length > 0) messages.forEach(appendMessage);
				}).catch(error => console.error("Error fetching initial chat messages:", error));
		};

		chatInput.addEventListener('keyup', (e) => {
			const popup = document.getElementById('mention-popup');
			if (e.key === '@') {
				const assignedUsers = JSON.parse(document.getElementById('allUsersData')?.textContent || '[]');
				if (assignedUsers.length > 0) {
					popup.innerHTML = assignedUsers.map(u => `<div class="mention-item" data-username="${u.username}">${u.username}</div>`).join('');
					popup.style.display = 'block';
				}
			} else if (popup.style.display === 'block' && e.key !== 'Shift') { // Avoid closing on shift
				popup.style.display = 'none';
			}
		});

		document.getElementById('mention-popup').addEventListener('click', (e) => {
			if (e.target.classList.contains('mention-item')) {
				const username = e.target.dataset.username;
				const text = chatInput.value;
				const atIndex = text.lastIndexOf('@');
				chatInput.value = text.substring(0, atIndex + 1) + username + ' ';
				document.getElementById('mention-popup').style.display = 'none';
				chatInput.focus();
			}
		});

		chatForm.addEventListener('submit', (event) => {
			event.preventDefault();
			const messageText = chatInput.value.trim();
			if (messageText && socket && socket.readyState === WebSocket.OPEN) {
				const payload = { type: "new_message", payload: { messageText: messageText } };
				socket.send(JSON.stringify(payload));
				chatInput.value = '';
			}
		});

		connect();
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\events.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';

	// --- SIGNUP MODAL LOGIC ---
	const signupModal = document.getElementById('signup-modal');
	if (signupModal) {
		const signupModalTitle = document.getElementById('signup-modal-title');
		const signupEventIdInput = document.getElementById('signup-event-id');
		const customFieldsContainer = document.getElementById('custom-fields-container');
		const closeModalBtn = signupModal.querySelector('.modal-close-btn');

		const openSignupModal = async (btn) => {
			const eventId = btn.dataset.eventId;
			const eventName = btn.dataset.eventName;

			signupModalTitle.textContent = `Anmeldung für: ${eventName}`;
			signupEventIdInput.value = eventId;
			customFieldsContainer.innerHTML = '<p>Lade Anmelde-Optionen...</p>';
			signupModal.classList.add('active');

			try {
				const response = await fetch(`${contextPath}/api/public/event-custom-fields?eventId=${eventId}`);
				if (!response.ok) throw new Error('Could not fetch custom fields for the event.');

				const customFields = await response.json();

				customFieldsContainer.innerHTML = '';
				if (customFields && customFields.length > 0) {
					customFields.forEach(field => {
						const fieldGroup = document.createElement('div');
						fieldGroup.className = 'form-group';
						let fieldHtml = `<label for="customfield_${field.id}">${field.fieldName}</label>`;
						if (field.fieldType === 'BOOLEAN') {
							fieldHtml += `<select name="customfield_${field.id}" id="customfield_${field.id}" class="form-control"><option value="true">Ja</option><option value="false">Nein</option></select>`;
						} else {
							fieldHtml += `<input type="text" name="customfield_${field.id}" id="customfield_${field.id}" class="form-control">`;
						}
						fieldGroup.innerHTML = fieldHtml;
						customFieldsContainer.appendChild(fieldGroup);
					});
				} else {
					customFieldsContainer.innerHTML = '<p>Für dieses Event sind keine weiteren Angaben nötig.</p>';
				}
			} catch (error) {
				console.error('Failed to load custom fields:', error);
				customFieldsContainer.innerHTML = '<p class="error-message">Fehler beim Laden der Anmelde-Optionen.</p>';
			}
		};

		document.querySelectorAll('.signup-btn').forEach(btn => btn.addEventListener('click', () => openSignupModal(btn)));
		closeModalBtn.addEventListener('click', () => signupModal.classList.remove('active'));
		signupModal.addEventListener('click', (e) => {
			if (e.target === signupModal) signupModal.classList.remove('active');
		});
	}

	// --- SIGN-OFF LOGIC (WITH REASON FOR RUNNING EVENTS) ---
	const signoffReasonModal = document.getElementById('signoff-reason-modal');
	if (signoffReasonModal) {
		const signoffEventIdInput = document.getElementById('signoff-event-id');
		const closeReasonModalBtn = signoffReasonModal.querySelector('.modal-close-btn');

		document.querySelectorAll('.js-signoff-form').forEach(form => {
			form.addEventListener('submit', function(e) {
				const eventStatus = this.dataset.eventStatus;

				if (eventStatus === 'LAUFEND') {
					e.preventDefault(); // Stop the default form submission
					signoffEventIdInput.value = this.dataset.eventId;
					signoffReasonModal.classList.add('active');
				} else {
					// For non-running events, use the standard confirmation
					e.preventDefault();
					showConfirmationModal(this.dataset.confirmMessage || 'Sind Sie sicher?', () => this.submit());
				}
			});
		});

		closeReasonModalBtn.addEventListener('click', () => signoffReasonModal.classList.remove('active'));
		signoffReasonModal.addEventListener('click', (e) => {
			if (e.target === signoffReasonModal) signoffReasonModal.classList.remove('active');
		});
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\lager.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const transactionModal = document.getElementById('transaction-modal');
	if (transactionModal) {
		const modalTitle = document.getElementById('transaction-modal-title');
		const modalItemId = document.getElementById('transaction-item-id');
		const quantityInput = document.getElementById('transaction-quantity');
		const checkoutButton = transactionModal.querySelector('button[value="checkout"]');
		const checkinButton = transactionModal.querySelector('button[value="checkin"]');
		const closeModalBtn = transactionModal.querySelector('.modal-close-btn');

		const openModal = (btn) => {
			modalTitle.textContent = `${btn.dataset.itemName}: Entnehmen / Einräumen`;
			modalItemId.value = btn.dataset.itemId;

			const availableQty = parseInt(btn.dataset.maxQty, 10);
			const currentQty = parseInt(btn.dataset.currentQty, 10);
			const totalMaxQty = parseInt(btn.dataset.totalMaxQty, 10);
			const availableSpace = totalMaxQty > 0 ? totalMaxQty - currentQty : 9999;

			quantityInput.max = availableQty;
			quantityInput.title = `Maximal entnehmbar: ${availableQty}`;
			quantityInput.value = 1;

			checkoutButton.disabled = (availableQty <= 0);
			checkinButton.disabled = (totalMaxQty > 0 && currentQty >= totalMaxQty);

			checkoutButton.onmouseover = () => {
				quantityInput.max = availableQty;
				quantityInput.title = `Maximal entnehmbar: ${availableQty}`;
			};

			checkinButton.onmouseover = () => {
				quantityInput.max = availableSpace > 0 ? availableSpace : 9999;
				quantityInput.title = `Maximal einräumbar: ${availableSpace}`;
			};

			transactionModal.classList.add('active');
		};

		const closeModal = () => transactionModal.classList.remove('active');
		document.querySelectorAll('.transaction-btn').forEach(btn => btn.addEventListener('click', () => openModal(btn)));
		closeModalBtn.addEventListener('click', closeModal);
		transactionModal.addEventListener('click', e => { if (e.target === transactionModal) closeModal(); });
	}

	const lightbox = document.getElementById('lightbox');
	if (lightbox) {
		const lightboxImage = document.getElementById('lightbox-image');
		const closeBtn = lightbox.querySelector('.lightbox-close');

		document.querySelectorAll('.lightbox-trigger').forEach(trigger => {
			trigger.addEventListener('click', (e) => {
				e.preventDefault();
				lightboxImage.src = trigger.dataset.src;
				lightbox.style.display = 'flex';
			});
		});

		const closeLightbox = () => {
			lightbox.style.display = 'none';
			lightboxImage.src = '';
		};

		if (closeBtn) closeBtn.addEventListener('click', closeLightbox);
		lightbox.addEventListener('click', (e) => {
			if (e.target === lightbox) {
				closeLightbox();
			}
		});
		document.addEventListener('keydown', (e) => {
			if (e.key === 'Escape' && lightbox.style.display === 'flex') {
				closeLightbox();
			}
		});
	}
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\profile.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const contextPath = document.body.dataset.contextPath || '';
	const profileForm = document.getElementById('profile-form');
	if (!profileForm) return;

	const editBtn = document.getElementById('edit-profile-btn');
	const submitBtn = document.getElementById('submit-profile-btn');
	const cancelBtn = document.getElementById('cancel-edit-btn');

	const editableFields = profileForm.querySelectorAll('.editable-field');
	const originalValues = {};

	const toggleEditMode = (isEditing) => {
		editableFields.forEach(field => {
			field.readOnly = !isEditing;
			if (!isEditing) {
				field.style.backgroundColor = '';
				field.style.border = '1px solid transparent';
			} else {
				field.style.backgroundColor = 'var(--bg-color)';
				field.style.border = '1px solid var(--border-color)';
			}
		});

		// Defensive check: only manipulate buttons if they exist
		if (editBtn) editBtn.style.display = isEditing ? 'none' : 'inline-flex';
		if (submitBtn) submitBtn.style.display = isEditing ? 'inline-flex' : 'none';
		if (cancelBtn) cancelBtn.style.display = isEditing ? 'inline-flex' : 'none';

		if (isEditing) {
			editableFields.forEach(input => {
				originalValues[input.name] = input.value;
			});
		}
	};

	// Initialize view mode
	toggleEditMode(false);
	profileForm.querySelector('input[name="username"]').style.border = '1px solid transparent';

	if (editBtn) {
		editBtn.addEventListener('click', () => toggleEditMode(true));
	}

	if (cancelBtn) {
		cancelBtn.addEventListener('click', () => {
			editableFields.forEach(input => {
				input.value = originalValues[input.name];
			});
			toggleEditMode(false);
		});
	}

	profileForm.addEventListener('submit', async (e) => {
		e.preventDefault();

		const body = new URLSearchParams(new FormData(profileForm));
		const actionUrl = profileForm.getAttribute('action');

		try {
			const response = await fetch(actionUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
				},
				body: body
			});

			const contentType = response.headers.get("content-type");
			if (contentType && contentType.includes("application/json")) {
				const result = await response.json();
				if (response.ok && result.success) {
					showToast(result.message, 'success');
					toggleEditMode(false);
					setTimeout(() => window.location.reload(), 1500);
				} else {
					showToast(result.message || 'Ein Fehler ist aufgetreten.', 'danger');
				}
			} else {
				const text = await response.text();
				console.error("Server returned non-JSON response:", text);
				throw new Error("Server did not return a valid JSON response. Status: " + response.status);
			}
		} catch (error) {
			console.error('Error submitting profile change request:', error);
			showToast('Ein Netzwerkfehler oder Serverfehler ist aufgetreten.', 'danger');
		}
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\qr_action.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const quantityInput = document.getElementById('quantity');
	const checkoutBtn = document.getElementById('checkout-btn');
	const checkinBtn = document.getElementById('checkin-btn');

	const form = document.querySelector('.qr-action-container form');
	const availableQty = parseInt(form.dataset.availableQty, 10);
	const totalQty = parseInt(form.dataset.totalQty, 10);
	const maxQty = parseInt(form.dataset.maxQty, 10);

	quantityInput.max = availableQty;

	checkoutBtn.addEventListener('click', () => {
		quantityInput.max = availableQty;
		quantityInput.title = `Maximal entnehmbar: ${availableQty}`;
	});

	checkinBtn.addEventListener('click', () => {
		const availableSpace = maxQty > 0 ? maxQty - totalQty : 9999;
		quantityInput.max = availableSpace > 0 ? availableSpace : 9999;
		quantityInput.title = `Maximal einräumbar: ${availableSpace}`;
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\public\storage_item_details.js
========================================================================

document.addEventListener('DOMContentLoaded', () => {
	const lightbox = document.getElementById('lightbox');
	if (lightbox) {
		const lightboxImage = document.getElementById('lightbox-image');
		const closeBtn = lightbox.querySelector('.lightbox-close');

		document.querySelectorAll('.lightbox-trigger').forEach(trigger => {
			trigger.addEventListener('click', (e) => {
				e.preventDefault();
				lightboxImage.src = trigger.href;
				lightbox.style.display = 'flex';
			});
		});

		const closeLightbox = () => { lightbox.style.display = 'none'; };
		if (closeBtn) closeBtn.addEventListener('click', closeLightbox);
		lightbox.addEventListener('click', (e) => { if (e.target === lightbox) closeLightbox(); });
		document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && lightbox.style.display === 'flex') closeLightbox(); });
	}

	const tabButtons = document.querySelectorAll('.modal-tab-button');
	const tabContents = document.querySelectorAll('.modal-tab-content');
	tabButtons.forEach(button => {
		button.addEventListener('click', () => {
			tabButtons.forEach(btn => btn.classList.remove('active'));
			button.classList.add('active');
			tabContents.forEach(content => {
				content.classList.toggle('active', content.id === button.dataset.tab);
			});
		});
	});
});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\diff-match-patch\diff_match_patch.js
========================================================================

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the Diff, Match and Patch methods.
 * @constructor
 */
var diff_match_patch = function() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
};


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', insert 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/**
 * Class representing one diff tuple.
 * Holds the operation (DIFF_DELETE, DIFF_INSERT or DIFF_EQUAL) and the
 * text involved.
 * @param {number} op One of DIFF_DELETE, DIFF_INSERT or DIFF_EQUAL.
 * @param {string} text The text being applied.
 * @constructor
 */
diff_match_patch.Diff = function(op, text) {
  this[0] = op;
  this[1] = text;
};

diff_match_patch.Diff.prototype.length = 2;

/**
 * Emulate an array ['slice', 'call', ''] -> 'slice'.
 * @return {string}
 */
diff_match_patch.Diff.prototype.toString = function() {
  return this[1];
};


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number=} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonprefix = this.diff_commonPrefix(text1, text2);
  var text1_prime = text1.substring(commonprefix);
  var text2_prime = text2.substring(commonprefix);

  // Trim off common suffix (speedup).
  var commonsuffix = this.diff_commonSuffix(text1_prime, text2_prime);
  var text1_prime = text1_prime.substring(0, text1_prime.length - commonsuffix);
  var text2_prime = text2_prime.substring(0, text2_prime.length - commonsuffix);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1_prime, text2_prime, checklines,
      deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, text1.substring(0,
        commonprefix)));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL,
        text1.substring(text1.length - commonsuffix)));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    // Just delete some text (speedup).
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
             new diff_match_patch.Diff(DIFF_INSERT,
                 longtext.substring(i + shorttext.length))];
    // Swap insertions for deletions if shorttext is text1.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
            new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
                           diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          var sub_diff =
              this.diff_main(text_delete, text_insert, false, deadline);
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          for (var j = sub_diff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, sub_diff[j]);
          }
          pointer = pointer + sub_diff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers's paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror matches?
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror matches?
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll start with '\n' and use the next Unicode code point available.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and lineHash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk through text searching for a newline.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          // Bail out at 65535 because
          // String.fromCharCode(65536) == String.fromCharCode(0)
          line = text.substring(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  // Allocate 2/3rds of the space for text1, 1/3rd for text2.
  var maxLines = 40000;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text = '';
    for (var j = 0; j < chars.length; j++) {
      text += lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text;
  }
};


/**
 * Find the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Find the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the half-match algorithm should be used.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Half-match algorithm drives the diff into timeout.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var lastEquality = null;
  // Always equal to diffs[equalities[equalities.length - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities.push(pointer);
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      length_insertions2 += (diffs[pointer][0] == DIFF_INSERT ?
                             diffs[pointer][1].length : 0);
      length_deletions2 += (diffs[pointer][0] == DIFF_DELETE ?
                            diffs[pointer][1].length : 0);
      // Five types of semantic edits are considered.
      if (lastEquality && (lastEquality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastEquality.length <= Math.max(length_insertions2,
                                            length_deletions2))) {
        // System.out.println("Semantic Chomp.
        // Equal(" + lastEquality + ") is small.");
        // Lift the equality out.
        diffs.splice(equalities[equalities.length - 1], 1);
        changes = true;
        // Pop the equality index.
        equalities.pop();
        // Shift the indices past the removed element.
        if (equalities.length > 0) {
          equalities[equalities.length - 1] =
              equalities[equalities.length - 1] - 1;
        }
        if (equalities.length > 0) {
          pointer--;
        } else {
          // There are no previous equalities, so just start over.
          pointer = -1;
        }
        // Throw away the lengths now that we have merged the changes
        // with the deleted equality.
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
      }
    }
    pointer++;
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abc</del><ins>axc</ins> -> <del>b</del>a<ins>x</ins>c
  // e.g: <del>axc</del><ins>abc</ins> -> a<del>x</del><ins>b</ins>c
  // Only extract an overlap if it is as big as the edit cost, or if it is
  // a real pre-existing equality.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2.0 ||
            overlap_length1 >= insertion.length / 2.0) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2.0 ||
            overlap_length2 >= insertion.length / 2.0) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to eliminate an equality.
 * e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(/\s/) || char1.match(/\p{P}/u);
    var nonAlphaNumeric2 = char2.match(/\s/) || char2.match(/\p{P}/u);
    var whitespace1 = nonAlphaNumeric1 && char1.match(/\s/);
    var whitespace2 = nonAlphaNumeric2 && char2.match(/\s/);
    var lineBreak1 = whitespace1 && char1.match(/[\r\n]/);
    var lineBreak2 = whitespace2 && char2.match(/[\r\n]/);
    var blankLine1 = lineBreak1 && one.match(/\n\r?\n$/);
    var blankLine2 = lineBreak2 && two.match(/^\r?\n\r?\n/);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing changes to move forward.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};


/**
 * Given two strings, compute a score representing whether the internal
 * boundary falls on logical boundaries.
 * Scores range from 6 (best) to 0 (worst).
 * @param {string} one First string.
 * @param {string} two Second string.
 * @return {number} The score.
 * @deprecated Use diff_cleanupSemanticScore_() instead.
 */
diff_match_patch.prototype.diff_cleanupSemanticScore =
    function(one, two) {
  var nonAlphaNumeric1 = one.match(/[^a-zA-Z0-9]/);
  var nonAlphaNumeric2 = two.match(/[^a-zA-Z0-9]/);
  var whitespace1 = nonAlphaNumeric1 && one.match(/\s/);
  var whitespace2 = nonAlphaNumeric2 && two.match(/\s/);
  var lineBreak1 = whitespace1 && one.match(/[\r\n]/);
  var lineBreak2 = whitespace2 && two.match(/[\r\n]/);
  var blankLine1 = lineBreak1 && one.match(/\n\r?\n$/);
  var blankLine2 = lineBreak2 && two.match(/^\r?\n\r?\n/);

  if (blankLine1 || blankLine2) {
    // Five points for blank lines.
    return 5;
  } else if (lineBreak1 || lineBreak2) {
    // Four points for line breaks.
    return 4;
  } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
    // Three points for end of sentences.
    return 3;
  } else if (whitespace1 || whitespace2) {
    // Two points for whitespace.
    return 2;
  } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
    // One point for non-alphanumeric.
    return 1;
  }
  return 0;
};


/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var lastEquality = '';  // Always equal to diffs[equalities[equalities.length - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        var tuples = [];
        var i = (pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) +
            (post_del ? 1 : 0);
        if (pre_ins) {
          tuples.push(diffs[equalities[equalities.length - 1] - i]);
        }
        if (pre_del) {
          tuples.push(diffs[equalities[equalities.length - 1] - i + 1]);
        }
        tuples.push(diffs[equalities[equalities.length - 1]]);
        if (post_ins) {
          tuples.push(diffs[equalities[equalities.length - 1] + 1]);
        }
        if (post_del) {
          tuples.push(diffs[equalities[equalities.length - 1] + 1 +
              (post_ins ? 1 : 0)]);
        }
        // Four edits costs less than the equality.
        if (tuples[0][1].length + tuples[tuples.length - 1][1].length >
            tuples[1][1].length) {
          diffs.splice(equalities[equalities.length - 1], 1);
          changes = true;
          // Throw away the equality we just deleted.
          lastEquality = '';
          equalities.pop();
          // The surrounding edits are no longer surrounding.
          pre_ins = pre_del = post_ins = post_del = false;
          // Special case: deleting the first equality.
          if (equalities.length == 0) {
            // Start over.
            pointer = -1;
          } else {
            equalities[equalities.length - 1] =
                equalities[equalities.length - 1] - 1;
            pointer = equalities[equalities.length - 1] -
                (pre_ins ? 1 : 0) - (pre_del ? 1 : 0);
          }
        }
      }
      equalities.push(pointer);
      lastEquality = diffs[pointer][1];
      pre_ins = pre_del = post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        if (equalities.length > 0) {
          post_del = true;
        } else {
          pre_del = true;
        }
      } else {
        if (equalities.length > 0) {
          post_ins = true;
        } else {
          pre_ins = true;
        }
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
                    text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another merge pass.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var lastdiff = null;
  for (var i = 0; i < diffs.length; i++) {
    var diff = diffs[i];
    if (diff[0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diff[1].length;
    }
    if (diff[0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diff[1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      lastdiff = diff;
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  if (lastdiff && lastdiff[0] === DIFF_DELETE) {
    // The location was deleted.
    return last_chars2;
  }
  // Add the remaining character length from the last equality.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var i = 0; i < diffs.length; i++) {
    var op = diffs[i][0];    // Operation (insert, delete, equal)
    var data = diffs[i][1];  // Text of change.
    var text = data.replace(pattern_amp, '&').replace(pattern_lt, '<')
        .replace(pattern_gt, '>').replace(pattern_para, '¶<br>');
    switch (op) {
      case DIFF_INSERT:
        html[i] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[i] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[i] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var i = 0; i < diffs.length; i++) {
    if (diffs[i][0] !== DIFF_INSERT) {
      text[i] = diffs[i][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var i = 0; i < diffs.length; i++) {
    if (diffs[i][0] !== DIFF_DELETE) {
      text[i] = diffs[i][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var i = 0; i < diffs.length; i++) {
    var op = diffs[i][0];
    var data = diffs[i][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var i = 0; i < diffs.length; i++) {
    switch (diffs[i][0]) {
      case DIFF_INSERT:
        text[i] = '+' + encodeURI(diffs[i][1]);
        break;
      case DIFF_DELETE:
        text[i] = '-' + diffs[i][1].length;
        break;
      case DIFF_EQUAL:
        text[i] = '=' + diffs[i][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given a delta string, parse it into an array of diff tuples.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var i = 0; i < tokens.length; i++) {
    // Each token begins with a one character parameter which specifies the
    // operation of that token (DELETED, INSERT, EQUAL).
    var param = tokens[i].substring(1);
    switch (tokens[i].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] =
              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[i].charAt(0) == '=') {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
        }
        break;
      default:
        // Anything else is an error.
        if (tokens[i]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[i]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Another shortcut)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score found so far.
  var score_threshold = this.Match_Threshold;
  // Best location found so far.
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Start of test range (insisting on minimum of 0).
  var search_start = Math.max(0, loc - this.Match_Distance);
  // End of test range (insisting on maximum of text.length).
  var search_end = Math.min(text.length, loc + this.Match_Distance);

  // Initialize the bit arrays.
  var bitarr = new Array(search_end - search_start);

  var last_rd = new Array(pattern.length + 2);
  last_rd[0] = (1 << pattern.length) - 1;
  for (var j = pattern.length; j > 0; j--) {
    last_rd[j] = (1 << (j - 1)) - 1;
  }
  for (var i = search_start; i < search_end; i++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at
    // this error level.
    var bin_min = 0;
    var bin_mid = pattern.length;
    var bin_max = pattern.length;
    var rd = last_rd.slice();
    while (bin_min < bin_mid) {
      if (match_bitapScore_(bin_max, loc) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the new last_rd.
    // Repeat this entire process, allowing for one more error.
    // For each character, calculate the bit array for that character.
    var char_rd = s[text.charAt(i)];
    var j = pattern.length;
    rd[j] = ((rd[j - 1] << 1) | 1) & char_rd;
    for (j--; j > 0; j--) {
      rd[j] = (((rd[j - 1] << 1) | 1) & char_rd) |
          (((rd[j] << 1) | 1) & (last_rd[j - 1])) |
          (((last_rd[j] << 1) | 1) & (last_rd[j - 1])) |
          last_rd[j];
    }
    // Keep track of the lowest error level so far.
    bitarr[i - search_start] = rd[1];
    if (rd[1] & 1) {
      var score = match_bitapScore_(0, i);
      if (score <= score_threshold) {
        // Found a perfect match at the desired location.  Bail out early.
        return i;
      }
    }
    last_rd = rd;
  }

  // Look for the best match.
  var best_dist = -1;
  for (var j = 0; j < pattern.length; j++) {
    for (var i = search_start; i < search_end; i++) {
      if (bitarr[i - search_start] & (1 << j)) {
        var score = match_bitapScore_(j + 1, i);
        // Better score than threshold.
        if (score <= score_threshold) {
          score_threshold = score;
          best_loc = i;
          best_dist = j + 1;
        }
      }
    }
  }
  // The last character of the pattern must match.
  if ((bitarr[search_end - search_start - 1] & 1) &&
      (match_bitapScore_(0, search_end - 1) <= score_threshold)) {
    best_loc = search_end - 1;
    best_dist = 0;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * The data structure representing a patch is an array of objects:
 * [{diffs: {!Array.<!diff_match_patch.Diff>}, start1: number, start2: number,
 *   length1: number, length2: number}]
 */

/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.Patch = function() {
  this.diffs = [];
  this.start1 = 0;
  this.start2 = 0;
  this.length1 = 0;
  this.length2 = 0;
};


/**
 * Emulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.Patch.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var i = 0; i < this.diffs.length; i++) {
    switch (this.diffs[i][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[i + 1] = op + encodeURI(this.diffs[i][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


/**
 * Take a list of diffs and create a textual patch.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {!Array.<!diff_match_patch.Patch>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, b, c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof b == 'string' && typeof c == 'undefined') {
    // Method 1: text1, text2
    // References b, c presumably not used.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof b == 'undefined' &&
             typeof c == 'undefined') {
    // Method 2: diffs
    // References b, c presumably not used.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && b && typeof b == 'object' &&
             typeof c == 'undefined') {
    // Method 3: text1, diffs
    // Reference c presumably not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(b);
  } else if (typeof a == 'string' && typeof b == 'string' &&
             c && typeof c == 'object') {
    // Method 4: text1, text2, diffs
    // text1 and text2 are not used.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.Patch();
  var patchDiffLength = 0;
  var char_count1 = 0;  // Number of characters consumed from text1.
  var char_count2 = 0;  // Number of characters consumed from text2.
  // Pre-populate text1 with applied diffs.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var i = 0; i < diffs.length; i++) {
    var diff_type = diffs[i][0];
    var diff_text = diffs[i][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[i];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[i];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != i + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[i];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        }

        if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.Patch();
            patchDiffLength = 0;
            // Reset the start characters for the next patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Add the final patch.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.Patch>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.Patch>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making a deep copy is not trivial in JavaScript.
  var patches_copy = [];
  for (var i = 0; i < patches.length; i++) {
    var patch = patches[i];
    var patch_copy = new diff_match_patch.Patch();
    patch_copy.diffs = [];
    for (var j = 0; j < patch.diffs.length; j++) {
      patch_copy.diffs[j] =
          new diff_match_patch.Diff(patch.diffs[j][0], patch.diffs[j][1]);
    }
    patch_copy.start1 = patch.start1;
    patch_copy.start2 = patch.start2;
    patch_copy.length1 = patch.length1;
    patch_copy.length2 = patch.length2;
    patches_copy[i] = patch_copy;
  }
  return patches_copy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.Patch>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to storage.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the patch in the text, assuming that patches are applied in order.
  var delta = 0;
  var results = [];
  for (var i = 0; i < patches.length; i++) {
    var expected_loc = patches[i].start2 + delta;
    var text1 = this.diff_text1(patches[i].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find overlapping edges.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[i] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[i].length2 - patches[i].length1;
    } else {
      // Found a match.  :)
      results[i] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[i].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.
        // Run a diff to get a framework of equivalent indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[i] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var text2_parts = [];
          for (var j = 0; j < patches[i].diffs.length; j++) {
            var mod = patches[i].diffs[j];
            if (mod[0] !== DIFF_EQUAL) {
              var index2 = this.diff_xIndex(diffs, index1);
              text2_parts[j] = this.diff_text2([mod]);
            }
            if (mod[0] === DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
          text = text.substring(0, start_loc) + text2_parts.join('') +
                 text.substring(start_loc + text1.length);
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.Patch>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var i = 1; i <= paddingLength; i++) {
    nullPadding += String.fromCharCode(i);
  }

  // Bump all the patches forward.
  for (var i = 0; i < patches.length; i++) {
    patches[i].start1 += paddingLength;
    patches[i].start2 += paddingLength;
  }

  // Add some padding on text start and end so that edges can match something.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.Patch>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var i = 0; i < patches.length; i++) {
    if (patches[i].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[i];
    // Remove the big patch.
    patches.splice(i--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.Patch();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++i, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.Patch>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var i = 0; i < patches.length; i++) {
    text[i] = patches[i];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.Patch>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.Patch();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.Patch} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(Math.max(0, patch.start2 - padding),
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(Math.max(0, patch.start2 - padding),
      patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
      patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};

// The following export code was added by @torbjorn
// It's not part of the original library.
// The purpose is to make this library function as a CJS module.
// See https://github.com/google/diff-match-patch/issues/59
if (typeof module !== 'undefined' && module.exports) {
  module.exports = diff_match_patch;
  module.exports.DIFF_DELETE = DIFF_DELETE;
  module.exports.DIFF_INSERT = DIFF_INSERT;
  module.exports.DIFF_EQUAL = DIFF_EQUAL;
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\fullcalendar\FullCalendar.js
========================================================================


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\fullcalendar\main.global.min.js
========================================================================

/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
var FullCalendar = (function(e) {
	"use strict";
	var t = function(e, n) {
		return (t =
			Object.setPrototypeOf ||
			({ __proto__: [] } instanceof Array &&
				function(e, t) {
					e.__proto__ = t;
				}) ||
			function(e, t) {
				for (var n in t)
					Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
			})(e, n);
	};
	function n(e, n) {
		if ("function" != typeof n && null !== n)
			throw new TypeError(
				"Class extends value " + String(n) + " is not a constructor or null"
			);
		function r() {
			this.constructor = e;
		}
		t(e, n),
			(e.prototype =
				null === n ? Object.create(n) : ((r.prototype = n.prototype), new r()));
	}
	var r = function() {
		return (r =
			Object.assign ||
			function(e) {
				for (var t, n = 1, r = arguments.length; n < r; n++)
					for (var o in (t = arguments[n]))
						Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
				return e;
			}).apply(this, arguments);
	};
	function o(e, t) {
		var n = {};
		for (var r in e)
			Object.prototype.hasOwnProperty.call(e, r) &&
				t.indexOf(r) < 0 &&
				(n[r] = e[r]);
		if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
			var o = 0;
			for (r = Object.getOwnPropertySymbols(e); o < r.length; o++)
				t.indexOf(r[o]) < 0 &&
					Object.prototype.propertyIsEnumerable.call(e, r[o]) &&
					(n[r[o]] = e[r[o]]);
		}
		return n;
	}
	function i(e, t) {
		for (
			var n = 0, r = t.length, o = e.length;
			n < r;
			n++, o++
		)
			e[o] = t[n];
		return e;
	}
	var a = "default",
		s = "5.11.5";
	function l(e) {
		return (
			e instanceof Element || "string" == typeof e || "number" == typeof e
		);
	}
	function u(e) {
		return e;
	}
	var c = {}.hasOwnProperty;
	function d(e, t) {
		return null != e && c.call(e, t);
	}
	function p(e) {
		var t = [];
		for (var n in e) t.push(e[n]);
		return t;
	}
	function f(e, t) {
		return v(e, null, t);
	}
	function h(e, t) {
		return v(e, t, null);
	}
	function v(e, t, n) {
		for (var r = Object.create(e || null), o = 0, i = [t, n]; o < 2; o++) {
			var a = i[o];
			if (a) for (var s in a) r[s] = a[s];
		}
		return r;
	}
	function g(e, t, n) {
		if ((void 0 === n && (n = {}), e === t)) return !0;
		if (e && t && e.constructor === t.constructor) {
			if (Array.isArray(e)) {
				if (e.length !== t.length) return !1;
				for (var o = 0; o < e.length; o++) if (!g(e[o], t[o], n)) return !1;
				return !0;
			}
			if (
				"object" == typeof e &&
				(n.marker ||
					((n.marker = Math.random()), (e[n.marker] = t[n.marker] = !0)),
					e[n.marker] !== t[n.marker])
			)
				return !1;
			for (var i in e)
				if (d(e, i) && !d(t, i)) {
					if (n.marker) {
						delete e[n.marker];
						delete t[n.marker];
					}
					return !1;
				}
			for (var i in t)
				if (d(t, i) && !d(e, i)) {
					if (n.marker) {
						delete e[n.marker];
						delete t[n.marker];
					}
					return !1;
				}
			for (var i in e) if (d(e, i) && !g(e[i], t[i], n)) return !1;
			if (n.marker) {
				delete e[n.marker];
				delete t[n.marker];
			}
			return !0;
		}
		return !1;
	}
	var m = {
		week: 3,
		separator: 0,
		omitZeroMinute: 0,
		meridiem: 0,
		omitCommas: 0,
	};
	function y(e, t) {
		return e.meridiem === t.meridiem && e.hour === t.hour && e.minute === t.minute
			? 1
			: 0;
	}
	function E(e, t) {
		var n = [];
		if (e) for (var r = 0; r < e.length; r++) n.push(t(e[r], r));
		return n;
	}
	function S(e, t) {
		var n = [];
		if (e) for (var r = 0; r < e.length; r++) t(e[r], r) && n.push(e[r]);
		return n;
	}
	function D(e, t) {
		var n = {};
		if (e)
			for (var r = 0; r < e.length; r++) {
				var o = t(e[r], r);
				n[o[0]] = o[1];
			}
		return n;
	}
	function b(e) {
		return e ? !0 === e[0] : [!1];
	}
	function C(e, t) {
		var n = {};
		if (e)
			for (var r in e) {
				var o = t(e[r], r);
				o && (n[r] = o);
			}
		return n;
	}
	function w(e, t) {
		for (var n = 0, r = e; n < r.length; n++) {
			var o = r[n];
			if (o[t]) return o[t];
		}
		return null;
	}
	function R(e, t) {
		return T(e, t);
	}
	function T(e, t) {
		for (var n = 0, r = e.length; n < r; n += 1)
			if (e[n] === t) return e.splice(n, 1), !0;
		return !1;
	}
	function k(e, t) {
		for (var n = e.length, r = t.length, o = 0; o < r; o++) e[(n + o) % r] = t[o];
	}
	function M(e, t) {
		var n = e[t];
		return "function" == typeof n ? n : u;
	}
	function x(e) {
		return e.charAt(0).toUpperCase() + e.slice(1);
	}
	function _(e, t) {
		return (t ? String(t) : "") + e;
	}
	function I(e) {
		return e < 10 ? "0" + e : "" + e;
	}
	function P(e) {
		return e > 999 ? Math.floor(e / 1e3) + "k" : String(e);
	}
	function N(e) {
		return (e + "")
			.replace(/&/g, "&")
			.replace(/</g, "<")
			.replace(/>/g, ">")
			.replace(/'/g, "'")
			.replace(/"/g, """)
			.replace(/\n/g, "<br />"));
	}
	function H(e) {
		return e.replace(/</g, "<").replace(/>/g, ">").replace(/"/g, '"').replace(/'/g, "'").replace(/&/g, "&");
	}
	function O(e) {
		return e.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, "");
	}
	function A(e) {
		for (
			var t = [],
			n = "string" == typeof e ? e.split(/\s*,\s*/) : e,
			r = 0,
			o = n;
			r < o.length;
			r++
		) {
			var i = o[r];
			"string" == typeof i ? (t = t.concat(i.split(/\s+/))) : t.push(i);
		}
		return t;
	}
	function U(e) {
		var t;
		return (t =
			"string" == typeof e
				? e.split(/\s*,\s*/)
				: e),
			S(t, function(e) {
				return e;
			});
	}
	function L(e) {
		return Array.isArray(e) ? e : [e];
	}
	function B(e, t, n) {
		for (var r = 0, o = e.length; r < o; r += 1) if (t.call(n, e[r], r, e)) return e[r];
	}
	function V(e, t, n, r) {
		for (var o = 0, i = e.length; o < i; o += 1)
			if (n !== (t ? e[o][t] : e[o])) {
				e.splice(o, r || 0, n);
				break;
			}
	}
	function F(e, t) {
		for (
			var n = 0,
			r = Math.min(e.length, t.length);
			n < r && e[n] === t[n];

		)
			n += 1;
		return n;
	}
	function z(e, t, n) {
		if (t) {
			var r = e.indexOf(t);
			if (r === n) return !0;
			if (n > r) return e.slice(r + 1, n + 1).every(G);
		}
		return !1;
	}
	function G(e) {
		return !e.tagName;
	}
	function j(e) {
		return Array.prototype.slice.call(e);
	}
	function q(e) {
		return Array.isArray(e) ? e : j(e);
	}
	function W(e, t) {
		var n = e.indexOf(t);
		return n > -1 && e.splice(n, 1), e;
	}
	function Y(e) {
		var t = document.createElement("div");
		return (
			(t.innerHTML = e.trim()),
			1 === t.childNodes.length ? t.childNodes[0] : t
		);
	}
	function Z(e, t, n, r) {
		for (var o = 0, i = e; o < i.length; o++) {
			var a = i[o];
			if (a.structure) return Z(a.children, t, n, r);
			r = n(a, t || r);
		}
		return r;
	}
	var K,
		X = 0;
	function J() {
		return String((X += 1));
	}
	function $() {
		document.body.classList.add("fc-not-allowed");
	}
	function Q() {
		document.body.classList.remove("fc-not-allowed");
	}
	function ee(e) {
		e.preventDefault();
	}
	function te(e) {
		return "function" == typeof e ? e() : e;
	}
	function ne(e) {
		return e.join("");
	}
	function re(e) {
		var t = Array.isArray(e[0]) ? e[0] : e;
		return (
			"object" == typeof t[0] && null !== t[0]
				? t.map(function(e) {
					return String(e.id);
				})
				: t
		).join(",");
	}
	function oe(e, t) {
		return (
			(e && t && e.getTime() === t.getTime()) || (!e && !t)
		);
	}
	function ie(e, t) {
		return (
			e && t && e.getFullYear() === t.getFullYear() && e.getMonth() === t.getMonth() && e.getDate() === t.getDate()
		);
	}
	var ae = ["years", "months", "days", "milliseconds"],
		se = /^(?:(\d+)\.)?(\d+):(\d+):(\d+)(?:\.(\d+))?$/;
	function le(e) {
		var t = typeof e;
		return "string" === t
			? se.test(e)
				? {
					years: 0,
					months: 0,
					days: parseInt(RegExp.$1, 10) || 0,
					milliseconds:
						(60 * (60 * (1e3 * (parseInt(RegExp.$2, 10) || 0)) + 1e3 * (parseInt(RegExp.$3, 10) || 0)) + 1e3 * (parseInt(RegExp.$4, 10) || 0) + (parseInt(RegExp.$5, 10) || 0)),
				}
				: null
			: "object" === t && e
				? {
					years: e.years || e.year || 0,
					months: e.months || e.month || 0,
					days: e.days || e.day || 0,
					milliseconds:
						60 *
						(60 * (1e3 * (e.hours || e.hour || 0)) +
							1e3 * (e.minutes || e.minute || 0)) +
						1e3 * (e.seconds || e.second || 0) +
						(e.milliseconds || e.millisecond || e.ms || 0),
				}
				: "number" === t
					? { years: 0, months: 0, days: 0, milliseconds: e }
					: null;
	}
	function ue(e) {
		return {
			years: e.years || 0,
			months: e.months || 0,
			days: e.days || 0,
			milliseconds: e.milliseconds || 0,
		};
	}
	function ce(e) {
		return (
			e.years ||
			e.months ||
			e.days ||
			e.milliseconds
		);
	}
	function de(e) {
		return (
			(36e5 * (e.days * 24) +
				36e5 * e.hours +
				6e4 * e.minutes +
				1e3 * e.seconds +
				e.milliseconds)
		);
	}
	function pe(e, t) {
		return {
			years: e.years + t.years,
			months: e.months + t.months,
			days: e.days + t.days,
			milliseconds: e.milliseconds + t.milliseconds,
		};
	}
	function fe(e, t) {
		return {
			years: e.years - t.years,
			months: e.months - t.months,
			days: e.days - t.days,
			milliseconds: e.milliseconds - t.milliseconds,
		};
	}
	function he(e, t) {
		return {
			years: e.years * t,
			months: e.months * t,
			days: e.days * t,
			milliseconds: e.milliseconds * t,
		};
	}
	function ve(e) {
		var t =
			e.milliseconds > 0
				? (e.milliseconds % 1e3 == 0) ? "second-strict"
					: "millisecond"
				: e.days
					? "day"
					: e.months
						? "month"
						: "year";
		return t ? me(t) : null;
	}
	function ge(e) {
		return JSON.stringify(e);
	}
	function me(e) {
		switch (e) {
			case "year":
				return 1;
			case "month":
				return 2;
			case "day":
				return 3;
			case "hour":
				return 4;
			case "minute":
				return 5;
			case "second":
				return 6;
			default:
				return null;
		}
	}
	function ye(e) {
		return e / 1e3;
	}
	function Ee(e) {
		return e / 6e4;
	}
	function Se(e) {
		return e / 36e5;
	}
	function De(e) {
		return e / 864e5;
	}
	function be(e) {
		return e / 6048e5;
	}
	function Ce(e) {
		return De(e) / 365;
	}
	function we(e, t) {
		return e.getUTCFullYear() === t.getUTCFullYear() && e.getUTCMonth() === t.getUTCMonth() && e.getUTCDate() === t.getUTCDate();
	}
	function Re(e, t) {
		return (
			e.getUTCFullYear() === t.getUTCFullYear() &&
			e.getUTCMonth() === t.getUTCMonth() &&
			e.getUTCDate() === t.getUTCDate() &&
			e.getUTCHours() === t.getUTCHours() &&
			e.getUTCMinutes() === t.getUTCMinutes()
		);
	}
	function Te(e) {
		return new Date(
			e.getUTCFullYear(),
			e.getUTCMonth(),
			e.getUTCDate(),
			e.getUTCHours(),
			e.getUTCMinutes(),
			e.getUTCSeconds(),
			e.getUTCMilliseconds()
		);
	}
	function ke(e, t) {
		return (
			(n = e),
			new Date(
				Date.UTC(
					n.getUTCFullYear(),
					n.getUTCMonth(),
					n.getUTCDate() + t
				)
			)
		);
		var n;
	}
	function Me(e, t) {
		return xe(e, t, 1);
	}
	function xe(e, t, n) {
		var r = e.getUTCFullYear(),
			o = _e(e, r, t * n);
		return o.setUTCDate(1), o;
	}
	function _e(e, t, n) {
		var r = e.getUTCMonth();
		return (
			(r += n),
			new Date(Date.UTC(t, r, 1))
		);
	}
	function Ie(e) {
		return e.getUTCDay();
	}
	var Pe = [
		"sun",
		"mon",
		"tue",
		"wed",
		"thu",
		"fri",
		"sat",
	];
	function Ne(e) {
		return Pe[e];
	}
	var He = 864e5;
	function Oe(e, t) {
		var n = new Date(e.valueOf() - t.valueOf());
		return Math.round(n.valueOf() / He);
	}
	function Ae(e, t) {
		return (e.valueOf() - t.valueOf()) / He;
	}
	function Ue(e, t) {
		var n = Le(e),
			r = Le(t);
		return {
			years: 0,
			months: 0,
			days: Math.round(De(n.valueOf() - r.valueOf())),
			milliseconds: n.valueOf() - r.valueOf(),
		};
	}
	function Le(e) {
		return new Date(e.valueOf() - Be(e));
	}
	function Be(e) {
		return (
			36e5 * e.getUTCHours() +
			6e4 * e.getUTCMinutes() +
			1e3 * e.getUTCSeconds() +
			e.getUTCMilliseconds()
		);
	}
	function Ve(e, t) {
		if (e.getUTCFullYear() === t.getUTCFullYear()) {
			var n = e.getUTCMonth(),
				r = t.getUTCMonth();
			if (n === r) return e.getUTCDate() - t.getUTCDate();
			var o = new Date(Date.UTC(e.getUTCFullYear(), n)),
				i = new Date(Date.UTC(e.getUTCFullYear(), r));
			return Math.round(De(o.valueOf() - i.valueOf()));
		}
		return null;
	}
	function Fe(e) {
		var t = e.getUTCFullYear();
		return new Date(Date.UTC(t + 1, 0, 1)).valueOf() -
			new Date(Date.UTC(t, 0, 1)).valueOf() >
			365 * He;
	}
	var ze,
		Ge = ["years", "months", "days", "milliseconds"],
		je = /^(-?)(?:(\d+)\.)?(\d+):(\d+):(\d+)(?:\.(\d+))?$/;
	function qe(e) {
		var t = typeof e;
		return "string" === t
			? je.test(e)
				? {
					years: 0,
					months: 0,
					days: parseInt(RegExp.$2, 10) || 0,
					milliseconds:
						(60 *
							(60 * (1e3 * (parseInt(RegExp.$3, 10) || 0)) +
								1e3 * (parseInt(RegExp.$4, 10) || 0)) +
							1e3 * (parseInt(RegExp.$5, 10) || 0) +
							(parseInt(RegExp.$6, 10) || 0)) *
						("-" === RegExp.$1 ? -1 : 1),
				}
				: null
			: "object" === t && e
				? {
					years: e.years || e.year || 0,
					months: e.months || e.month || 0,
					days: e.days || e.day || 0,
					milliseconds:
						60 *
						(60 * (1e3 * (e.hours || e.hour || 0)) +
							1e3 * (e.minutes || e.minute || 0)) +
						1e3 * (e.seconds || e.second || 0) +
						(e.milliseconds || e.millisecond || e.ms || 0),
				}
				: "number" === t
					? { years: 0, months: 0, days: 0, milliseconds: e }
					: null;
	}
	function We(e) {
		return JSON.stringify(e);
	}
	function Ye(e, t) {
		return e.years === t.years && e.months === t.months && e.days === t.days && e.milliseconds === t.milliseconds;
	}
	function Ze(e) {
		var t = [];
		return (
			e.years && t.push(e.years + "Y"),
			e.months && t.push(e.months + "M"),
			e.days && t.push(e.days + "D"),
			e.milliseconds &&
			t.push(
				"T" +
				(function(e) {
					var t = Math.floor(e / 36e5),
						n = Math.floor((e % 36e5) / 6e4),
						r = Math.floor((e % 6e4) / 1e3),
						o = e % 1e3;
					return (
						(t > 0 ? t + "H" : "") +
						(n > 0 ? n + "M" : "") +
						(r > 0 || o > 0 ? (r + (o ? "." + I(o) : "")) + "S" : "")
					);
				})(e.milliseconds)
			),
			"P" + t.join("")
		);
	}
	function Ke(e) {
		var t = document.createElement("a");
		return (t.href = e), t;
	}
	function Xe(e, t) {
		if (e.closest) return e.closest(t);
		if (!document.documentElement.contains(e)) return null;
		do {
			if (Je(e, t)) return e;
			e = e.parentElement || e.parentNode;
		} while (null !== e && 1 === e.nodeType);
		return null;
	}
	function Je(e, t) {
		return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t);
	}
	function $e(e, t) {
		for (
			var n = e instanceof HTMLElement ? [e] : e, r = [], o = 0;
			o < n.length;
			o += 1
		)
			for (
				var i = n[o].querySelectorAll(t), a = 0;
				a < i.length;
				a += 1
			)
				r.push(i[a]);
		return r;
	}
	(ze = {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
	}),
		["webkit", "moz", "ms", "o"].forEach(function(e) {
			(ze.webkitRequestFullScreen = e + "RequestFullScreen"),
				(ze.webkitExitFullscreen = e + "ExitFullscreen"),
				(ze.fullscreenElement = e + "FullscreenElement"),
				(ze.fullscreenchange = e + "fullscreenchange");
		});
	var Qe = "fullscreenElement";
	function et(e, t, n) {
		e.addEventListener(
			t,
			n.listener,
			n.options
		);
	}
	function tt(e, t, n) {
		e.removeEventListener(
			t,
			n.listener,
			n.options
		);
	}
	function nt(e, t, n) {
		var r =
			"object" == typeof n
				? r
				: { capture: n };
		return {
			listener: function(n) {
				if (!e.el || ("_fcUserEvent" in n && "touchend" === n.type && n._fcUserEvent.isTouch))
					t.call(e, n);
			},
			options: r,
		};
	}
	var rt =
		"undefined" != typeof window && window.getComputedStyle
			? window.getComputedStyle
			: null,
		ot = 1;
	function it(e, t) {
		if (!rt) return !0;
		var n = rt(e);
		if (n && n.getPropertyValue) {
			for (var r = 0, o = t; r < o.length; r++) {
				var i = o[r],
					a = i.split(" ");
				if (
					a.some(function(e) {
						return n.getPropertyValue(e) !== a[0];
					})
				)
					return !1;
			}
			return !0;
		}
		return !1;
	}
	var at,
		st,
		lt = 0,
		ut =
			"undefined" != typeof window &&
			(null === (at = window.navigator) || void 0 === at ? void 0 : at.userAgent) ||
			"",
		ct =
			/Edge/.test(ut) ||
			/Trident.*rv[ :]*11\./.test(ut) ||
			/MSIE/.test(ut),
		dt =
			/Safari/.test(ut) &&
			!/Chrome/.test(ut),
		pt =
			"undefined" != typeof window &&
			(null === (st = window.chrome) || void 0 === st ? void 0 : st.runtime);
	function ft(e) {
		var t = document.createElement("div");
		t.style.position = "absolute";
		t.style.top = "-1000px";
		t.style.left = "0px";
		document.body.appendChild(t);
		var n = e(t),
			r = t.getBoundingClientRect().height;
		return t.parentNode.removeChild(t), n > r;
	}
	var ht =
		ft(function(e) {
			return (
				(e.innerHTML =
					"<div style='height:3px'><div style='height:2px'></div></div>"),
				2 !== e.getBoundingClientRect().height
			);
		}),
		vt =
			ct ||
			ft(function(e) {
				return (
					(e.innerHTML =
						"<table><tr><td></td></tr></table><div style='height:3px'></div>"),
					3 !== e.getBoundingClientRect().height
				);
			});
	var gt = "fc-liquid-hack",
		mt = [
			"fc-daygrid-event",
			"fc-daygrid-block-event",
			"fc-daygrid-dot-event",
		];
	function yt(e, t) {
		if ("auto" === t) {
			if (!vt) return;
			if (e.classList.contains(gt)) return;
			e.classList.add(gt),
				(function(e) {
					for (var t = 0, n = e ? e.getElementsByTagName("th") : []; t < n.length; t++) {
						var r = n[t];
						Et(r);
					}
				})(e),
				e.offsetHeight;
		} else {
			var n;
			(n = e),
				mt.forEach(function(e) {
					n.classList.remove(e);
				}),
				e.classList.remove(gt);
		}
	}
	var Et = ft;
	function St(e) {
		return e.trim().replace(/\u200e/g, "").replace(/\u200f/g, "");
	}
	function Dt(e, t) {
		var n = {},
			r = {},
			o = {},
			i = {},
			a = {},
			s = bt(e.defs);
		for (var l in e.defs) {
			var u = e.defs[l];
			"event" === u.type
				? (n[l] = u)
				: "event-source" === u.type
					? (r[l] = u)
					: "event-ui" === u.type && (i[l] = u);
		}
		for (var l in e.instances) {
			var u = e.instances[l],
				c = s[u.defId];
			u.range && (o[l] = u),
				"event" === c.type
					? (a[l] = u)
					: "event-ui" === c.type &&
					(i[c.defId] = h(i[c.defId], u.ui));
		}
		for (var l in t)
			for (var d in t[l]) {
				var p = t[l][d];
				"event" === (s[p.defId] || {}).type &&
					o[d] &&
					(r[(s[p.defId] || {}).sourceId] || {}).backgroundColor &&
					(p.ui.backgroundColor =
						r[(s[p.defId] || {}).sourceId].backgroundColor);
			}
		return {
			eventDefs: n,
			eventInstances: o,
			eventUiBases: i,
			eventStore: { defs: n, instances: a },
			eventSources: r,
			eventUis: Ct(n, i, t),
			selection: Rt(o, t),
			businessHours: Tt(e, s),
			dateSelection: kt(e.dateSelection),
			eventSelection: Mt(e.eventSelection),
			eventDrag: xt(e.eventDrag),
			eventResize: _t(e.eventResize),
		};
	}
	function bt(e) {
		var t = {};
		for (var n in e) t[n] = e[n];
		return t;
	}
	function Ct(e, t, n) {
		var o = {};
		for (var i in e) {
			var a = wt(i, t, n);
			a.hasUrl && (o[i] = a);
		}
		return o;
	}
	function wt(e, t, n) {
		var o = {},
			i = t[e] || {},
			a = (n[e] || {}).ui;
		return (
			i.display && (o.display = i.display),
			i.classNames && (o.classNames = i.classNames),
			i.backgroundColor && (o.backgroundColor = i.backgroundColor),
			i.borderColor && (o.borderColor = i.borderColor),
			i.textColor && (o.textColor = i.textColor),
			i.extendedProps && (o.extendedProps = i.extendedProps),
			a &&
			a.startEditable &&
			(o.startEditable = a.startEditable),
			a && a.durationEditable && (o.durationEditable = a.durationEditable),
			a && a.constraints && (o.constraints = a.constraints),
			a && a.overlap && (o.overlap = a.overlap),
			a && a.allows && (o.allows = a.allows),
			a && a.backgroundColor && (o.backgroundColor = a.backgroundColor),
			a && a.borderColor && (o.borderColor = a.borderColor),
			a && a.textColor && (o.textColor = a.textColor),
			a && a.classNames && (o.classNames = a.classNames),
			i.url ||
			(o.hasUrl =
				(a && a.url) ||
				r(r({}, o), i).url),
			o
		);
	}
	function Rt(e, t) {
		for (var n in e) if (t[n] && t[n].ui.selected) return n;
		return "";
	}
	function Tt(e, t) {
		var n = e.businessHours,
			o = { defs: {}, instances: {} };
		if (n)
			for (var i in ((n = r(r({}, n), e.businessHours)), n.defs)) {
				var a = n.defs[i];
				t[a.defId] ||
					("businessHours" === a.type
						? (o.defs[i] = a)
						: t[a.defId] &&
						(r[t[a.defId].sourceId] || {}).forceEventColor &&
						(o.defs[i] = a));
			}
		for (var i in n.instances) {
			var s = n.instances[i];
			o.defs[s.defId] && (o.instances[i] = s);
		}
		return o;
	}
	function kt(e) {
		if (e) {
			var t = e.range,
				n = e.allDay,
				o = {};
			return (
				null == n || !1 === n || (o.allDay = n),
				{ range: t, allDay: "allDay" in o }
			);
		}
		return null;
	}
	function Mt(e) {
		return e || null;
	}
	function xt(e) {
		if (e) {
			var t = e.mutatedEvents,
				n = t.defs,
				o = t.instances,
				i = e.isEvent,
				a = e.origPublicEvent;
			return {
				affectedEvents: { defs: n, instances: o },
				mutatedEvents: { defs: n, instances: o },
				isEvent: i,
				origPublicEvent: a,
			};
		}
		return null;
	}
	function _t(e) {
		if (e) {
			var t = e.mutatedEvents,
				n = t.defs,
				o = t.instances,
				i = e.isEvent,
				a = e.origPublicEvent;
			return {
				affectedEvents: e.affectedEvents,
				mutatedEvents: { defs: n, instances: o },
				isEvent: i,
				origPublicEvent: a,
			};
		}
		return null;
	}
	function It(e, t) {
		return { type: "SET_DATE", dateMarker: e, oldDateMarker: t };
	}
	function Pt(e, t) {
		var n =
			e && e.type === t.type && g(e.dateProfile, t.dateProfile),
			r =
				n ||
				(e &&
					e.type === t.type &&
					e.dateProfile);
		return r && delete e.dateProfile, n;
	}
	var Nt = Object.freeze({
		__proto__: null,
		CALENDAR_HEADER_TEXT_FORMATTER: {
			year: "numeric",
			month: "long",
			day: "numeric",
			weekday: "long",
		},
		CALENDAR_FOOTER_TEXT_FORMATTER: { year: "numeric", month: "long" },
		LIST_EVENT_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			meridiem: "short",
		},
		LIST_EVENT_SHORT_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			meridiem: !0,
		},
		LIST_DAY_TEXT_FORMATTER: { weekday: "long" },
		LIST_DAY_SIDE_TEXT_FORMATTER: {
			year: "numeric",
			month: "long",
			day: "numeric",
		},
		AGENDA_WEEK_TEXT_FORMATTER: { weekday: "long" },
		WEEK_TEXT_FORMATTER: { week: "short" },
		DAY_HEADER_TEXT_FORMATTER: { weekday: "long" },
		THUMBNAIL_TEXT_FORMATTER: { week: "narrow" },
		MONTH_DAY_TEXT_FORMATTER: { day: "numeric" },
		YEAR_MONTH_TEXT_FORMATTER: { month: "long" },
		DAY_TEXT_FORMATTER: { day: "numeric", month: "long" },
		DAY_TITLE_FORMATTER: { year: "numeric", month: "long", day: "numeric" },
		EVENT_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			omitZeroMinute: !0,
			meridiem: "narrow",
		},
		EVENT_SHORT_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			meridiem: "narrow",
		},
		WEEK_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			meridiem: !1,
		},
		WEEK_SHORT_TIME_FORMATTER: {
			hour: "numeric",
			minute: "2-digit",
			meridiem: !1,
		},
		WEEK_DAY_FORMATTER: { weekday: "short", day: "numeric", omitCommas: !0 },
		WEEK_HEADER_FORMATTER: {
			day: "numeric",
			month: "long",
			year: "numeric",
			omitCommas: !0,
		},
		DAY_FORMATTER: { day: "numeric", month: "long", omitCommas: !0 },
		MONTH_FORMATTER: { month: "long", year: "numeric", omitCommas: !0 },
		YEAR_FORMATTER: { year: "numeric" },
		NO_TIME_TEXT: "All-day",
		NO_DATE_TEXT: "No date",
		MORE_LINK_TEXT: "more",
		CLOSE_TEXT: "Close",
		PREV_YEAR_TEXT: "Prev year",
		NEXT_YEAR_TEXT: "Next year",
		PREV_MONTH_TEXT: "Prev month",
		NEXT_MONTH_TEXT: "Next month",
		TODAY_TEXT: "Today",
		WEEK_TEXT: "Week",
		DAY_TEXT: "Day",
		MONTH_TEXT: "Month",
		YEAR_TEXT: "Year",
		LIST_TEXT: "List",
	}),
		Ht = {
			en: r({}, Nt),
			fr: {
				CALENDAR_HEADER_TEXT_FORMATTER: {
					year: "numeric",
					month: "long",
					day: "numeric",
					weekday: "long",
				},
				LIST_EVENT_TIME_FORMATTER: {
					hour: "numeric",
					minute: "2-digit",
					meridiem: !1,
				},
				LIST_EVENT_SHORT_TIME_FORMATTER: {
					hour: "numeric",
					minute: "2-digit",
					meridiem: !1,
				},
				NO_TIME_TEXT: "Toute la journée",
				MORE_LINK_TEXT: "plus",
				CLOSE_TEXT: "Fermer",
				PREV_YEAR_TEXT: "Année précédente",
				NEXT_YEAR_TEXT: "Année suivante",
				PREV_MONTH_TEXT: "Mois précédent",
				NEXT_MONTH_TEXT: "Mois suivant",
				TODAY_TEXT: "Aujourd'hui",
				WEEK_TEXT: "Semaine",
				DAY_TEXT: "Jour",
				MONTH_TEXT: "Mois",
				YEAR_TEXT: "Année",
				LIST_TEXT: "Liste",
			},
			de: {
				CALENDAR_HEADER_TEXT_FORMATTER: {
					year: "numeric",
					month: "long",
					day: "numeric",
					weekday: "long",
				},
				LIST_EVENT_TIME_FORMATTER: {
					hour: "numeric",
					minute: "2-digit",
					meridiem: !1,
				},
				LIST_EVENT_SHORT_TIME_FORMATTER: {
					hour: "numeric",
					minute: "2-digit",
					meridiem: !1,
				},
				NO_TIME_TEXT: "Ganztägig",
				MORE_LINK_TEXT: "mehr",
				CLOSE_TEXT: "Schließen",
				PREV_YEAR_TEXT: "Vorheriges Jahr",
				NEXT_YEAR_TEXT: "Nächstes Jahr",
				PREV_MONTH_TEXT: "Vorheriger Monat",
				NEXT_MONTH_TEXT: "Nächster Monat",
				TODAY_TEXT: "Heute",
				WEEK_TEXT: "Woche",
				DAY_TEXT: "Tag",
				MONTH_TEXT: "Monat",
				YEAR_TEXT: "Jahr",
				LIST_TEXT: "Liste",
			},
		};
	function Ot(e) {
		"undefined" == typeof FullCalendarVDom
			? console.error(e)
			: FullCalendarVDom.flushToDom();
	}
	var At,
		Ut,
		Lt,
		Bt,
		Vt,
		Ft,
		zt =
			(n(Gt, (Ut = Mn)),
				(Gt.prototype.remove = function() {
					this.context.dispatch({ type: "REMOVE_EVENT_SOURCE", sourceId: this.internalEventSource.sourceId }),
						this.internalEventSource.remove();
				}),
				(Gt.prototype.refetch = function() {
					this.context.dispatch({ type: "FETCH_EVENT_SOURCES", sourceIds: [this.internalEventSource.sourceId], isRefetch: !0 });
				}),
				Object.defineProperty(Gt.prototype, "id", {
					get: function() {
						return this.internalEventSource.publicId;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(Gt.prototype, "url", {
					get: function() {
						return this.internalEventSource.meta.url;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(Gt.prototype, "format", {
					get: function() {
						return this.internalEventSource.meta.format;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Gt);
	function Gt(e, t) {
		var n = Ut.call(this, e) || this;
		return (n.internalEventSource = t), n;
	}
	var jt =
		(n(qt, (Lt = Mn)),
			(qt.prototype.setProp = function(e, t) {
				this.context.dispatch({
					type: "SET_EVENT_PROP",
					eventId: this.internalEvent.publicId,
					propName: e,
					propValue: t,
				});
			}),
			(qt.prototype.setExtendedProp = function(e, t) {
				this.context.dispatch({
					type: "SET_EVENT_EXTENDED_PROP",
					eventId: this.internalEvent.publicId,
					fieldName: e,
					fieldValue: t,
				});
			}),
			(qt.prototype.setStart = function(e, t) {
				void 0 === t && (t = {});
				var n = this.context.dateEnv.createMarker(e);
				n &&
					this.context.dispatch({
						type: "MOVE_EVENT_INSTANCES",
						eventId: this.internalEvent.publicId,
						newDate: n,
						instanceId: this.internalEvent.instanceId,
						allDay: this.allDay,
						maintainDuration: t.maintainDuration,
					});
			}),
			(qt.prototype.setEnd = function(e, t) {
				void 0 === t && (t = {});
				var n = null;
				e && (n = this.context.dateEnv.createMarker(e)),
					n &&
					this.context.dispatch({
						type: "SET_EVENT_END",
						eventId: this.internalEvent.publicId,
						endDate: n,
					});
			}),
			(qt.prototype.setDates = function(e, t, n) {
				void 0 === n && (n = {});
				var r = this.context.dateEnv.createMarker(e);
				if (r) {
					var o = null;
					t && (o = this.context.dateEnv.createMarker(t));
					var i = this.allDay;
					"allDay" in n && (i = n.allDay);
					var a = this.internalEvent.instanceId;
					this.context.dispatch({
						type: "MOVE_EVENT_INSTANCES",
						eventId: this.internalEvent.publicId,
						newDate: r,
						instanceId: a,
						endDate: o,
						allDay: i,
						maintainDuration: n.maintainDuration,
					});
				}
			}),
			(qt.prototype.moveStart = function(e) {
				var t = le(e);
				t && this.setStart(pe(this.start, t));
			}),
			(qt.prototype.moveEnd = function(e) {
				var t = le(e);
				t && this.end && this.setEnd(pe(this.end, t));
			}),
			(qt.prototype.moveDates = function(e) {
				var t = le(e);
				t &&
					(this.setDates(pe(this.start, t), this.end ? pe(this.end, t) : null, {
						allDay: this.allDay,
					}),
						(this.internalEvent.instanceId =
							this.internalEvent.instanceId));
			}),
			(qt.prototype.setAllDay = function(e, t) {
				void 0 === t && (t = {});
				var n = this.context.dispatch({
					type: "CHANGE_EVENT_ALL_DAY",
					eventId: this.internalEvent.publicId,
					allDay: e,
					instanceId: this.internalEvent.instanceId,
					maintainDuration: t.maintainDuration,
				});
				return n;
			}),
			(qt.prototype.formatRange = function(e) {
				var t = this.context,
					n = t.dateEnv,
					r = t.options;
				return n.formatRange(this.start, this.end, e, {
					forcedStartTzo: this.startTzo,
					forcedEndTzo: this.endTzo,
					isEndExclusive: this.endExclusive,
					defaultSeparator: r.eventRangeSeparator,
				});
			}),
			(qt.prototype.remove = function() {
				this.context.dispatch({
					type: "REMOVE_EVENT_INSTANCES",
					eventId: this.internalEvent.publicId,
					instanceId: this.internalEvent.instanceId,
				});
			}),
			(qt.prototype.toPlainObject = function(e) {
				void 0 === e && (e = {});
				var t = _n(this.internalEvent, this.context.dateEnv, e.collapseExtendedProps, e.collapseColor),
					n = this.context.options.eventDataTransform;
				return n ? n(t) : t;
			}),
			(qt.prototype.toJSON = function() {
				return this.toPlainObject();
			}),
			Object.defineProperty(qt.prototype, "source", {
				get: function() {
					var e = this.internalEvent.sourceId;
					return e
						? new zt(
							this.context,
							this.context.getCurrentData().eventSources[e]
						)
						: null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "start", {
				get: function() {
					return this.context.dateEnv.toDate(this.internalEvent.range.start);
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "end", {
				get: function() {
					var e = this.internalEvent.range.end;
					return e ? this.context.dateEnv.toDate(e) : null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "startStr", {
				get: function() {
					return this.context.dateEnv.formatIso(this.internalEvent.range.start, {
						omitTime: this.allDay,
						forcedTzo: this.startTzo,
					});
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "endStr", {
				get: function() {
					var e = this.internalEvent.range.end;
					return e
						? this.context.dateEnv.formatIso(e, {
							omitTime: this.allDay,
							forcedTzo: this.endTzo,
						})
						: "";
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "id", {
				get: function() {
					return this.internalEvent.publicId;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "groupId", {
				get: function() {
					return this.internalEvent.groupId;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "allDay", {
				get: function() {
					return this.internalEvent.allDay;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "title", {
				get: function() {
					return this.internalEvent.title;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "url", {
				get: function() {
					return this.internalEvent.url;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "display", {
				get: function() {
					return this.internalEvent.ui.display || "auto";
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "startEditable", {
				get: function() {
					return this.internalEvent.ui.startEditable;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "durationEditable", {
				get: function() {
					return this.internalEvent.ui.durationEditable;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "constraint", {
				get: function() {
					return this.internalEvent.ui.constraints[0] || null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "overlap", {
				get: function() {
					return this.internalEvent.ui.overlap;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "allow", {
				get: function() {
					return this.internalEvent.ui.allows[0] || null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "backgroundColor", {
				get: function() {
					return this.internalEvent.ui.backgroundColor;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "borderColor", {
				get: function() {
					return this.internalEvent.ui.borderColor;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "textColor", {
				get: function() {
					return this.internalEvent.ui.textColor;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "classNames", {
				get: function() {
					return this.internalEvent.ui.classNames;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(qt.prototype, "extendedProps", {
				get: function() {
					return this.internalEvent.extendedProps;
				},
				enumerable: !1,
				configurable: !0,
			}),
			qt);
	function qt(e, t) {
		var n = Lt.call(this, e) || this;
		return (
			(n.internalEvent = t),
			(n.startTzo =
				e.options.timeZone === t.range.start.timeZone
					? null
					: t.range.start.timeZone),
			(n.endTzo =
				e.options.timeZone === t.range.end.timeZone
					? null
					: t.range.end.timeZone),
			(n.endExclusive = e.options.displayEventEnd),
			n
		);
	}
	var Wt,
		Yt = {
			id: String,
			groupId: String,
			title: String,
			url: String,
			display: String,
			classNames: A,
			extendedProps: u,
		},
		Zt = {
			startEditable: Boolean,
			durationEditable: Boolean,
			constraints: u,
			overlap: u,
			allows: u,
			backgroundColor: String,
			borderColor: String,
			textColor: String,
			classNames: A,
		},
		Kt = {
			id: String,
			start: null,
			end: null,
			date: null,
			allDay: null,
		},
		Xt = r(r(r({}, Yt), Zt), Kt);
	function Jt(e, t) {
		var n = {};
		for (var r in t) {
			var o = t[r],
				i = e[r];
			n[r] =
				null == i
					? o
					: Array.isArray(i)
						? i
						: "object" == typeof i && "object" == typeof o && i && o
							? h(i, o)
							: i;
		}
		return n;
	}
	var $t,
		Qt =
			(n(en, (Bt = Mn)),
				(en.prototype.setOption = function(e, t) {
					this.context.setOption(e, t);
				}),
				(en.prototype.getOption = function(e) {
					return this.context.getOption(e);
				}),
				(en.prototype.getAvailableLocaleCodes = function() {
					return Object.keys(Ht);
				}),
				(en.prototype.on = function(e, t) {
					var n = this.context.emitter;
					n.on(e, t);
				}),
				(en.prototype.off = function(e, t) {
					var n = this.context.emitter;
					n.off(e, t);
				}),
				(en.prototype.trigger = function(e) {
					for (
						var t, n = [], r = 1;
						r < arguments.length;
						r++
					)
						n[r - 1] = arguments[r];
					var o = this.context.emitter;
					return (t = o.trigger).call.apply(t, i([o, e], n));
				}),
				(en.prototype.changeView = function(e, t) {
					var n = this;
					this.batchRendering(function() {
						if ((n.unselect(), t))
							if (t.date)
								n.context.dispatch({ type: "CHANGE_DATE", dateMarker: t.date });
						n.context.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e });
					});
				}),
				(en.prototype.zoomTo = function(e, t) {
					var n;
					t = t || this.getCurrentData().viewApi.type;
					var r = this.getCurrentData().dateProfileGenerator.build(e, void 0, !0);
					(n = r.isValid ? { date: e, viewType: t } : { viewType: t }),
						this.context.dispatch(n);
				}),
				(en.prototype.batchRendering = function(e) {
					this.context.batchRendering(e);
				}),
				(en.prototype.updateSize = function() {
					this.context.updateSize();
				}),
				(en.prototype.setDates = function(e, t, n) {
					this.context.dateEnv.createMarker(e) &&
						this.context.dispatch({
							type: "CHANGE_DATE",
							dateMarker: e,
							endDate: t,
						});
				}),
				(en.prototype.prev = function() {
					this.context.dispatch({ type: "PREV" });
				}),
				(en.prototype.next = function() {
					this.context.dispatch({ type: "NEXT" });
				}),
				(en.prototype.prevYear = function() {
					this.context.dateProfileGenerator.move(
						this.getCurrentData().dateProfile,
						{ years: -1 }
					);
					var e = this.getCurrentData().currentDate;
					this.context.dispatch({
						type: "CHANGE_DATE",
						dateMarker: this.context.dateEnv.addYears(e, -1),
					});
				}),
				(en.prototype.nextYear = function() {
					this.context.dateProfileGenerator.move(
						this.getCurrentData().dateProfile,
						{ years: 1 }
					);
					var e = this.getCurrentData().currentDate;
					this.context.dispatch({
						type: "CHANGE_DATE",
						dateMarker: this.context.dateEnv.addYears(e, 1),
					});
				}),
				(en.prototype.today = function() {
					this.context.dispatch({ type: "CHANGE_DATE", dateMarker: new Date() });
				}),
				(en.prototype.gotoDate = function(e) {
					this.context.dispatch({ type: "CHANGE_DATE", dateMarker: e });
				}),
				(en.prototype.incrementDate = function(e) {
					var t = le(e);
					t &&
						this.context.dispatch({
							type: "CHANGE_DATE",
							dateMarker: this.context.dateEnv.add(
								this.getCurrentData().currentDate,
								t
							),
						});
				}),
				(en.prototype.getDate = function() {
					return this.context.dateEnv.toDate(
						this.getCurrentData().currentDate
					);
				}),
				(en.prototype.getEvents = function() {
					return rn(
						this.getCurrentData().eventStore,
						this.context
					);
				}),
				(en.prototype.getEventById = function(e) {
					var t = this.getCurrentData().eventStore;
					for (var n in t.defs) {
						var r = t.defs[n];
						if (r.publicId === e)
							for (var o in t.instances) {
								var i = t.instances[o];
								if (i.defId === r.defId)
									return new jt(this.context, {
										def: r,
										instance: i,
									});
							}
					}
					return null;
				}),
				(en.prototype.addEvent = function(e, t) {
					if (e instanceof jt) {
						console.warn("addEvent method doesn't accept an EventApi object. Use toPlainObject instead."),
							(e = e.toPlainObject());
					}
					var n = In(e, "object" == typeof t && t ? t.source : ""),
						r = n.refined,
						o = n.instance;
					return (
						this.context.dispatch({ type: "ADD_EVENTS", eventStore: { defs: { [r.defId]: r }, instances: { [o.instanceId]: o } } }),
						new jt(this.context, { def: r, instance: o })
					);
				}),
				(en.prototype.getEventSources = function() {
					var e = this.getCurrentData().eventSources,
						t = [];
					for (var n in e)
						t.push(new zt(this.context, e[n]));
					return t;
				}),
				(en.prototype.getEventSourceById = function(e) {
					var t = this.getCurrentData().eventSources;
					for (var n in t)
						if (t[n].publicId === e)
							return new zt(this.context, t[n]);
					return null;
				}),
				(en.prototype.addEventSource = function(e) {
					var t = Pn(e, this.context);
					return t
						? (this.context.dispatch({
							type: "ADD_EVENT_SOURCES",
							sources: [t],
						}),
							new zt(this.context, t))
						: null;
				}),
				(en.prototype.refetchEvents = function() {
					this.context.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: !0 });
				}),
				(en.prototype.render = function() {
					this.context.render();
				}),
				(en.prototype.destroy = function() {
					this.context.destroy();
				}),
				(en.prototype.select = function(e, t) {
					var n =
						null == t
							? null == e.start
								? { start: e, end: null }
								: e
							: { start: e, end: t },
						o = this.context.dateEnv.createMarkerMeta(
							n.start
						),
						i = n.end
							? this.context.dateEnv.createMarkerMeta(n.end)
							: null,
						a = r(r({}, o), i);
					this.context.dispatch({
						type: "SELECT_DATES",
						selection: { range: a.range, allDay: a.allDay },
					});
				}),
				(en.prototype.unselect = function(e) {
					this.context.dispatch({ type: "UNSELECT_DATES" });
				}),
				Object.defineProperty(en.prototype, "view", {
					get: function() {
						return this.getCurrentData().viewApi;
					},
					enumerable: !1,
					configurable: !0,
				}),
				en);
	function en(e, t, n) {
		var r = Bt.call(this, e) || this;
		return (
			(r.getCurrentData = t),
			(r.dispatch = n),
			r
		);
	}
	var tn =
		(n(nn, (Vt = Mn)),
			(nn.prototype.format = function(e, t) {
				return this.context.dateEnv.format(e, t);
			}),
			(nn.prototype.formatRange = function(e, t, n) {
				return this.context.dateEnv.formatRange(e, t, n);
			}),
			(nn.prototype.formatIso = function(e, t) {
				return this.context.dateEnv.formatIso(e, t);
			}),
			(nn.prototype.toDate = function(e) {
				return this.context.dateEnv.toDate(e);
			}),
			(nn.prototype.startOf = function(e, t) {
				return this.context.dateEnv.startOf(e, t);
			}),
			(nn.prototype.add = function(e, t) {
				return this.context.dateEnv.add(e, t);
			}),
			nn);
	function nn() {
		return (null !== Vt && Vt.apply(this, arguments)) || this;
	}
	var rn = function(e, t) {
		var n = e.instances,
			r = [];
		for (var o in n) {
			var i = n[o],
				a = e.defs[i.defId];
			r.push(
				new jt(t, { def: a, instance: i })
			);
		}
		return r;
	},
		on =
			(n(an, ($t = Mn)),
				an);
	function an() {
		return (null !== $t && $t.apply(this, arguments)) || this;
	}
	var sn =
		(n(ln, (Ft = Mn)),
			Object.defineProperty(ln.prototype, "start", {
				get: function() {
					return this.dateProfile
						? this.context.dateEnv.toDate(this.dateProfile.activeRange.start)
						: null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(ln.prototype, "end", {
				get: function() {
					return this.dateProfile
						? this.context.dateEnv.toDate(this.dateProfile.activeRange.end)
						: null;
				},
				enumerable: !1,
				configurable: !0,
			}),
			Object.defineProperty(ln.prototype, "title", {
				get: function() {
					return this.dateProfile
						? this.context.dateEnv.format(
							this.dateProfile.renderRange.start,
							this.dateProfile.renderRange.end,
							this.titleFormat,
							{ isEndExclusive: !0 }
						)
						: "";
				},
				enumerable: !1,
				configurable: !0,
			}),
			ln);
	function ln() {
		return (null !== Ft && Ft.apply(this, arguments)) || this;
	}
	function un(e, t) {
		return {
			id: J(),
			deps: e,
			reducers: t,
			contextInit: [],
		};
	}
	var cn,
		dn,
		pn,
		fn,
		hn = { defs: {}, instances: {} },
		vn =
			(null === (cn = e.FullCalendarVDom) || void 0 === cn ? void 0 : cn.Component) ||
			(function() {
				function e(e) {
					(this.context = e), (this.unrenderFuncs = []);
				}
				return (
					(e.prototype.destroy = function() {
						this.unrender();
					}),
					(e.prototype.unrender = function() {
						for (var e = 0, t = this.unrenderFuncs; e < t.length; e++) {
							(0, t[e])();
						}
						this.unrenderFuncs = [];
					}),
					(e.prototype.on = function(e, t) {
						this.context.emitter.on(e, t);
					}),
					(e.prototype.off = function(e, t) {
						this.context.emitter.off(e, t);
					}),
					(e.prototype.trigger = function(e) {
						for (var t, n, r = [], o = 1; o < arguments.length; o++) r[o - 1] = arguments[o];
						return (
							(n = (t = this.context.emitter).trigger).call.apply(
								n,
								i([t, e], r)
							)
						);
					}),
					e
				);
			})(),
		gn =
			((dn = vn),
				n(mn, dn),
				(mn.prototype.render = function(e) {
					this.props = e;
					var t = this.context,
						n = t.options,
						r = t.pluginHooks,
						o = n.content;
					"function" == typeof o &&
						(o = o(new on(this.context, e)));
					var i = (function(e, t) {
						if (e.classNames) return e.classNames;
						var n = [],
							r = t.viewSpec.classNames;
						"function" == typeof r && (r = r(t.viewApi));
						for (var o = 0, i = r; o < i.length; o++) {
							var a = i[o];
							n.push(a);
						}
						return n;
					})(e, this.context);
					this.el
						? this.el.classList.add.apply(this.el.classList, i)
						: (this.el = (function(e, t, n) {
							var r = document.createElement(t);
							return e && r.classList.add.apply(r.classList, e), n && (r.innerHTML = n), r;
						})(i, e.elTag || "div")),
						(function(e, t) {
							if ("function" == typeof t) e.appendChild(t);
							else if ("string" == typeof t)
								e.innerHTML = t;
							else if (t) {
								var n = t,
									r =
										n instanceof Element
											? [n]
											: Array.isArray(n)
												? n
												: j(n);
								r.forEach(function(t) {
									e.appendChild(t);
								});
							}
						})(this.el, o),
						(function(e, t) {
							for (
								var n = [], r = 0, o = t;
								r < o.length;
								r++
							) {
								var i = o[r](e);
								i && n.push(i);
							}
							return function() {
								for (
									var e = 0, t = n;
									e < t.length;
									e++
								) {
									t[e]();
								}
							};
						})(this.el, r.contentInjectionTransformers);
				}),
				(mn.prototype.destroy = function() {
					dn.prototype.destroy.call(this), this.el && (Et(this.el), (this.el = null));
				}),
				mn);
	function mn() {
		return (null !== dn && dn.apply(this, arguments)) || this;
	}
	var yn,
		En,
		Sn =
			((pn = vn),
				n(Dn, pn),
				(Dn.prototype.render = function(e) {
					this.props = e;
					var t = this.context,
						n = t.options;
					this.el ||
						(this.el = Y(
							"<div class='fc-view " +
							(e.extraClassNames || []).join(" ") +
							"'></div>"
						)),
						(this.el.style.display =
							e.isInDom && e.isVisible ? "" : "none"),
						(this.el.innerHTML =
							"<div class='fc-view-harness " +
							(e.isHarnessShort ? "fc-view-harness-active" : "fc-view-harness-passive") +
							"'></div>");
					var o = this.el.firstChild,
						i = n.content;
					"function" == typeof i &&
						(i = i(new on(this.context, e)));
					var a = (function(e, t, n) {
						var o = new gn(n, { elTag: "div", classNames: e.classNames });
						return o.render(t), o;
					})(e, i, this.context),
						s = a.el;
					o && s && o.appendChild(s), this.handleEl(s);
				}),
				(Dn.prototype.destroy = function() {
					this.content && this.content.destroy(),
						this.handleEl(null),
						pn.prototype.destroy.call(this);
				}),
				(Dn.prototype.handleEl = function(e) {
					this.el &&
						this.el !== e &&
						(Et(this.el),
							this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el)),
						(this.el = e);
				}),
				Dn);
	function Dn() {
		return (null !== pn && pn.apply(this, arguments)) || this;
	}
	var bn,
		Cn =
			((fn = vn),
				n(wn, fn),
				(wn.prototype.render = function(e) {
					(this.props = e), this.renderComponent(e.render, e.extraClassNames);
				}),
				wn);
	function wn(e, t) {
		var n = fn.call(this, t) || this;
		return (
			(n.elRef = e),
			(n.renderComponent = function(e, t) {
				var n =
					"function" == typeof e
						? e(
							r(
								r(
									r(
										r(
											{
												view:
													(o =
														n.context.viewApi),
											},
											o
										),
										{
											hookProps:
												n.props,
											isSticky:
												n.props
													.isSticky,
										}
									),
									{
										allDay:
											n.props
												.allDay,
										date: n
											.props.date,
										dateProfile:
											n.props
												.dateProfile,
										todayRange:
											n.props
												.todayRange,
										showDayNumber:
											n.props
												.showDayNumber,
										dayNumberFormat:
											n.props
												.dayNumberFormat,
										extraRenderProps:
											n.props
												.extraRenderProps,
									}
								),
								{
									getters:
										function() {
											return {};
										},
									setters:
										function(e) {
											var t = e.el;
											n.elRef &&
												n.elRef(
													t
												);
										},
								}
							)
						)
						: e,
					o = n.context,
					i = o.options;
				"string" == typeof n && (n = { html: n });
				var a = n,
					s = a.html,
					l = a.rootElRef,
					u =
						(i.content ||
							function() {
								return Y(s);
							})(new on(o));
				if (
					((n.el = u),
						n.rootElRef && n.rootElRef(n.el),
						t && n.el.classList.add.apply(n.el.classList, t),
						n.elRef)
				)
					if ("function" == typeof n.elRef) n.elRef(n.el);
					else {
						var c = n.elRef.current;
						(c && 1 === c.nodeType) || (n.elRef.current = n.el);
					}
			}),
			n
		);
	}
	var Rn =
		((At = vn),
			n(Tn, At),
			(Tn.prototype.render = function(e) {
				(this.inner = this.renderInner(e)),
					this.inner.el &&
					this.inner.el.classList.add.apply(
						this.inner.el.classList,
						e.elClasses || []
					),
					this.inner.el &&
					e.elAttrs &&
					(function(e, t) {
						for (var n in t) e.setAttribute(n, String(t[n]));
					})(this.inner.el, e.elAttrs);
			}),
			(Tn.prototype.destroy = function() {
				this.inner && this.inner.destroy(), At.prototype.destroy.call(this);
			}),
			(Tn.prototype.renderInner = function(e) { }),
			(Tn.addEqualityFuncs = function(e) {
				this.prototype.equalityFuncs = e;
			}),
			Tn);
	function Tn() {
		return (null !== At && At.apply(this, arguments)) || this;
	}
	var kn = "event-render-hooks",
		Mn =
			(Object.defineProperty(xn.prototype, "calendar", {
				get: function() {
					return this.context.calendarApi;
				},
				enumerable: !1,
				configurable: !0,
			}),
				Object.defineProperty(xn.prototype, "view", {
					get: function() {
						return this.context.viewApi;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(xn.prototype, "options", {
					get: function() {
						return this.context.options;
					},
					enumerable: !1,
					configurable: !0,
				}),
				Object.defineProperty(xn.prototype, "dateEnv", {
					get: function() {
						return this.context.dateEnv;
					},
					enumerable: !1,
					configurable: !0,
				}),
				xn);
	function xn(e) {
		this.context = e;
	}
	var _n = function(e, t, n, o) {
		var i = e.def,
			a = e.instance,
			s = {},
			l =
				i.defId +
				":" +
				(a ? a.instanceId : "");
		return (
			(s.id = i.publicId),
			(s.groupId = i.groupId),
			(s.allDay = i.allDay),
			(s.title = i.title),
			(s.url = i.url),
			(s.start = t.toDate(a.range.start)),
			(s.end = t.toDate(a.range.end)),
			(s.startStr = t.formatIso(a.range.start, {
				omitTime: i.allDay,
			})),
			(s.endStr = t.formatIso(a.range.end, { omitTime: i.allDay })),
			(s.extendedProps =
				(n ? i : r({}, i)).extendedProps),
			(s.display = i.ui.display || "auto"),
			(s.classNames = i.ui.classNames),
			(s.startEditable = i.ui.startEditable),
			(s.durationEditable = i.ui.durationEditable),
			o &&
			((s.backgroundColor = i.ui.backgroundColor),
				(s.borderColor = i.ui.borderColor),
				(s.textColor = i.ui.textColor)),
			s
		);
	},
		In = function(e, t, n) {
			var o,
				i,
				a,
				s,
				l = Pn(t, n),
				c = (function(e, t) {
					var n,
						o = {},
						i = {};
					for (var a in ((n = Fn(e)), t))
						if (a in n)
							if ("string" == typeof n[a]) {
								var s = t[a];
								s && (o[a] = s(n[a]));
							} else
								o[a] = n[a];
					return { refined: o, extra: i };
				})((i = e), Xt).refined,
				d = c.start,
				p = c.end,
				f = c.date,
				h = c.allDay;
			"string" == typeof d && (d = new Date(d)),
				"string" == typeof p && (p = new Date(p)),
				"string" == typeof f && (f = new Date(f));
			var v = null,
				g = null;
			if (null != d) v = d;
			else {
				if (null == f) return null;
				v = f;
			}
			return (
				(g = p),
				{
					def: (o = r(r({}, c), {
						defId: J(),
						sourceId: l ? l.sourceId : "",
						publicId: c.id,
						groupId: c.groupId,
						allDay: h,
						ui: h(l ? l.ui : null, c),
						extendedProps: r(
							r({}, ((s = e), Wn.reduce(function(e, t) {
								return delete e[t], e;
							}, s)
							)),
							c.extendedProps
						),
					})),
					instance:
						(a = a = {
							instanceId: J(),
							defId: o.defId,
							range: { start: v, end: g },
							forcedStartTzo: null,
							forcedEndTzo: null,
						}),
				}
			);
		},
		Pn = function(e, t, n) {
			if ((void 0 === n && (n = ""), "string" == typeof e)) {
				var o,
					i = t.pluginHooks.eventSourceDefs,
					a = i[e];
				if (a)
					return Pn(
						{ type: e, raw: {} },
						t,
						n
					);
				var s = (function(e, t) {
					var n,
						r = Ke(e);
					if (r.protocol)
						for (n in t) {
							var o = t[n];
							if (o.test(r.protocol)) return o;
						}
				})(e, t.pluginHooks.eventSourceParsers);
				return console.warn("No parsers for " + e + ". Going with raw feed."), Pn({ url: e, format: "json" }, t, n);
			}
			var l,
				u = e,
				c = t.options,
				d = t.dateEnv;
			if (u.type) l = u.type;
			else if (u.url)
				l =
					"json" === u.format
						? "json-feed"
						: (o = u.url)
							.match(/\.ics/i)
							? "ics"
							: o.match(/\.json/i)
								? "json"
								: "json-feed";
			else for (var p in t.pluginHooks.eventSourceDefs) if ("function" == typeof u) {
				l = p;
				break;
			}
			var f = t.pluginHooks.eventSourceDefs[l],
				h = f.parseMeta(u);
			return h ? r(r({ sourceId: n + String(++lt) }, h), { publicId: h.id || "", isFetching: !1, latestFetchId: "" }) : null;
		},
		Nn = Object.freeze({
			__proto__: null,
			parseEvents: In,
			parseEventDef: function(e) {
				return In(e).def;
			},
			parseDateSpan: zn,
			parseEventSource: Pn,
			isDateSpansEqual: function(e, t) {
				return e.allDay === t.allDay && e.range.start.valueOf() === t.range.start.valueOf() && e.range.end.valueOf() === t.range.end.valueOf();
			},
		}),
		Hn = {};
	var On = { week: !0 },
		An = /(?:^|[-_])(\w)/g;
	function Un(e, t) {
		var n = e.sourceId,
			o = e.allDay,
			i = e.range,
			a = t.dateEnv,
			s =
				t.options.eventDisplay ||
				"auto",
			l =
				t.options.displayEventEnd;
		return (
			null != l && !1 === l && (l = null),
			"auto" === s
				? o || de(fe(i.end, i.start)) < 864e5
					? "block"
					: "list-item"
				: "list-item" === s
					? "list-item"
					: "block"
		);
	}
	function Ln(e, t) {
		var n =
			e.startEditable,
			r =
				e.durationEditable;
		return (
			null == n &&
			(n = t.startEditable),
			null == r &&
			(r = t.durationEditable),
			{
				start: n,
				duration: r,
			}
		);
	}
	function Bn(e) {
		return null != e ? e : !0;
	}
	function Vn(e, t) {
		return Array.isArray(e) ? Hn[re(e)] || (Hn[re(e)] = zn(e, t)) : zn(e, t);
	}
	function Fn(e) {
		var t,
			n,
			o = {},
			i = {};
		for (var a in e)
			(t = e[a]),
				(n = a),
				Yt[n]
					? (o[n] = t)
					: Zt[n]
						? (i[n] = t)
						: n in Kt || (o.extendedProps = r(r({}, o.extendedProps || {}), { [n]: t }));
		return o.startEditable, o.durationEditable, o.constraints, o.overlap, o.allows, o.backgroundColor, o.borderColor, o.textColor, o.classNames, { def: o, ui: i };
	}
	function zn(e, t) {
		var n = t.createMarker(e.start),
			r = t.createMarker(e.end);
		if (n && r) return { start: n, end: r };
	}
	var Gn =
		"undefined" != typeof FullCalendarVDom
			? FullCalendarVDom
			: ((En = e),
				(Wt = {}),
			{
				Component: vn,
				createElement: En.createElement,
				render: function(e, t) {
					var n,
						r = new gn(Wt, { elTag: "div" });
					r.render(e),
						(n = r.el),
						t.appendChild(n),
						Ot();
				},
				Fragment: En.Fragment,
			});
	(e.Calendar = (function() {
		function e(e, t) {
			(this.el = e), (this.component = new Sn(this, { extraClassNames: ["fc"] }));
		}
		return (
			(e.prototype.render = function() {
				this.component.render({
					optionOverrides: {},
					calendarApi: {},
					isHeightAuto: !1,
					forPrint: !1,
				});
			}),
			(e.prototype.destroy = function() {
				this.component.destroy();
			}),
			(e.prototype.batchRendering = function(e) { }),
			(e.prototype.updateSize = function() { }),
			e
		);
	})()),
		(e.Component = vn),
		(e.DateEnv = void 0),
		(e.DateProfileGenerator = void 0),
		(e.DayCellContent = Cn),
		(e.DayCellRoot = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					return Gn.createElement(
						Cn,
						r({ context: t }, e)
					);
				}
			);
		}),
		(e.DayHeader = function(e) {
			var t = e.date,
				n = e.dateProfile,
				o = e.todayRange,
				i = e.colSpec,
				a = e.dayHeaderFormat,
				s =
					void 0 === a
						? {
							weekday: "short",
							month: "numeric",
							day: "numeric",
							omitCommas: !0,
						}
						: a;
			return Gn.createElement(
				on.Consumer,
				null,
				function(e) {
					return Gn.createElement(
						Cn,
						{
							context: e,
							date: t,
							dateProfile: n,
							todayRange: o,
							colSpec: i,
							elTag: "th",
						},
						function(e, n, o, i) {
							return Gn.createElement(
								"a",
								r({ "data-navlink": "", className: "fc-col-header-cell-cushion" }, i),
								e.format(t, s)
							);
						}
					);
				}
			);
		}),
		(e.DaySeriesModel = void 0),
		(e.DayTable = void 0),
		(e.DayTableModel = void 0),
		(e.ElementDragging = void 0),
		(e.ElementScrollController = void 0),
		(e.EventApi = jt),
		(e.EventRoot = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					var n = e.event,
						o = e.seg,
						i = Un(n, t),
						a = {
							hookProps: e,
							event: new jt(t, n.def, n.instance),
							isDragging: e.isDragging,
							isResizing: e.isResizing,
							isDateSelecting: e.isDateSelecting,
							isSelected: e.isSelected,
							isPast: e.isPast,
							isFuture: e.isFuture,
							isToday: e.isToday,
						};
					return Gn.createElement(
						Cn,
						{
							context: t,
							elTag: e.elTag,
							elClasses: [
								"fc-event",
								"fc-event-" + n.display,
								o.isStart ? "fc-event-start" : "",
								o.isEnd ? "fc-event-end" : "",
								o.isPast ? "fc-event-past" : "",
								o.isFuture ? "fc-event-future" : "",
								o.isToday ? "fc-event-today" : "",
								o.isSelected ? "fc-event-selected" : "",
								o.isDragging ? "fc-event-dragging" : "",
								o.isResizing ? "fc-event-resizing" : "",
							],
							elStyle: e.elStyle,
							render:
								t.options.eventContent ||
								function(e) {
									return Gn.createElement(
										"div",
										{ className: "fc-event-main" },
										e.timeText &&
										Gn.createElement(
											"div",
											{ className: "fc-event-time" },
											e.timeText
										),
										Gn.createElement(
											"div",
											{ className: "fc-event-title-container" },
											Gn.createElement(
												"div",
												{ className: "fc-event-title" },
												e.event.title || Gn.createElement(Gn.Fragment, null, " ")
											)
										)
									);
								},
						},
						a
					);
				}
			);
		}),
		(e.EventSourceApi = zt),
		(e.FeaturefulElementDragging = void 0),
		(e.Fragment = Gn.Fragment),
		(e.Interaction = void 0),
		(e.MoreLinkRoot = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					return Gn.createElement(
						Cn,
						{ context: t },
						e.children(
							e.allDayDate,
							e.allSegs,
							e.hiddenSegs
						)
					);
				}
			);
		}),
		(e.NowIndicatorRoot = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					return Gn.createElement(
						Cn,
						{ context: t },
						e.children(t, e.date, e.dateProfile)
					);
				}
			);
		}),
		(e.PointerDragging = void 0),
		(e.Popout = gn),
		(e.RecurringType = void 0),
		(e.ScrollResponder = void 0),
		(e.Scroller = void 0),
		(e.SimpleScrollGrid = void 0),
		(e.Slicer = void 0),
		(e.Splitter = void 0),
		(e.StandardEvent = void 0),
		(e.Table = void 0),
		(e.TableDateCell = function(e) {
			var t = e.date,
				n = e.dateProfile,
				o = e.todayRange,
				i = e.colSpec;
			return Gn.createElement(
				on.Consumer,
				null,
				function(e) {
					return Gn.createElement(Cn, {
						context: e,
						date: t,
						dateProfile: n,
						todayRange: o,
						colSpec: i,
						elTag: "td",
					});
				}
			);
		}),
		(e.TableDayCell = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					return Gn.createElement(
						Cn,
						{ context: t },
						e
					);
				}
			);
		}),
		(e.TableRow = void 0),
		(e.Theme = on),
		(e.ViewContextType = on.Provider),
		(e.ViewRoot = Sn),
		(e.WeekNumberRoot = function(e) {
			return Gn.createElement(
				on.Consumer,
				null,
				function(t) {
					return Gn.createElement(
						Cn,
						{ context: t },
						e
					);
				}
			);
		}),
		(e.addDays = ke),
		(e.addDurations = pe),
		(e.addMonths = Me),
		(e.addWeeks = function(e, t) {
			return ke(e, 7 * t);
		}),
		(e.addYears = function(e, t) {
			return xe(e, t, 1);
		}),
		(e.buildClassNameNormalizer = void 0),
		(e.buildDayRanges = void 0),
		(e.buildEventApis = rn),
		(e.buildEventRangeKey = void 0),
		(e.buildEventUrl = void 0),
		(e.buildNavLinkAttrs = void 0),
		(e.buildSegCompare = void 0),
		(e.buildSegTimeText = void 0),
		(e.buildSlatMetas = void 0),
		(e.buildTimeGridDayMatchKey = void 0),
		(e.buildTimeText = void 0),
		(e.buildViewContext = void 0),
		(e.buildViewSpecs = void 0),
		(e.capitaliseFirstLetter = x),
		(e.combineEventUis = void 0),
		(e.compareByFieldSpec = void 0),
		(e.compareByFieldSpecs = void 0),
		(e.compareNumbers = void 0),
		(e.compareObjs = g),
		(e.compileEventUis = void 0),
		(e.computeEarliestSegStart = void 0),
		(e.computeEventDraggable = Ln),
		(e.computeEventEndResizable = function(e, t) {
			return e.durationEditable;
		}),
		(e.computeEventStartResizable = function(e, t) {
			return e.durationEditable;
		}),
		(e.config = {}),
		(e.constrainPoint = void 0),
		(e.createAriaClickAttrs = void 0),
		(e.createContext = function(e) {
			return new on.Provider(e);
		}),
		(e.createDuration = le),
		(e.createElement = Gn.createElement),
		(e.createEmptyEventStore = function() {
			return { defs: {}, instances: {} };
		}),
		(e.createEventInstance = function(e, t, n) {
			return {
				instanceId: J(),
				defId: e,
				range: t,
				forcedStartTzo: null != n ? n.forcedStartTzo : null,
				forcedEndTzo: null != n ? n.forcedEndTzo : null,
			};
		}),
		(e.createEventUi = wt),
		(e.createFormatter = function(e) {
			return new an(e);
		}),
		(e.createPlugin = un),
		(e.createRef = function() {
			return { current: null };
		}),
		(e.diffDates = Ue),
		(e.diffDayAndTime = void 0),
		(e.diffDays = Oe),
		(e.diffPoints = void 0),
		(e.diffWeeks = function(e, t) {
			return Oe(e, t) / 7;
		}),
		(e.diffYears = function(e, t) {
			return Ae(e, t) / 365;
		}),
		(e.disableCursor = $),
		(e.enableCursor = Q),
		(e.eventTupleToStore = function(e, t, n) {
			return {
				defs: { [e.def.defId]: e.def },
				instances: { [e.instance.instanceId]: e.instance },
			};
		}),
		(e.filterEventStoreDefs = void 0),
		(e.filterHash = C),
		(e.findDirectChildren = void 0),
		(e.formatDate = function(e, t) {
			void 0 === t && (t = {});
			var n = new tn(t);
			return n.format(e, t);
		}),
		(e.formatDayString = function(e) {
			return (
				I(e.getUTCFullYear()) +
				"-" +
				I(e.getUTCMonth() + 1) +
				"-" +
				I(e.getUTCDate())
			);
		}),
		(e.formatIsoDay = function(e) {
			return (
				e.getUTCFullYear() +
				"-" +
				I(e.getUTCMonth() + 1) +
				"-" +
				I(e.getUTCDate())
			);
		}),
		(e.formatIsoTimeString = function(e) {
			return I(e.getUTCHours()) + ":" + I(e.getUTCMinutes()) + ":" + I(e.getUTCSeconds());
		}),
		(e.formatShortTime = void 0),
		(e.formatTimeZoneOffset = function(e) {
			var t = e / 60,
				n = Math.abs(t),
				r = Math.floor(n),
				o = Math.round(60 * (n - r));
			return (t < 0 ? "-" : "+") + I(r) + ":" + I(o);
		}),
		(e.getAllowYarnV2 = it),
		(e.getCanVGrowWithinCell = void 0),
		(e.getClippingParents = void 0),
		(e.getDateMeta = void 0),
		(e.getDayClassNames = void 0),
		(e.getDefaultEventEnd = void 0),
		(e.getElSeg = void 0),
		(e.getEventClassNames = Un),
		(e.getEventDef = function(e, t) {
			var n = t.getCurrentData().eventStore;
			for (var r in n.defs) {
				var o = n.defs[r];
				if (o.publicId === e) return o;
			}
			return null;
		}),
		(e.getEventTargetRelatedTo = void 0),
		(e.getEventUis = function(e, t, n) {
			var o = n.getCurrentData(),
				i = o.eventUiBases,
				a = o.eventStore;
			return [h(i[""], i[e]), h(i[""], i[t.sourceId]), i[t.defId]];
		}),
		(e.getIsRtl = function(e) {
			return "rtl" === e.direction;
		}),
		(e.getRectCenter = void 0),
		(e.getRelevantEvents = function(e, t) {
			var n = e.instances[t];
			return n ? { [t]: n } : {};
		}),
		(e.getScrollGridClass = void 0),
		(e.getScrollbarWidths = void 0),
		(e.getSegAnchorAttrs = void 0),
		(e.getSegMeta = function(e, t, n) {
			var r = t.getCurrentData().dateProfile,
				o = e.eventRange.range,
				i =
					o.start < r.activeRange.start
						? r.activeRange.start
						: o.start,
				a =
					o.end > r.activeRange.end
						? r.activeRange.end
						: o.end,
				s = i.valueOf() < a.valueOf();
			return (
				e.eventRange.def.allDay && s && (s = Le(i).valueOf() < Le(a).valueOf()),
				{
					isStart: e.isStart && s,
					isEnd: e.isEnd && s,
					isPast: i < t.getCurrentData().now,
					isFuture: a > t.getCurrentData().now,
					isToday:
						r.currentRange.start <= i &&
						r.currentRange.end > i,
				}
			);
		}),
		(e.getStickyFooterScrollbar = void 0),
		(e.getStickyHeaderDates = function(e) {
			var t = e.options;
			if (t.stickyHeaderDates)
				return (
					"auto" === t.stickyHeaderDates
						? ht
						: t.stickyHeaderDates
				);
		}),
		(e.getWeeksFromInput = U),
		(e.globalPlugins = []),
		(e.greatestDurationDenominator = ve),
		(e.hasShrinkWidth = vt),
		(e.interactionSettingsToStore = void 0),
		(e.intersectRanges = void 0),
		(e.intersectSpans = void 0),
		(e.isArraysEqual = g),
		(e.isDateSpansEqual = void 0),
		(e.isInteractionValid = function(e, t) {
			return (
				(n = e),
				(o = t),
				!(!n.allDay && !o.allDay && Re(n.range.start, o.range.start) && Re(n.range.end, o.range.end))
			);
			var n, o;
		}),
		(e.isPropsEqual = function(e, t, n, o) {
			return (
				!o &&
				(function(e, t) {
					if (e === t) return !0;
					for (var n in e) if (d(e, n) && !(n in t)) return !1;
					for (var n in t) if (d(t, n) && e[n] !== t[n]) return !1;
					return !0;
				})(e, t)
			);
		}),
		(e.isPropsValid = void 0),
		(e.isValuesSimilar = y),
		(e.listenBySelector = function(e, t, n, o, i) {
			function a(e, n) {
				for (var i = e.target, a = []; i && i !== s;) {
					var u = i.parentNode;
					if (Je(i, t)) {
						for (i.fcSeg = n.seg, r.push(i), o.call(l, i, n, u); i !== s;) i = i.parentNode;
						break;
					}
					a.push(i), (i = u);
				}
			}
			var s = e,
				l = {
					el: s,
					listener: function(e) {
						n.call(l, e);
					},
				};
			return et(s, "click", l), function() {
				tt(s, "click", l);
			};
		}),
		(e.mapHash = D),
		(e.memoize = void 0),
		(e.memoizeArraylike = void 0),
		(e.memoizeHashlike = void 0),
		(e.mergeEventStores = function(e, t) {
			return {
				defs: h(e.defs, t.defs),
				instances: h(e.instances, t.instances),
			};
		}),
		(e.multiplyDuration = he),
		(e.parseBusinessHours = void 0),
		(e.parseClassNames = A),
		(e.parseDragMeta = void 0),
		(e.parseEventDef = void 0),
		(e.parseFieldSpecs = Fn),
		(e.parseMarker = void 0),
		(e.pointInsideRect = void 0),
		(e.preventContextMenu = ee),
		(e.preventDefault = ee),
		(e.removeElement = Et),
		(e.removeExact = W),
		(e.render = Gn.render),
		(e.setElAttrs = void 0),
		(e.setElClasses = void 0),
		(e.setElStyle = void 0),
		(e.setRef = void 0),
		(e.sliceEventStore = void 0),
		(e.sliceEvents = void 0),
		(e.sortEventSegs = void 0),
		(e.startOfDay = Le),
		(e.startOfHour = void 0),
		(e.startOfMinute = void 0),
		(e.startOfSecond = void 0),
		(e.subtractDurations = fe),
		(e.svgDesc = void 0),
		(e.svgRect = void 0),
		(e.translateRect = void 0),
		(e.unpromisify = void 0),
		(e.version = s),
		(e.whenTransitionDone = void 0),
		(e.wholeDivideDurations = function(e, t) {
			for (
				var n = null, r = 0;
				r < Ge.length;
				r++
			) {
				var o = Ge[r];
				if (t[o]) {
					var i = e[o] / t[o];
					if (!yn(i) || (null !== n && n !== i)) return null;
					n = i;
				} else if (e[o]) return null;
			}
			return n;
		});
})(this.FullCalendar || (this.FullCalendar = {}));