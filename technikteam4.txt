
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\KeyboardHandler.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, runtime */
/*jslint bitwise: true*/

/**
 * @constructor
 * @return {?}
 */
gui.KeyboardHandler = function KeyboardHandler() {
    "use strict";
    var modifier = gui.KeyboardHandler.Modifier,
        /**@type{?function(!KeyboardEvent):boolean}*/
        defaultBinding = null,
        /**@type{!Object.<string,function():boolean>}*/
        bindings = {};

    /**
     * @param {!KeyboardEvent} e
     * @return {!number}
     */
    function getModifiers(e) {
        var modifiers = modifier.None;
        if (e.metaKey) { modifiers |= modifier.Meta; }
        if (e.ctrlKey) { modifiers |= modifier.Ctrl; }
        if (e.altKey) { modifiers |= modifier.Alt; }
        if (e.shiftKey) { modifiers |= modifier.Shift; }
        return modifiers;
    }

    /**
     * @param {!number}     keyCode
     * @param {!number}     modifiers
     * @return {!string}
     */
    function getKeyCombo(keyCode, modifiers) {
        if (!modifiers) {
            modifiers = modifier.None;
        }
        // When a modifier key is pressed on it's own, different browsers + platforms
        // may report the state of the corresponding modifier flag as trailing the event.
        // For example, pressing the ctrl key in FF on Linux will report (ctrlKey:false)
        // in the keydown event, while Chrome on Linux will report (ctrlKey:true) in the
        // keydown event.
        //
        // Easiest way to cope with this is to manually normalize these events.
        switch (keyCode) {
            case gui.KeyboardHandler.KeyCode.LeftMeta:
            case gui.KeyboardHandler.KeyCode.RightMeta:
            case gui.KeyboardHandler.KeyCode.MetaInMozilla:
                modifiers |= modifier.Meta;
                break;
            case gui.KeyboardHandler.KeyCode.Ctrl:
                modifiers |= modifier.Ctrl;
                break;
            case gui.KeyboardHandler.KeyCode.Alt:
                modifiers |= modifier.Alt;
                break;
            case gui.KeyboardHandler.KeyCode.Shift:
                modifiers |= modifier.Shift;
                break;
        }

        return keyCode + ':' + modifiers;
    }

    /**
     * @param {?Function}   callback
     */
    this.setDefault = function (callback) {
        defaultBinding = callback;
    };

    /**
     * Bind to the specified keycode + modifiers. To bind directly to one of the modifiers, simply
     * pass in the modifier as the keyCode (e.g., Keycode.Ctrl), and set the modifiers to Modifier.None.
     * This class will take care of binding to the appropriate modifiers to ensure the keybinding works as
     * expected.
     *
     * @param {!number}     keyCode
     * @param {!number}     modifiers
     * @param {!Function}   callback
     * @param {boolean=}   overwrite    Set to true to force a binding to be overwritten
     */
    this.bind = function (keyCode, modifiers, callback, overwrite) {
        var keyCombo = getKeyCombo(keyCode, modifiers);
        runtime.assert(overwrite || bindings.hasOwnProperty(keyCombo) === false,
            "tried to overwrite the callback handler of key combo: " + keyCombo);
        bindings[keyCombo] = callback;
    };

    /**
     * @param {!number}     keyCode
     * @param {!number}    modifiers
     */
    this.unbind = function (keyCode, modifiers) {
        var keyCombo = getKeyCombo(keyCode, modifiers);
        delete bindings[keyCombo];
    };

    /*
     * removes all the bindings includes the default binding
     */
    this.reset = function () {
        defaultBinding = null;
        bindings = {};
    };

    /**
     * @param {!KeyboardEvent} e
     */
    this.handleEvent = function (e) {
        var keyCombo = getKeyCombo(e.keyCode, getModifiers(e)),
            /**@type{function():boolean|undefined}*/
            callback = bindings[keyCombo],
            handled = false;

        if (callback) {
            handled = callback();
        } else if (defaultBinding !== null) {
            handled = defaultBinding(e);
        }

        if (handled) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            }
        }
    };
};

/**@const*/
gui.KeyboardHandler.Modifier = {
    None: 0,
    Meta: 1,
    Ctrl: 2,
    Alt: 4,
    CtrlAlt: 6,
    Shift: 8,
    MetaShift: 9,
    CtrlShift: 10,
    AltShift: 12
};

/**@const*/
gui.KeyboardHandler.KeyCode = {
    Backspace: 8,
    Tab: 9,
    Clear: 12,
    Enter: 13,
    Shift: 16,
    Ctrl: 17,
    Alt: 18,
    End: 35,
    Home: 36,
    Left: 37,
    Up: 38,
    Right: 39,
    Down: 40,
    Delete: 46,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    LeftMeta: 91,
    RightMeta: 93,
    MetaInMozilla: 224
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\LineBoundaryScanner.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui*/

/**
 * Finds line-wrap points by comparing the visual overlap between visible rectangles.
 *
 * @constructor
 * @implements {gui.VisualStepScanner}
 */
gui.LineBoundaryScanner = function () {
    "use strict";
    var self = this,
        lineRect = null,
        // Minimum amount of overlap between two rectangles to be considered on the same line is arbitrarily 40%
        /**@const*/ MIN_OVERLAP_THRESHOLD = 0.4;

    /**
     * Return the fraction of overlap between two rectangles. If there is
     * no overlap, or either of the rectangles is 0 height, this will
     * return 0.
     *
     * @param {!core.SimpleClientRect} rect1
     * @param {!core.SimpleClientRect} rect2
     * @return {!number}
     */
    function verticalOverlapPercent(rect1, rect2) {
        var rect1Height = rect1.bottom - rect1.top,
            rect2Height = rect2.bottom - rect2.top,
            minRectHeight = Math.min(rect1Height, rect2Height),
            intersectTop = Math.max(rect1.top, rect2.top),
            intersectBottom = Math.min(rect1.bottom, rect2.bottom),
            overlapHeight = intersectBottom - intersectTop;

        return minRectHeight > 0 ? (overlapHeight / minRectHeight) : 0;
    }

    /**
     * Returns true if the amount of overlap between the known line rectangle and the visible next rectangle
     * is below the specified MIN_OVERLAP_THRESHOLD. If there is no known line rectangle, this will return false.
     *
     * @param {!core.SimpleClientRect} nextRect Client rect of next step (by direction)
     * @return {!boolean}
     */
    function isLineBoundary(nextRect) {
        if (lineRect) {
            // TODO this logic will fail if the caret is between a subscript & superscript char as the overlap will be 0
            return verticalOverlapPercent(/**@type{!core.SimpleClientRect}*/(lineRect), nextRect) <= MIN_OVERLAP_THRESHOLD;
        }
        return false;
    }

    /**
     * @param {!core.SimpleClientRect} rect1
     * @param {!core.SimpleClientRect} rect2
     * @return {!core.SimpleClientRect}
     */
    function combineRects(rect1, rect2) {
        return {
            left: Math.min(rect1.left, rect2.left),
            right: Math.max(rect1.right, rect2.right),
            top: Math.min(rect1.top, rect2.top),
            bottom: Math.min(rect1.bottom, rect2.bottom)
        };
    }

    /**
     * @param {?core.SimpleClientRect} originalRect
     * @param {?core.SimpleClientRect} newRect
     * @return {?core.SimpleClientRect}
     */
    function growRect(originalRect, newRect) {
        if (originalRect && newRect) {
            return combineRects(/**@type{!core.SimpleClientRect}*/(originalRect),
                                /**@type{!core.SimpleClientRect}*/(newRect));
        }
        return originalRect || newRect;
    }

    this.token = undefined;

    /**
     * @param {!gui.StepInfo} stepInfo
     * @param {?ClientRect} previousRect
     * @param {?ClientRect} nextRect
     * @return {!boolean}
     */
    this.process = function(stepInfo, previousRect, nextRect) {
        // Can only detect line boundaries when the next rectangle is visible. An invisible next-rect
        // indicates the next step does not have any visible content attached, so it's location on screen
        // is impossible to determine accurately.
        var isOverLineBoundary = nextRect && isLineBoundary(/**@type{!core.SimpleClientRect}*/(nextRect));

        if (previousRect && (!nextRect || isOverLineBoundary)) {
            // Detect a possible line wrap point in one of two ways:
            // 1. Going from a visible to an invisible rectangle. An invisible rectangle can indicate a collapsed
            //      whitespace text node, or an invisible element that the browser may choose to wrap at.
            // 2. A confirmed wrap point where the nextRect is visible and clearly not on the same line as the previous.
            self.token = stepInfo.token;
        }

        if (isOverLineBoundary) {
            return true;
        }

        // Grow the current line rectangle by the (now approved) previous rectangle. This allows the line height
        // to grow naturally.
        lineRect = growRect(lineRect, previousRect);
        return false;
    };
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\MetadataController.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, runtime, core, ops, odf*/

/**
 * @constructor
 * @implements {core.Destroyable}
 * @param {!ops.Session} session
 * @param {!string} inputMemberId
 */
gui.MetadataController = function MetadataController(session, inputMemberId) {
    "use strict";

    var odtDocument = session.getOdtDocument(),
        eventNotifier = new core.EventNotifier([gui.MetadataController.signalMetadataChanged]),
        /** @const @type {!Array.<!string>} */
        readonlyProperties = [
            "dc:creator",
            "dc:date",
            "meta:editing-cycles",
            "meta:editing-duration",
            "meta:document-statistic"
        ];

    /**
     * @param {!Object} changes
     * @return {undefined}
     */
    function onMetadataUpdated(changes) {
        eventNotifier.emit(gui.MetadataController.signalMetadataChanged, changes);
    }

    /**
     * @param {!string} property
     * @return {!boolean}
     */
    function isWriteableMetadata(property) {
        var isWriteable = (readonlyProperties.indexOf(property) === -1);
        if (! isWriteable) {
            runtime.log("Setting " + property + " is restricted.");
        }
        return isWriteable;
    }

    /**
     * Sets the metadata fields from the given properties map.
     * Avoid setting certain fields since they are automatically set:
     *     dc:creator
     *     dc:date
     *     meta:editing-cycles
     * If you do wish to externally set these fields, try getting
     * the master session to inject operations into the timeline
     * with the relevant properties.
     *
     * The following properties are never used and will be removed for semantic
     * consistency from the document:
     *     meta:editing-duration
     *     meta:document-statistic
     *
     * Setting any of the above mentioned fields using this method will have no effect.
     *
     * @param {?Object.<!string, !string>} setProperties A flat object that is a string->string map of field name -> value.
     * @param {?Array.<!string>|undefined=} removedProperties An array of metadata field names (prefixed).
     * @return {undefined}
     */
    this.setMetadata = function (setProperties, removedProperties) {
        var /** @type {!Object.<!string,!string>} */
            filteredSetProperties = {},
            /** @type {!string} */
            filteredRemovedProperties = "",
            op;

        if (setProperties) {
            Object.keys(setProperties).filter(isWriteableMetadata).forEach(function (property) {
                filteredSetProperties[property] = setProperties[property];
            });
        }
        if (removedProperties) {
            filteredRemovedProperties = removedProperties.filter(isWriteableMetadata).join(",");
        }

        if (filteredRemovedProperties.length > 0
                || Object.keys(filteredSetProperties).length > 0) {
            op = new ops.OpUpdateMetadata();
            op.init({
                memberid: inputMemberId,
                setProperties: filteredSetProperties,
                removedProperties: filteredRemovedProperties.length > 0 ? { attributes: filteredRemovedProperties } : null
            });
            session.enqueue([op]);
        }
    };

    /**
     * Returns the value of the requested document metadata field
     * @param {!string} property A namespace-prefixed field name, for example
     * dc:creator
     * @return {?string}
     */
    this.getMetadata = function (property) {
        var namespaceUri, parts;

        runtime.assert(typeof property === "string", "Property must be a string");
        parts = property.split(':');
        runtime.assert(parts.length === 2, "Property must be a namespace-prefixed string");
        namespaceUri = odf.Namespaces.lookupNamespaceURI(parts[0]);
        // TODO: support other namespaces
        runtime.assert(Boolean(namespaceUri), "Prefix must be for an ODF namespace.");
        return odtDocument.getOdfCanvas().odfContainer().getMetadata(/**@type{!string}*/(namespaceUri), parts[1]);
    };

    /**
     * @param {!string} eventid
     * @param {!Function} cb
     * @return {undefined}
     */
    this.subscribe = function (eventid, cb) {
        eventNotifier.subscribe(eventid, cb);
    };

    /**
     * @param {!string} eventid
     * @param {!Function} cb
     * @return {undefined}
     */
    this.unsubscribe = function (eventid, cb) {
        eventNotifier.unsubscribe(eventid, cb);
    };

    /**
     * @param {!function(!Error=):undefined} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function(callback) {
        odtDocument.unsubscribe(ops.OdtDocument.signalMetadataUpdated, onMetadataUpdated);
        callback();
    };

    function init() {
        odtDocument.subscribe(ops.OdtDocument.signalMetadataUpdated, onMetadataUpdated);
    }

    init();
};

/**@const*/gui.MetadataController.signalMetadataChanged = "metadata/changed";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\MimeDataExporter.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, runtime, odf*/

/**
 * MimeDataExporter exports a passed range as several types
 * into the passed DataTransfer object
 * @constructor
 */
gui.MimeDataExporter = function MimeDataExporter() {
    "use strict";

    var /**@type{!odf.TextSerializer}*/
        textSerializer;

    /**
     * Copy the contents of the supplied range into the passed dataTransfer.
     * @param {!DataTransfer} dataTransfer
     * @param {!Range} range Selection range to copy into the clipboard
     * @return {undefined}
     */
    this.exportRangeToDataTransfer = function (dataTransfer, range) {
        var document = range.startContainer.ownerDocument,
            serializedFragment,
            fragmentContainer;

        // the document fragment needs to be wrapped in a span as
        // text nodes cannot be inserted at the top level of the DOM
        fragmentContainer = document.createElement('span');
        fragmentContainer.appendChild(range.cloneContents());
        serializedFragment = textSerializer.writeToString(fragmentContainer);
        try {
            dataTransfer.setData('text/plain', serializedFragment);
        } catch(e) {
            // Internet Explorer only supports the 'Text' key being set
            // See http://msdn.microsoft.com/en-us/library/ie/ms536744%28v=vs.85%29.aspx
            // Could do some browser sniffing potentially, but this is less error prone as it
            // doesn't rely on the agent string being correct.
            dataTransfer.setData('Text', serializedFragment);
        }
    };

    function init() {
        textSerializer = new odf.TextSerializer();
        textSerializer.filter = new odf.OdfNodeFilter();
    }

    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\OdfFieldView.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, odf*/

/**
 * Show ODF fields in an ODT document.
 *
 * @constructor
 * @implements {core.Destroyable}
 * @param {!odf.OdfCanvas} odfCanvas
 */
gui.OdfFieldView = function(odfCanvas) {
    "use strict";
    var /**@type{!HTMLStyleElement}*/
        style,
        document = odfCanvas.getElement().ownerDocument;

    /**
     * @return {!HTMLStyleElement}
     */
    function newStyleSheet() {
        var head = document.getElementsByTagName('head').item(0),
            sheet = /**@type{!HTMLStyleElement}*/(document.createElement('style')),
            /**@type{!string}*/
            text = "";

        sheet.type = 'text/css';
        sheet.media = 'screen, print, handheld, projection';
        odf.Namespaces.forEachPrefix(function(prefix, ns) {
            text += "@namespace " + prefix + " url(" + ns + ");\n";
        });
        sheet.appendChild(document.createTextNode(text));
        head.appendChild(sheet);
        return sheet;
    }

    /**
     * @param {!HTMLStyleElement} style
     * @return {undefined}
     */
    function clearCSSStyleSheet(style) {
        var stylesheet = /**@type{!CSSStyleSheet}*/(style.sheet),
            cssRules = stylesheet.cssRules;

        while (cssRules.length) {
            stylesheet.deleteRule(cssRules.length - 1);
        }
    }

    /**
     * @param {!Array.<!string>} selectors
     * @param {!string} css
     * @return {!string}
     */
    function createRule(selectors, css) {
        return selectors.join(",\n") + "\n" + css + "\n";
    }

    /**
     * Applies a grey background to all ODF field containers as defined in the container definitions within
     * this class.
     *
     * @return {!string}
     */
    function generateFieldCSS() {
        var /**@type{!Array.<!string>}*/
            cssSelectors = odf.OdfSchema.getFields().map(function(prefixedName) { return prefixedName.replace(":", "|"); }),
            highlightFields = createRule(cssSelectors, "{ background-color: #D0D0D0; }"),
            emptyCssSelectors = cssSelectors.map(function(selector) { return selector + ":empty::after"; }),
            // Ensure fields are always visible even if they contain no content
            highlightEmptyFields = createRule(emptyCssSelectors, "{ content:' '; white-space: pre; }");

        return highlightFields + "\n" + highlightEmptyFields;
    }

    /**
     * @return {undefined}
     */
    this.showFieldHighlight = function() {
        style.appendChild(document.createTextNode(generateFieldCSS()));
    };

    /**
     * @return {undefined}
     */
    this.hideFieldHighlight = function() {
        clearCSSStyleSheet(style);
    };

    /**
     * Destroy the object.
     * Do not access any member of this object after this call.
     * @param {function(!Error=):undefined} callback
     * @return {undefined}
     */
    this.destroy = function(callback) {
        if (style.parentNode) {
            style.parentNode.removeChild(style);
        }
        callback();
    };

    function init() {
        style = newStyleSheet();
    }
    init();
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\OdfTextBodyNodeFilter.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, NodeFilter, odf, Node*/

/**
 * Exclude nodes that do not make up part of the ODF's text body. This includes:
 * - Any text node that is not within a text grouping element
 * - Any node within a text:tracked-changes block
 *
 * @constructor
 * @implements NodeFilter
 */
gui.OdfTextBodyNodeFilter = function () {
    "use strict";
    var odfUtils = odf.OdfUtils,
        TEXT_NODE = Node.TEXT_NODE,
        FILTER_REJECT = NodeFilter.FILTER_REJECT,
        FILTER_ACCEPT = NodeFilter.FILTER_ACCEPT,
        textns = odf.Namespaces.textns;

    /**
     * @param {!Node} node
     * @return {!number}
     */
    this.acceptNode = function (node) {
        if (node.nodeType === TEXT_NODE) {
            if (!odfUtils.isGroupingElement(node.parentNode)) {
                return FILTER_REJECT;
            }
        } else if (node.namespaceURI === textns && node.localName === "tracked-changes") {
            return FILTER_REJECT;
        }
        return FILTER_ACCEPT;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\ParagraphBoundaryScanner.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, odf*/

/**
 * Allows only steps within the same paragraph as the first step the scanner is asked to process.
 * Will terminate upon encountering a step within a different paragraph, and return the most recent
 * step that was still within the target paragraph.
 *
 * @constructor
 */
gui.ParagraphBoundaryScanner = function () {
    "use strict";
    var self = this,
        isInitialised = false,
        /**@type{?Element}*/
        lastParagraph,
        odfUtils = odf.OdfUtils;

    this.token = undefined;

    /**
     * @param {!gui.StepInfo} stepInfo
     * @return {!boolean}
     */
    this.process = function(stepInfo) {
        var currentParagraph = odfUtils.getParagraphElement(stepInfo.container());
        if (!isInitialised) {
            lastParagraph = currentParagraph;
            isInitialised = true;
        }

        if (lastParagraph !== currentParagraph) {
            return true;
        }

        self.token = stepInfo.token;
        return false;
    };
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\PasteController.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, gui, ops, odf, core*/

/**
 * Provides a method to paste text at the current cursor
 * position, and processes the input string to understand
 * special structuring such as paragraph splits.
 * @implements {core.Destroyable}
 * @param {!ops.Session} session
 * @param {!gui.SessionConstraints} sessionConstraints
 * @param {!gui.SessionContext} sessionContext
 * @param {!string} inputMemberId
 * @constructor
 */
gui.PasteController = function PasteController(session, sessionConstraints, sessionContext, inputMemberId) {
    "use strict";

    var odtDocument = session.getOdtDocument(),
        isEnabled = false,
        /**@const*/
        textns = odf.Namespaces.textns,
        /**@const*/
        NEXT = core.StepDirection.NEXT,
        odfUtils = odf.OdfUtils;

    /**
     * @return {undefined}
     */
    function updateEnabledState() {
        if (sessionConstraints.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) === true) {
            isEnabled = /**@type{!boolean}*/(sessionContext.isLocalCursorWithinOwnAnnotation());
        } else {
            isEnabled = true;
        }
    }

    /**
     * @param {!ops.OdtCursor} cursor
     * @return {undefined}
     */
    function onCursorEvent(cursor) {
        if (cursor.getMemberId() === inputMemberId) {
            updateEnabledState();
        }
    }

    /**
     * @return {!boolean}
     */
    this.isEnabled = function () {
        return isEnabled;
    };

    /**
     * @param {!string} data
     * @return {undefined}
     */
    this.paste = function (data) {
        if (!isEnabled) {
            return;
        }

        var originalCursorPosition = odtDocument.getCursorPosition(inputMemberId),
            cursorNode = odtDocument.getCursor(inputMemberId).getNode(),
            originalParagraph = /**@type{!Element}*/(odfUtils.getParagraphElement(cursorNode)),
            paragraphStyle = originalParagraph.getAttributeNS(textns, "style-name") || "",
            /**@type{number}*/
            cursorPosition = originalCursorPosition,
            operations = [],
            currentParagraphStartPosition = odtDocument.convertDomPointToCursorStep(originalParagraph, 0, NEXT),
            paragraphs;

        paragraphs = data.replace(/\r/g, "").split("\n");
        paragraphs.forEach(function (text) {
            var insertTextOp = new ops.OpInsertText(),
                splitParagraphOp = new ops.OpSplitParagraph();

            insertTextOp.init({
                memberid: inputMemberId,
                position: cursorPosition,
                text: text,
                moveCursor: true
            });
            operations.push(insertTextOp);
            cursorPosition += text.length;

            splitParagraphOp.init({
                memberid: inputMemberId,
                position: cursorPosition,
                paragraphStyleName: paragraphStyle,
                sourceParagraphPosition: currentParagraphStartPosition,
                moveCursor: true
            });
            operations.push(splitParagraphOp);
            cursorPosition += 1; // Splitting a paragraph introduces 1 walkable position, bumping the cursor forward
            currentParagraphStartPosition = cursorPosition; // Reset the source paragraph to the newly created one
        });

        // Discard the last split paragraph op as unnecessary.
        // Reasoning through the scenarios, this produces the most intuitive behaviour:
        // 1. Paste a single line - No line split should be added
        // 2. Paste two lines - Only one paragraph split is necessary per new paragraph. As pasting MUST occur within an
        //                      existing paragraph, only a single split should occur.
        operations.pop();

        session.enqueue(operations);
    };

    /**
     * @param {!function(!Error=)} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function (callback) {
        odtDocument.unsubscribe(ops.Document.signalCursorMoved, onCursorEvent);
        sessionConstraints.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, updateEnabledState);
        callback();
    };

    function init() {
        odtDocument.subscribe(ops.Document.signalCursorMoved, onCursorEvent);
        sessionConstraints.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, updateEnabledState);
        updateEnabledState();
    }
    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SelectionController.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, gui, odf, ops, Node */

/**
 * @constructor
 * @implements {core.Destroyable}
 * @param {!ops.Session} session
 * @param {!string} inputMemberId
 */
gui.SelectionController = function SelectionController(session, inputMemberId) {
    "use strict";
    var odtDocument = session.getOdtDocument(),
        domUtils = core.DomUtils,
        odfUtils = odf.OdfUtils,
        baseFilter = odtDocument.getPositionFilter(),
        guiStepUtils = new gui.GuiStepUtils(),
        rootFilter = odtDocument.createRootFilter(inputMemberId),
        /**@type{?function():(!number|undefined)}*/
        caretXPositionLocator = null,
        /**@type{!number|undefined}*/
        lastXPosition,
        /**@type{!core.ScheduledTask}*/
        resetLastXPositionTask,
        TRAILING_SPACE = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING,
        LEADING_SPACE = odf.WordBoundaryFilter.IncludeWhitespace.LEADING,
        PREVIOUS = core.StepDirection.PREVIOUS,
        NEXT = core.StepDirection.NEXT,
        // Number of milliseconds to keep the user's last up/down caret X position for
        /**@const*/ UPDOWN_NAVIGATION_RESET_DELAY_MS = 2000;

    /**
     * @param {!ops.Operation} op
     * @return undefined;
     */
    function resetLastXPosition(op) {
        var opspec = op.spec();
        if (op.isEdit || opspec.memberid === inputMemberId) {
            lastXPosition = undefined;
            resetLastXPositionTask.cancel();
        }
    }

    /**
     * Create a new step iterator with the base Odt filter, and a root filter for the current input member.
     * The step iterator subtree is set to the root of the current cursor node
     * @return {!core.StepIterator}
     */
    function createKeyboardStepIterator() {
        var cursor = odtDocument.getCursor(inputMemberId),
            node = cursor.getNode();

        return odtDocument.createStepIterator(node, 0, [baseFilter, rootFilter], odtDocument.getRootElement(node));
    }

    /**
     * Create a new step iterator that will iterate by word boundaries
     * @param {!Node} node
     * @param {!number} offset
     * @param {!odf.WordBoundaryFilter.IncludeWhitespace} includeWhitespace
     * @return {!core.StepIterator}
     */
    function createWordBoundaryStepIterator(node, offset, includeWhitespace) {
        var wordBoundaryFilter = new odf.WordBoundaryFilter(odtDocument, includeWhitespace),
            nodeRoot = odtDocument.getRootElement(node) || odtDocument.getRootNode(),
            nodeRootFilter = odtDocument.createRootFilter(nodeRoot);
        return odtDocument.createStepIterator(node, offset, [baseFilter, nodeRootFilter, wordBoundaryFilter], nodeRoot);
    }

    /**
     * Derive a selection-type object from the provided cursor
     * @param {!{anchorNode: Node, anchorOffset: !number, focusNode: Node, focusOffset: !number}} selection
     * @return {{range: !Range, hasForwardSelection: !boolean}}
     */
    function selectionToRange(selection) {
        var hasForwardSelection = domUtils.comparePoints(/**@type{!Node}*/(selection.anchorNode), selection.anchorOffset,
                /**@type{!Node}*/(selection.focusNode), selection.focusOffset) >= 0,
            range = selection.focusNode.ownerDocument.createRange();
        if (hasForwardSelection) {
            range.setStart(selection.anchorNode, selection.anchorOffset);
            range.setEnd(selection.focusNode, selection.focusOffset);
        } else {
            range.setStart(selection.focusNode, selection.focusOffset);
            range.setEnd(selection.anchorNode, selection.anchorOffset);
        }
        return {
            range: range,
            hasForwardSelection: hasForwardSelection
        };
    }
    this.selectionToRange = selectionToRange;

    /**
     * Derive a selection-type object from the provided cursor
     * @param {!Range} range
     * @param {!boolean} hasForwardSelection
     * @return {!{anchorNode: !Node, anchorOffset: !number, focusNode: !Node, focusOffset: !number}}
     */
    function rangeToSelection(range, hasForwardSelection) {
        if (hasForwardSelection) {
            return {
                anchorNode: /**@type{!Node}*/(range.startContainer),
                anchorOffset: range.startOffset,
                focusNode: /**@type{!Node}*/(range.endContainer),
                focusOffset: range.endOffset
            };
        }
        return {
            anchorNode: /**@type{!Node}*/(range.endContainer),
            anchorOffset: range.endOffset,
            focusNode: /**@type{!Node}*/(range.startContainer),
            focusOffset: range.startOffset
        };
    }
    this.rangeToSelection = rangeToSelection;

    /**
     * @param {!number} position
     * @param {!number} length
     * @param {string=} selectionType
     * @return {!ops.Operation}
     */
    function createOpMoveCursor(position, length, selectionType) {
        var op = new ops.OpMoveCursor();
        op.init({
            memberid: inputMemberId,
            position: position,
            length: length || 0,
            selectionType: selectionType
        });
        return op;
    }

    /**
     * Move or extend the local member's selection to the specified focus point.
     *
     * @param {!Node} focusNode
     * @param {!number} focusOffset
     * @param {!boolean} extend Set to true to extend the selection (i.e., the current selection anchor
     *                          will remain unchanged)
     * @return {undefined}
     */
    function moveCursorFocusPoint(focusNode, focusOffset, extend) {
        var cursor,
            newSelection,
            newCursorSelection;

        cursor = odtDocument.getCursor(inputMemberId);
        newSelection = rangeToSelection(cursor.getSelectedRange(), cursor.hasForwardSelection());
        newSelection.focusNode = focusNode;
        newSelection.focusOffset = focusOffset;

        if (!extend) {
            newSelection.anchorNode = newSelection.focusNode;
            newSelection.anchorOffset = newSelection.focusOffset;
        }
        newCursorSelection = odtDocument.convertDomToCursorRange(newSelection);
        session.enqueue([createOpMoveCursor(newCursorSelection.position, newCursorSelection.length)]);
    }

    /**
     * @param {!Node} frameNode
     */
    function selectImage(frameNode) {
        var frameRoot = odtDocument.getRootElement(frameNode),
            frameRootFilter = odtDocument.createRootFilter(frameRoot),
            stepIterator = odtDocument.createStepIterator(frameNode, 0, [frameRootFilter, odtDocument.getPositionFilter()], frameRoot),
            anchorNode,
            anchorOffset,
            newSelection,
            op;

        if (!stepIterator.roundToPreviousStep()) {
            runtime.assert(false, "No walkable position before frame");
        }
        anchorNode = stepIterator.container();
        anchorOffset = stepIterator.offset();

        stepIterator.setPosition(frameNode, frameNode.childNodes.length);
        if (!stepIterator.roundToNextStep()) {
            runtime.assert(false, "No walkable position after frame");
        }

        newSelection = odtDocument.convertDomToCursorRange({
            anchorNode: anchorNode,
            anchorOffset: anchorOffset,
            focusNode: stepIterator.container(),
            focusOffset: stepIterator.offset()
        });
        op = createOpMoveCursor(newSelection.position, newSelection.length, ops.OdtCursor.RegionSelection);
        session.enqueue([op]);
    }
    this.selectImage = selectImage;

    /**
     * Expands the supplied selection to the nearest word boundaries
     * @param {!Range} range
     */
    function expandToWordBoundaries(range) {
        var stepIterator;

        stepIterator = createWordBoundaryStepIterator(/**@type{!Node}*/(range.startContainer), range.startOffset, TRAILING_SPACE);
        if (stepIterator.roundToPreviousStep()) {
            range.setStart(stepIterator.container(), stepIterator.offset());
        }

        stepIterator = createWordBoundaryStepIterator(/**@type{!Node}*/(range.endContainer), range.endOffset, LEADING_SPACE);
        if (stepIterator.roundToNextStep()) {
            range.setEnd(stepIterator.container(), stepIterator.offset());
        }
    }
    this.expandToWordBoundaries = expandToWordBoundaries;

    /**
     * Expands the supplied selection to the nearest paragraph boundaries
     * @param {!Range} range
     */
    function expandToParagraphBoundaries(range) {
        var paragraphs = odfUtils.getParagraphElements(range),
            startParagraph = paragraphs[0],
            endParagraph = paragraphs[paragraphs.length - 1];

        if (startParagraph) {
            range.setStart(startParagraph, 0);
        }

        if (endParagraph) {
            if (odfUtils.isParagraph(range.endContainer) && range.endOffset === 0) {
                // Chrome's built-in paragraph expansion will put the end of the selection
                // at (p,0) of the FOLLOWING paragraph. Round this back down to ensure
                // the next paragraph doesn't get incorrectly selected
                range.setEndBefore(endParagraph);
            } else {
                range.setEnd(endParagraph, endParagraph.childNodes.length);
            }
        }
    }
    this.expandToParagraphBoundaries = expandToParagraphBoundaries;

    /**
     * Rounds to the closest available step inside the supplied root, and preferably
     * inside the original paragraph the node and offset are within. If (node, offset) is
     * outside the root, the closest root boundary is used instead.
     * This function will assert if no valid step is found within the supplied root.
     *
     * @param {!Node} root Root to contain iteration within
     * @param {!Array.<!core.PositionFilter>} filters Position filters
     * @param {!Range} range Range to modify
     * @param {!boolean} modifyStart Set to true to modify the start container & offset. If false, the end
     * container and offset will be modified instead.
     *
     * @return {undefined}
     */
    function roundToClosestStep(root, filters, range, modifyStart) {
        var stepIterator,
            node,
            offset;

        if (modifyStart) {
            node = /**@type{!Node}*/(range.startContainer);
            offset = range.startOffset;
        } else {
            node = /**@type{!Node}*/(range.endContainer);
            offset = range.endOffset;
        }

        if (!domUtils.containsNode(root, node)) {
            if (domUtils.comparePoints(root, 0, node, offset) < 0) {
                offset = 0;
            } else {
                offset = root.childNodes.length;
            }
            node = root;
        }
        stepIterator = odtDocument.createStepIterator(node, offset, filters, odfUtils.getParagraphElement(node) || root);
        if (!stepIterator.roundToClosestStep()) {
            runtime.assert(false, "No step found in requested range");
        }
        if (modifyStart) {
            range.setStart(stepIterator.container(), stepIterator.offset());
        } else {
            range.setEnd(stepIterator.container(), stepIterator.offset());
        }
    }

    /**
     * Set the user's cursor to the specified selection. If the start and end containers are in different roots,
     * the anchor's root constraint is used (the anchor is the startContainer for a forward selection, or the
     * endContainer for a reverse selection).
     *
     * If both the range start and range end are outside of the canvas element, no operations are generated.
     *
     * @param {!Range} range
     * @param {!boolean} hasForwardSelection Set to true to indicate the range is from anchor (startContainer) to focus
     * (endContainer)
     * @param {number=} clickCount A value of 2 denotes expandToWordBoundaries, while a value of 3 and above will expand
     * to paragraph boundaries.
     * @return {undefined}
     */
    function selectRange(range, hasForwardSelection, clickCount) {
        var canvasElement = odtDocument.getOdfCanvas().getElement(),
            validSelection,
            startInsideCanvas,
            endInsideCanvas,
            existingSelection,
            newSelection,
            anchorRoot,
            filters = [baseFilter],
            op;

        startInsideCanvas = domUtils.containsNode(canvasElement, range.startContainer);
        endInsideCanvas = domUtils.containsNode(canvasElement, range.endContainer);
        if (!startInsideCanvas && !endInsideCanvas) {
            return;
        }

        if (startInsideCanvas && endInsideCanvas) {
            // Expansion behaviour should only occur when double & triple clicking is inside the canvas
            if (clickCount === 2) {
                expandToWordBoundaries(range);
            } else if (clickCount >= 3) {
                expandToParagraphBoundaries(range);
            }
        }

        if (hasForwardSelection) {
            anchorRoot = odtDocument.getRootElement(/**@type{!Node}*/(range.startContainer));
        } else {
            anchorRoot = odtDocument.getRootElement(/**@type{!Node}*/(range.endContainer));
        }
        if (!anchorRoot) {
            // If the range end is not within a root element, use the document root instead
            anchorRoot = odtDocument.getRootNode();
        }
        filters.push(odtDocument.createRootFilter(anchorRoot));
        roundToClosestStep(anchorRoot, filters, range, true);
        roundToClosestStep(anchorRoot, filters, range, false);
        validSelection = rangeToSelection(range, hasForwardSelection);
        newSelection = odtDocument.convertDomToCursorRange(validSelection);
        existingSelection = odtDocument.getCursorSelection(inputMemberId);
        if (newSelection.position !== existingSelection.position || newSelection.length !== existingSelection.length) {
            op = createOpMoveCursor(newSelection.position, newSelection.length, ops.OdtCursor.RangeSelection);
            session.enqueue([op]);
        }
    }
    this.selectRange = selectRange;

    /**
     * @param {!core.StepDirection} direction
     * @param {!boolean} extend
     * @return {undefined}
     */
    function moveCursor(direction, extend) {
        var stepIterator = createKeyboardStepIterator();

        if (stepIterator.advanceStep(direction)) {
            moveCursorFocusPoint(stepIterator.container(), stepIterator.offset(), extend);
        }
    }

    /**
     * @return {!boolean}
     */
    function moveCursorToLeft() {
        moveCursor(PREVIOUS, false);
        return true;
    }
    this.moveCursorToLeft = moveCursorToLeft;

    /**
     * @return {!boolean}
     */
    function moveCursorToRight() {
        moveCursor(NEXT, false);
        return true;
    }
    this.moveCursorToRight = moveCursorToRight;

    /**
     * @return {!boolean}
     */
    function extendSelectionToLeft() {
        moveCursor(PREVIOUS, true);
        return true;
    }
    this.extendSelectionToLeft = extendSelectionToLeft;

    /**
     * @return {!boolean}
     */
    function extendSelectionToRight() {
        moveCursor(NEXT, true);
        return true;
    }
    this.extendSelectionToRight = extendSelectionToRight;

    /**
     * Sets the position locator function for the local input member's visual caret. If
     * set to null, cursor movement by line will be disabled.
     *
     * @param {?function():(!number|undefined)} locator
     * @return {undefined}
     */
    this.setCaretXPositionLocator = function(locator) {
        caretXPositionLocator = locator;
    };

    /**
     * @param {!core.StepDirection} direction PREVIOUS for upwards NEXT for downwards
     * @param {!boolean} extend
     * @return {undefined}
     */
    function moveCursorByLine(direction, extend) {
        var stepIterator,
            currentX = lastXPosition,
            stepScanners = [new gui.LineBoundaryScanner(), new gui.ParagraphBoundaryScanner()];

        // Both a line boundary AND a paragraph boundary scanner are necessary to ensure the caret stops correctly
        // inside an empty paragraph.
        // The line boundary scanner requires a visible client rect in order to detect a line break, but for an
        // empty paragraph, there is no visible leading or trailing rect as there aren't any visible children.
        // As a result, the line boundary detection can't determine if an empty paragraph is a line-wrap point, but
        // the paragraph boundary scanner *will* correctly determine that step iterator has moved beyond the
        // current paragraph.

        if (currentX === undefined && caretXPositionLocator) {
            currentX = caretXPositionLocator();
        }

        if (isNaN(currentX)) {
            // Return as the current X offset is unknown. Either no locator is set or the locator returned
            // undefined (e.g., caret not currently visible).
            return;
        }

        stepIterator = createKeyboardStepIterator();
        // Move to the start/end of the current line.
        if (!guiStepUtils.moveToFilteredStep(stepIterator, direction, stepScanners)) {
            // No line boundary found
            return;
        }

        // Move to the first step on the next line
        if (!stepIterator.advanceStep(direction)) {
            // No step available in the specified direction
            return;
        }

        stepScanners = [new gui.ClosestXOffsetScanner(/**@type{!number}*/(currentX)),
                        new gui.LineBoundaryScanner(), new gui.ParagraphBoundaryScanner()];
        // Finally, move to the closest point to the desired X offset within the current line
        if (guiStepUtils.moveToFilteredStep(stepIterator, direction, stepScanners)) {
            moveCursorFocusPoint(stepIterator.container(), stepIterator.offset(), extend);
            lastXPosition = currentX;
            resetLastXPositionTask.restart();
        }
    }

    /**
     * @return {!boolean}
     */
    function moveCursorUp() {
        moveCursorByLine(PREVIOUS, false);
        return true;
    }
    this.moveCursorUp = moveCursorUp;

    /**
     * @return {!boolean}
     */
    function moveCursorDown() {
        moveCursorByLine(NEXT, false);
        return true;
    }
    this.moveCursorDown = moveCursorDown;

    /**
     * @return {!boolean}
     */
    function extendSelectionUp() {
        moveCursorByLine(PREVIOUS, true);
        return true;
    }
    this.extendSelectionUp = extendSelectionUp;

    /**
     * @return {!boolean}
     */
    function extendSelectionDown() {
        moveCursorByLine(NEXT, true);
        return true;
    }
    this.extendSelectionDown = extendSelectionDown;

    /**
     * @param {!core.StepDirection} direction
     * @param {!boolean} extend
     * @return {undefined}
     */
    function moveCursorToLineBoundary(direction, extend) {
        var stepIterator = createKeyboardStepIterator(),
            stepScanners = [new gui.LineBoundaryScanner(), new gui.ParagraphBoundaryScanner()];

        // Both a line boundary AND a paragraph boundary scanner are necessary to ensure the caret stops correctly
        // inside an empty paragraph.
        // The line boundary scanner requires a visible client rect in order to detect a line break, but for an
        // empty paragraph, there is no visible leading or trailing rect as there aren't any visible children.
        // As a result, the line boundary detection can't determine if an empty paragraph is a line-wrap point, but
        // the paragraph boundary scanner *will* correctly determine that step iterator has moved beyond the
        // current paragraph.
        if (guiStepUtils.moveToFilteredStep(stepIterator, direction, stepScanners)) {
            moveCursorFocusPoint(stepIterator.container(), stepIterator.offset(), extend);
        }
    }

    /**
     * @param {!core.StepDirection} direction
     * @param {!boolean} extend whether extend the selection instead of moving the cursor
     * @return {undefined}
     */
    function moveCursorByWord(direction, extend) {
        var cursor = odtDocument.getCursor(inputMemberId),
            newSelection = rangeToSelection(cursor.getSelectedRange(), cursor.hasForwardSelection()),
            stepIterator = createWordBoundaryStepIterator(newSelection.focusNode, newSelection.focusOffset, TRAILING_SPACE);

        if (stepIterator.advanceStep(direction)) {
            moveCursorFocusPoint(stepIterator.container(), stepIterator.offset(), extend);
        }
    }
    
    /**
     * @return {!boolean}
     */
    function moveCursorBeforeWord() {
        moveCursorByWord(PREVIOUS, false);
        return true;
    }
    this.moveCursorBeforeWord = moveCursorBeforeWord;

    /**
     * @return {!boolean}
     */
    function moveCursorPastWord() {
        moveCursorByWord(NEXT, false);
        return true;
    }
    this.moveCursorPastWord = moveCursorPastWord;

    /**
     * @return {!boolean}
     */
    function extendSelectionBeforeWord() {
        moveCursorByWord(PREVIOUS, true);
        return true;
    }
    this.extendSelectionBeforeWord = extendSelectionBeforeWord;

    /**
     * @return {!boolean}
     */
    function extendSelectionPastWord() {
        moveCursorByWord(NEXT, true);
        return true;
    }
    this.extendSelectionPastWord = extendSelectionPastWord;

    /**
     * @return {!boolean}
     */
    function moveCursorToLineStart() {
        moveCursorToLineBoundary(PREVIOUS, false);
        return true;
    }
    this.moveCursorToLineStart = moveCursorToLineStart;

    /**
     * @return {!boolean}
     */
    function moveCursorToLineEnd() {
        moveCursorToLineBoundary(NEXT, false);
        return true;
    }
    this.moveCursorToLineEnd = moveCursorToLineEnd;

    /**
     * @return {!boolean}
     */
    function extendSelectionToLineStart() {
        moveCursorToLineBoundary(PREVIOUS, true);
        return true;
    }
    this.extendSelectionToLineStart = extendSelectionToLineStart;

    /**
     * @return {!boolean}
     */
    function extendSelectionToLineEnd() {
        moveCursorToLineBoundary(NEXT, true);
        return true;
    }
    this.extendSelectionToLineEnd = extendSelectionToLineEnd;

    /**
     * @param {!core.StepDirection} direction
     * @param {!boolean} extend True to extend the selection
     * @param {!function(!Node):Node} getContainmentNode Returns a node container for the supplied node.
     *  Usually this will be something like the parent paragraph or root the supplied node is within
     * @return {undefined}
     */
    function adjustSelectionByNode(direction, extend, getContainmentNode) {
        var validStepFound = false,
            cursor = odtDocument.getCursor(inputMemberId),
            containmentNode,
            selection = rangeToSelection(cursor.getSelectedRange(), cursor.hasForwardSelection()),
            rootElement = odtDocument.getRootElement(selection.focusNode),
            stepIterator;

        runtime.assert(Boolean(rootElement), "SelectionController: Cursor outside root");
        stepIterator = odtDocument.createStepIterator(selection.focusNode, selection.focusOffset, [baseFilter, rootFilter], rootElement);
        stepIterator.roundToClosestStep();

        if (!stepIterator.advanceStep(direction)) {
            return;
        }

        containmentNode = getContainmentNode(stepIterator.container());
        if (!containmentNode) {
            return;
        }

        if (direction === PREVIOUS) {
            stepIterator.setPosition(/**@type{!Node}*/(containmentNode), 0);
            // Round up to the first walkable step in the containment node
            validStepFound = stepIterator.roundToNextStep();
        } else {
            stepIterator.setPosition(/**@type{!Node}*/(containmentNode), containmentNode.childNodes.length);
            // Round down to the last walkable step in the containment node
            validStepFound = stepIterator.roundToPreviousStep();
        }

        if (validStepFound) {
            moveCursorFocusPoint(stepIterator.container(), stepIterator.offset(), extend);
        }
    }

    /**
     * @return {!boolean}
     */
    this.extendSelectionToParagraphStart = function() {
        adjustSelectionByNode(PREVIOUS, true, odfUtils.getParagraphElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.extendSelectionToParagraphEnd = function () {
        adjustSelectionByNode(NEXT, true, odfUtils.getParagraphElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.moveCursorToParagraphStart = function () {
        adjustSelectionByNode(PREVIOUS, false, odfUtils.getParagraphElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.moveCursorToParagraphEnd = function () {
        adjustSelectionByNode(NEXT, false, odfUtils.getParagraphElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.moveCursorToDocumentStart = function () {
        adjustSelectionByNode(PREVIOUS, false, odtDocument.getRootElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.moveCursorToDocumentEnd = function () {
        adjustSelectionByNode(NEXT, false, odtDocument.getRootElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.extendSelectionToDocumentStart = function () {
        adjustSelectionByNode(PREVIOUS, true, odtDocument.getRootElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    this.extendSelectionToDocumentEnd = function () {
        adjustSelectionByNode(NEXT, true, odtDocument.getRootElement);
        return true;
    };

    /**
     * @return {!boolean}
     */
    function extendSelectionToEntireDocument() {
        var cursor = odtDocument.getCursor(inputMemberId),
            rootElement = odtDocument.getRootElement(cursor.getNode()),
            anchorNode,
            anchorOffset,
            stepIterator,
            newCursorSelection;

        runtime.assert(Boolean(rootElement), "SelectionController: Cursor outside root");
        stepIterator = odtDocument.createStepIterator(rootElement, 0, [baseFilter, rootFilter], rootElement);
        stepIterator.roundToClosestStep();
        anchorNode = stepIterator.container();
        anchorOffset = stepIterator.offset();

        stepIterator.setPosition(rootElement, rootElement.childNodes.length);
        stepIterator.roundToClosestStep();
        newCursorSelection = odtDocument.convertDomToCursorRange({
            anchorNode: anchorNode,
            anchorOffset: anchorOffset,
            focusNode: stepIterator.container(),
            focusOffset: stepIterator.offset()
        });
        session.enqueue([createOpMoveCursor(newCursorSelection.position, newCursorSelection.length)]);
        return true;
    }
    this.extendSelectionToEntireDocument = extendSelectionToEntireDocument;

    /**
     * @param {!function(!Error=)} callback passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function (callback) {
        odtDocument.unsubscribe(ops.OdtDocument.signalOperationStart, resetLastXPosition);
        core.Async.destroyAll([resetLastXPositionTask.destroy], callback);
    };

    function init() {
        resetLastXPositionTask = core.Task.createTimeoutTask(function() {
            lastXPosition = undefined;
        }, UPDOWN_NAVIGATION_RESET_DELAY_MS);
        odtDocument.subscribe(ops.OdtDocument.signalOperationStart, resetLastXPosition);
    }
    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SelectionView.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui*/
/*jslint emptyblock: true, unparam: true*/

/**
 * An interface for rendering a visible selection for the provided cursor
 * @interface
 * @param {!(ops.OdtCursor|gui.ShadowCursor)} cursor
 */
gui.SelectionView = function SelectionView(cursor) { "use strict"; };

/**
 * Rerender the selection overlay
 * @return {undefined}
 */
gui.SelectionView.prototype.rerender = function() { "use strict"; };

/**
 * Show selection overlay
 * @return {undefined}
 */
gui.SelectionView.prototype.show = function() { "use strict"; };
/**
 * Hide selection overlay
 * @return {undefined}
 */
gui.SelectionView.prototype.hide = function() { "use strict"; };

/**
 * Clear all overlay from the DOM
 * @param {function(!Error=)} callback
 * @return {undefined}
 */
gui.SelectionView.prototype.destroy = function (callback) { "use strict"; };

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SelectionViewManager.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, gui, ops*/

/**
 * The Selection View Manager is responsible for managing SelectionView objects
 * and attaching/detaching them to cursors.
 * @constructor
 * @implements {core.Destroyable}
 * @param {!function(new:gui.SelectionView, !(ops.OdtCursor|gui.ShadowCursor))} SelectionView
 */
gui.SelectionViewManager = function SelectionViewManager(SelectionView) {
    "use strict";
    var /**@type{!Object.<string,gui.SelectionView>}*/
        selectionViews = {};

    /**
     * @param {!string} memberId
     * @return {?gui.SelectionView}
     */
    function getSelectionView(memberId) {
        return selectionViews.hasOwnProperty(memberId) ? selectionViews[memberId] : null;
    }
    this.getSelectionView = getSelectionView;

    /**
     * @return {!Array.<!gui.SelectionView>}
     */
    function getSelectionViews() {
        return Object.keys(selectionViews).map(function (memberid) { return selectionViews[memberid]; });
    }
    this.getSelectionViews = getSelectionViews;

    /**
     * @param {!string} memberId
     * @return {undefined}
     */
    function removeSelectionView(memberId) {
        if (selectionViews.hasOwnProperty(memberId)) {
            /*jslint emptyblock: true*/
            selectionViews[memberId].destroy(function () { });
            /*jslint emptyblock: false*/
            delete selectionViews[memberId];
        }
    }
    this.removeSelectionView = removeSelectionView;

    /**
     * @param {!string} memberId
     * @return {undefined}
     */
    function hideSelectionView(memberId) {
        if (selectionViews.hasOwnProperty(memberId)) {
            selectionViews[memberId].hide();
        }
    }
    this.hideSelectionView = hideSelectionView;

    /**
     * @param {!string} memberId
     * @return {undefined}
     */
    function showSelectionView(memberId) {
        if (selectionViews.hasOwnProperty(memberId)) {
            selectionViews[memberId].show();
        }
    }
    this.showSelectionView = showSelectionView;

    /**
     * Rerenders the selection views that are already visible
     * @return {undefined}
     */
    this.rerenderSelectionViews = function () {
        Object.keys(selectionViews).forEach(function (memberId) {
            selectionViews[memberId].rerender();
        });
    };

    /**
     * @param {!(ops.OdtCursor|gui.ShadowCursor)} cursor
     * @param {!boolean} virtualSelectionsInitiallyVisible
     * @return {!gui.SelectionView}
     */
    this.registerCursor = function (cursor, virtualSelectionsInitiallyVisible) {
        var memberId = cursor.getMemberId(),
            selectionView = new SelectionView(cursor);

        if (virtualSelectionsInitiallyVisible) {
            selectionView.show();
        } else {
            selectionView.hide();
        }

        selectionViews[memberId] = selectionView;
        return selectionView;
    };

    /**
     * @param {function(!Error=)} callback
     */
    this.destroy = function (callback) {
        var selectionViewArray = getSelectionViews();

        /**
         * @param {!number} i
         * @param {!Error=} err
         * @return {undefined}
         */
        function destroySelectionView(i, err) {
            if (err) {
                callback(err);
            } else {
                if (i < selectionViewArray.length) {
                    selectionViewArray[i].destroy(function (err) {
                        destroySelectionView(i + 1, err);
                    });
                } else {
                    callback();
                }
            }
        }
        destroySelectionView(0, undefined);
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SessionConstraints.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, runtime, gui*/

/**
 * This class allows handling of 'constraints', which are modelled
 * as a name (string) with a true/false state.
 * It provides methods to register, set/get, and subscribe to constraint
 * states.
 * @constructor
 */
gui.SessionConstraints = function SessionConstraints() {
    "use strict";

    var constraints = {},
        constraintNotifier = new core.EventNotifier();

    /**
     * Register a constraint.
     * The default state is `false`. Has no effect if the constraint
     * already exists.
     * @param {!string} constraint
     * @return {undefined}
     */
    function registerConstraint(constraint) {
        if (!constraints.hasOwnProperty(constraint)) {
            constraints[constraint] = false;
            constraintNotifier.register(constraint);
        }
    }
    this.registerConstraint = registerConstraint;

    /**
     * Subscribe to a constraint's state.
     * @param {!string} constraint
     * @param {!Function} callback the only argument of this
     * callback is a boolean, indicating the new state of the
     * constraint.
     * @return {undefined}
     */
    this.subscribe = function (constraint, callback) {
        registerConstraint(constraint);
        constraintNotifier.subscribe(constraint, callback);
    };

    /**
     * Unsubscribe a callback from a constraint's
     * state.
     * @param {!string} constraint
     * @param {!Function} callback
     * @return {undefined}
     */
    this.unsubscribe = function (constraint, callback) {
        constraintNotifier.unsubscribe(constraint, callback);
    };

    /**
     * Set the enabled/disabled state of a constraint
     * @param {!string} constraint
     * @param {!boolean} enabled true if enabled, false if disabled
     * @return {undefined}
     */
    this.setState = function (constraint, enabled) {
        runtime.assert(constraints.hasOwnProperty(constraint) === true, "No such constraint");
        if (constraints[constraint] !== enabled) {
            constraints[constraint] = enabled;
            constraintNotifier.emit(constraint, enabled);
        }
    };

    /**
     * Returns the enabled/disabled state of a constraint
     * @param {!string} constraint
     * @return {!boolean}
     */
    this.getState = function (constraint) {
        runtime.assert(constraints.hasOwnProperty(constraint) === true, "No such constraint");
        return constraints[constraint];
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SessionContext.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, gui, odf */


/**
 * @constructor
 * @param {!ops.Session} session
 * @param {!string} inputMemberId
 */
gui.SessionContext = function (session, inputMemberId) {
    "use strict";

    var odtDocument = session.getOdtDocument(),
        odfUtils = odf.OdfUtils;

    /**
     * @return {!boolean}
     */
    this.isLocalCursorWithinOwnAnnotation = function () {
        var cursor = odtDocument.getCursor(inputMemberId),
            cursorNode,
            currentUserName,
            parentAnnotation;

        if (!cursor) {
            return false;
        }

        cursorNode = cursor && cursor.getNode();
        currentUserName = odtDocument.getMember(inputMemberId).getProperties().fullName;
        parentAnnotation = odfUtils.getParentAnnotation(cursorNode, odtDocument.getRootNode());

        if (parentAnnotation && odfUtils.getAnnotationCreator(parentAnnotation) === currentUserName) {
            return true;
        }

        return false;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SessionController.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, gui, Node, ops, odf */

/**
 * @constructor
 * @struct
 */
gui.SessionControllerOptions = function () {
    "use strict";

    /**
     * Sets whether direct paragraph styling should be enabled.
     * @type {!boolean}
     */
    this.directTextStylingEnabled = false;
    /**
     * Sets whether direct paragraph styling should be enabled.
     * @type {!boolean}
     */
    this.directParagraphStylingEnabled = false;
    /**
     * Sets whether annotation creation/deletion should be enabled.
     * @type {!boolean}
     */
    this.annotationsEnabled = false;
};

(function () {
    "use strict";

    var /**@const*/FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT;

    /**
     * @constructor
     * @implements {core.Destroyable}
     * @param {!ops.Session} session
     * @param {!string} inputMemberId
     * @param {!ops.OdtCursor} shadowCursor
     * @param {!gui.SessionControllerOptions} args
     */
    gui.SessionController = function SessionController(session, inputMemberId, shadowCursor, args) {
        var /**@type{!Window}*/window = /**@type{!Window}*/(runtime.getWindow()),
            odtDocument = session.getOdtDocument(),
            sessionConstraints = new gui.SessionConstraints(),
            sessionContext = new gui.SessionContext(session, inputMemberId),
            domUtils = core.DomUtils,
            odfUtils = odf.OdfUtils,
            mimeDataExporter = new gui.MimeDataExporter(),
            clipboard = new gui.Clipboard(mimeDataExporter),
            keyDownHandler = new gui.KeyboardHandler(),
            keyPressHandler = new gui.KeyboardHandler(),
            keyUpHandler = new gui.KeyboardHandler(),
            /**@type{boolean}*/
            clickStartedWithinCanvas = false,
            objectNameGenerator = new odf.ObjectNameGenerator(odtDocument.getOdfCanvas().odfContainer(), inputMemberId),
            isMouseMoved = false,
            /**@type{core.PositionFilter}*/
            mouseDownRootFilter = null,
            handleMouseClickTimeoutId,
            undoManager = null,
            eventManager = new gui.EventManager(odtDocument),
            annotationsEnabled = args.annotationsEnabled,
            annotationController = new gui.AnnotationController(session, sessionConstraints, inputMemberId),
            directFormattingController = new gui.DirectFormattingController(session, sessionConstraints, sessionContext, inputMemberId, objectNameGenerator,
                                                                            args.directTextStylingEnabled, args.directParagraphStylingEnabled),
            createCursorStyleOp = /**@type {function (!number, !number, !boolean):ops.Operation}*/ (directFormattingController.createCursorStyleOp),
            createParagraphStyleOps = /**@type {function (!number):!Array.<!ops.Operation>}*/ (directFormattingController.createParagraphStyleOps),
            textController = new gui.TextController(session, sessionConstraints, sessionContext, inputMemberId, createCursorStyleOp, createParagraphStyleOps),
            imageController = new gui.ImageController(session, sessionConstraints, sessionContext, inputMemberId, objectNameGenerator),
            imageSelector = new gui.ImageSelector(odtDocument.getOdfCanvas()),
            shadowCursorIterator = odtDocument.createPositionIterator(odtDocument.getRootNode()),
            /**@type{!core.ScheduledTask}*/
            drawShadowCursorTask,
            /**@type{!core.ScheduledTask}*/
            redrawRegionSelectionTask,
            pasteController = new gui.PasteController(session, sessionConstraints, sessionContext, inputMemberId),
            inputMethodEditor = new gui.InputMethodEditor(inputMemberId, eventManager),
            /**@type{number}*/
            clickCount = 0,
            hyperlinkClickHandler = new gui.HyperlinkClickHandler(odtDocument.getOdfCanvas().getElement,
                                                                    keyDownHandler, keyUpHandler),
            hyperlinkController = new gui.HyperlinkController(session, sessionConstraints, sessionContext, inputMemberId),
            selectionController = new gui.SelectionController(session, inputMemberId),
            metadataController = new gui.MetadataController(session, inputMemberId),
            modifier = gui.KeyboardHandler.Modifier,
            keyCode = gui.KeyboardHandler.KeyCode,
            isMacOS = window.navigator.appVersion.toLowerCase().indexOf("mac") !== -1,
            isIOS = ["iPad", "iPod", "iPhone"].indexOf(window.navigator.platform) !== -1,
            /**@type{?gui.IOSSafariSupport}*/
            iOSSafariSupport;

        runtime.assert(window !== null,
            "Expected to be run in an environment which has a global window, like a browser.");

        /**
         * @param {!Event} e
         * @return {Node}
         */
        function getTarget(e) {
            // e.srcElement because IE10 likes to be different...
            return /**@type{Node}*/(e.target) || e.srcElement || null;
        }

        /**
         * @param {!Event} event
         * @return {undefined}
         */
        function cancelEvent(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }
        }

        /**
         * @param {!number} x
         * @param {!number} y
         * @return {?{container:!Node, offset:!number}}
         */
        function caretPositionFromPoint(x, y) {
            var doc = odtDocument.getDOMDocument(),
                c,
                result = null;

            if (doc.caretRangeFromPoint) {
                c = doc.caretRangeFromPoint(x, y);
                result = {
                    container: /**@type{!Node}*/(c.startContainer),
                    offset: c.startOffset
                };
            } else if (doc.caretPositionFromPoint) {
                c = doc.caretPositionFromPoint(x, y);
                if (c && c.offsetNode) {
                    result = {
                        container: c.offsetNode,
                        offset: c.offset
                    };
                }
            }
            return result;
        }

        /**
         * If the user's current selection is region selection (e.g., an image), any executed operations
         * could cause the picture to shift relative to the selection rectangle.
         * @return {undefined}
         */
        function redrawRegionSelection() {
            var cursor = odtDocument.getCursor(inputMemberId),
                imageElement;

            if (cursor && cursor.getSelectionType() === ops.OdtCursor.RegionSelection) {
                imageElement = odfUtils.getImageElements(cursor.getSelectedRange())[0];
                if (imageElement) {
                    imageSelector.select(/**@type{!Element}*/(imageElement.parentNode));
                    return;
                }
            }

            // May have just processed our own remove cursor operation...
            // In this case, clear any image selection chrome to prevent user confusion
            imageSelector.clearSelection();
        }

        /**
         * @param {!Event} event
         * @return {?string}
         */
        function stringFromKeyPress(event) {
            if (event.which === null || event.which === undefined) {
                return String.fromCharCode(event.keyCode); // IE
            }
            if (event.which !== 0 && event.charCode !== 0) {
                return String.fromCharCode(event.which);   // the rest
            }
            return null; // special key
        }

        /**
         * Handle the cut operation request
         * @param {!Event} e
         * @return {undefined}
         */
        function handleCut(e) {
            var cursor = odtDocument.getCursor(inputMemberId),
                selectedRange = cursor.getSelectedRange();

            if (selectedRange.collapsed) {
                // Modifying the clipboard data will clear any existing data,
                // so cut shouldn't touch the clipboard if there is nothing selected
                e.preventDefault();
                return;
            }

            // The document is readonly, so the data will never get placed on
            // the clipboard in most browsers unless we do it ourselves.
            if (clipboard.setDataFromRange(e, selectedRange)) {
                textController.removeCurrentSelection();
            } else {
                // TODO What should we do if cut isn't supported?
                runtime.log("Cut operation failed");
            }
        }

        /**
         * Tell the browser that it's ok to perform a cut action on our read-only body
         * @return {!boolean}
         */
        function handleBeforeCut() {
            var cursor = odtDocument.getCursor(inputMemberId),
                selectedRange = cursor.getSelectedRange();
            return selectedRange.collapsed !== false; // return false to enable cut menu... straightforward right?!
        }

        /**
         * Handle the copy operation request
         * @param {!Event} e
         * @return {undefined}
         */
        function handleCopy(e) {
            var cursor = odtDocument.getCursor(inputMemberId),
                selectedRange = cursor.getSelectedRange();

            if (selectedRange.collapsed) {
                // Modifying the clipboard data will clear any existing data,
                // so copy shouldn't touch the clipboard if there is nothing
                // selected
                e.preventDefault();
                return;
            }

            // Place the data on the clipboard ourselves to ensure consistency
            // with cut behaviours
            if (!clipboard.setDataFromRange(e, selectedRange)) {
                // TODO What should we do if copy isn't supported?
                runtime.log("Copy operation failed");
            }
        }

        /**
         * @param {!Event} e
         * @return {undefined}
         */
        function handlePaste(e) {
            var plainText;

            if (window.clipboardData && window.clipboardData.getData) { // IE
                plainText = window.clipboardData.getData('Text');
            } else if (e.clipboardData && e.clipboardData.getData) { // the rest
                plainText = e.clipboardData.getData('text/plain');
            }

            if (plainText) {
                textController.removeCurrentSelection();
                pasteController.paste(plainText);
            }
            cancelEvent(e);
        }

        /**
         * Tell the browser that it's ok to perform a paste action on our read-only body
         * @return {!boolean}
         */
        function handleBeforePaste() {
            return false;
        }

        /**
         * @param {!ops.Operation} op
         * @return {undefined}
         */
        function updateUndoStack(op) {
            if (undoManager) {
                undoManager.onOperationExecuted(op);
            }
        }

        /**
         * @param {?Event} e
         * @return {undefined}
         */
        function forwardUndoStackChange(e) {
            odtDocument.emit(ops.OdtDocument.signalUndoStackChanged, e);
        }

        /**
         * @return {!boolean}
         */
        function undo() {
            var hadFocusBefore;

            if (undoManager) {
                hadFocusBefore = eventManager.hasFocus();
                undoManager.moveBackward(1);
                if (hadFocusBefore) {
                    eventManager.focus();
                }
                return true;
            }

            return false;
        }
        // TODO it will soon be time to grow an UndoController
        this.undo = undo;

        /**
         * @return {!boolean}
         */
        function redo() {
            var hadFocusBefore;
            if (undoManager) {
                hadFocusBefore = eventManager.hasFocus();
                undoManager.moveForward(1);
                if (hadFocusBefore) {
                    eventManager.focus();
                }
                return true;
            }

            return false;
        }
        // TODO it will soon be time to grow an UndoController
        this.redo = redo;

        /**
         * This processes our custom drag events and if they are on
         * a selection handle (with the attribute 'end' denoting the left
         * or right handle), updates the shadow cursor's selection to
         * be on those endpoints.
         * @param {!Event} event
         * @return {undefined}
         */
        function extendSelectionByDrag(event) {
            var position,
                cursor = odtDocument.getCursor(inputMemberId),
                selectedRange = cursor.getSelectedRange(),
                newSelectionRange,
                /**@type{!string}*/
                handleEnd = /**@type{!Element}*/(getTarget(event)).getAttribute('end');

            if (selectedRange && handleEnd) {
                position = caretPositionFromPoint(event.clientX, event.clientY);
                if (position) {
                    shadowCursorIterator.setUnfilteredPosition(position.container, position.offset);
                    if (mouseDownRootFilter.acceptPosition(shadowCursorIterator) === FILTER_ACCEPT) {
                        newSelectionRange = /**@type{!Range}*/(selectedRange.cloneRange());
                        if (handleEnd === 'left') {
                            newSelectionRange.setStart(shadowCursorIterator.container(), shadowCursorIterator.unfilteredDomOffset());
                        } else {
                            newSelectionRange.setEnd(shadowCursorIterator.container(), shadowCursorIterator.unfilteredDomOffset());
                        }
                        shadowCursor.setSelectedRange(newSelectionRange, handleEnd === 'right');
                        odtDocument.emit(ops.Document.signalCursorMoved, shadowCursor);
                    }
                }
            }
        }

        function updateCursorSelection() {
            selectionController.selectRange(shadowCursor.getSelectedRange(), shadowCursor.hasForwardSelection(), 1);
        }

        function updateShadowCursor() {
            var selection = window.getSelection(),
                selectionRange = selection.rangeCount > 0 && selectionController.selectionToRange(selection);

            if (clickStartedWithinCanvas && selectionRange) {
                isMouseMoved = true;

                imageSelector.clearSelection();
                shadowCursorIterator.setUnfilteredPosition(/**@type {!Node}*/(selection.focusNode), selection.focusOffset);
                if (mouseDownRootFilter.acceptPosition(shadowCursorIterator) === FILTER_ACCEPT) {
                    if (clickCount === 2) {
                        selectionController.expandToWordBoundaries(selectionRange.range);
                    } else if (clickCount >= 3) {
                        selectionController.expandToParagraphBoundaries(selectionRange.range);
                    }
                    shadowCursor.setSelectedRange(selectionRange.range, selectionRange.hasForwardSelection);
                    odtDocument.emit(ops.Document.signalCursorMoved, shadowCursor);
                }
            }
        }

        /**
         * In order for drag operations to work, the browser needs to have it's current
         * selection set. This is called on mouse down to synchronize the user's last selection
         * to the browser selection
         * @param {ops.OdtCursor} cursor
         * @return {undefined}
         */
        function synchronizeWindowSelection(cursor) {
            var selection = window.getSelection(),
                range = cursor.getSelectedRange();

            if (selection.extend) {
                if (cursor.hasForwardSelection()) {
                    selection.collapse(range.startContainer, range.startOffset);
                    selection.extend(range.endContainer, range.endOffset);
                } else {
                    selection.collapse(range.endContainer, range.endOffset);
                    selection.extend(range.startContainer, range.startOffset);
                }
            } else {
                // Internet explorer does provide any method for
                // preserving the range direction
                // See http://msdn.microsoft.com/en-us/library/ie/ff974359%28v=vs.85%29.aspx
                // Unfortunately, clearing the range will also blur the current focus.
                selection.removeAllRanges();
                selection.addRange(range.cloneRange());
            }
        }

        /**
         * Return the number of mouse clicks if the mouse event is for the primary button. Otherwise return 0.
         * @param {!UIEvent} event
         * @return {!number}
         */
        function computeClickCount(event) {
            // According to the spec, button === 0 indicates the primary button (the left button by default, or the
            // right button if the user has switched their mouse buttons around).
            return event.button === 0 ? event.detail : 0;
        }

        /**
         * Updates a flag indicating whether the mouse down event occurred within the OdfCanvas element.
         * This is necessary because the mouse-up binding needs to be global in order to handle mouse-up
         * events that occur when the user releases the mouse button outside the canvas.
         * This filter limits selection changes to mouse down events that start inside the canvas
         * @param {!UIEvent} e
         */
        function handleMouseDown(e) {
            var target = getTarget(e),
                cursor = odtDocument.getCursor(inputMemberId),
                rootNode;
            clickStartedWithinCanvas = target !== null && domUtils.containsNode(odtDocument.getOdfCanvas().getElement(), target);
            if (clickStartedWithinCanvas) {
                isMouseMoved = false;
                rootNode = odtDocument.getRootElement(/**@type{!Node}*/(target)) || odtDocument.getRootNode();
                mouseDownRootFilter = odtDocument.createRootFilter(rootNode);
                clickCount = computeClickCount(e);
                if (cursor && e.shiftKey) {
                    // Firefox seems to get rather confused about the window selection when shift+extending it.
                    // Help this poor browser by resetting the window selection back to the anchor node if the user
                    // is holding shift.
                    window.getSelection().collapse(cursor.getAnchorNode(), 0);
                } else {
                    synchronizeWindowSelection(cursor);
                }
                if (clickCount > 1) {
                    updateShadowCursor();
                }
            }
        }

        /**
         * Return a mutable version of a selection-type object.
         * @param {?Selection} selection
         * @return {?{anchorNode: ?Node, anchorOffset: !number, focusNode: ?Node, focusOffset: !number}}
         */
        function mutableSelection(selection) {
            if (selection) {
                return {
                    anchorNode: selection.anchorNode,
                    anchorOffset: selection.anchorOffset,
                    focusNode: selection.focusNode,
                    focusOffset: selection.focusOffset
                };
            }
            return null;
        }

        /**
         * Gets the next walkable position after the given node.
         * @param {!Node} node
         * @return {?{container:!Node, offset:!number}}
         */
        function getNextWalkablePosition(node) {
            var root = odtDocument.getRootElement(node),
                rootFilter = odtDocument.createRootFilter(root),
                stepIterator = odtDocument.createStepIterator(node, 0, [rootFilter, odtDocument.getPositionFilter()], root);
            stepIterator.setPosition(node, node.childNodes.length);
            if (!stepIterator.roundToNextStep()) {
                return null;
            }
            return {
                container: stepIterator.container(),
                offset: stepIterator.offset()
            };
        }

        /**
         * Causes a cursor movement to the position hinted by a mouse click
         * event.
         * @param {!UIEvent} event
         * @return {undefined}
         */
        function moveByMouseClickEvent(event) {
            var selection = mutableSelection(window.getSelection()),
                isCollapsed = window.getSelection().isCollapsed,
                position,
                selectionRange,
                rect,
                frameNode;

            if (!selection.anchorNode && !selection.focusNode) {
                // chrome & safari will report null for focus and anchor nodes after a right-click in text selection
                position = caretPositionFromPoint(event.clientX, event.clientY);
                if (position) {
                    selection.anchorNode = /**@type{!Node}*/(position.container);
                    selection.anchorOffset = position.offset;
                    selection.focusNode = selection.anchorNode;
                    selection.focusOffset = selection.anchorOffset;
                }
            }

            if (odfUtils.isImage(selection.focusNode) && selection.focusOffset === 0
                && odfUtils.isCharacterFrame(selection.focusNode.parentNode)) {
                // In FireFox if an image has no text around it, click on either side of the
                // image resulting the same selection get returned. focusNode: image, focusOffset: 0
                // Move the cursor to the next walkable position when clicking on the right side of an image
                frameNode = /**@type{!Element}*/(selection.focusNode.parentNode);
                rect = frameNode.getBoundingClientRect();
                if (event.clientX > rect.left) {
                    // On OSX, right-clicking on an image at the end of a range selection will hit
                    // this particular branch. The image should remain selected if the right-click occurs on top
                    // of it as technically it's the same behaviour as right clicking on an existing text selection.
                    position = getNextWalkablePosition(frameNode);
                    if (position) {
                        selection.focusNode = position.container;
                        selection.focusOffset = position.offset;
                        if (isCollapsed) {
                            // See above comment for the circumstances when the range might not be collapsed
                            selection.anchorNode = selection.focusNode;
                            selection.anchorOffset = selection.focusOffset;
                        }
                    }
                }
            } else if (odfUtils.isImage(selection.focusNode.firstChild) && selection.focusOffset === 1
                && odfUtils.isCharacterFrame(selection.focusNode)) {
                // When click on the right side of an image that has no text elements, non-FireFox browsers
                // will return focusNode: frame, focusOffset: 1 as the selection. Since this is not a valid cursor
                // position, move the cursor to the next walkable position after the frame node.

                // To activate this branch (only applicable on OSX + Linux WebKit-derived browsers AFAIK):
                // 1. With a paragraph containing some text followed by an inline image and no trailing text,
                //    select from the start of paragraph to the end.
                // 2. Now click once to the right hand side of the image. The cursor *should* jump to the right side
                position = getNextWalkablePosition(selection.focusNode);
                if (position) {
                    // This should only ever be hit when the selection is intended to become collapsed
                    selection.anchorNode = selection.focusNode = position.container;
                    selection.anchorOffset = selection.focusOffset = position.offset;
                }
            }

            // Need to check the selection again in case the caret position didn't return any result
            if (selection.anchorNode && selection.focusNode) {
                selectionRange = selectionController.selectionToRange(selection);
                selectionController.selectRange(selectionRange.range,
                    selectionRange.hasForwardSelection, computeClickCount(event));
            }
            eventManager.focus(); // Mouse clicks often cause focus to shift. Recapture this straight away
        }

        /**
         * @param {!Event} event
         * @return {undefined}
         */
        function selectWordByLongPress(event) {
            var /**@type{?{anchorNode: ?Node, anchorOffset: !number, focusNode: ?Node, focusOffset: !number}}*/
                selection,
                position,
                selectionRange,
                container, offset;

            position = caretPositionFromPoint(event.clientX, event.clientY);
            if (position) {
                container = /**@type{!Node}*/(position.container);
                offset = position.offset;

                selection = {
                    anchorNode: container,
                    anchorOffset: offset,
                    focusNode: container,
                    focusOffset: offset
                };

                selectionRange = selectionController.selectionToRange(selection);
                selectionController.selectRange(selectionRange.range,
                selectionRange.hasForwardSelection, 2);
                eventManager.focus();
            }
        }

        /**
         * @param {!UIEvent} event
         * @return {undefined}
         */
        function handleMouseClickEvent(event) {
            var target = getTarget(event),
                clickEvent,
                range,
                wasCollapsed,
                frameNode,
                pos;

            drawShadowCursorTask.processRequests(); // Resynchronise the shadow cursor before processing anything else

            if (clickStartedWithinCanvas) {
                // Each mouse down event should only ever result in a single mouse click being processed.
                // This is to cope with there being no hard rules about whether a contextmenu
                // should be followed by a mouseup as well according to the HTML5 specs.
                // See http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus

                // We don't want to just select the image if it is a range selection hence ensure the selection is collapsed.
                if (odfUtils.isImage(target) && odfUtils.isCharacterFrame(target.parentNode) && window.getSelection().isCollapsed) {
                    selectionController.selectImage(/**@type{!Node}*/(target.parentNode));
                    eventManager.focus(); // Mouse clicks often cause focus to shift. Recapture this straight away
                } else if (imageSelector.isSelectorElement(target)) {
                    eventManager.focus(); // Mouse clicks often cause focus to shift. Recapture this straight away
                } else if (isMouseMoved) {
                    range = shadowCursor.getSelectedRange();
                    wasCollapsed = range.collapsed;
                    // Resets the endContainer and endOffset when a forward selection end up on an image;
                    // Otherwise the image will not be selected because endContainer: image, endOffset 0 is not a valid
                    // cursor position.
                    if (odfUtils.isImage(range.endContainer) && range.endOffset === 0
                            && odfUtils.isCharacterFrame(range.endContainer.parentNode)) {
                        frameNode = /**@type{!Element}*/(range.endContainer.parentNode);
                        pos = getNextWalkablePosition(frameNode);
                        if (pos) {
                            range.setEnd(pos.container, pos.offset);
                            if (wasCollapsed) {
                                range.collapse(false); // collapses the range to its end
                            }
                        }
                    }
                    selectionController.selectRange(range, shadowCursor.hasForwardSelection(), computeClickCount(event));
                    eventManager.focus(); // Mouse clicks often cause focus to shift. Recapture this straight away
                } else {
                    // Clicking in already selected text won't update window.getSelection() until just after
                    // the click is processed. Set 0 timeout here so the newly clicked position can be updated
                    // by the browser. Unfortunately this is only working in Firefox. For other browsers, we have to work
                    // out the caret position from two coordinates.
                    // In iOS, however, it is not possible to assign focus within a timeout. But in that case
                    // we do not even need a timeout, because we do not use native selections at all there,
                    // therefore for that platform, just directly move by the mouse click and give focus.
                    if (isIOS) {
                        moveByMouseClickEvent(event);
                    } else {
                        // IE10 destructs event objects once the event handler is done, so create a copy of the data.
                        // "The event object is only available during an event; that is, you can use it in event handlers but not in other code"
                        // (from http://msdn.microsoft.com/en-us/library/ie/aa703876(v=vs.85).aspx)
                        // TODO: IE10 on a test machine does not have the "detail" property set on "mouseup" events here,
                        // even if the docs claim it should exist, cmp. http://msdn.microsoft.com/en-au/library/ie/ff974344(v=vs.85).aspx
                        // So doubleclicks will not be detected on (some?) IE currently.
                        clickEvent = /**@type{!UIEvent}*/(domUtils.cloneEvent(event));
                        handleMouseClickTimeoutId = runtime.setTimeout(function () {
                            moveByMouseClickEvent(clickEvent);
                        }, 0);
                    }
                }
                // TODO assumes the mouseup/contextmenu is the same button as the mousedown that initialized the clickCount
                clickCount = 0;
                clickStartedWithinCanvas = false;
                isMouseMoved = false;
            }
        }

        /**
         * @param {!MouseEvent} e
         * @return {undefined}
         */
        function handleDragStart(e) {
            var cursor = odtDocument.getCursor(inputMemberId),
                selectedRange = cursor.getSelectedRange();

            if (selectedRange.collapsed) {
                return;
            }

            mimeDataExporter.exportRangeToDataTransfer(/**@type{!DataTransfer}*/(e.dataTransfer), selectedRange);
        }

        function handleDragEnd() {
            // Drag operations consume the corresponding mouse up event.
            // If this happens, the selection should still be reset.
            if (clickStartedWithinCanvas) {
                eventManager.focus();
            }
            clickCount = 0;
            clickStartedWithinCanvas = false;
            isMouseMoved = false;
        }

        /**
         * @param {!UIEvent} e
         */
        function handleContextMenu(e) {
            // TODO Various browsers have different default behaviours on right click
            // We can detect this at runtime without doing any kind of platform sniffing
            // simply by observing what the browser has tried to do on right-click.
            // - OSX: Safari/Chrome - Expand to word boundary
            // - OSX: Firefox - No expansion
            // - Windows: Safari/Chrome/Firefox - No expansion
            handleMouseClickEvent(e);
        }

        /**
         * @param {!UIEvent} event
         */
        function handleMouseUp(event) {
            var target = /**@type{!Element}*/(getTarget(event)),
                annotationNode = null;

            if (target.className === "annotationRemoveButton") {
                runtime.assert(annotationsEnabled, "Remove buttons are displayed on annotations while annotation editing is disabled in the controller.");
                annotationNode = /**@type{!Element}*/(target.parentNode).getElementsByTagNameNS(odf.Namespaces.officens, 'annotation').item(0);
                annotationController.removeAnnotation(/**@type{!Element}*/(annotationNode));
                eventManager.focus();
            } else {
                if (target.getAttribute('class') !== 'webodf-draggable') {
                    handleMouseClickEvent(event);
                }
            }
        }

        /**
         * Handle composition end event. If there is data specified, treat this as text
         * to be inserted into the document.
         * @param {!CompositionEvent} e
         */
        function insertNonEmptyData(e) {
            // https://dvcs.w3.org/hg/dom3events/raw-file/tip/html/DOM3-Events.html#event-type-compositionend
            var input = e.data;
            if (input) {
                if (input.indexOf("\n") === -1) {
                    textController.insertText(input);
                } else {
                    // Multi-line input should be handled as if it was pasted, rather than inserted as one giant
                    // single string.
                    pasteController.paste(input);
                }
            }
        }

        /**
         * Executes the provided function and returns true
         * Used to swallow events regardless of whether an operation was created
         * @param {!Function} fn
         * @return {!Function}
         */
        function returnTrue(fn) {
            return function () {
                fn();
                return true;
            };
        }

        /**
         * Executes the given function on range selection only
         * @param {function(T):(boolean|undefined)} fn
         * @return {function(T):(boolean|undefined)}
         * @template T
         */
        function rangeSelectionOnly(fn) {
            /**
             * @param {*} e
             * @return {!boolean|undefined}
             */
            function f(e) {
                var selectionType = odtDocument.getCursor(inputMemberId).getSelectionType();
                if (selectionType === ops.OdtCursor.RangeSelection) {
                    return fn(e);
                }
                return true;
            }
            return f;
        }

        /**
         * Inserts the local cursor.
         * @return {undefined}
         */
        function insertLocalCursor() {
            runtime.assert(session.getOdtDocument().getCursor(inputMemberId) === undefined, "Inserting local cursor a second time.");

            var op = new ops.OpAddCursor();
            op.init({memberid: inputMemberId});
            session.enqueue([op]);
            // Immediately capture focus when the local cursor is inserted
            eventManager.focus();
        }
        this.insertLocalCursor = insertLocalCursor;


        /**
         * Removes the local cursor.
         * @return {undefined}
         */
        function removeLocalCursor() {
            runtime.assert(session.getOdtDocument().getCursor(inputMemberId) !== undefined, "Removing local cursor without inserting before.");

            var op = new ops.OpRemoveCursor();
            op.init({memberid: inputMemberId});
            session.enqueue([op]);
        }
        this.removeLocalCursor = removeLocalCursor;

        /**
         * @return {undefined}
         */
        this.startEditing = function () {
            inputMethodEditor.subscribe(gui.InputMethodEditor.signalCompositionStart, textController.removeCurrentSelection);
            inputMethodEditor.subscribe(gui.InputMethodEditor.signalCompositionEnd, insertNonEmptyData);

            eventManager.subscribe("beforecut", handleBeforeCut);
            eventManager.subscribe("cut", handleCut);
            eventManager.subscribe("beforepaste", handleBeforePaste);
            eventManager.subscribe("paste", handlePaste);

            if (undoManager) {
                // For most undo managers, the initial state is a clean document *with* a cursor present
                undoManager.initialize();
            }

            eventManager.setEditing(true);
            hyperlinkClickHandler.setModifier(isMacOS ? modifier.Meta : modifier.Ctrl);
            // Most browsers will go back one page when given an unhandled backspace press
            // To prevent this, the event handler for this key should always return true
            keyDownHandler.bind(keyCode.Backspace, modifier.None, returnTrue(textController.removeTextByBackspaceKey), true);
            keyDownHandler.bind(keyCode.Delete, modifier.None, textController.removeTextByDeleteKey);

            // TODO: deselect the currently selected image when press Esc
            // TODO: move the image selection box to next image/frame when press tab on selected image
            keyDownHandler.bind(keyCode.Tab, modifier.None, rangeSelectionOnly(function () {
                textController.insertText("\t");
                return true;
            }));

            if (isMacOS) {
                keyDownHandler.bind(keyCode.Clear, modifier.None, textController.removeCurrentSelection);
                keyDownHandler.bind(keyCode.B, modifier.Meta, rangeSelectionOnly(directFormattingController.toggleBold));
                keyDownHandler.bind(keyCode.I, modifier.Meta, rangeSelectionOnly(directFormattingController.toggleItalic));
                keyDownHandler.bind(keyCode.U, modifier.Meta, rangeSelectionOnly(directFormattingController.toggleUnderline));
                keyDownHandler.bind(keyCode.L, modifier.MetaShift, rangeSelectionOnly(directFormattingController.alignParagraphLeft));
                keyDownHandler.bind(keyCode.E, modifier.MetaShift, rangeSelectionOnly(directFormattingController.alignParagraphCenter));
                keyDownHandler.bind(keyCode.R, modifier.MetaShift, rangeSelectionOnly(directFormattingController.alignParagraphRight));
                keyDownHandler.bind(keyCode.J, modifier.MetaShift, rangeSelectionOnly(directFormattingController.alignParagraphJustified));
                if (annotationsEnabled) {
                    keyDownHandler.bind(keyCode.C, modifier.MetaShift, annotationController.addAnnotation);
                }
                keyDownHandler.bind(keyCode.Z, modifier.Meta, undo);
                keyDownHandler.bind(keyCode.Z, modifier.MetaShift, redo);
            } else {
                keyDownHandler.bind(keyCode.B, modifier.Ctrl, rangeSelectionOnly(directFormattingController.toggleBold));
                keyDownHandler.bind(keyCode.I, modifier.Ctrl, rangeSelectionOnly(directFormattingController.toggleItalic));
                keyDownHandler.bind(keyCode.U, modifier.Ctrl, rangeSelectionOnly(directFormattingController.toggleUnderline));
                keyDownHandler.bind(keyCode.L, modifier.CtrlShift, rangeSelectionOnly(directFormattingController.alignParagraphLeft));
                keyDownHandler.bind(keyCode.E, modifier.CtrlShift, rangeSelectionOnly(directFormattingController.alignParagraphCenter));
                keyDownHandler.bind(keyCode.R, modifier.CtrlShift, rangeSelectionOnly(directFormattingController.alignParagraphRight));
                keyDownHandler.bind(keyCode.J, modifier.CtrlShift, rangeSelectionOnly(directFormattingController.alignParagraphJustified));
                if (annotationsEnabled) {
                    keyDownHandler.bind(keyCode.C, modifier.CtrlAlt, annotationController.addAnnotation);
                }
                keyDownHandler.bind(keyCode.Z, modifier.Ctrl, undo);
                keyDownHandler.bind(keyCode.Z, modifier.CtrlShift, redo);
            }

            // the default action is to insert text into the document
            /**
             * @param {!KeyboardEvent} e
             * @return {boolean|undefined}
             */
            function handler(e) {
                var text = stringFromKeyPress(e);
                if (text && !(e.altKey || e.ctrlKey || e.metaKey)) {
                    textController.insertText(text);
                    return true;
                }
                return false;
            }
            keyPressHandler.setDefault(rangeSelectionOnly(handler));
            keyPressHandler.bind(keyCode.Enter, modifier.None, rangeSelectionOnly(textController.enqueueParagraphSplittingOps));
        };

        /**
         * @return {undefined}
         */
        this.endEditing = function () {
            inputMethodEditor.unsubscribe(gui.InputMethodEditor.signalCompositionStart, textController.removeCurrentSelection);
            inputMethodEditor.unsubscribe(gui.InputMethodEditor.signalCompositionEnd, insertNonEmptyData);

            eventManager.unsubscribe("cut", handleCut);
            eventManager.unsubscribe("beforecut", handleBeforeCut);
            eventManager.unsubscribe("paste", handlePaste);
            eventManager.unsubscribe("beforepaste", handleBeforePaste);

            eventManager.setEditing(false);
            hyperlinkClickHandler.setModifier(modifier.None);
            keyDownHandler.bind(keyCode.Backspace, modifier.None, function () { return true; }, true);
            keyDownHandler.unbind(keyCode.Delete, modifier.None);
            keyDownHandler.unbind(keyCode.Tab, modifier.None);

            if (isMacOS) {
                keyDownHandler.unbind(keyCode.Clear, modifier.None);
                keyDownHandler.unbind(keyCode.B, modifier.Meta);
                keyDownHandler.unbind(keyCode.I, modifier.Meta);
                keyDownHandler.unbind(keyCode.U, modifier.Meta);
                keyDownHandler.unbind(keyCode.L, modifier.MetaShift);
                keyDownHandler.unbind(keyCode.E, modifier.MetaShift);
                keyDownHandler.unbind(keyCode.R, modifier.MetaShift);
                keyDownHandler.unbind(keyCode.J, modifier.MetaShift);
                if (annotationsEnabled) {
                    keyDownHandler.unbind(keyCode.C, modifier.MetaShift);
                }
                keyDownHandler.unbind(keyCode.Z, modifier.Meta);
                keyDownHandler.unbind(keyCode.Z, modifier.MetaShift);
            } else {
                keyDownHandler.unbind(keyCode.B, modifier.Ctrl);
                keyDownHandler.unbind(keyCode.I, modifier.Ctrl);
                keyDownHandler.unbind(keyCode.U, modifier.Ctrl);
                keyDownHandler.unbind(keyCode.L, modifier.CtrlShift);
                keyDownHandler.unbind(keyCode.E, modifier.CtrlShift);
                keyDownHandler.unbind(keyCode.R, modifier.CtrlShift);
                keyDownHandler.unbind(keyCode.J, modifier.CtrlShift);
                if (annotationsEnabled) {
                    keyDownHandler.unbind(keyCode.C, modifier.CtrlAlt);
                }
                keyDownHandler.unbind(keyCode.Z, modifier.Ctrl);
                keyDownHandler.unbind(keyCode.Z, modifier.CtrlShift);
            }

            keyPressHandler.setDefault(null);
            keyPressHandler.unbind(keyCode.Enter, modifier.None);
        };

        /**
         * @return {!string}
         */
        this.getInputMemberId = function () {
            return inputMemberId;
        };

        /**
         * @return {!ops.Session}
         */
        this.getSession = function () {
            return session;
        };

        /**
         * @return {!gui.SessionConstraints}
         */
        this.getSessionConstraints = function () {
            return sessionConstraints;
        };

        /**
         * @param {?gui.UndoManager} manager
         * @return {undefined}
         */
        this.setUndoManager = function (manager) {
            if (undoManager) {
                undoManager.unsubscribe(gui.UndoManager.signalUndoStackChanged, forwardUndoStackChange);
            }

            undoManager = manager;
            if (undoManager) {
                undoManager.setDocument(odtDocument);
                // As per gui.UndoManager, this should NOT fire any signals or report
                // events being executed back to the undo manager.
                undoManager.setPlaybackFunction(session.enqueue);
                undoManager.subscribe(gui.UndoManager.signalUndoStackChanged, forwardUndoStackChange);
            }
        };

        /**
         * @return {?gui.UndoManager}
         */
        this.getUndoManager = function () {
            return undoManager;
        };

        /**
         * @return {!gui.MetadataController}
         */
        this.getMetadataController = function () {
            return metadataController;
        };

        /**
         * @return {?gui.AnnotationController}
         */
        this.getAnnotationController = function () {
            return annotationController;
        };

        /**
         * @return {!gui.DirectFormattingController}
         */
        this.getDirectFormattingController = function () {
            return directFormattingController;
        };

        /**
         * @return {!gui.HyperlinkClickHandler}
         */
        this.getHyperlinkClickHandler = function () {
            return hyperlinkClickHandler;
        };

        /**
         * @return {!gui.HyperlinkController}
         */
        this.getHyperlinkController = function () {
            return hyperlinkController;
        };

        /**
         * @return {!gui.ImageController}
         */
        this.getImageController = function () {
            return imageController;
        };

        /**
         * @return {!gui.SelectionController}
         */
        this.getSelectionController = function () {
            return selectionController;
        };

        /**
         * @return {!gui.TextController}
         */
        this.getTextController = function () {
            return textController;
        };

        /**
         * @return {!gui.EventManager}
         */
        this.getEventManager = function() {
            return eventManager;
        };

        /**
         * Return the keyboard event handlers
         * @return {{keydown: gui.KeyboardHandler, keypress: gui.KeyboardHandler}}
         */
        this.getKeyboardHandlers = function () {
            return {
                keydown: keyDownHandler,
                keypress: keyPressHandler
            };
        };

        /**
         * @param {!function(!Object=)} callback passing an error object in case of error
         * @return {undefined}
         */
        function destroy(callback) {
            eventManager.unsubscribe("keydown", keyDownHandler.handleEvent);
            eventManager.unsubscribe("keypress", keyPressHandler.handleEvent);
            eventManager.unsubscribe("keyup", keyUpHandler.handleEvent);
            eventManager.unsubscribe("copy", handleCopy);
            eventManager.unsubscribe("mousedown", handleMouseDown);
            eventManager.unsubscribe("mousemove", drawShadowCursorTask.trigger);
            eventManager.unsubscribe("mouseup", handleMouseUp);
            eventManager.unsubscribe("contextmenu", handleContextMenu);
            eventManager.unsubscribe("dragstart", handleDragStart);
            eventManager.unsubscribe("dragend", handleDragEnd);
            eventManager.unsubscribe("click", hyperlinkClickHandler.handleClick);
            eventManager.unsubscribe("longpress", selectWordByLongPress);
            eventManager.unsubscribe("drag", extendSelectionByDrag);
            eventManager.unsubscribe("dragstop", updateCursorSelection);

            odtDocument.unsubscribe(ops.OdtDocument.signalOperationEnd, redrawRegionSelectionTask.trigger);
            odtDocument.unsubscribe(ops.Document.signalCursorAdded, inputMethodEditor.registerCursor);
            odtDocument.unsubscribe(ops.Document.signalCursorRemoved, inputMethodEditor.removeCursor);
            odtDocument.unsubscribe(ops.OdtDocument.signalOperationEnd, updateUndoStack);

            callback();
        }

        /**
         * @param {!function(!Error=)} callback passing an error object in case of error
         * @return {undefined}
         */
        this.destroy = function (callback) {
            var destroyCallbacks = [
                drawShadowCursorTask.destroy,
                redrawRegionSelectionTask.destroy,
                directFormattingController.destroy,
                inputMethodEditor.destroy,
                eventManager.destroy,
                hyperlinkClickHandler.destroy,
                hyperlinkController.destroy,
                metadataController.destroy,
                selectionController.destroy,
                textController.destroy,
                destroy
            ];

            if (iOSSafariSupport) {
                destroyCallbacks.unshift(iOSSafariSupport.destroy);
            }

            runtime.clearTimeout(handleMouseClickTimeoutId);
            core.Async.destroyAll(destroyCallbacks, callback);
        };

        function init() {
            drawShadowCursorTask = core.Task.createRedrawTask(updateShadowCursor);
            redrawRegionSelectionTask = core.Task.createRedrawTask(redrawRegionSelection);

            keyDownHandler.bind(keyCode.Left, modifier.None, rangeSelectionOnly(selectionController.moveCursorToLeft));
            keyDownHandler.bind(keyCode.Right, modifier.None, rangeSelectionOnly(selectionController.moveCursorToRight));
            keyDownHandler.bind(keyCode.Up, modifier.None, rangeSelectionOnly(selectionController.moveCursorUp));
            keyDownHandler.bind(keyCode.Down, modifier.None, rangeSelectionOnly(selectionController.moveCursorDown));
            keyDownHandler.bind(keyCode.Left, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionToLeft));
            keyDownHandler.bind(keyCode.Right, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionToRight));
            keyDownHandler.bind(keyCode.Up, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionUp));
            keyDownHandler.bind(keyCode.Down, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionDown));
            keyDownHandler.bind(keyCode.Home, modifier.None, rangeSelectionOnly(selectionController.moveCursorToLineStart));
            keyDownHandler.bind(keyCode.End, modifier.None, rangeSelectionOnly(selectionController.moveCursorToLineEnd));
            keyDownHandler.bind(keyCode.Home, modifier.Ctrl, rangeSelectionOnly(selectionController.moveCursorToDocumentStart));
            keyDownHandler.bind(keyCode.End, modifier.Ctrl, rangeSelectionOnly(selectionController.moveCursorToDocumentEnd));
            keyDownHandler.bind(keyCode.Home, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionToLineStart));
            keyDownHandler.bind(keyCode.End, modifier.Shift, rangeSelectionOnly(selectionController.extendSelectionToLineEnd));
            keyDownHandler.bind(keyCode.Up, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionToParagraphStart));
            keyDownHandler.bind(keyCode.Down, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionToParagraphEnd));
            keyDownHandler.bind(keyCode.Home, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionToDocumentStart));
            keyDownHandler.bind(keyCode.End, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionToDocumentEnd));

            if (isMacOS) {
                keyDownHandler.bind(keyCode.Left, modifier.Alt, rangeSelectionOnly(selectionController.moveCursorBeforeWord));
                keyDownHandler.bind(keyCode.Right, modifier.Alt, rangeSelectionOnly(selectionController.moveCursorPastWord));
                keyDownHandler.bind(keyCode.Left, modifier.Meta, rangeSelectionOnly(selectionController.moveCursorToLineStart));
                keyDownHandler.bind(keyCode.Right, modifier.Meta, rangeSelectionOnly(selectionController.moveCursorToLineEnd));
                keyDownHandler.bind(keyCode.Home, modifier.Meta, rangeSelectionOnly(selectionController.moveCursorToDocumentStart));
                keyDownHandler.bind(keyCode.End, modifier.Meta, rangeSelectionOnly(selectionController.moveCursorToDocumentEnd));
                keyDownHandler.bind(keyCode.Left, modifier.AltShift, rangeSelectionOnly(selectionController.extendSelectionBeforeWord));
                keyDownHandler.bind(keyCode.Right, modifier.AltShift, rangeSelectionOnly(selectionController.extendSelectionPastWord));
                keyDownHandler.bind(keyCode.Left, modifier.MetaShift, rangeSelectionOnly(selectionController.extendSelectionToLineStart));
                keyDownHandler.bind(keyCode.Right, modifier.MetaShift, rangeSelectionOnly(selectionController.extendSelectionToLineEnd));
                keyDownHandler.bind(keyCode.Up, modifier.AltShift, rangeSelectionOnly(selectionController.extendSelectionToParagraphStart));
                keyDownHandler.bind(keyCode.Down, modifier.AltShift, rangeSelectionOnly(selectionController.extendSelectionToParagraphEnd));
                keyDownHandler.bind(keyCode.Up, modifier.MetaShift, rangeSelectionOnly(selectionController.extendSelectionToDocumentStart));
                keyDownHandler.bind(keyCode.Down, modifier.MetaShift, rangeSelectionOnly(selectionController.extendSelectionToDocumentEnd));
                keyDownHandler.bind(keyCode.A, modifier.Meta, rangeSelectionOnly(selectionController.extendSelectionToEntireDocument));
            } else {
                keyDownHandler.bind(keyCode.Left, modifier.Ctrl, rangeSelectionOnly(selectionController.moveCursorBeforeWord));
                keyDownHandler.bind(keyCode.Right, modifier.Ctrl, rangeSelectionOnly(selectionController.moveCursorPastWord));
                keyDownHandler.bind(keyCode.Left, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionBeforeWord));
                keyDownHandler.bind(keyCode.Right, modifier.CtrlShift, rangeSelectionOnly(selectionController.extendSelectionPastWord));
                keyDownHandler.bind(keyCode.A, modifier.Ctrl, rangeSelectionOnly(selectionController.extendSelectionToEntireDocument));
            }

            if (isIOS) {
                iOSSafariSupport = new gui.IOSSafariSupport(eventManager);
            }

            eventManager.subscribe("keydown", keyDownHandler.handleEvent);
            eventManager.subscribe("keypress", keyPressHandler.handleEvent);
            eventManager.subscribe("keyup", keyUpHandler.handleEvent);
            eventManager.subscribe("copy", handleCopy);
            eventManager.subscribe("mousedown", handleMouseDown);
            eventManager.subscribe("mousemove", drawShadowCursorTask.trigger);
            eventManager.subscribe("mouseup", handleMouseUp);
            eventManager.subscribe("contextmenu", handleContextMenu);
            eventManager.subscribe("dragstart", handleDragStart);
            eventManager.subscribe("dragend", handleDragEnd);
            eventManager.subscribe("click", hyperlinkClickHandler.handleClick);
            eventManager.subscribe("longpress", selectWordByLongPress);
            eventManager.subscribe("drag", extendSelectionByDrag);
            eventManager.subscribe("dragstop", updateCursorSelection);

            odtDocument.subscribe(ops.OdtDocument.signalOperationEnd, redrawRegionSelectionTask.trigger);
            odtDocument.subscribe(ops.Document.signalCursorAdded, inputMethodEditor.registerCursor);
            odtDocument.subscribe(ops.Document.signalCursorRemoved, inputMethodEditor.removeCursor);
            odtDocument.subscribe(ops.OdtDocument.signalOperationEnd, updateUndoStack);
        }

        init();
    };
}());
// vim:expandtab

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SessionView.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, document, runtime, gui, ops, core */

/**
 * @constructor
 * @struct
 */
gui.SessionViewOptions = function () {
    "use strict";

    /**
     * Set the initial edit information marker visibility
     * @type {boolean}
     */
    this.editInfoMarkersInitiallyVisible = true;

    /**
     * Sets the initial visibility of the avatar
     * @type {boolean}
     */
    this.caretAvatarsInitiallyVisible = true;

    /**
     * Specify that the caret should blink if a non-collapsed range is selected
     * @type {boolean}
     */
    this.caretBlinksOnRangeSelect = true;
};

(function () {
    "use strict";

    /**
     * Return a user-specified option, or the default value if no user option
     * is provided
     * @param {boolean} userValue
     * @param {!boolean} defaultValue
     * @return {!boolean}
     */
    function configOption(userValue, defaultValue) {
        return userValue !== undefined ? Boolean(userValue) : defaultValue;
    }

    /**
     * TODO: We really don't want to let SessionView be aware of localMemberId,
     * so eventually we'll need to refactor this. It is only here so that the id can
     * be matched with the memberids for which CSS is generated, to generate the same CSS
     * for shadow cursors.
     * @constructor
     * @implements {core.Destroyable}
     * @param {!gui.SessionViewOptions} viewOptions
     * @param {string} localMemberId
     * @param {!ops.Session} session
     * @param {!gui.SessionConstraints} sessionConstraints
     * @param {!gui.CaretManager} caretManager
     * @param {!gui.SelectionViewManager} selectionViewManager
     */
    gui.SessionView = function SessionView(viewOptions, localMemberId, session, sessionConstraints, caretManager, selectionViewManager) {
        var /**@type{!HTMLStyleElement}*/
            avatarInfoStyles,
            /**@type{!HTMLStyleElement}*/
            annotationConstraintStyles,
            editInfons = 'urn:webodf:names:editinfo',
            /**@type{!Object.<string,!gui.EditInfoMarker>}*/
            editInfoMap = {},
            /**@type{!ops.OdtDocument}*/
            odtDocument,
            /**@type{!odf.OdfCanvas}*/
            odfCanvas,
            /**@type{!core.ScheduledTask}*/
            highlightRefreshTask,
            showEditInfoMarkers = configOption(viewOptions.editInfoMarkersInitiallyVisible, true),
            showCaretAvatars = configOption(viewOptions.caretAvatarsInitiallyVisible, true),
            blinkOnRangeSelect = configOption(viewOptions.caretBlinksOnRangeSelect, true);

        /**
         * @param {!{memberId: !string, annotation: !Element}} info
         * @return {undefined}
         */
        function onAnnotationAdded(info) {
            if (info.memberId === localMemberId) {
                odfCanvas.getViewport().scrollIntoView(info.annotation.getBoundingClientRect());
            }
        }

        /**
         * @return {!HTMLStyleElement}
         */
        function newStyleSheet() {
            var head = document.getElementsByTagName('head').item(0),
                sheet = /**@type{!HTMLStyleElement}*/(document.createElement('style'));

            sheet.type = 'text/css';
            sheet.media = 'screen, print, handheld, projection';
            head.appendChild(sheet);

            return sheet;
        }

        /**
         * @param {!string} nodeName
         * @param {!string} memberId
         * @param {!string} pseudoClass
         * @return {!string}
         */
        function createAvatarInfoNodeMatch(nodeName, memberId, pseudoClass) {
            return nodeName + '[editinfo|memberid="' + memberId + '"]' + pseudoClass;
        }

        /**
         * @param {!string} nodeName
         * @param {!string} memberId
         * @param {string} pseudoClass
         * @return {?Node}
         */
        function getAvatarInfoStyle(nodeName, memberId, pseudoClass) {
            var node = avatarInfoStyles.firstChild,
                // adding "{" to make sure indexOf(nodeMatch) === 0 does not match longer selectors with same start
                nodeMatch = createAvatarInfoNodeMatch(nodeName, memberId, pseudoClass) + "{";

            while (node) {
                if (node.nodeType === Node.TEXT_NODE && /**@type{!Text}*/(node).data.indexOf(nodeMatch) === 0) {
                    return node;
                }
                node = node.nextSibling;
            }
            return null;
        }

        /**
         * @param {!string} memberId
         * @param {!string} name
         * @param {!string} color
         * @return {undefined}
         */
        function setAvatarInfoStyle(memberId, name, color) {
            /**
             * @param {!string} nodeName
             * @param {!string} rule
             * @param {!string} pseudoClass
             */
            function setStyle(nodeName, rule, pseudoClass) {
                var styleRule = createAvatarInfoNodeMatch(nodeName, memberId, pseudoClass) + rule,
                    styleNode = getAvatarInfoStyle(nodeName, memberId, pseudoClass);

                // TODO: this does not work with Firefox 16.0.1, throws a HierarchyRequestError on first try.
                // And Chromium a "SYNTAX_ERR: DOM Exception 12" now
                // avatarEditedStyles.sheet.insertRule(paragraphStyleName+styleRuleRudimentCStr, 0);
                // Workaround for now:
                if (styleNode) {
                    styleNode.data = styleRule;
                } else {
                    avatarInfoStyles.appendChild(document.createTextNode(styleRule));
                }
            }
            // WARNING: nodeMatch relies on that there is no space before the starting "{"
            setStyle('div.editInfoMarker', '{ background-color: ' + color + '; }', '');
            setStyle('span.editInfoColor', '{ background-color: ' + color + '; }', '');
            setStyle('span.editInfoAuthor', '{ content: "' + name + '"; }', ':before');
            setStyle('dc|creator', '{ background-color: ' + color + '; }', '');
            setStyle('.webodf-selectionOverlay', '{ fill: ' + color + '; stroke: ' + color + ';}', '');
            if (memberId === localMemberId) {
                // Show selection handles for local user
                setStyle('.webodf-touchEnabled .webodf-selectionOverlay', '{ display: block; }', ' > .webodf-draggable');

                // Also set shadow cursor rules for local user
                memberId = gui.ShadowCursor.ShadowCursorMemberId;
                setStyle('.webodf-selectionOverlay', '{ fill: ' + color + '; stroke: ' + color + ';}', '');
                setStyle('.webodf-touchEnabled .webodf-selectionOverlay', '{ display: block; }', ' > .webodf-draggable');
            }
        }

        /**
         * @param {!Element} element
         * @param {!string} memberId
         * @param {!number} timestamp
         * @return {undefined}
         */
        function highlightEdit(element, memberId, timestamp) {
            var editInfo,
                editInfoMarker,
                id = '',
                editInfoNode = element.getElementsByTagNameNS(editInfons, 'editinfo').item(0);

            if (editInfoNode) {
                id = /**@type{!Element}*/(editInfoNode).getAttributeNS(editInfons, 'id');
                editInfoMarker = editInfoMap[id];
            } else {
                id = Math.random().toString();
                editInfo = new ops.EditInfo(element, session.getOdtDocument());
                editInfoMarker = new gui.EditInfoMarker(editInfo, showEditInfoMarkers);

                editInfoNode = /**@type{!Element}*/(element.getElementsByTagNameNS(editInfons, 'editinfo').item(0));
                editInfoNode.setAttributeNS(editInfons, 'id', id);
                editInfoMap[id] = editInfoMarker;
            }

            editInfoMarker.addEdit(memberId, new Date(timestamp));
        }

        /**
         * Updates the visibility on all existing editInfo entries
         * @param {!boolean} visible
         * @return {undefined}
         */
        function setEditInfoMarkerVisibility(visible) {
            var editInfoMarker,
                /**@type{string}*/
                keyname;

            for (keyname in editInfoMap) {
                if (editInfoMap.hasOwnProperty(keyname)) {
                    editInfoMarker = editInfoMap[keyname];
                    if (visible) {
                        editInfoMarker.show();
                    } else {
                        editInfoMarker.hide();
                    }
                }
            }
        }

        /**
         * Updates the visibility on all existing avatars
         * @param {!boolean} visible
         * @return {undefined}
         */
        function setCaretAvatarVisibility(visible) {
            caretManager.getCarets().forEach(function (caret) {
                if (visible) {
                    caret.showHandle();
                } else {
                    caret.hideHandle();
                }
            });
        }

        /**
         * Show edit information markers displayed near edited paragraphs
         * @return {undefined}
         */
        this.showEditInfoMarkers = function () {
            if (showEditInfoMarkers) {
                return;
            }

            showEditInfoMarkers = true;
            setEditInfoMarkerVisibility(showEditInfoMarkers);
        };

        /**
         * Hide edit information markers displayed near edited paragraphs
         * @return {undefined}
         */
        this.hideEditInfoMarkers = function () {
            if (!showEditInfoMarkers) {
                return;
            }

            showEditInfoMarkers = false;
            setEditInfoMarkerVisibility(showEditInfoMarkers);
        };

        /**
         * Show member avatars above the cursor
         * @return {undefined}
         */
        this.showCaretAvatars = function () {
            if (showCaretAvatars) {
                return;
            }

            showCaretAvatars = true;
            setCaretAvatarVisibility(showCaretAvatars);
        };

        /**
         * Hide member avatars above the cursor
         * @return {undefined}
         */
        this.hideCaretAvatars = function () {
            if (!showCaretAvatars) {
                return;
            }

            showCaretAvatars = false;
            setCaretAvatarVisibility(showCaretAvatars);
        };

        /**
         * @return {!ops.Session}
         */
        this.getSession = function () {
            return session;
        };
        /**
         * @param {!string} memberid
         * @return {?gui.Caret}
         */
        this.getCaret = function (memberid) {
            return caretManager.getCaret(memberid);
        };

        /**
         * @param {!ops.Member} member
         * @return {undefined}
         */
        function renderMemberData(member) {
            var memberId = member.getMemberId(),
                properties = member.getProperties();

            setAvatarInfoStyle(memberId, properties.fullName, properties.color);
        }

        /**
         * @param {!ops.OdtCursor} cursor
         * @return {undefined}
         */
        function onCursorAdded(cursor) {
            var memberId = cursor.getMemberId(),
                properties = session.getOdtDocument().getMember(memberId).getProperties(),
                caret;

            caretManager.registerCursor(cursor, showCaretAvatars, blinkOnRangeSelect);
            selectionViewManager.registerCursor(cursor, true);

            caret = caretManager.getCaret(memberId);
            if (caret) {
                caret.setAvatarImageUrl(properties.imageUrl);
                caret.setColor(properties.color);
            }
            runtime.log("+++ View here +++ eagerly created an Caret for '" + memberId + "'! +++");
        }

        /**
         * @param {!ops.OdtCursor} cursor
         * @return {undefined}
         */
        function onCursorMoved(cursor) {
            var memberId = cursor.getMemberId(),
                localSelectionView = selectionViewManager.getSelectionView(localMemberId),
                shadowSelectionView = selectionViewManager.getSelectionView(gui.ShadowCursor.ShadowCursorMemberId),
                localCaret = caretManager.getCaret(localMemberId);

            if (memberId === localMemberId) {
                // If our actual cursor moved, then hide the shadow cursor's selection
                shadowSelectionView.hide();
                if (localSelectionView) {
                    localSelectionView.show();
                }
                if (localCaret) {
                    localCaret.show();
                }
            } else if (memberId === gui.ShadowCursor.ShadowCursorMemberId) {
                // If the shadow cursor moved, then hide the current cursor's selection
                shadowSelectionView.show();
                if (localSelectionView) {
                    localSelectionView.hide();
                }
                if (localCaret) {
                    localCaret.hide();
                }
            }
        }

        /**
         * @param {!string} memberid
         * @return {undefined}
         */
        function onCursorRemoved(memberid) {
            selectionViewManager.removeSelectionView(memberid);
        }

        /**
         * @param {!{paragraphElement:!Element,memberId:string,timeStamp:number}} info
         * @return {undefined}
         */
        function onParagraphChanged(info) {
            highlightEdit(info.paragraphElement, info.memberId, info.timeStamp);
            highlightRefreshTask.trigger();
        }

        /**
         * @return {undefined}
         */
        function refreshHighlights() {
            var annotationViewManager = odfCanvas.getAnnotationViewManager();
            if (annotationViewManager) {
                annotationViewManager.rehighlightAnnotations();
                odtDocument.fixCursorPositions();
            }
        }

        function processConstraints() {
            var localMemberName,
                cssString,
                localMember;

            // TODO: Move such handling into AnnotationViewManager
            if (annotationConstraintStyles.hasChildNodes()) {
                core.DomUtils.removeAllChildNodes(annotationConstraintStyles);
            }

            if (sessionConstraints.getState(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN) === true) {
                localMember = session.getOdtDocument().getMember(localMemberId);
                if (localMember) {
                    localMemberName = localMember.getProperties().fullName;
                    cssString = ".annotationWrapper:not([creator = '" + localMemberName + "']) .annotationRemoveButton { display: none; }";
                    annotationConstraintStyles.appendChild(document.createTextNode(cssString));
                }
            }
        }

        /**
         * @param {!function(!Error=)} callback
         * @return {undefined}
         */
        function destroy(callback) {
            var /**@type{!Array.<!gui.EditInfoMarker>}*/
                editInfoArray = Object.keys(editInfoMap).map(function (keyname) {
                    return editInfoMap[keyname];
                });

            odtDocument.unsubscribe(ops.Document.signalMemberAdded, renderMemberData);
            odtDocument.unsubscribe(ops.Document.signalMemberUpdated, renderMemberData);
            odtDocument.unsubscribe(ops.Document.signalCursorAdded, onCursorAdded);
            odtDocument.unsubscribe(ops.Document.signalCursorRemoved, onCursorRemoved);
            odtDocument.unsubscribe(ops.OdtDocument.signalParagraphChanged, onParagraphChanged);
            odtDocument.unsubscribe(ops.Document.signalCursorMoved, onCursorMoved);

            odtDocument.unsubscribe(ops.OdtDocument.signalParagraphChanged, selectionViewManager.rerenderSelectionViews);
            odtDocument.unsubscribe(ops.OdtDocument.signalTableAdded, selectionViewManager.rerenderSelectionViews);
            odtDocument.unsubscribe(ops.OdtDocument.signalParagraphStyleModified, selectionViewManager.rerenderSelectionViews);

            sessionConstraints.unsubscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, processConstraints);
            odtDocument.unsubscribe(ops.Document.signalMemberAdded, processConstraints);
            odtDocument.unsubscribe(ops.Document.signalMemberUpdated, processConstraints);

            avatarInfoStyles.parentNode.removeChild(avatarInfoStyles);
            annotationConstraintStyles.parentNode.removeChild(annotationConstraintStyles);

            (function destroyEditInfo(i, err) {
                if (err) {
                    callback(err);
                } else {
                    if (i < editInfoArray.length) {
                        editInfoArray[i].destroy(function (err) {
                            destroyEditInfo(i + 1, err);
                        });
                    } else {
                        callback();
                    }
                }
            }(0, undefined));
        }

        /**
         * @param {!function(!Error=)} callback, passing an error object in case of error
         * @return {undefined}
         */
        this.destroy = function (callback) {
            var cleanup = [highlightRefreshTask.destroy, destroy];
            odtDocument.unsubscribe(ops.OdtDocument.signalAnnotationAdded, onAnnotationAdded);
            core.Async.destroyAll(cleanup, callback);
        };

        function init() {
            odtDocument = session.getOdtDocument();
            odfCanvas = odtDocument.getOdfCanvas();

            odtDocument.subscribe(ops.OdtDocument.signalAnnotationAdded, onAnnotationAdded);
            odtDocument.subscribe(ops.Document.signalMemberAdded, renderMemberData);
            odtDocument.subscribe(ops.Document.signalMemberUpdated, renderMemberData);
            odtDocument.subscribe(ops.Document.signalCursorAdded, onCursorAdded);
            odtDocument.subscribe(ops.Document.signalCursorRemoved, onCursorRemoved);
            odtDocument.subscribe(ops.OdtDocument.signalParagraphChanged, onParagraphChanged);
            odtDocument.subscribe(ops.Document.signalCursorMoved, onCursorMoved);

            odtDocument.subscribe(ops.OdtDocument.signalParagraphChanged, selectionViewManager.rerenderSelectionViews);
            odtDocument.subscribe(ops.OdtDocument.signalTableAdded, selectionViewManager.rerenderSelectionViews);
            odtDocument.subscribe(ops.OdtDocument.signalParagraphStyleModified, selectionViewManager.rerenderSelectionViews);

            sessionConstraints.subscribe(gui.CommonConstraints.EDIT.ANNOTATIONS.ONLY_DELETE_OWN, processConstraints);
            odtDocument.subscribe(ops.Document.signalMemberAdded, processConstraints);
            odtDocument.subscribe(ops.Document.signalMemberUpdated, processConstraints);

            // Add a css sheet for user info-edited styling
            avatarInfoStyles = newStyleSheet();
            avatarInfoStyles.appendChild(document.createTextNode('@namespace editinfo url(urn:webodf:names:editinfo);'));
            avatarInfoStyles.appendChild(document.createTextNode('@namespace dc url(http://purl.org/dc/elements/1.1/);'));
            // Add a css sheet for annotation constraint styling
            annotationConstraintStyles = newStyleSheet();
            processConstraints();

            highlightRefreshTask = core.Task.createRedrawTask(refreshHighlights);
        }
        init();
    };
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\ShadowCursor.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <aditya.bhatt@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, gui, ops, runtime*/

/**
 * @class
 * The ShadowCursor class provides a very minimal OdtCursor-like interface.
 * It does not insert anything into the DOM, and is useful mainly for
 * simulating a Cursor when you cannot/should not use a real cursor.
 * 
 * @constructor
 * @param {!ops.Document} document
 */
gui.ShadowCursor = function ShadowCursor(document) {
    "use strict";
    var /**@type{!Range}*/
        selectedRange = /**@type{!Range}*/(document.getDOMDocument().createRange()),
        forwardSelection = true;

    /*jslint emptyblock: true*/
    this.removeFromDocument = function () {};
    /*jslint emptyblock: false*/

    /**
     * Obtain the memberid the cursor is assigned to. For a shadow cursor,
     * this value is always gui.ShadowCursor.ShadowCursorMemberId
     * @return {string}
     */
    this.getMemberId = function () {
        return gui.ShadowCursor.ShadowCursorMemberId;
    };

    /**
     * Obtain the currently selected range to which the cursor corresponds.
     * @return {!Range}
     */
    this.getSelectedRange = function () {
        return selectedRange;
    };

    /**
     * Set the given range as the selected range for this cursor
     * @param {!Range} range
     * @param {boolean=} isForwardSelection Assumed to be true by default
     * @return {undefined}
     */
    this.setSelectedRange = function (range, isForwardSelection) {
        selectedRange = range;
        forwardSelection = isForwardSelection !== false;
    };

    /**
     * Returns if the selection of this cursor has the
     * same direction as the direction of the range
     * @return {boolean}
     */
    this.hasForwardSelection = function () {
        return forwardSelection;
    };

    /**
     * Obtain the document to which the cursor corresponds.
     * @return {!ops.Document}
     */
    this.getDocument = function () {
        return document;
    };

    /**
     * Gets the current selection type. For a shadow cursor, this value is always
     * ops.OdtCursor.RangeSelection
     * @return {!string}
     */
    this.getSelectionType = function () {
        return ops.OdtCursor.RangeSelection;
    };

    function init() {
        selectedRange.setStart(document.getRootNode(), 0);
    }
    init();
};

/** @const @type {!string} */gui.ShadowCursor.ShadowCursorMemberId = "";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SingleScrollViewport.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui*/

/**
 * Viewport controller for a single scroll pane capable of scrolling either
 * horizontally or vertically.
 *
 * @constructor
 * @implements {gui.Viewport}
 * @param {!HTMLElement} scrollPane
 */
gui.SingleScrollViewport = function(scrollPane) {
    "use strict";
    var VIEW_PADDING_PX = 5;

    /**
     * Pad the client rect with the supplied margin
     * @param {!core.SimpleClientRect} clientRect
     * @param {!core.SimpleClientRect} margin
     * @return {!core.SimpleClientRect}
     */
    function shrinkClientRectByMargin(clientRect, margin) {
        return {
            left:   clientRect.left + margin.left,
            top:    clientRect.top + margin.top,
            right:  clientRect.right - margin.right,
            bottom: clientRect.bottom - margin.bottom
        };
    }

    /**
     * @param {!core.SimpleClientRect} clientRect
     * @return {!number}
     */
    function height(clientRect) {
        return clientRect.bottom - clientRect.top;
    }

    /**
     * @param {!core.SimpleClientRect} clientRect
     * @return {!number}
     */
    function width(clientRect) {
        return clientRect.right - clientRect.left;
    }

    /**
     * @param {?core.SimpleClientRect} clientRect
     * @param {!boolean=} alignWithTop
     * @return {undefined}
     */
    this.scrollIntoView = function(clientRect, alignWithTop) {
        var verticalScrollbarHeight = scrollPane.offsetHeight - scrollPane.clientHeight,
            horizontalScrollbarWidth = scrollPane.offsetWidth - scrollPane.clientWidth,
            nonNullClientRect,
            scrollPaneRect = scrollPane.getBoundingClientRect(),
            /**@type{!core.SimpleClientRect}*/
            paneRect;

        if (!clientRect || !scrollPaneRect) {
            return;
        }

        nonNullClientRect = /**@type{!core.SimpleClientRect}*/(clientRect);

        // Visible area is slightly different from the BCR
        // See https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model/Determining_the_dimensions_of_elements
        paneRect = shrinkClientRectByMargin(/**@type{!core.SimpleClientRect}*/(scrollPaneRect), {
            top: VIEW_PADDING_PX,
            bottom: verticalScrollbarHeight + VIEW_PADDING_PX,
            left: VIEW_PADDING_PX,
            right: horizontalScrollbarWidth + VIEW_PADDING_PX
        });

        // Vertical adjustment
        if (alignWithTop || nonNullClientRect.top < paneRect.top) {
            // Scroll top down into view
            scrollPane.scrollTop -= paneRect.top - nonNullClientRect.top;
        } else if (nonNullClientRect.top > paneRect.bottom || nonNullClientRect.bottom > paneRect.bottom) {
            // Scroll top *up* into view, potentially including bottom if possible
            if (height(nonNullClientRect) <= height(paneRect)) {
                // Whole region fits vertically on-screen, so scroll bottom into view
                scrollPane.scrollTop += nonNullClientRect.bottom - paneRect.bottom;
            } else {
                // Only one end will fit on screen, so scroll the top as high as possible
                scrollPane.scrollTop += nonNullClientRect.top - paneRect.top;
            }
        }

        // Horizontal adjustment - Logic mirrors vertical adjustment
        if (nonNullClientRect.left < paneRect.left) {
            scrollPane.scrollLeft -= paneRect.left - nonNullClientRect.left;
        } else if (nonNullClientRect.right > paneRect.right) {
            if (width(nonNullClientRect) <= width(paneRect)) {
                scrollPane.scrollLeft += nonNullClientRect.right - paneRect.right;
            } else {
                scrollPane.scrollLeft -= paneRect.left - nonNullClientRect.left;
            }
        }
    };
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\StyleSummary.js
========================================================================

/**
 * Copyright (C) 2012-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, gui*/

/**
 * @constructor
 * @param {!Array.<!odf.Formatting.AppliedStyle>} styles
 */
gui.StyleSummary = function StyleSummary(styles) {
    "use strict";
    var propertyValues = {};

    /**
     * Get all values for the section + propertyName across all supplied styles. If a
     * one or more styles do not have a defined value for the specified propertyName, the
     * returned array will contain an "undefined" value to indicate the property is
     * missing on some of the styles.
     *
     * @param {!string} section Section (e.g., style:text-properties)
     * @param {!string} propertyName Property (e.g., fo:font-weight)
     * @return {!Array.<!string|undefined>}
     */
    function getPropertyValues(section, propertyName) {
        var cacheKey = section + "|" + propertyName,
            /**@type{Array.<!string>}*/values;
        if (!propertyValues.hasOwnProperty(cacheKey)) {
            values = [];
            styles.forEach(function (style) {
                var styleSection = /**@type{!Object.<!string, !string>}*/(style.styleProperties[section]),
                    value = styleSection && styleSection[propertyName];
                if (values.indexOf(value) === -1) {
                    values.push(value);
                }
            });
            propertyValues[cacheKey] = values;
        }
        return propertyValues[cacheKey];
    }
    this.getPropertyValues = getPropertyValues;

    /**
     * Create a lazily-loaded, cached lookup function that returns true if all section + propertyName
     * values are contained in the supplied acceptedPropertyValues array
     *
     * @param {!string} section Section (e.g., style:text-properties)
     * @param {!string} propertyName Property (e.g., fo:font-weight)
     * @param {!Array.<!string>} acceptedPropertyValues Array of accepted values
     * @return {!function():!boolean} Returns true if all values are in the accepted property values
     */
    function lazilyLoaded(section, propertyName, acceptedPropertyValues) {
        return function () {
            var existingPropertyValues = getPropertyValues(section, propertyName);
            // As a small optimization, check accepted vs. existing lengths first.
            // If there are more existing values than accepted, this function should return
            // false as there are definitely some non-acceptable values.
            return acceptedPropertyValues.length >= existingPropertyValues.length
                // Next, ensure each existing property value appears in the accepted properties array
                && existingPropertyValues.every(function (v) { return acceptedPropertyValues.indexOf(v) !== -1; });
        };
    }

    /**
     * Return the common value for a section + propertyName if it has an identical value in all
     * supplied styles. If there are multiple values, or one or more styles do not have either
     * the section or propertyName present, this function will return undefined.
     *
     * @param {!string} section Section (e.g., style:text-properties)
     * @param {!string} propertyName Property (e.g., fo:font-weight)
     * @return {string|undefined}
     */
    function getCommonValue(section, propertyName) {
        var values = getPropertyValues(section, propertyName);
        return values.length === 1 ? values[0] : undefined;
    }
    this.getCommonValue = getCommonValue;

    /**
     * Returns true if all styles specify text as bold; otherwise false.
     * @return {!boolean}
     */
    this.isBold = lazilyLoaded("style:text-properties", "fo:font-weight", ["bold"]);

    /**
     * Returns true if all styles specify text as italic; otherwise false.
     * @return {!boolean}
     */
    this.isItalic = lazilyLoaded("style:text-properties", "fo:font-style", ["italic"]);

    /**
     * Returns true if all styles specify text as underlined; otherwise false.
     * @return {!boolean}
     */
    this.hasUnderline = lazilyLoaded("style:text-properties", "style:text-underline-style", ["solid"]);

    /**
     * Returns true if all styles specify text as strike-through; otherwise false.
     * @return {!boolean}
     */
    this.hasStrikeThrough = lazilyLoaded("style:text-properties", "style:text-line-through-style", ["solid"]);

    /**
     * Returns the common font size in the supplied styles; otherwise undefined if there is no common font size
     * @return {number|undefined}
     */
    this.fontSize = function () {
        var stringFontSize = getCommonValue('style:text-properties', 'fo:font-size');
        return /**@type{number|undefined}*/(stringFontSize && parseFloat(stringFontSize)); // TODO: support other units besides pt!
    };

    /**
     * Returns the common font name in the supplied styles; otherwise undefined if there is no common font name
     * @return {string|undefined}
     */
    this.fontName = function () {
        return getCommonValue('style:text-properties', 'style:font-name');
    };

    /**
     * Returns true if all styles are left aligned; otherwise false.
     * @return {!boolean}
     */
    this.isAlignedLeft = lazilyLoaded("style:paragraph-properties", "fo:text-align", ["left", "start"]);

    /**
     * Returns true if all styles are center aligned; otherwise false.
     * @return {!boolean}
     */
    this.isAlignedCenter = lazilyLoaded("style:paragraph-properties", "fo:text-align", ["center"]);

    /**
     * Returns true if all styles are right aligned; otherwise false.
     * @return {!boolean}
     */
    this.isAlignedRight = lazilyLoaded("style:paragraph-properties", "fo:text-align", ["right", "end"]);

    /**
     * Returns true if all styles are justified; otherwise false.
     * @return {!boolean}
     */
    this.isAlignedJustified = lazilyLoaded("style:paragraph-properties", "fo:text-align", ["justify"]);
    /**
     * @type{!Object.<string,function():*>}
     */
    this.text = {
        isBold: this.isBold,
        isItalic: this.isItalic,
        hasUnderline: this.hasUnderline,
        hasStrikeThrough: this.hasStrikeThrough,
        fontSize: this.fontSize,
        fontName: this.fontName
    };
    /**
     * @type{!Object.<string,function():*>}
     */
    this.paragraph = {
        isAlignedLeft: this.isAlignedLeft,
        isAlignedCenter: this.isAlignedCenter,
        isAlignedRight: this.isAlignedRight,
        isAlignedJustified: this.isAlignedJustified
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\SvgSelectionView.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, NodeFilter, gui, odf, ops, runtime, core*/

/**
 *  A GUI class that attaches to a cursor and renders it's selection
 *  as an SVG polygon.
 * @constructor
 * @implements {core.Destroyable}
 * @implements {gui.SelectionView}
 * @param {!ops.OdtCursor} cursor
 */
gui.SvgSelectionView = function SvgSelectionView(cursor) {
    "use strict";

    var /**@type{!ops.Document}*/
        document = cursor.getDocument(),
        documentRoot, // initialized by addOverlay
        /**@type{!HTMLElement}*/
        sizer,
        doc = document.getDOMDocument(),
        svgns = "http://www.w3.org/2000/svg",
        overlay = doc.createElementNS(svgns, 'svg'),
        polygon = doc.createElementNS(svgns, 'polygon'),
        handle1 = doc.createElementNS(svgns, 'circle'),
        handle2 = doc.createElementNS(svgns, 'circle'),
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils,
        /**@type{!gui.ZoomHelper}*/
        zoomHelper = document.getCanvas().getZoomHelper(),
        /**@type{boolean}*/
        isVisible = true,
        positionIterator = cursor.getDocument().createPositionIterator(document.getRootNode()),
        /**@const*/
        FILTER_ACCEPT = NodeFilter.FILTER_ACCEPT,
        /**@const*/
        FILTER_REJECT = NodeFilter.FILTER_REJECT,
        /**@const*/
        HANDLE_RADIUS = 8,
        /**@type{!core.ScheduledTask}*/
        renderTask;

    /**
     * This evil little check is necessary because someone, not mentioning any names *cough*
     * added an extremely hacky undo manager that replaces the root node in order to go back
     * to a prior document state.
     * This makes things very sad, and kills baby kittens.
     * Unfortunately, no-one has had time yet to write a *real* undo stack... so we just need
     * to cope with it for now.
     */
    function addOverlay() {
        var newDocumentRoot = document.getRootNode();
        if (documentRoot !== newDocumentRoot) {
            documentRoot = newDocumentRoot;
            sizer = document.getCanvas().getSizer();
            sizer.appendChild(overlay);
            overlay.setAttribute('class', 'webodf-selectionOverlay');
            handle1.setAttribute('class', 'webodf-draggable');
            handle2.setAttribute('class', 'webodf-draggable');
            handle1.setAttribute('end', 'left');
            handle2.setAttribute('end', 'right');
            handle1.setAttribute('r', HANDLE_RADIUS);
            handle2.setAttribute('r', HANDLE_RADIUS);
            overlay.appendChild(polygon);
            overlay.appendChild(handle1);
            overlay.appendChild(handle2);
        }
    }

    /**
     * Returns true if the supplied range has 1 or more visible client rectangles.
     * A range might not be visible if it:
     * - contains only hidden nodes
     * - contains only collapsed whitespace (e.g., multiple whitespace characters will only display as 1 character)
     *
     * @param {!Range} range
     * @return {!boolean}
     */
    function isRangeVisible(range) {
        var bcr = range.getBoundingClientRect();
        return Boolean(bcr && bcr.height !== 0);
    }

    /**
     * Set the range to the last visible selection in the text nodes array
     * @param {!Range} range
     * @param {!Array.<!Element|!Text>} nodes
     * @return {!boolean}
     */
    function lastVisibleRect(range, nodes) {
        var nextNodeIndex = nodes.length - 1,
            node = nodes[nextNodeIndex],
            startOffset,
            endOffset;
        if (range.endContainer === node) {
            startOffset = range.endOffset;
        } else if (node.nodeType === Node.TEXT_NODE) {
            startOffset = node.length;
        } else {
            startOffset = node.childNodes.length;
        }
        endOffset = startOffset;
        range.setStart(node, startOffset);
        range.setEnd(node, endOffset);
        while (!isRangeVisible(range)) {
            if (node.nodeType === Node.ELEMENT_NODE && startOffset > 0) {
                // Extending start to cover character node. End offset remains unchanged
                startOffset = 0;
            } else if (node.nodeType === Node.TEXT_NODE && startOffset > 0) {
                // Extending start to include one more text char. End offset remains unchanged
                startOffset -= 1;
            } else if (nodes[nextNodeIndex]) {
                // Moving range to a new node. Start collapsed at last available point
                node = nodes[nextNodeIndex];
                nextNodeIndex -= 1;
                startOffset = endOffset = node.length || node.childNodes.length;
            } else {
                // Iteration complete. No more nodes left to explore
                return false;
            }
            range.setStart(node, startOffset);
            range.setEnd(node, endOffset);
        }
        return true;
    }

    /**
     * Set the range to the first visible selection in the text nodes array
     * @param {!Range} range
     * @param {!Array.<!Element|!Text>} nodes
     * @return {!boolean}
     */
    function firstVisibleRect(range, nodes) {
        var nextNodeIndex = 0,
            node = nodes[nextNodeIndex],
            startOffset = range.startContainer === node ? range.startOffset : 0,
            endOffset = startOffset;
        range.setStart(node, startOffset);
        range.setEnd(node, endOffset);
        while (!isRangeVisible(range)) {
            if (node.nodeType === Node.ELEMENT_NODE && endOffset < node.childNodes.length) {
                // Extending end to cover character node. Start offset remains unchanged
                endOffset = node.childNodes.length;
            } else if (node.nodeType === Node.TEXT_NODE && endOffset < node.length) {
                // Extending end to include one more text char. Start offset remains unchanged
                endOffset += 1;
            } else if (nodes[nextNodeIndex]) {
                // Moving range to a new node. Start collapsed at first available point
                node = nodes[nextNodeIndex];
                nextNodeIndex += 1;
                startOffset = endOffset = 0;
            } else {
                // Iteration complete. No more nodes left to explore
                return false;
            }
            range.setStart(node, startOffset);
            range.setEnd(node, endOffset);
        }
        return true;
    }

    /**
     * Returns the 'extreme' ranges for a range.
     * This returns 3 ranges, where the firstRange is attached to the first
     * position in the first text node in the original range,
     * the lastRange is attached to the last text node's last position,
     * and the fillerRange starts at the start of firstRange and ends at the end of
     * lastRange.
     * @param {!Range} range
     * @return {?{firstRange: !Range, lastRange: !Range, fillerRange: !Range}}
     */
    function getExtremeRanges(range) {
        var nodes = odfUtils.getTextElements(range, true, false),
            firstRange = /**@type {!Range}*/(range.cloneRange()),
            lastRange = /**@type {!Range}*/(range.cloneRange()),
            fillerRange = range.cloneRange();

        if (!nodes.length) {
            return null;
        }

        if (!firstVisibleRect(firstRange, nodes)) {
            return null;
        }

        if (!lastVisibleRect(lastRange, nodes)) {
            return null;
        }

        fillerRange.setStart(firstRange.startContainer, firstRange.startOffset);
        fillerRange.setEnd(lastRange.endContainer, lastRange.endOffset);

        return {
            firstRange: firstRange,
            lastRange: lastRange,
            fillerRange: fillerRange
        };
    }

    /**
     * Returns the bounding rectangle of two given rectangles
     * @param {!ClientRect|!{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}} rect1
     * @param {!ClientRect|!{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}} rect2
     * @return {!{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}}
     */
    function getBoundingRect(rect1, rect2) {
        var resultRect = {};
        resultRect.top = Math.min(rect1.top, rect2.top);
        resultRect.left = Math.min(rect1.left, rect2.left);
        resultRect.right = Math.max(rect1.right, rect2.right);
        resultRect.bottom = Math.max(rect1.bottom, rect2.bottom);
        resultRect.width = resultRect.right - resultRect.left;
        resultRect.height = resultRect.bottom - resultRect.top;
        return resultRect;
    }

    /**
     * Checks if the newRect is a collapsed rect, and if it is not,
     * returns the bounding rect of the originalRect and the newRect.
     * If it is collapsed, returns the originalRect.
     * Bad ad-hoc function, but I want to keep the size of the code smaller
     * @param {ClientRect|{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}} originalRect 
     * @param {ClientRect|{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}} newRect
     * @return {?ClientRect|{top: !number, left: !number, bottom: !number, right: !number, width: !number, height: !number}}
     */
    function checkAndGrowOrCreateRect(originalRect, newRect) {
        if (newRect && newRect.width > 0 && newRect.height > 0) {
            if (!originalRect) {
                originalRect = newRect;
            } else {
                originalRect = getBoundingRect(originalRect, newRect);
            }
        }
        return originalRect;
    }

    /**
     * Chrome's implementation of getBoundingClientRect is buggy in that it sometimes
     * includes the ClientRect of a partially covered parent in the bounding rect.
     * Therefore, instead of simply using getBoundingClientRect on the fillerRange,
     * we have to carefully compute our own filler rect.
     * This is done by climbing up the ancestries of both the startContainer and endContainer,
     * to just one level below the commonAncestorContainer. Then, we iterate between the
     * 'firstNode' and 'lastNode' and compute the bounding rect of all the siblings in between.
     * The resulting rect will have the correct width, but the height will be equal or greater than
     * what a correct getBoundingClientRect would give us. This is not a problem though, because
     * we only require the width of this filler rect; the top and bottom of the firstRect and lastRect
     * are enough for the rest.
     * This function also improves upon getBoundingClientRect in another way:
     * it computes the bounding rects of the paragraph nodes between the two ends, instead of the
     * bounding rect of the *range*. This means that unlike gBCR, the bounding rect will not cover absolutely
     * positioned children such as annotation nodes.
     * @param {!Range} fillerRange
     * @return {ClientRect|{top: number, left: number, bottom: number, right: number, width: number, height: number}}
     */
    function getFillerRect(fillerRange) {
        var containerNode = fillerRange.commonAncestorContainer,
            /**@type{!Node}*/
            firstNode = /**@type{!Node}*/(fillerRange.startContainer),
            /**@type{!Node}*/
            lastNode = /**@type{!Node}*/(fillerRange.endContainer),
            firstOffset = fillerRange.startOffset,
            lastOffset = fillerRange.endOffset,
            currentNode,
            lastMeasuredNode,
            firstSibling,
            lastSibling,
            grownRect = null,
            currentRect,
            range = doc.createRange(),
            /**@type{!core.PositionFilter}*/
            rootFilter,
            odfNodeFilter = new odf.OdfNodeFilter(),
            treeWalker;

        /**
         * This checks if the node is allowed by the odf filter and the root filter.
         * @param {!Node} node
         * @return {!number}
         */
        function acceptNode(node) {
            positionIterator.setUnfilteredPosition(node, 0);
            if (odfNodeFilter.acceptNode(node) === FILTER_ACCEPT
                    && rootFilter.acceptPosition(positionIterator) === FILTER_ACCEPT) {
                return FILTER_ACCEPT;
            }
            return FILTER_REJECT;
        }

        /**
         * If the node is acceptable, check if the node is a grouping element.
         * If yes, then get it's complete bounding rect (we should use the
         *getBoundingClientRect call on nodes whenever possible, since it is
         * extremely buggy on ranges. This has the added good side-effect of
         * not taking annotations' rects into the bounding rect.
         * @param {!Node} node
         * @return {?ClientRect}
         */
        function getRectFromNodeAfterFiltering(node) {
            var rect = null;
            // If the sibling is acceptable by the odfNodeFilter and the rootFilter,
            // only then take into account it's dimensions
            if (acceptNode(node) === FILTER_ACCEPT) {
                rect = domUtils.getBoundingClientRect(node);
            }
            return rect;
        }


        // If the entire range is for just one node
        // then we can get the bounding rect for the range and be done with it
        if (firstNode === containerNode || lastNode === containerNode) {
            range = fillerRange.cloneRange();
            grownRect = range.getBoundingClientRect();
            range.detach();
            return grownRect;
        }

        // Compute the firstSibling and lastSibling,
        // which are top-level siblings just below the common ancestor node
        firstSibling = firstNode;
        while (firstSibling.parentNode !== containerNode) {
            firstSibling = firstSibling.parentNode;
        }
        lastSibling = lastNode;
        while (lastSibling.parentNode !== containerNode) {
            lastSibling = lastSibling.parentNode;
        }

        // We use a root filter to avoid taking any rects of nodes in other roots
        // into the bounding rect, should it happen that the selection contains
        // nodes from more than one root. Example: Paragraphs containing annotations
        rootFilter = document.createRootFilter(firstNode);

        // Now since this function is called a lot of times,
        // we need to iterate between and not including the
        // first and last top-level siblings (below the common
        // ancestor), and grow our rect from their bounding rects.
        // This is cheap technique, compared to actually iterating
        // over each node in the range.
        currentNode = firstSibling.nextSibling;
        while (currentNode && currentNode !== lastSibling) {
            currentRect = getRectFromNodeAfterFiltering(currentNode);
            grownRect = checkAndGrowOrCreateRect(grownRect, currentRect);
            currentNode = currentNode.nextSibling;
        }

        // If the first top-level sibling is a paragraph, then use it's
        // bounding rect for growing. This is actually not very necessary, but
        // makes our selections look more intuitive and more native-ish.
        // Case in point: If you draw a selection starting on the last (half-full) line of
        // text in a paragraph and ending somewhere in the middle of the first line of
        // the next paragraph, the selection will be only as wide as the distance between
        // the start and end of the selection.
        // This is where we'd prefer full-width selections, therefore using the paragraph
        // width is nicer.
        // We don't need to look deeper into the node, so this is very cheap.
        if (odfUtils.isParagraph(firstSibling)) {
            grownRect = checkAndGrowOrCreateRect(grownRect, domUtils.getBoundingClientRect(firstSibling));
        } else if (firstSibling.nodeType === Node.TEXT_NODE) {
            currentNode = firstSibling;
            range.setStart(currentNode, firstOffset);
            range.setEnd(currentNode, currentNode === lastSibling ? lastOffset : /**@type{!Text}*/(currentNode).length);
            currentRect = range.getBoundingClientRect();
            grownRect = checkAndGrowOrCreateRect(grownRect, currentRect);
        } else {
            // The first top-level sibling was not a paragraph, so we now need to
            // Grow the rect in a detailed manner using the selected area *inside* the first sibling.
            // For that, we start walking over textNodes within the firstSibling,
            // and grow using the the rects of all textnodes that lie including and after the
            // firstNode (the startContainer of the original fillerRange), and stop
            // when either the firstSibling ends or we encounter the lastNode.
            treeWalker = doc.createTreeWalker(firstSibling, NodeFilter.SHOW_TEXT, acceptNode, false);
            currentNode = treeWalker.currentNode = firstNode;
            while (currentNode && currentNode !== lastNode) {
                range.setStart(currentNode, firstOffset);
                range.setEnd(currentNode, /**@type{!Text}*/(currentNode).length);

                currentRect = range.getBoundingClientRect();
                grownRect = checkAndGrowOrCreateRect(grownRect, currentRect);

                // We keep track of the lastMeasuredNode, so that the next block where
                // we iterate backwards can know when to stop.
                lastMeasuredNode = currentNode;
                firstOffset = 0;
                currentNode = treeWalker.nextNode();
            }
        }

        // If there was no lastMeasuredNode, it means that even the firstNode
        // was not iterated over.
        if (!lastMeasuredNode) {
            lastMeasuredNode = firstNode;
        }

        // Just like before, a cheap way to avoid looking deeper into the listSibling
        // if it is a paragraph.
        if (odfUtils.isParagraph(lastSibling)) {
            grownRect = checkAndGrowOrCreateRect(grownRect, domUtils.getBoundingClientRect(lastSibling));
        } else if (lastSibling.nodeType === Node.TEXT_NODE) {
            currentNode = lastSibling;
            range.setStart(currentNode, currentNode === firstSibling ? firstOffset : 0);
            range.setEnd(currentNode, lastOffset);
            currentRect = range.getBoundingClientRect();
            grownRect = checkAndGrowOrCreateRect(grownRect, currentRect);
        } else {
            // Grow the rect using the selected area inside
            // the last sibling, iterating backwards from the lastNode
            // till we reach either the beginning of the lastSibling
            // or encounter the lastMeasuredNode
            treeWalker = doc.createTreeWalker(lastSibling, NodeFilter.SHOW_TEXT, acceptNode, false);
            currentNode = treeWalker.currentNode = lastNode;
            while (currentNode && currentNode !== lastMeasuredNode) {
                range.setStart(currentNode, 0);
                range.setEnd(currentNode, lastOffset);

                currentRect = range.getBoundingClientRect();
                grownRect = checkAndGrowOrCreateRect(grownRect, currentRect);

                currentNode = treeWalker.previousNode();
                if (currentNode) {
                    lastOffset = /**@type{!Text}*/(currentNode).length;
                }
            }
        }

        return grownRect;
    }

    /**
     * Gets the clientRect of a range within a textNode, and
     * collapses the rect to the left or right edge, and returns it
     * @param {!Range} range
     * @param {boolean} useRightEdge
     * @return {{width:number,top:number,bottom:number,height:number,left:number,right:number}}
     */
    function getCollapsedRectOfTextRange(range, useRightEdge) {
        var clientRect = range.getBoundingClientRect(),
            collapsedRect = {};

        collapsedRect.width = 0;
        collapsedRect.top = clientRect.top;
        collapsedRect.bottom = clientRect.bottom;
        collapsedRect.height = clientRect.height;
        collapsedRect.left = collapsedRect.right = useRightEdge ? clientRect.right : clientRect.left;
        return collapsedRect;
    }

    /**
     * Resets and grows the polygon from the supplied
     * points.
     * @param {!Array.<{x: !number, y: !number}>} points
     * @return {undefined}
     */
    function setPoints(points) {
        var pointsString = "",
            i;

        for (i = 0; i < points.length; i += 1) {
            pointsString += points[i].x + "," + points[i].y + " ";
        }
        polygon.setAttribute('points', pointsString);
    }

    /**
     * Repositions overlay over the given selected range of the cursor. If the
     * selected range has no visible rectangles (as may happen if the selection only
     * encompasses collapsed whitespace, or does not span any ODT text elements), this
     * function will return false to indicate the overlay element can be hidden.
     *
     * @param {!Range} selectedRange
     * @return {!boolean} Returns true if the selected range is visible (i.e., height +
     *    width are non-zero), otherwise returns false
     */
    function repositionOverlays(selectedRange) {
        var rootRect = /**@type{!ClientRect}*/(domUtils.getBoundingClientRect(sizer)),
            zoomLevel = zoomHelper.getZoomLevel(),
            extremes = getExtremeRanges(selectedRange),
            firstRange,
            lastRange,
            fillerRange,
            firstRect,
            fillerRect,
            lastRect,
            left,
            right,
            top,
            bottom;

        // If the range is collapsed (no selection) or no extremes were found, do not show
        // any virtual selections.
        if (extremes) {
            firstRange = extremes.firstRange;
            lastRange = extremes.lastRange;
            fillerRange = extremes.fillerRange;

            firstRect = domUtils.translateRect(getCollapsedRectOfTextRange(firstRange, false), rootRect, zoomLevel);
            lastRect = domUtils.translateRect(getCollapsedRectOfTextRange(lastRange, true), rootRect, zoomLevel);
            fillerRect = getFillerRect(fillerRange);

            if (!fillerRect) {
                fillerRect = getBoundingRect(firstRect, lastRect);
            } else {
                fillerRect = domUtils.translateRect(fillerRect, rootRect, zoomLevel);
            }

            // These are the absolute bounding left, right, top, and bottom coordinates of the
            // entire selection.
            left = fillerRect.left;
            right = firstRect.left + Math.max(0, fillerRect.width - (firstRect.left - fillerRect.left));
            // We will use the topmost 'top' value, because if lastRect.top lies above
            // firstRect.top, then both are most likely on the same line, and font sizes
            // are different, so the selection should be taller.
            top = Math.min(firstRect.top, lastRect.top);
            bottom = lastRect.top + lastRect.height;

            // Now we grow the polygon by adding the corners one by one,
            // and finally we make sure that the last point is the same
            // as the first.

            setPoints([
                { x: firstRect.left,    y: top + firstRect.height   },
                { x: firstRect.left,    y: top                      },
                { x: right,             y: top                      },
                { x: right,             y: bottom - lastRect.height },
                { x: lastRect.right,    y: bottom - lastRect.height },
                { x: lastRect.right,    y: bottom                   },
                { x: left,              y: bottom                   },
                { x: left,              y: top + firstRect.height   },
                { x: firstRect.left,    y: top + firstRect.height   }
            ]);

            handle1.setAttribute('cx', firstRect.left);
            handle1.setAttribute('cy', top + firstRect.height / 2);
            handle2.setAttribute('cx', lastRect.right);
            handle2.setAttribute('cy', bottom - lastRect.height / 2);

            firstRange.detach();
            lastRange.detach();
            fillerRange.detach();
        }
        return Boolean(extremes);
    }

    /**
     * Update the visible selection, or hide if it should no
     * longer be visible
     * @return {undefined}
     */
    function rerender() {
        var range = cursor.getSelectedRange(),
            shouldShow;
        shouldShow = isVisible
                        && cursor.getSelectionType() === ops.OdtCursor.RangeSelection
                        && !range.collapsed;
        if (shouldShow) {
            addOverlay();
            shouldShow = repositionOverlays(range);
        }
        if (shouldShow) {
            overlay.style.display = "block";
        } else {
            overlay.style.display = "none";
        }
    }

    /**
     * @inheritDoc
     */
    this.rerender = function () {
        if (isVisible) {
            renderTask.trigger();
        }
    };

    /**
     * @inheritDoc
     */
    this.show = function () {
        isVisible = true;
        renderTask.trigger();
    };

    /**
     * @inheritDoc
     */
    this.hide = function () {
        isVisible = false;
        renderTask.trigger();
    };

    /**
     * @param {!gui.ShadowCursor|ops.OdtCursor} movedCursor
     * @return {undefined}
     */
    function handleCursorMove(movedCursor) {
        if (isVisible && movedCursor === cursor) {
            renderTask.trigger();
        }
    }

    /**
     * Scale handles to 1/zoomLevel,so they are
     * finger-friendly at every zoom level.
     * @param {!number} zoomLevel
     * @return {undefined}
     */
    function scaleHandles(zoomLevel) {
        var radius = HANDLE_RADIUS / zoomLevel;

        handle1.setAttribute('r', radius);
        handle2.setAttribute('r', radius);
    }

    /**
     * @param {function(!Object=)} callback
     */
    function destroy(callback) {
        sizer.removeChild(overlay);
        sizer.classList.remove('webodf-virtualSelections');
        cursor.getDocument().unsubscribe(ops.Document.signalCursorMoved, handleCursorMove);
        zoomHelper.unsubscribe(gui.ZoomHelper.signalZoomChanged, scaleHandles);
        callback();
    }

    /**
     * @inheritDoc
     * @param {function(!Error=)} callback
     */
    this.destroy = function (callback) {
        core.Async.destroyAll([renderTask.destroy, destroy], callback);
    };

    function init() {
        var editinfons = 'urn:webodf:names:editinfo',
            memberid = cursor.getMemberId();

        renderTask = core.Task.createRedrawTask(rerender);
        addOverlay();
        overlay.setAttributeNS(editinfons, 'editinfo:memberid', memberid);
        sizer.classList.add('webodf-virtualSelections');
        cursor.getDocument().subscribe(ops.Document.signalCursorMoved, handleCursorMove);
        zoomHelper.subscribe(gui.ZoomHelper.signalZoomChanged, scaleHandles);
        scaleHandles(zoomHelper.getZoomLevel());
    }

    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\TextController.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, ops, gui, odf, runtime*/

/**
 * @constructor
 * @implements {core.Destroyable}
 * @param {!ops.Session} session
 * @param {!gui.SessionConstraints} sessionConstraints
 * @param {!gui.SessionContext} sessionContext
 * @param {!string} inputMemberId
 * @param {function(!number, !number, !boolean):ops.Operation} directStyleOp
 * @param {function(!number):!Array.<!ops.Operation>} paragraphStyleOps
 */
gui.TextController = function TextController(
    session,
    sessionConstraints,
    sessionContext,
    inputMemberId,
    directStyleOp,
    paragraphStyleOps
    ) {
    "use strict";

    var odtDocument = session.getOdtDocument(),
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils,
        /**
         * @const
         * @type {!boolean}
         */
        BACKWARD = false,
        /**
         * @const
         * @type {!boolean}
         */
        FORWARD = true,
        isEnabled = false,
        /** @const */
        textns = odf.Namespaces.textns,
        /**@const*/
        NEXT = core.StepDirection.NEXT;

    /**
     * @return {undefined}
     */
    function updateEnabledState() {
        if (sessionConstraints.getState(gui.CommonConstraints.EDIT.REVIEW_MODE) === true) {
            isEnabled = /**@type{!boolean}*/(sessionContext.isLocalCursorWithinOwnAnnotation());
        } else {
            isEnabled = true;
        }
    }

    /**
     * @param {!ops.OdtCursor} cursor
     * @return {undefined}
     */
    function onCursorEvent(cursor) {
        if (cursor.getMemberId() === inputMemberId) {
            updateEnabledState();
        }
    }

    /**
     * @return {!boolean}
     */
    this.isEnabled = function () {
        return isEnabled;
    };

    /**
     * Return the equivalent cursor range of the specified DOM range.
     * This is found by rounding the range's start and end DOM points to the closest step as defined by the document's
     * position filter (and optionally the root filter as well).
     *
     * @param {!Range} range Range to convert to an equivalent cursor selection
     * @param {!Element} subTree Subtree to limit step searches within. E.g., limit to steps within a certain paragraph.
     * @param {!boolean} withRootFilter Specify true to restrict steps to be within the same root as the range's
     *      start container.
     * @return {!{position: !number, length: !number}}
     */
    function domToCursorRange(range, subTree, withRootFilter) {
        var filters = [odtDocument.getPositionFilter()],
            startStep,
            endStep,
            stepIterator;

        if (withRootFilter) {
            filters.push(odtDocument.createRootFilter(/**@type{!Node}*/(range.startContainer)));
        }

        stepIterator = odtDocument.createStepIterator(/**@type{!Node}*/(range.startContainer), range.startOffset,
                                                            filters, subTree);
        if (!stepIterator.roundToClosestStep()) {
            runtime.assert(false, "No walkable step found in paragraph element at range start");
        }
        startStep = odtDocument.convertDomPointToCursorStep(stepIterator.container(), stepIterator.offset());

        if (range.collapsed) {
            endStep = startStep;
        } else {
            stepIterator.setPosition(/**@type{!Node}*/(range.endContainer), range.endOffset);
            if (!stepIterator.roundToClosestStep()) {
                runtime.assert(false, "No walkable step found in paragraph element at range end");
            }
            endStep = odtDocument.convertDomPointToCursorStep(stepIterator.container(), stepIterator.offset());
        }
        return {
            position: /**@type{!number}*/(startStep),
            length: /**@type{!number}*/(endStep - startStep)
        };
    }

    /**
     * Creates operations to remove the provided selection and update the destination
     * paragraph's style if necessary.
     * @param {!Range} range
     * @return {!Array.<!ops.Operation>}
     */
    function createRemoveSelectionOps(range) {
        var firstParagraph,
            lastParagraph,
            mergedParagraphStyleName,
            previousParagraphStart,
            paragraphs = odfUtils.getParagraphElements(range),
            paragraphRange = /**@type{!Range}*/(range.cloneRange()),
            operations = [];

        // If the removal range spans several paragraphs, decide the final paragraph's style name.
        firstParagraph = paragraphs[0];
        if (paragraphs.length > 1) {
            if (odfUtils.hasNoODFContent(firstParagraph)) {
                // If the first paragraph is empty, the last paragraph's style wins, otherwise the first wins.
                lastParagraph = paragraphs[paragraphs.length - 1];
                mergedParagraphStyleName = lastParagraph.getAttributeNS(odf.Namespaces.textns, 'style-name') || "";

                // Side note:
                // According to https://developer.mozilla.org/en-US/docs/Web/API/element.getAttributeNS, if there is no
                // explicitly defined style, getAttributeNS might return either "" or null or undefined depending on the
                // implementation. Simplify the operation by combining all these cases to be ""
            } else {
                mergedParagraphStyleName = firstParagraph.getAttributeNS(odf.Namespaces.textns, 'style-name') || "";
            }
        }

        // Note, the operations are built up in reverse order to the paragraph DOM order. This prevents the need for
        // any translation of paragraph start limits as the last paragraph will be removed and merged first
        paragraphs.forEach(function(paragraph, index) {
            var paragraphStart,
                removeLimits,
                intersectionRange,
                removeOp,
                mergeOp;

            paragraphRange.setStart(paragraph, 0);
            paragraphRange.collapse(true);
            paragraphStart = domToCursorRange(paragraphRange, paragraph, false).position;
            if (index > 0) {
                mergeOp = new ops.OpMergeParagraph();
                mergeOp.init({
                    memberid: inputMemberId,
                    paragraphStyleName: mergedParagraphStyleName,
                    destinationStartPosition: previousParagraphStart,
                    sourceStartPosition: paragraphStart,
                    // For perf reasons, only the very last merge paragraph op should move the cursor
                    moveCursor: index === 1
                });
                operations.unshift(mergeOp);
            }
            previousParagraphStart = paragraphStart;

            paragraphRange.selectNodeContents(paragraph);
            // The paragraph limits will differ from the text remove limits if either
            // 1. the remove range starts within an different inline root such as within an annotation
            // 2. the remove range doesn't cover the entire paragraph (i.e., it starts or ends within the paragraph)
            intersectionRange = domUtils.rangeIntersection(paragraphRange, range);
            if (intersectionRange) {
                removeLimits = domToCursorRange(intersectionRange, paragraph, true);

                if (removeLimits.length > 0) {
                    removeOp = new ops.OpRemoveText();
                    removeOp.init({
                        memberid: inputMemberId,
                        position: removeLimits.position,
                        length: removeLimits.length
                    });
                    operations.unshift(removeOp);
                }
            }
        });

        return operations;
    }

    /**
     * Ensures the provided selection is a "forward" selection (i.e., length is positive)
     * @param {!{position: number, length: number}} selection
     * @return {!{position: number, length: number}}
     */
    function toForwardSelection(selection) {
        if (selection.length < 0) {
            selection.position += selection.length;
            selection.length = -selection.length;
        }
        return selection;
    }

    /**
     * Insert a paragraph break at the current cursor location. Will remove any currently selected text first
     * @return {!boolean}
     */
    this.enqueueParagraphSplittingOps = function() {
        if (!isEnabled) {
            return false;
        }

        var cursor = odtDocument.getCursor(inputMemberId),
            range = cursor.getSelectedRange(),
            selection = toForwardSelection(odtDocument.getCursorSelection(inputMemberId)),
            op,
            operations = [],
            styleOps,
            originalParagraph = /**@type{!Element}*/(odfUtils.getParagraphElement(cursor.getNode())),
            paragraphStyle = originalParagraph.getAttributeNS(textns, "style-name") || "";

        if (selection.length > 0) {
            operations = operations.concat(createRemoveSelectionOps(range));
        }

        op = new ops.OpSplitParagraph();
        op.init({
            memberid: inputMemberId,
            position: selection.position,
            paragraphStyleName: paragraphStyle,
            sourceParagraphPosition: odtDocument.convertDomPointToCursorStep(originalParagraph, 0, NEXT),
            moveCursor: true
        });
        operations.push(op);

        // disabled for now, because nowjs seems to revert the order of the ops, which does not work here TODO: grouping of ops
        /*
         if (isAtEndOfParagraph) {
            paragraphNode = odfUtils.getParagraphElement(odtDocument.getCursor(inputMemberId).getNode());
            nextStyleName = odtDocument.getFormatting().getParagraphStyleAttribute(styleName, odf.Namespaces.stylens, 'next-style-name');

            if (nextStyleName && nextStyleName !== styleName) {
                op = new ops.OpSetParagraphStyle();
                op.init({
                    memberid: inputMemberId,
                    position: position + 1, // +1 should be at the start of the new paragraph
                    styleName: nextStyleName
                });
                operations.push(op);
            }
         }
         */

        if (paragraphStyleOps) {
            styleOps = paragraphStyleOps(selection.position + 1);
            operations = operations.concat(styleOps);
        }
        session.enqueue(operations);
        return true;
    };

    /**
     * Checks if there are any walkable positions in the specified direction within
     * the current root, starting at the specified node.
     * The iterator is constrained within the root element for the current cursor position so
     * iteration will stop once the root is entirely walked in the requested direction
     * @param {!Element} cursorNode
     * @return {!core.StepIterator}
     */
    function createStepIterator(cursorNode) {
        var cursorRoot = odtDocument.getRootElement(cursorNode),
            filters = [odtDocument.getPositionFilter(), odtDocument.createRootFilter(cursorRoot)];

        return odtDocument.createStepIterator(cursorNode, 0, filters, cursorRoot);
    }

    /**
     * Remove the current selection, or if the cursor is collapsed, remove the next step
     * in the specified direction.
     *
     * @param {!boolean} isForward True indicates delete the next step. False indicates delete the previous step
     * @return {!boolean}
     */
    function removeTextInDirection(isForward) {
        if (!isEnabled) {
            return false;
        }

        var cursorNode,
            // Take a clone of the range as it will be modified if the selection length is 0
            range = /**@type{!Range}*/(odtDocument.getCursor(inputMemberId).getSelectedRange().cloneRange()),
            selection = toForwardSelection(odtDocument.getCursorSelection(inputMemberId)),
            stepIterator;

        if (selection.length === 0) {
            selection = undefined;
            cursorNode = odtDocument.getCursor(inputMemberId).getNode();
            stepIterator = createStepIterator(cursorNode);
            // There must be at least one more step in the root same root as the cursor node
            // in order to do something if there is no selected text
            // TODO Superstition alert - Step rounding is probably not necessary as cursor should always be at a step
            if (stepIterator.roundToClosestStep()
                    && (isForward ? stepIterator.nextStep() : stepIterator.previousStep())) {
                selection = toForwardSelection(odtDocument.convertDomToCursorRange({
                    anchorNode: cursorNode,
                    anchorOffset: 0,
                    focusNode: stepIterator.container(),
                    focusOffset: stepIterator.offset()
                }));
                if (isForward) {
                    range.setStart(cursorNode, 0);
                    range.setEnd(stepIterator.container(), stepIterator.offset());
                } else {
                    range.setStart(stepIterator.container(), stepIterator.offset());
                    range.setEnd(cursorNode, 0);
                }
            }
        }
        if (selection) {
            session.enqueue(createRemoveSelectionOps(range));
        }
        return selection !== undefined;
    }

    /**
     * Removes the currently selected content. If no content is selected and there is at least
     * one character to the left of the current selection, that character will be removed instead.
     * @return {!boolean}
     */
    this.removeTextByBackspaceKey = function () {
        return removeTextInDirection(BACKWARD);
    };

    /**
     * Removes the currently selected content. If no content is selected and there is at least
     * one character to the right of the current selection, that character will be removed instead.
     * @return {!boolean}
     */
    this.removeTextByDeleteKey = function () {
        return removeTextInDirection(FORWARD);
    };

    /**
     * Removes the currently selected content
     * @return {!boolean}
     */
    this.removeCurrentSelection = function () {
        if (!isEnabled) {
            return false;
        }

        var range = odtDocument.getCursor(inputMemberId).getSelectedRange();
        session.enqueue(createRemoveSelectionOps(range));
        return true; // The function is always considered handled, even if nothing is removed
    };

    /**
     * Removes currently selected text (if any) before inserting the supplied text.
     * @param {!string} text
     * @return {undefined}
     */
    function insertText(text) {
        if (!isEnabled) {
            return;
        }

        var range = odtDocument.getCursor(inputMemberId).getSelectedRange(),
            selection = toForwardSelection(odtDocument.getCursorSelection(inputMemberId)),
            op, stylingOp, operations = [], useCachedStyle = false;

        if (selection.length > 0) {
            operations = operations.concat(createRemoveSelectionOps(range));
            useCachedStyle = true;
        }

        op = new ops.OpInsertText();
        op.init({
            memberid: inputMemberId,
            position: selection.position,
            text: text,
            moveCursor: true
        });
        operations.push(op);
        if (directStyleOp) {
            stylingOp = directStyleOp(selection.position, text.length, useCachedStyle);
            if (stylingOp) {
                operations.push(stylingOp);
            }
        }
        session.enqueue(operations);
    }
    this.insertText = insertText;

    /**
     * @param {!function(!Error=)} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function (callback) {
        odtDocument.unsubscribe(ops.Document.signalCursorMoved, onCursorEvent);
        sessionConstraints.unsubscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, updateEnabledState);
        callback();
    };

    function init() {
        odtDocument.subscribe(ops.Document.signalCursorMoved, onCursorEvent);
        sessionConstraints.subscribe(gui.CommonConstraints.EDIT.REVIEW_MODE, updateEnabledState);
        updateEnabledState();
    }
    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\TrivialUndoManager.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui,ops,core,runtime*/

(function() {
"use strict";

var/**
    * Base for generating unique state ids
    * @type {!number}
    */
    stateIdBase = 0;

/**
 * Id for a document state in the Undo/Redo history
 * @constructor
 * @param {!number=} mainId
 * @param {!number=} subId
 */
function StateId(mainId, subId) {
    /**@type{!number}*/
    this.mainId = mainId !== undefined ? mainId : -1;

    /**@type{!number}*/
    this.subId = subId !== undefined ? subId : -1;
}

/**
 * Contains all operations done between two document states
 * in the Undo/Redo history.
 * Possible TODO: create a context for sharing the undoRules,
 * instead of passing them to all StateTransition instances
 * @constructor
 * @param {gui.UndoStateRules=} undoRules
 * @param {!Array.<!ops.Operation>=} initialOps
 * @param {!boolean=} editOpsPossible  Set to @true if the initialOps could contain edit ops.
 */
function StateTransition(undoRules, initialOps, editOpsPossible) {
    var /**@type{!number}*/
        nextStateId,
        /**@type{!Array.<!ops.Operation>}*/
        operations,
        /**@type{!number}*/
        editOpsCount;

    /**
     * @param {!ops.Operation} op
     * @return {undefined}
     */
    this.addOperation = function (op) {
        if (undoRules.isEditOperation(op)) {
            editOpsCount += 1;
        }
        operations.push(op);
    };

    /**
     * @param {!StateId} stateId
     * @return {!boolean}
     */
    this.isNextStateId = function (stateId) {
        return (stateId.mainId === nextStateId) && (stateId.subId === editOpsCount);
    };

    /**
     * @return {!StateId}
     */
    this.getNextStateId = function () {
        return new StateId(nextStateId, editOpsCount);
    };

    /**
     * @return {!Array.<!ops.Operation>}
     */
    this.getOperations = function () {
        return operations;
    };

    /**
     * @param {!number} count
     * @param {!ops.Operation} op
     * @return {!number}
     */
    function addEditOpsCount(count, op) {
        return count + (undoRules.isEditOperation(op) ? 1 : 0);
    }

    function init() {
        stateIdBase += 1;
        nextStateId = stateIdBase;

        operations = initialOps || [];

        editOpsCount = (initialOps && editOpsPossible) ? initialOps.reduce(addEditOpsCount, 0) : 0;
    }
    init();
}

/**
 * @param {gui.UndoStateRules=} defaultRules
 * @constructor
 * @implements gui.UndoManager
 */
gui.TrivialUndoManager = function TrivialUndoManager(defaultRules) {
    var self = this,
        cursorns = 'urn:webodf:names:cursor',
        domUtils = core.DomUtils,
        /**@type{?Element}*/
        initialDoc,
        /**@type{!StateTransition}*/
        initialStateTransition,
        playFunc,
        /**@type{!ops.Document}*/
        document,
        /**@type {!StateId}*/
        unmodifiedStateId,
        /**@type{!StateTransition}*/
        currentUndoStateTransition,
        /**@type{!Array.<!StateTransition>}*/
        undoStateTransitions = [],
        /**@type{!Array.<!StateTransition>}*/
        redoStateTransitions = [],
        eventNotifier = new core.EventNotifier([
            gui.UndoManager.signalUndoStackChanged,
            gui.UndoManager.signalUndoStateCreated,
            gui.UndoManager.signalUndoStateModified,
            gui.UndoManager.signalDocumentModifiedChanged,
            gui.TrivialUndoManager.signalDocumentRootReplaced
        ]),
        undoRules = defaultRules || new gui.UndoStateRules(),
        isExecutingOps = false;

    /**
     * @return {!boolean}
     */
    function isModified() {
        return currentUndoStateTransition.isNextStateId(unmodifiedStateId) !== true;
    }

    /**
     * Execute all operations in the supplied state transition
     * @param {!StateTransition} stateTransition
     * @return {undefined}
     */
    function executeOperations(stateTransition) {
        var operations = stateTransition.getOperations();

        if (operations.length > 0) {
            isExecutingOps = true; // Used to ignore operations received whilst performing an undo or redo
            playFunc(operations);
            isExecutingOps = false;
        }
    }

    function emitStackChange() {
        eventNotifier.emit(gui.UndoManager.signalUndoStackChanged, {
            undoAvailable: self.hasUndoStates(),
            redoAvailable: self.hasRedoStates()
        });
    }

    /**
     * @param {!boolean} oldModified
     * @return {undefined}
     */
    function emitDocumentModifiedChange(oldModified) {
        var newModified = isModified();
        if (oldModified !== newModified) {
            eventNotifier.emit(gui.UndoManager.signalDocumentModifiedChanged, newModified);
        }
    }

    /**
     * @return {!StateTransition}
     */
    function mostRecentUndoStateTransition() {
        return undoStateTransitions[undoStateTransitions.length - 1];
    }

    /**
     * Pushes the currentUndoStateTransition into the undoStateTransitions if necessary
     */
    function completeCurrentUndoState() {
        if (currentUndoStateTransition !== initialStateTransition // Initial state should never be in the undo stack
                && currentUndoStateTransition !== mostRecentUndoStateTransition()) {
            // undoStateTransitions may already contain the current undo state if the user
            // has moved backwards and then forwards in the undo stack
            undoStateTransitions.push(currentUndoStateTransition);
        }
    }

    /**
     * @param {!Node} node
     */
    function removeNode(node) {
        var sibling = node.previousSibling || node.nextSibling;
        node.parentNode.removeChild(node);
        domUtils.normalizeTextNodes(sibling);
    }

    /**
     * @param {!Element} root
     */
    function removeCursors(root) {
        domUtils.getElementsByTagNameNS(root, cursorns, "cursor").forEach(removeNode);
        domUtils.getElementsByTagNameNS(root, cursorns, "anchor").forEach(removeNode);
    }

    /**
     * Converts an object hash into an unordered array of its values
     * @param {!Object} obj
     * @return {!Array.<Object>}
     */
    function values(obj) {
        return Object.keys(obj).map(function (key) { return obj[key]; });
    }

    /**
     * Reduce the provided undo states to just unique AddCursor followed by
     * MoveCursor commands for each still-present cursor. This is used when
     * restoring the original document state at the start of an undo step
     * @param {!Array.<!StateTransition>} undoStateTransitions
     * @return {!StateTransition}
     */
    function extractCursorStates(undoStateTransitions) {
        var addCursor = {},
            moveCursor = {},
            requiredAddOps = {},
            remainingAddOps,
            ops,
            stateTransition = undoStateTransitions.pop();

        document.getMemberIds().forEach(function (memberid) {
            requiredAddOps[memberid] = true;
        });
        remainingAddOps = Object.keys(requiredAddOps).length;

        // Every cursor that is visible on the document will need to be restored
        // Only need the *last* move or add operation for each visible cursor, as the length & position
        // are absolute
        /**
         * @param {!ops.Operation} op
         */
        function processOp(op) {
            var spec = op.spec();
            if (!requiredAddOps[spec.memberid]) {
                return;
            }
            switch (spec.optype) {
            case "AddCursor":
                if (!addCursor[spec.memberid]) {
                    addCursor[spec.memberid] = op;
                    delete requiredAddOps[spec.memberid];
                    remainingAddOps -= 1;
                }
                break;
            case "MoveCursor":
                if (!moveCursor[spec.memberid]) {
                    moveCursor[spec.memberid] = op;
                }
                break;
            }
        }

        while (stateTransition && remainingAddOps > 0) {
            ops = stateTransition.getOperations();
            ops.reverse(); // Want the LAST move/add operation seen
            ops.forEach(processOp);
            stateTransition = undoStateTransitions.pop();
        }

        return new StateTransition(undoRules, values(addCursor).concat(values(moveCursor)));
    }

    /**
     * Subscribe to events related to the undo manager
     * @param {!string} signal
     * @param {!Function} callback
     */
    this.subscribe = function (signal, callback) {
        eventNotifier.subscribe(signal, callback);
    };

    /**
     * Unsubscribe to events related to the undo manager
     * @param {!string} signal
     * @param {!Function} callback
     */
    this.unsubscribe = function (signal, callback) {
        eventNotifier.unsubscribe(signal, callback);
    };


    /**
     * @return {!boolean}
     */
    this.isDocumentModified = isModified;

    /**
     * @param {!boolean} modified
     * @return {undefined}
     */
    this.setDocumentModified = function(modified) {
        // current state is already matching the new state?
        if (isModified() === modified) {
            return;
        }

        if (modified) {
            // set to invalid state
            unmodifiedStateId = new StateId();
        } else {
            unmodifiedStateId = currentUndoStateTransition.getNextStateId();
        }

        eventNotifier.emit(gui.UndoManager.signalDocumentModifiedChanged, modified);
    };

    /**
     * Returns true if there are one or more undo states available
     * @return {boolean}
     */
    this.hasUndoStates = function () {
        return undoStateTransitions.length > 0;
    };

    /**
     * Returns true if there are one or more redo states available
     * @return {boolean}
     */
    this.hasRedoStates = function () {
        return redoStateTransitions.length > 0;
    };

    /**
     * Set the OdtDocument to operate on
     * @param {!ops.Document} newDocument
     */
    this.setDocument = function (newDocument) {
        document = newDocument;
    };

    /**
     * @inheritDoc
     */
    this.purgeInitialState = function () {
        var oldModified = isModified();

        undoStateTransitions.length = 0;
        redoStateTransitions.length = 0;
        currentUndoStateTransition = initialStateTransition = new StateTransition(undoRules);
        unmodifiedStateId = currentUndoStateTransition.getNextStateId();
        initialDoc = null;
        emitStackChange();
        emitDocumentModifiedChange(oldModified);
    };

    function setInitialState() {
        var oldModified = isModified();

        initialDoc = document.cloneDocumentElement();
        // The current state may contain cursors if the initial state is modified whilst the document is in edit mode.
        // To prevent this issue, immediately purge all cursor nodes after cloning
        removeCursors(initialDoc);
        completeCurrentUndoState();
        // We just threw away the cursors in the snapshot, so need to recover all these operations so the
        // cursor can be re-inserted when an undo is performed
        // TODO the last move state may not reflect a valid position in the document!!!
        // E.g., add cursor, move to end, delete all content + saveInitialState
        currentUndoStateTransition = initialStateTransition = extractCursorStates([initialStateTransition].concat(undoStateTransitions));
        undoStateTransitions.length = 0;
        redoStateTransitions.length = 0;
        // update unmodifiedStateId if needed
        if (!oldModified) {
            unmodifiedStateId = currentUndoStateTransition.getNextStateId();
        }
        emitStackChange();
        emitDocumentModifiedChange(oldModified);
    }

    /**
     * @inheritDoc
     */
    this.setInitialState = setInitialState;

    /**
     * @inheritDoc
     */
    this.initialize = function () {
        if (!initialDoc) {
            setInitialState();
        }
    };

    /**
     * Sets the playback function to use to re-execute operations from the undo stack.
     * @param {!function(!Array.<!ops.Operation>)} playback_func
     */
    this.setPlaybackFunction = function (playback_func) {
        playFunc = playback_func;
    };

    /**
     * Track the execution of an operation, and add it to the available undo states
     * @param {!ops.Operation} op
     * @return {undefined}
     */
    this.onOperationExecuted = function (op) {
        if (isExecutingOps) {
            return; // Ignore new operations generated whilst performing an undo/redo
        }

        var oldModified = isModified();

        // An edit operation is assumed to indicate the end of the initial state. The user can manually
        // reset the initial state later with setInitialState if desired.
        // Additionally, an edit operation received when in the middle of the undo stack should also create a new state,
        // as the current undo state is effectively "sealed" and shouldn't gain additional document modifications.
        if ((undoRules.isEditOperation(op) && (currentUndoStateTransition === initialStateTransition || redoStateTransitions.length > 0))
                || !undoRules.isPartOfOperationSet(op, currentUndoStateTransition.getOperations())) {
            redoStateTransitions.length = 0; // Creating a new undo state should always reset the redo stack
            completeCurrentUndoState();
            currentUndoStateTransition = new StateTransition(undoRules, [op], true);
            // Every undo state *MUST* contain an edit for it to be valid for undo or redo
            undoStateTransitions.push(currentUndoStateTransition);
            eventNotifier.emit(gui.UndoManager.signalUndoStateCreated, { operations: currentUndoStateTransition.getOperations() });
            emitStackChange();
        } else {
            currentUndoStateTransition.addOperation(op);
            eventNotifier.emit(gui.UndoManager.signalUndoStateModified, { operations: currentUndoStateTransition.getOperations() });
        }

        emitDocumentModifiedChange(oldModified);
    };

    /**
     * Move forward the desired number of states. Will stop when the number of
     * states is reached, or no more redo states are available.
     * @param {!number} states
     * @return {!number} Returns the number of states actually moved
     */
    this.moveForward = function (states) {
        var moved = 0,
            oldModified = isModified(),
            redoOperations;

        while (states && redoStateTransitions.length) {
            redoOperations = redoStateTransitions.pop();
            undoStateTransitions.push(redoOperations);
            executeOperations(redoOperations);
            states -= 1;
            moved += 1;
        }

        if (moved) {
            // There is at least one undo stack now available due to the move forward
            // Reset the most recent undo state to receive new (non-edit) commands again
            currentUndoStateTransition = mostRecentUndoStateTransition();
            // Only report the stack has modified if moveForward actually did something
            emitStackChange();
            emitDocumentModifiedChange(oldModified);
        }
        return moved;
    };

    /**
     * Move backward the desired number of states. Will stop when the number of
     * states is reached, or no more undo states are available.
     * @param {!number} states
     * @return {!number} Returns the number of states actually moved
     */
    this.moveBackward = function (states) {
        var moved = 0,
            oldModified = isModified();

        while (states && undoStateTransitions.length) {
            redoStateTransitions.push(undoStateTransitions.pop());
            states -= 1;
            moved += 1;
        }

        if (moved) {
            // Need to reset the odt document cursor list back to nil so new cursors are correctly re-registered
            document.getMemberIds().forEach(function (memberid) {
                if (document.hasCursor(memberid)) {
                    document.removeCursor(memberid);
                }
            });
            // Only do actual work if moveBackward does something to the undo stacks
            document.setDocumentElement(/**@type{!Element}*/(initialDoc.cloneNode(true)));
            eventNotifier.emit(gui.TrivialUndoManager.signalDocumentRootReplaced, { });
            executeOperations(initialStateTransition);
            undoStateTransitions.forEach(executeOperations);

            // On a move back command, new ops should be subsequently
            // evaluated for inclusion in the initial state again. This will
            // collect other cursor movement events and store them.
            // Without this step, an undo will always reset cursor position
            // back to the start of the document
            currentUndoStateTransition = mostRecentUndoStateTransition() || initialStateTransition;
            emitStackChange();
            emitDocumentModifiedChange(oldModified);
        }
        return moved;
    };

    function init() {
        currentUndoStateTransition = initialStateTransition = new StateTransition(undoRules);
        unmodifiedStateId = currentUndoStateTransition.getNextStateId();
    }

    init();
};

/**@const*/ gui.TrivialUndoManager.signalDocumentRootReplaced = "documentRootReplaced";

}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\UndoManager.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, gui*/
/*jslint emptyblock: true, unparam: true*/

/**
 * @interface
 */
gui.UndoManager = function UndoManager() {"use strict"; };

/**
 * Subscribe to events related to the undo manager
 * @param {!string} signal
 * @param {!Function} callback
 */
gui.UndoManager.prototype.subscribe = function(signal, callback) {"use strict"; };

/**
 * Unsubscribe to events related to the undo manager
 * @param {!string} signal
 * @param {!Function} callback
 */
gui.UndoManager.prototype.unsubscribe = function(signal, callback) {"use strict"; };

/**
 * Set the Document to operate on
 * @param {!ops.Document} newDocument
 */
gui.UndoManager.prototype.setDocument = function (newDocument) {"use strict"; };

/**
 * Sets the initial document state and operation state. This is the earliest point
 * the document can be undone to.
 */
gui.UndoManager.prototype.setInitialState = function () {"use strict"; };

/**
 * Initializes the undo manager and creates the initial document
 * snapshot. If the undo manager has already been previously initialized,
 * this call will do nothing.
 */
gui.UndoManager.prototype.initialize = function () {"use strict"; };

/**
 * Purges entire undo stack including the initial state. This is primarily intended
 * to free up memory and resources when the undo state is no longer required.
 */
gui.UndoManager.prototype.purgeInitialState = function () {"use strict"; };

/**
 * Sets the playback function to use to re-execute operations from the undo stack.
 * @param {!function(!Array.<!ops.Operation>)} playback_func
 */
gui.UndoManager.prototype.setPlaybackFunction = function (playback_func) {"use strict"; };

/**
 * Returns true if there are one or more undo states available
 * @return {boolean}
 */
gui.UndoManager.prototype.hasUndoStates = function () {"use strict"; };

/**
 * Returns true if there are one or more redo states available
 * @return {boolean}
 */
gui.UndoManager.prototype.hasRedoStates = function () {"use strict"; };

/**
 * Move forward the desired number of states. Will stop when the number of
 * states is reached, or no more redo states are available.
 * @param {!number} states
 * @return {!number} Returns the number of states actually moved
 */
gui.UndoManager.prototype.moveForward = function (states) {"use strict"; };

/**
 * Move backward the desired number of states. Will stop when the number of
 * states is reached, or no more undo states are available.
 * @param {!number} states
 * @return {!number} Returns the number of states actually moved
 */
gui.UndoManager.prototype.moveBackward = function (states) {"use strict"; };

/**
 * Track the execution of an operation, and add it to the available undo states
 * @param {!ops.Operation} op
 * @return {undefined}
 */
gui.UndoManager.prototype.onOperationExecuted = function (op) {"use strict"; };

/**
 * Returns if the current state matches the unmodified state.
 * @return {!boolean}
 */
gui.UndoManager.prototype.isDocumentModified = function () {"use strict"; };

/**
 * Sets the current state of the document to be either the unmodified state
 * or a modified state.
 * @param {!boolean} modified
 * @return {undefined}
 */
gui.UndoManager.prototype.setDocumentModified = function(modified) {"use strict"; };

/**@const*/gui.UndoManager.signalUndoStackChanged = "undoStackChanged";
/**@const*/gui.UndoManager.signalUndoStateCreated = "undoStateCreated";
/**@const*/gui.UndoManager.signalUndoStateModified = "undoStateModified";
/**@const*/gui.UndoManager.signalDocumentModifiedChanged = "documentModifiedChanged";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\UndoStateRules.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, runtime*/

/**
 * This class attempts to implement undo/redo behaviour identical
 * to how LibreOffice behaves.
 *
 * State iteration rules are:
 * - Multiple text inserts in the same direction are treated as one state
 * - Multiple text removes in the same direction are treated as one state
 * - An Undo state always consumes all trailing cursor move operations
 * - An edit operation cannot follow non-edit operations. A state can
 *      start with non-edit operations if it contains no further edit ops.
 * @constructor
 */
gui.UndoStateRules = function UndoStateRules() {
    "use strict";

    /**
     * Return the first element from the end of the array that matches the supplied predicate.
     * Each subsequent call to previous will return the next element from the end of the array
     * that matches the predicate.
     * @constructor
     * @param {!Array.<!ops.Operation>} array
     * @param {!function(!ops.Operation):!boolean} predicate
     */
    function ReverseIterator(array, predicate) {
        var index = array.length;

        /**
         * Return the previous element in the array that matches the predicate
         * @return {?ops.Operation} Returns null when no more elements in the array match the predicate
         */
        this.previous = function () {
            for (index = index - 1; index >= 0; index -= 1) {
                if (predicate(array[index])) {
                    return array[index];
                }
            }
            return null;
        };
    }

    /**
     * @param {!ops.Operation} op
     * @return {string}
     */
    function getOpType(op) {
        return op.spec().optype;
    }

    /**
     * @param {!ops.Operation} op
     * @return {number|undefined}
     */
    function getOpPosition(op) {
        var key = "position",
            spec = op.spec(),
            value;
        if (spec.hasOwnProperty(key)) {
            value = /**@type{number}*/(spec[key]);
        }
        return value;
    }

    /**
     * Returns true if the supplied operation
     * is considered an editing operation.
     * @param {!ops.Operation} op
     * @return {!boolean} Returns true if the supplied op is an edit operation
     */
    function isEditOperation(op) {
        return op.isEdit;
    }
    this.isEditOperation = isEditOperation;

    /**
     * Returns true if the supplied optype is allowed to
     * aggregate multiple operations in a single undo or redo state
     * @param {!ops.Operation} op
     * @return {!boolean}
     */
    function canAggregateOperation(op) {
        switch (getOpType(op)) {
        case "RemoveText":
        case "InsertText":
            return true;
        default:
            return false;
        }
    }

    /**
     * Returns true if the newly supplied operation is continuing
     * in the same direction of travel as the recent edit operations
     * @param {!ops.Operation} thisOp
     * @param {!ops.Operation} lastEditOp
     * @param {!ops.Operation} secondLastEditOp
     * @return {!boolean}
     */
    function isSameDirectionOfTravel(thisOp, lastEditOp, secondLastEditOp) {
        // Note, the operations in the recent queue are most
        // recent to least recent. As such, the direction order
        // should be thisPos => existing2 => existing1
        var thisPosition = getOpPosition(thisOp),
            lastPosition = getOpPosition(lastEditOp),
            secondLastPosition = getOpPosition(secondLastEditOp),
            diffLastToSecondLast = lastPosition - secondLastPosition,
            diffThisToLast = thisPosition - lastPosition;
        // Next, the tricky part... determining the direction of travel
        // Each aggregate operation can have two directions of travel:
        // RemoveText:
        // - delete via backspace - direction will be -1 as cursor moves back
        // - delete via delete key - direction will be 0 as cursor doesn't move
        // InsertText:
        // - prepend text - direction will be 0 as cursor doesn't move
        // - append text - direction will be 1 as cursor moves forward

        return diffThisToLast === diffLastToSecondLast;
    }

    /**
     * Returns true if the two operations are considered adjacent.
     * @param {!ops.Operation} thisOp
     * @param {!ops.Operation} lastEditOp
     * @return {!boolean}
     */
    function isAdjacentOperation(thisOp, lastEditOp) {
        var positionDifference = getOpPosition(thisOp) - getOpPosition(lastEditOp);
        // RemoveText:
        // - delete via backspace - direction will be -1 as cursor moves back
        // - delete via delete key - direction will be 0 as cursor doesn't move
        // InsertText:
        // - prepend text - direction will be 0 as cursor doesn't move
        // - append text - direction will be 1 as cursor moves forward
        return positionDifference === 0 || Math.abs(positionDifference) === 1;
    }

    /**
     *
     * @param {!ops.Operation} thisOp
     * @param {!ops.Operation} lastEditOp
     * @param {?ops.Operation} secondLastEditOp
     * @return {!boolean}
     */
    function continuesOperations(thisOp, lastEditOp, secondLastEditOp) {
        if (!secondLastEditOp) {
            // No previous edit operations, so can't calculate a direction of travel.
            // Just check new op is adjacent to existing op
            return isAdjacentOperation(thisOp, lastEditOp);
        }
        return isSameDirectionOfTravel(thisOp, lastEditOp, secondLastEditOp);
    }

    /**
     * Returns true if thisOp can be grouped together with the most recent edit operations.
     *
     * For an operation to be considered continuous it must:
     * - Be of a type that supports aggregation (e.g., insert text or remove text)
     * - Be of the same type as the most recent edit operation
     * - Be considered adjacent (and in the same direction as) the most recent edit operation
     *
     * @param {!ops.Operation} thisOp
     * @param {!Array.<!ops.Operation>} recentOperations
     * @return {!boolean}
     */
    function continuesMostRecentEditOperation(thisOp, recentOperations) {
        var thisOpType = getOpType(thisOp),
            editOpsFinder = new ReverseIterator(recentOperations, isEditOperation),
            lastEditOp = editOpsFinder.previous();

        runtime.assert(Boolean(lastEditOp), "No edit operations found in state");
        if (thisOpType === getOpType(/**@type{!ops.Operation}*/(lastEditOp))) {
            // Operation type is identical, so check if these operations are continuous
            return continuesOperations(thisOp, /**@type{!ops.Operation}*/(lastEditOp), editOpsFinder.previous());
        }
        return false;
    }

    /**
     * Returns true if thisOp can be grouped together with the most recent edit operations group.
     *
     * For an operation to be considered continuous it must:
     * - Be of a type that supports aggregation (e.g., insert text or remove text)
     * - Be continuous with the most recent edit operation of the same type in the most recent operations group
     *   (see isContinuousWithExistingOperation for the definition of "continuous")
     *
     * @param {!ops.Operation} thisOp
     * @param {!Array.<!ops.Operation>} recentOperations
     * @return {!boolean}
     */
    function continuesMostRecentEditGroup(thisOp, recentOperations) {
        var thisOpType = getOpType(thisOp),
            editOpsFinder = new ReverseIterator(recentOperations, isEditOperation),
            candidateOp = editOpsFinder.previous(),
            lastEditOp,
            secondLastEditOp = null,
            inspectedGroupsCount,
            groupId;

        runtime.assert(Boolean(candidateOp), "No edit operations found in state");
        groupId = candidateOp.group;
        runtime.assert(groupId !== undefined, "Operation has no group");
        inspectedGroupsCount = 1; // Need to keep track of how many edit groups have been inspected

        // Check if the current operation continues any operation in the latest group
        while (candidateOp && candidateOp.group === groupId) {
            if (thisOpType === getOpType(candidateOp)) {
                // A matching edit operation was found in the most recent edit group
                lastEditOp = candidateOp;
                break;
            }
            candidateOp = editOpsFinder.previous();
        }

        if (lastEditOp) {
            // Now try and find a second operation of the same type in either of the most recent two edit groups
            candidateOp = editOpsFinder.previous();
            while (candidateOp) {
                if (candidateOp.group !== groupId) {
                    if (inspectedGroupsCount === 2) {
                        // No second compatible op was found within two edit groups, so abandon searching for more
                        // and check continuity against lastEditOp only
                        break;
                    }
                    groupId = candidateOp.group;
                    inspectedGroupsCount += 1;
                }
                if (thisOpType === getOpType(candidateOp)) {
                    // Found an operation of the same type within the last two edit groups on the stack
                    secondLastEditOp = candidateOp;
                    break;
                }
                candidateOp = editOpsFinder.previous();
            }
            return continuesOperations(thisOp, /**@type{!ops.Operation}*/(lastEditOp), secondLastEditOp);
        }
        return false;
    }

    /**
     * Returns true if the provided operation is part of the existing
     * set of operations according to the undo rules
     * @param {!ops.Operation} operation
     * @param {!Array.<!ops.Operation>} recentOperations
     * @return {!boolean}
     */
    function isPartOfOperationSet(operation, recentOperations) {
        var areOperationsGrouped = operation.group !== undefined, // Expect groups to be consistently used (if in use at all)
            lastOperation;
        if (!isEditOperation(operation)) {
            // Non-edit operations always get appended to the existing undo state
            // this covers things such as move cursor ops
            return true;
        }
        if (recentOperations.length === 0) {
            // This is the first operation of a pristine state
            return true;
        }
        lastOperation = recentOperations[recentOperations.length - 1];
        if (areOperationsGrouped && operation.group === lastOperation.group) {
            // Operation groups match, so these were queued as a group
            return true;
        }
        if (canAggregateOperation(operation) && recentOperations.some(isEditOperation)) {
            // The are existing edit operations. Check if the current op can be combined with existing operations
            // E.g., multiple insert text or remove text ops
            if (areOperationsGrouped) {
                return continuesMostRecentEditGroup(operation, recentOperations);
            }
            return continuesMostRecentEditOperation(operation, recentOperations);
        }
        // The following are all true at this point:
        // - new operation is an edit operation (check 1)
        // - existing undo state has at least one existing operation (check 2)
        // - new operation is not part of most recent operation group (check 3)
        // - new operation is not continuous with the existing edit operations (check 4 + 5)
        return false;
    }
    this.isPartOfOperationSet = isPartOfOperationSet;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\Viewport.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui*/
/*jslint emptyblock: true, unparam: true*/

/**
 * @interface
 */
gui.Viewport = function Viewport() { "use strict"; };

/**
 * Scroll the specified client rectangle into the viewport. No scrolling
 * will occur if the clientRect is already visible, is null, or the scroll pane
 * itself is invisible.
 *
 * If the clientRect is larger than the available scroll height, as much of the
 * rect will be shown in the view as possible whilst ensuring the top is still
 * on screen. Similar logic applies if the clientRect width is too large.
 *
 * @param {?core.SimpleClientRect} clientRect
 * @param {!boolean=} alignWithTop Align the clientRect to the top of the viewport. If unspecified or false, the
 *  view will scroll only as much as required to bring the clientRect into view.
 * @return {undefined}
 */
gui.Viewport.prototype.scrollIntoView = function(clientRect, alignWithTop) { "use strict"; };
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\VisualStepScanner.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui*/
/*jslint emptyblock:true, unparam:true*/

/**
 * @constructor
 * @struct
 */
gui.StepInfo = function() { "use strict"; };

/**
 * Visual step iteration direction, taking into account
 * whether the text block is right-to-left or left to right.
 *
 * For left-to-right languages, this maps onto
 * core.StepDirection as:
 *  LEFT_TO_RIGHT = NEXT
 *  RIGHT_TO_LEFT = PREV
 *
 * @enum {!number}
 */
gui.StepInfo.VisualDirection = {
    LEFT_TO_RIGHT: 0,
    RIGHT_TO_LEFT: 1
};

/**
 * @type {!core.StepIterator.StepSnapshot}
 */
gui.StepInfo.prototype.token;

/**
 * @return {!Element|!Text}
 */
gui.StepInfo.prototype.container = function() { "use strict"; };

/**
 * @return {!number}
 */
gui.StepInfo.prototype.offset = function() { "use strict"; };

/**
 * The direction of iteration from previous to next rect.
 *
 * @type {!core.StepDirection}
 */
gui.StepInfo.prototype.direction;

/**
 * The visual direction of iteration accounting for right-to-left
 * languages.
 *
 * @type {!gui.StepInfo.VisualDirection}
 */
gui.StepInfo.prototype.visualDirection;

/**
 * Scanners are stateful objects that are used to locate a step matching certain
 * parameters within a sequence. This a similar concept to lexical scanners.
 *
 * As these are stateful objects, a new instance should be created for every use.
 * @interface
 */
gui.VisualStepScanner = function() { "use strict"; };

/**
 * Token for the last step accepted by this scanner
 * @type {?core.StepIterator.StepSnapshot|undefined}
 */
gui.VisualStepScanner.prototype.token;

/**
 * @param {!gui.StepInfo} stepInfo
 * @param {?ClientRect} previousRect
 * @param {?ClientRect} nextRect
 * @return {!boolean} Return true in terminate iteration
 */
gui.VisualStepScanner.prototype.process = function(stepInfo, previousRect, nextRect) { "use strict"; };
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\gui\ZoomHelper.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, gui*/

(function () {
    "use strict";

    /**
     * @constructor
     * @param {!number} x
     * @param {!number} y
     */
    function Point(x, y) {
        var self = this;
        /**
         * @param {!Point} point
         * @return {!number}
         */
        this.getDistance = function (point) {
            var xOffset = self.x - point.x,
                yOffset = self.y - point.y;
            return Math.sqrt(xOffset * xOffset + yOffset * yOffset);
        };

        /**
         * @param {!Point} point
         * @return {!Point}
         */
        this.getCenter = function (point) {
            return new Point((self.x + point.x) / 2, (self.y + point.y) / 2);
        };

        /**@type{!number}*/
        this.x;
        /**@type{!number}*/
        this.y;
        function init() {
            self.x = x;
            self.y = y;
        }
        init();
    }

    /**
     * ZoomHelper handles touch gestures and provides pinch-to-zoom support
     * on the sizer element. It also provides some methods to set, get, and
     * subscribe to the current zoom level.
     * @constructor
     * @implements {core.Destroyable}
     */
    gui.ZoomHelper = function () {
        var /**@type{!HTMLElement}*/
            zoomableElement,
            /**@type{!Point}*/
            panPoint,
            /**@type{!Point}*/
            previousPanPoint,
            /**@type{!number}*/
            firstPinchDistance,
            /**@type{!number}*/
            zoom,
            /**@type{!number}*/
            previousZoom,
            maxZoom = 4.0,
            /**@type{!HTMLElement}*/
            offsetParent,
            /**@type{!HTMLElement}*/
            parentElement,
            events = new core.EventNotifier([gui.ZoomHelper.signalZoomChanged]),
            /**@const*/
            gestures = {
                NONE: 0,
                SCROLL: 1,
                PINCH: 2
            },
            /**@type{!number}*/
            currentGesture = gestures.NONE,
            /**
             * On webkit, which has the ability to style scrollbars
             * with CSS, `window` has the property 'ontouchstart'.
             * This can be used as a hint of touch event support,
             * and we can take advantage of that to decide to show
             * custom scrollbars (because webkit hides them).
             * @type{!boolean}
             */
            requiresCustomScrollBars = runtime.getWindow().hasOwnProperty('ontouchstart'),
            /**@type{?string}*/
            parentOverflow = "";

        /**
         * Apply a 3D or 2D CSS transform with the given
         * x and y offset, and scale.
         * @param {!number} x
         * @param {!number} y
         * @param {!number} scale
         * @param {!boolean} is3D
         * @return {undefined}
         */
        function applyCSSTransform(x, y, scale, is3D) {
            var transformCommand;

            if (is3D) {
                transformCommand = 'translate3d(' + x + 'px, ' + y + 'px, 0) scale3d(' + scale + ', ' + scale + ', 1)';
            } else {
                transformCommand = 'translate(' + x + 'px, ' + y + 'px) scale(' + scale + ')';
            }

            zoomableElement.style.WebkitTransform = transformCommand;
            zoomableElement.style.MozTransform = transformCommand;
            zoomableElement.style.msTransform = transformCommand;
            zoomableElement.style.OTransform = transformCommand;
            zoomableElement.style.transform = transformCommand;
        }

        /**
         * Apply the current computed transform
         * (including pan and zoom)
         * @param {!boolean} is3D
         * @return {undefined}
         */
        function applyTransform(is3D) {
            if (is3D) {
                applyCSSTransform(-panPoint.x, -panPoint.y, zoom, true);
            } else {
                // It tends to feel smoother (with less flicker)
                // if we apply a fast transform first and then a
                // detailed transform.
                // A detailed (2d) transform is only done 'at rest',
                // therefore ignore the panning value, because
                // the positioning is handled by scrollbars in that case.
                applyCSSTransform(0, 0, zoom, true);
                applyCSSTransform(0, 0, zoom, false);
            }
        }

        /**
         * Applies the current computed zoom & pan
         * as a quick-and-dirty rendering, to be used
         * during a gesture or when a flicker needs
         * to be masked.
         * @return {undefined}
         */
        function applyFastTransform() {
            applyTransform(true);
        }

        /**
         * Applies the current zoom as a detailed
         * rendering. This is a slow call to be done
         * post-gesture.
         * @return {undefined}
         */
        function applyDetailedTransform() {
            applyTransform(false);
        }

        /**
         * Enable or disable virtual scrollbars on the container.
         * @param {!boolean} enable
         * @return {undefined}
         */
        function enableScrollBars(enable) {
            if (!offsetParent || !requiresCustomScrollBars) {
                return;
            }

            var initialOverflow = offsetParent.style.overflow,
                enabled = offsetParent.classList.contains('webodf-customScrollbars');

            if ((enable && enabled) || (!enable && !enabled)) {
                return;
            }

            if (enable) {
                offsetParent.classList.add('webodf-customScrollbars');
                // The custom scrollbar does not appear in webkit unless a full redraw
                // of the scrollable area is forced. Therefore attempt to toggle the
                // overflow stle of the scrolling container across successive animation
                // frames.
                offsetParent.style.overflow = 'hidden';
                runtime.requestAnimationFrame(function () {
                    offsetParent.style.overflow = initialOverflow;
                });
            } else {
                offsetParent.classList.remove('webodf-customScrollbars');
            }
        }


        /**
         * Sets the scrolling of the container to (0,0)
         * so that transforms and event points can be
         * conveniently computed.
         * Applies a quick transform to make it look like
         * this never happened.
         * @return {undefined}
         */
        function removeScroll() {
            applyCSSTransform(-panPoint.x, -panPoint.y, zoom, true);
            offsetParent.scrollLeft = 0;
            offsetParent.scrollTop = 0;
            parentOverflow = parentElement.style.overflow;
            parentElement.style.overflow = "visible";
            enableScrollBars(false);
        }

        /**
         * Restores the scrollTop and scrollLeft of
         * the container to the x and y pan values.
         * Applies a quick transform to make it look like
         * this never happened.
         * @return {undefined}
         */
        function restoreScroll() {
            applyCSSTransform(0, 0, zoom, true);
            offsetParent.scrollLeft = panPoint.x;
            offsetParent.scrollTop = panPoint.y;
            parentElement.style.overflow = parentOverflow || "";
            enableScrollBars(true);
        }

        /**
         * Returns a Point instance for a given touch.
         * @param {!Touch} touch
         * @return {!Point}
         */
        function getPoint(touch) {
            return new Point(touch.pageX - zoomableElement.offsetLeft, touch.pageY - zoomableElement.offsetTop);
        }

        /**
         * Returns the closest point to the given point
         * within the boundaries of the zoomable element,
         * such that it never causes panning outside
         * the viewport.
         * @param {!Point} point
         * @return {!Point}
         */
        function sanitizePointForPan(point) {
            return new Point(
                Math.min(Math.max(point.x, zoomableElement.offsetLeft), (zoomableElement.offsetLeft + zoomableElement.offsetWidth) * zoom - offsetParent.clientWidth),
                Math.min(Math.max(point.y, zoomableElement.offsetTop), (zoomableElement.offsetTop + zoomableElement.offsetHeight) * zoom - offsetParent.clientHeight)
            );
        }

        /**
         * Takes a point in page coordinates and pans towards it
         * @param {!Point} point
         * @return {undefined}
         */
        function processPan(point) {
            if (previousPanPoint) {
                panPoint.x -= point.x - previousPanPoint.x;
                panPoint.y -= point.y - previousPanPoint.y;
                panPoint = sanitizePointForPan(panPoint);
            }
            previousPanPoint = point;
        }

        /**
         * Takes a point and a relative zoom factor,
         * with which the panPoint is accordingly updated
         * to reflect the new zoom center, and the current
         * zoom level is multiplied by the relative factor.
         * Useful for when the zoom is dynamically being changed
         * during a gesture.
         * This does not zoom beyond a minimum reasonable zoom
         * level. Since we assume that gestures are for a
         * mobile device, it makes some sense to not allow
         * shrinking of a document to a width less than the container's
         * width. Also easier for computation of pan coordinates.
         * @param {!Point} zoomPoint
         * @param {!number} incrementalZoom
         * @return {undefined}
         */
        function processZoom(zoomPoint, incrementalZoom) {
            var originalZoom = zoom,
                actuallyIncrementedZoom,
                minZoom = Math.min(maxZoom, zoomableElement.offsetParent.clientWidth / zoomableElement.offsetWidth);

            zoom = previousZoom * incrementalZoom;
            zoom = Math.min(Math.max(zoom, minZoom), maxZoom);
            actuallyIncrementedZoom = zoom / originalZoom;

            panPoint.x += (actuallyIncrementedZoom - 1) * (zoomPoint.x + panPoint.x);
            panPoint.y += (actuallyIncrementedZoom - 1) * (zoomPoint.y + panPoint.y);
        }

        /**
         * @param {!Point} point1
         * @param {!Point} point2
         * @return {undefined}
         */
        function processPinch(point1, point2) {
            var zoomPoint = point1.getCenter(point2),
                pinchDistance = point1.getDistance(point2),
                incrementalZoom = pinchDistance / firstPinchDistance;

            processPan(zoomPoint);
            processZoom(zoomPoint, incrementalZoom);
        }

        /**
         * @param {!TouchEvent} event
         * @return {undefined}
         */
        function prepareGesture(event) {
            var fingers = event.touches.length,
                point1 = fingers > 0 ? getPoint(event.touches[0]) : null,
                point2 = fingers > 1 ? getPoint(event.touches[1]) : null;

            if (point1 && point2) {
                // Compute the first pinch distance for later comparison against
                // fresh pinch distances during gesture processing, the ratio
                // of which represents the relative-to-current zoom level.
                firstPinchDistance = point1.getDistance(point2);
                previousZoom = zoom;
                previousPanPoint = point1.getCenter(point2);
                // Assuming this is the start of a pinch gesture,
                // therefore scroll to (0,0) for easy computing.
                removeScroll();
                currentGesture = gestures.PINCH;
            } else if (point1) {
                previousPanPoint = point1;
                currentGesture = gestures.SCROLL;
            }
        }

        /**
         * @param {!TouchEvent} event
         * @return {undefined}
         */
        function processGesture(event) {
            var fingers = event.touches.length,
                point1 = fingers > 0 ? getPoint(event.touches[0]) : null,
                point2 = fingers > 1 ? getPoint(event.touches[1]) : null;

            if (point1 && point2) {
                // Prevent default behavior of panning when a pinch is detected
                event.preventDefault();
                // If the current gesture is a SCROLL (or pan),
                // switch that to PINCH and scroll to (0,0)
                // for easy computing of transforms
                if (currentGesture === gestures.SCROLL) {
                    currentGesture = gestures.PINCH;
                    removeScroll();
                    firstPinchDistance = point1.getDistance(point2);
                    // Do no more pinch processing for this
                    // event now that we scrolled, because
                    // we still have the old coordinates.
                    // It is fine to waste a couple of events
                    // in a gesture.
                    return;
                }
                processPinch(point1, point2);
                applyFastTransform();
            } else if (point1) {
                // If there is a switch from pinch to
                // scroll mode, restore the scroll position
                // to the current pan coordinates.
                if (currentGesture === gestures.PINCH) {
                    currentGesture = gestures.SCROLL;
                    restoreScroll();
                    // Do no more pan processing for this event because
                    // the scrolling changed the coordinates.
                    return;
                }
                // Even when we are doing native scrolling/panning,
                // keep track and process the pan (but do not apply
                // a transform), so that when there is a switch to
                // pinch mode, the new pan coordinates are taken into
                // account.
                processPan(point1);
            }

        }


        /**
         * Restores scroll to the current pan position
         * after the gesture is over.
         * @return {undefined}
         */
        function sanitizeGesture() {
            if (currentGesture === gestures.PINCH) {
                // Here, signalZoomChanged is emitted before restoring the
                // scroll, because otherwise scrolling and then changing the
                // scroll area's dimensions will cause the view to end up
                // in unexpected places. Scrolling later will ensure that
                // the scrolled view is set by us and not the browser.
                events.emit(gui.ZoomHelper.signalZoomChanged, zoom);
                restoreScroll();
                applyDetailedTransform();
            }
            currentGesture = gestures.NONE;
        }

        /**
         * @param {!string} eventid
         * @param {!Function} cb
         * @return {undefined}
         */
        this.subscribe = function (eventid, cb) {
            events.subscribe(eventid, cb);
        };

        /**
         * @param {!string} eventid
         * @param {!Function} cb
         * @return {undefined}
         */
        this.unsubscribe = function (eventid, cb) {
            events.unsubscribe(eventid, cb);
        };

        /**
         * @return {!number}
         */
        this.getZoomLevel = function () {
            return zoom;
        };

        /**
         * @param {!number} zoomLevel
         * @return {undefined}
         */
        this.setZoomLevel = function (zoomLevel) {
            if (zoomableElement) {
                zoom = zoomLevel;
                applyDetailedTransform();
                events.emit(gui.ZoomHelper.signalZoomChanged, zoom);
            }
        };

        /**
         * Adds touchstart, touchmove, and touchend
         * event listeners to the element's scrollable
         * container.
         * @return {undefined}
         */
        function registerGestureListeners() {
            if (offsetParent) {
                // There is no reliable way of detecting if the browser
                // supports these touch events. Therefore the only thing
                // we can do is simply attach listeners to these events
                // as this seems harmless if the events are not supported
                // anyway.
                offsetParent.addEventListener('touchstart', /**@type{!EventListener}*/(prepareGesture), false);
                offsetParent.addEventListener('touchmove', /**@type{!EventListener}*/(processGesture), false);
                offsetParent.addEventListener('touchend', /**@type{!EventListener}*/(sanitizeGesture), false);
            }
        }

        /**
         * @return {undefined}
         */
        function unregisterGestureListeners() {
            if (offsetParent) {
                offsetParent.removeEventListener('touchstart', /**@type{!EventListener}*/(prepareGesture), false);
                offsetParent.removeEventListener('touchmove', /**@type{!EventListener}*/(processGesture), false);
                offsetParent.removeEventListener('touchend', /**@type{!EventListener}*/(sanitizeGesture), false);
            }
        }

        /**
         * @param {!function(!Error=)} callback, passing an error object in case of error
         * @return {undefined}
         */
        this.destroy = function (callback) {
            unregisterGestureListeners();
            enableScrollBars(false);
            callback();
        };

        /**
         * FIXME: I don't like that we can switch the zoomable
         * element at runtime, but I don't see any other way to
         * keep the zoom helper working after an undo.
         * @param {!HTMLElement} element
         * @return {undefined}
         */
        this.setZoomableElement = function (element) {
            unregisterGestureListeners();
            zoomableElement = element;
            offsetParent = /**@type{!HTMLElement}*/(zoomableElement.offsetParent);
            parentElement = /**@type{!HTMLElement}*/(zoomableElement.parentNode);
            // Write out the current transform to the new element.
            applyDetailedTransform();
            registerGestureListeners();
            enableScrollBars(true);
        };

        function init() {
            zoom = 1;
            previousZoom = 1;
            panPoint = new Point(0, 0);
        }
        init();
    };
    /**@const
     * @type {!string} */
    gui.ZoomHelper.signalZoomChanged = "zoomChanged";
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\CollapsingRules.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, core, Node, NodeFilter*/

/**
 * Defines a set of rules for how elements can be collapsed based on whether they contain ODT content (e.g.,
 * text or character elements).
 * @constructor
 * @param {!Node} rootNode Root text element of the odtDocument
 */
odf.CollapsingRules = function CollapsingRules(rootNode) {
    "use strict";
    var odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils;

    /**
     * Returns NodeFilter value if a given node is odf node or a text node that has a odf parent.
     * @param {!Node} node
     * @return {!number}
     */
    function filterOdfNodesToRemove(node) {
        var isToRemove = odfUtils.isODFNode(node)
            || (node.localName === "br" && odfUtils.isLineBreak(node.parentNode))
            || (node.nodeType === Node.TEXT_NODE && odfUtils.isODFNode(/** @type {!Node}*/(node.parentNode)));
        return isToRemove ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    }

    /**
     * Returns true if the supplied node should be automatically collapsed (i.e., removed) if it contains no
     * text or ODF character elements. The only element that should always be kept is a paragraph element.
     * Paragraph elements can only be deleted through merging
     * @param {!Node} node
     * @return {!boolean}
     */
    function isCollapsibleContainer(node) {
        return !odfUtils.isParagraph(node) && node !== rootNode && odfUtils.hasNoODFContent(node);
    }

    /**
     * Merge all child nodes into the node's parent and remove the node entirely
     * @param {!Node} targetNode Node to merge into parent
     * @return {?Node} Final parent node collapsing ended at
     */
    function mergeChildrenIntoParent(targetNode) {
        var parent;
        if (targetNode.nodeType === Node.TEXT_NODE) {
            parent = targetNode.parentNode;
            parent.removeChild(targetNode);
        } else {
            // removes all odf nodes
            parent = domUtils.removeUnwantedNodes(targetNode, filterOdfNodesToRemove);
        }
        if (parent && isCollapsibleContainer(parent)) {
            return mergeChildrenIntoParent(parent);
        }
        return parent;
    }
    this.mergeChildrenIntoParent = mergeChildrenIntoParent;
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\CommandLineTools.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, odf*/

/**
 * @constructor
 */
odf.CommandLineTools = function CommandLineTools() {
    "use strict";
    /**
     * @param {!string} inputfilepath
     * @param {!string} outputfilepath
     * @param {!function(string=):undefined} callback
     * @return {!odf.OdfContainer}
     */
    this.roundTrip = function (inputfilepath, outputfilepath, callback) {
        function onready(odfcontainer) {
            if (odfcontainer.state === odf.OdfContainer.INVALID) {
                return callback("Document " + inputfilepath + " is invalid.");
            }
            if (odfcontainer.state === odf.OdfContainer.DONE) {
                odfcontainer.saveAs(outputfilepath, function (err) {
                    callback(err);
                });
            } else {
                callback("Document was not completely loaded.");
            }
        }
        var odfcontainer = new odf.OdfContainer(inputfilepath, onready);
        return odfcontainer;
    };
    /**
     * @param {!string} inputfilepath
     * @param {!Document} document
     * @param {!function(*):undefined} callback
     * @return {undefined}
     */
    this.render = function (inputfilepath, document, callback) {
        var body = document.getElementsByTagName("body")[0],
            odfcanvas;
        core.DomUtils.removeAllChildNodes(body);
        odfcanvas = new odf.OdfCanvas(body);
        odfcanvas.addListener("statereadychange", function (err) {
            callback(err);
        });
        odfcanvas.load(inputfilepath);
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\FontLoader.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf, core, document, xmldom*/
/*jslint sub: true*/


(function () {
    "use strict";
    var xpath = xmldom.XPath,
        odfUtils = odf.OdfUtils,
        base64 = new core.Base64();

    /**
     * @param {!Element} fontFaceDecls
     * @return {!Object.<string,{href:string,family:string}>}
     */
    function getEmbeddedFontDeclarations(fontFaceDecls) {
        var decls = {}, fonts, i, font, name, uris, href, family;
        if (!fontFaceDecls) {
            return decls;
        }
        fonts = xpath.getODFElementsWithXPath(fontFaceDecls,
                    "style:font-face[svg:font-face-src]",
                    odf.Namespaces.lookupNamespaceURI);
        for (i = 0; i < fonts.length; i += 1) {
            font = fonts[i];
            name = font.getAttributeNS(odf.Namespaces.stylens, "name");
            family = odfUtils.getNormalizedFontFamilyName(font.getAttributeNS(odf.Namespaces.svgns, "font-family"));
            uris = xpath.getODFElementsWithXPath(font,
                "svg:font-face-src/svg:font-face-uri",
                odf.Namespaces.lookupNamespaceURI);
            if (uris.length > 0) {
                href = uris[0].getAttributeNS(odf.Namespaces.xlinkns, "href");
                decls[name] = {href: href, family: family};
            }
        }
        return decls;
    }
    /**
     * @param {!string} name
     * @param {!{href:string,family:string}} font
     * @param {!Uint8Array} fontdata
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     */
    function addFontToCSS(name, font, fontdata, stylesheet) {
        var cssFamily = font.family || name,
            // font-family already has a quotation in the name if needed, as required by
            // ODF 1.2 §19.528 svg:font-family, which points to SVG 1.1 §20.8.3, which points to
            // @font-face facility in CSS2
            // wrapping again with ' and ' only result in problems with font-family names
            // that are quoted with ' and ' itself
            rule = "@font-face { font-family: " + cssFamily + "; src: " +
                "url(data:application/x-font-ttf;charset=binary;base64," +
                base64.convertUTF8ArrayToBase64(fontdata) +
                ") format(\"truetype\"); }";
        try {
            stylesheet.insertRule(rule, stylesheet.cssRules.length);
        } catch (/**@type{!DOMException}*/e) {
            runtime.log("Problem inserting rule in CSS: " + runtime.toJson(e) + "\nRule: " + rule);
        }
    }
    /**
     * @param {!Object.<string,{href:string,family:string}>} embeddedFontDeclarations
     * @param {!odf.OdfContainer} odfContainer
     * @param {!number} pos
     * @param {!CSSStyleSheet} stylesheet
     * @param {!function():undefined=} callback
     * @return {undefined}
     */
    function loadFontIntoCSS(embeddedFontDeclarations, odfContainer, pos,
            stylesheet, callback) {
        var name, i = 0,
            /**@type{string}*/
            n;
        for (n in embeddedFontDeclarations) {
            if (embeddedFontDeclarations.hasOwnProperty(n)) {
                if (i === pos) {
                    name = n;
                    break;
                }
                i += 1;
            }
        }
        if (!name) {
            if (callback) {
                callback();
            }
            return;
        }
        odfContainer.getPartData(embeddedFontDeclarations[name].href, function (err, fontdata) {
            if (err) {
                runtime.log(err);
            } else if (!fontdata) {
                runtime.log("missing font data for "
                    + embeddedFontDeclarations[name].href);
            } else {
                addFontToCSS(name, embeddedFontDeclarations[name], fontdata,
                    stylesheet);
            }
            loadFontIntoCSS(embeddedFontDeclarations, odfContainer, pos + 1,
                    stylesheet, callback);
        });
    }
    /**
     * @param {!Object.<string,{href:string,family:string}>} embeddedFontDeclarations
     * @param {!odf.OdfContainer} odfContainer
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     */
    function loadFontsIntoCSS(embeddedFontDeclarations, odfContainer,
            stylesheet) {
        loadFontIntoCSS(embeddedFontDeclarations, odfContainer, 0, stylesheet);
    }
    /**
     * This class loads embedded fonts into the CSS
     * @constructor
     * @return {?}
     */
    odf.FontLoader = function FontLoader() {
        /**
         * @param {!odf.OdfContainer} odfContainer
         * @param {!CSSStyleSheet} stylesheet Will be cleaned and filled with rules for the fonts
         * @return {undefined}
         */
        this.loadFonts = function (odfContainer, stylesheet) {
            var embeddedFontDeclarations,
                /** @type {?Element}*/fontFaceDecls = odfContainer.rootElement.fontFaceDecls;

            // make stylesheet empty
            while (stylesheet.cssRules.length) {
                stylesheet.deleteRule(stylesheet.cssRules.length - 1);
            }

            if (fontFaceDecls) {
                embeddedFontDeclarations = getEmbeddedFontDeclarations(
                    fontFaceDecls
                );
                loadFontsIntoCSS(embeddedFontDeclarations, odfContainer, stylesheet);
            }
        };
    };
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\Formatting.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, odf, runtime, core*/

/**
 * @constructor
 */
odf.Formatting = function Formatting() {
    "use strict";
    var /**@type{odf.OdfContainer}*/
        odfContainer,
        /**@type{odf.StyleInfo}*/
        styleInfo = new odf.StyleInfo(),
        /**@const*/
        svgns = odf.Namespaces.svgns,
        /**@const*/
        stylens = odf.Namespaces.stylens,
        /**@const*/
        textns = odf.Namespaces.textns,
        /**@const*/
        numberns = odf.Namespaces.numberns,
        /**@const*/
        fons = odf.Namespaces.fons,
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils,
        utils = new core.Utils(),
        cssUnits = new core.CSSUnits(),
        // TODO: needs to be extended. Possibly created together with CSS from sone default description?
        /**@const
           @type {!Object.<!string,!odf.Formatting.StyleData>}*/
        builtInDefaultStyleAttributesByFamily = {
            'paragraph' : {
                'style:paragraph-properties': {
                    'fo:text-align': 'left'
                }
            }
        },
        /**@const*/
        defaultPageFormatSettings = {
            width: "21.001cm", // showing as 21.00 in page format dialog but the value is actually 21.001 in the xml
            height: "29.7cm",
            margin: "2cm",
            padding: "0cm"
        }; // LO 4.1.1.2's default page format settings.

    /**
     * Returns a JSON representation of the built-in default style attributes
     * of a given style family.
     * Creates a deep copy, so the result can be modified by the callee.
     * If there are no such attributes, null is returned.
     * @param {string} styleFamily
     * @return {!odf.Formatting.StyleData}
     */
    function getSystemDefaultStyleAttributes(styleFamily) {
        var result,
            /**@type{!odf.Formatting.StyleData|undefined}*/
            builtInDefaultStyleAttributes = builtInDefaultStyleAttributesByFamily[styleFamily];

        if (builtInDefaultStyleAttributes) {
            // reusing mergeObjects to copy builtInDefaultStyleAttributes into the result
            result = utils.mergeObjects({}, builtInDefaultStyleAttributes);
        } else {
            result = {};
        }

        return result;
    }
    this.getSystemDefaultStyleAttributes = getSystemDefaultStyleAttributes;

    /**
     * @param {!odf.OdfContainer} odfcontainer
     * @return {undefined}
     */
    this.setOdfContainer = function (odfcontainer) {
        odfContainer = odfcontainer;
    };
    /**
     * Returns a font face declarations map, where the key is the style:name and
     * the value is the svg:font-family or null, if none set but a svg:font-face-uri
     * @return {!Object.<string,string>}
     */
    function getFontMap() {
        var fontFaceDecls = odfContainer.rootElement.fontFaceDecls,
            /**@type {!Object.<string,string>}*/
            fontFaceDeclsMap = {},
            node,
            name,
            family;

        node = fontFaceDecls && fontFaceDecls.firstElementChild;
        while (node) {
            name = node.getAttributeNS(stylens, 'name');
            if (name) {
                // add family name as value, or, if there is a
                // font-face-uri, an empty string
                family = node.getAttributeNS(svgns, 'font-family');
                if (family || node.getElementsByTagNameNS(svgns, 'font-face-uri').length > 0) {
                    fontFaceDeclsMap[name] = family;
                }
            }
            node = node.nextElementSibling;
        }

        return fontFaceDeclsMap;
    }
    this.getFontMap = getFontMap;

    /**
     * Loop over the <style:style> elements and place the attributes
     * style:name and style:display-name in an array.
     * @return {!Array}
     */
    this.getAvailableParagraphStyles = function () {
        var node = odfContainer.rootElement.styles,
            p_family,
            p_name,
            p_displayName,
            paragraphStyles = [];
        node = node && node.firstElementChild;
        while (node) {
            if (node.localName === "style" && node.namespaceURI === stylens) {
                p_family = node.getAttributeNS(stylens, 'family');
                if (p_family === "paragraph") {
                    p_name = node.getAttributeNS(stylens, 'name');
                    p_displayName = node.getAttributeNS(stylens, 'display-name') || p_name;
                    if (p_name && p_displayName) {
                        paragraphStyles.push({
                            name: p_name,
                            displayName: p_displayName
                        });
                    }
                }
            }
            node = node.nextElementSibling;
        }
        return paragraphStyles;
    };

    /**
     * Returns if the given style is used anywhere in the document.
     * @param {!Element} styleElement
     * @return {!boolean}
     */
    this.isStyleUsed = function (styleElement) {
        var hasDerivedStyles, isUsed,
            root = odfContainer.rootElement;

        hasDerivedStyles = styleInfo.hasDerivedStyles(root,
            odf.Namespaces.lookupNamespaceURI, styleElement);

        isUsed =
            new styleInfo.UsedStyleList(root.styles).uses(styleElement)
            || new styleInfo.UsedStyleList(root.automaticStyles).uses(styleElement)
            || new styleInfo.UsedStyleList(root.body).uses(styleElement);

        return hasDerivedStyles || isUsed;
    };

    /**
     * @param {!string} family
     * @return {?Element}
     */
    function getDefaultStyleElement(family) {
        var node = odfContainer.rootElement.styles.firstElementChild;

        while (node) {
            if (node.namespaceURI === stylens
                    && node.localName === "default-style"
                    && node.getAttributeNS(stylens, 'family') === family) {
                return node;
            }
            node = node.nextElementSibling;
        }
        return null;
    }
    this.getDefaultStyleElement = getDefaultStyleElement;

    /**
     * Fetch style element associated with the requested name and family
     * @param {!string} styleName
     * @param {!string} family
     * @param {!Array.<!Element>=} styleElements Specific style trees to search. If unspecified will search both automatic
     *  and user-created styles
     * @return {?Element}
     */
    function getStyleElement(styleName, family, styleElements) {
        var node,
            nodeStyleName,
            styleListElement,
            i;

        styleElements = styleElements || [odfContainer.rootElement.automaticStyles, odfContainer.rootElement.styles];
        for (i = 0; i < styleElements.length; i += 1) {
            styleListElement = /**@type{!Element}*/(styleElements[i]);
            node = styleListElement.firstElementChild;
            while (node) {
                nodeStyleName = node.getAttributeNS(stylens, 'name');
                if (node.namespaceURI === stylens
                        && node.localName === "style"
                        && node.getAttributeNS(stylens, 'family') === family
                        && nodeStyleName === styleName) {
                    return node;
                }
                if (family === "list-style"
                        && node.namespaceURI === textns
                        && node.localName === "list-style"
                        && nodeStyleName === styleName) {
                    return node;
                }
                if (family === "data"
                        && node.namespaceURI === numberns
                        && nodeStyleName === styleName) {
                    return node;
                }
                node = node.nextElementSibling;
            }
        }
        return null;
    }
    this.getStyleElement = getStyleElement;

    /**
     * Returns a JSON representation of the style attributes of a given style element
     * @param {!Element} styleNode
     * @return {!odf.Formatting.StyleData}
     */
    function getStyleAttributes(styleNode) {
        var i, a, map, ai,
            propertiesMap = {},
            propertiesNode = styleNode.firstElementChild;

        while (propertiesNode) {
            if (propertiesNode.namespaceURI === stylens) {
                map = propertiesMap[propertiesNode.nodeName] = {};
                a = propertiesNode.attributes;
                for (i = 0; i < a.length; i += 1) {
                    ai = /**@type{!Attr}*/(a.item(i));
                    map[ai.name] = ai.value;
                }
            }
            propertiesNode = propertiesNode.nextElementSibling;
        }
        a = styleNode.attributes;
        for (i = 0; i < a.length; i += 1) {
            ai = /**@type{!Attr}*/(a.item(i));
            propertiesMap[ai.name] = ai.value;
        }

        return propertiesMap;
    }
    this.getStyleAttributes = getStyleAttributes;

    /**
     * Returns a JSON representation of the style attributes of a given style element, also containing attributes
     * inherited from it's ancestry - up to and including the document's default style for the family.
     * @param {!Element} styleNode
     * @param {!boolean=} includeSystemDefault True by default. Specify false to suppress inclusion of system defaults
     * @return {!odf.Formatting.StyleData}
     */
    function getInheritedStyleAttributes(styleNode, includeSystemDefault) {
        var styleListElement = odfContainer.rootElement.styles,
            parentStyleName,
            propertiesMap,
            inheritedPropertiesMap = {},
            styleFamily = styleNode.getAttributeNS(stylens, 'family'),
            node = styleNode;

        // Iterate through the style ancestry
        while (node) {
            propertiesMap = getStyleAttributes(node);
            // All child properties should override any matching parent properties
            inheritedPropertiesMap = utils.mergeObjects(propertiesMap, inheritedPropertiesMap);

            parentStyleName = node.getAttributeNS(stylens, 'parent-style-name');
            if (parentStyleName) {
                node = getStyleElement(parentStyleName, styleFamily, [styleListElement]);
            } else {
                node = null;
            }
        }

        // Next incorporate attributes from the default style
        node = getDefaultStyleElement(styleFamily);
        if (node) {
            propertiesMap = getStyleAttributes(node);
            // All child properties should override any matching parent properties
            inheritedPropertiesMap = utils.mergeObjects(propertiesMap, inheritedPropertiesMap);
        }

        // Last incorporate attributes from the built-in default style
        if (includeSystemDefault !== false) {
            propertiesMap = getSystemDefaultStyleAttributes(styleFamily);
            // All child properties should override any matching parent properties
            inheritedPropertiesMap = utils.mergeObjects(propertiesMap, inheritedPropertiesMap);
        }

        return inheritedPropertiesMap;
    }
    this.getInheritedStyleAttributes = getInheritedStyleAttributes;

    /**
     * Get the name of the first common style in the parent style chain.
     * If none is found, null is returned and you should assume the Default style.
     * @param {!string} styleName
     * @return {?string}
     */
    this.getFirstCommonParentStyleNameOrSelf = function (styleName) {
        var automaticStyleElementList = odfContainer.rootElement.automaticStyles,
            styleElementList = odfContainer.rootElement.styles,
            styleElement;

        // first look for automatic style with the name and get its parent style
        styleElement = getStyleElement(styleName, "paragraph", [automaticStyleElementList]);
        if (styleElement) {
            styleName = styleElement.getAttributeNS(stylens, 'parent-style-name');
            if (!styleName) {
                return null;
            }
        }
        // then see if that style is in common styles
        styleElement = getStyleElement(styleName, "paragraph", [styleElementList]);
        if (!styleElement) {
            return null;
        }
        return styleName;
    };

    /**
     * Returns if there is an automatic or common paragraph style with the given name.
     * @param {!string} styleName
     * @return {!boolean}
     */
    this.hasParagraphStyle = function (styleName) {
        return Boolean(getStyleElement(styleName, "paragraph"));
    };

    /**
     * Builds up a style chain for a given node by climbing up all parent nodes and checking for style information
     * @param {!Node} node
     * @param {!Object.<!string, !Array.<!Object>>=} collectedChains Dictionary to add any new style chains to
     * @return {!Array.<!Object>|undefined}
     */
    function buildStyleChain(node, collectedChains) {
        var parent = /**@type{!Element}*/(node.nodeType === Node.TEXT_NODE
                  ? node.parentNode : node),
            nodeStyles,
            appliedStyles = [],
            /**@type{string}*/
            chainKey = '',
            foundContainer = false;

        while (parent && (!odfUtils.isInlineRoot(parent)) && (parent.parentNode !== odfContainer.rootElement)) {
            if (!foundContainer && odfUtils.isGroupingElement(parent)) {
                foundContainer = true;
            }
            nodeStyles = styleInfo.determineStylesForNode(parent);
            if (nodeStyles) {
                appliedStyles.push(nodeStyles);
            }
            parent = /**@type{!Element}*/(parent.parentNode);
        }

        /**
         * @param {!Array.<!Object.<string,!Object.<string,number>>>} usedStyleMap
         */
        function chainStyles(usedStyleMap) {
            Object.keys(usedStyleMap).forEach(function (styleFamily) {
                Object.keys(usedStyleMap[styleFamily]).forEach(function (styleName) {
                    chainKey += '|' + styleFamily + ':' + styleName + '|';
                });
            });
        }
        if (foundContainer) {
            appliedStyles.forEach(chainStyles);
            if (collectedChains) {
                collectedChains[chainKey] = appliedStyles;
            }
        }

        return foundContainer ? appliedStyles : undefined;
    }

    /**
     * Returns true if the supplied style node is a common style.
     * From the OpenDocument spec:
     *
     * "Common and automatic styles behave differently in OpenDocument editing consumers. Common
     *  styles are presented to the user as a named set of formatting properties. The formatting
     *  properties of an automatic style are presented to a user as properties of the object to
     *  which the style is applied."
     *
     * http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#element-office_automatic-styles
     *
     * @param {!Node} styleNode
     * @return {!boolean}
     */
    function isCommonStyleElement(styleNode) {
        return styleNode.parentNode === odfContainer.rootElement.styles;
    }

    /**
     * Takes a provided style chain and calculates the resulting inherited style, starting from the outer-most to the
     * inner-most style
     * @param {!Array.<!Object>} styleChain Ordered list starting from inner-most style to outer-most style
     * @return {!odf.Formatting.AppliedStyle}
     */
    function calculateAppliedStyle(styleChain) {
        var mergedChildStyle = { orderedStyles: [], styleProperties: {} };

        // The complete style is built up by starting at the base known style and merging each new entry
        // on top of it, so the inner-most style properties override the outer-most
        styleChain.forEach(function (elementStyleSet) {
            Object.keys(/**@type{!Object}*/(elementStyleSet)).forEach(function (styleFamily) {
                // Expect there to only be a single style for a given family per element (e.g., 1 text, 1 paragraph)
                var styleName = Object.keys(elementStyleSet[styleFamily])[0],
                    styleSummary = {
                        name: styleName,
                        family: styleFamily,
                        displayName: undefined,
                        isCommonStyle: false
                    },
                    styleElement,
                    parentStyle;

                styleElement = getStyleElement(styleName, styleFamily);
                if (styleElement) {
                    parentStyle = getInheritedStyleAttributes(/**@type{!Element}*/(styleElement));
                    mergedChildStyle.styleProperties = utils.mergeObjects(parentStyle, mergedChildStyle.styleProperties);
                    styleSummary.displayName = styleElement.getAttributeNS(stylens, 'display-name') || undefined;
                    styleSummary.isCommonStyle = isCommonStyleElement(styleElement);
                } else {
                    runtime.log("No style element found for '" + styleName + "' of family '" + styleFamily + "'");
                }
                mergedChildStyle.orderedStyles.push(styleSummary);
            });
        });
        return mergedChildStyle;
    }

    /**
     * Returns an array of all unique styles in the given text nodes
     * @param {!Array.<!Node>} nodes
     * @param {!Object.<!string, !odf.Formatting.AppliedStyle>=} calculatedStylesCache Short-lived cache of calculated styles.
     *      Useful if a function is looking up the style information for multiple nodes without updating
     *      any style definitions.
     * @return {!Array.<!odf.Formatting.AppliedStyle>}
     */
    function getAppliedStyles(nodes, calculatedStylesCache) {
        var styleChains = {},
            styles = [];

        if (!calculatedStylesCache) {
            calculatedStylesCache = {}; // Makes the following logic easier as a cache can be assumed to exist
        }
        nodes.forEach(function (n) {
            buildStyleChain(n, styleChains);
        });

        Object.keys(styleChains).forEach(function (key) {
            if (!calculatedStylesCache[key]) {
                calculatedStylesCache[key] = calculateAppliedStyle(styleChains[key]);
            }
            styles.push(calculatedStylesCache[key]);
        });
        return styles;
    }
    this.getAppliedStyles = getAppliedStyles;

    /**
     * Returns a the applied style to the current node
     * @param {!Node} node
     * @param {!Object.<!string, !odf.Formatting.AppliedStyle>=} calculatedStylesCache Short-lived cache of calculated styles.
     *      Useful if a function is looking up the style information for multiple nodes without updating
     *      any style definitions.
     * @return {!odf.Formatting.AppliedStyle|undefined}
     */
    this.getAppliedStylesForElement = function (node, calculatedStylesCache) {
        return getAppliedStyles([node], calculatedStylesCache)[0];
    };

    /**
     * Overrides the specific properties on the styleNode from the values in the supplied properties Object.
     * If a newStylePrefix is supplied, this method will automatically generate a unique name for the style node
     * @param {!Element} styleNode
     * @param {!odf.Formatting.StyleData} properties Prefix to put in front of new auto styles
     */
    this.updateStyle = function (styleNode, properties) {
        var fontName, fontFaceNode, textProperties;

        domUtils.mapObjOntoNode(styleNode, properties, odf.Namespaces.lookupNamespaceURI);

        textProperties = /**@type {!odf.Formatting.StyleData|undefined}*/(properties["style:text-properties"]);
        fontName = /**@type {!string}*/(textProperties && textProperties["style:font-name"]);
        if (fontName && !getFontMap().hasOwnProperty(fontName)) {
            fontFaceNode = styleNode.ownerDocument.createElementNS(stylens, 'style:font-face');
            fontFaceNode.setAttributeNS(stylens, 'style:name', fontName);
            fontFaceNode.setAttributeNS(svgns, 'svg:font-family', fontName);
            odfContainer.rootElement.fontFaceDecls.appendChild(fontFaceNode);
        }
    };

    /**
     * Create a style object (JSON-equivalent) that is equivalent to inheriting from the parent
     * style and family, and applying the specified overrides.
     * This contains logic for simulating inheritance for automatic styles
     * @param {!string} parentStyleName
     * @param {!string} family
     * @param {!odf.Formatting.StyleData} overrides
     * @return {!odf.Formatting.StyleData}
     */
    this.createDerivedStyleObject = function(parentStyleName, family, overrides) {
        var originalStyleElement = /**@type{!Element}*/(getStyleElement(parentStyleName, family)),
            newStyleObject;
        runtime.assert(Boolean(originalStyleElement), "No style element found for '" + parentStyleName + "' of family '" + family + "'");
        if (isCommonStyleElement(originalStyleElement)) {
            newStyleObject = { "style:parent-style-name": parentStyleName };
        } else {
            // Automatic styles cannot be inherited from. The way to create a derived style is to clone it entirely
            newStyleObject = getStyleAttributes(originalStyleElement);
        }
        newStyleObject["style:family"] =  family;
        utils.mergeObjects(newStyleObject, overrides);
        return newStyleObject;
    };

    /**
     * Get the default tab-stop distance defined for this document
     * See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#property-style_tab-stop-distance
     * @return {?{value: !number, unit: !string}}
     */
    this.getDefaultTabStopDistance = function () {
        var defaultParagraph = getDefaultStyleElement('paragraph'),
            paragraphProperties = defaultParagraph && defaultParagraph.firstElementChild,
            tabStopDistance;
        while (paragraphProperties) {
            if (paragraphProperties.namespaceURI === stylens && paragraphProperties.localName === "paragraph-properties") {
                tabStopDistance = paragraphProperties.getAttributeNS(stylens, "tab-stop-distance");
            }
            paragraphProperties = paragraphProperties.nextElementSibling;
        }

        if (!tabStopDistance) {
            tabStopDistance =  "1.25cm"; // What is the default value for tab stops? Pulled this from LO 4.1.1
        }
        return odfUtils.parseNonNegativeLength(tabStopDistance);
    };

    /**
     * Find a master page definition with the specified name
     * @param {!string} pageName
     * @return {?Element}
     */
    function getMasterPageElement(pageName) {
        var node = odfContainer.rootElement.masterStyles.firstElementChild;
        while (node) {
            if (node.namespaceURI === stylens
                && node.localName === "master-page"
                && node.getAttributeNS(stylens, "name") === pageName) {
                break;
            }
            node = node.nextElementSibling;
        }
        return node;
    }
    this.getMasterPageElement = getMasterPageElement;

    /**
     * Gets the associated page layout style node for the given style and family.
     * @param {!string} styleName
     * @param {!string} styleFamily either 'paragraph' or 'table'
     * @return {?Element}
     */
    function getPageLayoutStyleElement(styleName, styleFamily) {
        var masterPageName,
            layoutName,
            pageLayoutElements,
            /**@type{?Element}*/
            node,
            i,
            styleElement = getStyleElement(styleName, styleFamily);

        runtime.assert(styleFamily === "paragraph" || styleFamily === "table",
            "styleFamily must be either paragraph or table");

        if (styleElement) {
            masterPageName = styleElement.getAttributeNS(stylens, "master-page-name");
            if (masterPageName) {
                node = getMasterPageElement(masterPageName);
                if (!node) {
                    runtime.log("WARN: No master page definition found for " + masterPageName);
                }
            }
            // TODO If element has no master-page-name defined find the master-page-name from closest previous sibling
            // See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1417948_253892949
            if (!node) {
                // Fallback 1: LibreOffice usually puts a page layout in called "Standard"
                node = getMasterPageElement("Standard");
            }
            if (!node) {
                // Fallback 2: Find any page style
                node = /**@type{?Element}*/(odfContainer.rootElement.masterStyles.getElementsByTagNameNS(stylens, "master-page")[0]);
                if (!node) {
                    // See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#element-style_master-page
                    // "All documents shall contain at least one master page element."
                    runtime.log("WARN: Document has no master pages defined");
                }
            }

            if (node) {
                // It would be surprising if we still haven't found a page by now. Still, better safe than sorry!
                // Note, all warnings are already logged in the above conditions
                layoutName = node.getAttributeNS(stylens, "page-layout-name");
                pageLayoutElements = odfContainer.rootElement.automaticStyles.getElementsByTagNameNS(stylens, "page-layout");
                for (i = 0; i < pageLayoutElements.length; i += 1) {
                    node = /**@type{!Element}*/(pageLayoutElements.item(i));
                    if (node.getAttributeNS(stylens, "name") === layoutName) {
                        return node;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @param {?string|undefined} length
     * @param {string=} defaultValue
     * @return {!number|undefined}
     */
    function lengthInPx(length, defaultValue) {
        var measure;
        if (length) {
            measure = cssUnits.convertMeasure(length, "px");
        }
        if (measure === undefined && defaultValue) {
            measure = cssUnits.convertMeasure(defaultValue, "px");
        }
        return measure;
    }

    /**
     * Gets the width and height of content area in pixels.
     * @param {string} styleName
     * @param {string} styleFamily
     * @return {!{width: number, height: number}} Available content size in pixels
     */
    this.getContentSize = function(styleName, styleFamily) {
        var pageLayoutElement,
            props,
            defaultOrientedPageWidth,
            defaultOrientedPageHeight,
            pageWidth,
            pageHeight,
            margin,
            marginLeft,
            marginRight,
            marginTop,
            marginBottom,
            padding,
            paddingLeft,
            paddingRight,
            paddingTop,
            paddingBottom;

        pageLayoutElement = getPageLayoutStyleElement(styleName, styleFamily);
        if (!pageLayoutElement) {
            pageLayoutElement = domUtils.getDirectChild(odfContainer.rootElement.styles, stylens, "default-page-layout");
        }
        props = domUtils.getDirectChild(pageLayoutElement, stylens, "page-layout-properties");
        if (props) {
            // set page's default width and height based on print orientation
            if (props.getAttributeNS(stylens, "print-orientation") === "landscape") {
                // swap the default width and height around in landscape
                defaultOrientedPageWidth = defaultPageFormatSettings.height;
                defaultOrientedPageHeight = defaultPageFormatSettings.width;
            } else {
                defaultOrientedPageWidth = defaultPageFormatSettings.width;
                defaultOrientedPageHeight = defaultPageFormatSettings.height;
            }

            pageWidth = lengthInPx(props.getAttributeNS(fons, "page-width"), defaultOrientedPageWidth);
            pageHeight = lengthInPx(props.getAttributeNS(fons, "page-height"), defaultOrientedPageHeight);

            margin = lengthInPx(props.getAttributeNS(fons, "margin"));
            if (margin === undefined) {
                marginLeft = lengthInPx(props.getAttributeNS(fons, "margin-left"), defaultPageFormatSettings.margin);
                marginRight = lengthInPx(props.getAttributeNS(fons, "margin-right"), defaultPageFormatSettings.margin);
                marginTop = lengthInPx(props.getAttributeNS(fons, "margin-top"), defaultPageFormatSettings.margin);
                marginBottom = lengthInPx(props.getAttributeNS(fons, "margin-bottom"), defaultPageFormatSettings.margin);
            } else {
                marginLeft = marginRight = marginTop = marginBottom = margin;
            }

            padding = lengthInPx(props.getAttributeNS(fons, "padding"));
            if (padding === undefined) {
                paddingLeft = lengthInPx(props.getAttributeNS(fons, "padding-left"), defaultPageFormatSettings.padding);
                paddingRight = lengthInPx(props.getAttributeNS(fons, "padding-right"), defaultPageFormatSettings.padding);
                paddingTop = lengthInPx(props.getAttributeNS(fons, "padding-top"), defaultPageFormatSettings.padding);
                paddingBottom = lengthInPx(props.getAttributeNS(fons, "padding-bottom"), defaultPageFormatSettings.padding);
            } else {
                paddingLeft = paddingRight = paddingTop = paddingBottom = padding;
            }
        } else {
            pageWidth = lengthInPx(defaultPageFormatSettings.width);
            pageHeight = lengthInPx(defaultPageFormatSettings.height);
            margin = lengthInPx(defaultPageFormatSettings.margin);
            marginLeft = marginRight = marginTop = marginBottom = margin;
            padding = lengthInPx(defaultPageFormatSettings.padding);
            paddingLeft = paddingRight = paddingTop = paddingBottom = padding;
        }
        return {
            width: pageWidth - marginLeft - marginRight - paddingLeft - paddingRight,
            height: pageHeight - marginTop - marginBottom - paddingTop - paddingBottom
        };
    };
};

/**@typedef{{
    name:!string,
    family:!string,
    displayName:(!string|undefined),
    isCommonStyle:!boolean
}}*/
odf.Formatting.StyleMetadata;

/**@typedef{!Object.<!string,(!string|!Object.<!string,!string>)>}*/
odf.Formatting.StyleData;

/**@typedef{{
    orderedStyles:!Array.<!odf.Formatting.StyleMetadata>,
    styleProperties:!odf.Formatting.StyleData
}}*/
odf.Formatting.AppliedStyle;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\GraphicProperties.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/

/**
 * Convenient access to style attributes for graphic-properties.
 * @constructor
 * @param {!Element} element <style:graphic-properties/> element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.GraphicProperties|undefined} parent
 */
odf.GraphicProperties = function (element, styleParseUtils, parent) {
    "use strict";
    var self = this,
        stylens = odf.Namespaces.stylens,
        svgns = odf.Namespaces.svgns,
        getter;
    getter = {
        verticalPos: function () {
            var v = element.getAttributeNS(stylens, "vertical-pos");
            return v === "" ? undefined : v;
        },
        verticalRel: function () {
            var v = element.getAttributeNS(stylens, "vertical-rel");
            return v === "" ? undefined : v;
        },
        horizontalPos: function () {
            var v = element.getAttributeNS(stylens, "horizontal-pos");
            return v === "" ? undefined : v;
        },
        horizontalRel: function () {
            var v = element.getAttributeNS(stylens, "horizontal-rel");
            return v === "" ? undefined : v;
        },
        strokeWidth: function () {
            var a = element.getAttributeNS(svgns, "stroke-width");
            return styleParseUtils.parseLength(a);
        }
    };
    /**
     * @return {!string|undefined}
     */
    this.verticalPos = function () {
        return /**@type{!string|undefined}*/(self.data.value("verticalPos"));
    };
    /**
     * @return {!string|undefined}
     */
    this.verticalRel = function () {
        return /**@type{!string|undefined}*/(self.data.value("verticalRel"));
    };
    /**
     * @return {!string|undefined}
     */
    this.horizontalPos = function () {
        return /**@type{!string|undefined}*/(self.data.value("horizontalPos"));
    };
    /**
     * @return {!string|undefined}
     */
    this.horizontalRel = function () {
        return /**@type{!string|undefined}*/(self.data.value("horizontalRel"));
    };
    /**
     * @return {!number|undefined}
     */
    this.strokeWidth = function () {
        return /**@type{!number|undefined}*/(self.data.value("strokeWidth"));
    };
    /**
     * @type {!odf.LazyStyleProperties}
     */
    this.data;
    function init() {
        var p = parent === undefined ? undefined : parent.data;
        self.data = new odf.LazyStyleProperties(p, getter);
    }
    init();
};
/**
 * @constructor
 */
odf.ComputedGraphicProperties = function () {
    "use strict";
    var /**@type{!odf.GraphicProperties|undefined}*/
        g;
    /**
     * @param {!odf.GraphicProperties|undefined} graphicProperties
     * @return {undefined}
     */
    this.setGraphicProperties = function (graphicProperties) {
        g = graphicProperties;
    };
    /**
     * @return {!string}
     */
    this.verticalPos = function () {
        return (g && g.verticalPos()) || "from-top";
    };
    /**
     * @return {!string}
     */
    this.verticalRel = function () {
        return (g && g.verticalRel()) || "page";
    };
    /**
     * @return {!string}
     */
    this.horizontalPos = function () {
        return (g && g.horizontalPos()) || "from-left";
    };
    /**
     * @return {!string}
     */
    this.horizontalRel = function () {
        return (g && g.horizontalRel()) || "page";
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\ListStylesToCss.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, core, runtime*/

(function () {
    "use strict";

    var /**@const
           @type{!string}*/
        fons = odf.Namespaces.fons,
        /**@const
           @type{!string}*/
        stylens = odf.Namespaces.stylens,
        /**@const
           @type{!string}*/
        textns = odf.Namespaces.textns,
        /**@const
           @type{!string}*/
        xmlns = odf.Namespaces.xmlns,
        /**@const
           @type{!string}*/
        helperns = "urn:webodf:names:helper",
        /**@const
           @type{!string}*/
        listCounterIdSuffix = "webodf-listLevel",
        /**@const
           @type{!Object.<string,string>}*/
        stylemap = {
            '1': 'decimal',
            'a': 'lower-latin',
            'A': 'upper-latin',
            'i': 'lower-roman',
            'I': 'upper-roman'
        };

    /**
     * Appends the rule into the stylesheets and logs any errors that occur
     * @param {!CSSStyleSheet} styleSheet
     * @param {!string} rule
     * @return {undefined}
     */
    function appendRule(styleSheet, rule) {
        try {
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
        } catch (/**@type{!DOMException}*/e) {
            runtime.log("cannot load rule: " + rule + " - " + e);
        }
    }

    /**
     * Holds the current state of parsing the text:list elements in the DOM
     * @param {!Object.<!string, !string>} contentRules
     * @param {!Array.<!string>} continuedCounterIdStack
     * @constructor
     * @struct
     */
    function ParseState(contentRules, continuedCounterIdStack) {
        /**
         * The number of list counters created for a list
         * This is just a number appended to the list counter identifier to make it unique within the list
         * @type {!number}
         */
        this.listCounterCount = 0;

        /**
         * The CSS generated content rule keyed by list level
         * @type {!Object.<!string, !string>}
         */
        this.contentRules = contentRules;

        /**
         * The stack of counters for the list being processed
         * @type {!Array.<!string>}
         */
        this.counterIdStack = [];

        /**
         * The stack of counters the list should continue from if any
         * @type {!Array.<!string>}
         */
        this.continuedCounterIdStack = continuedCounterIdStack;
    }

    /**
     * Assigns globally unique CSS list counters to each text:list element in the document.
     * The reason a global list counter is required is due to how the scope of CSS counters works
     * which is described here http://www.w3.org/TR/CSS21/generate.html#scope
     *
     * The relevant part is that the scope of the counter applies to the element that the counter-reset rule
     * was applied to and any children or siblings of that element. Applying another counter-reset rule to the
     * same counter resets this scope and previous values of the counter are lost. These values are also inaccessible
     * if we inspect the value of the counter outside of the scope and we simply get the default value of zero.
     *
     * The above is important for the case of continued numbering combined with multi-level list numbering.
     * Multi-level lists use a separate counter for each list level and joins each counter value together.
     * Continued numbering takes the list counter from the list we want to continue and uses it for the list
     * that is being continued. Combining these two we get the approach of taking the list counter at each list level
     * from the list that is being continued and then using these counters at each level in the continued list.
     *
     * However the scope rules prevent us from continuing counters at any level deeper than the first level and
     * this behaviour is illustrated in an example of some list content below.
     * <office:document>
     *     <text:list>
     *         <text:list-item> counter: level1 value: 1
     *             <text:list>
     *                 <text:list-item><text:p>Item</text:p></text:list-item> counter: level2 value: 1
     *             </text:list>
     *         </text:list-item>
     *     </text:list>
     *     other doc content
     *     <text:list text:continue-numbering="true">
     *         <text:list-item>
     *             <text:list>
     *                 <text:list-item><text:p>Item</text:p></text:list-item> counter: level2 value: 0
     *             </text:list>
     *         </text:list-item>
     *     </text:list>
     * </office:document>
     *
     * The solution to this was to hoist the counter initialisation up to the document level so that the counter
     * scope applies to all lists in the document. Then each text:list element is given a unique counter by default.
     * Having unique counters is only really required for continuing a list based on its xml:id but having it for
     * all lists makes the code simpler and reduces the amount of CSS rules being overridden. Hence we end up with a
     * list counter setup as below.
     * <office:document> counter-reset: list1-1 list1-2
     *     <text:list>
     *         <text:list-item> counter: list1-1 value: 1
     *             <text:list>
     *                 <text:list-item><text:p>Item</text:p></text:list-item> counter: list1-2 value: 1
     *             </text:list>
     *         </text:list-item>
     *     </text:list>
     *     other doc content
     *     <text:list text:continue-numbering="true">
     *         <text:list-item>
     *             <text:list>
     *                 <text:list-item><text:p>Item</text:p></text:list-item> counter: list1-2 value: 2
     *             </text:list>
     *         </text:list-item>
     *     </text:list>
     * </office:document>
     *
     * @param {!CSSStyleSheet} styleSheet
     * @constructor
     */
    function UniqueListCounter(styleSheet) {
        var /**@type{!number}*/
            customListIdIndex = 0,
            /**@type{!string}*/
            globalCounterResetRule = "",
            /**@type{!Object.<!string,!Array.<!string>>}*/
            counterIdStacks = {};

        /**
         * Gets the stack of list counters for the given list.
         * Counter stacks are keyed by the list counter id of the first list level.
         * Returns a deep copy of the counter stack so it can be modified
         * @param {!Element|undefined} list
         * @return {!Array.<!string>}
         */
        function getCounterIdStack(list) {
            var counterId,
                stack = [];

            if (list) {
                counterId = list.getAttributeNS(helperns, "counter-id");
                stack = counterIdStacks[counterId].slice(0);
            }
            return stack;
        }

        /**
         * Assigns a unique global CSS list counter to this text:list element
         * @param {!string} topLevelListId This is used to generate a unique identifier for this element
         * @param {!Element} listElement This is always a text:list element
         * @param {!number} listLevel
         * @param {!ParseState} parseState
         * @return {undefined}
         */
        function createCssRulesForList(topLevelListId, listElement, listLevel, parseState) {
            var /**@type{!string}*/
                newListSelectorId,
                newListCounterId,
                newRule,
                contentRule,
                i;

            // increment counters and create a new identifier for this text:list element
            // this identifier will be used as the CSS counter name if this list is not continuing another list
            parseState.listCounterCount += 1;
            newListSelectorId = topLevelListId + "-level" + listLevel + "-" + parseState.listCounterCount;
            listElement.setAttributeNS(helperns, "counter-id", newListSelectorId);

            // if we need to continue from a previous list then get the counter from the stack
            // of the continued list and use it as the counter for this list element
            newListCounterId = parseState.continuedCounterIdStack.shift();
            if (!newListCounterId) {
                newListCounterId = newListSelectorId;

                // add the newly created counter to the counter reset rule so it can be
                // initialised later once we have parsed all the lists in the document.
                // In the case of a multi-level list with no items the counter increment rule
                // will not apply. To fix this issue we initialise the counters to a value of 1
                // instead of the default of 0.
                globalCounterResetRule += newListSelectorId + ' 1 ';

                // CSS counters increment the value before displaying the rendered list label. This is not an issue but as
                // we initialise the counters to a value of 1 above to handle lists with no list items it means that
                // lists that actually have list items will all start with the counter value of 2 which is not desirable.
                // To fix this we apply another CSS rule here that overrides the counter increment rule above and
                // prevents incrementing the counter on the FIRST list item that has content (AKA a visible list label).
                newRule = 'text|list[webodfhelper|counter-id="' + newListSelectorId + '"]';
                newRule += ' > text|list-item:first-child > :not(text|list):first-child:before';
                newRule += '{';
                // Due to https://bugs.webkit.org/show_bug.cgi?id=84985 a value of "none" is ignored by some version of WebKit
                // (specifically the ones shipped with the Cocoa frameworks on OSX 10.7 + 10.8).
                // Override the counter-increment on this counter by name to workaround this
                newRule += 'counter-increment: ' + newListCounterId + ' 0;';
                newRule += '}';
                appendRule(styleSheet, newRule);
            }

            // remove any counters from the stack that are deeper than the current list level
            // and push the newly created or continued counter on to the stack
            while (parseState.counterIdStack.length >= listLevel) {
                parseState.counterIdStack.pop();
            }
            parseState.counterIdStack.push(newListCounterId);

            // substitute the unique list counters in for each level up to the current one
            // this only replaces the first occurrence in the string as the generated rule
            // will have a different counter for each list level and multi level counter rules
            // are created by joining counters from different levels together
            contentRule = parseState.contentRules[listLevel.toString()] || "";
            for (i = 1; i <= listLevel; i += 1) {
                contentRule = contentRule.replace(i + listCounterIdSuffix, parseState.counterIdStack[i - 1]);
            }

            // Apply the counter increment to EVERY list item in this list that has content (AKA a visible list label)
            newRule = 'text|list[webodfhelper|counter-id="' + newListSelectorId + '"]';
            newRule += ' > text|list-item > :not(text|list):first-child:before';
            newRule += '{';
            newRule += contentRule;
            newRule += 'counter-increment: ' + newListCounterId + ';';
            newRule += '}';
            appendRule(styleSheet, newRule);
        }

        /**
         * Takes an element and parses it and its subtree for any text:list elements.
         * The text:list elements then have CSS rules applied that give each one
         * a unique global CSS counter for the purpose of list numbering.
         * @param {!string} topLevelListId
         * @param {!Element} element
         * @param {!number} listLevel
         * @param {!ParseState} parseState
         * @return {undefined}
         */
        function iterateOverChildListElements(topLevelListId, element, listLevel, parseState) {
            var isListElement = element.namespaceURI === textns && element.localName === "list",
                isListItemElement = element.namespaceURI === textns && element.localName === "list-item",
                childElement;

            // don't continue iterating over elements that aren't text:list or text:list-item
            if (!isListElement && !isListItemElement) {
                parseState.continuedCounterIdStack = [];
                return;
            }

            if (isListElement) {
                listLevel += 1;
                createCssRulesForList(topLevelListId, element, listLevel, parseState);
            }

            childElement = element.firstElementChild;
            while (childElement) {
                iterateOverChildListElements(topLevelListId, childElement, listLevel, parseState);
                childElement = childElement.nextElementSibling;
            }
        }

        /**
         * Takes a text:list element and creates CSS counter rules used for numbering
         * @param {!Object.<!string, !string>} contentRules
         * @param {!Element} list
         * @param {!Element=} continuedList
         * @return {undefined}
         */
        this.createCounterRules = function (contentRules, list, continuedList) {
            var /**@type{!string}*/
                listId = list.getAttributeNS(xmlns, "id"),
                currentParseState = new ParseState(contentRules, getCounterIdStack(continuedList));

            // ensure there is a unique identifier for each list if it does not have one
            if (!listId) {
                customListIdIndex += 1;
                listId = "X" + customListIdIndex;
            } else {
                listId = "Y" + listId;
            }

            iterateOverChildListElements(listId, list, 0, currentParseState);

            counterIdStacks[listId + "-level1-1"] = currentParseState.counterIdStack;
        };

        /**
         * Initialises all CSS counters created so far by this UniqueListCounter with a counter-reset rule.
         * Calling this method twice will cause the previous counter reset CSS rule to be overridden
         * @return {undefined}
         */
        this.initialiseCreatedCounters = function () {
            var newRule;

            newRule = 'office|document';
            newRule += '{';
            newRule += 'counter-reset: ' + globalCounterResetRule + ';';
            newRule += "}";
            appendRule(styleSheet, newRule);
        };
    }

    /**
     * @constructor
     */
    odf.ListStyleToCss = function ListStyleToCss() {

        var cssUnits = new core.CSSUnits(),
            odfUtils = odf.OdfUtils;

        /**
         * Takes a value with a valid CSS unit and converts it to a CSS pixel value
         * @param {!string} value
         * @return {!number}
         */
        function convertToPxValue(value) {
            var parsedLength = odfUtils.parseLength(value);
            if (!parsedLength) {
                runtime.log("Could not parse value '" + value + "'.");
                // Return 0 as fallback, might have least bad results if used
                return 0;
            }
            return cssUnits.convert(parsedLength.value, parsedLength.unit, "px");
        }

        /**
         * Return the supplied value with any backslashes escaped, and double-quotes escaped
         * @param {!string} value
         * @return {!string}
         */
        function escapeCSSString(value) {
            return value.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        }

        /**
         * Determines whether the list element style-name matches the style-name we require
         * @param {!Element|undefined} list
         * @param {!string} matchingStyleName
         * @return {!boolean}
         */
        function isMatchingListStyle(list, matchingStyleName) {
            var styleName;
            if (list) {
                styleName = list.getAttributeNS(textns, "style-name");
            }
            return styleName === matchingStyleName;
        }

        /**
         * Gets the CSS content for a numbered list
         * @param {!Element} node
         * @return {!string}
         */
        function getNumberRule(node) {
            var style = node.getAttributeNS(stylens, "num-format"),
                /**@type{!string}*/
                suffix = node.getAttributeNS(stylens, "num-suffix") || "",
                /**@type{!string}*/
                prefix = node.getAttributeNS(stylens, "num-prefix") || "",
                /**@type{!string}*/
                content = "",
                textLevel = node.getAttributeNS(textns, "level"),
                displayLevels = node.getAttributeNS(textns, "display-levels");
            if (prefix) {
                // Content needs to be on a new line if it contains slashes due to a bug in older versions of webkit
                // E.g., the one used in the qt runtime tests - https://bugs.webkit.org/show_bug.cgi?id=35010
                content += '"' + escapeCSSString(prefix) + '"\n';
            }
            if (stylemap.hasOwnProperty(style)) {
                textLevel = textLevel ? parseInt(textLevel, 10) : 1;
                displayLevels = displayLevels ? parseInt(displayLevels, 10) : 1;

                // as we might want to display a subset of the counters
                // we assume a different counter for each list level
                // and concatenate them for multi level lists
                // https://wiki.openoffice.org/wiki/Number_labels
                while (displayLevels > 0) {
                    content += " counter(" + (textLevel - displayLevels + 1) + listCounterIdSuffix + "," + stylemap[style] + ")";
                    if (displayLevels > 1) {
                        content += '"."';
                    }
                    displayLevels -= 1;
                }
            } else if (style) {
                content += ' "' + style + '"';
            } else {
                content += ' ""';
            }
            return 'content:' + content + ' "' + escapeCSSString(suffix) + '"';
        }

        /**
         * Gets the CSS content for a image bullet list
         * @return {!string}
         */
        function getImageRule() {
            return "content: none";
        }

        /**
         * Gets the CSS content for a bullet list
         * @param {!Element} node
         * @return {!string}
         */
        function getBulletRule(node) {
            var bulletChar = node.getAttributeNS(textns, "bullet-char");
            return 'content: "' + escapeCSSString(bulletChar) + '"';
        }

        /**
         * Gets the CSS generated content rule for the list style
         * @param {!Element} node
         * @return {!string}
         */
        function getContentRule(node) {
            var contentRule = "",
                listLevelProps,
                listLevelPositionSpaceMode,
                listLevelLabelAlign,
                followedBy;

            if (node.localName === "list-level-style-number") {
                contentRule = getNumberRule(node);
            } else if (node.localName === "list-level-style-image") {
                contentRule = getImageRule();
            } else if (node.localName === "list-level-style-bullet") {
                contentRule = getBulletRule(node);
            }

            listLevelProps = /**@type{!Element}*/(node.getElementsByTagNameNS(stylens, "list-level-properties")[0]);
            if (listLevelProps) {
                listLevelPositionSpaceMode = listLevelProps.getAttributeNS(textns, "list-level-position-and-space-mode");

                if (listLevelPositionSpaceMode === "label-alignment") {
                    listLevelLabelAlign = /**@type{!Element}*/(listLevelProps.getElementsByTagNameNS(stylens, "list-level-label-alignment")[0]);
                    if (listLevelLabelAlign) {
                        followedBy = listLevelLabelAlign.getAttributeNS(textns, "label-followed-by");
                    }

                    if (followedBy === "space") {
                        contentRule += ' "\\a0"';
                    }
                }
            }

            // Content needs to be on a new line if it contains slashes due to a bug in older versions of webkit
            // E.g., the one used in the qt runtime tests - https://bugs.webkit.org/show_bug.cgi?id=35010
            return '\n' + contentRule + ';\n';
        }

        /**
         * Takes a text:list-style element and returns the generated CSS
         * content rules for each list level in the list style
         * @param {!Element} listStyleNode
         * @return {!Object.<!string, !string>}
         */
        function getAllContentRules(listStyleNode) {
            var childNode = listStyleNode.firstElementChild,
                level,
                rules = {};

            while (childNode) {
                level = childNode.getAttributeNS(textns, "level");
                level = level && parseInt(level, 10);
                rules[level] = getContentRule(childNode);
                childNode = childNode.nextElementSibling;
            }
            return rules;
        }

        /**
         * In label-width-and-position mode of specifying list layout the margin and indent specified in
         * the paragraph style is additive to the layout specified in the list style.
         *
         *   fo:margin-left    text:space-before    fo:text-indent  +-----------+
         * +---------------->+------------------>+----------------->|   label   |     LIST TEXT
         *                                                          +-----------+
         * +---------------->+------------------>+-------------------->LIST TEXT LIST TEXT LIST TEXT
         *                                        text:min-label-width
         *
         * To get this additive behaviour we calculate an offset from the left side of the page which is
         * the space-before +  min-label-width. We then apply this offset to each text:list-item
         * element and apply the negative value of the offset to each text:list element. This allows the positioning
         * provided in the list style to apply relative to the paragraph style as we desired. Then on each
         * ::before pseudo-element which holds the label we apply the negative value of the min-label-width to complete
         * the alignment from the left side of the page. We then apply the min-label-distance as padding to the right
         * of the ::before psuedo-element to complete the list label placement.
         *
         * For the label-alignment mode the paragraph style overrides the list style but we specify offsets for
         * the text:list and text:list-item elements to keep the code consistent between the modes
         *
         * Diagram and implementation based on: https://wiki.openoffice.org/wiki/Number_layout
         *
         * @param {!CSSStyleSheet} styleSheet
         * @param {!string} name
         * @param {!Element} node
         * @return {undefined}
         */
        function addListStyleRule(styleSheet, name, node) {
            var selector = 'text|list[text|style-name="' + name + '"]',
                level = node.getAttributeNS(textns, "level"),
                selectorLevel,
                listItemRule,
                listLevelProps,
                listLevelPositionSpaceMode,
                listLevelLabelAlign,
                listIndent,
                textAlign,
                bulletWidth,
                labelDistance,
                bulletIndent,
                followedBy,
                leftOffset;

            // style:list-level-properties is an optional element. Since the rest of this function
            // depends on its existence, return from it if it is not found.
            listLevelProps = /**@type{!Element|undefined}*/(node.getElementsByTagNameNS(stylens, "list-level-properties")[0]);
            listLevelPositionSpaceMode = listLevelProps && listLevelProps.getAttributeNS(textns, "list-level-position-and-space-mode");
            listLevelLabelAlign = /**@type{!Element|undefined}*/(listLevelProps) &&
                                  /**@type{!Element|undefined}*/(listLevelProps.getElementsByTagNameNS(stylens, "list-level-label-alignment")[0]);

            // calculate CSS selector based on list level
            level = level && parseInt(level, 10);
            selectorLevel = level;
            while (selectorLevel > 1) {
                selector += ' > text|list-item > text|list';
                selectorLevel -= 1;
            }

            // TODO: fo:text-align is only an optional attribute with <style:list-level-properties>,
            // needs to be found what should be done if not present. For now falling back to "left"
            textAlign = (listLevelProps && listLevelProps.getAttributeNS(fons, "text-align")) || "left";
            // convert the start and end text alignments to left and right as
            // IE does not support the start and end values for text alignment
            switch (textAlign) {
                case "end":
                    textAlign = "right";
                    break;
                case "start":
                    textAlign = "left";
                    break;
            }

            // get relevant properties from the style based on the list label positioning mode
            if (listLevelPositionSpaceMode === "label-alignment") {
                // TODO: fetch the margin and indent from the paragraph style if it is defined there
                // http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#element-style_list-level-label-alignment
                // for now just fallback to "0px" if not defined on <style:list-level-label-alignment>
                listIndent = (listLevelLabelAlign && listLevelLabelAlign.getAttributeNS(fons, "margin-left")) || "0px";
                bulletIndent = (listLevelLabelAlign && listLevelLabelAlign.getAttributeNS(fons, "text-indent")) || "0px";
                followedBy = listLevelLabelAlign && listLevelLabelAlign.getAttributeNS(textns, "label-followed-by");
                leftOffset = convertToPxValue(listIndent);

            } else {
                // this block is entered if list-level-position-and-space-mode
                // has the value label-width-and-position or is not present
                // TODO: fallback values should be read from parent styles or (system) defaults
                listIndent = (listLevelProps && listLevelProps.getAttributeNS(textns, "space-before")) || "0px";
                bulletWidth = (listLevelProps && listLevelProps.getAttributeNS(textns, "min-label-width")) || "0px";
                labelDistance = (listLevelProps && listLevelProps.getAttributeNS(textns, "min-label-distance")) || "0px";
                leftOffset = convertToPxValue(listIndent) + convertToPxValue(bulletWidth);
            }

            listItemRule = selector + ' > text|list-item';
            listItemRule += '{';
            listItemRule += 'margin-left: ' + leftOffset + 'px;';
            listItemRule += '}';
            appendRule(styleSheet, listItemRule);

            listItemRule = selector + ' > text|list-item > text|list';
            listItemRule += '{';
            listItemRule += 'margin-left: ' + (-leftOffset) + 'px;';
            listItemRule += '}';
            appendRule(styleSheet, listItemRule);

            // insert the list label before every immediate child of the list-item, except for lists
            listItemRule = selector + ' > text|list-item > :not(text|list):first-child:before';
            listItemRule += '{';
            listItemRule += 'text-align: ' + textAlign + ';';
            listItemRule += 'display: inline-block;';

            if (listLevelPositionSpaceMode === "label-alignment") {
                listItemRule += 'margin-left: ' + bulletIndent + ';';
                if (followedBy === "listtab") {
                    // TODO: remove this padding once text:label-followed-by="listtab" is implemented
                    // http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#attribute-text_label-followed-by
                    listItemRule += 'padding-right: 0.2cm;';
                }
            } else {
                listItemRule += 'min-width: ' + bulletWidth + ';';
                listItemRule += 'margin-left: ' + (parseFloat(bulletWidth) === 0 ? '' : '-') + bulletWidth + ';';
                listItemRule += 'padding-right: ' + labelDistance + ';';
            }
            listItemRule += '}';
            appendRule(styleSheet, listItemRule);
        }

        /**
         * Adds a CSS rule for every ODF list style
         * @param {!CSSStyleSheet} styleSheet
         * @param {!string} name
         * @param {!Element} node
         * @return {undefined}
         */
        function addRule(styleSheet, name, node) {
            var n = node.firstElementChild;
            while (n) {
                if (n.namespaceURI === textns) {
                    addListStyleRule(styleSheet, name, n);
                }
                n = n.nextElementSibling;
            }
        }

        /**
         * Adds new CSS rules based on any properties in
         * the ODF list content if they affect the final style
         * @param {!CSSStyleSheet} styleSheet
         * @param {!Element} odfBody
         * @param {!Object.<!string, !odf.StyleTreeNode>} listStyles
         * @return {undefined}
         */
        function applyContentBasedStyles(styleSheet, odfBody, listStyles) {
            var lists = odfBody.getElementsByTagNameNS(textns, "list"),
                listCounter = new UniqueListCounter(styleSheet),
                list,
                previousList,
                continueNumbering,
                continueListXmlId,
                xmlId,
                styleName,
                contentRules,
                listsWithXmlId = {},
                i;

            for (i = 0; i < lists.length; i += 1) {
                list = /**@type{!Element}*/(lists.item(i));
                styleName = list.getAttributeNS(textns, "style-name");

                // TODO: Handle default list style
                // lists that have no text:style-name attribute defined and do not have a parent text:list that
                // defines a style name use a default implementation defined style as per the spec
                // http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#attribute-text_style-name_element-text_list

                // lists that have no text:style-name attribute defined but do have a parent list that defines a
                // style name will inherit that style and will be handled correctly as any text:list with a style defined
                // will have CSS rules applied to its child text:list elements
                if (styleName) {
                    continueNumbering = list.getAttributeNS(textns, "continue-numbering");
                    continueListXmlId = list.getAttributeNS(textns, "continue-list");
                    xmlId = list.getAttributeNS(xmlns, "id");

                    // store the list keyed by the xml:id
                    if (xmlId) {
                        listsWithXmlId[xmlId] = list;
                    }

                    contentRules = getAllContentRules(listStyles[styleName].element);

                    // lists with different styles cannot be continued
                    // https://tools.oasis-open.org/issues/browse/OFFICE-3558
                    if (continueNumbering && !continueListXmlId && isMatchingListStyle(previousList, styleName)) {
                        listCounter.createCounterRules(contentRules, list, previousList);
                    } else if (continueListXmlId && isMatchingListStyle(listsWithXmlId[continueListXmlId], styleName)) {
                        listCounter.createCounterRules(contentRules, list, listsWithXmlId[continueListXmlId]);
                    } else {
                        listCounter.createCounterRules(contentRules, list);
                    }
                    previousList = list;
                }
            }

            listCounter.initialiseCreatedCounters();
        }

        /**
         * Creates CSS styles from the given ODF list styles and applies them to the stylesheet
         * @param {!CSSStyleSheet} styleSheet
         * @param {!odf.StyleTree.Tree} styleTree
         * @param {!Element} odfBody
         * @return {undefined}
         */
        this.applyListStyles = function (styleSheet, styleTree, odfBody) {
            var styleFamilyTree,
                node;

            /*jslint sub:true*/
            // The available families are defined in StyleUtils.familyNamespacePrefixes.
            styleFamilyTree = (styleTree["list"]);
            /*jslint sub:false*/
            if (styleFamilyTree) {
                Object.keys(styleFamilyTree).forEach(function (styleName) {
                    node = /**@type{!odf.StyleTreeNode}*/(styleFamilyTree[styleName]);
                    addRule(styleSheet, styleName, node.element);
                });
            }

            applyContentBasedStyles(styleSheet, odfBody, styleFamilyTree);
        };
    };
}());


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\Namespaces.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf*/

/**
 * Singleton object which provides namespace ids and
 * some utility methods related to prefixes and namespaces
 * @const
 */
odf.Namespaces = {
    namespaceMap: {
        config: "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
        db: "urn:oasis:names:tc:opendocument:xmlns:database:1.0",
        dc: "http://purl.org/dc/elements/1.1/",
        dr3d: "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
        draw: "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
        chart: "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
        fo: "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
        form: "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
        math: "http://www.w3.org/1998/Math/MathML",
        meta: "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
        number: "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
        office: "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
        presentation: "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
        style: "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
        svg: "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
        table: "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
        text: "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
        xforms: "http://www.w3.org/2002/xforms",
        xlink: 'http://www.w3.org/1999/xlink',
        xml: "http://www.w3.org/XML/1998/namespace"
    },
    /**@type{!Object.<string,string>}*/
    prefixMap: {},
    configns: "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
    dbns: "urn:oasis:names:tc:opendocument:xmlns:database:1.0",
    dcns: "http://purl.org/dc/elements/1.1/",
    dr3dns: "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
    drawns: "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    chartns: "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
    /**
     * @const
     * @type{string}
     */
    fons: "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    formns: "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
    mathns: "http://www.w3.org/1998/Math/MathML",
    metans: "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
    /**
     * @const
     * @type{string}
     */
    numberns: "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    /**
     * @const
     * @type{string}
     */
    officens: "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    presentationns: "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
    /**
     * @const
     * @type{string}
     */
    stylens: "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    /**
     * @const
     * @type{string}
     */
    svgns: "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    tablens: "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    /**
     * @const
     * @type{string}
     */
    textns: "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    xformsns: "http://www.w3.org/2002/xforms",
    xlinkns: 'http://www.w3.org/1999/xlink',
    xmlns: "http://www.w3.org/XML/1998/namespace"
};

(function () {
    "use strict";
    // map namespacemap to prefix map on startup
    var map = odf.Namespaces.namespaceMap,
        /**@type{!Object.<string,string>}*/
        pmap = odf.Namespaces.prefixMap,
        /**@type{string}*/
        prefix;

    for (prefix in map) {
        if (map.hasOwnProperty(prefix)) {
            pmap[map[prefix]] = prefix;
        }
    }
}());

/**
 * Calls the passed callback for all pairs of prefix and namespace
 * which are in the namespaceMap property
 * @param {function(string,string):undefined} cb
 * @return {undefined}
 */
odf.Namespaces.forEachPrefix = function forEachPrefix(cb) {
    "use strict";
    var /**@type{!Object.<string,string>}*/
        ns = odf.Namespaces.namespaceMap,
        /**@type{string}*/
        prefix;

    for (prefix in ns) {
        if (ns.hasOwnProperty(prefix)) {
            cb(prefix, ns[prefix]);
        }
    }
};

/**
 * Returns the namespace belonging to the prefix or null.
 * @param {string} prefix
 * @return {?string}
 */
odf.Namespaces.lookupNamespaceURI = function lookupNamespaceURI(prefix) {
    "use strict";
    var /**@type{?string}*/
        r = null;
    if (odf.Namespaces.namespaceMap.hasOwnProperty(prefix)) {
        r = /**@type{string}*/(odf.Namespaces.namespaceMap[prefix]);
    }
    return r;
};

/**
 * Returns the prefix belonging to the NamespaceURI or null.
 * @param {string} namespaceURI
 * @return {?string}
 */
odf.Namespaces.lookupPrefix = function lookupPrefix(namespaceURI) {
    "use strict";
    var /**@type{!Object.<string,string>}*/
        map = odf.Namespaces.prefixMap;
    return map.hasOwnProperty(namespaceURI) ? map[namespaceURI] : null;
};

// TODO: document where and why this is needed
odf.Namespaces.lookupNamespaceURI.lookupNamespaceURI = odf.Namespaces.lookupNamespaceURI;


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\ObjectNameGenerator.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, runtime, core, Node*/

/**
 * Helper object for generating unique object names. Each name is only reported once per instance,
 * irrespective of whether it is actually then inserted into the dom tree in the odfContainer.
 *
 * There is expected to be a single instance of the object name generator created per session. This is necessary
 * to close a potential race condition when generating unique names for operations. As there is no guarantee
 * when a given op is executed, it is insufficient to simply rely on all previously generated names to be now present
 * in the document definitions. To cope with this, the names generated by this instance are also cached for
 * the lifetime of this object.
 *
 * Failure to do this could result in a situation like the following
 * 1. SessionController generates new OpAddStyle & adds to session's queue
 * 2. SessionController generates another OpAddStyle & adds to session's queue
 *
 * At step 2, as the session's queue implementation has no requirement that it immediately executes the operation from
 * step 1, it is likely that the style created in step 1 is not yet present in the document DOM.
 *
 * @param {!odf.OdfContainer} odfContainer
 * @param {!string} memberId
 * @constructor
 */
odf.ObjectNameGenerator = function ObjectNameGenerator(odfContainer, memberId) {
    "use strict";
    var stylens = odf.Namespaces.stylens,
        drawns = odf.Namespaces.drawns,
        xlinkns = odf.Namespaces.xlinkns,
        utils = new core.Utils(),
        memberIdHash = utils.hashString(memberId),
        styleNameGenerator = null,
        frameNameGenerator = null,
        imageNameGenerator = null,
        existingFrameNames = {},
        existingImageNames = {};

    /**
     * @param {string} prefix Prefix to use for unique name generation
     * @param {function():!Object.<string,boolean>} findExistingNames
     * @constructor
     */
    function NameGenerator(prefix, findExistingNames) {
        var /**@type{!Object.<string,boolean>}*/
            reportedNames = {};
        /**
         * Generate a unique name
         * @return {string}
         */
        this.generateName = function () {
            var existingNames = findExistingNames(),
                startIndex = 0,
                name;
            do {
                name = prefix + startIndex;
                startIndex += 1;
            } while (reportedNames[name] || existingNames[name]);
            reportedNames[name] = true;
            return name;
        };
    }

    /**
     * Get all the style names defined in the style:style elements of the
     * current document including automatic styles.
     *
     * @return {!Object.<string,boolean>}
     */
    function getAllStyleNames() {
        var styleElements = [
                odfContainer.rootElement.automaticStyles,
                odfContainer.rootElement.styles
            ],
            styleNames = {};

        /**
         * @param {!Element} styleListElement
         */
        function getStyleNames(styleListElement) {
            var e = styleListElement.firstElementChild;
            while (e) {
                if (e.namespaceURI === stylens && e.localName === "style") {
                    styleNames[e.getAttributeNS(stylens, 'name')] = true;
                }
                e = e.nextElementSibling;
            }
        }
        styleElements.forEach(getStyleNames);
        return styleNames;
    }

    /**
     * Generate a unique style name across the style:style elements
     * @return {!string}
     */
    this.generateStyleName = function () {
        if (styleNameGenerator === null) {
            styleNameGenerator = new NameGenerator(
                "auto" + memberIdHash + "_",
                function () {
                    // TODO: can cache the existing names once we fix the todo in formatting.applyStyle
                    return getAllStyleNames();
                }
            );
        }
        return styleNameGenerator.generateName();
    };
    /**
     * Generate a unique frame name
     * @return {!string}
     */
    this.generateFrameName = function () {
        var i, nodes, node;
        if (frameNameGenerator === null) {
            nodes = odfContainer.rootElement.body.getElementsByTagNameNS(drawns, 'frame');
            for (i = 0; i < nodes.length; i += 1) {
                node = /**@type{!Element}*/(nodes.item(i));
                existingFrameNames[node.getAttributeNS(drawns, 'name')] = true;
            }

            frameNameGenerator = new NameGenerator(
                "fr" + memberIdHash + "_",
                function () {
                    return existingFrameNames;
                }
            );
        }
        return frameNameGenerator.generateName();
    };
    /**
     * Generate a unique image name
     * @return {!string}
     */
    this.generateImageName = function () {
        var i, path, nodes, node;

        if (imageNameGenerator === null) {
            nodes = odfContainer.rootElement.body.getElementsByTagNameNS(drawns, 'image');
            for (i = 0; i < nodes.length; i += 1) {
                node = /**@type{!Element}*/(nodes.item(i));
                path = node.getAttributeNS(xlinkns, 'href');
                path = path.substring("Pictures/".length, path.lastIndexOf('.'));
                existingImageNames[path] = true;
            }

            imageNameGenerator = new NameGenerator(
                "img" + memberIdHash + "_",
                function () {
                    return existingImageNames;
                }
            );
        }
        return imageNameGenerator.generateName();
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\OdfCanvas.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf, xmldom, webodf_css, core, gui */
/*jslint sub: true*/

(function () {
    "use strict";
    /**
     * A loading queue where various tasks related to loading can be placed
     * and will be run with 10 ms between them. This gives the ui a change to
     * to update.
     * @constructor
     */
    function LoadingQueue() {
        var /**@type{!Array.<!Function>}*/
            queue = [],
            taskRunning = false;
        /**
         * @param {!Function} task
         * @return {undefined}
         */
        function run(task) {
            taskRunning = true;
            runtime.setTimeout(function () {
                try {
                    task();
                } catch (/**@type{Error}*/e) {
                    runtime.log(String(e) + "\n" + e.stack);
                }
                taskRunning = false;
                if (queue.length > 0) {
                    run(queue.pop());
                }
            }, 10);
        }
        /**
         * @return {undefined}
         */
        this.clearQueue = function () {
            queue.length = 0;
        };
        /**
         * @param {!Function} loadingTask
         * @return {undefined}
         */
        this.addToQueue = function (loadingTask) {
            if (queue.length === 0 && !taskRunning) {
                return run(loadingTask);
            }
            queue.push(loadingTask);
        };
    }
    /**
     * @constructor
     * @implements {core.Destroyable}
     * @param {!HTMLStyleElement} css
     */
    function PageSwitcher(css) {
        var sheet = /**@type{!CSSStyleSheet}*/(css.sheet),
            /**@type{number}*/
            position = 1;
        /**
         * @return {undefined}
         */
        function updateCSS() {
            while (sheet.cssRules.length > 0) {
                sheet.deleteRule(0);
            }
            // The #shadowContent contains the master pages, with each page in the slideshow
            // corresponding to a master page in #shadowContent, and in the same order.
            // So, when showing a page, also make it's master page (behind it) visible.
            sheet.insertRule('#shadowContent draw|page {display:none;}', 0);
            sheet.insertRule('office|presentation draw|page {display:none;}', 1);
            sheet.insertRule("#shadowContent draw|page:nth-of-type(" +
                position + ") {display:block;}", 2);
            sheet.insertRule("office|presentation draw|page:nth-of-type(" +
                position + ") {display:block;}", 3);
        }
        /**
         * @return {undefined}
         */
        this.showFirstPage = function () {
            position = 1;
            updateCSS();
        };
        /**
         * @return {undefined}
         */
        this.showNextPage = function () {
            position += 1;
            updateCSS();
        };
        /**
         * @return {undefined}
         */
        this.showPreviousPage = function () {
            if (position > 1) {
                position -= 1;
                updateCSS();
            }
        };

        /**
         * @param {!number} n  number of the page
         * @return {undefined}
         */
        this.showPage = function (n) {
            if (n > 0) {
                position = n;
                updateCSS();
            }
        };

        this.css = css;

        /**
         * @param {!function(!Error=)} callback, passing an error object in case of error
         * @return {undefined}
         */
        this.destroy = function (callback) {
            css.parentNode.removeChild(css);
            callback();
        };
    }
    /**
     * Register event listener on DOM element.
     * @param {!Element} eventTarget
     * @param {!string} eventType
     * @param {!Function} eventHandler
     * @return {undefined}
     */
    function listenEvent(eventTarget, eventType, eventHandler) {
        if (eventTarget.addEventListener) {
            eventTarget.addEventListener(eventType, eventHandler, false);
        } else if (eventTarget.attachEvent) {
            eventType = "on" + eventType;
            eventTarget.attachEvent(eventType, eventHandler);
        } else {
            eventTarget["on" + eventType] = eventHandler;
        }
    }

    // variables per class (so not per instance!)
    var /**@const@type {!string}*/drawns  = odf.Namespaces.drawns,
        /**@const@type {!string}*/fons    = odf.Namespaces.fons,
        /**@const@type {!string}*/officens = odf.Namespaces.officens,
        /**@const@type {!string}*/stylens = odf.Namespaces.stylens,
        /**@const@type {!string}*/svgns   = odf.Namespaces.svgns,
        /**@const@type {!string}*/tablens = odf.Namespaces.tablens,
        /**@const@type {!string}*/textns  = odf.Namespaces.textns,
        /**@const@type {!string}*/xlinkns = odf.Namespaces.xlinkns,
        /**@const@type {!string}*/presentationns = odf.Namespaces.presentationns,
        /**@const@type {!string}*/webodfhelperns = "urn:webodf:names:helper",
        xpath = xmldom.XPath,
        domUtils = core.DomUtils;

    /**
     * @param {!HTMLStyleElement} style
     * @return {undefined}
     */
    function clearCSSStyleSheet(style) {
        var stylesheet = /**@type{!CSSStyleSheet}*/(style.sheet),
            cssRules = stylesheet.cssRules;

        while (cssRules.length) {
            stylesheet.deleteRule(cssRules.length - 1);
        }
    }

    /**
     * A new styles.xml has been loaded. Update the live document with it.
     * @param {!odf.OdfContainer} odfcontainer
     * @param {!odf.Formatting} formatting
     * @param {!HTMLStyleElement} stylesxmlcss
     * @return {undefined}
     **/
    function handleStyles(odfcontainer, formatting, stylesxmlcss) {
        // update the css translation of the styles
        var style2css = new odf.Style2CSS(),
            list2css = new odf.ListStyleToCss(),
            styleSheet = /**@type{!CSSStyleSheet}*/(stylesxmlcss.sheet),
            styleTree = new odf.StyleTree(
                odfcontainer.rootElement.styles,
                odfcontainer.rootElement.automaticStyles).getStyleTree();

        style2css.style2css(
            odfcontainer.getDocumentType(),
            odfcontainer.rootElement,
            styleSheet,
            formatting.getFontMap(),
            styleTree
        );

        list2css.applyListStyles(
            styleSheet,
            styleTree,
            odfcontainer.rootElement.body);

    }

    /**
     * @param {!odf.OdfContainer} odfContainer
     * @param {!HTMLStyleElement} fontcss
     * @return {undefined}
     **/
    function handleFonts(odfContainer, fontcss) {
        // update the css references to the fonts
        var fontLoader = new odf.FontLoader();
        fontLoader.loadFonts(odfContainer,
            /**@type{!CSSStyleSheet}*/(fontcss.sheet));
    }

    /**
     * @param {!Element} clonedNode <draw:page/>
     * @return {undefined}
     */
    function dropTemplateDrawFrames(clonedNode) {
        // drop all frames which are just template frames
        var i, element, presentationClass,
            clonedDrawFrameElements = domUtils.getElementsByTagNameNS(clonedNode, drawns, 'frame');
        for (i = 0; i < clonedDrawFrameElements.length; i += 1) {
            element = /**@type{!Element}*/(clonedDrawFrameElements[i]);
            presentationClass = element.getAttributeNS(presentationns, 'class');
            if (presentationClass && ! /^(date-time|footer|header|page-number)$/.test(presentationClass)) {
                element.parentNode.removeChild(element);
            }
        }
    }

    /**
     * @param {!odf.OdfContainer} odfContainer
     * @param {!Element} frame
     * @param {!string} headerFooterId
     * @return {?string}
     */
    function getHeaderFooter(odfContainer, frame, headerFooterId) {
        var headerFooter = null,
            i,
            declElements = odfContainer.rootElement.body.getElementsByTagNameNS(presentationns, headerFooterId+'-decl'),
            headerFooterName = frame.getAttributeNS(presentationns, 'use-'+headerFooterId+'-name'),
            element;

        if (headerFooterName && declElements.length > 0) {
            for (i = 0; i < declElements.length; i += 1) {
                element = /**@type{!Element}*/(declElements[i]);
                if (element.getAttributeNS(presentationns, 'name') === headerFooterName) {
                    headerFooter = element.textContent;
                    break;
                }
            }
        }
        return headerFooter;
    }

    /**
     * @param {!Element} rootElement
     * @param {string} ns
     * @param {string} localName
     * @param {?string} value
     * @return {undefined}
     */
    function setContainerValue(rootElement, ns, localName, value) {
        var i, containerList,
            document = rootElement.ownerDocument,
            e;

        containerList = domUtils.getElementsByTagNameNS(rootElement, ns, localName);
        for (i = 0; i < containerList.length; i += 1) {
            domUtils.removeAllChildNodes(containerList[i]);
            if (value) {
                e = /**@type{!Element}*/(containerList[i]);
                e.appendChild(document.createTextNode(value));
            }
        }
    }

    /**
     * @param {string} styleid
     * @param {!Element} frame
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     **/
    function setDrawElementPosition(styleid, frame, stylesheet) {
        frame.setAttributeNS(webodfhelperns, 'styleid', styleid);
        var rule,
            anchor = frame.getAttributeNS(textns, 'anchor-type'),
            x = frame.getAttributeNS(svgns, 'x'),
            y = frame.getAttributeNS(svgns, 'y'),
            width = frame.getAttributeNS(svgns, 'width'),
            height = frame.getAttributeNS(svgns, 'height'),
            minheight = frame.getAttributeNS(fons, 'min-height'),
            minwidth = frame.getAttributeNS(fons, 'min-width');

        if (anchor === "as-char") {
            rule = 'display: inline-block;';
        } else if (anchor || x || y) {
            rule = 'position: absolute;';
        } else if (width || height || minheight || minwidth) {
            rule = 'display: block;';
        }
        if (x) {
            rule += 'left: ' + x + ';';
        }
        if (y) {
            rule += 'top: ' + y + ';';
        }
        if (width) {
            rule += 'width: ' + width + ';';
        }
        if (height) {
            rule += 'height: ' + height + ';';
        }
        if (minheight) {
            rule += 'min-height: ' + minheight + ';';
        }
        if (minwidth) {
            rule += 'min-width: ' + minwidth + ';';
        }
        if (rule) {
            rule = 'draw|' + frame.localName + '[webodfhelper|styleid="' + styleid + '"] {' +
                rule + '}';
            stylesheet.insertRule(rule, stylesheet.cssRules.length);
        }
    }
    /**
     * @param {!Element} image
     * @return {string}
     **/
    function getUrlFromBinaryDataElement(image) {
        var node = image.firstChild;
        while (node) {
            if (node.namespaceURI === officens &&
                    node.localName === "binary-data") {
                // TODO: detect mime-type, assuming png for now
                // the base64 data can be  pretty printed, hence we need remove all the line breaks and whitespaces
                return "data:image/png;base64," + node.textContent.replace(/[\r\n\s]/g, '');
            }
            node = node.nextSibling;
        }
        return "";
    }
    /**
     * @param {string} id
     * @param {!odf.OdfContainer} container
     * @param {!Element} image
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     **/
    function setImage(id, container, image, stylesheet) {
        image.setAttributeNS(webodfhelperns, 'styleid', id);
        var url = image.getAttributeNS(xlinkns, 'href'),
            /**@type{!odf.OdfPart}*/
            part;
        /**
         * @param {?string} url
         */
        function callback(url) {
            var rule;
            if (url) { // if part cannot be loaded, url is null
                rule = "background-image: url(" + url + ");";
                rule = 'draw|image[webodfhelper|styleid="' + id + '"] {' + rule + '}';
                stylesheet.insertRule(rule, stylesheet.cssRules.length);
            }
        }
        /**
         * @param {!odf.OdfPart} p
         */
        function onchange(p) {
            callback(p.url);
        }
        // look for a office:binary-data
        if (url) {
            try {
                part = container.getPart(url);
                part.onchange = onchange;
                part.load();
            } catch (/**@type{*}*/e) {
                runtime.log('slight problem: ' + String(e));
            }
        } else {
            url = getUrlFromBinaryDataElement(image);
            callback(url);
        }
    }
    /**
     * @param {!Element} odfbody
     * @return {undefined}
     */
    function formatParagraphAnchors(odfbody) {
        var n,
            i,
            nodes = xpath.getODFElementsWithXPath(odfbody,
                ".//*[*[@text:anchor-type='paragraph']]",
                odf.Namespaces.lookupNamespaceURI);
        for (i = 0; i < nodes.length; i += 1) {
            n = nodes[i];
            if (n.setAttributeNS) {
                n.setAttributeNS(webodfhelperns, "containsparagraphanchor", true);
            }
        }
    }
    /**
     * Modify tables to support merged cells (col/row span)
     * @param {!Element} odffragment
     * @param {!string} documentns
     * @return {undefined}
     */
    function modifyTables(odffragment, documentns) {
        var i,
            tableCells,
            node;

        /**
         * @param {!Element} node
         * @return {undefined}
         */
        function modifyTableCell(node) {
            // If we have a cell which spans columns or rows,
            // then add col-span or row-span attributes.
            if (node.hasAttributeNS(tablens, "number-columns-spanned")) {
                node.setAttributeNS(documentns, "colspan",
                    node.getAttributeNS(tablens, "number-columns-spanned"));
            }
            if (node.hasAttributeNS(tablens, "number-rows-spanned")) {
                node.setAttributeNS(documentns, "rowspan",
                    node.getAttributeNS(tablens, "number-rows-spanned"));
            }
        }
        tableCells = domUtils.getElementsByTagNameNS(odffragment, tablens, 'table-cell');
        for (i = 0; i < tableCells.length; i += 1) {
            node = /**@type{!Element}*/(tableCells[i]);
            modifyTableCell(node);
        }
    }

    /**
     * Make the text:line-break elements behave like html br element.
     * @param {!Element} odffragment
     * @return {undefined}
     */
    function modifyLineBreakElements(odffragment) {
        var document = odffragment.ownerDocument,
            lineBreakElements = domUtils.getElementsByTagNameNS(odffragment, textns, "line-break");
        lineBreakElements.forEach(function (lineBreak) {
            // Make sure we don't add br more than once as this method is executed whenever user undo an operation.
            if (!lineBreak.hasChildNodes()) {
                lineBreak.appendChild(document.createElement("br"));
            }
        });
    }

    /**
     * Expand ODF spaces of the form <text:s text:c=N/> to N consecutive
     * <text:s/> elements. This makes things simpler for WebODF during
     * handling of spaces, in particular during editing.
     * @param {!Element} odffragment
     * @return {undefined}
     */
    function expandSpaceElements(odffragment) {
        var spaces,
            doc = odffragment.ownerDocument;

        /**
         * @param {!Element} space
         * @return {undefined}
         */
        function expandSpaceElement(space) {
            var j, count;
            // If the space has any children, remove them and put a " " text
            // node in place.
            domUtils.removeAllChildNodes(space);
            space.appendChild(doc.createTextNode(" "));

            count = parseInt(space.getAttributeNS(textns, "c"), 10);
            if (count > 1) {
                // Make it a 'simple' space node
                space.removeAttributeNS(textns, "c");
                // Prepend count-1 clones of this space node to itself
                for (j = 1; j < count; j += 1) {
                    space.parentNode.insertBefore(space.cloneNode(true), space);
                }
            }
        }

        spaces = domUtils.getElementsByTagNameNS(odffragment, textns, "s");
        spaces.forEach(expandSpaceElement);
    }

    /**
     * Expand tabs to contain tab characters. This eases cursor behaviour
     * during editing
     * @param {!Element} odffragment
     */
    function expandTabElements(odffragment) {
        var tabs;

        tabs = domUtils.getElementsByTagNameNS(odffragment, textns, "tab");
        tabs.forEach(function(tab) {
            tab.textContent = "\t";
        });
    }
    /**
     * @param {!Element} odfbody
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     **/
    function modifyDrawElements(odfbody, stylesheet) {
        var node,
            /**@type{!Array.<!Element>}*/
            drawElements = [],
            i;
        // find all the draw:* elements
        node = odfbody.firstElementChild;
        while (node && node !== odfbody) {
            if (node.namespaceURI === drawns) {
                drawElements[drawElements.length] = node;
            }
            if (node.firstElementChild) {
                node = node.firstElementChild;
            } else {
                while (node && node !== odfbody && !node.nextElementSibling) {
                    node = /**@type{!Element}*/(node.parentNode);
                }
                if (node && node.nextElementSibling) {
                    node = node.nextElementSibling;
                }
            }
        }
        // adjust all the frame positions
        for (i = 0; i < drawElements.length; i += 1) {
            node = drawElements[i];
            setDrawElementPosition('frame' + String(i), node, stylesheet);
        }
        formatParagraphAnchors(odfbody);
    }

    /**
     * @param {!odf.Formatting} formatting
     * @param {!odf.OdfContainer} odfContainer
     * @param {!Element} shadowContent
     * @param {!Element} odfbody
     * @param {!CSSStyleSheet} stylesheet
     * @return {undefined}
     **/
    function cloneMasterPages(formatting, odfContainer, shadowContent, odfbody, stylesheet) {
        var masterPageName,
            masterPageElement,
            styleId,
            clonedPageElement,
            clonedElement,
            clonedDrawElements,
            pageNumber = 0,
            i,
            element,
            elementToClone,
            document = odfContainer.rootElement.ownerDocument;

        element = odfbody.firstElementChild;
        // no master pages to expect?
        if (!(element && element.namespaceURI === officens &&
              (element.localName === "presentation" || element.localName === "drawing"))) {
            return;
        }

        element = element.firstElementChild;
        while (element) {
            // If there was a master-page-name attribute, then we are dealing with a draw:page.
            // Get the referenced master page element from the master styles
            masterPageName = element.getAttributeNS(drawns, 'master-page-name');
            masterPageElement = masterPageName ? formatting.getMasterPageElement(masterPageName) : null;

            // If the referenced master page exists, create a new page and copy over it's contents into the new page,
            // except for the ones that are placeholders. Also, call setDrawElementPosition on each of those child frames.
            if (masterPageElement) {
                styleId = element.getAttributeNS(webodfhelperns, 'styleid');
                clonedPageElement = document.createElementNS(drawns, 'draw:page');

                elementToClone = masterPageElement.firstElementChild;
                i = 0;
                while (elementToClone) {
                    if (elementToClone.getAttributeNS(presentationns, 'placeholder') !== 'true') {
                        clonedElement = /**@type{!Element}*/(elementToClone.cloneNode(true));
                        clonedPageElement.appendChild(clonedElement);
                    }
                    elementToClone = elementToClone.nextElementSibling;
                    i += 1;
                }
                // TODO: above already do not clone nodes which match the rule for being dropped
                dropTemplateDrawFrames(clonedPageElement);

                // Position all elements
                clonedDrawElements = domUtils.getElementsByTagNameNS(clonedPageElement, drawns, '*');
                for (i = 0; i < clonedDrawElements.length; i += 1) {
                    setDrawElementPosition(styleId + '_' + i, clonedDrawElements[i], stylesheet);
                }

                // Append the cloned master page to the "Shadow Content" element outside the main ODF dom
                shadowContent.appendChild(clonedPageElement);

                // Get the page number by counting the number of previous master pages in this shadowContent
                pageNumber = String(shadowContent.getElementsByTagNameNS(drawns, 'page').length);
                // Get the page-number tag in the cloned master page and set the text content to the calculated number
                setContainerValue(clonedPageElement, textns, 'page-number', pageNumber);

                // Care for header
                setContainerValue(clonedPageElement, presentationns, 'header', getHeaderFooter(odfContainer, /**@type{!Element}*/(element), 'header'));
                // Care for footer
                setContainerValue(clonedPageElement, presentationns, 'footer', getHeaderFooter(odfContainer, /**@type{!Element}*/(element), 'footer'));

                // Now call setDrawElementPosition on this new page to set the proper dimensions
                setDrawElementPosition(styleId, clonedPageElement, stylesheet);
                // Add a custom attribute with the style name of the normal page, so the CSS rules created for the styles of the normal page
                // to display/hide frames of certain classes from the master page can address the cloned master page belonging to that normal page
                // Cmp. addDrawPageFrameDisplayRules in Style2CSS
                clonedPageElement.setAttributeNS(webodfhelperns, 'page-style-name', element.getAttributeNS(drawns, 'style-name'));
                // TODO: investigate if the attributes draw:style-name and style:page-layoutname should be copied over
                // to the cloned page from the master page as well, or if this one below is enough already
                // And finally, add an attribute referring to the master page, so the CSS targeted for that master page will style this
                clonedPageElement.setAttributeNS(drawns, 'draw:master-page-name', masterPageElement.getAttributeNS(stylens, 'name'));
            }

            element = element.nextElementSibling;
        }
    }

    /**
     * @param {!odf.OdfContainer} container
     * @param {!Element} plugin
     * @return {undefined}
     **/
    function setVideo(container, plugin) {
        var video, source, url, doc = plugin.ownerDocument,
            /**@type{!odf.OdfPart}*/
            part;

        url = plugin.getAttributeNS(xlinkns, 'href');

        /**
         * @param {?string} url
         * @param {string} mimetype
         * @return {undefined}
         */
        function callback(url, mimetype) {
            var ns = doc.documentElement.namespaceURI;
            // test for video mimetypes
            if (mimetype.substr(0, 6) === 'video/') {
                video = doc.createElementNS(ns, "video");
                video.setAttribute('controls', 'controls');

                source = doc.createElementNS(ns, 'source');
                if (url) {
                    source.setAttribute('src', url);
                }
                source.setAttribute('type', mimetype);

                video.appendChild(source);
                plugin.parentNode.appendChild(video);
            } else {
                plugin.innerHtml = 'Unrecognised Plugin';
            }
        }
        /**
         * @param {!odf.OdfPart} p
         */
        function onchange(p) {
            callback(p.url, p.mimetype);
        }
        // look for a office:binary-data
        if (url) {
            try {
                part = container.getPart(url);
                part.onchange = onchange;
                part.load();
            } catch (/**@type{*}*/e) {
                runtime.log('slight problem: ' + String(e));
            }
        } else {
        // this will fail  atm - following function assumes PNG data]
            runtime.log('using MP4 data fallback');
            url = getUrlFromBinaryDataElement(plugin);
            callback(url, 'video/mp4');
        }
    }

    /**
     * @param {!HTMLHeadElement} head
     * @return {?HTMLStyleElement}
     */
    function findWebODFStyleSheet(head) {
        var style = head.firstElementChild;
        while (style && !(style.localName === "style"
                && style.hasAttribute("webodfcss"))) {
            style = style.nextElementSibling;
        }
        return /**@type{?HTMLStyleElement}*/(style);
    }

    /**
     * @param {!Document} document
     * @return {!HTMLStyleElement}
     */
    function addWebODFStyleSheet(document) {
        var head = /**@type{!HTMLHeadElement}*/(document.getElementsByTagName('head')[0]),
            css,
            /**@type{?HTMLStyleElement}*/
            style,
            href,
            count = document.styleSheets.length;
        // make sure this is only added once per HTML document, e.g. in case of
        // multiple odfCanvases
        style = findWebODFStyleSheet(head);
        if (style) {
            count = parseInt(style.getAttribute("webodfcss"), 10);
            style.setAttribute("webodfcss", count + 1);
            return style;
        }
        if (String(typeof webodf_css) === "string") {
            css = /**@type{!string}*/(webodf_css);
        } else {
            href = "webodf.css";
            if (runtime.currentDirectory) {
                href = runtime.currentDirectory();
                if (href.length > 0 && href.substr(-1) !== "/") {
                    href += "/";
                }
                href += "../webodf.css";
            }
            css = /**@type{!string}*/(runtime.readFileSync(href, "utf-8"));
        }
        style = /**@type{!HTMLStyleElement}*/(document.createElementNS(head.namespaceURI, 'style'));
        style.setAttribute('media', 'screen, print, handheld, projection');
        style.setAttribute('type', 'text/css');
        style.setAttribute('webodfcss', '1');
        style.appendChild(document.createTextNode(css));
        head.appendChild(style);
        return style;
    }

    /**
     * @param {!HTMLStyleElement} webodfcss
     * @return {undefined}
     */
    function removeWebODFStyleSheet(webodfcss) {
        var count = parseInt(webodfcss.getAttribute("webodfcss"), 10);
        if (count === 1) {
             webodfcss.parentNode.removeChild(webodfcss);
        } else {
             webodfcss.setAttribute("count", count - 1);
        }
    }

    /**
     * @param {!Document} document Put and ODF Canvas inside this element.
     * @return {!HTMLStyleElement}
     */
    function addStyleSheet(document) {
        var head = /**@type{!HTMLHeadElement}*/(document.getElementsByTagName('head')[0]),
            style = document.createElementNS(head.namespaceURI, 'style'),
            /**@type{string}*/
            text = '';
        style.setAttribute('type', 'text/css');
        style.setAttribute('media', 'screen, print, handheld, projection');
        odf.Namespaces.forEachPrefix(function(prefix, ns) {
            text += "@namespace " + prefix + " url(" + ns + ");\n";
        });
        text += "@namespace webodfhelper url(" + webodfhelperns + ");\n";
        style.appendChild(document.createTextNode(text));
        head.appendChild(style);
        return /**@type {!HTMLStyleElement}*/(style);
    }
    /**
     * This class manages a loaded ODF document that is shown in an element.
     * It takes care of giving visual feedback on loading, ensures that the
     * stylesheets are loaded.
     * @constructor
     * @implements {gui.AnnotatableCanvas}
     * @implements {ops.Canvas}
     * @implements {core.Destroyable}
     * @param {!HTMLElement} element Put and ODF Canvas inside this element.
     * @param {!gui.Viewport=} viewport Viewport used for scrolling elements and ranges into view
     */
    odf.OdfCanvas = function OdfCanvas(element, viewport) {
        runtime.assert((element !== null) && (element !== undefined),
            "odf.OdfCanvas constructor needs DOM element");
        runtime.assert((element.ownerDocument !== null) && (element.ownerDocument !== undefined),
            "odf.OdfCanvas constructor needs DOM");
        var self = this,
            doc = /**@type{!Document}*/(element.ownerDocument),
            /**@type{!odf.OdfContainer}*/
            odfcontainer,
            /**@type{!odf.Formatting}*/
            formatting = new odf.Formatting(),
            /**@type{!PageSwitcher}*/
            pageSwitcher,
            /**@type{HTMLDivElement}*/
            sizer = null,
            /**@type{HTMLDivElement}*/
            annotationsPane = null,
            allowAnnotations = false,
            showAnnotationRemoveButton = false,
            /**@type{gui.AnnotationViewManager}*/
            annotationViewManager = null,
            /**@type{!HTMLStyleElement}*/
            webodfcss,
            /**@type{!HTMLStyleElement}*/
            fontcss,
            /**@type{!HTMLStyleElement}*/
            stylesxmlcss,
            /**@type{!HTMLStyleElement}*/
            positioncss,
            shadowContent,
            /**@type{!Object.<string,!Array.<!Function>>}*/
            eventHandlers = {},
            waitingForDoneTimeoutId,
            /**@type{!core.ScheduledTask}*/redrawContainerTask,
            shouldRefreshCss = false,
            shouldRerenderAnnotations = false,
            loadingQueue = new LoadingQueue(),
            /**@type{!gui.ZoomHelper}*/
            zoomHelper = new gui.ZoomHelper(),
            /**@type{!gui.Viewport}*/
            canvasViewport = viewport || new gui.SingleScrollViewport(/**@type{!HTMLElement}*/(element.parentNode));

        /**
         * Load all the images that are inside an odf element.
         * @param {!odf.OdfContainer} container
         * @param {!Element} odffragment
         * @param {!CSSStyleSheet} stylesheet
         * @return {undefined}
         */
        function loadImages(container, odffragment, stylesheet) {
            var i,
                images,
                node;
            /**
             * Do delayed loading for all the images
             * @param {string} name
             * @param {!odf.OdfContainer} container
             * @param {!Element} node
             * @param {!CSSStyleSheet} stylesheet
             * @return {undefined}
             */
            function loadImage(name, container, node, stylesheet) {
                // load image with a small delay to give the html ui a chance to
                // update
                loadingQueue.addToQueue(function () {
                    setImage(name, container, node, stylesheet);
                });
            }
            images = odffragment.getElementsByTagNameNS(drawns, 'image');
            for (i = 0; i < images.length; i += 1) {
                node = /**@type{!Element}*/(images.item(i));
                loadImage('image' + String(i), container, node, stylesheet);
            }
        }
        /**
         * Load all the video that are inside an odf element.
         * @param {!odf.OdfContainer} container
         * @param {!Element} odffragment
         * @return {undefined}
         */
        function loadVideos(container, odffragment) {
            var i,
                plugins,
                node;
            /**
             * Do delayed loading for all the videos
             * @param {!odf.OdfContainer} container
             * @param {!Element} node
             * @return {undefined}
             */
            function loadVideo(container, node) {
                // load video with a small delay to give the html ui a chance to
                // update
                loadingQueue.addToQueue(function () {
                    setVideo(container, node);
                });
            }
            // embedded video is stored in a draw:plugin element
            plugins = odffragment.getElementsByTagNameNS(drawns, 'plugin');
            for (i = 0; i < plugins.length; i += 1) {
                node = /**@type{!Element}*/(plugins.item(i));
                loadVideo(container, node);
            }
        }

        /**
         * Register an event handler
         * @param {!string} eventType
         * @param {!Function} eventHandler
         * @return {undefined}
         */
        function addEventListener(eventType, eventHandler) {
            var handlers;
            if (eventHandlers.hasOwnProperty(eventType)) {
                handlers = eventHandlers[eventType];
            } else {
                handlers = eventHandlers[eventType] = [];
            }
            if (eventHandler && handlers.indexOf(eventHandler) === -1) {
                handlers.push(eventHandler);
            }
        }
        /**
         * Fire an event
         * @param {!string} eventType
         * @param {Array.<Object>=} args
         * @return {undefined}
         */
        function fireEvent(eventType, args) {
            if (!eventHandlers.hasOwnProperty(eventType)) {
                return;
            }
            var handlers = eventHandlers[eventType], i;
            for (i = 0; i < handlers.length; i += 1) {
                handlers[i].apply(null, args);
            }
        }

        /**
         * @return {undefined}
         */
        function fixContainerSize() {
            var minHeight,
                odfdoc = sizer.firstChild,
                zoomLevel = zoomHelper.getZoomLevel();

            if (!odfdoc) {
                return;
            }

            // All zooming of the sizer within the canvas
            // is done relative to the top-left corner.
            sizer.style.WebkitTransformOrigin = "0% 0%";
            sizer.style.MozTransformOrigin = "0% 0%";
            sizer.style.msTransformOrigin = "0% 0%";
            sizer.style.OTransformOrigin = "0% 0%";
            sizer.style.transformOrigin = "0% 0%";

            if (annotationViewManager) {
                minHeight = annotationViewManager.getMinimumHeightForAnnotationPane();
                if (minHeight) {
                    sizer.style.minHeight = minHeight;
                } else {
                    sizer.style.removeProperty('min-height');
                }
            }

            element.style.width = Math.round(zoomLevel * sizer.offsetWidth) + "px";
            element.style.height = Math.round(zoomLevel * sizer.offsetHeight) + "px";
            // Re-apply inline-block to canvas element on resizing.
            // Chrome tends to forget this property after a relayout
            element.style.display = "inline-block";
        }

        /**
         * @return {undefined}
         */
        function redrawContainer() {
            if (shouldRefreshCss) {
                handleStyles(odfcontainer, formatting, stylesxmlcss);
                shouldRefreshCss = false;
                // different styles means different layout, thus different sizes
            }
            if (shouldRerenderAnnotations) {
                if (annotationViewManager) {
                    annotationViewManager.rerenderAnnotations();
                }
                shouldRerenderAnnotations = false;
            }
            fixContainerSize();
        }

        /**
         * A new content.xml has been loaded. Update the live document with it.
         * @param {!odf.OdfContainer} container
         * @param {!odf.ODFDocumentElement} odfnode
         * @return {undefined}
         **/
        function handleContent(container, odfnode) {
            var css = /**@type{!CSSStyleSheet}*/(positioncss.sheet);
            // only append the content at the end
            domUtils.removeAllChildNodes(element);

            sizer = /**@type{!HTMLDivElement}*/(doc.createElementNS(element.namespaceURI, 'div'));
            sizer.style.display = "inline-block";
            sizer.style.background = "white";
            // When the window is shrunk such that the
            // canvas container has a horizontal scrollbar,
            // zooming out seems to not make the scrollable
            // width disappear. This extra scrollable
            // width seems to be proportional to the
            // annotation pane's width. Setting the 'float'
            // of the sizer to 'left' fixes this in webkit.
            sizer.style.setProperty("float", "left", "important");
            sizer.appendChild(odfnode);
            element.appendChild(sizer);

            // An annotations pane div. Will only be shown when annotations are enabled
            annotationsPane = /**@type{!HTMLDivElement}*/(doc.createElementNS(element.namespaceURI, 'div'));
            annotationsPane.id = "annotationsPane";
            // A "Shadow Content" div. This will contain stuff like pages
            // extracted from <style:master-page>. These need to be nicely
            // styled, so we will populate this in the ODF body first. Once the
            // styling is handled, it can then be lifted out of the
            // ODF body and placed beside it, to not pollute the ODF dom.
            shadowContent = doc.createElementNS(element.namespaceURI, 'div');
            shadowContent.id = "shadowContent";
            shadowContent.style.position = 'absolute';
            shadowContent.style.top = 0;
            shadowContent.style.left = 0;
            container.getContentElement().appendChild(shadowContent);

            modifyDrawElements(odfnode.body, css);
            cloneMasterPages(formatting, container, shadowContent, odfnode.body, css);
            modifyTables(odfnode.body, element.namespaceURI);
            modifyLineBreakElements(odfnode.body);
            expandSpaceElements(odfnode.body);
            expandTabElements(odfnode.body);
            loadImages(container, odfnode.body, css);
            loadVideos(container, odfnode.body);

            sizer.insertBefore(shadowContent, sizer.firstChild);
            zoomHelper.setZoomableElement(sizer);
        }

        /**
         * This should create an annotations pane if non existent, and then populate it with annotations
         * If annotations are disallowed, it should remove the pane and all annotations
         * @param {!odf.ODFDocumentElement} odfnode
         */
        function handleAnnotations(odfnode) {
            var annotationNodes;

            if (allowAnnotations) {
                if (!annotationsPane.parentNode) {
                    sizer.appendChild(annotationsPane);
                }
                if (annotationViewManager) {
                    annotationViewManager.forgetAnnotations();
                }
                annotationViewManager = new gui.AnnotationViewManager(self, odfnode.body, annotationsPane, showAnnotationRemoveButton);
                annotationNodes = /**@type{!Array.<!odf.AnnotationElement>}*/(domUtils.getElementsByTagNameNS(odfnode.body, officens, 'annotation'));
                annotationViewManager.addAnnotations(annotationNodes);

                fixContainerSize();
            } else {
                if (annotationsPane.parentNode) {
                    sizer.removeChild(annotationsPane);
                    annotationViewManager.forgetAnnotations();
                    fixContainerSize();
                }
            }
        }

        /**
         * @param {boolean} suppressEvent Suppress the statereadychange event from firing. Used for refreshing the OdtContainer
         * @return {undefined}
         **/
        function refreshOdf(suppressEvent) {

            // synchronize the object a window.odfcontainer with the view
            function callback() {
                // clean up
                clearCSSStyleSheet(fontcss);
                clearCSSStyleSheet(stylesxmlcss);
                clearCSSStyleSheet(positioncss);

                domUtils.removeAllChildNodes(element);

                // setup
                element.style.display = "inline-block";
                var odfnode = odfcontainer.rootElement;
                element.ownerDocument.importNode(odfnode, true);

                formatting.setOdfContainer(odfcontainer);
                handleFonts(odfcontainer, fontcss);
                handleStyles(odfcontainer, formatting, stylesxmlcss);
                // do content last, because otherwise the document is constantly
                // updated whenever the css changes
                handleContent(odfcontainer, odfnode);
                handleAnnotations(odfnode);

                if (!suppressEvent) {
                    loadingQueue.addToQueue(function () {
                        fireEvent("statereadychange", [odfcontainer]);
                    });
                }
            }

            if (odfcontainer.state === odf.OdfContainer.DONE) {
                callback();
            } else {
                // so the ODF is not done yet. take care that we'll
                // do the work once it is done:

                // FIXME: use callback registry instead of replacing the onchange
                runtime.log("WARNING: refreshOdf called but ODF was not DONE.");

                waitingForDoneTimeoutId = runtime.setTimeout(function later_cb() {
                    if (odfcontainer.state === odf.OdfContainer.DONE) {
                        callback();
                    } else {
                        runtime.log("will be back later...");
                        waitingForDoneTimeoutId = runtime.setTimeout(later_cb, 500);
                    }
                }, 100);
            }
        }

        /**
         * Updates the CSS rules to match the ODF document styles and also
         * updates the size of the canvas to match the new layout.
         * Needs to be called after changes to the styles of the ODF document.
         * @return {undefined}
         */
        this.refreshCSS = function () {
            shouldRefreshCss = true;
            redrawContainerTask.trigger();
        };

        /**
         * Updates the size of the canvas to the size of the content.
         * Needs to be called after changes to the content of the ODF document.
         * @return {undefined}
         */
        this.refreshSize = function () {
            redrawContainerTask.trigger();
        };
        /**
         * @return {!odf.OdfContainer}
         */
        this.odfContainer = function () {
            return odfcontainer;
        };
        /**
         * Set a odfcontainer manually.
         * @param {!odf.OdfContainer} container
         * @param {boolean=} suppressEvent Default value is false
         * @return {undefined}
         */
        this.setOdfContainer = function (container, suppressEvent) {
            odfcontainer = container;
            refreshOdf(suppressEvent === true);
        };
        /**
         * @param {string} url
         * @return {undefined}
         */
        function load(url) {
            // clean up
            loadingQueue.clearQueue();

            // FIXME: We need to support parametrized strings, because
            // drop-in word replacements are inadequate for translations;
            // see http://techbase.kde.org/Development/Tutorials/Localization/i18n_Mistakes#Pitfall_.232:_Word_Puzzles
            domUtils.removeAllChildNodes(element);
            element.appendChild(element.ownerDocument.createTextNode(runtime.tr('Loading') + url + '...'));
            element.removeAttribute('style');
            // open the odf container
            odfcontainer = new odf.OdfContainer(url, function (container) {
                // assignment might be necessary if the callback
                // fires before the assignment above happens.
                odfcontainer = container;
                refreshOdf(false);
            });
        }
        this["load"] = load;
        this.load = load;

        /**
         * @param {function(?string):undefined} callback
         * @return {undefined}
         */
        this.save = function (callback) {
            odfcontainer.save(callback);
        };

        /**
         * @param {!string} eventName
         * @param {!function(*)} handler
         * @return {undefined}
         */
        this.addListener = function (eventName, handler) {
            switch (eventName) {
            case "click":
                listenEvent(element, eventName, handler); break;
            default:
                addEventListener(eventName, handler); break;
            }
        };

        /**
         * @return {!odf.Formatting}
         */
        this.getFormatting = function () {
            return formatting;
        };

        /**
         * @return {gui.AnnotationViewManager}
         */
        this.getAnnotationViewManager = function () {
            return annotationViewManager;
        };

        /**
         * Unstyles and untracks all annotations present in the document,
         * and then tracks them again with fresh rendering
         * @return {undefined}
         */
        this.refreshAnnotations = function () {
            handleAnnotations(odfcontainer.rootElement);
        };

        /**
         * Re-renders all annotations if enabled
         * @return {undefined}
         */
        this.rerenderAnnotations = function () {
            if (annotationViewManager) {
                shouldRerenderAnnotations = true;
                redrawContainerTask.trigger();
            }
        };

        /**
         * This returns the element inside the canvas which can be zoomed with
         * CSS and which contains the ODF document and the annotation sidebar.
         * @return {!HTMLElement}
         */
        this.getSizer = function () {
            return /**@type{!HTMLElement}*/(sizer);
        };

        /** Allows / disallows annotations
         * @param {!boolean} allow
         * @param {!boolean} showRemoveButton
         * @return {undefined}
         */
        this.enableAnnotations = function (allow, showRemoveButton) {
            if (allow !== allowAnnotations) {
                allowAnnotations = allow;
                showAnnotationRemoveButton = showRemoveButton;
                if (odfcontainer) {
                    handleAnnotations(odfcontainer.rootElement);
                }
            }
        };

        /**
         * Adds an annotation for the annotaiton manager to track
         * and wraps and highlights it
         * @param {!odf.AnnotationElement} annotation
         * @return {undefined}
         */
        this.addAnnotation = function (annotation) {
            if (annotationViewManager) {
                annotationViewManager.addAnnotations([annotation]);
                fixContainerSize();
            }
        };

        /**
         * Stops an annotation and unwraps it
         * @param {!odf.AnnotationElement} annotation
         * @return {undefined}
         */
        this.forgetAnnotation = function (annotation) {
            if (annotationViewManager) {
                annotationViewManager.forgetAnnotation(annotation);
                fixContainerSize();
            }
        };

        /**
         * @return {!gui.ZoomHelper}
         */
        this.getZoomHelper = function () {
            return zoomHelper;
        };

        /**
         * @param {!number} zoom
         * @return {undefined}
         */
        this.setZoomLevel = function (zoom) {
            zoomHelper.setZoomLevel(zoom);
        };
        /**
         * @return {!number}
         */
        this.getZoomLevel = function () {
            return zoomHelper.getZoomLevel();
        };
        /**
         * @param {!number} width
         * @param {!number} height
         * @return {undefined}
         */
        this.fitToContainingElement = function (width, height) {
            var zoomLevel = zoomHelper.getZoomLevel(),
                realWidth = element.offsetWidth / zoomLevel,
                realHeight = element.offsetHeight / zoomLevel,
                zoom;

            zoom = width / realWidth;
            if (height / realHeight < zoom) {
                zoom = height / realHeight;
            }
            zoomHelper.setZoomLevel(zoom);
        };
        /**
         * @param {!number} width
         * @return {undefined}
         */
        this.fitToWidth = function (width) {
            var realWidth = element.offsetWidth / zoomHelper.getZoomLevel();
            zoomHelper.setZoomLevel(width / realWidth);
        };
        /**
         * @param {!number} width
         * @param {!number} height
         * @return {undefined}
         */
        this.fitSmart = function (width, height) {
            var realWidth, realHeight, newScale,
                zoomLevel = zoomHelper.getZoomLevel();

            realWidth = element.offsetWidth / zoomLevel;
            realHeight = element.offsetHeight / zoomLevel;

            newScale = width / realWidth;
            if (height !== undefined) {
                if (height / realHeight < newScale) {
                    newScale = height / realHeight;
                }
            }

            zoomHelper.setZoomLevel(Math.min(1.0, newScale));
        };
        /**
         * @param {!number} height
         * @return {undefined}
         */
        this.fitToHeight = function (height) {
            var realHeight = element.offsetHeight / zoomHelper.getZoomLevel();
            zoomHelper.setZoomLevel(height / realHeight);
        };
        /**
         * @return {undefined}
         */
        this.showFirstPage = function () {
            pageSwitcher.showFirstPage();
        };
        /**
         * @return {undefined}
         */
        this.showNextPage = function () {
            pageSwitcher.showNextPage();
        };
        /**
         * @return {undefined}
         */
        this.showPreviousPage = function () {
            pageSwitcher.showPreviousPage();
        };
        /**
         * @param {!number} n  number of the page
         * @return {undefined}
         */
        this.showPage = function (n) {
            pageSwitcher.showPage(n);
            fixContainerSize();
        };

        /**
         * @return {!HTMLElement}
         */
        this.getElement = function () {
            return element;
        };

        /**
         * @return {!gui.Viewport}
         */
        this.getViewport = function () {
            return canvasViewport;
        };

        /**
         * Add additional css rules for newly inserted draw:frame and draw:image. eg. position, dimensions and background image
         * @param {!Element} frame
         */
        this.addCssForFrameWithImage = function (frame) {
            // TODO: frameid and imageid generation here is better brought in sync with that for the images on loading of a odf file.
            var frameName = frame.getAttributeNS(drawns, 'name'),
                fc = frame.firstElementChild;
            setDrawElementPosition(frameName, frame,
                    /**@type{!CSSStyleSheet}*/(positioncss.sheet));
            if (fc) {
                setImage(frameName + 'img', odfcontainer, fc,
                   /**@type{!CSSStyleSheet}*/( positioncss.sheet));
            }
        };
        /**
         * @param {!function(!Error=)} callback, passing an error object in case of error
         * @return {undefined}
         */
        this.destroy = function(callback) {
            var head = /**@type{!HTMLHeadElement}*/(doc.getElementsByTagName('head')[0]),
                cleanup = [pageSwitcher.destroy, redrawContainerTask.destroy];

            runtime.clearTimeout(waitingForDoneTimeoutId);
            // TODO: anything to clean with annotationViewManager?
            if (annotationsPane && annotationsPane.parentNode) {
                annotationsPane.parentNode.removeChild(annotationsPane);
            }

            zoomHelper.destroy(function () {
                if (sizer) {
                    element.removeChild(sizer);
                    sizer = null;
                }
            });

            // remove all styles
            removeWebODFStyleSheet(webodfcss);
            head.removeChild(fontcss);
            head.removeChild(stylesxmlcss);
            head.removeChild(positioncss);

            // TODO: loadingQueue, make sure it is empty
            core.Async.destroyAll(cleanup, callback);
        };

        function init() {
            webodfcss = addWebODFStyleSheet(doc);
            pageSwitcher = new PageSwitcher(addStyleSheet(doc));
            fontcss = addStyleSheet(doc);
            stylesxmlcss = addStyleSheet(doc);
            positioncss = addStyleSheet(doc);
            redrawContainerTask = core.Task.createRedrawTask(redrawContainer);
            zoomHelper.subscribe(gui.ZoomHelper.signalZoomChanged, fixContainerSize);
        }

        init();
    };
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\OdfContainer.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, NodeFilter, runtime, core, xmldom, odf, DOMParser, document, webodf */

(function () {
    "use strict";
    var styleInfo = new odf.StyleInfo(),
        domUtils = core.DomUtils,
        /**@const
           @type{!string}*/
        officens = "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
        /**@const
           @type{!string}*/
        manifestns = "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0",
        /**@const
           @type{!string}*/
        webodfns = "urn:webodf:names:scope",
        /**@const
           @type{!string}*/
        stylens = odf.Namespaces.stylens,
        /**@const
           @type{!Array.<!string>}*/
        nodeorder = ['meta', 'settings', 'scripts', 'font-face-decls', 'styles',
            'automatic-styles', 'master-styles', 'body'],
        /**@const
           @type{!string}*/
        automaticStylePrefix = Date.now() + "_webodf_",
        base64 = new core.Base64(),
        /**@const
           @type{!string}*/
        documentStylesScope = "document-styles",
        /**@const
           @type{!string}*/
        documentContentScope = "document-content";

    /**
     * Return the position the node should get according to the ODF flat format.
     * @param {!Node} child
     * @return {!number}
     */
    function getNodePosition(child) {
        var i, l = nodeorder.length;
        for (i = 0; i < l; i += 1) {
            if (child.namespaceURI === officens &&
                    child.localName === nodeorder[i]) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Class that filters runtime specific nodes from the DOM.
     * Additionally all unused automatic styles are skipped, if a tree
     * of elements was passed to check the style usage in it.
     * @constructor
     * @implements {xmldom.LSSerializerFilter}
     * @param {!Element} styleUsingElementsRoot root element of tree of elements using styles
     * @param {?Element=} automaticStyles root element of the automatic style definition tree
     */
    function OdfStylesFilter(styleUsingElementsRoot, automaticStyles) {
        var usedStyleList = new styleInfo.UsedStyleList(styleUsingElementsRoot, automaticStyles),
            odfNodeFilter = new odf.OdfNodeFilter();

        /**
         * @param {!Node} node
         * @return {!number}
         */
        this.acceptNode = function (node) {
            var result = odfNodeFilter.acceptNode(node);
            if (result === NodeFilter.FILTER_ACCEPT
                    && node.parentNode === automaticStyles
                    && node.nodeType === Node.ELEMENT_NODE) {
                // skip all automatic styles which are not used
                if (usedStyleList.uses(/**@type{!Element}*/(node))) {
                    result = NodeFilter.FILTER_ACCEPT;
                } else {
                    result = NodeFilter.FILTER_REJECT;
                }
            }
            return result;
        };
    }
    /**
     * Class that extends OdfStylesFilter
     * Additionally, filter out ' ' within the <text:s> element and '\t' within the <text:tab> element
     * @constructor
     * @implements {xmldom.LSSerializerFilter}
     * @param {!Element} styleUsingElementsRoot root element of tree of elements using styles
     * @param {?Element=} automaticStyles root element of the automatic style definition tree
     */
    function OdfContentFilter(styleUsingElementsRoot, automaticStyles) {
        var odfStylesFilter = new OdfStylesFilter(styleUsingElementsRoot, automaticStyles);

        /**
         * @param {!Node} node
         * @return {!number}
         */
        this.acceptNode = function (node) {
            var result = odfStylesFilter.acceptNode(node);
            if (result === NodeFilter.FILTER_ACCEPT
                    && node.parentNode
                    && node.parentNode.namespaceURI === odf.Namespaces.textns
                    && (node.parentNode.localName === 's' || node.parentNode.localName === 'tab')) {
                result = NodeFilter.FILTER_REJECT;
            }
            return result;
        };
    }
    /**
     * Put the element at the right position in the parent.
     * The right order is given by the value returned from getNodePosition.
     * @param {!Node} node
     * @param {?Node} child
     * @return {undefined}
     */
    function setChild(node, child) {
        if (!child) {
            return;
        }
        var childpos = getNodePosition(child),
            pos,
            c = node.firstChild;
        if (childpos === -1) {
            return;
        }
        while (c) {
            pos = getNodePosition(c);
            if (pos !== -1 && pos > childpos) {
                break;
            }
            c = c.nextSibling;
        }
        node.insertBefore(child, c);
    }
    /*jslint emptyblock: true*/
    /**
     * A DOM element that is part of and ODF part of a DOM.
     * @constructor
     * @extends {Element}
     */
    odf.ODFElement = function ODFElement() {
    };
    /**
     * The root element of an ODF document.
     * @constructor
     * @extends {odf.ODFElement}
     */
    odf.ODFDocumentElement = function ODFDocumentElement() {
    };
    /*jslint emptyblock: false*/
    odf.ODFDocumentElement.prototype = new odf.ODFElement();
    odf.ODFDocumentElement.prototype.constructor = odf.ODFDocumentElement;
    /**
     * Optional tag <office:automatic-styles/>
     * If it is missing, it is created.
     * @type {!Element}
     */
    odf.ODFDocumentElement.prototype.automaticStyles;
    /**
     * Required tag <office:body/>
     * @type {!Element}
     */
    odf.ODFDocumentElement.prototype.body;
    /**
     * Optional tag <office:font-face-decls/>
     * @type {Element}
     */
    odf.ODFDocumentElement.prototype.fontFaceDecls = null;
    /**
     * @type {Element}
     */
    odf.ODFDocumentElement.prototype.manifest = null;
    /**
     * Optional tag <office:master-styles/>
     * If it is missing, it is created.
     * @type {!Element}
     */
    odf.ODFDocumentElement.prototype.masterStyles;
    /**
     * Optional tag <office:meta/>
     * @type {?Element}
     */
    odf.ODFDocumentElement.prototype.meta;
    /**
     * Optional tag <office:settings/>
     * @type {Element}
     */
    odf.ODFDocumentElement.prototype.settings = null;
    /**
     * Optional tag <office:styles/>
     * If it is missing, it is created.
     * @type {!Element}
     */
    odf.ODFDocumentElement.prototype.styles;
    odf.ODFDocumentElement.namespaceURI = officens;
    odf.ODFDocumentElement.localName = 'document';

    /*jslint emptyblock: true*/
    /**
     * An element that also has a pointer to the optional annotation end
     * @constructor
     * @extends {odf.ODFElement}
     */
    odf.AnnotationElement = function AnnotationElement() {
    };
    /*jslint emptyblock: false*/

    /**
    * @type {?Element}
    */
    odf.AnnotationElement.prototype.annotationEndElement;

    // private constructor
    /**
     * @constructor
     * @param {string} name
     * @param {string} mimetype
     * @param {!odf.OdfContainer} container
     * @param {core.Zip} zip
     */
    odf.OdfPart = function OdfPart(name, mimetype,  container, zip) {
        var self = this;

        // declare public variables
        this.size = 0;
        this.type = null;
        this.name = name;
        this.container = container;
        /**@type{?string}*/
        this.url = null;
        /**@type{string}*/
        this.mimetype = mimetype;
        this.document = null;
        this.onstatereadychange = null;
        /**@type{?function(!odf.OdfPart)}*/
        this.onchange;
        this.EMPTY = 0;
        this.LOADING = 1;
        this.DONE = 2;
        this.state = this.EMPTY;
        this.data = "";

        // private functions
        // public functions
        /**
         * @return {undefined}
         */
        this.load = function () {
            if (zip === null) {
                return;
            }
            this.mimetype = mimetype;
            zip.loadAsDataURL(name, mimetype, function (err, url) {
                if (err) {
                    runtime.log(err);
                }
                self.url = url;
                if (self.onchange) {
                    self.onchange(self);
                }
                if (self.onstatereadychange) {
                    self.onstatereadychange(self);
                }
            });
        };
    };
    /*jslint emptyblock: true*/
    odf.OdfPart.prototype.load = function () {
    };
    /*jslint emptyblock: false*/
    odf.OdfPart.prototype.getUrl = function () {
        if (this.data) {
            return 'data:;base64,' + base64.toBase64(this.data);
        }
        return null;
    };
    /**
     * The OdfContainer class manages the various parts that constitues an ODF
     * document.
     * The constructor takes a url or a type. If urlOrType is a type, an empty
     * document of that type is created. Otherwise, urlOrType is interpreted as
     * a url and loaded from that url.
     *
     * @constructor
     * @param {!string|!odf.OdfContainer.DocumentType} urlOrType
     * @param {?function(!odf.OdfContainer)=} onstatereadychange
     * @return {?}
     */
    odf.OdfContainer = function OdfContainer(urlOrType, onstatereadychange) {
        var self = this,
            /**@type {!core.Zip}*/
            zip,
            /**@type {!Object.<!string,!string>}*/
            partMimetypes = {},
            /**@type {?Element}*/
            contentElement,
            /**@type{!string}*/
            url = "";

        // NOTE each instance of OdfContainer has a copy of the private functions
        // it would be better to have a class OdfContainerPrivate where the
        // private functions can be defined via OdfContainerPrivate.prototype
        // without exposing them

        // declare public variables
        this.onstatereadychange = onstatereadychange;
        this.onchange = null;
        this.state = null;
        /**
         * @type {!odf.ODFDocumentElement}
         */
        this.rootElement;

        /**
         * @param {!Element} element
         * @return {undefined}
         */
        function removeProcessingInstructions(element) {
            var n = element.firstChild, next, e;
            while (n) {
                next = n.nextSibling;
                if (n.nodeType === Node.ELEMENT_NODE) {
                    e = /**@type{!Element}*/(n);
                    removeProcessingInstructions(e);
                } else if (n.nodeType === Node.PROCESSING_INSTRUCTION_NODE) {
                    element.removeChild(n);
                }
                n = next;
            }
        }

        // private functions
        /**
         * Iterates through the subtree of rootElement and adds annotation-end
         * elements as direct properties of the corresponding annotation elements.
         * Expects properly used annotation elements, does not try
         * to do heuristic fixes or drop broken elements.
         * @param {!Element} rootElement
         * @return {undefined}
         */
        function linkAnnotationStartAndEndElements(rootElement) {
            var document = rootElement.ownerDocument,
                /** @type {!Object.<!string,!Element>} */
                annotationStarts = {},
                n, name, annotationStart,
                // TODO: optimize by using a filter rejecting subtrees without annotations possible
                nodeIterator = document.createNodeIterator(rootElement, NodeFilter.SHOW_ELEMENT, null, false);

            n = /**@type{?Element}*/(nodeIterator.nextNode());
            while (n) {
                if (n.namespaceURI === officens) {
                    if (n.localName === "annotation") {
                        name = n.getAttributeNS(officens, 'name');
                        if (name) {
                            if (annotationStarts.hasOwnProperty(name)) {
                                runtime.log("Warning: annotation name used more than once with <office:annotation/>: '" + name + "'");
                            } else {
                                annotationStarts[name] = n;
                            }
                        }
                    } else if (n.localName === "annotation-end") {
                        name = n.getAttributeNS(officens, 'name');
                        if (name) {
                            if (annotationStarts.hasOwnProperty(name)) {
                                annotationStart = /** @type {!odf.AnnotationElement}*/(annotationStarts[name]);
                                if (!annotationStart.annotationEndElement) {
                                    // Linking annotation start & end
                                    annotationStart.annotationEndElement = n;
                                } else {
                                    runtime.log("Warning: annotation name used more than once with <office:annotation-end/>: '" + name + "'");
                                }
                            } else {
                                runtime.log("Warning: annotation end without an annotation start, name: '" + name + "'");
                            }
                        } else {
                            runtime.log("Warning: annotation end without a name found");
                        }
                    }
                }
                n = /**@type{?Element}*/(nodeIterator.nextNode());
            }
        }

        /**
         * Tags all styles with an attribute noting their scope.
         * Helper function for the primitive complete backwriting of
         * the automatic styles.
         * @param {?Element} stylesRootElement
         * @param {!string} scope
         * @return {undefined}
         */
        function setAutomaticStylesScope(stylesRootElement, scope) {
            var n = stylesRootElement && stylesRootElement.firstChild;
            while (n) {
                if (n.nodeType === Node.ELEMENT_NODE) {
                    /**@type{!Element}*/(n).setAttributeNS(webodfns, "scope", scope);
                }
                n = n.nextSibling;
            }
        }

        /**
         * Returns the meta element. If it did not exist before, it will be created.
         * @return {!Element}
         */
        function getEnsuredMetaElement() {
            var root = self.rootElement,
                meta = root.meta;

            if (!meta) {
                root.meta = meta = document.createElementNS(officens, "meta");
                setChild(root, meta);
            }

            return meta;
        }

        /**
         * @param {!string} metadataNs
         * @param {!string} metadataLocalName
         * @return {?string}
         */
        function getMetadata(metadataNs, metadataLocalName) {
            var node = self.rootElement.meta, textNode;

            node = node && node.firstChild;
            while (node && (node.namespaceURI !== metadataNs || node.localName !== metadataLocalName)) {
                node = node.nextSibling;
            }
            node = node && node.firstChild;
            while (node && node.nodeType !== Node.TEXT_NODE) {
                node = node.nextSibling;
            }
            if (node) {
                textNode = /**@type{!Text}*/(node);
                return textNode.data;
            }
            return null;
        }
        this.getMetadata = getMetadata;

        /**
         * Returns key with a number postfix or none, as key unused both in map1 and map2.
         * @param {!string} key
         * @param {!Object} map1
         * @param {!Object} map2
         * @return {!string}
         */
        function unusedKey(key, map1, map2) {
            var i = 0, postFixedKey;

            // cut any current postfix number
            key = key.replace(/\d+$/, '');
            // start with no postfix, continue with i = 1, aiming for the simpelst unused number or key
            postFixedKey = key;
            while (map1.hasOwnProperty(postFixedKey) || map2.hasOwnProperty(postFixedKey)) {
                i += 1;
                postFixedKey = key + i;
            }

            return postFixedKey;
        }

        /**
         * Returns a map with the fontface declaration elements, with font-face name as key.
         * @param {!Element} fontFaceDecls
         * @return {!Object.<!string,!Element>}
          */
        function mapByFontFaceName(fontFaceDecls) {
            var fn, result = {}, fontname;
            // create map of current target decls
            fn = fontFaceDecls.firstChild;
            while (fn) {
                if (fn.nodeType === Node.ELEMENT_NODE
                        && fn.namespaceURI === stylens
                        && fn.localName === "font-face") {
                    fontname = /**@type{!Element}*/(fn).getAttributeNS(stylens, "name");
                    // assuming existance and uniqueness of style:name here
                    result[fontname] = fn;
                }
                fn = fn.nextSibling;
            }
            return result;
        }

        /**
         * Merges all style:font-face elements from the source into the target.
         * Skips elements equal to one already in the target.
         * Elements with the same style:name but different properties get a new
         * value for style:name. Any name changes are logged and returned as a map
         * with the old names as keys.
         * @param {!Element} targetFontFaceDeclsRootElement
         * @param {!Element} sourceFontFaceDeclsRootElement
         * @return {!Object.<!string,!string>}  mapping of old font-face name to new
         */
        function mergeFontFaceDecls(targetFontFaceDeclsRootElement, sourceFontFaceDeclsRootElement) {
            var e, s, fontFaceName, newFontFaceName,
                targetFontFaceDeclsMap, sourceFontFaceDeclsMap,
                fontFaceNameChangeMap = {};

            targetFontFaceDeclsMap = mapByFontFaceName(targetFontFaceDeclsRootElement);
            sourceFontFaceDeclsMap = mapByFontFaceName(sourceFontFaceDeclsRootElement);

            // merge source decls into target
            e = sourceFontFaceDeclsRootElement.firstElementChild;
            while (e) {
                s = e.nextElementSibling;
                if (e.namespaceURI === stylens && e.localName === "font-face") {
                    fontFaceName = e.getAttributeNS(stylens, "name");
                    // already such a name used in target?
                    if (targetFontFaceDeclsMap.hasOwnProperty(fontFaceName)) {
                        // skip it if the declarations are equal, otherwise insert with a new, unused name
                        if (!e.isEqualNode(targetFontFaceDeclsMap[fontFaceName])) {
                            newFontFaceName = unusedKey(fontFaceName, targetFontFaceDeclsMap, sourceFontFaceDeclsMap);
                            e.setAttributeNS(stylens, "style:name", newFontFaceName);
                            // copy with a new name
                            targetFontFaceDeclsRootElement.appendChild(e);
                            targetFontFaceDeclsMap[newFontFaceName] = e;
                            delete sourceFontFaceDeclsMap[fontFaceName];
                            // note name change
                            fontFaceNameChangeMap[fontFaceName] = newFontFaceName;
                        }
                    } else {
                        // move over
                        // perhaps one day it could also be checked if there is an equal declaration
                        // with a different name, but that has yet to be seen in real life
                        targetFontFaceDeclsRootElement.appendChild(e);
                        targetFontFaceDeclsMap[fontFaceName] = e;
                        delete sourceFontFaceDeclsMap[fontFaceName];
                    }
                }
                e = s;
            }
            return fontFaceNameChangeMap;
        }

        /**
         * Creates a clone of the styles tree containing only styles tagged
         * with the given scope, or with no specified scope.
         * Helper function for the primitive complete backwriting of
         * the automatic styles.
         * @param {?Element} stylesRootElement
         * @param {!string} scope
         * @return {?Element}
         */
        function cloneStylesInScope(stylesRootElement, scope) {
            var copy = null, e, s, scopeAttrValue;
            if (stylesRootElement) {
                copy = stylesRootElement.cloneNode(true);
                e = copy.firstElementChild;
                while (e) {
                    s = e.nextElementSibling;
                    scopeAttrValue = e.getAttributeNS(webodfns, "scope");
                    if (scopeAttrValue && scopeAttrValue !== scope) {
                        copy.removeChild(e);
                    }
                    e = s;
                }
            }
            return copy;
        }
        /**
         * Creates a clone of the font face declaration tree containing only
         * those declarations which are referenced in the passed styles.
         * @param {?Element} fontFaceDeclsRootElement
         * @param {!Array.<!Element>} stylesRootElementList
         * @return {?Element}
         */
        function cloneFontFaceDeclsUsedInStyles(fontFaceDeclsRootElement, stylesRootElementList) {
            var e, nextSibling, fontFaceName,
                copy = null,
                usedFontFaceDeclMap = {};

            if (fontFaceDeclsRootElement) {
                // first collect used font faces
                stylesRootElementList.forEach(function (stylesRootElement) {
                    styleInfo.collectUsedFontFaces(usedFontFaceDeclMap, stylesRootElement);
                });

                // then clone all font face declarations and drop those which are not in the list of used
                copy = fontFaceDeclsRootElement.cloneNode(true);
                e = copy.firstElementChild;
                while (e) {
                    nextSibling = e.nextElementSibling;
                    fontFaceName = e.getAttributeNS(stylens, "name");
                    if (!usedFontFaceDeclMap[fontFaceName]) {
                        copy.removeChild(e);
                    }
                    e = nextSibling;
                }
            }
            return copy;
        }

        /**
         * Import the document elementnode into the DOM of OdfContainer.
         * Any processing instructions are removed, since importing them
         * gives an exception.
         * @param {Document|undefined} xmldoc
         * @return {!Element|undefined}
         */
        function importRootNode(xmldoc) {
            var doc = self.rootElement.ownerDocument,
                node;
            // remove all processing instructions
            // TODO: replace cursor processing instruction with an element
            if (xmldoc) {
                removeProcessingInstructions(xmldoc.documentElement);
                try {
                    node = /**@type{!Element}*/(doc.importNode(xmldoc.documentElement, true));
                } catch (ignore) {
                }
            }
            return node;
        }
        /**
         * @param {!number} state
         * @return {undefined}
         */
        function setState(state) {
            self.state = state;
            if (self.onchange) {
                self.onchange(self);
            }
            if (self.onstatereadychange) {
                self.onstatereadychange(self);
            }
        }
        /**
         * @param {!Element} root
         * @return {undefined}
         */
        function setRootElement(root) {
            contentElement = null;
            self.rootElement = /**@type{!odf.ODFDocumentElement}*/(root);
            root.fontFaceDecls = domUtils.getDirectChild(root, officens, 'font-face-decls');
            root.styles = domUtils.getDirectChild(root, officens, 'styles');
            root.automaticStyles = domUtils.getDirectChild(root, officens, 'automatic-styles');
            root.masterStyles = domUtils.getDirectChild(root, officens, 'master-styles');
            root.body = domUtils.getDirectChild(root, officens, 'body');
            root.meta = domUtils.getDirectChild(root, officens, 'meta');
            root.settings = domUtils.getDirectChild(root, officens, 'settings');
            root.scripts = domUtils.getDirectChild(root, officens, 'scripts');
            linkAnnotationStartAndEndElements(root);
        }
        /**
         * @param {Document|undefined} xmldoc
         * @return {undefined}
         */
        function handleFlatXml(xmldoc) {
            var root = importRootNode(xmldoc);
            if (!root || root.localName !== 'document' ||
                    root.namespaceURI !== officens) {
                setState(OdfContainer.INVALID);
                return;
            }
            setRootElement(/**@type{!Element}*/(root));
            setState(OdfContainer.DONE);
        }
        /**
         * @param {Document} xmldoc
         * @return {undefined}
         */
        function handleStylesXml(xmldoc) {
            var node = importRootNode(xmldoc),
                root = self.rootElement,
                n;
            if (!node || node.localName !== 'document-styles' ||
                    node.namespaceURI !== officens) {
                setState(OdfContainer.INVALID);
                return;
            }
            root.fontFaceDecls = domUtils.getDirectChild(node, officens, 'font-face-decls');
            setChild(root, root.fontFaceDecls);
            n = domUtils.getDirectChild(node, officens, 'styles');
            root.styles = n || xmldoc.createElementNS(officens, 'styles');
            setChild(root, root.styles);
            n = domUtils.getDirectChild(node, officens, 'automatic-styles');
            root.automaticStyles = n || xmldoc.createElementNS(officens, 'automatic-styles');
            setAutomaticStylesScope(root.automaticStyles, documentStylesScope);
            setChild(root, root.automaticStyles);
            node = domUtils.getDirectChild(node, officens, 'master-styles');
            root.masterStyles = node || xmldoc.createElementNS(officens,
                    'master-styles');
            setChild(root, root.masterStyles);
            // automatic styles from styles.xml could shadow automatic styles
            // from content.xml, because they could have the same name
            // so prefix them and their uses with some almost unique string
            styleInfo.prefixStyleNames(root.automaticStyles, automaticStylePrefix, root.masterStyles);
        }
        /**
         * @param {Document} xmldoc
         * @return {undefined}
         */
        function handleContentXml(xmldoc) {
            var node = importRootNode(xmldoc),
                root,
                automaticStyles,
                fontFaceDecls,
                fontFaceNameChangeMap,
                c;
            if (!node || node.localName !== 'document-content' ||
                    node.namespaceURI !== officens) {
                setState(OdfContainer.INVALID);
                return;
            }
            root = self.rootElement;
            fontFaceDecls = domUtils.getDirectChild(node, officens, 'font-face-decls');
            if (root.fontFaceDecls && fontFaceDecls) {
                fontFaceNameChangeMap = mergeFontFaceDecls(root.fontFaceDecls, fontFaceDecls);
            } else if (fontFaceDecls) {
                root.fontFaceDecls = fontFaceDecls;
                setChild(root, fontFaceDecls);
            }
            automaticStyles = domUtils.getDirectChild(node, officens, 'automatic-styles');
            setAutomaticStylesScope(automaticStyles, documentContentScope);
            if (fontFaceNameChangeMap) {
                styleInfo.changeFontFaceNames(automaticStyles, fontFaceNameChangeMap);
            }
            if (root.automaticStyles && automaticStyles) {
                c = automaticStyles.firstChild;
                while (c) {
                    root.automaticStyles.appendChild(c);
                    c = automaticStyles.firstChild; // works because node c moved
                }
            } else if (automaticStyles) {
                root.automaticStyles = automaticStyles;
                setChild(root, automaticStyles);
            }
            node = domUtils.getDirectChild(node, officens, 'body');
            if (node === null) {
                throw "<office:body/> tag is mising.";
            }
            root.body = node;
            setChild(root, root.body);
        }
        /**
         * @param {Document} xmldoc
         * @return {undefined}
         */
        function handleMetaXml(xmldoc) {
            var node = importRootNode(xmldoc),
                root;
            if (!node || node.localName !== 'document-meta' ||
                    node.namespaceURI !== officens) {
                return;
            }
            root = self.rootElement;
            root.meta = domUtils.getDirectChild(node, officens, 'meta');
            setChild(root, root.meta);
        }
        /**
         * @param {Document} xmldoc
         * @return {undefined}
         */
        function handleSettingsXml(xmldoc) {
            var node = importRootNode(xmldoc),
                root;
            if (!node || node.localName !== 'document-settings' ||
                    node.namespaceURI !== officens) {
                return;
            }
            root = self.rootElement;
            root.settings = domUtils.getDirectChild(node, officens, 'settings');
            setChild(root, root.settings);
        }
        /**
         * @param {Document} xmldoc
         * @return {undefined}
         */
        function handleManifestXml(xmldoc) {
            var node = importRootNode(xmldoc),
                root,
                e;
            if (!node || node.localName !== 'manifest' ||
                    node.namespaceURI !== manifestns) {
                return;
            }
            root = self.rootElement;
            root.manifest = /**@type{!Element}*/(node);
            e = root.manifest.firstElementChild;
            while (e) {
                if (e.localName === "file-entry" &&
                        e.namespaceURI === manifestns) {
                    partMimetypes[e.getAttributeNS(manifestns, "full-path")] =
                        e.getAttributeNS(manifestns, "media-type");
                }
                e = e.nextElementSibling;
            }
        }
        /**
         * @param {!Document} xmldoc
         * @param {!string} localName
         * @param {!Object.<!string,!boolean>} allowedNamespaces
         * @return {undefined}
         */
        function removeElements(xmldoc, localName, allowedNamespaces) {
            var elements = domUtils.getElementsByTagName(xmldoc, localName),
                element,
                i;
            for (i = 0; i < elements.length; i += 1) {
                element = elements[i];
                if (!allowedNamespaces.hasOwnProperty(element.namespaceURI)) {
                    element.parentNode.removeChild(element);
                }
            }
        }
        /**
         * Remove any HTML <script/> tags from the DOM.
         * The tags need to be removed, because otherwise they would be executed
         * when the dom is inserted into the document.
         * To be safe, all elements with localName "script" are removed, unless
         * they are in a known, allowed namespace.
         * @param {!Document} xmldoc
         * @return {undefined}
         */
        function removeDangerousElements(xmldoc) {
            removeElements(xmldoc, "script", {
                "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:office:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:table:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:text:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0": true
            });
            removeElements(xmldoc, "style", {
                "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0": true,
                "urn:oasis:names:tc:opendocument:xmlns:style:1.0": true
            });
        }

        /**
         * Remove all attributes that have no namespace and that have
         * localname like 'on....', the event handler attributes.
         * @param {!Element} element
         * @return {undefined}
         */
        function removeDangerousAttributes(element) {
            var e = element.firstElementChild, as = [], i, n, a,
                atts = element.attributes,
                l = atts.length;
            // collect all dangerous attributes
            for (i = 0; i < l; i += 1) {
                a = atts.item(i);
                n = a.localName.substr(0, 2).toLowerCase();
                if (a.namespaceURI === null && n === "on") {
                    as.push(a);
                }
            }
            // remove the dangerous attributes
            l = as.length;
            for (i = 0; i < l; i += 1) {
                element.removeAttributeNode(as[i]);
            }
            // recurse into the child elements
            while (e) {
                removeDangerousAttributes(e);
                e = e.nextElementSibling;
            }
        }

        /**
         * @param {!Array.<!{path:string,handler:function(?Document)}>} remainingComponents
         * @return {undefined}
         */
        function loadNextComponent(remainingComponents) {
            var component = remainingComponents.shift();

            if (component) {
                zip.loadAsDOM(component.path, function (err, xmldoc) {
                    if (xmldoc) {
                        removeDangerousElements(xmldoc);
                        removeDangerousAttributes(xmldoc.documentElement);
                    }
                    component.handler(xmldoc);
                    if (self.state === OdfContainer.INVALID) {
                        if (err) {
                            runtime.log("ERROR: Unable to load " + component.path + " - " + err);
                        } else {
                            runtime.log("ERROR: Unable to load " + component.path);
                        }
                        return;
                    }
                    if (err) {
                        runtime.log("DEBUG: Unable to load " + component.path + " - " + err);
                    }
                    loadNextComponent(remainingComponents);
                });
            } else {
                linkAnnotationStartAndEndElements(self.rootElement);
                setState(OdfContainer.DONE);
            }
        }
        /**
         * @return {undefined}
         */
        function loadComponents() {
            var componentOrder = [
                {path: 'styles.xml', handler: handleStylesXml},
                {path: 'content.xml', handler: handleContentXml},
                {path: 'meta.xml', handler: handleMetaXml},
                {path: 'settings.xml', handler: handleSettingsXml},
                {path: 'META-INF/manifest.xml', handler: handleManifestXml}
            ];
            loadNextComponent(componentOrder);
        }
        /**
         * @param {!string} name
         * @return {!string}
         */
        function createDocumentElement(name) {
            var /**@type{string}*/
                s = "";

            /**
             * @param {string} prefix
             * @param {string} ns
             */
            function defineNamespace(prefix, ns) {
                s += " xmlns:" + prefix + "=\"" + ns + "\"";
            }
            odf.Namespaces.forEachPrefix(defineNamespace);
            return "<?xml version=\"1.0\" encoding=\"UTF-8\"?><office:" + name +
                    " " + s + " office:version=\"1.2\">";
        }
        /**
         * @return {!string}
         */
        function serializeMetaXml() {
            var serializer = new xmldom.LSSerializer(),
                /**@type{!string}*/
                s = createDocumentElement("document-meta");
            serializer.filter = new odf.OdfNodeFilter();
            s += serializer.writeToString(self.rootElement.meta, odf.Namespaces.namespaceMap);
            s += "</office:document-meta>";
            return s;
        }
        /**
         * Creates a manifest:file-entry node
         * @param {!string} fullPath Full-path attribute value for the file-entry
         * @param {!string} mediaType Media-type attribute value for the file-entry
         * @return {!Node}
         */
        function createManifestEntry(fullPath, mediaType) {
            var element = document.createElementNS(manifestns, 'manifest:file-entry');
            element.setAttributeNS(manifestns, 'manifest:full-path', fullPath);
            element.setAttributeNS(manifestns, 'manifest:media-type', mediaType);
            return element;
        }
        /**
         * @return {string}
         */
        function serializeManifestXml() {
            var header = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n',
                xml = '<manifest:manifest xmlns:manifest="' + manifestns + '" manifest:version="1.2"></manifest:manifest>',
                manifest = /**@type{!Document}*/(runtime.parseXML(xml)),
                manifestRoot = manifest.documentElement,
                serializer = new xmldom.LSSerializer(),
                /**@type{string}*/
                fullPath;

            for (fullPath in partMimetypes) {
                if (partMimetypes.hasOwnProperty(fullPath)) {
                    manifestRoot.appendChild(createManifestEntry(fullPath, partMimetypes[fullPath]));
                }
            }
            serializer.filter = new odf.OdfNodeFilter();
            return header + serializer.writeToString(manifest, odf.Namespaces.namespaceMap);
        }
        /**
         * @return {!string}
         */
        function serializeSettingsXml() {
            var serializer = new xmldom.LSSerializer(),
                /**@type{!string}*/
                s = createDocumentElement("document-settings");
            // <office:settings/> is optional, but if present must have at least one child element
            if (self.rootElement.settings && self.rootElement.settings.firstElementChild) {
                serializer.filter = new odf.OdfNodeFilter();
                s += serializer.writeToString(self.rootElement.settings, odf.Namespaces.namespaceMap);
            }
            return s + "</office:document-settings>";
        }
        /**
         * @return {!string}
         */
        function serializeStylesXml() {
            var fontFaceDecls, automaticStyles, masterStyles,
                nsmap = odf.Namespaces.namespaceMap,
                serializer = new xmldom.LSSerializer(),
                /**@type{!string}*/
                s = createDocumentElement("document-styles");

            // special handling for merged toplevel nodes
            automaticStyles = cloneStylesInScope(
                self.rootElement.automaticStyles,
                documentStylesScope
            );
            masterStyles = /**@type{!Element}*/(self.rootElement.masterStyles.cloneNode(true));
            fontFaceDecls = cloneFontFaceDeclsUsedInStyles(self.rootElement.fontFaceDecls, [masterStyles, self.rootElement.styles, automaticStyles]);

            // automatic styles from styles.xml could shadow automatic styles from content.xml,
            // because they could have the same name
            // thus they were prefixed on loading with some almost unique string, which cam be removed
            // again before saving
            styleInfo.removePrefixFromStyleNames(automaticStyles,
                    automaticStylePrefix, masterStyles);
            serializer.filter = new OdfStylesFilter(masterStyles, automaticStyles);

            s += serializer.writeToString(fontFaceDecls, nsmap);
            s += serializer.writeToString(self.rootElement.styles, nsmap);
            s += serializer.writeToString(automaticStyles, nsmap);
            s += serializer.writeToString(masterStyles, nsmap);
            s += "</office:document-styles>";
            return s;
        }
        /**
         * @return {!string}
         */
        function serializeContentXml() {
            var fontFaceDecls, automaticStyles,
                nsmap = odf.Namespaces.namespaceMap,
                serializer = new xmldom.LSSerializer(),
                /**@type{!string}*/
                s = createDocumentElement("document-content");

            // special handling for merged toplevel nodes
            automaticStyles = cloneStylesInScope(self.rootElement.automaticStyles, documentContentScope);
            fontFaceDecls = cloneFontFaceDeclsUsedInStyles(self.rootElement.fontFaceDecls, [automaticStyles]);

            serializer.filter = new OdfContentFilter(self.rootElement.body, automaticStyles);

            s += serializer.writeToString(fontFaceDecls, nsmap);
            s += serializer.writeToString(automaticStyles, nsmap);
            s += serializer.writeToString(self.rootElement.body, nsmap);
            s += "</office:document-content>";
            return s;
        }
        /**
         * @param {!{Type:function(new:Object),namespaceURI:string,localName:string}} type
         * @return {!Element}
         */
        function createElement(type) {
            var original = document.createElementNS(
                    type.namespaceURI,
                    type.localName
                ),
                /**@type{string}*/
                method,
                iface = new type.Type();
            for (method in iface) {
                if (iface.hasOwnProperty(method)) {
                    original[method] = iface[method];
                }
            }
            return original;
        }
        /**
         * @param {!string} url
         * @param {!function((string)):undefined} callback
         * @return {undefined}
         */
        function loadFromXML(url, callback) {
            /**
             * @param {?string} err
             * @param {?Document} dom
             */
            function handler(err, dom) {
                if (err) {
                    callback(err);
                } else if (!dom) {
                    callback("No DOM was loaded.");
                } else {
                    removeDangerousElements(dom);
                    removeDangerousAttributes(dom.documentElement);
                    handleFlatXml(dom);
                }
            }
            runtime.loadXML(url, handler);
        }
        // public functions
        this.setRootElement = setRootElement;

        /**
         * @return {!Element}
         */
        this.getContentElement = function () {
            var /**@type{!Element}*/
                body;
            if (!contentElement) {
                body = self.rootElement.body;
                contentElement = domUtils.getDirectChild(body, officens, "text")
                    || domUtils.getDirectChild(body, officens, "presentation")
                    || domUtils.getDirectChild(body, officens, "spreadsheet");
            }
            if (!contentElement) {
                throw "Could not find content element in <office:body/>.";
            }
            return contentElement;
        };

        /**
         * Gets the document type as 'text', 'presentation', or 'spreadsheet'.
         * @return {!string}
         */
        this.getDocumentType = function () {
            var content = self.getContentElement();
            return content && content.localName;
        };

        /**
         * Returns whether the document is a template.
         * @return {!boolean}
         */
        this.isTemplate = function () {
            var docMimetype = partMimetypes["/"];
            return (docMimetype.substr(-9) === "-template");
        };

         /**
         * Sets whether the document is a template or not.
         * @param {!boolean} isTemplate
         * @return {undefined}
         */
       this.setIsTemplate = function (isTemplate) {
            var docMimetype = partMimetypes["/"],
                oldIsTemplate = (docMimetype.substr(-9) === "-template"),
                data;

            if (isTemplate === oldIsTemplate) {
                return;
            }

            if (isTemplate) {
                docMimetype = docMimetype + "-template";
            } else {
                docMimetype = docMimetype.substr(0, docMimetype.length-9);
            }

            partMimetypes["/"] = docMimetype;
            data = runtime.byteArrayFromString(docMimetype, "utf8");
            zip.save("mimetype", data, false, new Date());
        };

        /**
         * Open file and parse it. Return the XML Node. Return the root node of
         * the file or null if this is not possible.
         * For 'content.xml', 'styles.xml', 'meta.xml', and 'settings.xml', the
         * elements 'document-content', 'document-styles', 'document-meta', or
         * 'document-settings' will be returned respectively.
         * @param {string} partname
         * @return {!odf.OdfPart}
         **/
        this.getPart = function (partname) {
            return new odf.OdfPart(partname, partMimetypes[partname], self, zip);
        };
        /**
         * @param {string} url
         * @param {function(?string, ?Uint8Array)} callback receiving err and data
         * @return {undefined}
         */
        this.getPartData = function (url, callback) {
            zip.load(url, callback);
        };

        /**
         * Sets the metadata fields from the given properties map.
         * @param {?Object.<!string, !string>} setProperties A flat object that is a string->string map of field name -> value.
         * @param {?Array.<!string>} removedPropertyNames An array of metadata field names (prefixed).
         * @return {undefined}
         */
        function setMetadata(setProperties, removedPropertyNames) {
            var metaElement = getEnsuredMetaElement();

            if (setProperties) {
                domUtils.mapKeyValObjOntoNode(metaElement, setProperties, odf.Namespaces.lookupNamespaceURI);
            }
            if (removedPropertyNames) {
                domUtils.removeKeyElementsFromNode(metaElement, removedPropertyNames, odf.Namespaces.lookupNamespaceURI);
            }
        }
        this.setMetadata = setMetadata;

        /**
         * Increment the number of times the document has been edited.
         * @return {!number} new number of editing cycles
         */
        this.incrementEditingCycles = function () {
            var currentValueString = getMetadata(odf.Namespaces.metans, "editing-cycles"),
                currentCycles = currentValueString ? parseInt(currentValueString, 10) : 0;

            if (isNaN(currentCycles)) {
                currentCycles = 0;
            }

            setMetadata({"meta:editing-cycles": currentCycles + 1}, null);
            return currentCycles + 1;
        };

        /**
         * Write pre-saving metadata to the DOM
         * @return {undefined}
         */
        function updateMetadataForSaving() {
            // set the opendocument provider used to create/
            // last modify the document.
            // this string should match the definition for
            // user-agents in the http protocol as specified
            // in section 14.43 of [RFC2616].
            var generatorString,
                window = runtime.getWindow();

            generatorString = "WebODF/" + webodf.Version;

            if (window) {
                generatorString = generatorString + " " + window.navigator.userAgent;
            }

            setMetadata({"meta:generator": generatorString}, null);
        }

        /**
         * @param {!string} type
         * @param {!boolean=} isTemplate  Default value is false.
         * @return {!core.Zip}
         */
        function createEmptyDocument(type, isTemplate) {
            var emptyzip = new core.Zip("", null),
                mimetype = "application/vnd.oasis.opendocument." + type + (isTemplate === true ? "-template" : ""),
                data = runtime.byteArrayFromString(
                    mimetype,
                    "utf8"
                ),
                root = self.rootElement,
                content = document.createElementNS(officens, type);
            emptyzip.save("mimetype", data, false, new Date());
            /**
             * @param {!string} memberName  variant of the real local name which allows dot notation
             * @param {!string=} realLocalName
             * @return {undefined}
             */
            function addToplevelElement(memberName, realLocalName) {
                var element;
                if (!realLocalName) {
                    realLocalName = memberName;
                }
                element = document.createElementNS(officens, realLocalName);
                root[memberName] = element;
                root.appendChild(element);
            }
            // add toplevel elements in correct order to the root node
            addToplevelElement("meta");
            addToplevelElement("settings");
            addToplevelElement("scripts");
            addToplevelElement("fontFaceDecls",   "font-face-decls");
            addToplevelElement("styles");
            addToplevelElement("automaticStyles", "automatic-styles");
            addToplevelElement("masterStyles",    "master-styles");
            addToplevelElement("body");
            root.body.appendChild(content);
            partMimetypes["/"] = mimetype;
            partMimetypes["settings.xml"] = "text/xml";
            partMimetypes["meta.xml"] = "text/xml";
            partMimetypes["styles.xml"] = "text/xml";
            partMimetypes["content.xml"] = "text/xml";

            setState(OdfContainer.DONE);
            return emptyzip;
        }

        /**
         * Fill the zip with current data.
         * @return {undefined}
         */
        function fillZip() {
            // the assumption so far is that all ODF parts are serialized
            // already, but meta, settings, styles and content should be
            // refreshed
            // update the zip entries with the data from the live ODF DOM
            var data,
                date = new Date(),
                settings;

            if (partMimetypes["settings.xml"]) {
                settings = serializeSettingsXml();
                // Optional according to package spec
                // See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__440346_826425813
                data = runtime.byteArrayFromString(settings, "utf8");
                zip.save("settings.xml", data, true, date);
            } else {
                zip.remove("settings.xml");
            }
            updateMetadataForSaving();
            // Even thought meta-data is optional, it is always created by the previous statement
            data = runtime.byteArrayFromString(serializeMetaXml(), "utf8");
            zip.save("meta.xml", data, true, date);
            data = runtime.byteArrayFromString(serializeStylesXml(), "utf8");
            zip.save("styles.xml", data, true, date);
            data = runtime.byteArrayFromString(serializeContentXml(), "utf8");
            zip.save("content.xml", data, true, date);
            data = runtime.byteArrayFromString(serializeManifestXml(), "utf8");
            zip.save("META-INF/manifest.xml", data, true, date);
        }
        /**
         * Create a bytearray from the zipfile.
         * @param {!function(!Uint8Array):undefined} successCallback receiving zip as bytearray
         * @param {!function(?string):undefined} errorCallback receiving possible err
         * @return {undefined}
         */
        function createByteArray(successCallback, errorCallback) {
            fillZip();
            zip.createByteArray(successCallback, errorCallback);
        }
        this.createByteArray = createByteArray;
        /**
         * @param {!string} newurl
         * @param {function(?string):undefined} callback
         * @return {undefined}
         */
        function saveAs(newurl, callback) {
            fillZip();
            zip.writeAs(newurl, function (err) {
                callback(err);
            });
        }
        this.saveAs = saveAs;
        /**
         * @param {function(?string):undefined} callback
         * @return {undefined}
         */
        this.save = function (callback) {
            saveAs(url, callback);
        };

        /**
         * @return {!string}
         */
        this.getUrl = function () {
            // TODO: saveAs seems to not update the url, is that wanted?
            return url;
        };
        /**
         * Add a new blob or overwrite any existing blob which has the same filename.
         * @param {!string} filename
         * @param {!string} mimetype
         * @param {!string} content base64 encoded string
         */
        this.setBlob = function (filename, mimetype, content) {
            var data = base64.convertBase64ToByteArray(content),
                date = new Date();
            zip.save(filename, data, false, date);
            if (partMimetypes.hasOwnProperty(filename)) {
                runtime.log(filename + " has been overwritten.");
            }
            partMimetypes[filename] = mimetype;
        };
        /**
         * @param {!string} filename
         */
        this.removeBlob = function (filename) {
            var foundAndRemoved = zip.remove(filename);
            runtime.assert(foundAndRemoved, "file is not found: " + filename);
            delete partMimetypes[filename];
        };
        // initialize public variables
        this.state = OdfContainer.LOADING;
        this.rootElement = /**@type{!odf.ODFDocumentElement}*/(
            createElement({
                Type: odf.ODFDocumentElement,
                namespaceURI: odf.ODFDocumentElement.namespaceURI,
                localName: odf.ODFDocumentElement.localName
            })
        );

        // initialize private variables
        if (urlOrType === odf.OdfContainer.DocumentType.TEXT) {
            zip = createEmptyDocument("text");
        } else if (urlOrType === odf.OdfContainer.DocumentType.TEXT_TEMPLATE) {
            zip = createEmptyDocument("text", true);
        } else if (urlOrType === odf.OdfContainer.DocumentType.PRESENTATION) {
            zip = createEmptyDocument("presentation");
        } else if (urlOrType === odf.OdfContainer.DocumentType.PRESENTATION_TEMPLATE) {
            zip = createEmptyDocument("presentation", true);
        } else if (urlOrType === odf.OdfContainer.DocumentType.SPREADSHEET) {
            zip = createEmptyDocument("spreadsheet");
        } else if (urlOrType === odf.OdfContainer.DocumentType.SPREADSHEET_TEMPLATE) {
            zip = createEmptyDocument("spreadsheet", true);
        } else {
            url = /**@type{!string}*/(urlOrType);
            zip = new core.Zip(url, function (err, zipobject) {
                zip = zipobject;
                if (err) {
                    loadFromXML(url, function (xmlerr) {
                        if (err) {
                            zip.error = err + "\n" + xmlerr;
                            setState(OdfContainer.INVALID);
                        }
                    });
                } else {
                    loadComponents();
                }
            });
        }
    };
    odf.OdfContainer.EMPTY = 0;
    odf.OdfContainer.LOADING = 1;
    odf.OdfContainer.DONE = 2;
    odf.OdfContainer.INVALID = 3;
    odf.OdfContainer.SAVING = 4;
    odf.OdfContainer.MODIFIED = 5;
    /**
     * @param {!string} url
     * @return {!odf.OdfContainer}
     */
    odf.OdfContainer.getContainer = function (url) {
        return new odf.OdfContainer(url, null);
    };
}());
/**
 * @enum {number}
 */
odf.OdfContainer.DocumentType = {
    TEXT:                  1,
    TEXT_TEMPLATE:         2,
    PRESENTATION:          3,
    PRESENTATION_TEMPLATE: 4,
    SPREADSHEET:           5,
    SPREADSHEET_TEMPLATE:  6
};
