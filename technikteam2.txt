
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\fullcalendar\main.min.css
========================================================================

/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-media-screen {
	max-width: 900px
}

.fc-media-print {
	display: none
}

.fc-liquid-hack .fc-event, .fc-liquid-hack .fc-event-main-frame,
	.fc-liquid-hack .fc-event-time, .fc-liquid-hack .fc-event-title,
	.fc-liquid-hack .fc-timegrid-event-harness, .fc-liquid-hack .fc-timegrid-now-indicator-arrow,
	.fc-liquid-hack .fc-timegrid-now-indicator-line, .fc-liquid-hack td,
	.fc-liquid-hack th {
	box-sizing: content-box
}

.fc {
	direction: ltr;
	text-align: left
}

.fc-rtl {
	text-align: right
}

.fc-h-event .fc-event-main {
	color: #000
}

.fc-h-event .fc-event-main-frame {
	display: flex;
	flex-wrap: wrap
}

.fc-h-event .fc-event-time {
	flex-shrink: 0
}

.fc-h-event .fc-event-title {
	flex-grow: 1;
	flex-shrink: 1;
	min-width: 0
}

.fc-h-event .fc-event-resizer {
	align-self: flex-end
}

.fc-event {
	position: relative;
	display: flex;
	font-size: 1em;
	line-height: 1.4;
	border-radius: .25em
}

.fc-event-main {
	flex-grow: 1;
	flex-shrink: 1;
	min-width: 0
}

.fc-event-main-frame {
	display: flex;
	height: 100%
}

.fc-event-time, .fc-event-title-container {
	flex-shrink: 0
}

.fc-event:focus {
	z-index: 9
}

.fc-event-resizer {
	position: absolute;
	z-index: 4
}

.fc-event.fc-event-dragging, .fc-event:hover {
	z-index: 8
}

.fc-event .fc-event-bg {
	z-index: 1;
	background: var(--fc-event-bg-color, #fff)
}

.fc-event .fc-event-main {
	position: relative;
	z-index: 2;
	color: var(--fc-event-text-color, #000)
}

.fc a[data-navlink] {
	cursor: pointer
}

.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),
	.fc-direction-ltr .fc-daygrid-dot-event:not(.fc-event-start) {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0
}

.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),
	.fc-direction-ltr .fc-daygrid-dot-event:not(.fc-event-end) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0
}

.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start),
	.fc-direction-rtl .fc-daygrid-dot-event:not(.fc-event-start) {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0
}

.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end),
	.fc-direction-rtl .fc-daygrid-dot-event:not(.fc-event-end) {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0
}

.fc-daygrid-event-harness {
	position: relative
}

.fc-daygrid-event.fc-event-mirror {
	position: absolute;
	z-index: 1001
}

.fc-daygrid-block-event {
	display: block
}

.fc-daygrid-block-event, .fc-daygrid-block-event .fc-event-main {
	position: relative
}

.fc-daygrid-block-event .fc-event-main {
	width: 100%
}

.fc-daygrid-block-event .fc-event-time, .fc-daygrid-block-event .fc-event-title
	{
	padding: 0 1px
}

.fc-daygrid-dot-event {
	display: flex;
	align-items: center
}

.fc-daygrid-dot-event .fc-event-main {
	flex-grow: 1;
	flex-shrink: 1;
	min-width: 0;
	overflow: hidden
}

.fc-daygrid-dot-event .fc-event-title {
	overflow: hidden
}

.fc-daygrid-event-dot {
	margin: 0 4px;
	box-sizing: content-box
}

.fc-list-event .fc-event-main-frame, .fc-list-event.fc-event-mirror .fc-event-main-frame
	{
	position: relative;
	z-index: 2;
	height: auto
}

.fc-list-table {
	width: 100%;
	border-collapse: collapse
}

.fc-list-table tr:hover td {
	background-color: rgba(0, 0, 0, .04)
}

.fc-list-day {
	background-color: rgba(0, 0, 0, .07)
}

.fc-list-event.fc-event-mirror {
	box-shadow: 0 2px 5px rgba(0, 0, 0, .3)
}

.fc-timegrid-axis-frame {
	position: sticky;
	top: 0;
	left: 0;
	z-index: 2;
	background: var(--fc-page-bg-color, #fff)
}

.fc-timegrid-col.fc-day-today {
	background-color: rgba(255, 220, 40, .15)
}

.fc-timegrid-event-harness {
	position: absolute
}

.fc-timegrid-event {
	position: absolute;
	left: 0;
	right: 0;
	border-width: 0 1px 1px 1px;
	border-bottom-style: solid;
	border-image: initial;
	border-color: inherit
}

.fc-timegrid-event .fc-event-main {
	padding: 1px 1px 0
}

.fc-timegrid-event .fc-event-time {
	white-space: nowrap;
	font-size: .9em
}

.fc-timegrid-event .fc-event-title {
	overflow: hidden
}

.fc-timegrid-event.fc-event-mirror {
	z-index: 1001
}

.fc-timegrid-event.fc-event-selected:before {
	content: "";
	position: absolute;
	top: -1px;
	left: -1px;
	right: -1px;
	bottom: -1px;
	border: 1px solid #000;
	z-index: -1
}

.fc-timegrid-now-indicator-line {
	position: absolute;
	z-index: 4;
	left: 0;
	right: 0
}

.fc-timegrid-now-indicator-arrow {
	position: absolute;
	z-index: 4;
	margin-top: -6px
}

.fc-timegrid-slots, .fc-timegrid-slots tr {
	height: 1.5em
}

.fc-timegrid-slots td {
	border: 0
}

.fc-timegrid-bg-harness {
	position: absolute;
	top: 0;
	bottom: 0;
	pointer-events: none
}

.fc-timegrid-bg-event {
	position: absolute;
	z-index: 1;
	left: 0;
	right: 0
}

.fc-timegrid-axis-chunk>div {
	position: relative
}

.fc-timegrid-axis-chunk>div>div {
	position: sticky;
	top: 0;
	left: 0
}

.fc-resource {
	position: relative
}

.fc-resource-header-cell {
	position: sticky;
	top: 0;
	left: 0;
	z-index: 2;
	background: var(--fc-page-bg-color, #fff)
}

.fc-resource-header-cell>div {
	position: relative
}

.fc-resource-header-cell>div>div {
	position: sticky;
	left: 0
}

.fc-resource-header-cell .fc-datagrid-cell-cushion,
	.fc-resource-header-cell .fc-datagrid-cell-main {
	display: block
}

.fc-resource.fc-day-today {
	background-color: rgba(255, 220, 40, .15)
}

.fc-resource-timeline-divider {
	position: absolute;
	top: 0;
	bottom: 0;
	z-index: 2
}

.fc-resource-timeline-slots td {
	border-width: 0 1px;
	border-style: solid;
	border-color: transparent
}

.fc-resource-timeline-slots tr:first-child td {
	border-top-width: 1px
}

.fc-resource-timeline .fc-datagrid-cell-frame {
	height: 100%
}

.fc-resource-timeline-lane {
	position: relative
}

.fc-resource-timeline-lane .fc-timegrid-event-harness {
	position: absolute;
	top: 0;
	left: 0;
	right: 0
}

.fc-resource-timeline-lane .fc-timegrid-bg-harness {
	position: absolute;
	top: 0;
	bottom: 0;
	left: 0;
	right: 0
}

.fc-resource-timeline-lane-frame {
	position: absolute;
	left: 0;
	right: 0;
	top: 0;
	bottom: 0
}

.fc-vresource-area {
	position: absolute;
	top: 0;
	left: 0;
	height: 100%;
	background: var(--fc-page-bg-color, #fff)
}

.fc-vresource-area .fc-datagrid-cell-frame {
	position: sticky;
	top: 0
}

.fc-vresource-area td, .fc-vresource-area th {
	vertical-align: top
}

.fc-vresource-view .fc-timegrid-axis-frame {
	position: absolute
}

.fc-vresource-view .fc-timegrid-col-frame {
	position: relative
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-theme-bootstrap, .fc-theme-bootstrap5 {
	--fc-event-border-color: #fff
}

.fc-theme-bootstrap5 a:not([href]), .fc-theme-bootstrap a:not([href]) {
	color: inherit;
	text-decoration: inherit
}

.fc-theme-bootstrap5 .table, .fc-theme-bootstrap .table {
	margin-bottom: 0
}

.fc-theme-bootstrap5 .table-bordered thead td, .fc-theme-bootstrap5 .table-bordered thead th,
	.fc-theme-bootstrap .table-bordered thead td, .fc-theme-bootstrap .table-bordered thead th
	{
	border-bottom-width: 2px
}

.fc-theme-bootstrap5 .table-bordered td, .fc-theme-bootstrap5 .table-bordered th,
	.fc-theme-bootstrap .table-bordered td, .fc-theme-bootstrap .table-bordered th
	{
	border: 1px solid #ddd
}

.fc-theme-bootstrap5 td, .fc-theme-bootstrap5 th, .fc-theme-bootstrap td,
	.fc-theme-bootstrap th {
	border: none
}

.fc-theme-bootstrap5 .fc-scrollgrid, .fc-theme-bootstrap .fc-scrollgrid
	{
	border-collapse: separate;
	border: 1px solid #dee2e6
}

.fc-theme-bootstrap5 .fc-scrollgrid, .fc-theme-bootstrap5 .fc-scrollgrid table,
	.fc-theme-bootstrap .fc-scrollgrid, .fc-theme-bootstrap .fc-scrollgrid table
	{
	border-radius: .25rem
}

.fc-theme-bootstrap5 .fc-daygrid-day-number, .fc-theme-bootstrap .fc-daygrid-day-number
	{
	padding: .2em
}

.fc-theme-bootstrap5 .fc-list-table, .fc-theme-bootstrap .fc-list-table
	{
	border: 1px solid #dee2e6
}

.fc-theme-bootstrap5 .fc-list-table td, .fc-theme-bootstrap .fc-list-table td
	{
	border-top: 1px solid #dee2e6
}

.fc-direction-ltr, .fc-direction-rtl, .fc-theme-standard {
	--fc-border-color: #ddd;
	--fc-page-bg-color: #fff;
	--fc-neutral-bg-color: hsla(0, 0%, 96.1%, .65);
	--fc-neutral-text-color: #808080;
	--fc-today-bg-color: rgba(255, 220, 40, .15);
	--fc-highlight-color: rgba(69, 173, 255, .2);
	--fc-event-bg-color: #3788d8;
	--fc-event-border-color: #3788d8;
	--fc-event-text-color: #fff;
	--fc-event-selected-overlay-color: rgba(0, 0, 0, .25);
	--fc-more-link-bg-color: #d0d0d0;
	--fc-more-link-text-color: inherit;
	--fc-event-resizer-thickness: 8px;
	--fc-event-resizer-dot-thickness: 1px;
	--fc-event-resizer-dot-border-width: 1px;
	--fc-event-resizer-dot-border-color: #fff;
	--fc-non-business-color: hsla(0, 0%, 96.1%, .6);
	--fc-bg-event-color: #8fdf82;
	--fc-bg-event-opacity: .3;
	--fc-list-event-dot-width: 10px;
	--fc-list-event-hover-bg-color: #f5f5f5
}

.fc-theme-standard .fc-scrollgrid {
	border: 1px solid var(--fc-border-color)
}

.fc-theme-standard td, .fc-theme-standard th {
	border: 1px solid var(--fc-border-color)
}

.fc-theme-standard .fc-scrollgrid-section-header td, .fc-theme-standard .fc-scrollgrid-section-header th
	{
	border-bottom-width: 0
}

.fc-theme-standard .fc-scrollgrid-section-body table, .fc-theme-standard .fc-scrollgrid-section-body td,
	.fc-theme-standard .fc-scrollgrid-section-body th {
	border-top-width: 0
}

.fc-theme-standard .fc-scrollgrid-section-footer td, .fc-theme-standard .fc-scrollgrid-section-footer th
	{
	border-top-width: 0
}

.fc-theme-standard .fc-scrollgrid-section-liquid td, .fc-theme-standard .fc-scrollgrid-section-liquid th
	{
	border-bottom-width: 0
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-datagrid {
	width: 100%;
	border-collapse: collapse
}

.fc-datagrid-cell-frame {
	position: relative;
	padding: .3em .4em;
	height: 100%
}

.fc-datagrid-cell-cushion {
	display: flex;
	align-items: center
}

.fc-datagrid-cell-main {
	flex-grow: 1;
	flex-shrink: 1;
	min-width: 0
}

.fc-datagrid-cell.fc-datagrid-cell-expander {
	text-align: center
}

.fc-datagrid-expander {
	display: inline-block;
	cursor: pointer;
	font-family: monospace;
	font-size: 1.1em
}

.fc-datagrid-expander-placeholder {
	display: inline-block;
	visibility: hidden
}

.fc-datagrid-expander-content:before {
	content: "\025B8"
}

.fc-datagrid-row.fc-datagrid-row-expanded .fc-datagrid-expander-content:before
	{
	content: "\025BE"
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-scrollgrid {
	width: 100%;
	table-layout: fixed
}

.fc-scrollgrid table {
	border-collapse: collapse;
	border-spacing: 0
}

.fc-scrollgrid-liquid {
	height: 100%
}

.fc-scrollgrid-section>td, .fc-scrollgrid-section>th {
	border-left-width: 0;
	border-right-width: 0;
	vertical-align: top
}

.fc-scrollgrid-section>td:first-child, .fc-scrollgrid-section>th:first-child
	{
	border-left-width: 1px
}

.fc-scrollgrid-section>td:last-child, .fc-scrollgrid-section>th:last-child
	{
	border-right-width: 1px
}

.fc-scrollgrid-section-header>th {
	text-align: center
}

.fc-scrollgrid-section-header, .fc-scrollgrid-section-footer {
	flex-shrink: 0
}

.fc-scrollgrid-section-body {
	position: relative
}

.fc-scrollgrid-section-body, .fc-scrollgrid-section-body>tr>td {
	height: 100%
}

.fc-scrollgrid-section-body.fc-scrollgrid-section-liquid {
	height: 100%
}

.fc-scrollgrid-section-body.fc-scrollgrid-section-liquid>tr {
	height: 100%
}

.fc-scrollgrid-section-body table {
	width: 100%
}

.fc-scrollgrid-section-body>tr:first-child>td {
	border-top-width: 0
}

.fc-scrollgrid-section-body>tr:last-child>td {
	border-bottom-width: 0
}

.fc-scrollgrid-section-body table {
	height: 100%
}

.fc-scrollgrid-section-body>tr {
	height: 0
}

.fc-scrollgrid-section-body>tr>td {
	position: relative
}

.fc-scrollgrid-section-body>tr>td:first-child {
	border-left-width: 0
}

.fc-scrollgrid-section-body>tr>td:last-child {
	border-right-width: 0
}

.fc-scrollgrid-scroller {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	overflow: auto
}

.fc-scrollgrid-scroller-liquid {
	position: relative;
	height: 100%
}

.fc-scrollgrid-col-resizer {
	position: absolute;
	top: 0;
	cursor: col-resize
}

.fc-scrollgrid-col-resizer:after {
	content: "";
	position: absolute;
	top: 0;
	left: -5px;
	right: -5px;
	bottom: -5px
}

.fc-scrollgrid-sync-inner {
	position: relative;
	height: 100%
}

.fc-scrollgrid-sync-table {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	width: 100%;
	height: 100%
}

.fc-scrollgrid-sticky-hacks>td, .fc-scrollgrid-sticky-hacks>th {
	background: var(--fc-page-bg-color, #fff)
}

.fc-scrollgrid-sticky-hacks tr:last-child td,
	.fc-scrollgrid-sticky-hacks tr:last-child th {
	border-bottom: 0
}

.fc-scrollgrid-sticky-hacks .fc-scrollgrid-section-body table {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0
}

.fc-scrollgrid-sticky-hacks .fc-scrollgrid-section-body>tr:not(:first-child)
	{
	visibility: hidden
}

.fc-scrollgrid-sticky-hacks .fc-scrollgrid-section-body>tr>td {
	height: 0
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-popover {
	position: absolute;
	z-index: 1000;
	box-shadow: 0 2px 6px rgba(0, 0, 0, .15)
}

.fc-popover-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: .5em .75em
}

.fc-popover-title {
	margin: 0
}

.fc-popover-close {
	cursor: pointer;
	opacity: .65;
	font-size: 1.1em
}

.fc-popover-close:hover {
	opacity: 1
}

.fc-popover-body {
	padding: .75em
}

.fc-list {
	border: 1px solid var(--fc-border-color)
}

.fc-list-empty {
	padding: 2em;
	text-align: center
}

.fc-list-empty-cushion {
	margin: 0
}

.fc-list-table thead {
	border-bottom: 1px solid var(--fc-border-color)
}

.fc-list-table th {
	padding: 1em
}

.fc-list-day>th {
	position: sticky;
	top: 0;
	background: var(--fc-page-bg-color, #fff)
}

.fc-list-day-text, .fc-list-day-side-text {
	text-decoration: none
}

.fc-list-day-text:hover, .fc-list-day-side-text:hover {
	text-decoration: underline
}

.fc-list-table td {
	padding: .5em .8em
}

.fc-list-event-graphic {
	padding-right: .5em
}

.fc-list-event-dot {
	border: calc(var(--fc-list-event-dot-width)/2) solid
		var(--fc-event-border-color)
}

.fc-list-event-time {
	white-space: nowrap
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-toolbar {
	display: flex;
	justify-content: space-between;
	align-items: center
}

.fc-toolbar-chunk {
	display: flex;
	position: relative;
	align-items: center
}

.fc-toolbar-title {
	font-size: 1.5em;
	margin: 0
}

.fc-button {
	position: relative;
	display: inline-block;
	padding: .4em .65em;
	margin: 0 .2em;
	font-size: 1em;
	font-family: inherit;
	font-weight: inherit;
	line-height: 1.4;
	text-transform: capitalize;
	border: 1px solid var(--fc-border-color);
	border-radius: .25em;
	background: var(--fc-page-bg-color, #fff);
	color: var(--fc-neutral-text-color, #808080);
	cursor: pointer
}

.fc-button:disabled {
	opacity: .5
}

.fc-button:not(:disabled):active, .fc-button:not(:disabled):hover {
	background: var(--fc-neutral-bg-color, hsla(0, 0%, 96.1%, .65))
}

.fc-button-primary {
	border-width: 0;
	background: var(--fc-button-bg-color, var(--fc-event-bg-color, #3788d8));
	color: var(--fc-button-text-color, var(--fc-event-text-color, #fff))
}

.fc-button-primary:disabled {
	background: var(--fc-button-bg-color, var(--fc-event-bg-color, #3788d8));
	opacity: .5
}

.fc-button-primary:not(:disabled):active, .fc-button-primary:not(:disabled):hover
	{
	background: var(--fc-button-hover-bg-color, var(--fc-event-bg-color, #3788d8))
}

.fc-button-group {
	display: inline-flex;
	position: relative;
	vertical-align: middle
}

.fc-button-group>.fc-button {
	position: relative;
	flex: 1 1 auto
}

.fc-button-group>.fc-button:first-child {
	border-top-right-radius: 0;
	border-bottom-right-radius: 0
}

.fc-button-group>.fc-button:last-child {
	border-top-left-radius: 0;
	border-bottom-left-radius: 0
}

.fc-button-group>.fc-button:not(:first-child) {
	margin-left: -1px
}

.fc-button-group>.fc-button.fc-button-active, .fc-button-group>.fc-button:active,
	.fc-button-group>.fc-button:focus, .fc-button-group>.fc-button:hover {
	z-index: 1
}

.fc-button.fc-button-active {
	background: var(--fc-neutral-bg-color, hsla(0, 0%, 96.1%, .65))
}
/*!
FullCalendar v5.11.5
Docs & License: https://fullcalendar.io/
(c) 2022 Adam Shaw
*/
.fc-view-harness {
	flex-grow: 1;
	position: relative
}

.fc-view-harness-active>.fc-view {
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0
}

.fc-view, body, html {
	font-size: 1em
}

.fc-col-header {
	display: flex;
	flex-direction: column;
	position: relative
}

.fc-col-header-cell {
	position: relative
}

.fc .fc-col-header-cell-cushion {
	display: inline-block;
	padding: .2em .4em
}

.fc-daygrid-day-frame {
	position: relative;
	min-height: 100%
}

.fc-daygrid-day-top {
	display: flex
}

.fc-daygrid-day-bottom {
	font-size: .85em;
	padding: 2px
}

.fc-daygrid-day-events {
	position: relative;
	z-index: 1;
	min-height: 1.2em;
	margin-top: 1.5em
}

.fc-daygrid-day-bg {
	position: absolute;
	z-index: 0;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0
}

.fc-daygrid-day-number {
	position: relative;
	z-index: 2;
	padding: .4em
}

.fc-day-today .fc-daygrid-day-number {
	font-weight: 700
}

.fc-daygrid-more-link {
	position: relative;
	z-index: 2;
	cursor: pointer;
	margin-top: 2px;
	padding: 0 2px
}

.fc-event-title-container, .fc-event-time {
	padding: .1em .2em
}

.fc-event-title-container {
	flex-grow: 1;
	flex-shrink: 1;
	min-width: 0
}

.fc-event-end .fc-event-resizer-end, .fc-event-start .fc-event-resizer-start
	{
	cursor: e-resize
}

.fc-rtl .fc-event-end .fc-event-resizer-end, .fc-rtl .fc-event-start .fc-event-resizer-start
	{
	cursor: w-resize
}

.fc-event-resizer-end {
	right: 0;
	border-right-width: var(--fc-event-resizer-thickness, 8px);
	border-top-right-radius: var(--fc-event-resizer-thickness, 8px);
	border-bottom-right-radius: var(--fc-event-resizer-thickness, 8px)
}

.fc-event-resizer-start {
	left: 0;
	border-left-width: var(--fc-event-resizer-thickness, 8px);
	border-top-left-radius: var(--fc-event-resizer-thickness, 8px);
	border-bottom-left-radius: var(--fc-event-resizer-thickness, 8px)
}

.fc-timegrid {
	position: relative
}

.fc-timegrid-container {
	position: relative;
	flex-grow: 1
}

.fc-timegrid-body, .fc-timegrid-head {
	position: relative;
	width: 100%;
	table-layout: fixed
}

.fc-timegrid-slots {
	position: relative;
	z-index: 1
}

.fc-timegrid-cols {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0
}

.fc-timegrid-col {
	position: relative
}

.fc-timegrid-axis {
	vertical-align: middle;
	padding: 0 .5em
}

.fc-timegrid-axis-cushion {
	padding: .3em 0
}

.fc-timegrid-axis-frame-liquid {
	height: 100%
}

.fc-timegrid-slicer {
	position: absolute;
	top: 0;
	left: 0;
	right: 0
}

.fc-timegrid-slicer-events, .fc-timegrid-slicer-non-events {
	position: relative
}

.fc-timegrid-slicer-events {
	z-index: 1
}

.fc-timegrid-slicer-non-events {
	z-index: 0
}

.fc-timegrid-slicer-frame {
	position: absolute;
	top: 0;
	left: 0;
	right: 0
}

.fc-timegrid-slicer-container {
	position: relative
}

.fc-timegrid-slicer-col {
	position: absolute;
	top: 0;
	bottom: 0
}

.fc-timegrid-slicer-col table {
	height: 100%
}

.fc-timegrid-slicer-col table td {
	border: 0
}

.fc-timegrid-event-resizer-end {
	bottom: 0;
	cursor: s-resize
}

.fc-timegrid-event-resizer-start {
	top: 0;
	cursor: n-resize
}

.fc-timegrid-now-indicator-line {
	border-style: solid;
	border-width: 1px 0 0
}

.fc-timegrid-now-indicator-arrow {
	border-style: solid;
	border-width: 6px 0 6px 6px
}

.fc-direction-ltr .fc-timegrid-now-indicator-arrow {
	border-left-color: inherit;
	border-top-color: transparent;
	border-bottom-color: transparent
}

.fc-direction-rtl .fc-timegrid-now-indicator-arrow {
	border-right-color: inherit;
	border-top-color: transparent;
	border-bottom-color: transparent;
	margin-left: -6px;
	border-left-width: 0;
	border-right-width: 6px
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\fullcalendar\locales\de.js
========================================================================

(function(e,l){"object"==typeof exports&&"undefined"!=typeof module?l(exports,require("@fullcalendar/core")):"function"==typeof define&&define.amd?define(["exports","@fullcalendar/core"],l):l((e.FullCalendarLocales=e.FullCalendarLocales||{},e.FullCalendarLocales.de={}),e.FullCalendar);})(this,function(e,l){"use strict";var o={code:"de",week:{dow:1,doy:4},buttonText:{prev:"Zurück",next:"Vor",today:"Heute",year:"Jahr",month:"Monat",week:"Woche",day:"Tag",list:"Terminübersicht"},weekText:"W",weekTextLong:"Woche",allDayText:"Ganztägig",moreLinkText:function(e){return"+ weitere "+e},noEventsText:"Keine Ereignisse anzuzeigen"};return l.globalLocales.push(o),e.default=o,Object.defineProperty(e,"__esModule",{value:!0}),e;});
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\webodf.js
========================================================================

/**
 * Copyright (C) 2013-2014 KO GmbH <copyright@kogmbh.com>
 *
 * Modified for TechnikTeam project to be self-locating.
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global XMLHttpRequest, runtime, WodoFromSource: true*/

(function() {
	"use strict";

	// Find the path to this script to locate the 'lib' directory.
	var scripts = document.getElementsByTagName("script");
	var webodfScriptSrc = scripts[scripts.length - 1].src;
	var webodfScriptPath = webodfScriptSrc.substring(0, webodfScriptSrc.lastIndexOf('/'));

	var xhr = new XMLHttpRequest(),
		path = webodfScriptPath + "/lib", // Use the dynamically found path
		runtimeFilePath = path + "/runtime.js",
		code;

	xhr.open("GET", runtimeFilePath, false); // Synchronous XHR, old but part of the library
	xhr.send(null);

	if (xhr.status !== 200 && xhr.status !== 0) { // status 0 for file:// protocol
		console.error("Failed to load WebODF runtime from " + runtimeFilePath);
		return;
	}

	code = xhr.responseText;
	code += "\n//# sourceURL=" + runtimeFilePath;
	/*jslint evil: true*/
	eval(code);
	/*jslint evil: false*/

	// adapt for out-of-sources run
	runtime.currentDirectory = function() {
		return path;
	};
	runtime.libraryPaths = function() {
		return [path];
	};
	// load a class to trigger loading the complete lib
	runtime.loadClass('odf.OdfContainer');

	// flag for telling the editor component that this is run from source
	window.WodoFromSource = true;
}());
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\wodo.js
========================================================================

/**
 * Copyright (C) 2013-2014 KO GmbH <copyright@kogmbh.com>
 *
 * Modified for TechnikTeam project to be self-locating.
 * This version executes in the global scope to prevent reference errors.
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

// This script MUST execute in the global scope, not an IIFE,
// so that the eval'd 'runtime.js' creates a global 'runtime' object.

var scripts = document.getElementsByTagName("script");
var wodoScriptSrc = scripts[scripts.length - 1].src;
var wodoScriptPath = wodoScriptSrc.substring(0, wodoScriptSrc.lastIndexOf('/'));

var xhr = new XMLHttpRequest();
// Use the dynamically found path to build the correct library path
var path = wodoScriptPath + "/lib";
var runtimeFilePath = path + "/runtime.js";
var code;

// Synchronous XHR is part of the original library's design for simplicity.
xhr.open("GET", runtimeFilePath, false);
xhr.send(null);

if (xhr.status !== 200 && xhr.status !== 0) { // status 0 is for file:// protocol access
	console.error("Failed to load WebODF runtime from " + runtimeFilePath);
} else {
	code = xhr.responseText;
	code += "\n//# sourceURL=" + runtimeFilePath;

	// By not using an IIFE, 'var runtime' inside the eval'd code will become a global variable.
	eval(code);

	// Now 'runtime' should be a global object available for configuration.
	if (typeof runtime !== 'undefined') {
		runtime.currentDirectory = function() {
			return path;
		};
		runtime.libraryPaths = function() {
			return [path];
		};

		// Load a class to trigger loading the complete library
		runtime.loadClass('odf.OdfContainer');

		// Flag for telling the editor component that this is run from source
		window.WodoFromSource = true;
	} else {
		console.error("WebODF runtime object was not created after evaluating runtime.js. Check the file content.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\HeaderCompiled.js
========================================================================

/**
 * @license
 * This is a generated file. DO NOT EDIT.
 *
 * Copyright (C) 2010-2015 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is the compiled version of the WebODF library.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\runtime.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*jslint nomen: true, bitwise: true, emptyblock: true, unparam: true */
/*global window, XMLHttpRequest, require, console, DOMParser, document,
  process, __dirname, setTimeout, Packages, print,
  readFile, quit, Buffer, ArrayBuffer, Uint8Array,
  navigator, VBArray, alert, now, clearTimeout, webodf_version */

/**
 * Three implementations of a runtime for browser, node.js and rhino.
 */

/**
 * Abstraction of the runtime environment.
 * @class
 * @interface
 */
function Runtime() {"use strict"; }

/**
 * @param {!string} name
 * @return {*}
 */
Runtime.prototype.getVariable = function (name) { "use strict"; };

/**
 * @param {*} anything
 * @return {!string}
 */
Runtime.prototype.toJson = function (anything) { "use strict"; };

/**
 * @param {!string} jsonstr
 * @return {*}
 */
Runtime.prototype.fromJson = function (jsonstr) { "use strict"; };

/**
 * @param {!string} string
 * @param {!string} encoding
 * @return {!Uint8Array}
 */
Runtime.prototype.byteArrayFromString = function (string, encoding) {"use strict"; };
/**
 * @param {!Uint8Array} bytearray
 * @param {!string} encoding
 * @return {!string}
 */
Runtime.prototype.byteArrayToString = function (bytearray, encoding) {"use strict"; };
/**
 * Read part of a binary file.
 * @param {!string} path
 * @param {!number} offset
 * @param {!number} length
 * @param {!function(?string,?Uint8Array):undefined} callback
 * @return {undefined}
 */
Runtime.prototype.read = function (path, offset, length, callback) {"use strict"; };
/**
 * Read the contents of a file. Returns the result via a callback. If the
 * encoding is 'binary', the result is returned as a Uint8Array,
 * otherwise, it is returned as a string.
 * @param {!string} path
 * @param {!string} encoding text encoding or 'binary'
 * @param {!function(?string,?(string|Uint8Array)):undefined} callback
 * @return {undefined}
 */
Runtime.prototype.readFile = function (path, encoding, callback) {"use strict"; };
/**
 * Read a file completely, throw an exception if there is a problem.
 * @param {!string} path
 * @param {!string} encoding text encoding or 'binary'
 * @return {!string|!Uint8Array}
 */
Runtime.prototype.readFileSync = function (path, encoding) {"use strict"; };
/**
 * @param {!string} path
 * @param {!function(?string,?Document):undefined} callback
 * @return {undefined}
 */
Runtime.prototype.loadXML = function (path, callback) {"use strict"; };
/**
 * @param {!string} path
 * @param {!Uint8Array} data
 * @param {!function(?string):undefined} callback
 * @return {undefined}
 */
Runtime.prototype.writeFile = function (path, data, callback) {"use strict"; };
/**
 * @param {!string} path
 * @param {!function(?string):undefined} callback
 * @return {undefined}
 */
Runtime.prototype.deleteFile = function (path, callback) {"use strict"; };
/**
 * @param {!string} msgOrCategory
 * @param {!string=} msg
 * @return {undefined}
 */
Runtime.prototype.log = function (msgOrCategory, msg) {"use strict"; };
/**
 * @param {!function():undefined} callback
 * @param {!number} milliseconds
 * @return {!number}
 */
Runtime.prototype.setTimeout = function (callback, milliseconds) {"use strict"; };
/**
 * @param {!number} timeoutID
 * @return {undefined}
 */
Runtime.prototype.clearTimeout = function (timeoutID) {"use strict"; };
/**
 * @return {!Array.<string>}
 */
Runtime.prototype.libraryPaths = function () {"use strict"; };
/**
 * @return {!string}
 */
Runtime.prototype.currentDirectory = function () {"use strict"; };
/**
 * @param {!string} dir
 * @return {undefined}
 */
Runtime.prototype.setCurrentDirectory = function (dir) {"use strict"; };
/**
 * @return {string}
 */
Runtime.prototype.type = function () {"use strict"; };
/**
 * @return {?DOMImplementation}
 */
Runtime.prototype.getDOMImplementation = function () {"use strict"; };
/**
 * @param {!string} xml
 * @return {?Document}
 */
Runtime.prototype.parseXML = function (xml) {"use strict"; };
/**
 * @param {!number} exitCode
 */
Runtime.prototype.exit = function (exitCode) {"use strict"; };
/**
 * @return {?Window}
 */
Runtime.prototype.getWindow = function () {"use strict"; };
/**
 * @param {!function():undefined} callback
 * @return {!number}
 */
Runtime.prototype.requestAnimationFrame = function (callback) {"use strict"; };
/**
 * @param {!number} requestId
 * @return {undefined}
 */
Runtime.prototype.cancelAnimationFrame = function (requestId) {"use strict"; };
/**
 * @param {!boolean} condition
 * @param {!string} message
 * @return {undefined}
 */
Runtime.prototype.assert = function (condition, message) { "use strict"; };
/*jslint emptyblock: false, unparam: false */

/** @define {boolean} */
var IS_COMPILED_CODE = false;

/**
 * @this {Runtime}
 * @param {!Uint8Array} bytearray
 * @param {!string} encoding
 * @return {!string}
 */
Runtime.byteArrayToString = function (bytearray, encoding) {
    "use strict";
    /**
     * @param {!Uint8Array} bytearray
     * @return {!string}
     */
    function byteArrayToString(bytearray) {
        var s = "", i, l = bytearray.length;
        for (i = 0; i < l; i += 1) {
            s += String.fromCharCode(bytearray[i] & 0xff);
        }
        return s;
    }
    /**
     * @param {!Uint8Array} bytearray
     * @return {!string}
     */
    function utf8ByteArrayToString(bytearray) {
        var s = "", startPos, i, l = bytearray.length,
            chars = [],
            c0, c1, c2, c3, codepoint;

        // skip a possible UTF-8 BOM
        if (l >= 3 && bytearray[0] === 0xef && bytearray[1] === 0xbb && bytearray[2] === 0xbf) {
            startPos = 3;
        } else {
            startPos = 0;
        }

        for (i = startPos; i < l; i += 1) {
            c0 = /**@type{!number}*/(bytearray[i]);
            if (c0 < 0x80) {
                chars.push(c0);
            } else {
                i += 1;
                c1 = /**@type{!number}*/(bytearray[i]);
                if (c0 >= 0xc2 && c0 < 0xe0) {
                    chars.push(((c0 & 0x1f) << 6) | (c1 & 0x3f));
                } else {
                    i += 1;
                    c2 = /**@type{!number}*/(bytearray[i]);
                    if (c0 >= 0xe0 && c0 < 0xf0) {
                        chars.push(((c0 & 0x0f) << 12) | ((c1 & 0x3f) << 6) | (c2 & 0x3f));
                    } else {
                        i += 1;
                        c3 = /**@type{!number}*/(bytearray[i]);
                        if (c0 >= 0xf0 && c0 < 0xf5) {
                            codepoint = ((c0 & 0x07) << 18) | ((c1 & 0x3f) << 12) | ((c2 & 0x3f) << 6) | (c3 & 0x3f);
                            codepoint -= 0x10000;
                            chars.push((codepoint >> 10) + 0xd800, (codepoint & 0x3ff) + 0xdc00);
                        }
                    }
                }
            }
            if (chars.length >= 1000) {
                // more than 2 chars can be added in the above logic, so the length might exceed 1000

                // Char-to-string conversion is done using apply as it provides a roughly %30 improvement vs.
                // converting the characters 1-by-1, and improves memory usage significantly as well.

                // However, the apply function has an upper limit on the size of the arguments array. If it is exceeded,
                // most browsers with throw a RangeError. Avoid this problem by converting no more than 1000(ish)
                // characters per call.
                s += String.fromCharCode.apply(null, chars);
                chars.length = 0;
            }
        }
        // Based on the above chars.length check, there is guaranteed to be less than 1000 chars left in the array
        return s + String.fromCharCode.apply(null, chars);
    }
    var result;
    if (encoding === "utf8") {
        result = utf8ByteArrayToString(bytearray);
    } else {
        if (encoding !== "binary") {
            this.log("Unsupported encoding: " + encoding);
        }
        result = byteArrayToString(bytearray);
    }
    return result;
};

/**
 * @param {!string} name
 * @return {*}
 */
Runtime.getVariable = function (name) {
    "use strict";
    /*jslint evil: true*/
    try {
        return eval(name);
    } catch (e) {
        return undefined;
    }
    /*jslint evil: false*/
};

/**
 * @param {*} anything
 * @return {!string}
 */
Runtime.toJson = function (anything) {
    "use strict";
    return JSON.stringify(anything);
};

/**
 * @param {!string} jsonstr
 * @return {*}
 */
Runtime.fromJson = function (jsonstr) {
    "use strict";
    return JSON.parse(jsonstr);
};

/**
 * @param {!Function} f
 * @return {?string}
 */
Runtime.getFunctionName = function getFunctionName(f) {
    "use strict";
    var m;
    if (f.name === undefined) {
        m = new RegExp("function\\s+(\\w+)").exec(f);
        return m && m[1];
    }
    return f.name;
};

/**
 * @this {Runtime}
 * @param {!boolean} condition
 * @param {!string} message
 * @return {undefined}
 */
Runtime.assert = function (condition, message) {
    "use strict";
    if (!condition) {
        this.log("alert", "ASSERTION FAILED:\n" + message);
        throw new Error(message); // interrupt execution and provide a backtrace
    }
};

/**
 * @class
 * @constructor
 * @augments Runtime
 * @implements {Runtime}
 */
function BrowserRuntime() {
    "use strict";
    var self = this;

    /**
     * Return the number of bytes a string would take up when encoded as utf-8.
     * @param {string} string
     * @return {number}
     */
    function getUtf8LengthForString(string) {
        var l = string.length, i, n, j = 0;
        for (i = 0; i < l; i += 1) {
            n = string.charCodeAt(i);
            j += 1 + (n > 0x80) + (n > 0x800);
            if (n > 0xd700 && n < 0xe000) { // first of a surrogate pair
                j += 1;
                i += 1; // skip second half of in surrogate pair
            }
        }
        return j;
    }

    /**
     * Convert UCS-2 string to UTF-8 array.
     * @param {string} string
     * @param {number} length the length of the resulting array
     * @param {boolean} addBOM whether or not to start with a BOM
     * @return {!Uint8Array}
     */
    function utf8ByteArrayFromString(string, length, addBOM) {
        var l = string.length, bytearray, i, n,
            j;
        // allocate a buffer and convert to a utf8 array
        bytearray = new Uint8Array(new ArrayBuffer(length));
        if (addBOM) {
            bytearray[0] = 0xef;
            bytearray[1] = 0xbb;
            bytearray[2] = 0xbf;
            j = 3;
        } else {
            j = 0;
        }
        for (i = 0; i < l; i += 1) {
            n = string.charCodeAt(i);
            if (n < 0x80) {
                bytearray[j] = n;
                j += 1;
            } else if (n < 0x800) {
                bytearray[j] = 0xc0 | (n >>>  6);
                bytearray[j + 1] = 0x80 | (n & 0x3f);
                j += 2;
            } else if (n <= 0xd700 || n >= 0xe000) {
                bytearray[j] = 0xe0 | ((n >>> 12) & 0x0f);
                bytearray[j + 1] = 0x80 | ((n >>>  6) & 0x3f);
                bytearray[j + 2] = 0x80 |  (n         & 0x3f);
                j += 3;
            } else { // surrogate pair
                i += 1;
                n = (((n - 0xd800) << 10) | (string.charCodeAt(i) - 0xdc00))
                    + 0x10000;
                bytearray[j] = 0xf0 | (n >>> 18 & 0x07);
                bytearray[j + 1] = 0x80 | (n >>> 12 & 0x3f);
                bytearray[j + 2] = 0x80 | (n >>> 6 & 0x3f);
                bytearray[j + 3] = 0x80 | (n & 0x3f);
                j += 4;
            }
        }
        return bytearray;
    }
    /**
     * Convert UCS-2 string to UTF-8 array.
     * wishLength is the desired length, if it is 3 bytes longer than
     * forsee by the string data, a BOM is prepended.
     * @param {string} string
     * @param {(number|string)=} wishLength
     * @return {!Uint8Array|undefined}
     */
    function utf8ByteArrayFromXHRString(string, wishLength) {
        var addBOM = false,
            length = getUtf8LengthForString(string);
        if (typeof wishLength === "number") {
            if (wishLength !== length && wishLength !== length + 3) {
                // the desired length does not match the content of the string
                return undefined;
            }
            addBOM = length + 3 === wishLength;
            length = wishLength;
        }
        return utf8ByteArrayFromString(string, length, addBOM);
    }
    /**
     * @param {!string} string
     * @return {!Uint8Array}
     */
    function byteArrayFromString(string) {
        // ignore encoding for now
        var l = string.length,
            a = new Uint8Array(new ArrayBuffer(l)),
            i;
        for (i = 0; i < l; i += 1) {
            a[i] = string.charCodeAt(i) & 0xff;
        }
        return a;
    }
    /**
     * @param {!string} string
     * @param {!string} encoding
     * @return {!Uint8Array}
     */
    this.byteArrayFromString = function (string, encoding) {
        var result;
        if (encoding === "utf8") {
            result = utf8ByteArrayFromString(string,
                getUtf8LengthForString(string), false);
        } else {
            if (encoding !== "binary") {
                self.log("unknown encoding: " + encoding);
            }
            result = byteArrayFromString(string);
        }
        return result;
    };
    this.byteArrayToString = Runtime.byteArrayToString;

    /**
    * @param {!string} name
    * @return {*}
    */
    this.getVariable = Runtime.getVariable;


    /**
    * @param {!string} jsonstr
    * @return {*}
    */
    this.fromJson = Runtime.fromJson;
    /**
    * @param {*} anything
    * @return {!string}
    */
    this.toJson = Runtime.toJson;

    /**
     * @param {!string} msgOrCategory
     * @param {string=} msg
     * @return {undefined}
     */
    function log(msgOrCategory, msg) {
        var category;
        if (msg !== undefined) {
            category = msgOrCategory;
        } else {
            msg = msgOrCategory;
        }
        console.log(msg);
        if (self.enableAlerts && category === "alert") {
            alert(msg);
        }
    }

    /**
     * @param {!Array.<!number>} buffer
     * @return {!Uint8Array}
     */
    function arrayToUint8Array(buffer) {
        var l = buffer.length, i,
            a = new Uint8Array(new ArrayBuffer(l));
        for (i = 0; i < l; i += 1) {
            a[i] = buffer[i];
        }
        return a;
    }
    /**
     * Convert the text received by XHR to a byte array.
     * An XHR request can send a text as a response even though binary content
     * was requested. This text string should be converted to a byte array.
     * If the length of the text is equal to the reported length of the content
     * then each character becomes one byte.
     * If the length is different, which can happen on WebKit and Blink
     * browsers, the string should be converted while taking into account the
     * encoding. Currently, only utf8 is supported for this procedure.
     * @param {!XMLHttpRequest} xhr
     * @return {!Uint8Array}
     */
    function stringToBinaryWorkaround(xhr) {
        var cl, data;
        cl = xhr.getResponseHeader("Content-Length");
        if (cl) {
            cl = parseInt(cl, 10);
        }
        // If Content-Length was found and is a valid number that is not equal
        // to the length of the string, the byte array should be reconstructed
        // from the encoding.
        if (cl && cl !== xhr.responseText.length) {
            // The text is not simple ascii, so we assume it is utf8 and try to
            // reconstruct the text from that.
            data = utf8ByteArrayFromXHRString(xhr.responseText, cl);
        }
        if (data === undefined) {
            data = byteArrayFromString(xhr.responseText);
        }
        return data;
    }
    /**
     * @param {!string} path
     * @param {!string} encoding
     * @param {!XMLHttpRequest} xhr
     * @return {!{err:?string,data:(?string|?Uint8Array)}}
     */
    function handleXHRResult(path, encoding, xhr) {
        var r, d, a,
            /**@type{!Uint8Array|!string}*/
            data;
        if (xhr.status === 0 && !xhr.responseText) {
            // for local files there is no difference between missing
            // and empty files, so empty files are considered as errors
            r = {err: "File " + path + " is empty.", data: null};
        } else if (xhr.status === 200 || xhr.status === 0) {
            // report file
            if (xhr.response && typeof xhr.response !== "string") {
                // w3c compliant way http://www.w3.org/TR/XMLHttpRequest2/#the-response-attribute
                if (encoding === "binary") {
                    d = /**@type{!ArrayBuffer}*/(xhr.response);
                    data = new Uint8Array(d);
                } else {
                    data = String(xhr.response);
                }
            } else if (encoding === "binary") {
                if (xhr.responseBody !== null
                        && String(typeof VBArray) !== "undefined") {
                    // fallback for IE <= 10
                    a = (new VBArray(xhr.responseBody)).toArray();
                    data = arrayToUint8Array(a);
                } else {
                    data = stringToBinaryWorkaround(xhr);
                }
            } else {
                // if we just want text, it's simple
                data = xhr.responseText;
            }
            r = {err: null, data: data};
        } else {
            // report error
            r = {err: xhr.responseText || xhr.statusText, data: null};
        }
        return r;
    }
    /**
     * @param {!string} path
     * @param {!string} encoding
     * @param {!boolean} async
     * @return {!XMLHttpRequest}
     */
    function createXHR(path, encoding, async) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', path, async);
        if (xhr.overrideMimeType) {
            if (encoding !== "binary") {
                xhr.overrideMimeType("text/plain; charset=" + encoding);
            } else {
                xhr.overrideMimeType("text/plain; charset=x-user-defined");
            }
        }
        return xhr;
    }
    /**
     * Read the contents of a file. Returns the result via a callback. If the
     * encoding is 'binary', the result is returned as a Uint8Array,
     * otherwise, it is returned as a string.
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @param {!function(?string,?(string|Uint8Array)):undefined} callback
     * @return {undefined}
     */
    function readFile(path, encoding, callback) {
        var xhr = createXHR(path, encoding, true);
        function handleResult() {
            var r;
            if (xhr.readyState === 4) {
                r = handleXHRResult(path, encoding, xhr);
                callback(r.err, r.data);
            }
        }
        xhr.onreadystatechange = handleResult;
        try {
            xhr.send(null);
        } catch (/**@type{!Error}*/e) {
            callback(e.message, null);
        }
    }
    /**
     * @param {!string} path
     * @param {!number} offset
     * @param {!number} length
     * @param {!function(?string,?Uint8Array):undefined} callback
     * @return {undefined}
     */
    function read(path, offset, length, callback) {
        readFile(path, "binary", function (err, result) {
            var r = null;
            if (result) {
                if (typeof result === "string") {
                    throw "This should not happen.";
                }
                r = /**@type{!Uint8Array}*/(result.subarray(offset,
                                                            offset + length));
            }
            callback(err, r);
        });
    }
    /**
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @return {!string|!Uint8Array}
     */
    function readFileSync(path, encoding) {
        var xhr = createXHR(path, encoding, false),
            r;
        try {
            xhr.send(null);
            r = handleXHRResult(path, encoding, xhr);
            if (r.err) {
                throw r.err;
            }
            if (r.data === null) {
                throw "No data read from " + path + ".";
            }
        } catch (/**@type{!Error}*/e) {
            throw e;
        }
        return r.data;
    }
    /**
     * @param {!string} path
     * @param {!Uint8Array} data
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    function writeFile(path, data, callback) {
        var xhr = new XMLHttpRequest(),
            /**@type{!string|!ArrayBuffer}*/
            d;
        function handleResult() {
            if (xhr.readyState === 4) {
                if (xhr.status === 0 && !xhr.responseText) {
                    // for local files there is no difference between missing
                    // and empty files, so empty files are considered as errors
                    callback("File " + path + " is empty.");
                } else if ((xhr.status >= 200 && xhr.status < 300) ||
                           xhr.status === 0) {
                    // report success
                    callback(null);
                } else {
                    // report error
                    callback("Status " + String(xhr.status) + ": " +
                            xhr.responseText || xhr.statusText);
                }
            }
        }
        xhr.open('PUT', path, true);
        xhr.onreadystatechange = handleResult;
        // ArrayBufferView will have an ArrayBuffer property, in WebKit, XHR
        // can send() an ArrayBuffer, In Firefox, one must use sendAsBinary with
        // a string
        if (data.buffer && !xhr.sendAsBinary) {
            d = data.buffer; // webkit supports sending an ArrayBuffer
        } else {
            // encode into a string, this works in FireFox >= 3
            d = self.byteArrayToString(data, "binary");
        }
        try {
            if (xhr.sendAsBinary) {
                xhr.sendAsBinary(d);
            } else {
                xhr.send(d);
            }
        } catch (/**@type{!Error}*/e) {
            self.log("HUH? " + e + " " + data);
            callback(e.message);
        }
    }
    /**
     * @param {!string} path
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    function deleteFile(path, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('DELETE', path, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status < 200 && xhr.status >= 300) {
                    callback(xhr.responseText);
                } else {
                    callback(null);
                }
            }
        };
        xhr.send(null);
    }
    /**
     * @param {!string} path
     * @param {!function(?string,?Document):undefined} callback
     * @return {undefined}
     */
    function loadXML(path, callback) {
        var xhr = new XMLHttpRequest();
        function handleResult() {
            if (xhr.readyState === 4) {
                if (xhr.status === 0 && !xhr.responseText) {
                    callback("File " + path + " is empty.", null);
                } else if (xhr.status === 200 || xhr.status === 0) {
                    // report file
                    callback(null, xhr.responseXML);
                } else {
                    // report error
                    callback(xhr.responseText, null);
                }
            }
        }
        xhr.open("GET", path, true);
        if (xhr.overrideMimeType) {
            xhr.overrideMimeType("text/xml");
        }
        xhr.onreadystatechange = handleResult;
        try {
            xhr.send(null);
        } catch (/**@type{!Error}*/e) {
            callback(e.message, null);
        }
    }
    this.readFile = readFile;
    this.read = read;
    this.readFileSync = readFileSync;
    this.writeFile = writeFile;
    this.deleteFile = deleteFile;
    this.loadXML = loadXML;
    this.log = log;
    this.enableAlerts = true;
    this.assert = Runtime.assert;
    /**
     * @param {!function():undefined} f
     * @param {!number} msec
     * @return {!number}
     */
    this.setTimeout = function (f, msec) {
        return setTimeout(function () {
            f();
        }, msec);
    };
    /**
     * @param {!number} timeoutID
     * @return {undefined}
     */
    this.clearTimeout = function (timeoutID) {
        clearTimeout(timeoutID);
    };
    /**
     * @return {!Array.<!string>}
     */
    this.libraryPaths = function () {
        return ["lib"]; // TODO: find a good solution
                                       // probably let html app specify it
    };
    /*jslint emptyblock: true*/
    this.setCurrentDirectory = function () {
    };
    /*jslint emptyblock: false*/
    /**
     * @return {!string}
     */
    this.currentDirectory = function () {
        return "";
    };
    this.type = function () {
        return "BrowserRuntime";
    };
    this.getDOMImplementation = function () {
        return window.document.implementation;
    };
    /**
     * @param {!string} xml
     * @return {?Document}
     */
    this.parseXML = function (xml) {
        var parser = new DOMParser();
        return parser.parseFromString(xml, "text/xml");
    };
    /**
     * @param {!number} exitCode
     */
    this.exit = function (exitCode) {
        log("Calling exit with code " + String(exitCode) +
                ", but exit() is not implemented.");
    };
    /**
     * @return {!Window}
     */
    this.getWindow = function () {
        return window;
    };
    /**
     * @param {!function():undefined} callback
     * @return {!number}
     */
    this.requestAnimationFrame = function (callback) {
        var rAF = window.requestAnimationFrame
            || window.webkitRequestAnimationFrame
            || window.mozRequestAnimationFrame
            || window.msRequestAnimationFrame,
            requestId = 0;

        if (rAF) {
            // This code is to satisfy Closure, which expects
            // that the `this` of rAF should be window.
            rAF.bind(window);
            requestId = /**@type{function(!function():undefined):!number}*/(rAF)(callback);
        } else {
            return setTimeout(callback, 15);
        }

        return requestId;
    };
    /**
     * @param {!number} requestId
     * @return {undefined}
     */
    this.cancelAnimationFrame = function (requestId) {
        var cAF = window.cancelAnimationFrame
            || window.webkitCancelAnimationFrame
            || window.mozCancelAnimationFrame
            || window.msCancelAnimationFrame;

        if (cAF) {
            cAF.bind(window);
            /**@type{function(!number)}*/(cAF)(requestId);
        } else {
            clearTimeout(requestId);
        }
    };
}

/**
 * @constructor
 * @implements {Runtime}
 */
function NodeJSRuntime() {
    "use strict";
    var self = this,
        fs = require('fs'),
        pathmod = require('path'),
        /**@type{!string}*/
        currentDirectory = "",
        /**@type{!DOMParser}*/
        parser,
        domImplementation;

    /**
     * @param {!Buffer} buffer
     * @return {!Uint8Array}
     */
    function bufferToUint8Array(buffer) {
        var l = buffer.length, i,
            a = new Uint8Array(new ArrayBuffer(l));
        for (i = 0; i < l; i += 1) {
            a[i] = buffer[i];
        }
        return a;
    }
    /**
     * @param {!string} string
     * @param {!string} encoding
     * @return {!Uint8Array}
     */
    this.byteArrayFromString = function (string, encoding) {
        var buf = new Buffer(string, encoding), i, l = buf.length,
            a = new Uint8Array(new ArrayBuffer(l));
        for (i = 0; i < l; i += 1) {
            a[i] = buf[i];
        }
        return a;
    };

    this.byteArrayToString = Runtime.byteArrayToString;

    /**
    * @param {!string} name
    * @return {*}
    */
    this.getVariable = Runtime.getVariable;

    /**
    * @param {!string} jsonstr
    * @return {*}
    */
    this.fromJson = Runtime.fromJson;
    /**
    * @param {*} anything
    * @return {!string}
    */
    this.toJson = Runtime.toJson;

    /**
     * Read the contents of a file. Returns the result via a callback. If the
     * encoding is 'binary', the result is returned as a Uint8Array,
     * otherwise, it is returned as a string.
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @param {!function(?string,?(string|Uint8Array)):undefined} callback
     * @return {undefined}
     */
    function readFile(path, encoding, callback) {
        /**
         * @param {?string} err
         * @param {?Buffer|?string} data
         * @return {undefined}
         */
        function convert(err, data) {
            if (err) {
                return callback(err, null);
            }
            if (!data) {
                return callback("No data for " + path + ".", null);
            }
            var d;
            if (typeof data === "string") {
                d = /**@type{!string}*/(data);
                return callback(err, d);
            }
            d = /**@type{!Buffer}*/(data);
            callback(err, bufferToUint8Array(d));
        }
        path = pathmod.resolve(currentDirectory, path);
        if (encoding !== "binary") {
            fs.readFile(path, encoding, convert);
        } else {
            fs.readFile(path, null, convert);
        }
    }
    this.readFile = readFile;
    /**
     * @param {!string} path
     * @param {!function(?string,?Document):undefined} callback
     * @return {undefined}
     */
    function loadXML(path, callback) {
        readFile(path, "utf-8", function (err, data) {
            if (err) {
                return callback(err, null);
            }
            if (!data) {
                return callback("No data for " + path + ".", null);
            }
            var d = /**@type{!string}*/(data);
            callback(null, self.parseXML(d));
        });
    }
    this.loadXML = loadXML;
    /**
     * @param {!string} path
     * @param {!Uint8Array} data
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    this.writeFile = function (path, data, callback) {
        var buf = new Buffer(data);
        path = pathmod.resolve(currentDirectory, path);
        fs.writeFile(path, buf, "binary", function (err) {
            callback(err || null);
        });
    };
    /**
     * @param {!string} path
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    this.deleteFile = function (path, callback) {
        path = pathmod.resolve(currentDirectory, path);
        fs.unlink(path, callback);
    };
    /**
     * @param {!string} path
     * @param {!number} offset
     * @param {!number} length
     * @param {!function(?string,?Uint8Array):undefined} callback
     * @return {undefined}
     */
    this.read = function (path, offset, length, callback) {
        path = pathmod.resolve(currentDirectory, path);
        fs.open(path, "r+", 666, function (err, fd) {
            if (err) {
                callback(err, null);
                return;
            }
            var buffer = new Buffer(length);
            fs.read(fd, buffer, 0, length, offset, function (err) {
                fs.close(fd);
                callback(err, bufferToUint8Array(buffer));
            });
        });
    };
    /**
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @return {!string|!Uint8Array}
     */
    this.readFileSync = function (path, encoding) {
        var s,
            enc = (encoding === "binary") ? null : encoding,
            r = fs.readFileSync(path, enc);
        if (r === null) {
            throw "File " + path + " could not be read.";
        }
        if (encoding === "binary") {
            s = /**@type{!Buffer}*/(r);
            s = bufferToUint8Array(s);
        } else {
            s = /**@type{!string}*/(r);
        }
        return s;
    };
    /**
     * @param {!string} msgOrCategory
     * @param {string=} msg
     * @return {undefined}
     */
    function log(msgOrCategory, msg) {
        var category;
        if (msg !== undefined) {
            category = msgOrCategory;
        } else {
            msg = msgOrCategory;
        }
        if (category === "alert") {
            process.stderr.write("\n!!!!! ALERT !!!!!" + '\n');
        }
        process.stderr.write(msg + '\n');
        if (category === "alert") {
            process.stderr.write("!!!!! ALERT !!!!!" + '\n');
        }
    }
    this.log = log;

    this.assert = Runtime.assert;

    /**
     * @param {!function():undefined} f
     * @param {!number} msec
     * @return {!number}
     */
    this.setTimeout = function (f, msec) {
        return setTimeout(function () {
            f();
        }, msec);
    };
    /**
     * @param {!number} timeoutID
     * @return {undefined}
     */
    this.clearTimeout = function (timeoutID) {
        clearTimeout(timeoutID);
    };
    /**
     * @return {!Array.<!string>}
     */
    this.libraryPaths = function () {
        return [__dirname];
    };
    /**
     * @param {!string} dir
     * @return {undefined}
     */
    this.setCurrentDirectory = function (dir) {
        currentDirectory = dir;
    };
    this.currentDirectory = function () {
        return currentDirectory;
    };
    this.type = function () {
        return "NodeJSRuntime";
    };
    this.getDOMImplementation = function () {
        return domImplementation;
    };
    /**
     * @param {!string} xml
     * @return {?Document}
     */
    this.parseXML = function (xml) {
        return parser.parseFromString(xml, "text/xml");
    };
    this.exit = process.exit;
    this.getWindow = function () {
        return null;
    };
    /**
     * @param {!function():undefined} callback
     * @return {!number}
     */
    this.requestAnimationFrame = function (callback) {
        return setTimeout(callback, 15);
    };
    /**
     * @param {!number} requestId
     * @return {undefined}
     */
    this.cancelAnimationFrame = function (requestId) {
        clearTimeout(requestId);
    };
    function init() {
        var /**@type{function(new:DOMParser)}*/
            DOMParser = require('xmldom').DOMParser;
        parser = new DOMParser();
        domImplementation = self.parseXML("<a/>").implementation;
    }
    init();
}

/**
 * @constructor
 * @implements {Runtime}
 */
function RhinoRuntime() {
    "use strict";
    var self = this,
        Packages = {},
        dom = Packages.javax.xml.parsers.DocumentBuilderFactory.newInstance(),
        /**@type{!Packages.javax.xml.parsers.DocumentBuilder}*/
        builder,
        entityresolver,
        /**@type{!string}*/
        currentDirectory = "";
    dom.setValidating(false);
    dom.setNamespaceAware(true);
    dom.setExpandEntityReferences(false);
    dom.setSchema(null);
    /*jslint unparam: true */
    entityresolver = Packages.org.xml.sax.EntityResolver({
        /**
         * @param {!string} publicId
         * @param {!string} systemId
         * @return {!Packages.org.xml.sax.InputSource}
         */
        resolveEntity: function (publicId, systemId) {
            var file;
            /**
             * @param {!string} path
             * @return {!Packages.org.xml.sax.InputSource}
             */
            function open(path) {
                var reader = new Packages.java.io.FileReader(path),
                    source = new Packages.org.xml.sax.InputSource(reader);
                return source;
            }
            file = systemId;
            //file = /[^\/]*$/.exec(systemId); // what should this do?
            return open(file);
        }
    });
    /*jslint unparam: false */
    //dom.setEntityResolver(entityresolver);
    builder = dom.newDocumentBuilder();
    builder.setEntityResolver(entityresolver);

    /*jslint unparam: true*/
    /**
     * @param {!string} string
     * @param {!string} encoding
     * @return {!Uint8Array}
     */
    this.byteArrayFromString = function (string, encoding) {
        // ignore encoding for now
        var i,
            l = string.length,
            a = new Uint8Array(new ArrayBuffer(l));
        for (i = 0; i < l; i += 1) {
            a[i] = string.charCodeAt(i) & 0xff;
        }
        return a;
    };
    /*jslint unparam: false*/
    this.byteArrayToString = Runtime.byteArrayToString;

    /**
    * @param {!string} name
    * @return {*}
    */
    this.getVariable = Runtime.getVariable;

    /**
    * @param {!string} jsonstr
    * @return {*}
    */
    this.fromJson = Runtime.fromJson;
    /**
    * @param {*} anything
    * @return {!string}
    */
    this.toJson = Runtime.toJson;

    /**
     * @param {!string} path
     * @param {!function(?string,?Document):undefined} callback
     * @return {undefined}
     */
    function loadXML(path, callback) {
        var file = new Packages.java.io.File(path),
            xmlDocument = null;
        try {
            xmlDocument = builder.parse(file);
        } catch (/**@type{!string}*/err) {
            print(err);
            return callback(err, null);
        }
        callback(null, xmlDocument);
    }
    /**
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @param {!function(?string,?(string|Uint8Array)):undefined} callback
     * @return {undefined}
     */
    function runtimeReadFile(path, encoding, callback) {
        if (currentDirectory) {
            path = currentDirectory + "/" + path;
        }
        var file = new Packages.java.io.File(path),
            data,
            // read binary, seems hacky but works
            rhinoencoding = (encoding === "binary") ? "latin1" : encoding;
        if (!file.isFile()) {
            callback(path + " is not a file.", null);
        } else {
            data = readFile(path, rhinoencoding);
            if (data && encoding === "binary") {
                data = self.byteArrayFromString(data, "binary");
            }
            callback(null, data);
        }
    }
    /**
     * @param {!string} path
     * @param {!string} encoding
     * @return {?string}
     */
    function runtimeReadFileSync(path, encoding) {
        var file = new Packages.java.io.File(path);
        if (!file.isFile()) {
            return null;
        }
        if (encoding === "binary") {
            encoding = "latin1"; // read binary, seems hacky but works
        }
        return readFile(path, encoding);
    }
    this.loadXML = loadXML;
    this.readFile = runtimeReadFile;
    /**
     * @param {!string} path
     * @param {!Uint8Array} data
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    this.writeFile = function (path, data, callback) {
        if (currentDirectory) {
            path = currentDirectory + "/" + path;
        }
        var out = new Packages.java.io.FileOutputStream(path),
            i,
            l = data.length;
        for (i = 0; i < l; i += 1) {
            out.write(data[i]);
        }
        out.close();
        callback(null);
    };
    /**
     * @param {!string} path
     * @param {!function(?string):undefined} callback
     * @return {undefined}
     */
    this.deleteFile = function (path, callback) {
        if (currentDirectory) {
            path = currentDirectory + "/" + path;
        }
        var file = new Packages.java.io.File(path),
            otherPath = path + Math.random(),
            other = new Packages.java.io.File(otherPath);
        // 'delete' cannot be used with closure compiler, so we use a workaround
        if (file.rename(other)) {
            other.deleteOnExit();
            callback(null);
        } else {
            callback("Could not delete " + path);
        }
    };
    /**
     * @param {!string} path
     * @param {!number} offset
     * @param {!number} length
     * @param {!function(?string,?Uint8Array):undefined} callback
     * @return {undefined}
     */
    this.read = function (path, offset, length, callback) {
        // TODO: adapt to read only a part instead of the whole file
        if (currentDirectory) {
            path = currentDirectory + "/" + path;
        }
        var data = runtimeReadFileSync(path, "binary");
        if (data) {
            callback(null, this.byteArrayFromString(
                data.substring(offset, offset + length),
                "binary"
            ));
        } else {
            callback("Cannot read " + path, null);
        }
    };
    /**
     * @param {!string} path
     * @param {!string} encoding text encoding or 'binary'
     * @return {!string}
     */
    this.readFileSync = function (path, encoding) {
        if (!encoding) {
            return "";
        }
        var s = readFile(path, encoding);
        if (s === null) {
            throw "File could not be read.";
        }
        return s;
    };
    /**
     * @param {!string} msgOrCategory
     * @param {string=} msg
     * @return {undefined}
     */
    function log(msgOrCategory, msg) {
        var category;
        if (msg !== undefined) {
            category = msgOrCategory;
        } else {
            msg = msgOrCategory;
        }
        if (category === "alert") {
            print("\n!!!!! ALERT !!!!!");
        }
        print(msg);
        if (category === "alert") {
            print("!!!!! ALERT !!!!!");
        }
    }
    this.log = log;

    this.assert = Runtime.assert;

    /**
     * @param {!function():undefined} f
     * @return {!number}
     */
    this.setTimeout = function (f) {
        f();
        return 0;
    };
    /*jslint emptyblock: true */
    /**
     * @return {undefined}
     */
    this.clearTimeout = function () {
    };
    /*jslint emptyblock: false */
    /**
     * @return {!Array.<!string>}
     */
    this.libraryPaths = function () {
        return ["lib"];
    };
    /**
     * @param {!string} dir
     */
    this.setCurrentDirectory = function (dir) {
        currentDirectory = dir;
    };
    this.currentDirectory = function () {
        return currentDirectory;
    };
    this.type = function () {
        return "RhinoRuntime";
    };
    this.getDOMImplementation = function () {
        return builder.getDOMImplementation();
    };
    /**
     * @param {!string} xml
     * @return {?Document}
     */
    this.parseXML = function (xml) {
        var reader = new Packages.java.io.StringReader(xml),
            source = new Packages.org.xml.sax.InputSource(reader);
        return builder.parse(source);
    };
    this.exit = quit;
    this.getWindow = function () {
        return null;
    };
    /**
     * @param {!function():undefined} callback
     * @return {!number}
     */
    this.requestAnimationFrame = function (callback) {
        callback();
        return 0;
    };
    /*jslint emptyblock: true */
    /**
     * @return {undefined}
     */
    this.cancelAnimationFrame = function () {
    };
    /*jslint emptyblock: false */
}

/**
 * @return {!Runtime}
 */
Runtime.create = function create() {
    "use strict";
    var /**@type{!Runtime}*/
        result;
    if (String(typeof window) !== "undefined") {
        result = new BrowserRuntime();
    } else if (String(typeof require) !== "undefined") {
        result = new NodeJSRuntime();
    } else {
        result = new RhinoRuntime();
    }
    return result;
};

/**
 * @const
 * @type {!Runtime}
 */
var runtime = Runtime.create();

/**
 * @namespace The core package.
 */
var core = {};
/**
 * @namespace The gui package.
 */
var gui = {};
/**
 * @namespace The xmldom package.
 */
var xmldom = {};
/**
 * @namespace The ODF package.
 */
var odf = {};
/**
 * @namespace The editing operations
 */
var ops = {};

/**
 * @namespace The webodf namespace
 */
var webodf = {};

(function () {
    "use strict";
    /**
     * @return {string}
     */
    function getWebODFVersion() {
        var version = (String(typeof webodf_version) !== "undefined"
            ? webodf_version
            : "From Source"
        );
        return version;
    }
    /**
     * @const
     * @type {!string}
     */
    webodf.Version = getWebODFVersion();
}());

/*jslint sloppy: true*/
(function () {
    /**
     * @param {string} dir  Needs to be non-empty, use "." to denote same directory
     * @param {!Object.<string,!{dir:string, deps:!Array.<string>}>} dependencies
     * @param {!boolean=} expectFail  Set to true if it is not known if there is a manifest
     */
    function loadDependenciesFromManifest(dir, dependencies, expectFail) {
        "use strict";
        var path = dir + "/manifest.json",
            content,
            list,
            manifest,
            /**@type{string}*/
            m;
        runtime.log("Loading manifest: "+path);
        try {
            content = runtime.readFileSync(path, "utf-8");
        } catch (/**@type{string}*/e) {
            if (expectFail) {
                runtime.log("No loadable manifest found.");
            } else {
                console.log(String(e));
                throw e;
            }
            return;
        }
        list = JSON.parse(/**@type{string}*/(content));
        manifest = /**@type{!Object.<!Array.<string>>}*/(list);
        for (m in manifest) {
            if (manifest.hasOwnProperty(m)) {
                dependencies[m] = {dir: dir, deps: manifest[m]};
            }
        }
    }
    /**
     * @return {!Object.<string,!{dir:string, deps:!Array.<string>}>}
     */
    function loadDependenciesFromManifests() {
        "use strict";
        var /**@type{!Object.<string,!{dir:string, deps:!Array.<string>}>}*/
            dependencies = [],
            paths = runtime.libraryPaths(),
            i;
        // Convenience: try to load any possible manifest in the current directory
        // but only if it not also included in the library paths
        if (runtime.currentDirectory() && paths.indexOf(runtime.currentDirectory()) === -1) {
            // there is no need to have a manifest there, so allow loading to fail
            loadDependenciesFromManifest(runtime.currentDirectory(), dependencies, true);
        }
        for (i = 0; i < paths.length; i += 1) {
            loadDependenciesFromManifest(paths[i], dependencies);
        }
        return dependencies;
    }
    /**
     * @param {string} dir
     * @param {string} className
     * @return {string}
     */
    function getPath(dir, className) {
        "use strict";
        return dir + "/" + className.replace(".", "/") + ".js";
    }
    /**
     * Create a list of required classes from a list of desired classes.
     * A new list is created that lists all classes that still need to be loaded
     * to load the list of desired classes.
     * @param {!Array.<string>} classNames
     * @param {!Object.<string,!{dir:string, deps:!Array.<string>}>} dependencies
     * @param {function(string):boolean} isDefined
     * @return {!Array.<string>}
     */
    function getLoadList(classNames, dependencies, isDefined) {
        "use strict";
        var loadList = [],
            stack = {},
            /**@type{!Object.<string,boolean>}*/
            visited = {};
        /**
         * @param {string} n
         */
        function visit(n) {
            if (visited[n] || isDefined(n)) {
                return;
            }
            if (stack[n]) {
                throw "Circular dependency detected for " + n + ".";
            }
            stack[n] = true;
            if (!dependencies[n]) {
                throw "Missing dependency information for class " + n + ".";
            }
            var d = dependencies[n], deps = d.deps, i, l = deps.length;
            for (i = 0; i < l; i += 1) {
                visit(deps[i]);
            }
            stack[n] = false;
            visited[n] = true;
            loadList.push(getPath(d.dir, n));
        }
        classNames.forEach(visit);
        return loadList;
    }
    /**
     * @param {string} path
     * @param {string} content
     * @return {string}
     */
    function addContent(path, content) {
        "use strict";
        content += "\n//# sourceURL=" + path;
        return content;
    }
    /**
     * @param {!Array.<string>} paths
     */
    function loadFiles(paths) {
        // this function is not strict, so eval can assign to globals
        var i,
            content;
        for (i = 0; i < paths.length; i += 1) {
            content = runtime.readFileSync(paths[i], "utf-8");
            content = addContent(paths[i], /**@type{string}*/(content));
            /*jslint evil: true*/
            eval(content);
            /*jslint evil: false*/
        }
    }
    /**
     * Load scripts by adding <script/> elements to the DOM.
     * The new script tags are added after the <script/> tag for runtime.js.
     * The scripts are added with async = false so that they are executed in the
     * right order. The scripts are executed when control returns to the browser
     * from the current stack.
     * If a callback is provided, it is executed after the last script has run.
     * @param {!Array.<string>} paths array with one or more script paths
     * @param {!Function=} callback
     */
    function loadFilesInBrowser(paths, callback) {
        "use strict";
        var e = document.currentScript || document.documentElement.lastChild,
            df = document.createDocumentFragment(),
            script,
            i;
        for (i = 0; i < paths.length; i += 1) {
            script = document.createElement("script");
            script.type = "text/javascript";
            script.charset = "utf-8";
            script.async = false; // execute the scripts in order
            script.setAttribute("src", paths[i]);
            df.appendChild(script);
        }
        if (callback) {
            script.onload = callback;
        }
        e.parentNode.insertBefore(df, e);
    }
    var /**@type{!Object.<string,!{dir:string, deps:!Array.<string>}>}*/
        dependencies,
        packages = {
            core: core,
            gui: gui,
            xmldom: xmldom,
            odf: odf,
            ops: ops
        };
    /**
     * Check if a class has been defined.
     * For class "core.sub.Name", this checks if there is an entry
     * packages.core.sub.Name.
     * @param {string} classname
     * @return {boolean}
     */
    function isDefined(classname) {
        "use strict";
        var parts = classname.split("."), i,
            /**@type{Object}*/
            p = packages,
            l = parts.length;
        for (i = 0; i < l; i += 1) {
            if (!p.hasOwnProperty(parts[i])) {
                return false;
            }
            p = /**@type{Object}*/(p[parts[i]]);
        }
        return true;
    }
    /**
     * @param {!Array.<string>} classnames
     * @param {function():undefined=} callback
     * @returns {undefined}
     */
    runtime.loadClasses = function (classnames, callback) {
        "use strict";
        if (IS_COMPILED_CODE || classnames.length === 0) {
            return callback && callback();
        }
        dependencies = dependencies || loadDependenciesFromManifests();
        classnames = getLoadList(classnames, dependencies, isDefined);
        if (classnames.length === 0) {
            return callback && callback();
        }
        if (runtime.type() === "BrowserRuntime" && callback) {
            loadFilesInBrowser(classnames, callback);
        } else {
            loadFiles(classnames);
            if (callback) {
                callback();
            }
        }
    };
    /**
     * @param {string} classname
     * @param {function():undefined=} callback
     * @return {undefined}
     * @export
     */
    runtime.loadClass = function (classname, callback) {
        "use strict";
        runtime.loadClasses([classname], callback);
    };
}());
/*jslint sloppy: false*/

(function () {
    "use strict";
    /**
     * @param {!string} string
     * @return {!string}
     */
    var translator = function (string) {
        return string;
    };
    /*jslint emptyblock: false*/

    /**
     * Translator function. Takes the original string
     * and returns the translation if it exists, else
     * returns the original.
     * @param {!string} original
     * @return {!string}
     */
    function tr(original) {
        var result = translator(original);
        if (!result || (String(typeof result) !== "string")) {
            return original;
        }
        return result;
    }

    /**
     * Gets the custom translator function
     * @return {!function(!string):!string}
     */
    runtime.getTranslator = function () {
        return translator;
    };
    /**
     * Set an external translator function
     * @param {!function(!string):!string} translatorFunction
     * @return {undefined}
     */
    runtime.setTranslator = function (translatorFunction) {
        translator = translatorFunction;
    };
    /**
     * @param {string} original
     * @return {string}
     */
    runtime.tr = tr;
}());

/*jslint sloppy: true*/
(function (args) {
    if (args) {
        args = Array.prototype.slice.call(/**@type{{length:number}}*/(args));
    } else {
        args = [];
    }

    /*jslint unvar: true, defined: true*/
    /**
     * @param {!Array.<!string>} argv
     */
    function run(argv) {
        if (!argv.length) {
            return;
        }
        var script = argv[0];
        runtime.readFile(script, "utf8", function (err, code) {
            var path = "",
                pathEndIndex = script.lastIndexOf("/"),
                codestring = /**@type{string}*/(code);

            if (pathEndIndex !== -1) {
                path = script.substring(0, pathEndIndex);
            } else {
                path = ".";
            }
            runtime.setCurrentDirectory(path);
            function inner_run() {
                var script, path, args, argv, result; // hide variables
                // execute script and make arguments available via argv
                /*jslint evil: true*/
                result = /**@type{!number}*/(eval(codestring));
                /*jslint evil: false*/
                if (result) {
                    runtime.exit(result);
                }
                return;
            }
            if (err) {
                runtime.log(err);
                runtime.exit(1);
            } else if (codestring === null) {
                runtime.log("No code found for " + script);
                runtime.exit(1);
            } else {
                // run the script with arguments bound to arguments parameter
                inner_run.apply(null, argv);
            }
        });
    }
    /*jslint unvar: false, defined: false*/
    // if rhino or node.js, run the scripts provided as arguments
    if (runtime.type() === "NodeJSRuntime") {
        run(process.argv.slice(2));
    } else if (runtime.type() === "RhinoRuntime") {
        run(args);
    } else {
        run(args.slice(1));
    }
}(String(typeof arguments) !== "undefined" && arguments));

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Async.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/

(function() {
    "use strict";

    /**
     * @return {!{forEach:!function(!Array.<*>,!function(*, !function(!string):undefined):undefined,!function(?string)):undefined, destroyAll:function(!Array.<!function(!function(!Error=))>,!function(!Error=)):undefined}}
     */
    function createASyncSingleton() {
        /**
         * @param {!Array.<*>} items
         * @param {!function(*, !function(!string):undefined):undefined} f
         * @param {!function(?string)} callback
         * @return {undefined}
         */
        function forEach(items, f, callback) {
            var i, l = items.length,
                /**@type{!number}*/
                itemsDone = 0;
            /**
             * @param {?string} err
             * @return {undefined}
             */
            function end(err) {
                if (itemsDone !== l) {
                    if (err) {
                        itemsDone = l;
                        callback(err);
                    } else {
                        itemsDone += 1;
                        if (itemsDone === l) {
                            callback(null);
                        }
                    }
                }
            }
            for (i = 0; i < l; i += 1) {
                f(items[i], end);
            }
        }

        /**
         * @param {!Array.<!function(!function(!Error=))>} items
         * @param {!function(!Error=)} callback
         * @return {undefined}
         */
        function destroyAll(items, callback) {
            /**
             * @param {!number} itemIndex
             * @param {!Error|undefined} err
             * @return {undefined}
             */
            function destroy(itemIndex, err) {
                if (err) {
                    callback(err);
                } else {
                    if (itemIndex < items.length) {
                        items[itemIndex](function (err) { destroy(itemIndex + 1, err); });
                    } else {
                        callback();
                    }
                }
            }
            destroy(0, undefined);
        }

        return {
            forEach: forEach,
            destroyAll: destroyAll
        };
    }

    /**
     * Wrapper for Async functions
     * @const
     * @type {!{forEach:!function(!Array.<*>,!function(*, !function(!string):undefined):undefined,!function(?string)):undefined, destroyAll:function(!Array.<!function(!function(!Error=))>,!function(!Error=)):undefined}}
     */
    core.Async = createASyncSingleton();
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Base64.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, runtime, ArrayBuffer, Uint8Array*/
/*jslint bitwise: true, regexp: true, plusplus: true*/

/*
 * $Id: base64.js,v 0.9 2009/03/01 20:51:18 dankogai Exp dankogai $
 */
/**
 * @return {function(new:core.Base64):?}
 */
function makeBase64() {
    "use strict";
    /**
     * @param {!string} bin
     * @return {!Object.<!string,!number>}
     */
    function makeB64tab(bin) {
        var /**@type{!Object.<!string,!number>}*/
            t = {},
            i, l;
        for (i = 0, l = bin.length; i < l; i += 1) {
            t[bin.charAt(i)] = i;
        }
        return t;
    }
    var /**@const@type{!string}*/
        b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        /**@const@type{!Object.<!string,!number>}*/
        b64tab = makeB64tab(b64chars),
        /**@type{!function(!string):!string}*/
        convertUTF16StringToBase64,
        /**@type{!function(!string):!string}*/
        convertBase64ToUTF16String,
        /**@type{?Window}*/
        window = runtime.getWindow(),
        /**@type{!function(!string):!string}*/
        btoa,
        /**@type{!function(!string):!string}*/
        atob;

    /**
     * @param {!string} s
     * @return {!Uint8Array}
     */
    function stringToArray(s) {
        var i,
            l = s.length,
            a = new Uint8Array(new ArrayBuffer(l));
        for (i = 0; i < l; i += 1) {
            a[i] = s.charCodeAt(i) & 0xff;
        }
        return a;
    }

    /**
     * @param {!Uint8Array} bin
     * @return {!string}
     */
    function convertUTF8ArrayToBase64(bin) {
        var /**@type{!number}*/
            n,
            /**@type{!string}*/
            b64 = "",
            i,
            l = bin.length - 2;
        for (i = 0; i < l; i += 3) {
            n = (bin[i] << 16) | (bin[i + 1] << 8) | bin[i + 2];
            b64 += /**@type{!string}*/(b64chars[n >>> 18]);
            b64 += /**@type{!string}*/(b64chars[(n >>> 12) & 63]);
            b64 += /**@type{!string}*/(b64chars[(n >>>  6) & 63]);
            b64 += /**@type{!string}*/(b64chars[n          & 63]);
        }
        if (i === l + 1) { // 1 byte left
            n = bin[i] << 4;
            b64 += /**@type{!string}*/(b64chars[n >>> 6]);
            b64 += /**@type{!string}*/(b64chars[n & 63]);
            b64 += "==";
        } else if (i === l) { // 2 bytes left
            n = (bin[i] << 10) | (bin[i + 1] << 2);
            b64 += /**@type{!string}*/(b64chars[n >>> 12]);
            b64 += /**@type{!string}*/(b64chars[(n >>> 6) & 63]);
            b64 += /**@type{!string}*/(b64chars[n & 63]);
            b64 += "=";
        }
        return b64;
    }
    /**
     * @param {!string} b64
     * @return {!Uint8Array}
     */
    function convertBase64ToUTF8Array(b64) {
        b64 = b64.replace(/[^A-Za-z0-9+\/]+/g, '');
        var l = b64.length,
            bin = new Uint8Array(new ArrayBuffer(3 * l)),
            padlen = b64.length % 4,
            o = 0,
            i,
            n,
            a = [0, 0, 2, 1];
        for (i = 0; i < l; i += 4) {
            n = ((b64tab[b64.charAt(i)]     || 0) << 18) |
                ((b64tab[b64.charAt(i + 1)] || 0) << 12) |
                ((b64tab[b64.charAt(i + 2)] || 0) <<  6) |
                ((b64tab[b64.charAt(i + 3)] || 0));
            bin[o]     =  n >> 16;
            bin[o + 1] = (n >> 8) & 0xff;
            bin[o + 2] =  n       & 0xff;
            o += 3;
        }
        l = 3 * l - a[padlen];
        return bin.subarray(0, l);
    }
    /**
     * @param {!Uint8Array} uni
     * @return {!Uint8Array}
     */
    function convertUTF16ArrayToUTF8Array(uni) {
        var i, n,
            l = uni.length,
            o = 0,
            bin = new Uint8Array(new ArrayBuffer(3 * l));
        for (i = 0; i < l; i += 1) {
            n = /**@type{!number}*/(uni[i]);
            if (n < 0x80) {
                bin[o++] = n;
            } else if (n < 0x800) {
                bin[o++] = 0xc0 | (n >>>  6);
                bin[o++] = 0x80 | (n & 0x3f);
            } else {
                bin[o++] = 0xe0 | ((n >>> 12) & 0x0f);
                bin[o++] = 0x80 | ((n >>>  6) & 0x3f);
                bin[o++] = 0x80 |  (n         & 0x3f);
            }
        }
        return bin.subarray(0, o);
    }
    /**
     * @param {!Uint8Array} bin
     * @return {!Uint8Array}
     */
    function convertUTF8ArrayToUTF16Array(bin) {
        var i, c0, c1, c2,
            l = bin.length,
            uni = new Uint8Array(new ArrayBuffer(l)),
            o = 0;
        for (i = 0; i < l; i += 1) {
            c0 = /**@type{!number}*/(bin[i]);
            if (c0 < 0x80) {
                uni[o++] = c0;
            } else {
                i += 1;
                c1 = /**@type{!number}*/(bin[i]);
                if (c0 < 0xe0) {
                    uni[o++] = ((c0 & 0x1f) << 6) | (c1 & 0x3f);
                } else {
                    i += 1;
                    c2 = /**@type{!number}*/(bin[i]);
                    uni[o++] = ((c0 & 0x0f) << 12) | ((c1 & 0x3f) << 6) |
                            (c2 & 0x3f);
                }
            }
        }
        return uni.subarray(0, o);
    }
    /**
     * @param {!string} bin
     * @return {!string}
     */
    function convertUTF8StringToBase64(bin) {
        return convertUTF8ArrayToBase64(stringToArray(bin));
    }
    /**
     * @param {!string} b64
     * @return {!string}
     */
    function convertBase64ToUTF8String(b64) {
        return String.fromCharCode.apply(String, convertBase64ToUTF8Array(b64));
    }
    /**
     * @param {!string} bin
     * @return {!Uint8Array}
     */
    function convertUTF8StringToUTF16Array(bin) {
        return convertUTF8ArrayToUTF16Array(stringToArray(bin));
    }
    /**
     * @param {!Uint8Array} bin
     * @return {!string}
     */
    function convertUTF8ArrayToUTF16String(bin) {
        // this conversion is done in chunks to avoid a stack overflow in
        // apply()
        var b = convertUTF8ArrayToUTF16Array(bin),
            r = "",
            i = 0,
            chunksize = 45000;
        while (i < b.length) {
            r += String.fromCharCode.apply(String, b.subarray(i, i + chunksize));
            i += chunksize;
        }
        return r;
    }
    /**
     * @param {!Array.<number>|!string} bin
     * @param {!number} i
     * @param {!number} end
     * @return {!string}
     */
    function convertUTF8StringToUTF16String_internal(bin, i, end) {
        var c0, c1, c2, j,
            str = "";
        for (j = i; j < end; j += 1) {
            c0 = bin.charCodeAt(j) & 0xff;
            if (c0 < 0x80) {
                str += String.fromCharCode(c0);
            } else {
                j += 1;
                c1 = bin.charCodeAt(j) & 0xff;
                if (c0 < 0xe0) {
                    str += String.fromCharCode(((c0 & 0x1f) << 6) |
                        (c1 & 0x3f));
                } else {
                    j += 1;
                    c2 = bin.charCodeAt(j) & 0xff;
                    str += String.fromCharCode(((c0 & 0x0f) << 12) |
                            ((c1 & 0x3f) << 6) | (c2 & 0x3f));
                }
            }
        }
        return str;
    }

    /**
     * Convert a utf-8 array into a utf-16 string.
     * The input array is treated as a list of values between 0 and 255.
     * This function works with a callback and splits the work up in parts
     * between which it yields to the main thread.
     * After each part the progress is reported with the callback function that
     * also passes a booleant that indicates if the job has finished.
     * If the conversion should stop, the callback should return false.
     *
     * @param {!Array.<number>|!string} bin
     * @param {!function(!string, boolean):boolean} callback
     * @return {undefined}
     */
    function convertUTF8StringToUTF16String(bin, callback) {
        var /**@const@type{!number}*/
            partsize = 100000,
            /**@type{!string}*/
            str = "",
            /**@type{!number}*/
            pos = 0;
        if (bin.length < partsize) {
            callback(convertUTF8StringToUTF16String_internal(bin, 0,
                    bin.length), true);
            return;
        }
        // make a local copy if the input is a string, to avoid modification
        if (typeof bin !== "string") {
            bin = bin.slice();
        }
        function f() {
            var end = pos + partsize;
            if (end > bin.length) {
                end = bin.length;
            }
            str += convertUTF8StringToUTF16String_internal(bin, pos, end);
            pos = end;
            end = pos === bin.length;
            if (callback(str, end) && !end) {
                runtime.setTimeout(f, 0);
            }
        }
        f();
    }
    /**
     * @param {!string} uni
     * @return {!Uint8Array}
     */
    function convertUTF16StringToUTF8Array(uni) {
        return convertUTF16ArrayToUTF8Array(stringToArray(uni));
    }
    /**
     * @param {!Uint8Array} uni
     * @return {!string}
     */
    function convertUTF16ArrayToUTF8String(uni) {
        return String.fromCharCode.apply(String,
                 convertUTF16ArrayToUTF8Array(uni));
    }
    /**
     * @param {!string} uni
     * @return {!string}
     */
    function convertUTF16StringToUTF8String(uni) {
        return String.fromCharCode.apply(String,
                 convertUTF16ArrayToUTF8Array(stringToArray(uni)));
    }

    if (window && window.btoa) {
        /**
         * @param {!string} b
         * @return {!string}
         */
        btoa = window.btoa;
        /**
         * @param {!string} uni
         * @return {!string}
         */
        convertUTF16StringToBase64 = function (uni) {
            return btoa(convertUTF16StringToUTF8String(uni));
        };
    } else {
        btoa = convertUTF8StringToBase64;
        /**
         * @param {!string} uni
         * @return {!string}
         */
        convertUTF16StringToBase64 = function (uni) {
            return convertUTF8ArrayToBase64(convertUTF16StringToUTF8Array(uni));
        };
    }
    if (window && window.atob) {
        /**
         * @param {!string} a
         * @return {!string}
         */
        atob = window.atob;
        /**
         * @param {!string} b64
         * @return {!string}
         */
        convertBase64ToUTF16String = function (b64) {
            var /**@type{!string}*/
                b = atob(b64);
            return convertUTF8StringToUTF16String_internal(b, 0, b.length);
        };
    } else {
        atob = convertBase64ToUTF8String;
        /**
         * @param {!string} b64
         * @return {!string}
         */
        convertBase64ToUTF16String = function (b64) {
            return convertUTF8ArrayToUTF16String(convertBase64ToUTF8Array(b64));
        };
    }

    /**
     * @constructor
     * @struct
     */
    core.Base64 = function Base64() {
        this.convertUTF8ArrayToBase64 = convertUTF8ArrayToBase64;
        this.convertByteArrayToBase64 = convertUTF8ArrayToBase64;
        this.convertBase64ToUTF8Array = convertBase64ToUTF8Array;
        this.convertBase64ToByteArray = convertBase64ToUTF8Array;
        this.convertUTF16ArrayToUTF8Array = convertUTF16ArrayToUTF8Array;
        this.convertUTF16ArrayToByteArray = convertUTF16ArrayToUTF8Array;
        this.convertUTF8ArrayToUTF16Array = convertUTF8ArrayToUTF16Array;
        this.convertByteArrayToUTF16Array = convertUTF8ArrayToUTF16Array;
        this.convertUTF8StringToBase64 = convertUTF8StringToBase64;
        this.convertBase64ToUTF8String = convertBase64ToUTF8String;
        this.convertUTF8StringToUTF16Array = convertUTF8StringToUTF16Array;
        this.convertUTF8ArrayToUTF16String = convertUTF8ArrayToUTF16String;
        this.convertByteArrayToUTF16String = convertUTF8ArrayToUTF16String;
        this.convertUTF8StringToUTF16String = convertUTF8StringToUTF16String;
        this.convertUTF16StringToUTF8Array = convertUTF16StringToUTF8Array;
        this.convertUTF16StringToByteArray = convertUTF16StringToUTF8Array;
        this.convertUTF16ArrayToUTF8String = convertUTF16ArrayToUTF8String;
        this.convertUTF16StringToUTF8String = convertUTF16StringToUTF8String;
        this.convertUTF16StringToBase64 = convertUTF16StringToBase64;
        this.convertBase64ToUTF16String = convertBase64ToUTF16String;
        this.fromBase64 = convertBase64ToUTF8String;
        this.toBase64 = convertUTF8StringToBase64;
        this.atob = atob;
        this.btoa = btoa;
        this.utob = convertUTF16StringToUTF8String;
        this.btou = convertUTF8StringToUTF16String;
        this.encode = convertUTF16StringToBase64;
        /**
         * @param {!string} u
         * @return {!string}
         */
        this.encodeURI = function (u) {
            return convertUTF16StringToBase64(u).replace(/[+\/]/g,
                /**
                 * @param {!string} m0
                 * @return {!string}
                 */
                function (m0) {
                    return m0 === '+' ? '-' : '_';
                }).replace(/\\=+$/, '');
        };
        /**
         * @param {!string} a
         * @return {!string}
         */
        this.decode = function (a) {
            return convertBase64ToUTF16String(a.replace(/[\-_]/g,
                /**
                 * @param {!string} m0
                 * @return {!string}
                 */
                function (m0) {
                    return m0 === '-' ? '+' : '/';
                }));
        };
        return this;
    };
    return core.Base64;
}
/**
 * @constructor
 */
core.Base64 = makeBase64();

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\CSSUnits.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <aditya.bhatt@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/
/*jslint plusplus: true, bitwise: true */

/**
 * @constructor
 */
core.CSSUnits = function CSSUnits() {
    "use strict";

    // Unit values relative to 1 inch
    var self = this,
        sizemap = {
            "in": 1,
            "cm": 2.54,
            "mm": 25.4,
            "pt": 72,
            "pc": 12,
            "px": 96
        };

    /**
     * Takes a number of an oldUnit and returns its value in newUnit
     * @param {!number} value
     * @param {!string} oldUnit
     * @param {!string} newUnit
     * @return {!number}
     */
    this.convert = function (value, oldUnit, newUnit) {
        return value * sizemap[newUnit] / sizemap[oldUnit];
    };

    /**
     * Takes a measure such as "2cm" and returns it's measurement in the new unit, e.g. 20
     * @param {!string} measure
     * @param {!string} newUnit
     * @return {!number|undefined}
     */
    this.convertMeasure = function (measure, newUnit) {
        var value, oldUnit, newMeasure;
        if (measure && newUnit) {
            value = parseFloat(measure);
            oldUnit = measure.replace(value.toString(), "");

            newMeasure = self.convert(value, oldUnit, newUnit);
        }
        return newMeasure;
    };
    /**
     * @param {!string} measure
     * @return {!string}
     */
    this.getUnits = function (measure) {
        return measure.substr(measure.length - 2, measure.length);
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Cursor.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, core, ops, runtime*/

/**
 * @class
 * A cursor is a dom node that visually represents a cursor in a DOM tree.
 * It should stay synchronized with the selection in the document. When
 * there is only one collapsed selection range, a cursor should be shown at
 * that point.
 *
 * Putting the cursor in the DOM tree modifies the DOM, so care should be taken
 * to keep the selection consistent. If e.g. a selection is drawn over the
 * cursor, and the cursor is updated to the selection, the cursor is removed
 * from the DOM because the selection is not collapsed. This means that the
 * offsets of the selection may have to be changed.
 *
 * When the selection is collapsed, the cursor is placed after the point of the
 * selection and the selection will stay valid. However, if the cursor was
 * placed in the DOM tree and was counted in the offset, the offset in the
 * selection should be decreased by one.
 *
 * Even when the selection allows for a cursor, it might be desireable to hide
 * the cursor by not letting it be part of the DOM.
 *
 * @constructor
 * @param {!Document} document  The DOM document in which the cursor is placed
 * @param {!string} memberId The memberid this cursor is assigned to
 */
core.Cursor = function Cursor(document, memberId) {
    "use strict";
    var cursorns = 'urn:webodf:names:cursor',
        /**@type{!Element}*/
        cursorNode = document.createElementNS(cursorns, 'cursor'),
        /**@type{!Element}*/
        anchorNode = document.createElementNS(cursorns, 'anchor'),
        forwardSelection,
        recentlyModifiedNodes = [],
        /**@type{!Range}*/
        selectedRange = /**@type{!Range}*/(document.createRange()),
        isCollapsed,
        domUtils = core.DomUtils;

    /**
     * Split a text node and put the cursor into it.
     * @param {!Node} node
     * @param {!Text} container
     * @param {!number} offset
     * @return {undefined}
     */
    function putIntoTextNode(node, container, offset) {
        runtime.assert(Boolean(container), "putCursorIntoTextNode: invalid container");
        var parent = container.parentNode;
        runtime.assert(Boolean(parent), "putCursorIntoTextNode: container without parent");
        runtime.assert(offset >= 0 && offset <= container.length, "putCursorIntoTextNode: offset is out of bounds");

        if (offset === 0) {
            parent.insertBefore(node, container);
        } else if (offset === container.length) {
            parent.insertBefore(node, container.nextSibling);
        } else {
            container.splitText(offset);
            parent.insertBefore(node, container.nextSibling);
        }
    }
    /**
     * Remove the cursor from the tree.
     * @param {!Element} node
     */
    function removeNode(node) {
        if (node.parentNode) {
            recentlyModifiedNodes.push(node.previousSibling);
            recentlyModifiedNodes.push(node.nextSibling);
            node.parentNode.removeChild(node);
        }
    }

    /**
     * Put the cursor at a particular position.
     * @param {!Node} node
     * @param {!Node} container
     * @param {!number} offset
     * @return {undefined}
     */
    function putNode(node, container, offset) {
        if (container.nodeType === Node.TEXT_NODE) {
            putIntoTextNode(node, /**@type{!Text}*/(container), offset);
        } else if (container.nodeType === Node.ELEMENT_NODE) {
            container.insertBefore(node, container.childNodes.item(offset));
        }
        recentlyModifiedNodes.push(node.previousSibling);
        recentlyModifiedNodes.push(node.nextSibling);
    }

    /**
     * Gets the earliest selection node in the document
     * @return {!Node}
     */
    function getStartNode() {
        return forwardSelection ? anchorNode : cursorNode;
    }

    /**
     * Gets the latest selection node in the document
     * @return {!Node}
     */
    function getEndNode() {
        return forwardSelection ? cursorNode : anchorNode;
    }
    /**
     * Obtain the node representing the cursor. This is
     * the selection end point
     * @return {!Element}
     */
    this.getNode = function () {
        return cursorNode;
    };
    /**
     * Obtain the node representing the selection start point.
     * If a 0-length range is selected (e.g., by clicking without
     * dragging),, this will return the exact same node as getNode
     * @return {!Element}
     */
    this.getAnchorNode = function () {
        return anchorNode.parentNode ? anchorNode : cursorNode;
    };
    /**
     * Obtain the selection to which the cursor corresponds.
     * @return {!Range}
     */
    this.getSelectedRange = function () {
        if (isCollapsed) {
            selectedRange.setStartBefore(cursorNode);
            selectedRange.collapse(true);
        } else {
            selectedRange.setStartAfter(getStartNode());
            selectedRange.setEndBefore(getEndNode());
        }
        return selectedRange;
    };
    /**
     * Synchronize the cursor to a specific range
     * If there is a single collapsed selection range, the cursor will be placed
     * there. If not, the cursor will be removed from the document tree.
     * @param {!Range} range
     * @param {boolean=} isForwardSelection Set to true to indicate the direction of the
     *                          range is startContainer => endContainer. This should be false if
     *                          the user creates a selection that ends before it starts in the document (i.e.,
     *                          drags the range backwards from the start point)
     * @return {undefined}
     */
    this.setSelectedRange = function (range, isForwardSelection) {
        if (selectedRange && selectedRange !== range) {
            selectedRange.detach();
        }
        selectedRange = range;
        forwardSelection = isForwardSelection !== false;
        isCollapsed = range.collapsed;

        // TODO the nodes need to be added and removed in the right order to preserve the range
        if (range.collapsed) {
            removeNode(anchorNode);
            removeNode(cursorNode);
            putNode(cursorNode, /**@type {!Node}*/(range.startContainer), range.startOffset);
        } else {
            removeNode(anchorNode);
            removeNode(cursorNode);
            // putting in the end node first eliminates the chance the position of the start node is destroyed
            putNode(getEndNode(), /**@type {!Node}*/(range.endContainer), range.endOffset);
            putNode(getStartNode(), /**@type {!Node}*/(range.startContainer), range.startOffset);
        }
        recentlyModifiedNodes.forEach(domUtils.normalizeTextNodes);
        recentlyModifiedNodes.length = 0;
    };
    /**
     * Returns if the selection of this cursor has the
     * same direction as the direction of the range
     * @return {boolean}
     */
    this.hasForwardSelection = function () {
        return forwardSelection;
    };
    /**
     * Remove the cursor from the document tree.
     * @return {undefined}
     */
    this.remove = function () {
        removeNode(cursorNode);
        recentlyModifiedNodes.forEach(domUtils.normalizeTextNodes);
        recentlyModifiedNodes.length = 0;
    };

    function init() {
        // mark cursornode with memberid
        cursorNode.setAttributeNS(cursorns, "memberId", memberId);
        anchorNode.setAttributeNS(cursorns, "memberId", memberId);
    }

    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Destroyable.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/
/*jslint emptyblock: true, unparam: true*/

/**
 * An operation that can be performed on a document.
 * @interface
 */
core.Destroyable = function Destroyable() {
    "use strict";
};
/**
 * Destroy the object.
 * Do not access any member of this object after this call.
 * @param {function(!Error=):undefined} callback
 * @return {undefined}
 */
core.Destroyable.prototype.destroy = function (callback) {"use strict"; };


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\DomUtils.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, core, ops, runtime, NodeFilter, Range*/

(function () {
    "use strict";
    var /**@type{!{rangeBCRIgnoresElementBCR: boolean, unscaledRangeClientRects: boolean, elementBCRIgnoresBodyScroll: !boolean}}*/
        browserQuirks;

    /**
     * Detect various browser quirks
     * unscaledRangeClientRects - Firefox doesn't apply parent css transforms to any range client rectangles
     * rangeBCRIgnoresElementBCR - Internet explorer returns 0 client rects for an empty element that has fixed dimensions
     * elementBCRIgnoresBodyScroll - iOS safari returns false client rects for an element that do not correlate with a scrolled body
     * @return {!{unscaledRangeClientRects: !boolean, rangeBCRIgnoresElementBCR: !boolean, elementBCRIgnoresBodyScroll: !boolean}}
     */
    function getBrowserQuirks() {
        var range,
            directBoundingRect,
            rangeBoundingRect,
            testContainer,
            testElement,
            detectedQuirks,
            window,
            document,
            docElement,
            body,
            docOverflow,
            bodyOverflow,
            bodyHeight,
            bodyScroll;

        if (browserQuirks === undefined) {
            window = runtime.getWindow();
            document = window && window.document;
            docElement = document.documentElement;
            body = document.body;
            browserQuirks = {
                rangeBCRIgnoresElementBCR: false,
                unscaledRangeClientRects: false,
                elementBCRIgnoresBodyScroll: false
            };
            if (document) {
                testContainer = document.createElement("div");
                testContainer.style.position = "absolute";
                testContainer.style.left = "-99999px";
                testContainer.style.transform = "scale(2)";
                testContainer.style["-webkit-transform"] = "scale(2)";

                testElement = document.createElement("div");
                testContainer.appendChild(testElement);
                body.appendChild(testContainer);
                range = document.createRange();
                range.selectNode(testElement);
                // Internet explorer (v10 and others?) will omit the element's own client rect from
                // the returned client rects list for the range
                browserQuirks.rangeBCRIgnoresElementBCR = range.getClientRects().length === 0;

                testElement.appendChild(document.createTextNode("Rect transform test"));
                directBoundingRect = testElement.getBoundingClientRect();
                rangeBoundingRect = range.getBoundingClientRect();
                // Firefox doesn't apply parent css transforms to any range client rectangles
                // See https://bugzilla.mozilla.org/show_bug.cgi?id=863618
                // Depending on the browser, client rects can sometimes have sub-pixel rounding effects, so
                // add some wiggle room for this. The scale is 200%, so there is no issues with false positives here
                browserQuirks.unscaledRangeClientRects = Math.abs(directBoundingRect.height - rangeBoundingRect.height) > 2;

                testContainer.style.transform = "";
                testContainer.style["-webkit-transform"] = "";
                // Backup current values for documentElement and body's overflows, body height, and body scroll.
                docOverflow = docElement.style.overflow;
                bodyOverflow = body.style.overflow;
                bodyHeight = body.style.height;
                bodyScroll = body.scrollTop;
                // Set new values for the backed up properties
                docElement.style.overflow = "visible";
                body.style.overflow = "visible";
                body.style.height = "200%";
                body.scrollTop = body.scrollHeight;
                // After extending the body's height to twice and scrolling by that amount,
                // if the element's new BCR is not the same as the range's BCR, then
                // Houston we have a Quirk! This problem has been seen on iOS7, which
                // seems to report the correct BCR for a range but ignores body scroll
                // effects on an element...
                browserQuirks.elementBCRIgnoresBodyScroll = (range.getBoundingClientRect().top !== testElement.getBoundingClientRect().top);
                // Restore backed up property values
                body.scrollTop = bodyScroll;
                body.style.height = bodyHeight;
                body.style.overflow = bodyOverflow;
                docElement.style.overflow = docOverflow;

                range.detach();
                body.removeChild(testContainer);
                detectedQuirks = Object.keys(browserQuirks).map(
                    /**
                     * @param {!string} quirk
                     * @return {!string}
                     */
                    function (quirk) {
                        return quirk + ":" + String(browserQuirks[quirk]);
                    }
                ).join(", ");
                runtime.log("Detected browser quirks - " + detectedQuirks);
            }
        }
        return browserQuirks;
    }

    /**
     * Return the first child element with the given namespace and name.
     * If the parent is null, or if there is no child with the given name and
     * namespace, null is returned.
     * @param {?Element} parent
     * @param {!string} ns
     * @param {!string} name
     * @return {?Element}
     */
    function getDirectChild(parent, ns, name) {
        var node = parent ? parent.firstElementChild : null;
        while (node) {
            if (node.localName === name && node.namespaceURI === ns) {
                return /**@type{!Element}*/(node);
            }
            node = node.nextElementSibling;
        }
        return null;
    }

    /**
     * A collection of Dom utilities
     * @constructor
     */
    core.DomUtilsImpl = function DomUtilsImpl() {
        var /**@type{?Range}*/
            sharedRange = null;

        /**
         * @param {!Document} doc
         * @return {!Range}
         */
        function getSharedRange(doc) {
            var range;
            if (sharedRange) {
                range = sharedRange;
            } else {
                sharedRange = range = /**@type{!Range}*/(doc.createRange());
            }
            return range;
        }

        /**
         * Find the inner-most child point that is equivalent
         * to the provided container and offset.
         * @param {!Node} container
         * @param {!number} offset
         * @return {{container: Node, offset: !number}}
         */
        function findStablePoint(container, offset) {
            var c = container;
            if (offset < c.childNodes.length) {
                c = c.childNodes.item(offset);
                offset = 0;
                while (c.firstChild) {
                    c = c.firstChild;
                }
            } else {
                while (c.lastChild) {
                    c = c.lastChild;
                    offset = c.nodeType === Node.TEXT_NODE
                        ? c.textContent.length
                        : c.childNodes.length;
                }
            }
            return {container: c, offset: offset};
        }

        /**
         * Gets the unfiltered DOM 'offset' of a node within a container that may not be it's direct parent.
         * @param {!Node} node
         * @param {!Node} container
         * @return {!number}
         */
        function getPositionInContainingNode(node, container) {
            var offset = 0,
                n;
            while (node.parentNode !== container) {
                runtime.assert(node.parentNode !== null, "parent is null");
                node = /**@type{!Node}*/(node.parentNode);
            }
            n = container.firstChild;
            while (n !== node) {
                offset += 1;
                n = n.nextSibling;
            }
            return offset;
        }

        /**
         * If either the start or end boundaries of a range start within a text
         * node, this function will split these text nodes and reset the range
         * boundaries to select the new nodes. The end result is that there are
         * no partially contained text nodes within the resulting range.
         * E.g., the text node with selection:
         *  "A|BCD|E"
         * would be split into 3 text nodes, with the range modified to maintain
         * only the completely selected text node:
         *  "A" "|BCD|" "E"
         * @param {!Range} range
         * @return {!Array.<!Node>} Return a list of nodes modified as a result
         *                           of this split operation. These are often
         *                           processed through
         *                           DomUtils.normalizeTextNodes after all
         *                           processing has been complete.
         */
        function splitBoundaries(range) {
            var modifiedNodes = [],
                originalEndContainer,
                resetToContainerLength,
                end,
                splitStart,
                node,
                text,
                offset;

            if (range.startContainer.nodeType === Node.TEXT_NODE
                    || range.endContainer.nodeType === Node.TEXT_NODE) {
                originalEndContainer = range.endContainer;
                resetToContainerLength = range.endContainer.nodeType !== Node.TEXT_NODE ?
                        range.endOffset === range.endContainer.childNodes.length : false;

                end = findStablePoint(range.endContainer, range.endOffset);
                if (end.container === originalEndContainer) {
                    originalEndContainer = null;
                }
                // Stable points need to be found to ensure splitting the text
                // node doesn't inadvertently modify the other end of the range
                range.setEnd(end.container, end.offset);

                // Must split end first to stop the start point from being lost
                node = range.endContainer;
                if (range.endOffset !== 0 && node.nodeType === Node.TEXT_NODE) {
                    text = /**@type{!Text}*/(node);
                    if (range.endOffset !== text.length) {
                        modifiedNodes.push(text.splitText(range.endOffset));
                        modifiedNodes.push(text);
                        // The end doesn't need to be reset as endContainer &
                        // endOffset are still valid after the modification
                    }
                }

                node = range.startContainer;
                if (range.startOffset !== 0 && node.nodeType === Node.TEXT_NODE) {
                    text = /**@type{!Text}*/(node);
                    if (range.startOffset !== text.length) {
                        splitStart = text.splitText(range.startOffset);
                        modifiedNodes.push(text);
                        modifiedNodes.push(splitStart);
                        range.setStart(splitStart, 0);
                    }
                }

                if (originalEndContainer !== null) {
                    node = range.endContainer;
                    while (node.parentNode && node.parentNode !== originalEndContainer) {
                        node = node.parentNode;
                    }
                    if (resetToContainerLength) {
                        offset = originalEndContainer.childNodes.length;
                    } else {
                        offset = getPositionInContainingNode(node, originalEndContainer);
                    }
                    range.setEnd(originalEndContainer, offset);
                }
            }
            return modifiedNodes;
        }
        this.splitBoundaries = splitBoundaries;

        /**
         * Returns true if the container range completely contains the insideRange.
         * Aligned boundaries are counted as inclusion
         * @param {!Range} container
         * @param {!Range} insideRange
         * @return {boolean}
         */
        function containsRange(container, insideRange) {
            return container.compareBoundaryPoints(Range.START_TO_START, insideRange) <= 0
                && container.compareBoundaryPoints(Range.END_TO_END, insideRange) >= 0;
        }
        this.containsRange = containsRange;

        /**
         * Returns true if there is any intersection between range1 and range2
         * @param {!Range} range1
         * @param {!Range} range2
         * @return {boolean}
         */
        function rangesIntersect(range1, range2) {
            return range1.compareBoundaryPoints(Range.END_TO_START, range2) <= 0
                && range1.compareBoundaryPoints(Range.START_TO_END, range2) >= 0;
        }
        this.rangesIntersect = rangesIntersect;

        /**
         * Returns the intersection of two ranges. If there is no intersection, this
         * will return undefined.
         *
         * @param {!Range} range1
         * @param {!Range} range2
         * @return {!Range|undefined}
         */
        function rangeIntersection(range1, range2) {
            var newRange;

            if (rangesIntersect(range1, range2)) {
                newRange = /**@type{!Range}*/(range1.cloneRange());
                if (range1.compareBoundaryPoints(Range.START_TO_START, range2) === -1) {
                    // If range1's start is before range2's start, use range2's start
                    newRange.setStart(range2.startContainer, range2.startOffset);
                }

                if (range1.compareBoundaryPoints(Range.END_TO_END, range2) === 1) {
                    // if range1's end is after range2's end, use range2's end
                    newRange.setEnd(range2.endContainer, range2.endOffset);
                }
            }
            return newRange;
        }
        this.rangeIntersection = rangeIntersection;

        /**
         * Returns the maximum available offset for the node. If this is a text
         * node, this will be node.length, or for an element node, childNodes.length
         * @param {!Node} node
         * @return {!number}
         */
        function maximumOffset(node) {
            return node.nodeType === Node.TEXT_NODE ? /**@type{!Text}*/(node).length : node.childNodes.length;
        }

        /**
         * Checks all nodes between the tree walker's current node and the defined
         * root. If any nodes are rejected, the tree walker is moved to the
         * highest rejected node below the root. Note, the root is excluded from
         * this check.
         *
         * This logic is similar to PositionIterator.moveToAcceptedNode
         * @param {!TreeWalker} walker
         * @param {!Node} root
         * @param {!function(!Node) : number} nodeFilter
         *
         * @return {!Node} Returns the current node the walker is on
         */
        function moveToNonRejectedNode(walker, root, nodeFilter) {
            var node = walker.currentNode;

            // Ensure currentNode is not within a rejected subtree by crawling each parent node
            // up to the root and verifying it is either accepted or skipped by the nodeFilter.
            // NOTE: The root is deliberately not checked as it is the container iteration happens within.
            if (node !== root) {
                node = node.parentNode;
                while (node && node !== root) {
                    if (nodeFilter(node) === NodeFilter.FILTER_REJECT) {
                        walker.currentNode = node;
                    }
                    node = node.parentNode;
                }
            }
            return walker.currentNode;
        }

        /**
         * Fetches all nodes within a supplied range that pass the required filter
         * @param {!Range} range
         * @param {!function(!Node) : number} nodeFilter
         * @param {!number} whatToShow
         * @return {!Array.<!Node>}
         */
        /*jslint bitwise:true*/
        function getNodesInRange(range, nodeFilter, whatToShow) {
            var document = range.startContainer.ownerDocument,
                elements = [],
                rangeRoot = range.commonAncestorContainer,
                root = /**@type{!Node}*/(rangeRoot.nodeType === Node.TEXT_NODE ? rangeRoot.parentNode : rangeRoot),
                treeWalker = document.createTreeWalker(root, whatToShow, nodeFilter, false),
                currentNode,
                lastNodeInRange,
                endNodeCompareFlags,
                comparePositionResult;

            if (range.endContainer.childNodes[range.endOffset - 1]) {
                // This is the last node completely contained in the range
                lastNodeInRange = /**@type{!Node}*/(range.endContainer.childNodes[range.endOffset - 1]);
                // Accept anything preceding or contained by this node.
                endNodeCompareFlags = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINED_BY;
            } else {
                // Either no child nodes (e.g., TEXT_NODE) or endOffset = 0
                lastNodeInRange = /**@type{!Node}*/(range.endContainer);
                // Don't accept things contained within this node, as the range ends before this node's children.
                // This is the last node touching the range though, so the node is still accepted into the results.
                endNodeCompareFlags = Node.DOCUMENT_POSITION_PRECEDING;
            }

            if (range.startContainer.childNodes[range.startOffset]) {
                // The range starts within startContainer, so this child node is the first node in the range
                currentNode = /**@type{!Node}*/(range.startContainer.childNodes[range.startOffset]);
                treeWalker.currentNode = currentNode;
            } else if (range.startOffset === maximumOffset(range.startContainer)) {
                // This condition will be true if the range starts beyond the last position of a node
                // E.g., (text, text.length) or (div, div.childNodes.length)
                currentNode = /**@type{!Node}*/(range.startContainer);
                treeWalker.currentNode = currentNode;
                // In this case, move to the last child (if the node has children)
                treeWalker.lastChild(); // May return null if the current node has no children
                // And navigate onto the next node in sequence
                currentNode = treeWalker.nextNode();
            } else {
                // This will only be hit for a text node that is partially overlapped by the range start
                currentNode = /**@type{!Node}*/(range.startContainer);
                treeWalker.currentNode = currentNode;
            }

            if (currentNode) {
                // If the treeWalker hit the end of the sequence in the treeWalker.nextNode line just above,
                // currentNode will be null.
                currentNode = moveToNonRejectedNode(treeWalker, root, nodeFilter);
                switch (nodeFilter(/**@type{!Node}*/(currentNode))) {
                    case NodeFilter.FILTER_REJECT:
                        // If started on a rejected node, calling nextNode will incorrectly
                        // dive down into the rejected node's children. Instead, advance to
                        // the next sibling or parent node's sibling and resume walking from
                        // there.
                        currentNode = treeWalker.nextSibling();
                        while (!currentNode && treeWalker.parentNode()) {
                            currentNode = treeWalker.nextSibling();
                        }
                        break;
                    case NodeFilter.FILTER_SKIP:
                        // Immediately advance to the next node without giving an opportunity for the current one to
                        // be stored.
                        currentNode = treeWalker.nextNode();
                        break;
                    default:
                    // case NodeFilter.FILTER_ACCEPT:
                        // Proceed into the following loop. The current node will be stored at the end of the loop
                        // if it is contained within the requested range.
                        break;
                }

                while (currentNode) {
                    comparePositionResult = lastNodeInRange.compareDocumentPosition(currentNode);
                    if (comparePositionResult !== 0 && (comparePositionResult & endNodeCompareFlags) === 0) {
                        // comparePositionResult === 0 if currentNode === lastNodeInRange. This is considered within the range
                        // comparePositionResult & endNodeCompareFlags would be non-zero if n precedes lastNodeInRange
                        // If either of these statements are false, currentNode is past the end of the range
                        break;
                    }
                    elements.push(currentNode);
                    currentNode = treeWalker.nextNode();
                }
            }

            return elements;
        }
        /*jslint bitwise:false*/
        this.getNodesInRange = getNodesInRange;

        /**
         * Merges the content of node with nextNode.
         * If node is an empty text node, it will be removed in any case.
         * If nextNode is an empty text node, it will be only removed if node is a text node.
         * @param {!Node} node
         * @param {!Node} nextNode
         * @return {?Node} merged text node or null if there is no text node as result
         */
        function mergeTextNodes(node, nextNode) {
            var mergedNode = null, text, nextText;

            if (node.nodeType === Node.TEXT_NODE) {
                text = /**@type{!Text}*/(node);
                if (text.length === 0) {
                    text.parentNode.removeChild(text);
                    if (nextNode.nodeType === Node.TEXT_NODE) {
                        mergedNode = nextNode;
                    }
                } else {
                    if (nextNode.nodeType === Node.TEXT_NODE) {
                        // in chrome it is important to add nextNode to node.
                        // doing it the other way around causes random
                        // whitespace to appear
                        nextText = /**@type{!Text}*/(nextNode);
                        text.appendData(nextText.data);
                        nextNode.parentNode.removeChild(nextNode);
                    }
                    mergedNode = node;
                }
            }

            return mergedNode;
        }

        /**
         * Attempts to normalize the node with any surrounding text nodes. No
         * actions are performed if the node is undefined, has no siblings, or
         * is not a text node
         * @param {Node} node
         * @return {undefined}
         */
        function normalizeTextNodes(node) {
            if (node && node.nextSibling) {
                node = mergeTextNodes(node, node.nextSibling);
            }
            if (node && node.previousSibling) {
                mergeTextNodes(node.previousSibling, node);
            }
        }
        this.normalizeTextNodes = normalizeTextNodes;

        /**
         * Checks if the provided limits fully encompass the passed in node
         * @param {!Range|{startContainer: Node, startOffset: !number, endContainer: Node, endOffset: !number}} limits
         * @param {!Node} node
         * @return {boolean} Returns true if the node is fully contained within
         *                    the range
         */
        function rangeContainsNode(limits, node) {
            var range = node.ownerDocument.createRange(),
                nodeRange = node.ownerDocument.createRange(),
                result;

            range.setStart(limits.startContainer, limits.startOffset);
            range.setEnd(limits.endContainer, limits.endOffset);
            nodeRange.selectNodeContents(node);

            result = containsRange(range, nodeRange);

            range.detach();
            nodeRange.detach();
            return result;
        }
        this.rangeContainsNode = rangeContainsNode;

        /**
         * Merge all child nodes into the targetNode's parent and remove the targetNode entirely
         * @param {!Node} targetNode
         * @return {!Node} parent of targetNode
         */
        function mergeIntoParent(targetNode) {
            var parent = targetNode.parentNode;
            while (targetNode.firstChild) {
                parent.insertBefore(targetNode.firstChild, targetNode);
            }
            parent.removeChild(targetNode);
            return parent;
        }
        this.mergeIntoParent = mergeIntoParent;

        /**
         * Removes all unwanted nodes from targetNode includes itself.
         * The nodeFilter defines which nodes should be removed (NodeFilter.FILTER_REJECT),
         * should be skipped including the subtree (NodeFilter.FILTER_SKIP) or should be kept
         * and their subtree checked further (NodeFilter.FILTER_ACCEPT).
         * @param {!Node} targetNode
         * @param {!function(!Node) : !number} nodeFilter
         * @return {?Node} parent of targetNode
         */
        function removeUnwantedNodes(targetNode, nodeFilter) {
            var parent = targetNode.parentNode,
                node = targetNode.firstChild,
                filterResult = nodeFilter(targetNode),
                next;

            if (filterResult === NodeFilter.FILTER_SKIP) {
                return parent;
            }

            while (node) {
                next = node.nextSibling;
                removeUnwantedNodes(node, nodeFilter);
                node = next;
            }
            if (parent && (filterResult === NodeFilter.FILTER_REJECT)) {
                mergeIntoParent(targetNode);
            }
            return parent;
        }
        this.removeUnwantedNodes = removeUnwantedNodes;

        /**
         * Removes all child nodes from the given node.
         * To be used instead of e.g. `node.innerHTML = "";`
         * @param {!Node} node
         * @return {undefined}
         */
        this.removeAllChildNodes = function (node) {
            while (node.firstChild) {
                node.removeChild(node.firstChild);
            }
        };

        /**
         * Get an array of nodes below the specified node with the specific namespace and tag name.
         *
         * Use this function instead of node.getElementsByTagNameNS when modifications are going to be made
         * to the document content during iteration. For read-only uses, node.getElementsByTagNameNS will perform
         * faster and use less memory. See https://github.com/kogmbh/WebODF/issues/736 for further discussion.
         *
         * @param {!Element|!Document} node
         * @param {!string} namespace
         * @param {!string} tagName
         * @return {!Array.<!Element>}
         */
        function getElementsByTagNameNS(node, namespace, tagName) {
            var e = [], list, i, l;
            list = node.getElementsByTagNameNS(namespace, tagName);
            e.length = l = list.length;
            for (i = 0; i < l; i += 1) {
                e[i] = /**@type{!Element}*/(list.item(i));
            }
            return e;
        }
        this.getElementsByTagNameNS = getElementsByTagNameNS;

        /**
         * Get an array of nodes below the specified node with the specific name tag name.
         *
         * Use this function instead of node.getElementsByTagName when modifications are going to be made
         * to the document content during iteration. For read-only uses, node.getElementsByTagName will perform
         * faster and use less memory. See https://github.com/kogmbh/WebODF/issues/736 for further discussion.
         *
         * @param {!Element|!Document} node
         * @param {!string} tagName
         * @return {!Array.<!Element>}
         */
        function getElementsByTagName(node, tagName) {
            var e = [], list, i, l;
            list = node.getElementsByTagName(tagName);
            e.length = l = list.length;
            for (i = 0; i < l; i += 1) {
                e[i] = /**@type{!Element}*/(list.item(i));
            }
            return e;
        }
        this.getElementsByTagName = getElementsByTagName;

        /**
         * Whether a node contains another node
         * Wrapper around Node.contains
         * http://www.w3.org/TR/domcore/#dom-node-contains
         * @param {!Node} parent The node that should contain the other node
         * @param {?Node} descendant The node to test presence of
         * @return {!boolean}
         */
        function containsNode(parent, descendant) {
            return parent === descendant
                // the casts to Element are a workaround due to a different
                // contains() definition in the Closure Compiler externs file.
                || /**@type{!Element}*/(parent).contains(/**@type{!Element}*/(descendant));
        }
        this.containsNode = containsNode;

        /**
         * Whether a node contains another node
         * @param {!Node} parent The node that should contain the other node
         * @param {?Node} descendant The node to test presence of
         * @return {!boolean}
         */
        /*jslint bitwise:true*/
        function containsNodeForBrokenWebKit(parent, descendant) {
            // the contains function is not reliable on safari/webkit so use
            // compareDocumentPosition instead
            return parent === descendant ||
                Boolean(parent.compareDocumentPosition(descendant) & Node.DOCUMENT_POSITION_CONTAINED_BY);
        }
        /*jslint bitwise:false*/

        /**
         * Return a number > 0 when point 1 precedes point 2. Return 0 if the points
         * are equal. Return < 0 when point 2 precedes point 1.
         * @param {!Node} c1 container of point 1
         * @param {!number} o1  offset in unfiltered DOM world of point 1
         * @param {!Node} c2 container of point 2
         * @param {!number} o2  offset in unfiltered DOM world of point 2
         * @return {!number}
         */
        function comparePoints(c1, o1, c2, o2) {
            if (c1 === c2) {
                return o2 - o1;
            }
            var comparison = c1.compareDocumentPosition(c2);
            if (comparison === 2) { // DOCUMENT_POSITION_PRECEDING
                comparison = -1;
            } else if (comparison === 4) { // DOCUMENT_POSITION_FOLLOWING
                comparison = 1;
            } else if (comparison === 10) { // DOCUMENT_POSITION_CONTAINS
                // c0 contains c2
                o1 = getPositionInContainingNode(c1, c2);
                comparison = (o1 < o2) ? 1 : -1;
            } else { // DOCUMENT_POSITION_CONTAINED_BY
                o2 = getPositionInContainingNode(c2, c1);
                comparison = (o2 < o1) ? -1 : 1;
            }
            return comparison;
        }
        this.comparePoints = comparePoints;

        /**
         * Scale the supplied number by the specified zoom transformation if the
         * bowser does not transform range client rectangles correctly.
         * In firefox, the span rectangle will be affected by the zoom, but the
         * range is not. In most all other browsers, the range number is
         * affected zoom.
         *
         * See http://dev.w3.org/csswg/cssom-view/#extensions-to-the-range-interface
         * Section 10, getClientRects,
         * "The transforms that apply to the ancestors are applied."
         * @param {!number} inputNumber An input number to be scaled. This is
         *                              expected to be the difference between
         *                              a property on two range-sourced client
         *                              rectangles (e.g., rect1.top - rect2.top)
         * @param {!number} zoomLevel   Current canvas zoom level
         * @return {!number}
         */
        function adaptRangeDifferenceToZoomLevel(inputNumber, zoomLevel) {
            if (getBrowserQuirks().unscaledRangeClientRects) {
                return inputNumber;
            }
            return inputNumber / zoomLevel;
        }
        this.adaptRangeDifferenceToZoomLevel = adaptRangeDifferenceToZoomLevel;

        /**
         * Translate a given child client rectangle to be relative to the parent's rectangle.
         * Adapt to the provided zoom level as per adaptRangeDifferenceToZoomLevel.
         *
         * IMPORTANT: due to browser quirks, any element bounding client rect used with this function
         * MUST be retrieved using DomUtils.getBoundingClientRect.
         *
         * @param {!ClientRect|!Object.<!string, !number>} child
         * @param {!ClientRect|!Object.<!string, !number>} parent
         * @param {!number} zoomLevel
         * @return {!ClientRect|{top: !number, left: !number,  bottom: !number, right: !number, width: !number, height: !number}}
         */
        this.translateRect = function(child, parent, zoomLevel) {
            return {
                top: adaptRangeDifferenceToZoomLevel(child.top - parent.top, zoomLevel),
                left: adaptRangeDifferenceToZoomLevel(child.left - parent.left, zoomLevel),
                bottom: adaptRangeDifferenceToZoomLevel(child.bottom - parent.top, zoomLevel),
                right: adaptRangeDifferenceToZoomLevel(child.right - parent.left, zoomLevel),
                width: adaptRangeDifferenceToZoomLevel(child.width, zoomLevel),
                height: adaptRangeDifferenceToZoomLevel(child.height, zoomLevel)
            };
        };

        /**
         * Get the bounding client rect for the specified node.
         * This function attempts to cope with various browser quirks, ideally
         * returning a rectangle that can be used in conjunction with rectangles
         * retrieved from ranges.
         *
         * Range & element client rectangles can only be mixed if both are
         * transformed in the same way.
         * See https://bugzilla.mozilla.org/show_bug.cgi?id=863618
         * @param {!Node} node
         * @return {?ClientRect}
         */
        function getBoundingClientRect(node) {
            var doc = /**@type{!Document}*/(node.ownerDocument),
                quirks = getBrowserQuirks(),
                range,
                element,
                rect,
                body = doc.body;

            if (quirks.unscaledRangeClientRects === false
                    || quirks.rangeBCRIgnoresElementBCR) {
                if (node.nodeType === Node.ELEMENT_NODE) {
                    element = /**@type{!Element}*/(node);
                    rect = element.getBoundingClientRect();
                    if (quirks.elementBCRIgnoresBodyScroll) {
                        return /**@type{?ClientRect}*/({
                            left: rect.left + body.scrollLeft,
                            right: rect.right + body.scrollLeft,
                            top: rect.top + body.scrollTop,
                            bottom: rect.bottom + body.scrollTop,
                            width: rect.width,
                            height: rect.height
                        });
                    }
                    return rect;
                }
            }
            range = getSharedRange(doc);
            range.selectNode(node);
            return range.getBoundingClientRect();
        }
        this.getBoundingClientRect = getBoundingClientRect;

        /**
         * Takes a flat object which is a key-value
         * map of strings, and populates/modifies
         * the node with child elements which have
         * the key name as the node name (namespace
         * prefix required in the key name)
         * and the value as the text content. 
         * Example: mapKeyValObjOntoNode(node, {"dc:creator": "Bob"}, nsResolver);
         * If a namespace prefix is unresolved with the
         * nsResolver, that key will be ignored and not written to the node.
         * @param {!Element} node
         * @param {!Object.<!string, !string>} properties
         * @param {!function(!string):?string} nsResolver
         */
        function mapKeyValObjOntoNode(node, properties, nsResolver) {
            Object.keys(properties).forEach(function (key) {
                var parts = key.split(":"),
                    prefix = parts[0],
                    localName = parts[1],
                    ns = nsResolver(prefix),
                    value = properties[key],
                    element;

                // Ignore if the prefix is unsupported,
                // otherwise set the textContent of the
                // element to the value.
                if (ns) {
                    element = /**@type{!Element|undefined}*/(node.getElementsByTagNameNS(ns, localName)[0]);
                    if (!element) {
                        element = node.ownerDocument.createElementNS(ns, key);
                        node.appendChild(element);
                    }
                    element.textContent = value;
                } else {
                    runtime.log("Key ignored: " + key);
                }
            });
        }
        this.mapKeyValObjOntoNode = mapKeyValObjOntoNode;

        /**
         * Takes an array of strings, which is a listing of
         * properties to be removed (namespace required),
         * and deletes the corresponding top-level child elements
         * that represent those properties, from the
         * supplied node.
         * Example: removeKeyElementsFromNode(node, ["dc:creator"], nsResolver);
         * If a namespace is not resolved with the nsResolver,
         * that key element will be not removed.
         * If a key element does not exist, it will be ignored.
         * @param {!Element} node
         * @param {!Array.<!string>} propertyNames
         * @param {!function(!string):?string} nsResolver
         */
        function removeKeyElementsFromNode(node, propertyNames, nsResolver) {
            propertyNames.forEach(function (propertyName) {
                var parts = propertyName.split(":"),
                    prefix = parts[0],
                    localName = parts[1],
                    ns = nsResolver(prefix),
                    element;

                // Ignore if the prefix is unsupported,
                // otherwise delete the element if found
                if (ns) {
                    element = /**@type{!Element|undefined}*/(node.getElementsByTagNameNS(ns, localName)[0]);
                    if (element) {
                        element.parentNode.removeChild(element);
                    } else {
                         runtime.log("Element for " + propertyName + " not found.");
                    }
                } else {
                    runtime.log("Property Name ignored: " + propertyName);
                }
            });
        }
        this.removeKeyElementsFromNode = removeKeyElementsFromNode;
 
        /**
         * Looks at an element's direct children, and generates an object which is a
         * flat key-value map from the child's ns:localName to it's text content.
         * Only those children that have a resolvable prefixed name will be taken into
         * account for generating this map.
         * @param {!Element} node
         * @param {function(!string):?string} prefixResolver 
         * @return {!Object.<!string,!string>}
         */
        function getKeyValRepresentationOfNode(node, prefixResolver) {
            var properties = {},
                currentSibling = node.firstElementChild,
                prefix;

            while (currentSibling) {
                prefix = prefixResolver(currentSibling.namespaceURI);
                if (prefix) {
                    properties[prefix + ':' + currentSibling.localName] = currentSibling.textContent;
                }
                currentSibling = currentSibling.nextElementSibling;
            }

            return properties;
        }
        this.getKeyValRepresentationOfNode = getKeyValRepresentationOfNode;

        /**
         * Maps attributes and elements in the properties object over top of the node.
         * Supports recursion and deep mapping.
         *
         * Supported value types are:
         * - string (mapped to an attribute string on node)
         * - number (mapped to an attribute string on node)
         * - object (deep mapped to a new child node on node)
         *
         * @param {!Element} node
         * @param {!Object.<string,*>} properties
         * @param {!function(!string):?string} nsResolver
         */
        function mapObjOntoNode(node, properties, nsResolver) {
            Object.keys(properties).forEach(function(key) {
                var parts = key.split(":"),
                    prefix = parts[0],
                    localName = parts[1],
                    ns = nsResolver(prefix),
                    value = properties[key],
                    valueType = typeof value,
                    element;

                if (valueType === "object") {
                    // Only create the destination sub-element if there are values to populate it with
                    if (Object.keys(/**@type{!Object}*/(value)).length) {
                        if (ns) {
                            element = /**@type{!Element|undefined}*/(node.getElementsByTagNameNS(ns, localName)[0])
                                || node.ownerDocument.createElementNS(ns, key);
                        } else {
                            element = /**@type{!Element|undefined}*/(node.getElementsByTagName(localName)[0])
                                || node.ownerDocument.createElement(key);
                        }
                        node.appendChild(element);
                        mapObjOntoNode(element, /**@type{!Object}*/(value), nsResolver);
                    }
                } else if (ns) {
                    runtime.assert(valueType === "number" || valueType === "string",
                        "attempting to map unsupported type '" + valueType + "' (key: " + key + ")");
                    node.setAttributeNS(ns, key, String(value));
                    // If the prefix is unknown or unsupported, simply ignore it for now
                }
            });
        }
        this.mapObjOntoNode = mapObjOntoNode;

        /**
         * Clones an event object.
         * IE10 destructs event objects once the event handler is done:
         * "The event object is only available during an event; that is, you can use it in event handlers but not in other code"
         * (from http://msdn.microsoft.com/en-us/library/ie/aa703876(v=vs.85).aspx)
         * This method can be used to create a copy of the event object, to work around that.
         * @param {!Event} event
         * @return {!Event}
         */
        function cloneEvent(event) {
            var e = Object.create(null);

            // copy over all direct properties
            Object.keys(event.constructor.prototype).forEach(function (x) {
                e[x] = event[x];
            });
            // only now set the prototype (might set properties read-only)
            e.prototype = event.constructor.prototype;

            return /**@type{!Event}*/(e);
        }
        this.cloneEvent = cloneEvent;

        this.getDirectChild = getDirectChild;

        /**
         * @param {!core.DomUtilsImpl} self
         */
        function init(self) {
            var appVersion, webKitOrSafari, ie,
                /**@type{?Window}*/
                window = runtime.getWindow();

            if (window === null) {
                return;
            }

            appVersion = window.navigator.appVersion.toLowerCase();
            webKitOrSafari = appVersion.indexOf('chrome') === -1
                && (appVersion.indexOf('applewebkit') !== -1
                    || appVersion.indexOf('safari') !== -1);
            // See http://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect
            // Also, IE cleverly removed the MSIE tag without fixing the bug we're attempting to sniff here...
            // http://msdn.microsoft.com/en-us/library/ie/bg182625%28v=vs.110%29.aspx
            ie = appVersion.indexOf('msie') !== -1 || appVersion.indexOf('trident') !== -1;
            if (webKitOrSafari || ie) {
                self.containsNode = containsNodeForBrokenWebKit;
            }
        }
        init(this);
    };

    /**
     * @type {!core.DomUtilsImpl}
     */
    core.DomUtils = new core.DomUtilsImpl();
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\enums.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/

/**
 * Step or iteration direction values
 * @enum {!number}
 */
core.StepDirection = {
    PREVIOUS: 1,
    NEXT: 2
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\EventNotifier.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, runtime*/

/**
 * @constructor
 * @implements {core.EventSource}
 * @param {!Array.<!string>=} eventIds
 */
core.EventNotifier = function EventNotifier(eventIds) {
    "use strict";

    var /**@type{!Object.<!string,!Array.<!Function>>}*/
        eventListener = {};

    /**
     * @param {!string} eventId
     * @param {*} args
     * @return {undefined}
     */
    this.emit = function (eventId, args) {
        var i, subscribers;

        runtime.assert(eventListener.hasOwnProperty(eventId),
            "unknown event fired \"" + eventId + "\"");
        subscribers = eventListener[eventId];
        // runtime.log("firing event \"" + eventId + "\" to " + subscribers.length + " subscribers.");
        for (i = 0; i < subscribers.length; i += 1) {
            subscribers[i](args);
        }
    };

    /**
     * @param {!string} eventId
     * @param {!Function} cb
     * @return {undefined}
     */
    this.subscribe = function (eventId, cb) {
        runtime.assert(eventListener.hasOwnProperty(eventId),
            "tried to subscribe to unknown event \"" + eventId + "\"");
        eventListener[eventId].push(cb);
    };

    /**
     * @param {!string} eventId
     * @param {!Function} cb
     * @return {undefined}
     */
    this.unsubscribe = function (eventId, cb) {
        var cbIndex;
        runtime.assert(eventListener.hasOwnProperty(eventId),
            "tried to unsubscribe from unknown event \"" + eventId + "\"");

        cbIndex = eventListener[eventId].indexOf(cb);
        runtime.assert(cbIndex !== -1, "tried to unsubscribe unknown callback from event \"" + eventId + "\"");
        if (cbIndex !== -1) {
            eventListener[eventId].splice(cbIndex, 1);
        }
    };

    /**
     * Register an event
     * @param {!string} eventId
     * @return {undefined}
     */
    function register(eventId) {
        runtime.assert(!eventListener.hasOwnProperty(eventId), "Duplicated event ids: \"" + eventId + "\" registered more than once.");
        eventListener[eventId] = [];
    }
    this.register = register;

    /**
     * @return {undefined}
     */
    function init() {
        if (eventIds) {
            eventIds.forEach(register);
        }
    }

    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\EventSource.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/
/*jslint emptyblock: true, unparam: true*/

/**
 * An object that allows subscription to events
 * @interface
 */
core.EventSource = function() { "use strict"; };

/**
 * @param {!string} eventId
 * @param {!Function} cb
 * @return {undefined}
 */
core.EventSource.prototype.subscribe = function (eventId, cb) { "use strict"; };

/**
 * @param {!string} eventId
 * @param {!Function} cb
 * @return {undefined}
 */
core.EventSource.prototype.unsubscribe = function (eventId, cb) { "use strict"; };
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\EventSubscriptions.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global gui, core*/

/**
 * A helper object used to subscribe to events on multiple event sources. Tracking this makes it easier to unsubscribe
 * to all events upon destruction.
 * 
 * @constructor
 * @implements {core.Destroyable}
 */
core.EventSubscriptions = function () {
    "use strict";
     var /**@type{!Array.<!{eventSource: !core.EventSource, eventid: !string, callback: !Function}>}*/
         subscriptions = [],
         /**@type {!core.EventNotifier}*/
         frameEventNotifier = new core.EventNotifier(),
         /**@type{!Object.<!string,!Array.<!{frameEventId: !string, eventSource: !Object, task: !core.ScheduledTask}>>}*/
         frameSubscriptions = {},
         /**@type{!number}*/
         nextFrameEventId = 0;

    /**
     * Subscribe to the specified event on the supplied eventSource
     * @param {!core.EventSource} eventSource
     * @param {!string} eventid
     * @param {!Function} callback
     */
    function addSubscription(eventSource, eventid, callback) {
        eventSource.subscribe(eventid, callback);
        subscriptions.push({
            eventSource: eventSource,
            eventid: eventid,
            callback: callback
        });
    }
    this.addSubscription = addSubscription;

    /**
     * Register a callback that will be invoked if the supplied event id is triggered at least once before the next
     * frame. The callback will only be triggered once per event id when the browser redraws the content.
     * The callback takes no arguments.
     *
     * @param {!core.EventSource} eventSource
     * @param {!string} eventid
     * @param {!function():undefined} callback Event callback. This callback takes NO arguments
     * @return {undefined}
     */
    this.addFrameSubscription = function (eventSource, eventid, callback) {
        var frameSubscription,
            frameEventId,
            eventFrameSubscriptions,
            i;

        if (!frameSubscriptions.hasOwnProperty(eventid)) {
            frameSubscriptions[eventid] = [];
        }
        eventFrameSubscriptions = frameSubscriptions[eventid];

        for (i = 0; i < eventFrameSubscriptions.length; i += 1) {
            if (eventFrameSubscriptions[i].eventSource === eventSource) {
                frameSubscription = eventFrameSubscriptions[i];
                break;
            }
        }

        if (!frameSubscription) {
            frameEventId = "s" + nextFrameEventId;
            nextFrameEventId += 1;
            frameEventNotifier.register(frameEventId);
            frameSubscription = {
                // A unique frame event id is necessary in case multiple eventSources identical external event ids
                frameEventId: frameEventId,
                eventSource: eventSource,
                task: core.Task.createRedrawTask(function() {
                    frameEventNotifier.emit(frameEventId, undefined);
                })
            };
            eventFrameSubscriptions.push(frameSubscription);
            addSubscription(eventSource, eventid, frameSubscription.task.trigger);
        }

        frameEventNotifier.subscribe(frameSubscription.frameEventId, callback);
    };

    /**
     * Unsubscribe all event subscriptions on all eventSources
     * @return {undefined}
     */
    function unsubscribeAll() {
        var cleanup = [];

        subscriptions.forEach(function(subscription) {
            subscription.eventSource.unsubscribe(subscription.eventid, subscription.callback);
        });
        subscriptions.length = 0;

        Object.keys(frameSubscriptions).forEach(function(eventId) {
            frameSubscriptions[eventId].forEach(function(subscriber) {
                cleanup.push(subscriber.task.destroy);
            });
            delete frameSubscriptions[eventId];
        });
        /*jslint emptyblock:true*/
        core.Async.destroyAll(cleanup, function() { });
        /*jslint emptyblock:false*/
        frameEventNotifier = new core.EventNotifier();
    }
    this.unsubscribeAll = unsubscribeAll;

    /**
     * Destroy the object.
     * Do not access any member of this object after this call.
     * @param {function(!Error=):undefined} callback
     * @return {undefined}
     */
    this.destroy = function(callback) {
        unsubscribeAll();
        callback();
    };
};
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\JSLint.js
========================================================================

/*global core*/
// jslint.js
// 2014-07-08

// Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// The Software shall be used for Good, not Evil.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// WARNING: JSLint will hurt your feelings.

// JSLINT is a global function. It takes two parameters.

//     var myResult = JSLINT(source, option);

// The first parameter is either a string or an array of strings. If it is a
// string, it will be split on '\n' or '\r'. If it is an array of strings, it
// is assumed that each string represents one line. The source can be a
// JavaScript text or a JSON text.

// The second parameter is an optional object of options that control the
// operation of JSLINT. Most of the options are booleans: They are all
// optional and have a default value of false. One of the options, predef,
// can be an array of names, which will be used to declare global variables,
// or an object whose keys are used as global names, with a boolean value
// that determines if they are assignable.

// If it checks out, JSLINT returns true. Otherwise, it returns false.

// If false, you can inspect JSLINT.errors to find out the problems.
// JSLINT.errors is an array of objects containing these properties:

//  {
//      line      : The line (relative to 0) at which the lint was found
//      character : The character (relative to 0) at which the lint was found
//      reason    : The problem
//      evidence  : The text line in which the problem occurred
//      raw       : The raw message before the details were inserted
//      a         : The first detail
//      b         : The second detail
//      c         : The third detail
//      d         : The fourth detail
//  }

// If a stopping error was found, a null will be the last element of the
// JSLINT.errors array. A stopping error means that JSLint was not confident
// enough to continue. It does not necessarily mean that the error was
// especially heinous.

// You can request a data structure that contains JSLint's results.

//     var myData = JSLINT.data();

// It returns a structure with this form:

//     {
//         errors: [
//             {
//                 line: NUMBER,
//                 character: NUMBER,
//                 reason: STRING,
//                 evidence: STRING
//             }
//         ],
//         functions: [
//             {
//                 name: STRING,
//                 line: NUMBER,
//                 level: NUMBER,
//                 parameter: [
//                     STRING
//                 ],
//                 var: [
//                     STRING
//                 ],
//                 exception: [
//                     STRING
//                 ],
//                 closure: [
//                     STRING
//                 ],
//                 outer: [
//                     STRING
//                 ],
//                 global: [
//                     STRING
//                 ],
//                 label: [
//                     STRING
//                 ]
//             }
//         ],
//         global: [
//             STRING
//         ],
//         member: {
//             STRING: NUMBER
//         },
//         json: BOOLEAN
//     }

// You can request a Function Report, which shows all of the functions
// and the parameters and vars that they use. This can be used to find
// implied global variables and other problems. The report is in HTML and
// can be inserted into an HTML <body>. It should be given the result of the
// JSLINT.data function.

//     var myReport = JSLINT.report(data);

// You can request an HTML error report.

//     var myErrorReport = JSLINT.error_report(data);

// You can obtain an object containing all of the properties found in the
// file. JSLINT.property contains an object containing a key for each
// property used in the program, the value being the number of times that
// property name was used in the file.

// You can request a properties report, which produces a list of the program's
// properties in the form of a /*properties*/ declaration.

//      var myPropertyReport = JSLINT.properties_report(JSLINT.property);

// You can obtain the parse tree that JSLint constructed while parsing. The
// latest tree is kept in JSLINT.tree. A nice stringification can be produced
// with

//     JSON.stringify(JSLINT.tree, [
//         'string',  'arity', 'name',  'first',
//         'second', 'third', 'block', 'else'
//     ], 4));

// You can request a context coloring table. It contains information that can be
// applied to the file that was analyzed. Context coloring colors functions
// based on their nesting level, and variables on the color of the functions
// in which they are defined.

//      var myColorization = JSLINT.color(data);

// It returns an array containing objects of this form:

//      {
//          from: COLUMN,
//          thru: COLUMN,
//          line: ROW,
//          level: 0 or higher
//      }

// JSLint provides three inline directives. They look like slashstar comments,
// and allow for setting options, declaring global variables, and establishing a
// set of allowed property names.

// These directives respect function scope.

// The jslint directive is a special comment that can set one or more options.
// For example:

/*jslint
    evil: true, nomen: true, regexp: true, todo: true
*/

// The current option set is

//     ass        true, if assignment expressions should be allowed
//     bitwise    true, if bitwise operators should be allowed
//     browser    true, if the standard browser globals should be predefined
//     closure    true, if Google Closure idioms should be tolerated
//     continue   true, if the continuation statement should be tolerated
//     debug      true, if debugger statements should be allowed
//     defined    true, if already defined variables are allowed
//     devel      true, if logging should be allowed (console, alert, etc.)
//     emptyblock true, if empty blocks should be allowed
//     eqeq       true, if == should be allowed
//     evil       true, if eval should be allowed
//     forin      true, if for in statements need not filter
//     indent     the indentation factor
//     maxerr     the maximum number of errors to allow
//     maxlen     the maximum length of a source line
//     newcap     true, if constructor names capitalization is ignored
//     node       true, if Node.js globals should be predefined
//     nomen      true, if names may have dangling _
//     passfail   true, if the scan should stop on first error
//     plusplus   true, if increment/decrement should be allowed
//     properties true, if all property names must be declared with /*properties*/
//     regexp     true, if the . should be allowed in regexp literals
//     rhino      true, if the Rhino environment globals should be predefined
//     unparam    true, if unused parameters should be tolerated
//     sloppy     true, if the 'use strict'; pragma is optional
//     stupid     true, if really stupid practices are tolerated
//     sub        true, if all forms of subscript notation are tolerated
//     todo       true, if TODO comments are tolerated
//     unvar      true, if unused variables should be tolerated
//     vars       true, if multiple var statements per function should be allowed
//     white      true, if sloppy whitespace is tolerated

// The properties directive declares an exclusive list of property names.
// Any properties named in the program that are not in the list will
// produce a warning.

// For example:

/*properties
    defined, emptyblock, unvar, JSLINT, JSLint, core,
    '\b', '\t', '\n', '\f', '\r', '!', '!=', '!==', '"', '%', '\'', '(begin)',
    '(error)', '*', '+', '-', '/', '<', '<=', '==', '===', '>', '>=', '\\', a,
    a_label, a_scope, already_defined, and, apply, arguments, arity, ass,
    assign, assignment_expression, assignment_function_expression, at, avoid_a,
    b, bad_assignment, bad_constructor, bad_in_a, bad_invocation, bad_new,
    bad_number, bad_operand, bad_wrap, bitwise, block, break, breakage, browser,
    c, call, charAt, charCodeAt, character, closure, code, color, combine_var,
    comments, conditional_assignment, confusing_a, confusing_regexp,
    constructor_name_a, continue, control_a, couch, create, d, dangling_a, data,
    dead, debug, deleted, devel, disrupt, duplicate_a, edge, edition, elif,
    else, empty_block, empty_case, empty_class, entityify, eqeq, error_report,
    errors, evidence, evil, exception, exec, expected_a_at_b_c, expected_a_b,
    expected_a_b_from_c_d, expected_id_a, expected_identifier_a,
    expected_identifier_a_reserved, expected_number_a, expected_operator_a,
    expected_positive_a, expected_small_a, expected_space_a_b,
    expected_string_a, f, first, flag, floor, forEach, for_if, forin, from,
    fromCharCode, fud, function, function_block, function_eval, function_loop,
    function_statement, function_strict, functions, global, hasOwnProperty, id,
    identifier, identifier_function, immed, implied_evil, indent, indexOf,
    infix_in, init, insecure_a, isAlpha, isArray, isDigit, isNaN, join, jslint,
    json, keys, kind, label, labeled, lbp, leading_decimal_a, led, left, length,
    level, line, loopage, master, match, maxerr, maxlen, message, missing_a,
    missing_a_after_b, missing_property, missing_space_a_b, missing_use_strict,
    mode, move_invocation, move_var, n, name, name_function, nested_comment,
    newcap, node, nomen, not, not_a_constructor, not_a_defined, not_a_function,
    not_a_label, not_a_scope, not_greater, nud, number, octal_a, open, outer,
    parameter, parameter_a_get_b, parameter_arguments_a, parameter_set_a,
    params, paren, passfail, plusplus, pop, postscript, predef, properties,
    properties_report, property, prototype, push, quote, r, radix, raw,
    read_only, reason, redefinition_a_b, regexp, relation, replace, report,
    reserved, reserved_a, rhino, right, scanned_a_b, scope, search, second,
    shift, slash_equal, slice, sloppy, sort, split, statement, statement_block,
    stop, stopping, strange_loop, strict, string, stupid, sub, subscript,
    substr, supplant, sync_a, t, tag_a_in_b, test, third, thru, toString, todo,
    todo_comment, token, tokens, too_long, too_many, trailing_decimal_a, tree,
    unclosed, unclosed_comment, unclosed_regexp, unescaped_a, unexpected_a,
    unexpected_char_a, unexpected_comment, unexpected_label_a,
    unexpected_property_a, unexpected_space_a_b, unexpected_typeof_a,
    uninitialized_a, unnecessary_else, unnecessary_initialize, unnecessary_use,
    unparam, unreachable_a_b, unsafe, unused_a, url, use_array, use_braces,
    use_nested_if, use_object, use_or, use_param, use_spaces, used,
    used_before_a, var, var_a_not, var_loop, vars, varstatement, warn, warning,
    was, weird_assignment, weird_condition, weird_new, weird_program,
    weird_relation, weird_ternary, white, wrap, wrap_immediate, wrap_regexp,
    write_is_wrong, writeable
*/

// The global directive is used to declare global variables that can
// be accessed by the program. If a declaration is true, then the variable
// is writeable. Otherwise, it is read-only.

// We build the application inside a function so that we produce only a single
// global variable. That function will be invoked immediately, and its return
// value is the JSLINT function itself. That function is also an object that
// can contain data and other functions.

var JSLINT = (function () {
    'use strict';

    function array_to_object(array, value) {

// Make an object from an array of keys and a common value.

        var i, length = array.length, object = Object.create(null);
        for (i = 0; i < length; i += 1) {
            object[array[i]] = value;
        }
        return object;
    }


    var allowed_option = {
            ass       : true,
            bitwise   : true,
            browser   : true,
            closure   : true,
            continue  : true,
            couch     : true,
            debug     : true,
            defined   : true,
            devel     : true,
            emptyblock: true,
            eqeq      : true,
            evil      : true,
            forin     : true,
            indent    :   10,
            maxerr    : 1000,
            maxlen    :  256,
            newcap    : true,
            node      : true,
            nomen     : true,
            passfail  : true,
            plusplus  : true,
            properties: true,
            regexp    : true,
            rhino     : true,
            unparam   : true,
            sloppy    : true,
            stupid    : true,
            sub       : true,
            todo      : true,
            unvar     : true,
            vars      : true,
            white     : true
        },
        anonname,       // The guessed name for anonymous functions.

// These are operators that should not be used with the ! operator.

        bang = {
            '<'  : true,
            '<=' : true,
            '==' : true,
            '===': true,
            '!==': true,
            '!=' : true,
            '>'  : true,
            '>=' : true,
            '+'  : true,
            '-'  : true,
            '*'  : true,
            '/'  : true,
            '%'  : true
        },
        begin,          // The root token
        block_var,     // vars defined in the current block

// browser contains a set of global names that are commonly provided by a
// web browser environment.

        browser = array_to_object([
            'clearInterval', 'clearTimeout', 'document', 'event', 'FormData',
            'frames', 'history', 'Image', 'localStorage', 'location', 'name',
            'navigator', 'Option', 'parent', 'screen', 'sessionStorage',
            'setInterval', 'setTimeout', 'Storage', 'window', 'XMLHttpRequest'
        ], false),

// bundle contains the text messages.

        bundle = {
            a_label: "'{a}' is a statement label.",
            a_scope: "'{a}' used out of scope.",
            already_defined: "'{a}' is already defined.",
            and: "The '&&' subexpression should be wrapped in parens.",
            assignment_expression: "Unexpected assignment expression.",
            assignment_function_expression: "Expected an assignment or " +
                "function call and instead saw an expression.",
            avoid_a: "Avoid '{a}'.",
            bad_assignment: "Bad assignment.",
            bad_constructor: "Bad constructor.",
            bad_in_a: "Bad for in variable '{a}'.",
            bad_invocation: "Bad invocation.",
            bad_new: "Do not use 'new' for side effects.",
            bad_number: "Bad number '{a}'.",
            bad_operand: "Bad operand.",
            bad_wrap: "Do not wrap function literals in parens unless they " +
                "are to be immediately invoked.",
            combine_var: "Combine this with the previous 'var' statement.",
            conditional_assignment: "Expected a conditional expression and " +
                "instead saw an assignment.",
            confusing_a: "Confusing use of '{a}'.",
            confusing_regexp: "Confusing regular expression.",
            constructor_name_a: "A constructor name '{a}' should start with " +
                "an uppercase letter.",
            control_a: "Unexpected control character '{a}'.",
            dangling_a: "Unexpected dangling '_' in '{a}'.",
            deleted: "Only properties should be deleted.",
            duplicate_a: "Duplicate '{a}'.",
            empty_block: "Empty block.",
            empty_case: "Empty case.",
            empty_class: "Empty class.",
            evil: "eval is evil.",
            expected_a_b: "Expected '{a}' and instead saw '{b}'.",
            expected_a_b_from_c_d: "Expected '{a}' to match '{b}' from line " +
                "{c} and instead saw '{d}'.",
            expected_a_at_b_c: "Expected '{a}' at column {b}, not column {c}.",
            expected_id_a: "Expected an id, and instead saw #{a}.",
            expected_identifier_a: "Expected an identifier and instead saw '{a}'.",
            expected_identifier_a_reserved: "Expected an identifier and " +
                "instead saw '{a}' (a reserved word).",
            expected_number_a: "Expected a number and instead saw '{a}'.",
            expected_operator_a: "Expected an operator and instead saw '{a}'.",
            expected_positive_a: "Expected a positive number and instead saw '{a}'",
            expected_small_a: "Expected a small positive integer and instead saw '{a}'",
            expected_space_a_b: "Expected exactly one space between '{a}' and '{b}'.",
            expected_string_a: "Expected a string and instead saw '{a}'.",
            for_if: "The body of a for in should be wrapped in an if " +
                "statement to filter unwanted properties from the prototype.",
            function_block: "Function statements should not be placed in blocks." +
                "Use a function expression or move the statement to the top of " +
                "the outer function.",
            function_eval: "The Function constructor is eval.",
            function_loop: "Don't make functions within a loop.",
            function_statement: "Function statements are not invocable. " +
                "Wrap the whole function invocation in parens.",
            function_strict: "Use the function form of 'use strict'.",
            identifier_function: "Expected an identifier in an assignment " +
                "and instead saw a function invocation.",
            implied_evil: "Implied eval is evil. Pass a function instead of a string.",
            infix_in: "Unexpected 'in'. Compare with undefined, or use the " +
                "hasOwnProperty method instead.",
            insecure_a: "Insecure '{a}'.",
            isNaN: "Use the isNaN function to compare with NaN.",
            leading_decimal_a: "A leading decimal point can be confused with a dot: '.{a}'.",
            missing_a: "Missing '{a}'.",
            missing_a_after_b: "Missing '{a}' after '{b}'.",
            missing_property: "Missing property name.",
            missing_space_a_b: "Missing space between '{a}' and '{b}'.",
            missing_use_strict: "Missing 'use strict' statement.",
            move_invocation: "Move the invocation into the parens that " +
                "contain the function.",
            move_var: "Move 'var' declarations to the top of the function.",
            name_function: "Missing name in function statement.",
            nested_comment: "Nested comment.",
            not: "Nested not.",
            not_a_constructor: "Do not use {a} as a constructor.",
            not_a_defined: "'{a}' has not been fully defined yet.",
            not_a_function: "'{a}' is not a function.",
            not_a_label: "'{a}' is not a label.",
            not_a_scope: "'{a}' is out of scope.",
            not_greater: "'{a}' should not be greater than '{b}'.",
            octal_a: "Don't use octal: '{a}'. Use '\\u....' instead.",
            parameter_arguments_a: "Do not mutate parameter '{a}' when using 'arguments'.",
            parameter_a_get_b: "Unexpected parameter '{a}' in get {b} function.",
            parameter_set_a: "Expected parameter (value) in set {a} function.",
            radix: "Missing radix parameter.",
            read_only: "Read only.",
            redefinition_a_b: "Redefinition of '{a}' from line {b}.",
            reserved_a: "Reserved name '{a}'.",
            scanned_a_b: "{a} ({b}% scanned).",
            slash_equal: "A regular expression literal can be confused with '/='.",
            statement_block: "Expected to see a statement and instead saw a block.",
            stopping: "Stopping.",
            strange_loop: "Strange loop.",
            strict: "Strict violation.",
            subscript: "['{a}'] is better written in dot notation.",
            sync_a: "Unexpected sync method: '{a}'.",
            tag_a_in_b: "A '<{a}>' must be within '<{b}>'.",
            todo_comment: "Unexpected TODO comment.",
            too_long: "Line too long.",
            too_many: "Too many errors.",
            trailing_decimal_a: "A trailing decimal point can be confused " +
                "with a dot: '.{a}'.",
            unclosed: "Unclosed string.",
            unclosed_comment: "Unclosed comment.",
            unclosed_regexp: "Unclosed regular expression.",
            unescaped_a: "Unescaped '{a}'.",
            unexpected_a: "Unexpected '{a}'.",
            unexpected_char_a: "Unexpected character '{a}'.",
            unexpected_comment: "Unexpected comment.",
            unexpected_label_a: "Unexpected label '{a}'.",
            unexpected_property_a: "Unexpected /*property*/ '{a}'.",
            unexpected_space_a_b: "Unexpected space between '{a}' and '{b}'.",
            unexpected_typeof_a: "Unexpected 'typeof'. " +
                "Use '===' to compare directly with {a}.",
            uninitialized_a: "Uninitialized '{a}'.",
            unnecessary_else: "Unnecessary 'else' after disruption.",
            unnecessary_initialize: "It is not necessary to initialize '{a}' " +
                "to 'undefined'.",
            unnecessary_use: "Unnecessary 'use strict'.",
            unreachable_a_b: "Unreachable '{a}' after '{b}'.",
            unsafe: "Unsafe character.",
            unused_a: "Unused '{a}'.",
            url: "JavaScript URL.",
            use_array: "Use the array literal notation [].",
            use_braces: "Spaces are hard to count. Use {{a}}.",
            use_nested_if: "Expected 'else { if' and instead saw 'else if'.",
            use_object: "Use the object literal notation {} or Object.create(null).",
            use_or: "Use the || operator.",
            use_param: "Use a named parameter.",
            use_spaces: "Use spaces, not tabs.",
            used_before_a: "'{a}' was used before it was defined.",
            var_a_not: "Variable {a} was not declared correctly.",
            var_loop: "Don't declare variables in a loop.",
            weird_assignment: "Weird assignment.",
            weird_condition: "Weird condition.",
            weird_new: "Weird construction. Delete 'new'.",
            weird_program: "Weird program.",
            weird_relation: "Weird relation.",
            weird_ternary: "Weird ternary.",
            wrap_immediate: "Wrap an immediate function invocation in " +
                "parentheses to assist the reader in understanding that the " +
                "expression is the result of a function, and not the " +
                "function itself.",
            wrap_regexp: "Wrap the /regexp/ literal in parens to " +
                "disambiguate the slash operator.",
            write_is_wrong: "document.write can be a form of eval."
        },
        closure = array_to_object([
            'goog'
        ], false),
        comments,
        comments_off,
        couch = array_to_object([
            'emit', 'getRow', 'isArray', 'log', 'provides', 'registerType',
            'require', 'send', 'start', 'sum', 'toJSON'
        ], false),

        descapes = {
            'b': '\b',
            't': '\t',
            'n': '\n',
            'f': '\f',
            'r': '\r',
            '"': '"',
            '/': '/',
            '\\': '\\',
            '!': '!'
        },

        devel = array_to_object([
            'alert', 'confirm', 'console', 'Debug', 'opera', 'prompt', 'WSH'
        ], false),
        directive,
        escapes = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\'': '\\\'',
            '"' : '\\"',
            '/' : '\\/',
            '\\': '\\\\'
        },

        funct,          // The current function

        functions,      // All of the functions
        global_funct,   // The global body
        global_scope,   // The global scope
        in_block,       // Where function statements are not allowed
        indent,
        itself,         // JSLINT itself
        json_mode,
        lex,            // the tokenizer
        lines,
        lookahead,
        node = array_to_object([
            'Buffer', 'clearImmediate', 'clearInterval', 'clearTimeout',
            'console', 'exports', 'global', 'module', 'process',
            'require', 'setImmediate', 'setInterval', 'setTimeout',
            '__dirname', '__filename'
        ], false),
        node_js,
        numbery = array_to_object(['indexOf', 'lastIndexOf', 'search'], true),
        next_token,
        option,
        predefined,     // Global variables defined by option
        prereg,
        prev_token,
        property,
        protosymbol,
        regexp_flag = array_to_object(['g', 'i', 'm'], true),
        return_this = function return_this() {
            return this;
        },
        rhino = array_to_object([
            'defineClass', 'deserialize', 'gc', 'help', 'load', 'loadClass',
            'print', 'quit', 'readFile', 'readUrl', 'runCommand', 'seal',
            'serialize', 'spawn', 'sync', 'toint32', 'version'
        ], false),

        scope,      // An object containing an object for each variable in scope
        semicolon_coda = array_to_object([';', '"', '\'', ')'], true),

// standard contains the global names that are provided by the
// ECMAScript standard.

        standard = array_to_object([
            'Array', 'Boolean', 'Date', 'decodeURI', 'decodeURIComponent',
            'encodeURI', 'encodeURIComponent', 'Error', 'eval', 'EvalError',
            'Function', 'isFinite', 'isNaN', 'JSON', 'Map', 'Math', 'Number',
            'Object', 'parseInt', 'parseFloat', 'Promise', 'Proxy',
            'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set',
            'String', 'Symbol', 'SyntaxError', 'System', 'TypeError',
            'URIError', 'WeakMap', 'WeakSet'
        ], false),

        strict_mode,
        syntax = Object.create(null),
        token,
        tokens,
        var_mode,
        warnings,

// Regular expressions. Some of these are stupidly long.

// carriage return, carriage return linefeed, or linefeed
        crlfx = /\r\n?|\n/,
// unsafe characters that are silently deleted by one or more browsers
        cx = /[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/,
// identifier
        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,
// javascript url
        jx = /^(?:javascript|jscript|ecmascript|vbscript)\s*:/i,
// star slash
        lx = /\*\/|\/\*/,
// characters in strings that need escapement
        nx = /[\u0000-\u001f'\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
// sync
        syx = /Sync$/,
// comment todo
        tox = /^\W*to\s*do(?:\W|$)/i,
// token
        tx = /^\s*([(){}\[\]\?.,:;'"~#@`]|={1,3}|\/(\*(jslint|properties|property|members?|globals?)?|=|\/)?|\*[\/=]?|\+(?:=|\++)?|-(?:=|-+)?|[\^%]=?|&[&=]?|\|[|=]?|>{1,3}=?|<(?:[\/=!]|\!(\[|--)?|<=?)?|\!(\!|==?)?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+(?:[xX][0-9a-fA-F]+|\.[0-9]*)?(?:[eE][+\-]?[0-9]+)?)/;


    if (typeof String.prototype.entityify !== 'function') {
        String.prototype.entityify = function () {
            return this
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        };
    }

    if (typeof String.prototype.isAlpha !== 'function') {
        String.prototype.isAlpha = function () {
            return (this >= 'a' && this <= 'z\uffff') ||
                (this >= 'A' && this <= 'Z\uffff');
        };
    }

    if (typeof String.prototype.isDigit !== 'function') {
        String.prototype.isDigit = function () {
            return (this >= '0' && this <= '9');
        };
    }

    if (typeof String.prototype.supplant !== 'function') {
        String.prototype.supplant = function (o) {
            return this.replace(/\{([^{}]*)\}/g, function (a, b) {
                var replacement = o[b];
                return typeof replacement === 'string' ||
                    typeof replacement === 'number' ? replacement : a;
            });
        };
    }


    function sanitize(a) {

//  Escapify a troublesome character.

        return escapes[a] ||
            '\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);
    }


    function add_to_predefined(group) {
        Object.keys(group).forEach(function (name) {
            predefined[name] = group[name];
        });
    }


    function assume() {
        if (option.browser) {
            add_to_predefined(browser);
            option.browser = false;
        }
        if (option.closure) {
            add_to_predefined(closure);
        }
        if (option.couch) {
            add_to_predefined(couch);
            option.couch = false;
        }
        if (option.devel) {
            add_to_predefined(devel);
            option.devel = false;
        }
        if (option.node) {
            add_to_predefined(node);
            option.node = false;
            node_js = true;
        }
        if (option.rhino) {
            add_to_predefined(rhino);
            option.rhino = false;
        }
    }


// Produce an error warning.

    function artifact(tok) {
        if (!tok) {
            tok = next_token;
        }
        return tok.id === '(number)' ? tok.number : tok.string;
    }

    function quit(message, line, character) {
        throw {
            name: 'JSLintError',
            line: line,
            character: character,
            message: bundle.scanned_a_b.supplant({
                a: bundle[message] || message,
                b: Math.floor((line / lines.length) * 100)
            })
        };
    }

    function warn(code, line, character, a, b, c, d) {
        var warning = {         // ~~
            id: '(error)',
            raw: bundle[code] || code,
            code: code,
            evidence: lines[line - 1] || '',
            line: line,
            character: character,
            a: a || artifact(this),
            b: b,
            c: c,
            d: d
        };
        warning.reason = warning.raw.supplant(warning);
        itself.errors.push(warning);
        if (option.passfail) {
            quit('stopping', line, character);
        }
        warnings += 1;
        if (warnings >= option.maxerr) {
            quit('too_many', line, character);
        }
        return warning;
    }

    function stop(code, line, character, a, b, c, d) {
        var warning = warn(code, line, character, a, b, c, d);
        quit('stopping', warning.line, warning.character);
    }

    function expected_at(at) {
        if (!option.white && next_token.from !== at) {
            next_token.warn('expected_a_at_b_c', '', at, next_token.from);
        }
    }

// lexical analysis and token construction

    lex = (function lex() {
        var character, c, from, length, line, pos, source_row;

// Private lex methods

        function next_line() {
            var at;
            character = 1;
            source_row = lines[line];
            line += 1;
            if (source_row === undefined) {
                return false;
            }
            at = source_row.search(/\t/);
            if (at >= 0) {
                if (option.white) {
                    source_row = source_row.replace(/\t/g, ' ');
                } else {
                    warn('use_spaces', line, at + 1);
                }
            }
            at = source_row.search(cx);
            if (at >= 0) {
                warn('unsafe', line, at);
            }
            if (option.maxlen && option.maxlen < source_row.length) {
                warn('too_long', line, source_row.length);
            }
            return true;
        }

// Produce a token object.  The token inherits from a syntax symbol.

        function it(type, value) {
            var id, the_token;
            if (type === '(string)') {
                if (jx.test(value)) {
                    warn('url', line, from);
                }
            }
            the_token = Object.create(syntax[(
                type === '(punctuator)' || (type === '(identifier)' &&
                        Object.prototype.hasOwnProperty.call(syntax, value))
                    ? value
                    : type
            )] || syntax['(error)']);
            if (type === '(identifier)') {
                the_token.identifier = true;
                if (value === '__iterator__' || value === '__proto__') {
                    stop('reserved_a', line, from, value);
                } else if (!option.nomen &&
                        (value.charAt(0) === '_' ||
                        value.charAt(value.length - 1) === '_')) {
                    warn('dangling_a', line, from, value);
                }
            }
            if (type === '(number)') {
                the_token.number = +value;
            } else if (value !== undefined) {
                the_token.string = String(value);
            }
            the_token.line = line;
            the_token.from = from;
            the_token.thru = character;
            if (comments.length) {
                the_token.comments = comments;
                comments = [];
            }
            id = the_token.id;
            prereg = id && (
                ('(,=:[!&|?{};~+-*%^<>'.indexOf(id.charAt(id.length - 1)) >= 0) ||
                id === 'return' || id === 'case'
            );
            return the_token;
        }

        function match(x) {
            var exec = x.exec(source_row), first;
            if (exec) {
                length = exec[0].length;
                first = exec[1];
                c = first.charAt(0);
                source_row = source_row.slice(length);
                from = character + length - first.length;
                character += length;
                return first;
            }
            for (;;) {
                if (!source_row) {
                    if (!option.white) {
                        warn('unexpected_char_a', line, character - 1, '(space)');
                    }
                    return;
                }
                c = source_row.charAt(0);
                if (c !== ' ') {
                    break;
                }
                source_row = source_row.slice(1);
                character += 1;
            }
            stop('unexpected_char_a', line, character, c);

        }

        function string(x) {
            var ch, at = 0, r = '', result;

            function hex(n) {
                var i = parseInt(source_row.substr(at + 1, n), 16);
                at += n;
                if (i >= 32 && i <= 126 &&
                        i !== 34 && i !== 92 && i !== 39) {
                    warn('unexpected_a', line, character, '\\');
                }
                character += n;
                ch = String.fromCharCode(i);
            }

            if (json_mode && x !== '"') {
                warn('expected_a_b', line, character, '"', x);
            }

            for (;;) {
                while (at >= source_row.length) {
                    at = 0;
                    if (!next_line()) {
                        stop('unclosed', line - 1, from);
                    }
                }
                ch = source_row.charAt(at);
                if (ch === x) {
                    character += 1;
                    source_row = source_row.slice(at + 1);
                    result = it('(string)', r);
                    result.quote = x;
                    return result;
                }
                if (ch < ' ') {
                    if (ch === '\n' || ch === '\r') {
                        break;
                    }
                    warn('control_a', line, character + at,
                        source_row.slice(0, at));
                } else if (ch === '\\') {
                    at += 1;
                    character += 1;
                    ch = source_row.charAt(at);
                    switch (ch) {
                    case '':
                        warn('unexpected_a', line, character, '\\');
                        next_line();
                        at = -1;
                        break;
                    case '\'':
                        if (json_mode) {
                            warn('unexpected_a', line, character, '\\\'');
                        }
                        break;
                    case 'u':
                        hex(4);
                        break;
                    case 'v':
                        if (json_mode) {
                            warn('unexpected_a', line, character, '\\v');
                        }
                        ch = '\v';
                        break;
                    case 'x':
                        if (json_mode) {
                            warn('unexpected_a', line, character, '\\x');
                        }
                        hex(2);
                        break;
                    default:
                        if (typeof descapes[ch] !== 'string') {
                            warn(ch >= '0' && ch <= '7' ? 'octal_a' : 'unexpected_a',
                                line, character, '\\' + ch);
                        } else {
                            ch = descapes[ch];
                        }
                    }
                }
                r += ch;
                character += 1;
                at += 1;
            }
        }

        function number(snippet) {
            var digit;
            if (source_row.charAt(0).isAlpha()) {
                warn('expected_space_a_b',
                    line, character, c, source_row.charAt(0));
            }
            if (c === '0') {
                digit = snippet.charAt(1);
                if (digit.isDigit()) {
                    if (token.id !== '.') {
                        warn('unexpected_a', line, character, snippet);
                    }
                } else if (json_mode && (digit === 'x' || digit === 'X')) {
                    warn('unexpected_a', line, character, '0x');
                }
            }
            if (snippet.slice(snippet.length - 1) === '.') {
                warn('trailing_decimal_a', line, character, snippet);
            }
            digit = +snippet;
            if (!isFinite(digit)) {
                warn('bad_number', line, character, snippet);
            }
            snippet = digit;
            return it('(number)', snippet);
        }

        function comment(snippet, type) {
            if (comments_off) {
                warn('unexpected_comment', line, character);
            } else if (!option.todo && tox.test(snippet)) {
                warn('todo_comment', line, character);
            }
            comments.push({
                id: type,
                from: from,
                thru: character,
                line: line,
                string: snippet
            });
        }

        function regexp() {
            var at = 0,
                b,
                bit,
                depth = 0,
                flag = '',
                high,
                letter,
                low,
                potential,
                quote,
                result;
            for (;;) {
                b = true;
                c = source_row.charAt(at);
                at += 1;
                switch (c) {
                case '':
                    stop('unclosed_regexp', line, from);
                    return;
                case '/':
                    if (depth > 0) {
                        warn('unescaped_a', line, from + at, '/');
                    }
                    c = source_row.slice(0, at - 1);
                    potential = Object.create(regexp_flag);
                    for (;;) {
                        letter = source_row.charAt(at);
                        if (potential[letter] !== true) {
                            break;
                        }
                        potential[letter] = false;
                        at += 1;
                        flag += letter;
                    }
                    if (source_row.charAt(at).isAlpha()) {
                        stop('unexpected_a', line, from, source_row.charAt(at));
                    }
                    character += at;
                    source_row = source_row.slice(at);
                    quote = source_row.charAt(0);
                    if (quote === '/' || quote === '*') {
                        stop('confusing_regexp', line, from);
                    }
                    result = it('(regexp)', c);
                    result.flag = flag;
                    return result;
                case '\\':
                    c = source_row.charAt(at);
                    if (c < ' ') {
                        warn('control_a', line, from + at, String(c));
                    } else if (c === '<') {
                        warn('unexpected_a', line, from + at, '\\');
                    }
                    at += 1;
                    break;
                case '(':
                    depth += 1;
                    b = false;
                    if (source_row.charAt(at) === '?') {
                        at += 1;
                        switch (source_row.charAt(at)) {
                        case ':':
                        case '=':
                        case '!':
                            at += 1;
                            break;
                        default:
                            warn('expected_a_b', line, from + at,
                                ':', source_row.charAt(at));
                        }
                    }
                    break;
                case '|':
                    b = false;
                    break;
                case ')':
                    if (depth === 0) {
                        warn('unescaped_a', line, from + at, ')');
                    } else {
                        depth -= 1;
                    }
                    break;
                case ' ':
                    pos = 1;
                    while (source_row.charAt(at) === ' ') {
                        at += 1;
                        pos += 1;
                    }
                    if (pos > 1) {
                        warn('use_braces', line, from + at, pos);
                    }
                    break;
                case '[':
                    c = source_row.charAt(at);
                    if (c === '^') {
                        at += 1;
                        if (!option.regexp) {
                            warn('insecure_a', line, from + at, c);
                        } else if (source_row.charAt(at) === ']') {
                            stop('unescaped_a', line, from + at, '^');
                        }
                    }
                    bit = false;
                    if (c === ']') {
                        warn('empty_class', line, from + at - 1);
                        bit = true;
                    }
klass:              do {
                        c = source_row.charAt(at);
                        at += 1;
                        switch (c) {
                        case '[':
                        case '^':
                            warn('unescaped_a', line, from + at, c);
                            bit = true;
                            break;
                        case '-':
                            if (bit) {
                                bit = false;
                            } else {
                                warn('unescaped_a', line, from + at, '-');
                                bit = true;
                            }
                            break;
                        case ']':
                            if (!bit) {
                                warn('unescaped_a', line, from + at - 1, '-');
                            }
                            break klass;
                        case '\\':
                            c = source_row.charAt(at);
                            if (c < ' ') {
                                warn('control_a', line, from + at, String(c));
                            } else if (c === '<') {
                                warn('unexpected_a', line, from + at, '\\');
                            }
                            at += 1;
                            bit = true;
                            break;
                        case '/':
                            warn('unescaped_a', line, from + at - 1, '/');
                            bit = true;
                            break;
                        default:
                            bit = true;
                        }
                    } while (c);
                    break;
                case '.':
                    if (!option.regexp) {
                        warn('insecure_a', line, from + at, c);
                    }
                    break;
                case ']':
                case '?':
                case '{':
                case '}':
                case '+':
                case '*':
                    warn('unescaped_a', line, from + at, c);
                    break;
                }
                if (b) {
                    switch (source_row.charAt(at)) {
                    case '?':
                    case '+':
                    case '*':
                        at += 1;
                        if (source_row.charAt(at) === '?') {
                            at += 1;
                        }
                        break;
                    case '{':
                        at += 1;
                        c = source_row.charAt(at);
                        if (c < '0' || c > '9') {
                            warn('expected_number_a', line,
                                from + at, c);
                        }
                        at += 1;
                        low = +c;
                        for (;;) {
                            c = source_row.charAt(at);
                            if (c < '0' || c > '9') {
                                break;
                            }
                            at += 1;
                            low = +c + (low * 10);
                        }
                        high = low;
                        if (c === ',') {
                            at += 1;
                            high = Infinity;
                            c = source_row.charAt(at);
                            if (c >= '0' && c <= '9') {
                                at += 1;
                                high = +c;
                                for (;;) {
                                    c = source_row.charAt(at);
                                    if (c < '0' || c > '9') {
                                        break;
                                    }
                                    at += 1;
                                    high = +c + (high * 10);
                                }
                            }
                        }
                        if (source_row.charAt(at) !== '}') {
                            warn('expected_a_b', line, from + at,
                                '}', c);
                        } else {
                            at += 1;
                        }
                        if (source_row.charAt(at) === '?') {
                            at += 1;
                        }
                        if (low > high) {
                            warn('not_greater', line, from + at,
                                low, high);
                        }
                        break;
                    }
                }
            }
            c = source_row.slice(0, at - 1);
            character += at;
            source_row = source_row.slice(at);
            return it('(regexp)', c);
        }

// Public lex methods

        return {
            init: function (source) {
                if (typeof source === 'string') {
                    lines = source.split(crlfx);
                } else {
                    lines = source;
                }
                line = 0;
                next_line();
                from = 1;
            },

// token -- this is called by advance to get the next token.

            token: function () {
                var first, i, snippet;

                for (;;) {
                    while (!source_row) {
                        if (!next_line()) {
                            return it('(end)');
                        }
                    }
                    snippet = match(tx);
                    if (snippet) {

//      identifier

                        first = snippet.charAt(0);
                        if (first.isAlpha() || first === '_' || first === '$') {
                            return it('(identifier)', snippet);
                        }

//      number

                        if (first.isDigit()) {
                            return number(snippet);
                        }
                        switch (snippet) {

//      string

                        case '"':
                        case "'":
                            return string(snippet);

//      // comment

                        case '//':
                            comment(source_row, '//');
                            source_row = '';
                            break;

//      /* comment

                        case '/*':
                            for (;;) {
                                i = source_row.search(lx);
                                if (i >= 0) {
                                    break;
                                }
                                character = source_row.length;
                                comment(source_row);
                                from = 0;
                                if (!next_line()) {
                                    stop('unclosed_comment', line, character);
                                }
                            }
                            comment(source_row.slice(0, i), '/*');
                            character += i + 2;
                            if (source_row.charAt(i) === '/') {
                                stop('nested_comment', line, character);
                            }
                            source_row = source_row.slice(i + 2);
                            break;

                        case '':
                            break;
//      /
                        case '/':
                            if (token.id === '/=') {
                                stop('slash_equal', line, from);
                            }
                            return prereg
                                ? regexp()
                                : it('(punctuator)', snippet);

//      punctuator
                        default:
                            return it('(punctuator)', snippet);
                        }
                    }
                }
            }
        };
    }());

    function define(kind, token) {

// Define a name.

        var name = token.string,
            master = scope[name];       // The current definition of the name

// vars are created with a deadzone, so that the expression that initializes
// the var cannot access the var. Functions are not writeable.

        token.dead = false;
        token.init = false;
        token.kind = kind;
        token.master = master;
        token.used = 0;
        token.writeable = true;

// Global variables are a little weird. They can be defined multiple times.
// Some predefined global vars are (or should) not be writeable.

        if (kind === 'var' && funct === global_funct) {
            if (!master) {
                if (predefined[name] === false) {
                    token.writeable = false;
                }
                global_scope[name] = token;
            }
        } else {

// It is an error if the name has already been defined in this scope, except
// when reusing an exception variable name.

            if (master && !option.defined) {
                if (master.function === funct) {
                    if (master.kind !== 'exception' || kind !== 'exception' ||
                            !master.dead) {
                        token.warn('already_defined', name);
                    }
                } else if (master.function !== global_funct) {
                    if (kind === 'var') {
                        token.warn('redefinition_a_b', name, master.line);
                    }
                }
            }
            scope[name] = token;
            if (kind === 'var') {
                block_var.push(name);
            }
        }
    }

    function peek(distance) {

// Peek ahead to a future token. The distance is how far ahead to look. The
// default is the next token.

        var found, slot = 0;

        distance = distance || 0;
        while (slot <= distance) {
            found = lookahead[slot];
            if (!found) {
                found = lookahead[slot] = lex.token();
            }
            slot += 1;
        }
        return found;
    }


    function advance(id, match) {

// Produce the next token, also looking for programming errors.

        if (indent) {

// If indentation checking was requested, then inspect all of the line breakings.
// The var statement is tricky because the names might be aligned or not. We
// look at the first line break after the var to determine the programmer's
// intention.

            if (var_mode && next_token.line !== token.line) {
                if ((var_mode !== indent || !next_token.edge) &&
                        next_token.from === indent.at -
                        (next_token.edge ? option.indent : 0)) {
                    var dent = indent;
                    for (;;) {
                        dent.at -= option.indent;
                        if (dent === var_mode) {
                            break;
                        }
                        dent = dent.was;
                    }
                    dent.open = false;
                }
                var_mode = null;
            }
            if (next_token.id === '?' && indent.mode === ':' &&
                    token.line !== next_token.line) {
                indent.at -= option.indent;
            }
            if (indent.open) {

// If the token is an edge.

                if (next_token.edge) {
                    if (next_token.edge === 'label') {
                        expected_at(1);
                    } else if (next_token.edge === 'case' || indent.mode === 'statement') {
                        expected_at(indent.at - option.indent);
                    } else if (indent.mode !== 'array' || next_token.line !== token.line) {
                        expected_at(indent.at);
                    }

// If the token is not an edge, but is the first token on the line.

                } else if (next_token.line !== token.line) {
                    if (next_token.from < indent.at + (indent.mode ===
                            'expression' ? 0 : option.indent)) {
                        expected_at(indent.at + option.indent);
                    }
                    indent.wrap = true;
                }
            } else if (next_token.line !== token.line) {
                if (next_token.edge) {
                    expected_at(indent.at);
                } else {
                    indent.wrap = true;
                    if (indent.mode === 'statement' || indent.mode === 'var') {
                        expected_at(indent.at + option.indent);
                    } else if (next_token.from < indent.at + (indent.mode ===
                            'expression' ? 0 : option.indent)) {
                        expected_at(indent.at + option.indent);
                    }
                }
            }
        }

        switch (token.id) {
        case '(number)':
            if (next_token.id === '.') {
                next_token.warn('trailing_decimal_a');
            }
            break;
        case '-':
            if (next_token.id === '-' || next_token.id === '--') {
                next_token.warn('confusing_a');
            }
            break;
        case '+':
            if (next_token.id === '+' || next_token.id === '++') {
                next_token.warn('confusing_a');
            }
            break;
        }
        if (token.id === '(string)' || token.identifier) {
            anonname = token.string;
        }

        if (id && next_token.id !== id) {
            if (match) {
                next_token.warn('expected_a_b_from_c_d', id,
                    match.id, match.line, artifact());
            } else if (!next_token.identifier || next_token.string !== id) {
                next_token.warn('expected_a_b', id, artifact());
            }
        }
        prev_token = token;
        token = next_token;
        next_token = lookahead.shift() || lex.token();
        next_token.function = funct;
        tokens.push(next_token);
    }


    function do_globals() {
        var name, writeable;
        for (;;) {
            if (next_token.id !== '(string)' && !next_token.identifier) {
                return;
            }
            name = next_token.string;
            advance();
            writeable = false;
            if (next_token.id === ':') {
                advance(':');
                switch (next_token.id) {
                case 'true':
                    writeable = predefined[name] !== false;
                    advance('true');
                    break;
                case 'false':
                    advance('false');
                    break;
                default:
                    next_token.stop('unexpected_a');
                }
            }
            predefined[name] = writeable;
            if (next_token.id !== ',') {
                return;
            }
            advance(',');
        }
    }


    function do_jslint() {
        var name, value;
        while (next_token.id === '(string)' || next_token.identifier) {
            name = next_token.string;
            if (!allowed_option[name]) {
                next_token.stop('unexpected_a');
            }
            advance();
            if (next_token.id !== ':') {
                next_token.stop('expected_a_b', ':', artifact());
            }
            advance(':');
            if (typeof allowed_option[name] === 'number') {
                value = next_token.number;
                if (value > allowed_option[name] || value <= 0 ||
                        Math.floor(value) !== value) {
                    next_token.stop('expected_small_a');
                }
                option[name] = value;
            } else {
                if (next_token.id === 'true') {
                    option[name] = true;
                } else if (next_token.id === 'false') {
                    option[name] = false;
                } else {
                    next_token.stop('unexpected_a');
                }
            }
            advance();
            if (next_token.id === ',') {
                advance(',');
            }
        }
        assume();
    }


    function do_properties() {
        var name;
        option.properties = true;
        for (;;) {
            if (next_token.id !== '(string)' && !next_token.identifier) {
                return;
            }
            name = next_token.string;
            advance();
            if (next_token.id === ':') {
                for (;;) {
                    advance();
                    if (next_token.id !== '(string)' && !next_token.identifier) {
                        break;
                    }
                }
            }
            property[name] = 0;
            if (next_token.id !== ',') {
                return;
            }
            advance(',');
        }
    }


    directive = function directive() {
        var command = this.id,
            old_comments_off = comments_off,
            old_indent = indent;
        comments_off = true;
        indent = null;
        if (next_token.line === token.line && next_token.from === token.thru) {
            next_token.warn('missing_space_a_b', artifact(token), artifact());
        }
        if (lookahead.length > 0) {
            this.warn('unexpected_a');
        }
        switch (command) {
        case '/*properties':
        case '/*property':
        case '/*members':
        case '/*member':
            do_properties();
            break;
        case '/*jslint':
            do_jslint();
            break;
        case '/*globals':
        case '/*global':
            do_globals();
            break;
        default:
            this.stop('unexpected_a');
        }
        comments_off = old_comments_off;
        advance('*/');
        indent = old_indent;
    };


// Indentation intention

    function edge(mode) {
        next_token.edge = indent ? indent.open && (mode || 'edge') : '';
    }


    function step_in(mode) {
        var open;
        if (typeof mode === 'number') {
            indent = {
                at: +mode,
                open: true,
                was: indent
            };
        } else if (!indent) {
            indent = {
                at: 1,
                mode: 'statement',
                open: true
            };
        } else if (mode === 'statement') {
            indent = {
                at: indent.at,
                open: true,
                was: indent
            };
        } else {
            open = mode === 'var' || next_token.line !== token.line;
            indent = {
                at: (open || mode === 'control'
                    ? indent.at + option.indent
                    : indent.at) + (indent.wrap ? option.indent : 0),
                mode: mode,
                open: open,
                was: indent
            };
            if (mode === 'var' && open) {
                var_mode = indent;
            }
        }
    }

    function step_out(id, symbol) {
        if (id) {
            if (indent && indent.open) {
                indent.at -= option.indent;
                edge();
            }
            advance(id, symbol);
        }
        if (indent) {
            indent = indent.was;
        }
    }

// Functions for conformance of whitespace.

    function one_space(left, right) {
        left = left || token;
        right = right || next_token;
        if (right.id !== '(end)' && !option.white &&
                (token.line !== right.line ||
                token.thru + 1 !== right.from)) {
            right.warn('expected_space_a_b', artifact(token), artifact(right));
        }
    }

    function one_space_only(left, right) {
        left = left || token;
        right = right || next_token;
        if (right.id !== '(end)' && (left.line !== right.line ||
                (!option.white && left.thru + 1 !== right.from))) {
            right.warn('expected_space_a_b', artifact(left), artifact(right));
        }
    }

    function no_space(left, right) {
        left = left || token;
        right = right || next_token;
        if ((!option.white) &&
                left.thru !== right.from && left.line === right.line) {
            if (!(option.closure && right.comments.length === 1
                  && right.comments[0].string.substr(0, 7) === '*@type{')) {
                right.warn('unexpected_space_a_b', artifact(left),
                           artifact(right));
            }
        }
    }

    function no_space_only(left, right) {
        left = left || token;
        right = right || next_token;
        if (right.id !== '(end)' && (left.line !== right.line ||
                (!option.white && left.thru !== right.from))) {
            right.warn('unexpected_space_a_b', artifact(left), artifact(right));
        }
    }

    function spaces(left, right) {
        if (!option.white) {
            left = left || token;
            right = right || next_token;
            if (left.thru === right.from && left.line === right.line) {
                right.warn('missing_space_a_b', artifact(left), artifact(right));
            }
        }
    }

    function comma() {
        if (next_token.id !== ',') {
            warn('expected_a_b', token.line, token.thru, ',', artifact());
        } else {
            if (!option.white) {
                no_space_only();
            }
            advance(',');
            spaces();
        }
    }


    function semicolon() {
        if (next_token.id !== ';') {
            warn('expected_a_b', token.line, token.thru, ';', artifact());
        } else {
            if (!option.white) {
                no_space_only();
            }
            advance(';');
            if (semicolon_coda[next_token.id] !== true) {
                spaces();
            }
        }
    }

    function use_strict() {
        if (next_token.string === 'use strict') {
            if (strict_mode) {
                next_token.warn('unnecessary_use');
            }
            edge();
            advance();
            semicolon();
            strict_mode = true;
            return true;
        }
        return false;
    }


    function are_similar(a, b) {
        if (a === b) {
            return true;
        }
        if (Array.isArray(a)) {
            if (Array.isArray(b) && a.length === b.length) {
                var i;
                for (i = 0; i < a.length; i += 1) {
                    if (!are_similar(a[i], b[i])) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        if (Array.isArray(b)) {
            return false;
        }
        if (a.id === '(number)' && b.id === '(number)') {
            return a.number === b.number;
        }
        if (a.arity === b.arity && a.string === b.string) {
            switch (a.arity) {
            case undefined:
                return a.string === b.string;
            case 'prefix':
            case 'suffix':
                return a.id === b.id && are_similar(a.first, b.first) &&
                    a.id !== '{' && a.id !== '[';
            case 'infix':
                return are_similar(a.first, b.first) &&
                    are_similar(a.second, b.second);
            case 'ternary':
                return are_similar(a.first, b.first) &&
                    are_similar(a.second, b.second) &&
                    are_similar(a.third, b.third);
            case 'function':
            case 'regexp':
                return false;
            default:
                return true;
            }
        }
        if (a.id === '.' && b.id === '[' && b.arity === 'infix') {
            return a.second.string === b.second.string && b.second.id === '(string)';
        }
        if (a.id === '[' && a.arity === 'infix' && b.id === '.') {
            return a.second.string === b.second.string && a.second.id === '(string)';
        }
        return false;
    }


// This is the heart of JSLINT, the Pratt parser. In addition to parsing, it
// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is
// like .nud except that it is only used on the first token of a statement.
// Having .fud makes it much easier to define statement-oriented languages like
// JavaScript. I retained Pratt's nomenclature.

// .nud     Null denotation
// .fud     First null denotation
// .led     Left denotation
//  lbp     Left binding power
//  rbp     Right binding power

// They are elements of the parsing method called Top Down Operator Precedence.

    function expression(rbp, initial) {

// rbp is the right binding power.
// initial indicates that this is the first expression of a statement.

        var left;
        if (next_token.id === '(end)') {
            token.stop('unexpected_a', next_token.id);
        }
        advance();
        if (initial) {
            anonname = 'anonymous';
        }
        if (initial === true && token.fud) {
            left = token.fud();
        } else {
            if (token.nud) {
                left = token.nud();
            } else {
                if (next_token.id === '(number)' && token.id === '.') {
                    token.warn('leading_decimal_a', artifact());
                    advance();
                    return token;
                }
                token.stop('expected_identifier_a', artifact(token));
            }
            while (rbp < next_token.lbp) {
                advance();
                left = token.led(left);
            }
        }
        if (left && left.assign && !initial) {
            if (!option.ass) {
                left.warn('assignment_expression');
            }
            if (left.id !== '=' && left.first.master) {
                left.first.master.used = true;
            }
        }
        return left;
    }

    protosymbol = {
        nud: function () {
            this.stop('unexpected_a');
        },
        led: function () {
            this.stop('expected_operator_a');
        },
        warn: function (code, a, b, c, d) {
            if (!this.warning) {
                this.warning = warn(code, this.line || 0, this.from || 0,
                    a || artifact(this), b, c, d);
            }
        },
        stop: function (code, a, b, c, d) {
            this.warning = undefined;
            this.warn(code, a, b, c, d);
            return quit('stopping', this.line, this.character);
        },
        lbp: 0
    };

// Functional constructors for making the symbols that will be inherited by
// tokens.

    function symbol(s, bp) {
        var x = syntax[s];
        if (!x) {
            x = Object.create(protosymbol);
            x.id = x.string = s;
            x.lbp = bp || 0;
            syntax[s] = x;
        }
        return x;
    }

    function postscript(x) {
        x.postscript = true;
        return x;
    }

    function ultimate(s) {
        var x = symbol(s, 0);
        x.from = 1;
        x.thru = 1;
        x.line = 0;
        x.edge = 'edge';
        x.string = s;
        return postscript(x);
    }

    function reserve_name(x) {
        var c = x.id.charAt(0);
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            x.identifier = x.reserved = true;
        }
        return x;
    }

    function stmt(s, f) {
        var x = symbol(s);
        x.fud = f;
        return reserve_name(x);
    }

    function disrupt_stmt(s, f) {
        var x = stmt(s, f);
        x.disrupt = true;
    }

    function labeled_stmt(s, f) {
        var x = stmt(s, function labeled() {
            var the_statement;
            if (funct.breakage) {
                funct.breakage.push(this);
            } else {
                funct.breakage = [this];
            }
            the_statement = f.apply(this);
            if (funct.breakage.length > 1) {
                funct.breakage.pop();
            } else {
                delete funct.breakage;
            }
            return the_statement;
        });
        x.labeled = true;
    }

    function prefix(s, f) {
        var x = symbol(s, 150);
        reserve_name(x);
        x.nud = function () {
            var that = this;
            that.arity = 'prefix';
            if (typeof f === 'function') {
                that = f(that);
                if (that.arity !== 'prefix') {
                    return that;
                }
            } else {
                if (s === 'typeof') {
                    one_space();
                } else {
                    no_space_only();
                }
                that.first = expression(150);
            }
            switch (that.id) {
            case '++':
            case '--':
                if (!option.plusplus) {
                    that.warn('unexpected_a');
                } else if ((!that.first.identifier || that.first.reserved) &&
                        that.first.id !== '.' && that.first.id !== '[') {
                    that.warn('bad_operand');
                }
                break;
            default:
                if (that.first.arity === 'prefix' ||
                        that.first.arity === 'function') {
                    that.warn('unexpected_a');
                }
            }
            return that;
        };
        return x;
    }


    function type(s, t, nud) {
        var x = symbol(s);
        x.arity = t;
        if (nud) {
            x.nud = nud;
        }
        return x;
    }


    function reserve(s, f) {
        var x = symbol(s);
        x.identifier = x.reserved = true;
        if (typeof f === 'function') {
            x.nud = f;
        }
        return x;
    }


    function constant(name) {
        var x = reserve(name);
        x.string = name;
        x.nud = return_this;
        return x;
    }


    function reservevar(s, v) {
        return reserve(s, function () {
            if (typeof v === 'function') {
                v(this);
            }
            return this;
        });
    }


    function infix(s, p, f, w) {
        var x = symbol(s, p);
        reserve_name(x);
        x.led = function (left) {
            this.arity = 'infix';
            if (!w) {
                spaces(prev_token, token);
                spaces();
            }
            if (!option.bitwise && this.bitwise) {
                this.warn('unexpected_a');
            }
            if (typeof f === 'function') {
                return f(left, this);
            }
            this.first = left;
            this.second = expression(p);
            return this;
        };
        return x;
    }

    function expected_relation(node, message) {
        if (node.assign) {
            node.warn(message || 'conditional_assignment');
        }
        return node;
    }

    function expected_condition(node, message) {
        switch (node.id) {
        case '[':
        case '-':
            if (node.arity !== 'infix') {
                node.warn(message || 'weird_condition');
            }
            break;
        case 'false':
        case 'function':
        case 'Infinity':
        case 'NaN':
        case 'null':
        case 'true':
        case 'undefined':
        case 'void':
        case '(number)':
        case '(regexp)':
        case '(string)':
        case '{':
        case '?':
        case '~':
            node.warn(message || 'weird_condition');
            break;
        case '(':
            if (node.first.id === 'new' ||
                    (node.first.string === 'Boolean') ||
                    (node.first.id === '.' &&
                        numbery[node.first.second.string] === true)) {
                node.warn(message || 'weird_condition');
            }
            break;
        }
        return node;
    }

    function check_relation(node) {
        switch (node.arity) {
        case 'prefix':
            switch (node.id) {
            case '{':
            case '[':
                node.warn('unexpected_a');
                break;
            case '!':
                node.warn('confusing_a');
                break;
            }
            break;
        case 'function':
        case 'regexp':
            node.warn('unexpected_a');
            break;
        default:
            if (node.id  === 'NaN') {
                node.warn('isNaN');
            } else if (node.relation) {
                node.warn('weird_relation');
            }
        }
        return node;
    }


    function relation(s, eqeq) {
        var x = infix(s, 100, function (left, that) {
            check_relation(left);
            if (eqeq && !option.eqeq) {
                that.warn('expected_a_b', eqeq, that.id);
            }
            var right = expression(100);
            if (are_similar(left, right) ||
                    ((left.id === '(string)' || left.id === '(number)') &&
                    (right.id === '(string)' || right.id === '(number)'))) {
                that.warn('weird_relation');
            } else if (left.id === 'typeof') {
                if (right.id !== '(string)') {
                    right.warn("expected_string_a", artifact(right));
                } else if (right.string === 'undefined' ||
                        right.string === 'null') {
                    left.warn("unexpected_typeof_a", right.string);
                }
            } else if (right.id === 'typeof') {
                if (left.id !== '(string)') {
                    left.warn("expected_string_a", artifact(left));
                } else if (left.string === 'undefined' ||
                        left.string === 'null') {
                    right.warn("unexpected_typeof_a", left.string);
                }
            }
            that.first = left;
            that.second = check_relation(right);
            return that;
        });
        x.relation = true;
        return x;
    }

    function lvalue(that, s) {
        var master;
        if (that.identifier) {
            master = scope[that.string];
            if (master) {
                if (scope[that.string].writeable !== true) {
                    that.warn('read_only');
                }
                master.used -= 1;
                if (s === '=') {
                    master.init = true;
                }
            } else if (that.reserved) {
                that.warn('expected_identifier_a_reserved');
            }
        } else if (that.id === '.' || that.id === '[') {
            if (!that.first || that.first.string === 'arguments') {
                that.warn('bad_assignment');
            }
        } else {
            that.warn('bad_assignment');
        }
    }


    function assignop(s, op) {
        var x = infix(s, 20, function (left, that) {
            var next;
            that.first = left;
            lvalue(left, s);
            that.second = expression(20);
            if (that.id === '=' && are_similar(that.first, that.second)) {
                that.warn('weird_assignment');
            }
            next = that;
            while (next_token.id === '=') {
                lvalue(next.second, '=');
                next_token.first = next.second;
                next.second = next_token;
                next = next_token;
                advance('=');
                next.second = expression(20);
            }
            return that;
        });
        x.assign = true;
        if (op) {
            if (syntax[op].bitwise) {
                x.bitwise = true;
            }
        }
        return x;
    }


    function bitwise(s, p) {
        var x = infix(s, p, 'number');
        x.bitwise = true;
        return x;
    }


    function suffix(s) {
        var x = symbol(s, 150);
        x.led = function (left) {
            no_space_only(prev_token, token);
            if (!option.plusplus) {
                this.warn('unexpected_a');
            } else if ((!left.identifier || left.reserved) &&
                    left.id !== '.' && left.id !== '[') {
                this.warn('bad_operand');
            }
            this.first = left;
            this.arity = 'suffix';
            return this;
        };
        return x;
    }


    function optional_identifier(variable) {
        if (next_token.identifier) {
            advance();
            if (token.reserved && variable) {
                token.warn('expected_identifier_a_reserved');
            }
            return token.string;
        }
    }


    function identifier(variable) {
        var i = optional_identifier(variable);
        if (!i) {
            next_token.stop(token.id === 'function' && next_token.id === '('
                ? 'name_function'
                : 'expected_identifier_a');
        }
        return i;
    }


    function statement() {

        var label, preamble, the_statement;

// We don't like the empty statement.

        if (next_token.id === ';') {
            next_token.warn('unexpected_a');
            semicolon();
            return;
        }

// Is this a labeled statement?

        if (next_token.identifier && !next_token.reserved && peek().id === ':') {
            edge('label');
            label = next_token;
            advance();
            advance(':');
            define('label', label);
            if (next_token.labeled !== true || funct === global_funct) {
                label.stop('unexpected_label_a');
            } else if (jx.test(label.string + ':')) {
                label.warn('url');
            }
            next_token.label = label;
            label.init = true;
            label.statement = next_token;
        }

// Parse the statement.

        preamble = next_token;
        if (token.id !== 'else') {
            edge();
        }
        step_in('statement');
        the_statement = expression(0, true);
        if (the_statement) {

// Look for the final semicolon.

            if (the_statement.arity === 'statement') {
                if (the_statement.id === 'switch' ||
                        (the_statement.block && the_statement.id !== 'do')) {
                    spaces();
                } else {
                    semicolon();
                }
            } else {

// If this is an expression statement, determine if it is acceptable.
// We do not like
//      new Blah;
// statements. If it is to be used at all, new should only be used to make
// objects, not side effects. The expression statements we do like do
// assignment or invocation or delete.

                if (the_statement.id === '(') {
                    if (the_statement.first.id === 'new') {
                        next_token.warn('bad_new');
                    }
                } else if (the_statement.id === '++' ||
                        the_statement.id === '--') {
                    lvalue(the_statement.first);
                } else if (!the_statement.assign &&
                        the_statement.id !== 'delete') {
                    if (!option.closure || !preamble.comments) {
                        preamble.warn('assignment_function_expression');
                    }
                }
                semicolon();
            }
        }
        step_out();
        if (label) {
            label.dead = true;
        }
        return the_statement;
    }


    function statements() {
        var array = [], disruptor, the_statement;

// A disrupt statement may not be followed by any other statement.
// If the last statement is disrupt, then the sequence is disrupt.

        while (next_token.postscript !== true) {
            if (next_token.id === ';') {
                next_token.warn('unexpected_a');
                semicolon();
            } else {
                if (next_token.string === 'use strict') {
                    if ((!node_js) || funct !== global_funct || array.length > 0) {
                        next_token.warn('function_strict');
                    }
                    use_strict();
                }
                if (disruptor) {
                    next_token.warn('unreachable_a_b', next_token.string,
                        disruptor.string);
                    disruptor = null;
                }
                the_statement = statement();
                if (the_statement) {
                    array.push(the_statement);
                    if (the_statement.disrupt) {
                        disruptor = the_statement;
                        array.disrupt = true;
                    }
                }
            }
        }
        return array;
    }


    function block(kind) {

// A block is a sequence of statements wrapped in braces.

        var array,
            curly = next_token,
            old_block_var = block_var,
            old_in_block = in_block,
            old_strict_mode = strict_mode;

        in_block = kind !== 'function' && kind !== 'try' && kind !== 'catch';
        block_var = [];
        if (curly.id === '{') {
            spaces();
            advance('{');
            step_in();
            if (kind === 'function' && !use_strict() && !old_strict_mode &&
                    !option.sloppy && funct.level === 1) {
                next_token.warn('missing_use_strict');
            }
            array = statements();
            strict_mode = old_strict_mode;
            step_out('}', curly);
        } else if (in_block) {
            curly.stop('expected_a_b', '{', artifact());
        } else {
            curly.warn('expected_a_b', '{', artifact());
            array = [statement()];
            array.disrupt = array[0].disrupt;
        }
        if (!(option.emptyblock || option.debug) && kind !== 'catch' && array.length === 0) {
            curly.warn('empty_block');
        }
        block_var.forEach(function (name) {
            scope[name].dead = true;
        });
        block_var = old_block_var;
        in_block = old_in_block;
        return array;
    }


    function tally_property(name) {
        if (option.properties && typeof property[name] !== 'number') {
            token.warn('unexpected_property_a', name);
        }
        if (property[name]) {
            property[name] += 1;
        } else {
            property[name] = 1;
        }
    }


// ECMAScript parser

    (function () {
        var x = symbol('(identifier)');
        x.nud = function () {
            var name = this.string,
                master = scope[name],
                writeable;

// If the master is not in scope, then we may have an undeclared variable.
// Check the predefined list. If it was predefined, create the global
// variable.

            if (!master) {
                writeable = predefined[name];
                if (typeof writeable === 'boolean') {
                    global_scope[name] = master = {
                        dead: false,
                        function: global_funct,
                        kind: 'var',
                        string: name,
                        writeable: writeable
                    };

// But if the variable is not in scope, and is not predefined, and if we are not
// in the global scope, then we have an undefined variable error.

                } else {
                    token.warn('used_before_a');
                }
            } else {
                this.master = master;
            }

// Annotate uses that cross scope boundaries.

            if (master) {
                if (master.kind === 'label') {
                    this.warn('a_label');
                } else {
                    if (master.dead === true || master.dead === funct) {
                        this.warn('a_scope');
                    }
                    master.used += 1;
                    if (master.function !== funct) {
                        if (master.function === global_funct) {
                            funct.global.push(name);
                        } else {
                            master.function.closure.push(name);
                            funct.outer.push(name);
                        }
                    }
                }
            }
            return this;
        };
        x.identifier = true;
    }());


// Build the syntax table by declaring the syntactic elements.

    type('(array)', 'array');
    type('(function)', 'function');
    type('(number)', 'number', return_this);
    type('(object)', 'object');
    type('(string)', 'string', return_this);
    type('(boolean)', 'boolean', return_this);
    type('(regexp)', 'regexp', return_this);

    ultimate('(begin)');
    ultimate('(end)');
    ultimate('(error)');
    postscript(symbol('}'));
    symbol(')');
    symbol(']');
    postscript(symbol('"'));
    postscript(symbol('\''));
    symbol(';');
    symbol(':');
    symbol(',');
    symbol('#');
    symbol('@');
    symbol('*/');
    postscript(reserve('case'));
    reserve('catch');
    postscript(reserve('default'));
    reserve('else');
    reserve('finally');

    reservevar('arguments', function (x) {
        if (strict_mode && funct === global_funct) {
            x.warn('strict');
        }
        funct.arguments = true;
    });
    reservevar('eval');
    constant('false', 'boolean');
    constant('Infinity', 'number');
    constant('NaN', 'number');
    constant('null', '');
    reservevar('this', function (x) {
        if (strict_mode && funct.statement && funct.name.charAt(0) > 'Z') {
            x.warn('strict');
        }
    });
    constant('true', 'boolean');
    constant('undefined', '');

    infix('?', 30, function (left, that) {
        step_in('?');
        that.first = expected_condition(expected_relation(left));
        that.second = expression(0);
        spaces();
        step_out();
        var colon = next_token;
        advance(':');
        step_in(':');
        spaces();
        that.third = expression(10);
        that.arity = 'ternary';
        if (are_similar(that.second, that.third)) {
            colon.warn('weird_ternary');
        } else if (are_similar(that.first, that.second)) {
            that.warn('use_or');
        }
        step_out();
        return that;
    });

    infix('||', 40, function (left, that) {
        function paren_check(that) {
            if (that.id === '&&' && !that.paren) {
                that.warn('and');
            }
            return that;
        }

        that.first = paren_check(expected_condition(expected_relation(left)));
        that.second = paren_check(expected_relation(expression(40)));
        if (are_similar(that.first, that.second)) {
            that.warn('weird_condition');
        }
        return that;
    });

    infix('&&', 50, function (left, that) {
        that.first = expected_condition(expected_relation(left));
        that.second = expected_relation(expression(50));
        if (are_similar(that.first, that.second)) {
            that.warn('weird_condition');
        }
        return that;
    });

    prefix('void', function (that) {
        that.first = expression(0);
        that.warn('expected_a_b', 'undefined', 'void');
        return that;
    });

    bitwise('|', 70);
    bitwise('^', 80);
    bitwise('&', 90);

    relation('==', '===');
    relation('===');
    relation('!=', '!==');
    relation('!==');
    relation('<');
    relation('>');
    relation('<=');
    relation('>=');

    bitwise('<<', 120);
    bitwise('>>', 120);
    bitwise('>>>', 120);

    infix('in', 120, function (left, that) {
        that.warn('infix_in');
        that.left = left;
        that.right = expression(130);
        return that;
    });
    infix('instanceof', 120);
    infix('+', 130, function (left, that) {
        if (left.id === '(number)') {
            if (left.number === 0) {
                left.warn('unexpected_a', '0');
            }
        } else if (left.id === '(string)') {
            if (left.string === '') {
                left.warn('expected_a_b', 'String', '\'\'');
            }
        }
        var right = expression(130);
        if (right.id === '(number)') {
            if (right.number === 0) {
                right.warn('unexpected_a', '0');
            }
        } else if (right.id === '(string)') {
            if (right.string === '') {
                right.warn('expected_a_b', 'String', '\'\'');
            }
        }
        if (left.id === right.id) {
            if (left.id === '(string)' || left.id === '(number)') {
                if (left.id === '(string)') {
                    left.string += right.string;
                    if (jx.test(left.string)) {
                        left.warn('url');
                    }
                } else {
                    left.number += right.number;
                }
                left.thru = right.thru;
                return left;
            }
        }
        that.first = left;
        that.second = right;
        return that;
    });
    prefix('+');
    prefix('+++', function () {
        token.warn('confusing_a');
        this.first = expression(150);
        this.arity = 'prefix';
        return this;
    });
    infix('+++', 130, function (left) {
        token.warn('confusing_a');
        this.first = left;
        this.second = expression(130);
        return this;
    });
    infix('-', 130, function (left, that) {
        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {
            left.warn('unexpected_a');
        }
        var right = expression(130);
        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {
            right.warn('unexpected_a');
        }
        if (left.id === right.id && left.id === '(number)') {
            left.number -= right.number;
            left.thru = right.thru;
            return left;
        }
        that.first = left;
        that.second = right;
        return that;
    });
    prefix('-');
    prefix('---', function () {
        token.warn('confusing_a');
        this.first = expression(150);
        this.arity = 'prefix';
        return this;
    });
    infix('---', 130, function (left) {
        token.warn('confusing_a');
        this.first = left;
        this.second = expression(130);
        return this;
    });
    infix('*', 140, function (left, that) {
        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {
            left.warn('unexpected_a');
        }
        var right = expression(140);
        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {
            right.warn('unexpected_a');
        }
        if (left.id === right.id && left.id === '(number)') {
            left.number *= right.number;
            left.thru = right.thru;
            return left;
        }
        that.first = left;
        that.second = right;
        return that;
    });
    infix('/', 140, function (left, that) {
        if ((left.id === '(number)' && left.number === 0) || left.id === '(string)') {
            left.warn('unexpected_a');
        }
        var right = expression(140);
        if ((right.id === '(number)' && (right.number === 0 || right.number === 1)) || right.id === '(string)') {
            right.warn('unexpected_a');
        }
        if (left.id === right.id && left.id === '(number)') {
            left.number /= right.number;
            left.thru = right.thru;
            return left;
        }
        that.first = left;
        that.second = right;
        return that;
    });
    infix('%', 140, function (left, that) {
        if ((left.id === '(number)' && (left.number === 0 || left.number === 1)) || left.id === '(string)') {
            left.warn('unexpected_a');
        }
        var right = expression(140);
        if ((right.id === '(number)' && right.number === 0) || right.id === '(string)') {
            right.warn('unexpected_a');
        }
        if (left.id === right.id && left.id === '(number)') {
            left.number %= right.number;
            left.thru = right.thru;
            return left;
        }
        that.first = left;
        that.second = right;
        return that;
    });

    suffix('++');
    prefix('++');

    suffix('--');
    prefix('--');
    prefix('delete', function (that) {
        one_space();
        var p = expression(0);
        if (!p || (p.id !== '.' && p.id !== '[')) {
            next_token.warn('deleted');
        }
        that.first = p;
        return that;
    });


    prefix('~', function (that) {
        no_space_only();
        if (!option.bitwise) {
            that.warn('unexpected_a');
        }
        that.first = expression(150);
        return that;
    });
    function banger(that) {
        no_space_only();
        that.first = expected_condition(expression(150));
        if (bang[that.first.id] === that || that.first.assign) {
            that.warn('confusing_a');
        }
        return that;
    }
    prefix('!', banger);
    prefix('!!', banger);
    prefix('typeof');
    prefix('new', function (that) {
        one_space();
        var c = expression(160), n, p, v;
        that.first = c;
        if (c.id !== 'function') {
            if (c.identifier) {
                switch (c.string) {
                case 'Object':
                    token.warn('use_object');
                    break;
                case 'Array':
                    if (next_token.id === '(') {
                        p = next_token;
                        p.first = this;
                        advance('(');
                        if (next_token.id !== ')') {
                            n = expression(0);
                            p.second = [n];
                            if (n.id === '(string)' || next_token.id === ',') {
                                p.warn('use_array');
                            }
                            while (next_token.id === ',') {
                                advance(',');
                                p.second.push(expression(0));
                            }
                        } else {
                            token.warn('use_array');
                        }
                        advance(')', p);
                        return p;
                    }
                    token.warn('use_array');
                    break;
                case 'Number':
                case 'String':
                case 'Boolean':
                case 'Math':
                case 'JSON':
                    c.warn('not_a_constructor');
                    break;
                case 'Function':
                    if (!option.evil) {
                        next_token.warn('function_eval');
                    }
                    break;
                case 'Date':
                case 'RegExp':
                case 'this':
                    break;
                default:
                    if (c.id !== 'function') {
                        v = c.string.charAt(0);
                        if (!option.newcap && (v < 'A' || v > 'Z')) {
                            token.warn('constructor_name_a');
                        }
                    }
                }
            } else {
                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {
                    token.warn('bad_constructor');
                }
            }
        } else {
            that.warn('weird_new');
        }
        if (next_token.id !== '(') {
            next_token.warn('missing_a', '()');
        }
        return that;
    });

    infix('(', 160, function (left, that) {
        var e, p;
        if (indent && indent.mode === 'expression') {
            no_space(prev_token, token);
        } else {
            no_space_only(prev_token, token);
        }
        if (!left.immed && left.id === 'function') {
            next_token.warn('wrap_immediate');
        }
        p = [];
        if (left.identifier) {
            if (left.string.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                if (left.string !== 'Number' && left.string !== 'String' &&
                        left.string !== 'Boolean' && left.string !== 'Date') {
                    if (left.string === 'Math') {
                        left.warn('not_a_function');
                    } else if (left.string === 'Object') {
                        token.warn('use_object');
                    } else if (left.string === 'Array' || !option.newcap) {
                        left.warn('missing_a', 'new');
                    }
                }
            } else if (left.string === 'JSON') {
                left.warn('not_a_function');
            }
        } else if (left.id === '.') {
            if (left.second.string === 'split' &&
                    left.first.id === '(string)') {
                left.second.warn('use_array');
            }
        }
        step_in();
        if (next_token.id !== ')') {
            no_space();
            for (;;) {
                edge();
                e = expression(10);
                if (left.string === 'Boolean' && (e.id === '!' || e.id === '~')) {
                    e.warn('weird_condition');
                }
                p.push(e);
                if (next_token.id !== ',') {
                    break;
                }
                comma();
            }
        }
        no_space();
        step_out(')', that);
        if (typeof left === 'object') {
            if (left.string === 'parseInt' && p.length === 1) {
                left.warn('radix');
            } else if (left.string === 'String' && p.length >= 1 && p[0].id === '(string)') {
                left.warn('unexpected_a');
            }
            if (!option.evil) {
                if (left.string === 'eval' || left.string === 'Function' ||
                        left.string === 'execScript') {
                    left.warn('evil');
                } else if (p[0] && p[0].id === '(string)' &&
                        (left.string === 'setTimeout' ||
                        left.string === 'setInterval')) {
                    left.warn('implied_evil');
                }
            }
            if (!left.identifier && left.id !== '.' && left.id !== '[' &&
                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&
                    left.id !== '?') {
                left.warn('bad_invocation');
            }
            if (left.id === '.') {
                if (p.length > 0 &&
                        left.first && left.first.first &&
                        are_similar(p[0], left.first.first)) {
                    if (left.second.string === 'call' ||
                            (left.second.string === 'apply' && (p.length === 1 ||
                            (p[1].arity === 'prefix' && p[1].id === '[')))) {
                        left.second.warn('unexpected_a');
                    }
                }
                if (left.second.string === 'toString') {
                    if (left.first.id === '(string)' || left.first.id === '(number)') {
                        left.second.warn('unexpected_a');
                    }
                }
            }
        }
        that.first = left;
        that.second = p;
        return that;
    }, true);

    prefix('(', function (that) {
        step_in('expression');
        no_space();
        edge();
        if (next_token.id === 'function') {
            next_token.immed = true;
        }
        var value = expression(0);
        value.paren = true;
        no_space();
        step_out(')', that);
        if (value.id === 'function') {
            switch (next_token.id) {
            case '(':
                next_token.warn('move_invocation');
                break;
            case '.':
            case '[':
                next_token.warn('unexpected_a');
                break;
            default:
                that.warn('bad_wrap');
            }
        } else if (!value.arity) {
            if (!option.closure || !that.comments) {
                that.warn('unexpected_a');
            }
        }
        return value;
    });

    infix('.', 170, function (left, that) {
        no_space(prev_token, token);
        no_space();
        var name = identifier();
        if (typeof name === 'string') {
            tally_property(name);
        }
        that.first = left;
        that.second = token;
        if (left && left.string === 'arguments' &&
                (name === 'callee' || name === 'caller')) {
            left.warn('avoid_a', 'arguments.' + name);
        } else if (!option.evil && left && left.string === 'document' &&
                (name === 'write' || name === 'writeln')) {
            left.warn('write_is_wrong');
        } else if (!option.stupid && syx.test(name)) {
            token.warn('sync_a');
        } else if (left && left.id === '{') {
            that.warn('unexpected_a');
        }
        if (!option.evil && (name === 'eval' || name === 'execScript')) {
            next_token.warn('evil');
        }
        return that;
    }, true);

    infix('[', 170, function (left, that) {
        var e, s;
        no_space_only(prev_token, token);
        no_space();
        step_in();
        edge();
        e = expression(0);
        switch (e.id) {
        case '(number)':
            if (e.id === '(number)' && left.id === 'arguments') {
                left.warn('use_param');
            }
            break;
        case '(string)':
            if (!option.evil &&
                    (e.string === 'eval' || e.string === 'execScript')) {
                e.warn('evil');
            } else if (!option.sub && ix.test(e.string)) {
                s = syntax[e.string];
                if (!s || !s.reserved) {
                    e.warn('subscript');
                }
            }
            tally_property(e.string);
            break;
        }
        if (left && (left.id === '{' || (left.id === '[' && left.arity === 'prefix'))) {
            that.warn('unexpected_a');
        }
        step_out(']', that);
        no_space(prev_token, token);
        that.first = left;
        that.second = e;
        return that;
    }, true);

    prefix('[', function (that) {
        that.first = [];
        step_in('array');
        while (next_token.id !== '(end)') {
            while (next_token.id === ',') {
                next_token.warn('unexpected_a');
                advance(',');
            }
            if (next_token.id === ']') {
                break;
            }
            indent.wrap = false;
            edge();
            that.first.push(expression(10));
            if (next_token.id === ',') {
                comma();
                if (next_token.id === ']') {
                    token.warn('unexpected_a');
                    break;
                }
            } else {
                break;
            }
        }
        step_out(']', that);
        return that;
    }, 170);


    function property_name() {
        var id = optional_identifier();
        if (!id) {
            if (next_token.id === '(string)') {
                id = next_token.string;
                advance();
            } else if (next_token.id === '(number)') {
                id = next_token.number.toString();
                advance();
            }
        }
        return id;
    }



    assignop('=');
    assignop('+=', '+');
    assignop('-=', '-');
    assignop('*=', '*');
    assignop('/=', '/').nud = function () {
        next_token.stop('slash_equal');
    };
    assignop('%=', '%');
    assignop('&=', '&');
    assignop('|=', '|');
    assignop('^=', '^');
    assignop('<<=', '<<');
    assignop('>>=', '>>');
    assignop('>>>=', '>>>');

    function function_parameters() {
        var id, parameters = [], paren = next_token;
        advance('(');
        token.function = funct;
        step_in();
        no_space();
        if (next_token.id !== ')') {
            for (;;) {
                edge();
                id = identifier();
                if (token.reserved) {
                    token.warn('expected_identifier_a_reserved');
                }
                define('parameter', token);
                parameters.push(id);
                token.init = true;
                token.writeable = true;
                if (next_token.id !== ',') {
                    break;
                }
                comma();
            }
        }
        no_space();
        step_out(')', paren);
        return parameters;
    }

    function do_function(func, name) {
        var old_funct = funct,
            old_option = option,
            old_scope = scope;
        scope = Object.create(old_scope);
        funct = {
            closure: [],
            global: [],
            level: old_funct.level + 1,
            line: next_token.line,
            loopage: 0,
            name: name || '\'' + (anonname || '').replace(nx, sanitize) + '\'',
            outer: [],
            scope: scope
        };
        funct.parameter = function_parameters();
        func.function = funct;
        option = Object.create(old_option);
        functions.push(funct);
        if (name) {
            func.name = name;
            func.string = name;
            define('function', func);
            func.init = true;
            func.used += 1;
        }
        func.writeable = false;
        one_space();
        func.block = block('function');
        Object.keys(scope).forEach(function (name) {
            var master = scope[name];
            if (!master.used && master.kind !== 'exception' &&
                    ((master.kind === 'var' && !option.unvar)
                    || (master.kind === 'parameter' && !option.unparam))) {
                master.warn('unused_a');
            } else if (!master.init && (master.kind !== 'var' || !option.unvar)) {
                master.warn('uninitialized_a');
            }
        });
        funct = old_funct;
        option = old_option;
        scope = old_scope;
    }

    prefix('{', function (that) {
        var get, i, j, name, set, seen = Object.create(null);
        that.first = [];
        step_in();
        while (next_token.id !== '}') {
            indent.wrap = false;

// JSLint recognizes the ES5 extension for get/set in object literals,
// but requires that they be used in pairs.

            edge();
            if (next_token.string === 'get' && peek().id !== ':') {
                get = next_token;
                advance('get');
                one_space_only();
                name = next_token;
                i = property_name();
                if (!i) {
                    next_token.stop('missing_property');
                }
                get.string = '';
                do_function(get);
                if (funct.loopage) {
                    get.warn('function_loop');
                }
                if (get.function.parameter.length) {
                    get.warn('parameter_a_get_b', get.function.parameter[0], i);
                }
                comma();
                set = next_token;
                spaces();
                edge();
                advance('set');
                set.string = '';
                one_space_only();
                j = property_name();
                if (i !== j) {
                    token.stop('expected_a_b', i, j || next_token.string);
                }
                do_function(set);
                if (set.block.length === 0) {
                    token.warn('missing_a', 'throw');
                }
                if (set.function.parameter.length === 0) {
                    set.stop('parameter_set_a', 'value');
                } else if (set.function.parameter[0] !== 'value') {
                    set.stop('expected_a_b', 'value',
                        set.function.parameter[0]);
                }
                name.first = [get, set];
            } else {
                name = next_token;
                i = property_name();
                if (typeof i !== 'string') {
                    next_token.stop('missing_property');
                }
                advance(':');
                spaces();
                name.first = expression(10);
            }
            that.first.push(name);
            if (seen[i] === true) {
                next_token.warn('duplicate_a', i);
            }
            seen[i] = true;
            tally_property(i);
            if (next_token.id !== ',') {
                break;
            }
            for (;;) {
                comma();
                if (next_token.id !== ',') {
                    break;
                }
                next_token.warn('unexpected_a');
            }
            if (next_token.id === '}') {
                token.warn('unexpected_a');
            }
        }
        step_out('}', that);
        return that;
    });

    stmt('{', function () {
        next_token.warn('statement_block');
        this.arity = 'statement';
        this.block = statements();
        this.disrupt = this.block.disrupt;
        advance('}', this);
        return this;
    });

    stmt('/*global', directive);
    stmt('/*globals', directive);
    stmt('/*jslint', directive);
    stmt('/*member', directive);
    stmt('/*members', directive);
    stmt('/*property', directive);
    stmt('/*properties', directive);

    stmt('var', function () {

// JavaScript does not have block scope. It only has function scope. So,
// declaring a variable in a block can have unexpected consequences.

// var.first will contain an array, the array containing name tokens
// and assignment tokens.

        var assign, id, name;

        if (funct.loopage) {
            next_token.warn('var_loop');
        } else if (funct.varstatement && !option.vars) {
            next_token.warn('combine_var');
        }
        if (funct !== global_funct) {
            funct.varstatement = true;
        }
        this.arity = 'statement';
        this.first = [];
        step_in('var');
        for (;;) {
            name = next_token;
            id = identifier(true);
            define('var', name);
            name.dead = funct;
            if (next_token.id === '=') {
                if (funct === global_funct && !name.writeable) {
                    name.warn('read_only');
                }
                assign = next_token;
                assign.first = name;
                spaces();
                advance('=');
                spaces();
                if (next_token.id === 'undefined') {
                    token.warn('unnecessary_initialize', id);
                }
                if (peek(0).id === '=' && next_token.identifier) {
                    next_token.stop('var_a_not');
                }
                assign.second = expression(0);
                assign.arity = 'infix';
                name.init = true;
                this.first.push(assign);
            } else {
                this.first.push(name);
            }
            name.dead = false;
            name.writeable = true;
            if (next_token.id !== ',') {
                break;
            }
            comma();
            indent.wrap = false;
            if (var_mode && next_token.line === token.line &&
                    this.first.length === 1) {
                var_mode = null;
                indent.open = false;
                indent.at -= option.indent;
            }
            spaces();
            edge();
        }
        var_mode = null;
        step_out();
        return this;
    });

    stmt('function', function () {
        one_space();
        if (in_block) {
            token.warn('function_block');
        }
        var name = next_token,
            id = identifier(true);
        define('var', name);
        if (!name.writeable) {
            name.warn('read_only');
        }
        name.init = true;
        name.statement = true;
        no_space();
        this.arity = 'statement';
        do_function(this, id);
        if (next_token.id === '(' && next_token.line === token.line) {
            next_token.stop('function_statement');
        }
        return this;
    });

    prefix('function', function (that) {
        var id = optional_identifier(true), name;
        if (id) {
            name = token;
            no_space();
        } else {
            id = '';
            one_space();
        }
        do_function(that, id);
        if (name) {
            name.function = that.function;
        }
        if (funct.loopage) {
            that.warn('function_loop');
        }
        switch (next_token.id) {
        case ';':
        case '(':
        case ')':
        case ',':
        case ']':
        case '}':
        case ':':
        case '(end)':
            break;
        case '.':
            if (peek().string !== 'bind' || peek(1).id !== '(') {
                next_token.warn('unexpected_a');
            }
            break;
        default:
            next_token.stop('unexpected_a');
        }
        that.arity = 'function';
        return that;
    });

    stmt('if', function () {
        var paren = next_token;
        one_space();
        advance('(');
        step_in('control');
        no_space();
        edge();
        this.arity = 'statement';
        this.first = expected_condition(expected_relation(expression(0)));
        no_space();
        step_out(')', paren);
        one_space();
        this.block = block('if');
        if (next_token.id === 'else') {
            if (this.block.disrupt) {
                next_token.warn(this.elif ? 'use_nested_if' : 'unnecessary_else');
            }
            one_space();
            advance('else');
            one_space();
            if (next_token.id === 'if') {
                next_token.elif = true;
                this.else = statement(true);
            } else {
                this.else = block('else');
            }
            if (this.else.disrupt && this.block.disrupt) {
                this.disrupt = true;
            }
        }
        return this;
    });

    stmt('try', function () {

// try.first    The catch variable
// try.second   The catch clause
// try.third    The finally clause
// try.block    The try block

        var exception_variable, paren;
        one_space();
        this.arity = 'statement';
        this.block = block('try');
        if (next_token.id === 'catch') {
            one_space();
            advance('catch');
            one_space();
            paren = next_token;
            advance('(');
            step_in('control');
            no_space();
            edge();
            exception_variable = next_token;
            this.first = identifier();
            define('exception', exception_variable);
            exception_variable.init = true;
            no_space();
            step_out(')', paren);
            one_space();
            this.second = block('catch');
            if (this.second.length) {
                if (this.first === 'ignore') {
                    exception_variable.warn('unexpected_a');
                }
            } else {
                if (this.first !== 'ignore') {
                    exception_variable.warn('expected_a_b', 'ignore',
                        exception_variable.string);
                }
            }
            exception_variable.dead = true;
        }
        if (next_token.id === 'finally') {
            one_space();
            advance('finally');
            one_space();
            this.third = block('finally');
        } else if (!this.second) {
            next_token.stop('expected_a_b', 'catch', artifact());
        }
        return this;
    });

    labeled_stmt('while', function () {
        one_space();
        var paren = next_token;
        funct.loopage += 1;
        advance('(');
        step_in('control');
        no_space();
        edge();
        this.arity = 'statement';
        this.first = expected_relation(expression(0));
        if (this.first.id !== 'true') {
            expected_condition(this.first, 'unexpected_a');
        }
        no_space();
        step_out(')', paren);
        one_space();
        this.block = block('while');
        if (this.block.disrupt) {
            prev_token.warn('strange_loop');
        }
        funct.loopage -= 1;
        return this;
    });

    reserve('with');

    labeled_stmt('switch', function () {

// switch.first         the switch expression
// switch.second        the array of cases. A case is 'case' or 'default' token:
//    case.first        the array of case expressions
//    case.second       the array of statements
// If all of the arrays of statements are disrupt, then the switch is disrupt.

        var cases = [],
            old_in_block = in_block,
            particular,
            that = token,
            the_case = next_token;

        function find_duplicate_case(value) {
            if (are_similar(particular, value)) {
                value.warn('duplicate_a');
            }
        }

        one_space();
        advance('(');
        no_space();
        step_in();
        this.arity = 'statement';
        this.first = expected_condition(expected_relation(expression(0)));
        no_space();
        step_out(')', the_case);
        one_space();
        advance('{');
        step_in();
        in_block = true;
        this.second = [];
        if (that.from !== next_token.from && !option.white) {
            next_token.warn('expected_a_at_b_c', next_token.string, that.from, next_token.from);
        }
        while (next_token.id === 'case') {
            the_case = next_token;
            the_case.first = [];
            the_case.arity = 'case';
            for (;;) {
                spaces();
                edge('case');
                advance('case');
                one_space();
                particular = expression(0);
                cases.forEach(find_duplicate_case);
                cases.push(particular);
                the_case.first.push(particular);
                if (particular.id === 'NaN') {
                    particular.warn('unexpected_a');
                }
                no_space_only();
                advance(':');
                if (next_token.id !== 'case') {
                    break;
                }
            }
            spaces();
            the_case.second = statements();
            if (the_case.second && the_case.second.length > 0) {
                if (!the_case.second[the_case.second.length - 1].disrupt) {
                    next_token.warn('missing_a_after_b', 'break', 'case');
                }
            } else {
                next_token.warn('empty_case');
            }
            this.second.push(the_case);
        }
        if (this.second.length === 0) {
            next_token.warn('missing_a', 'case');
        }
        if (next_token.id === 'default') {
            spaces();
            the_case = next_token;
            the_case.arity = 'case';
            edge('case');
            advance('default');
            no_space_only();
            advance(':');
            spaces();
            the_case.second = statements();
            if (the_case.second && the_case.second.length > 0) {
                this.disrupt = the_case.second[the_case.second.length - 1].disrupt;
            } else {
                the_case.warn('empty_case');
            }
            this.second.push(the_case);
        }
        if (this.break) {
            this.disrupt = false;
        }
        spaces();
        step_out('}', this);
        in_block = old_in_block;
        return this;
    });

    stmt('debugger', function () {
        if (!option.debug) {
            this.warn('unexpected_a');
        }
        this.arity = 'statement';
        return this;
    });

    labeled_stmt('do', function () {
        funct.loopage += 1;
        one_space();
        this.arity = 'statement';
        this.block = block('do');
        if (this.block.disrupt) {
            prev_token.warn('strange_loop');
        }
        one_space();
        advance('while');
        var paren = next_token;
        one_space();
        advance('(');
        step_in();
        no_space();
        edge();
        this.first = expected_condition(expected_relation(expression(0)), 'unexpected_a');
        no_space();
        step_out(')', paren);
        funct.loopage -= 1;
        return this;
    });

    labeled_stmt('for', function () {

        var blok, filter, master, ok = false, paren = next_token, value;
        this.arity = 'statement';
        funct.loopage += 1;
        advance('(');
        if (next_token.id === ';') {
            no_space();
            advance(';');
            no_space();
            advance(';');
            no_space();
            advance(')');
            blok = block('for');
        } else {
            step_in('control');
            spaces(this, paren);
            no_space();
            if (next_token.id === 'var') {
                next_token.stop('move_var');
            }
            edge();
            if (peek(0).id === 'in') {
                this.forin = true;
                value = expression(1000);
                master = value.master;
                if (!master) {
                    value.stop('bad_in_a');
                }
                if (master.kind !== 'var' || master.function !== funct ||
                        !master.writeable || master.dead) {
                    value.warn('bad_in_a');
                }
                master.init = true;
                master.used -= 1;
                this.first = value;
                advance('in');
                this.second = expression(20);
                step_out(')', paren);
                blok = block('for');
                if (!option.forin) {
                    if (blok.length === 1 && typeof blok[0] === 'object') {
                        if (blok[0].id === 'if' && !blok[0].else) {
                            filter = blok[0].first;
                            while (filter.id === '&&') {
                                filter = filter.first;
                            }
                            switch (filter.id) {
                            case '===':
                            case '!==':
                                ok = filter.first.id === '['
                                    ? are_similar(filter.first.first, this.second) &&
                                        are_similar(filter.first.second, this.first)
                                    : filter.first.id === 'typeof' &&
                                        filter.first.first.id === '[' &&
                                        are_similar(filter.first.first.first, this.second) &&
                                        are_similar(filter.first.first.second, this.first);
                                break;
                            case '(':
                                ok = filter.first.id === '.' && ((
                                    are_similar(filter.first.first, this.second) &&
                                    filter.first.second.string === 'hasOwnProperty' &&
                                    are_similar(filter.second[0], this.first)
                                ) || (
                                    filter.first.first.id === '.' &&
                                    filter.first.first.first.first &&
                                    filter.first.first.first.first.string === 'Object' &&
                                    filter.first.first.first.id === '.' &&
                                    filter.first.first.first.second.string === 'prototype' &&
                                    filter.first.first.second.string === 'hasOwnProperty' &&
                                    filter.first.second.string === 'call' &&
                                    are_similar(filter.second[0], this.second) &&
                                    are_similar(filter.second[1], this.first)
                                ));
                                break;
                            }
                        } else if (blok[0].id === 'switch') {
                            ok = blok[0].id === 'switch' &&
                                blok[0].first.id === 'typeof' &&
                                blok[0].first.first.id === '[' &&
                                are_similar(blok[0].first.first.first, this.second) &&
                                are_similar(blok[0].first.first.second, this.first);
                        }
                    }
                    if (!ok) {
                        this.warn('for_if');
                    }
                }
            } else {
                edge();
                this.first = [];
                for (;;) {
                    this.first.push(expression(0, 'for'));
                    if (next_token.id !== ',') {
                        break;
                    }
                    comma();
                }
                semicolon();
                edge();
                this.second = expected_relation(expression(0));
                if (this.second.id !== 'true') {
                    expected_condition(this.second, 'unexpected_a');
                }
                semicolon(token);
                if (next_token.id === ';') {
                    next_token.stop('expected_a_b', ')', ';');
                }
                this.third = [];
                edge();
                for (;;) {
                    this.third.push(expression(0, 'for'));
                    if (next_token.id !== ',') {
                        break;
                    }
                    comma();
                }
                no_space();
                step_out(')', paren);
                one_space();
                blok = block('for');
            }
        }
        if (blok.disrupt) {
            prev_token.warn('strange_loop');
        }
        this.block = blok;
        funct.loopage -= 1;
        return this;
    });

    function optional_label(that) {
        var label = next_token.string,
            master;
        that.arity = 'statement';
        if (!funct.breakage || (!option.continue && that.id === 'continue')) {
            that.warn('unexpected_a');
        } else if (next_token.identifier && token.line === next_token.line) {
            one_space_only();
            master = scope[label];
            if (!master || master.kind !== 'label') {
                next_token.warn('not_a_label');
            } else if (master.dead || master.function !== funct) {
                next_token.warn('not_a_scope');
            } else {
                master.used += 1;
                if (that.id === 'break') {
                    master.statement.break = true;
                }
                if (funct.breakage[funct.breakage.length - 1] === master.statement) {
                    next_token.warn('unexpected_a');
                }
            }
            that.first = next_token;
            advance();
        } else {
            if (that.id === 'break') {
                funct.breakage[funct.breakage.length - 1].break = true;
            }
        }
        return that;

    }

    disrupt_stmt('break', function () {
        return optional_label(this);
    });

    disrupt_stmt('continue', function () {
        return optional_label(this);
    });

    disrupt_stmt('return', function () {
        if (funct === global_funct) {
            this.warn('unexpected_a');
        }
        this.arity = 'statement';
        if (next_token.id !== ';' && next_token.line === token.line) {
            if (option.closure) {
                spaces();
            } else {
                one_space_only();
            }
            if (next_token.id === '/' || next_token.id === '(regexp)') {
                next_token.warn('wrap_regexp');
            }
            this.first = expression(0);
            if (this.first.assign) {
                this.first.warn('unexpected_a');
            }
        }
        return this;
    });

    disrupt_stmt('throw', function () {
        this.arity = 'statement';
        one_space_only();
        this.first = expression(20);
        return this;
    });


//  Superfluous reserved words

    reserve('class');
    reserve('const');
    reserve('enum');
    reserve('export');
    reserve('extends');
    reserve('import');
    reserve('super');

// Harmony reserved words

    reserve('implements');
    reserve('interface');
    reserve('let');
    reserve('package');
    reserve('private');
    reserve('protected');
    reserve('public');
    reserve('static');
    reserve('yield');


// Parse JSON

    function json_value() {

        function json_object() {
            var brace = next_token, object = Object.create(null);
            advance('{');
            if (next_token.id !== '}') {
                while (next_token.id !== '(end)') {
                    while (next_token.id === ',') {
                        next_token.warn('unexpected_a');
                        advance(',');
                    }
                    if (next_token.id !== '(string)') {
                        next_token.warn('expected_string_a');
                    }
                    if (object[next_token.string] === true) {
                        next_token.warn('duplicate_a');
                    } else if (next_token.string === '__proto__') {
                        next_token.warn('dangling_a');
                    } else {
                        object[next_token.string] = true;
                    }
                    advance();
                    advance(':');
                    json_value();
                    if (next_token.id !== ',') {
                        break;
                    }
                    advance(',');
                    if (next_token.id === '}') {
                        token.warn('unexpected_a');
                        break;
                    }
                }
            }
            advance('}', brace);
        }

        function json_array() {
            var bracket = next_token;
            advance('[');
            if (next_token.id !== ']') {
                while (next_token.id !== '(end)') {
                    while (next_token.id === ',') {
                        next_token.warn('unexpected_a');
                        advance(',');
                    }
                    json_value();
                    if (next_token.id !== ',') {
                        break;
                    }
                    advance(',');
                    if (next_token.id === ']') {
                        token.warn('unexpected_a');
                        break;
                    }
                }
            }
            advance(']', bracket);
        }

        switch (next_token.id) {
        case '{':
            json_object();
            break;
        case '[':
            json_array();
            break;
        case 'true':
        case 'false':
        case 'null':
        case '(number)':
        case '(string)':
            advance();
            break;
        case '-':
            advance('-');
            no_space_only();
            advance('(number)');
            break;
        default:
            next_token.stop('unexpected_a');
        }
    }


// The actual JSLINT function itself.

    itself = function JSLint(the_source, the_option) {

        var i, predef, tree;
        itself.errors = [];
        itself.tree = '';
        itself.properties = '';
        begin = prev_token = token = next_token =
            Object.create(syntax['(begin)']);
        tokens = [];
        predefined = Object.create(null);
        add_to_predefined(standard);
        property = Object.create(null);
        if (the_option) {
            option = Object.create(the_option);
            predef = option.predef;
            if (predef) {
                if (Array.isArray(predef)) {
                    for (i = 0; i < predef.length; i += 1) {
                        predefined[predef[i]] = true;
                    }
                } else if (typeof predef === 'object') {
                    add_to_predefined(predef);
                }
            }
        } else {
            option = Object.create(null);
        }
        option.indent = +option.indent || 4;
        option.maxerr = +option.maxerr || 50;
        global_scope = scope = Object.create(null);
        global_funct = funct = {
            scope: scope,
            loopage: 0,
            level: 0
        };
        functions = [funct];
        block_var = [];

        comments = [];
        comments_off = false;
        in_block = false;
        indent = null;
        json_mode = false;
        lookahead = [];
        node_js = false;
        prereg = true;
        strict_mode = false;
        var_mode = null;
        warnings = 0;
        lex.init(the_source);

        assume();

        try {
            advance();
            if (next_token.id === '(number)') {
                next_token.stop('unexpected_a');
            } else {
                switch (next_token.id) {
                case '{':
                case '[':
                    comments_off = true;
                    json_mode = true;
                    json_value();
                    break;
                default:

// If the first token is a semicolon, ignore it. This is sometimes used when
// files are intended to be appended to files that may be sloppy. A sloppy
// file may be depending on semicolon insertion on its last line.

                    step_in(1);
                    if (next_token.id === ';' && !node_js) {
                        next_token.edge = true;
                        advance(';');
                    }
                    tree = statements();
                    begin.first = tree;
                    itself.tree = begin;
                    if (tree.disrupt) {
                        prev_token.warn('weird_program');
                    }
                }
            }
            indent = null;
            advance('(end)');
            itself.property = property;
        } catch (e) {
            if (e) {        // ~~
                itself.errors.push({
                    reason    : e.message,
                    line      : e.line || next_token.line,
                    character : e.character || next_token.from
                }, null);
            }
        }
        return itself.errors.length === 0;
    };

    function unique(array) {
        array = array.sort();
        var i, length = 0, previous, value;
        for (i = 0; i < array.length; i += 1) {
            value = array[i];
            if (value !== previous) {
                array[length] = value;
                previous = value;
                length += 1;
            }
        }
        array.length = length;
        return array;
    }

// Data summary.

    itself.data = function () {
        var data = {functions: []},
            function_data,
            i,
            the_function,
            the_scope;
        data.errors = itself.errors;
        data.json = json_mode;
        data.global = unique(Object.keys(global_scope));

        function selects(name) {
            var kind = the_scope[name].kind;
            switch (kind) {
            case 'var':
            case 'exception':
            case 'label':
                function_data[kind].push(name);
                break;
            }
        }

        for (i = 1; i < functions.length; i += 1) {
            the_function = functions[i];
            function_data = {
                name: the_function.name,
                line: the_function.line,
                level: the_function.level,
                parameter: the_function.parameter,
                var: [],
                exception: [],
                closure: unique(the_function.closure),
                outer: unique(the_function.outer),
                global: unique(the_function.global),
                label: []
            };
            the_scope = the_function.scope;
            Object.keys(the_scope).forEach(selects);
            function_data.var.sort();
            function_data.exception.sort();
            function_data.label.sort();
            data.functions.push(function_data);
        }
        data.tokens = tokens;
        return data;
    };

    itself.error_report = function (data) {
        var evidence, i, output = [], warning;
        if (data.errors.length) {
            if (data.json) {
                output.push('<cite>JSON: bad.</cite><br>');
            }
            for (i = 0; i < data.errors.length; i += 1) {
                warning = data.errors[i];
                if (warning) {
                    evidence = warning.evidence || '';
                    output.push('<cite>');
                    if (isFinite(warning.line)) {
                        output.push('<address>line ' +
                            String(warning.line) +
                            ' character ' + String(warning.character) +
                            '</address>');
                    }
                    output.push(warning.reason.entityify() + '</cite>');
                    if (evidence) {
                        output.push('<pre>' + evidence.entityify() + '</pre>');
                    }
                }
            }
        }
        return output.join('');
    };


    itself.report = function (data) {
        var dl, i, j, names, output = [], the_function;

        function detail(h, array) {
            var comma_needed = false;
            if (array.length) {
                output.push("<dt>" + h + "</dt><dd>");
                array.forEach(function (item) {
                    output.push((comma_needed ? ', ' : '') + item);
                    comma_needed = true;
                });
                output.push("</dd>");
            }
        }

        output.push('<dl class=level0>');
        if (data.global.length) {
            detail('global', data.global);
            dl = true;
        } else if (data.json) {
            if (!data.errors.length) {
                output.push("<dt>JSON: good.</dt>");
            }
        } else {
            output.push("<dt><i>No new global variables introduced.</i></dt>");
        }
        if (dl) {
            output.push("</dl>");
        } else {
            output[0] = '';
        }

        if (data.functions) {
            for (i = 0; i < data.functions.length; i += 1) {
                the_function = data.functions[i];
                names = [];
                if (the_function.params) {
                    for (j = 0; j < the_function.params.length; j += 1) {
                        names[j] = the_function.params[j].string;
                    }
                }
                output.push('<dl class=level' + the_function.level +
                    '><address>line ' + String(the_function.line) +
                    '</address>' + the_function.name.entityify());
                detail('parameter', the_function.parameter);
                detail('variable', the_function.var);
                detail('exception', the_function.exception);
                detail('closure', the_function.closure);
                detail('outer', the_function.outer);
                detail('global', the_function.global);
                detail('label', the_function.label);
                output.push('</dl>');
            }
        }
        return output.join('');
    };

    itself.properties_report = function (property) {
        if (!property) {
            return '';
        }
        var i,
            key,
            keys = Object.keys(property).sort(),
            mem = '   ',
            name,
            not_first = false,
            output = ['/*properties'];
        for (i = 0; i < keys.length; i += 1) {
            key = keys[i];
            if (property[key] > 0) {
                if (not_first) {
                    mem += ',';
                }
                name = ix.test(key)
                    ? key
                    : '\'' + key.replace(nx, sanitize) + '\'';
                if (mem.length + name.length >= 80) {
                    output.push(mem);
                    mem = '    ';
                } else {
                    mem += ' ';
                }
                mem += name;
                not_first = true;
            }
        }
        output.push(mem, '*/\n');
        return output.join('\n');
    };

    itself.color = function (data) {
        var from,
            i = 1,
            level,
            line,
            result = [],
            thru,
            data_token = data.tokens[0];
        while (data_token && data_token.id !== '(end)') {
            from = data_token.from;
            line = data_token.line;
            thru = data_token.thru;
            level = data_token.function.level;
            do {
                thru = data_token.thru;
                data_token = data.tokens[i];
                i += 1;
            } while (data_token && data_token.line === line &&
                    data_token.from - thru < 5 &&
                    level === data_token.function.level);
            result.push({
                line: line,
                level: level,
                from: from,
                thru: thru
            });
        }
        return result;
    };

    itself.jslint = itself;

    itself.edition = '2014-07-08';

    return itself;
}());
core.JSLint = function JSLint() {
    "use strict";
    this.JSLINT = JSLINT;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\LazyProperty.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/

// TODO Apparently newer closure compilers do a better job with generics

/**
 * Lazily loaded property. The value is loaded using the valueLoader and cached
 * the first time it's requested. Subsequent requests will return the cached value.
 * Calling reset will clear the cached value, causing the next value request
 * to load a new value via the valueLoader.
 *
 * @constructor
 * @template T
 * @param {!function():Object} valueLoader Property value loader
 */
core.LazyProperty = function (valueLoader) {
    "use strict";
    var cachedValue,
        valueLoaded = false;

    /**
     * @return {T}
     */
    this.value = function() {
        if (!valueLoaded) {
            cachedValue = valueLoader();
            valueLoaded = true;
        }
        return cachedValue;
    };

    /**
     * @return {undefined}
     */
    this.reset = function() {
        valueLoaded = false;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\LoopWatchDog.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core,runtime */

/**
 * An iterator that iterators through positions in a DOM tree.
 * @constructor
 * @param {!number} timeout
 * @param {!number=} maxChecks
 */
core.LoopWatchDog = function LoopWatchDog(timeout, maxChecks) {
    "use strict";
    var startTime = Date.now(),
        /**@type{!number}*/
        checks = 0;
    function check() {
        var t;
        if (timeout) {
            t = Date.now();
            if (t - startTime > timeout) {
                runtime.log("alert", "watchdog timeout");
                throw "timeout!";
            }
        }
        if (maxChecks > 0) {
            checks += 1;
            if (checks > maxChecks) {
                runtime.log("alert", "watchdog loop overflow");
                throw "loop overflow";
            }
        }
    }
    this.check = check;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\NodeFilterChain.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, NodeFilter*/

/**
 * @constructor
 * @implements NodeFilter
 * @param {!Array.<!NodeFilter>} filters
 */
core.NodeFilterChain = function (filters) {
    "use strict";
    var FILTER_REJECT = NodeFilter.FILTER_REJECT,
        FILTER_ACCEPT = NodeFilter.FILTER_ACCEPT;

    /**
     * @param {!Node} node
     * @return {!number}
     */
    this.acceptNode = function (node) {
        var i;
        for (i = 0; i < filters.length; i += 1) {
            if (filters[i].acceptNode(node) === FILTER_REJECT) {
                return FILTER_REJECT;
            }
        }
        return FILTER_ACCEPT;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\PositionFilter.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core*/
/*jslint emptyblock: true, unparam: true*/

/**
 * @interface
 */
core.PositionFilter = function PositionFilter() {"use strict"; };
/**
 * @enum {number}
 */
core.PositionFilter.FilterResult = {
    FILTER_ACCEPT: 1,
    FILTER_REJECT: 2,
    FILTER_SKIP:   3
};
/**
 * @param {!core.PositionIterator} point
 * @return {!core.PositionFilter.FilterResult}
 */
core.PositionFilter.prototype.acceptPosition = function (point) {"use strict"; };

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\PositionFilterChain.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <aditya.bhatt@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core*/
/*jslint emptyblock: true, unparam: true*/

/**
 * A structure that acts like a filter for all purposes,
 * and also can be combined with other instances of it's own kind or other filters.
 * @constructor
 * @implements {core.PositionFilter}
 */
core.PositionFilterChain = function PositionFilterChain() {
    "use strict";

    var /**@type{!Array.<!core.PositionFilter|!core.PositionFilterChain>}*/
        filterChain = [],
        /**@const*/
        FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT,
        /**@const*/
        FILTER_REJECT  = core.PositionFilter.FilterResult.FILTER_REJECT;

    /**
     * Returns accept if all filters in the chain accept the position, else reject.
     * @param {!core.PositionIterator} iterator
     * @return {!core.PositionFilter.FilterResult}
     */
    this.acceptPosition = function (iterator) {
        var i;
        for (i = 0; i < filterChain.length; i += 1) {
            if (filterChain[i].acceptPosition(iterator) === FILTER_REJECT) {
                return FILTER_REJECT;
            }
        }
        return FILTER_ACCEPT;
    };

    /**
     * Adds a filter to the filter chain.
     * @param {!core.PositionFilter|!core.PositionFilterChain} filterInstance
     * @return {undefined}
     */
    this.addFilter = function (filterInstance) {
        filterChain.push(filterInstance);
    };

};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\PositionIterator.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, NodeFilter, runtime, core*/

/**
 * An iterator that iterators through positions in a DOM tree.
 * Positions in the DOM tree are places between nodes and between characters.
 * Undesired positions can be avoided by passing a filter to constructor of the
 * PositionIterator.
 * In the following example '|' designates positions that an unfiltered
 * PositionIterator would visit.
 *
 *  <a>|<b>|<c>|a|b|</c>|a|<a>|</a>|</b>|</a>
 *
 * Certain positions are considered equivalent in by the PositionIterator.
 * Position 0 in a Text node is the same as the position preceding the Text node
 * in the parent node. The last position in a Text node is considered equal to
 * the subsequent position in the parent node. As such, these two Text node
 * positions are ommitted from the PositionIterator's traversal throught the
 * DOM. If the PositionIterator is set to a first or last position in a Text
 * node, it is instead set the equivalent position in the parent node.
 * Omitting the first and last Text node positions serves two functions:
 *  - It ensures that the number of iterated steps is independent of how
 *    characters are split up over text nodes.
 *  - The iterator avoids positions that not distinguised by the API for
 *    range and selections purposes.
 *
 *
 * @constructor
 * @param {!Node} root
 * @param {!number=} whatToShow
 * @param {!NodeFilter=} filter
 * @param {!boolean=} expandEntityReferences
 */
core.PositionIterator = function PositionIterator(root, whatToShow, filter,
        expandEntityReferences) {
    "use strict";
    /*
     * Implementation notes.
     * The position of the positioniterator is defined by two internal
     * variables: walker and currentPos. The walker is an instance of TreeWalker
     * which has a member called currentNode of type Node.
     * Since the implementation uses a Node and an offset, it is comparable to
     * the parameters that go into Range and Selection related functions.
     * If the currentNode is a Text node, the variable currentPos gives the
     * offset in the node.
     * If the currentNode is an Element node, the variable currentPos can only
     * have the values 0 or 1. The value 0 means that the iterator is at the
     * position just before the currentNode. A value of 1 means that the
     * iterator is at the last position inside the currentNode.
     */
    var self = this,
        /**@type{!TreeWalker}*/
        walker,
        /**@type{!number}*/
        currentPos,
        /**@type{!function(?Node):!number}*/
        nodeFilter,
        TEXT_NODE = Node.TEXT_NODE,
        ELEMENT_NODE = Node.ELEMENT_NODE,
        FILTER_ACCEPT = NodeFilter.FILTER_ACCEPT,
        FILTER_REJECT = NodeFilter.FILTER_REJECT;

    /**
     * Empty text nodes are not considered to be a valid position for the
     * positioniterator. They should be filtered out in all cases.
     * @constructor
     * @implements NodeFilter
     */
    function EmptyTextNodeFilter() {
        /**
         * @param {?Node} node
         * @return {!number}
         */
        this.acceptNode = function (node) {
            var text = /**@type{!Text}*/(node);
            if (!node || (node.nodeType === TEXT_NODE && text.length === 0)) {
                return FILTER_REJECT;
            }
            return FILTER_ACCEPT;
        };
    }
    /**
     * @constructor
     * @implements NodeFilter
     * @param {!NodeFilter} filter
     */
    function FilteredEmptyTextNodeFilter(filter) {
        /**
         * @param {?Node} node
         * @return {!number}
         */
        this.acceptNode = function (node) {
            var text = /**@type{!Text}*/(node);
            if (!node || (node.nodeType === TEXT_NODE && text.length === 0)) {
                return FILTER_REJECT;
            }
            return filter.acceptNode(node);
        };
    }

    /**
     * @return {!boolean}
     */
    this.nextPosition = function () {
        var currentNode = walker.currentNode,
            nodeType = currentNode.nodeType,
            text = /**@type{!Text}*/(currentNode);
        if (currentNode === root) {
            return false;
        }
        if (currentPos === 0 && nodeType === ELEMENT_NODE) {
            // step inside an element
            if (walker.firstChild() === null) {
                currentPos = 1;
            }
        } else if (nodeType === TEXT_NODE
                && currentPos + 1 < text.length) {
            // advance inside a text node
            currentPos += 1;
        } else {
            if (walker.nextSibling() !== null) {
                currentPos = 0;
            } else if (walker.parentNode()) {
                currentPos = 1;
            } else {
                return false;
            }
        }
        return true;
    };
    function setAtEnd() {
        var text = /**@type{!Text}*/(walker.currentNode),
            type = text.nodeType;
        if (type === TEXT_NODE) {
            currentPos = text.length - 1;
        } else {
            currentPos = (type === ELEMENT_NODE) ? 1 : 0;
        }
    }
    /**
     * @return {!boolean}
     */
    function previousNode() {
        if (walker.previousSibling() === null) {
            if (!walker.parentNode() || walker.currentNode === root) {
                walker.firstChild();
                return false;
            }
            currentPos = 0;
        } else {
            setAtEnd();
        }
        return true;
    }
    /**
     * Move the iterator to the previous position.
     * If the iterator is already at the first position, it is not moved and
     * false is returned instead of true.
     * @return {!boolean}
     */
    this.previousPosition = function () {
        var moved = true,
            currentNode = walker.currentNode;
        if (currentPos === 0) {
            moved = previousNode();
        } else if (currentNode.nodeType === TEXT_NODE) {
            currentPos -= 1;
        } else if (walker.lastChild() !== null) {
            setAtEnd();
        } else if (currentNode === root) {
            moved = false;
        } else {
            currentPos = 0;
        }
        return moved;
    };
    /**
     * This function exposes class internals and should be avoided.
     */
    this.previousNode = previousNode;
    /**
     * Return the container for the current position.
     * @return {!Element|!Text}
     */
    this.container = function () {
        var n = /**@type{!Element|!Text}*/(walker.currentNode),
            t = n.nodeType;
        if (currentPos === 0 && t !== TEXT_NODE) {
            n = /**@type{!Element|!Text}*/(n.parentNode);
        }
        return n;
    };
    /**
     * Return the node to the right of the current iterator position.
     * If the iterator is placed between two characters in a text node,
     * the text node will be returned.
     * If there is no right neighbor in the container node, then null is
     * returned.
     * Only filtered nodes will be returned.
     * @return {?Node}
     */
    this.rightNode = function () {
        var n = walker.currentNode,
            text = /**@type{!Text}*/(n),
            nodeType = n.nodeType;
        if (nodeType === TEXT_NODE && currentPos === text.length) {
            n = n.nextSibling;
            while (n && nodeFilter(n) !== FILTER_ACCEPT) {
                n = n.nextSibling;
            }
        } else if (nodeType === ELEMENT_NODE && currentPos === 1) {
            n = null;
        }
        return n;
    };
    /**
     * Return the node to the left of the current iterator position.
     * See rightNode().
     * @return {?Node}
     */
    this.leftNode = function () {
        var n = walker.currentNode;
        if (currentPos === 0) {
            n = n.previousSibling;
            while (n && nodeFilter(n) !== FILTER_ACCEPT) {
                n = n.previousSibling;
            }
        } else if (n.nodeType === ELEMENT_NODE) {
            n = n.lastChild;
            while (n && nodeFilter(n) !== FILTER_ACCEPT) {
                n = n.previousSibling;
            }
        }
        return n;
    };
    /**
     * This function exposes class internals and should be avoided.
     * @return {!Element|!Text}
     */
    this.getCurrentNode = function () {
        var n = /**@type{!Element|!Text}*/(walker.currentNode);
        return n;
    };
    /**
     * Returns the current position within the container of the iterator.
     * This function is useful for communication iterator position with
     * components that do not use a filter.
     * @return {!number}
     */
    this.unfilteredDomOffset = function () {
        if (walker.currentNode.nodeType === TEXT_NODE) {
            return currentPos;
        }
        var c = 0,
            n = walker.currentNode;
        if (currentPos === 1) {
            n = n.lastChild;
        } else {
            n = n.previousSibling;
        }
        while (n) {
            c += 1;
            n = n.previousSibling;
        }
        return c;
    };
    /**
     * Return the previous sibling of the current node
     * @return {Node}
     */
    this.getPreviousSibling = function () {
        var currentNode = walker.currentNode,
            sibling = walker.previousSibling();

        walker.currentNode = currentNode;

        return sibling;
    };
    /**
     * Return the next sibling of the current node
     * @return {Node}
     */
    this.getNextSibling = function () {
        var currentNode = walker.currentNode,
            sibling = walker.nextSibling();

        walker.currentNode = currentNode;

        return sibling;
    };

    /**
     * Advance the walker to the first node that is accepted by the node filter
     * (i.e., nodeFilter(node) === FILTER_ACCEPT)
     *
     * @return {!boolean} Returns true if the walker found an accepted node. Otherwise
     * returns false.
     */
    function moveToAcceptedNode() {
        var node = walker.currentNode,
            filterResult,
            moveResult;

        // Ensure currentNode is not within a rejected subtree by crawling each parent node
        // up to the root and verifying it is either accepted or skipped by the nodeFilter.
        // NOTE: The root is deliberately not checked as it is the container iteration happens within.
        filterResult = nodeFilter(node);
        if (node !== root) {
            node = node.parentNode;
            while (node && node !== root) {
                if (nodeFilter(node) === FILTER_REJECT) {
                    walker.currentNode = node;
                    filterResult = FILTER_REJECT;
                }
                node = node.parentNode;
            }
        }

        if (filterResult === FILTER_REJECT) {
            // Set currentPos to be 1 (or text data.length), so nextPosition will jump to the next sibling or parent
            currentPos = walker.currentNode.nodeType === TEXT_NODE ? /**@type{!Text}*/(node).length : 1;
            moveResult = self.nextPosition();
        } else if (filterResult === FILTER_ACCEPT) {
            moveResult = true;
        } else {
            // filterResult === FILTER_SKIP
            // FILTER_SKIP indicates children of the current node are acceptable.
            // currentPos is left unchanged as nextPosition can advance to an accepted child inside the node
            moveResult = self.nextPosition();
        }
        if (moveResult) {
            runtime.assert(nodeFilter(walker.currentNode) === FILTER_ACCEPT,
                "moveToAcceptedNode did not result in walker being on an accepted node");
        }
        return moveResult;
    }

    /**
     * Set the current position of the iterator to just before the supplied element.
     *
     * Querying the iterator then will return the container of the element and the offset
     * of the element within it's container (assuming the supplied element is accepted by
     * the nodeFilter).
     *
     * E.g.,
     * p1.setPositionBeforeElement(span);
     * p1.container() === span.parentNode
     * p1.unfilteredDomOffset === positionInParent(span)
     *
     * If the element is not accepted by the nodeFilter, the iterator will immediately
     * move to the next accepted node.
     *
     * @param {!Element} element
     * @return {!boolean} Returns true if the iterator was set to a valid position
     * (i.e., is currently on a node that is accepted by the nodeFilter)
     */
    this.setPositionBeforeElement = function (element) {
        runtime.assert(Boolean(element), "setPositionBeforeElement called without element");
        walker.currentNode = element;
        currentPos = 0;

        return moveToAcceptedNode();
    };

    /**
     * Set the current position of the iterator to the specified container + offset.
     *
     * Querying the iterator will then return the supplied container + offset
     * (assuming the supplied element is accepted by the nodeFilter).
     *
     * E.g.,
     * p2.setUnfilteredPosition(container, offset);
     * p2.container() === container
     * p2.unfilteredDomOffset() === offset;
     *
     * If the container is not accepted by the nodeFilter, the iterator will immediately
     * move to the next accepted node.
     *
     * @param {!Node} container
     * @param {!number} offset offset in unfiltered DOM world. Will immediately advance
     * the iterator to the numbered child node of the provided container.
     * @return {!boolean} Returns true if the iterator was set to a valid position
     * (i.e., is currently on a node that is accepted by the nodeFilter)
     */
    this.setUnfilteredPosition = function (container, offset) {
        var text;
        runtime.assert(Boolean(container), "PositionIterator.setUnfilteredPosition called without container");
        walker.currentNode = container;
        if (container.nodeType === TEXT_NODE) {
            currentPos = offset;
            text = /**@type{!Text}*/(container);
            runtime.assert(offset <= text.length, "Error in setPosition: " +
                offset + " > " + text.length);
            runtime.assert(offset >= 0, "Error in setPosition: " +
                offset + " < 0");
            if (offset === text.length) {
                if (walker.nextSibling()) {
                    currentPos = 0;
                } else if (walker.parentNode()) {
                    currentPos = 1;
                } else {
                    runtime.assert(false, "Error in setUnfilteredPosition: position not valid.");
                }
            }
        } else if (offset < container.childNodes.length) {
            // Immediately advance to the child node at that offset to begin iteration.
            // This is necessary in order to satisfy the most frequent use case where developer will
            // store the (container, unfilteredDomOffset) from a previous position iterator, and use
            // this value to resume iteration at the specified point. If we didn't immediately advance
            // to the next position, the first call to nextPosition would return the input container+offset.
            walker.currentNode = /**@type{!Node}*/(container.childNodes.item(offset));
            currentPos = 0;
        } else {
            // Either the node has no children or offset === childNodes.length

            // Set currentPos to 1 to indicate iteration on the currentNode is complete.
            // This will cause the next call to self.nextPosition() to jump to the next
            // available sibling or parent
            currentPos = 1;
        }

        return moveToAcceptedNode();
    };
    /**
     * Move the iterator to its last possible position.
     * This is at the last position in the root node if the iterator.
     * @return {undefined}
     */
    this.moveToEnd = function () {
        walker.currentNode = root;
        currentPos = 1;
    };

    /**
     * Places the iterator at the last position inside the given node.
     * @param {!Node} node
     * @return {undefined}
     */
    this.moveToEndOfNode = function (node) {
        var text;
        if (node.nodeType === TEXT_NODE) {
            text = /**@type{!Text}*/(node);
            self.setUnfilteredPosition(text, text.length);
        } else {
            walker.currentNode = node;
            currentPos = 1;
        }
    };

    /**
     * Returns true if the iterator is just to the left of a node. In this position,
     * calls to container() will return the parent of the node, and unfilteredDomOffset
     * will return the position of the node within the parent container.
     *
     * Calls to unfilteredDomOffset are extremely slow when the iterator is just before a
     * node, so querying this method can provide warning when a slow offset is necessary.
     * @return {!boolean}
     */
    this.isBeforeNode = function() {
        return currentPos === 0;
    };

    /**
     * Return the filter that is used in this iterator.
     * @return {!function(?Node):!number}
     */
    this.getNodeFilter = function () {
        return nodeFilter;
    };

    function init() {
        var f;
        // a position can never be near an empty TextNode. A NodeFilter is the
        // easiest way of filtering out these nodes.
        if (filter) {
            f = new FilteredEmptyTextNodeFilter(filter);
        } else {
            f = new EmptyTextNodeFilter();
        }
        // workaround for versions of createTreeWalker that need a function
        // instead of an object with a function such as IE 9 and older webkits
        nodeFilter = /**@type {!function(?Node):!number}*/(f.acceptNode);
        nodeFilter.acceptNode = nodeFilter;
        whatToShow = whatToShow || NodeFilter.SHOW_ALL;
        runtime.assert(root.nodeType !== Node.TEXT_NODE, "Internet Explorer doesn't allow tree walker roots to be text nodes");
        walker = root.ownerDocument.createTreeWalker(root, whatToShow,
                nodeFilter, expandEntityReferences);

        currentPos = 0;
        if (walker.firstChild() === null) {
            currentPos = 1;
        }
    }
    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\ScheduledTask.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, core, runtime*/

/**
 * @class
 * A scheduled task allows multiple requests for the same function to
 * be aggregated into a single call at a future time. This is useful for
 * batching up draw requests or other lower-priority or high-volume calls
 *
 * @constructor
 * @implements {core.Destroyable}
 * @param {!Function} fn The function to execute for this task
 * @param {!function(!function():undefined):!number} scheduleTask Schedule the task to execute
 * @param {!function(!number):undefined} cancelTask Cancel a scheduled task
 */
core.ScheduledTask = function ScheduledTask(fn, scheduleTask, cancelTask) {
    "use strict";
    var timeoutId,
        scheduled = false,
        args = [],
        destroyed = false;

    function cancel() {
        if (scheduled) {
            cancelTask(timeoutId);
            scheduled = false;
        }
    }

    function execute() {
        cancel();
        fn.apply(undefined, args);
        args = null;
    }

    /**
     * Schedule this task to execute. If one has already been requested,
     * this call will have no impact
     */
    this.trigger = function () {
        runtime.assert(destroyed === false, "Can't trigger destroyed ScheduledTask instance");
        args = Array.prototype.slice.call(arguments);
        if (!scheduled) {
            scheduled = true;
            timeoutId = scheduleTask(execute);
        }
    };

    /**
     * Immediately trigger this task and clear any pending requests.
     */
    this.triggerImmediate = function () {
        runtime.assert(destroyed === false, "Can't trigger destroyed ScheduledTask instance");
        args = Array.prototype.slice.call(arguments);
        execute();
    };

    /**
     * Execute any pending requests, but do not start any new ones.
     * If there are no pending requests, this call will do nothing.
     */
    this.processRequests = function () {
        if (scheduled) {
            execute();
        }
    };

    /**
     * Cancel any current pending requests
     * @type {Function}
     */
    this.cancel = cancel;

    /**
     * Cancel any scheduled callbacks and immediately reschedule a new call with
     * any existing arguments.
     * @return {undefined}
     */
    this.restart = function () {
        runtime.assert(destroyed === false, "Can't trigger destroyed ScheduledTask instance");
        cancel();
        scheduled = true;
        timeoutId = scheduleTask(execute);
    };

    /**
     * Cancel any pending requests
     * @param {!function(!Error=)} callback
     */
    this.destroy = function (callback) {
        cancel();
        destroyed = true;
        callback();
    };

};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\StepIterator.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core*/


/**
 * Creates a helper class for navigating by steps. Instances of this class are intended to be VERY
 * short-lived, and makes no guarantees about proper behaviour if the DOM or supplied filter is
 * modified during the lifetime of the object.
 *
 * @constructor
 * @param {!core.PositionFilter} filter Filter to apply to the iterator positions
 * @param {!core.PositionIterator} iterator Substree to search for step within. Generally a paragraph or document root
 */
core.StepIterator = function StepIterator(filter, iterator) {
    "use strict";

    var /**@const*/
        FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT,
        /**@const*/
        NEXT = core.StepDirection.NEXT,
        cachedContainer,
        cachedOffset,
        cachedFilterResult;

    function resetCache() {
        // TODO Speed up access of the container & offset pairs on the PositionIterator
        // These values are cached because container & offset lookups on the iterator
        // can be prohibitively slow. Ideally, the iterator itself will be eventually sped up
        cachedContainer = null;
        cachedOffset = undefined;
        cachedFilterResult = undefined;
    }

    /**
     * Returns true if the current iterator position is accepted by the supplied filter
     * @return {!boolean}
     */
    function isStep() {
        if (cachedFilterResult === undefined) {
            cachedFilterResult = filter.acceptPosition(iterator) === FILTER_ACCEPT;
        }
        return /**@type{!boolean}*/(cachedFilterResult);
    }
    this.isStep = isStep;

    /**
     * Sets the position of the underlying iterator
     * @param {!Node} newContainer
     * @param {!number} newOffset
     * @return {!boolean}
     */
    function setPosition(newContainer, newOffset) {
        resetCache();
        return iterator.setUnfilteredPosition(newContainer, newOffset);
    }
    this.setPosition = setPosition;

    /**
     * Return the container for the current position.
     * @return {!Element|!Text}
     */
     function container() {
        if (!cachedContainer) {
            cachedContainer = iterator.container();
        }
        return cachedContainer;
    }
    this.container = container;

    /**
     * Get the current unfiltered DOM offset of the underlying iterator
     * @return {!number}
     */
    function offset() {
        if (cachedOffset === undefined) {
            cachedOffset = iterator.unfilteredDomOffset();
        }
        return /**@type{!number}*/(cachedOffset);
    }
    this.offset = offset;

    /**
     * Move to the next step. Returns false if no step exists
     * @return {!boolean}
     */
    function nextStep() {
        resetCache(); // Necessary in case the are no more positions
        while (iterator.nextPosition()) {
            resetCache();
            if (isStep()) {
                return true;
            }
        }
        return false;
    }
    this.nextStep = nextStep;

    /**
     * Move to the previous step. Returns false if no step exists
     * @return {!boolean}
     */
    function previousStep() {
        resetCache(); // Necessary in case the are no more positions
        while (iterator.previousPosition()) {
            resetCache();
            if (isStep()) {
                return true;
            }
        }
        return false;
    }
    this.previousStep = previousStep;

    /**
     * Advance the iterator by one step in the specified direction.
     *
     * @param {!core.StepDirection} direction
     * @return {!boolean}
     */
    this.advanceStep = function(direction) {
        return direction === NEXT ? nextStep() : previousStep();
    };

    /**
     * If the current position is not on a valid step, this function will move the iterator
     * to the closest previous step. If there is no previous step, it will advance to the next
     * closest step.
     * @return {!boolean} Returns true if the iterator ends on a valid step
     */
    this.roundToClosestStep = function() {
        var currentContainer,
            currentOffset,
            isAtStep = isStep();
        if (!isAtStep) {
            currentContainer = container();
            currentOffset = offset();
            // Default rule is to always round a position DOWN to the closest step equal or prior
            // This produces the easiest behaviour to understand (e.g., put the cursor just AFTER the step it represents)
            isAtStep = previousStep();
            if (!isAtStep) {
                // Restore back to the prior position and see if there is a step available above
                setPosition(currentContainer, currentOffset);
                isAtStep = nextStep();
            }
        }
        return isAtStep;
    };

    /**
     * If the current position is not a valid step, move to the previous step.
     * If there is no previous step, returns false.
     * @return {!boolean} Returns true if the iterator ends on a valid step
     */
    this.roundToPreviousStep = function() {
        var isAtStep = isStep();
        if (!isAtStep) {
            isAtStep = previousStep();
        }
        return isAtStep;
    };

    /**
     * If the current position is not a valid step, move to the next step.
     * If there is no next step, returns false.
     * @return {!boolean} Returns true if the iterator ends on a valid step
     */
    this.roundToNextStep = function() {
        var isAtStep = isStep();
        if (!isAtStep) {
            isAtStep = nextStep();
        }
        return isAtStep;
    };

    /**
     * Return the node to the left of the current iterator position.
     * See PositionIterator.leftNode
     * @return {?Node}
     */
    this.leftNode = function() {
        return iterator.leftNode();
    };

    /**
     * Store a snapshot of the current step iterator position. Intended to be used
     * in conjunction with restore to be able to save & restore a particular position.
     *
     * Note, the returned type should be treated as an opaque token, as the data structure
     * is allowed to change at any moment.
     *
     * @return {!core.StepIterator.StepSnapshot}
     */
    this.snapshot = function() {
        return new core.StepIterator.StepSnapshot(container(), offset());
    };

    /**
     * Restore the step iterator back to a specific position. The input to this is
     * expected to be the direct result of a snapshot call.
     *
     * @param {!core.StepIterator.StepSnapshot} snapshot
     * @return {undefined}
     */
    this.restore = function(snapshot) {
        setPosition(snapshot.container, snapshot.offset);
    };
};


/**
 * StepIterator snapshot token that is used to save and restore the current position of StepIterator
 *
 * All properties and methods on this class are intended to be private to StepIterator, and should not be used outside
 * of the StepIterator file. The contents stored may be changed at any time and should not be relied upon by
 * external consumers.
 *
 * @constructor
 * @param {!Text|!Element} container
 * @param {!number} offset
 */
core.StepIterator.StepSnapshot = function (container, offset) {
    "use strict";

    /**
     * @private
     * @type {!Text|!Element}
     */
    this.container = container;

    /**
     * @private
     * @type {!number}
     */
    this.offset = offset;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Task.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, runtime*/

(function() {
    "use strict";
    /** @type {!RedrawTasks} */
    var redrawTasks;

    /**
     * FF doesn't execute requestAnimationFrame requests before it's next repaint,
     * causing flickering when performing some types of updates (e.g., recomputing Style2CSS).
     * To workaround this, sometimes we force animation callbacks to redraw ourselves
     * at certain points.
     *
     * This object collects animation frame requests and provides
     * a safe way of executing any outstanding requests
     *
     * @constructor
     */
    function RedrawTasks() {
        var callbacks = {};

        /**
         * Schedule a callback to be invoked on the next animation frame, or
         * when performRedraw is called.
         *
         * @param {!function():undefined} callback
         * @return {!number}
         */
        this.requestRedrawTask = function(callback) {
            var id = runtime.requestAnimationFrame(function() {
                callback();
                delete callbacks[id];
            });
            callbacks[id] = callback;
            return id;
        };

        /**
         * Execute any pending animation frame callbacks and cancel their
         * browser animation frame request.
         *
         * @return {undefined}
         */
        this.performRedraw = function() {
            Object.keys(callbacks).forEach(function(id) {
                callbacks[id]();
                runtime.cancelAnimationFrame(parseInt(id, 10));
            });
            callbacks = {};
        };

        /**
         * Cancel a pending animation frame callback
         * @param {!number} id
         * @return {undefined}
         */
        this.cancelRedrawTask = function(id) {
            runtime.cancelAnimationFrame(id);
            delete callbacks[id];
        };
    }

    /**
     * @type {!Object}
     */
    core.Task =  {};

    /**
     * Disable manually processing of tasks when core.Task.processTasks is called.
     * This is only used during benchmarks to prevent caret redraws from skewing
     * the resulting numbers
     * @type {!boolean}
     */
    core.Task.SUPPRESS_MANUAL_PROCESSING = false;

    /**
     * Process any outstanding redraw tasks that may be queued up
     * waiting for an animation frame
     * 
     * @return {undefined}
     */
    core.Task.processTasks = function() {
        if (!core.Task.SUPPRESS_MANUAL_PROCESSING) {
            redrawTasks.performRedraw();
        }
    };

    /**
     * Creates a new task that will execute the specified callback once
     * when redrawing the next animation frame. Triggering the task multiple
     * times before the execution occurs will still only result in a single
     * call being made.
     *
     * @param {!Function} callback
     * @return {!core.ScheduledTask}
     */
    core.Task.createRedrawTask = function (callback) {
        return new core.ScheduledTask(callback,
            redrawTasks.requestRedrawTask,
            redrawTasks.cancelRedrawTask
        );
    };

    /**
     * Creates a new task that will execute the specified callback once
     * within the specified delay period. Triggering the task multiple
     * times before the execution occurs will still only result in a single
     * call being made.
     *
     * @param {!Function} callback
     * @param {!number} delay
     * @return {!core.ScheduledTask}
     */
    core.Task.createTimeoutTask = function (callback, delay) {
        return new core.ScheduledTask(callback,
            function(callback) {
                return runtime.setTimeout(callback, delay);
            },
            runtime.clearTimeout
        );
    };

    function init() {
        redrawTasks = new RedrawTasks();
    }
    init();
}());
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\typedefs.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/

/**
 * @typedef {(ClientRect|{left: !number, right: !number, top: !number, bottom: !number})}
 */
core.SimpleClientRect = null;
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Utils.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <aditya.bhatt@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core*/

/**
 * A collection of useful utility functions
 * @constructor
 */
core.Utils = function Utils() {
    "use strict";

    /**
     * Simple string hash
     * Based off http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
     * @param {!string} value
     * @return {!number}
     */
    function hashString(value) {
        var hash = 0, i, l;
        for (i = 0, l = value.length; i < l; i += 1) {
            /*jslint bitwise:true*/
            hash = ((hash << 5) - hash) + value.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
            /*jslint bitwise:false*/
        }
        return hash;
    }
    this.hashString = hashString;

    var mergeObjects;
    /**
     * @param {*} destination
     * @param {*} source
     * @return {*}
     */
    function mergeItems(destination, source) {
        // Property in destination object set; update its value.
        if (source && Array.isArray(source)) {
            // create destination array if it does not exist yet
            destination = destination || [];
            if (!Array.isArray(destination)) {
                throw "Destination is not an array.";
            }
            // An array will report as a type of object, but this is not able to
            // mapped using mergeObjects
            // The following will clone each individual item in the source array
            // and append them to the end of the destination array
            destination = /**@type{!Array.<*>}*/(destination).concat(
                /**@type{!Array.<*>}*/(source).map(function (obj) {
                    return mergeItems(null, obj);
                })
            );
        } else if (source && typeof source === 'object') {
            destination = destination || {};
            if (typeof destination !== 'object') {
                throw "Destination is not an object.";
            }
            Object.keys(/**@type{!Object}*/(source)).forEach(function (p) {
                destination[p] = mergeItems(destination[p], source[p]);
            });
        } else {
            destination = source;
        }
        return destination;
    }
    /**
     * Recursively merge properties of two objects
     * Merge behaviours for the object members are:
     *  array => array - Append clones of source array onto the end of the
     *                   destination array
     *  object => object - Map each individual key from source onto destination
     *                     (recursive, so these are clones)
     *  primitive => primitive - return primitive value
     *
     * @param {!Object.<string,*>} destination
     * @param {!Object.<string,*>} source
     * @return {!Object.<string,*>}
     */
    mergeObjects = function (destination, source) {
        Object.keys(source).forEach(function (p) {
            destination[p] = mergeItems(destination[p], source[p]);
        });
        return destination;
    };
    this.mergeObjects = mergeObjects;
};


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\core\Zip.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, DOMParser, externs*/
/*jslint bitwise: true*/

/**
 * @constructor
 * @param {!string} url path to zip file, should be readable by the runtime
 * @param {?function(?string, !core.Zip):undefined} entriesReadCallback callback
 *        indicating the zip
 *        has loaded this list of entries, the arguments are a string that
 *        indicates error if present and the created object
 */
core.Zip = function Zip(url, entriesReadCallback) {
    "use strict";
    var /**@type{!core.Zip}*/
        self = this,
        /**@type{!JSZip}*/
        zip,
        base64 = new core.Base64();

    /**
     * @param {!string} filename
     * @param {!function(?string, ?Uint8Array)} callback receiving err and data
     * @return {undefined}
     */
    function load(filename, callback) {
        var entry = zip.file(filename);
        if (entry) {
            callback(null, entry.asUint8Array());
        } else {
            callback(filename + " not found.", null);
        }
    }
    /**
     * @param {!string} filename
     * @param {!function(?string, ?string):undefined} callback receiving err and data
     * @return {undefined}
     */
    function loadAsString(filename, callback) {
        // the javascript implementation simply reads the file and converts to
        // string
        load(filename, function (err, data) {
            if (err || data === null) {
                return callback(err, null);
            }
            var d = runtime.byteArrayToString(data, "utf8");
            callback(null, d);
        });
    }
    /**
     * @param {!string} filename
     * @param {!{rootElementReady: function(?string, ?string=, boolean=):undefined}} handler
     * @return {undefined}
     */
    function loadContentXmlAsFragments(filename, handler) {
        // the javascript implementation simply reads the file
        loadAsString(filename, function (err, data) {
            if (err) {
                return handler.rootElementReady(err);
            }
            handler.rootElementReady(null, data, true);
        });
    }
    /**
     * @param {!string} filename
     * @param {!string} mimetype
     * @param {!function(?string,?string):undefined} callback
     */
    function loadAsDataURL(filename, mimetype, callback) {
        load(filename, function (err, data) {
            if (err || !data) {
                return callback(err, null);
            }
            var /**@const@type{!Uint8Array}*/p = data,
                chunksize = 45000, // must be multiple of 3 and less than 50000
                i = 0,
                dataurl;
            if (!mimetype) {
                if (p[1] === 0x50 && p[2] === 0x4E && p[3] === 0x47) {
                    mimetype = "image/png";
                } else if (p[0] === 0xFF && p[1] === 0xD8 && p[2] === 0xFF) {
                    mimetype = "image/jpeg";
                } else if (p[0] === 0x47 && p[1] === 0x49 && p[2] === 0x46) {
                    mimetype = "image/gif";
                } else {
                    mimetype = "";
                }
            }
            dataurl = 'data:' + mimetype + ';base64,';
            // to avoid exceptions, base64 encoding is done in chunks
            // it would make sense to move this to base64.toBase64
            while (i < data.length) {
                dataurl += base64.convertUTF8ArrayToBase64(
                    p.subarray(i, Math.min(i + chunksize, p.length))
                );
                i += chunksize;
            }
            callback(null, dataurl);
        });
    }
    /**
     * @param {!string} filename
     * @param {function(?string,?Document):undefined} callback
     * @return {undefined}
     */
    function loadAsDOM(filename, callback) {
        loadAsString(filename, function (err, xmldata) {
            if (err || xmldata === null) {
                callback(err, null);
                return;
            }
            var parser = new DOMParser(),
                dom = parser.parseFromString(xmldata, "text/xml");
            callback(null, dom);
        });
    }
    /**
     * Add or replace an entry to the zip file.
     * This data is not stored to disk yet, and therefore, no callback is
     * necessary.
     * @param {!string} filename
     * @param {!Uint8Array} data
     * @param {!boolean} compressed
     * @param {!Date} date
     * @return {undefined}
     */
    function save(filename, data, compressed, date) {
        zip.file(filename, data, {date: date, compression: compressed ? "DEFLATE" : "STORE"});
    }
    /**
     * Removes entry from the zip.
     * @param {!string} filename
     * @return {!boolean} return false if entry is not found; otherwise true.
     */
    function remove(filename) {
        var exists = zip.file(filename) !== null;
        zip.remove(filename);
        return exists;
    }
    /**
     * Create a bytearray from the zipfile.
     * @param {!function(!Uint8Array):undefined} successCallback receiving zip as bytearray
     * @param {!function(?string):undefined} errorCallback receiving possible err
     * @return {undefined}
     */
    function createByteArray(successCallback, errorCallback) {
        try {
            successCallback(/**@type{!Uint8Array}*/(zip.generate({type: "uint8array", compression: "STORE"})));
        } catch(/**@type{!Error}*/e) {
            errorCallback(e.message);
        }
    }
    /**
     * Write the zipfile to the given path.
     * @param {!string} newurl
     * @param {!function(?string):undefined} callback receiving possible err
     * @return {undefined}
     */
    function writeAs(newurl, callback) {
        createByteArray(function (data) {
            runtime.writeFile(newurl, data, callback);
        }, callback);
    }
    /**
     * Write the zipfile to the given path.
     * @param {!function(?string):undefined} callback receiving possible err
     * @return {undefined}
     */
    function write(callback) {
        writeAs(url, callback);
    }
    this.load = load;
    this.save = save;
    this.remove = remove;
    this.write = write;
    this.writeAs = writeAs;
    this.createByteArray = createByteArray;
    // a special function that makes faster odf loading possible
    this.loadContentXmlAsFragments = loadContentXmlAsFragments;
    this.loadAsString = loadAsString;
    this.loadAsDOM = loadAsDOM;
    this.loadAsDataURL = loadAsDataURL;

    /**
     * @return {!Array.<!{filename: !string,date: !Date}>}
     */
    this.getEntries = function () {
        return Object.keys(zip.files).map(function(filename) {
            var e = zip.files[filename];
            return {
                filename: filename,
                date: e.date
            };
        });
    };

    zip = new externs.JSZip();
    // if no callback is defined, this is a new file
    if (entriesReadCallback === null) {
        return;
    }
    runtime.readFile(url, "binary", function (err, result) {
        if (typeof result === "string") {
            err = "file was read as a string. Should be Uint8Array.";
        }
        if (err || !result || result.length === 0) {
            entriesReadCallback("File '" + url + "' cannot be read. Err: " + (err || "[none]"), self);
        } else {
            try {
                // CRC32 check disabled to improve performance
                zip.load(/**@type{!Uint8Array}*/(result), { checkCRC32: false });
                entriesReadCallback(null, self);
            } catch (/**@type{!Error}*/e) {
                entriesReadCallback(e.message, self);
            }
        }
    });
};
