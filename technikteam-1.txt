
========================================================================
FILE: frontend\src\pages\admin\AdminVenuesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminVenuesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/venues'), []);
	const { data: venues, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingVenue, setEditingVenue] = useState(null);
	const { addToast } = useToast();

	const openModal = (venue = null) => {
		setEditingVenue(venue);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingVenue(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (venue) => {
		if (window.confirm(`Veranstaltungsort "${venue.name}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/venues/${venue.id}`);
				if (result.success) {
					addToast('Ort erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-map-marked-alt"></i> Veranstaltungsorte verwalten</h1>
			<p>Verwalten Sie hier die Orte und die zugehörigen Raumpläne.</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neuer Ort
				</button>
			</div>

			{loading && <p>Lade Orte...</p>}
			{error && <p className="error-message">{error}</p>}

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Adresse</th>
							<th>Kartenbild</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{venues?.map(venue => (
							<tr key={venue.id}>
								<td>{venue.name}</td>
								<td>{venue.address}</td>
								<td>{venue.mapImagePath ? 'Ja' : 'Nein'}</td>
								<td>
									<button onClick={() => openModal(venue)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(venue)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			<div className="mobile-card-list">
				{venues?.map(venue => (
					<div className="list-item-card" key={venue.id}>
						<h3 className="card-title">{venue.name}</h3>
						<div className="card-row"><strong>Adresse:</strong> <span>{venue.address || '-'}</span></div>
						<div className="card-row"><strong>Karte:</strong> <span>{venue.mapImagePath ? 'Ja' : 'Nein'}</span></div>
						<div className="card-actions">
							<button onClick={() => openModal(venue)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => handleDelete(venue)} className="btn btn-small btn-danger">Löschen</button>
						</div>
					</div>
				))}
			</div>
			{isModalOpen && (
				<VenueModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					venue={editingVenue}
				/>
			)}
		</div>
	);
};

const VenueModal = ({ isOpen, onClose, onSuccess, venue }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const formData = new FormData();
		const venueData = {
			name: e.target.name.value,
			address: e.target.address.value,
			notes: e.target.notes.value,
			mapImagePath: venue?.mapImagePath // Preserve existing image path
		};
		formData.append('venue', new Blob([JSON.stringify(venueData)], { type: 'application/json' }));
		if (e.target.mapImage.files[0]) {
			formData.append('mapImage', e.target.mapImage.files[0]);
		}

		try {
			const endpoint = venue ? `/admin/venues/${venue.id}` : '/admin/venues';
			// Since apiClient doesn't have a dedicated `put` for FormData, we use `request`
			const result = await apiClient.request(endpoint, {
				method: venue ? 'PUT' : 'POST',
				body: formData
			});

			if (result.success) {
				addToast(`Ort erfolgreich ${venue ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={venue ? 'Ort bearbeiten' : 'Neuen Ort erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label>Name des Ortes</label>
					<input name="name" defaultValue={venue?.name} required />
				</div>
				<div className="form-group">
					<label>Adresse (optional)</label>
					<input name="address" defaultValue={venue?.address} />
				</div>
				<div className="form-group">
					<label>Notizen (z.B. Kontaktperson, Besonderheiten)</label>
					<textarea name="notes" defaultValue={venue?.notes} rows="3"></textarea>
				</div>
				<div className="form-group">
					<label>Raumplan / Kartenbild (optional)</label>
					<input type="file" name="mapImage" accept="image/*" />
					{venue?.mapImagePath && <small>Aktuelles Bild wird überschrieben, wenn eine neue Datei ausgewählt wird.</small>}
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminVenuesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminWikiPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const WikiPageModal = ({ isOpen, onClose, onSuccess, parentPath }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const formData = new FormData(e.target);
		const fileName = formData.get('fileName');
		const fullPath = parentPath ? `${parentPath}/${fileName}` : fileName;

		try {
			const result = await apiClient.post('/wiki', { filePath: fullPath, content: `# ${fileName}\n\nNeue Seite.` });
			if (result.success) {
				addToast('Seite erfolgreich erstellt', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Erstellen der Seite fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Wiki-Seite erstellen">
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="wiki-parent-path">Übergeordneter Pfad</label>
					<input id="wiki-parent-path" type="text" value={parentPath || '/'} readOnly disabled />
				</div>
				<div className="form-group">
					<label htmlFor="wiki-file-name">Dateiname (z.B. `neue-seite.md`)</label>
					<input id="wiki-file-name" name="fileName" required pattern=".*\.md$" title="Muss mit .md enden" />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird erstellt...' : 'Seite erstellen'}
				</button>
			</form>
		</Modal>
	);
};


const AdminWikiPage = () => {
	const treeApiCall = useCallback(() => apiClient.get('/wiki'), []);
	const { data: wikiTree, loading, error, reload } = useApi(treeApiCall);
	const [selectedEntry, setSelectedEntry] = useState(null);
	const [isEditing, setIsEditing] = useState(false);
	const [editContent, setEditContent] = useState('');
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [modalParentPath, setModalParentPath] = useState('');
	const { addToast } = useToast();

	const handleSelectEntry = async (entry) => {
		try {
			const result = await apiClient.get(`/wiki/${entry.id}`);
			if (result.success) {
				setSelectedEntry(result.data);
				setEditContent(result.data.content);
				setIsEditing(false);
			}
		} catch (err) {
			addToast(`Fehler beim Laden der Seite: ${err.message}`, 'error');
		}
	};

	const handleSave = async () => {
		if (!selectedEntry) return;
		try {
			const result = await apiClient.put(`/wiki/${selectedEntry.id}`, { content: editContent });
			if (result.success) {
				addToast('Seite gespeichert', 'success');
				await handleSelectEntry(selectedEntry); // Reload content
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Speichern: ${err.message}`, 'error');
		}
	};

	const handleDelete = async () => {
		if (!selectedEntry) return;
		if (window.confirm(`Seite "${selectedEntry.filePath}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/wiki/${selectedEntry.id}`);
				if (result.success) {
					addToast('Seite gelöscht', 'success');
					setSelectedEntry(null);
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler beim Löschen: ${err.message}`, 'error');
			}
		}
	};

	const renderTree = (node, path = '') => (
		<ul>
			{Object.entries(node).map(([name, child]) => (
				<li key={path + name}>
					{child.id ? ( // It's a file
						<a href="#" onClick={(e) => { e.preventDefault(); handleSelectEntry(child); }} className={selectedEntry?.id === child.id ? 'active' : ''}>
							<i className="fas fa-file-alt fa-fw"></i> {name}
						</a>
					) : ( // It's a directory
						<details open>
							<summary><i className="fas fa-folder fa-fw"></i> {name}</summary>
							{renderTree(child, `${path}${name}/`)}
						</details>
					)}
				</li>
			))}
		</ul>
	);

	if (loading) return <div>Lade Wiki-Struktur...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div className={`wiki-page-wrapper ${selectedEntry ? 'content-visible' : 'tree-visible'}`}>
			<aside className="wiki-sidebar">
				<div className="wiki-sidebar-header">
					<h3>Wiki-Verzeichnis</h3>
					<button className="btn btn-small" onClick={() => { setModalParentPath(''); setIsModalOpen(true); }}>+</button>
				</div>
				<div className="wiki-tree-container">
					{wikiTree && renderTree(wikiTree)}
				</div>
			</aside>
			<main className="wiki-content-pane">
				{selectedEntry ? (
					<>
						<div className="wiki-content-header">
							<button className="mobile-only btn btn-small" onClick={() => setSelectedEntry(null)}>
								<i className="fas fa-arrow-left"></i> Verzeichnis
							</button>
							<h2>{selectedEntry.filePath}</h2>
							<div className="wiki-editor-controls">
								{isEditing ? (
									<>
										<button onClick={handleSave} className="btn btn-success btn-small">Speichern</button>
										<button onClick={() => setIsEditing(false)} className="btn btn-secondary btn-small">Abbrechen</button>
									</>
								) : (
									<>
										<button onClick={() => setIsEditing(true)} className="btn btn-small">Bearbeiten</button>
										<button onClick={handleDelete} className="btn btn-danger btn-small">Löschen</button>
									</>
								)}
							</div>
						</div>
						{isEditing ? (
							<textarea
								id="editor"
								className="form-group"
								value={editContent}
								onChange={(e) => setEditContent(e.target.value)}
								style={{ flexGrow: 1, fontFamily: 'monospace' }}
							/>
						) : (
							<div className="markdown-content">
								<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
									{selectedEntry.content}
								</ReactMarkdown>
							</div>
						)}
					</>
				) : (
					<div className="wiki-welcome-pane desktop-only">
						<i className="fas fa-book-reader" style={{ fontSize: '4rem' }}></i>
						<h1>Wiki</h1>
						<p>Wählen Sie eine Seite aus der Navigation aus, um sie anzuzeigen oder zu bearbeiten.</p>
					</div>
				)}
			</main>
			{isModalOpen && (
				<WikiPageModal
					isOpen={isModalOpen}
					onClose={() => setIsModalOpen(false)}
					onSuccess={() => { setIsModalOpen(false); reload(); }}
					parentPath={modalParentPath}
				/>
			)}
		</div>
	);
};

export default AdminWikiPage;
========================================================================
FILE: frontend\src\pages\error\ErrorPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { useRouteError, Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const ErrorPage = () => {
	const error = useRouteError();
	console.error(error);

	// Safely determine the error message to display
	const errorMessage = useMemo(() => {
		if (typeof error === 'string') return error;
		if (error instanceof Error) return error.message;
		if (error?.statusText) return error.statusText;
		if (error?.message) return error.message;
		return "Ein unbekannter Fehler ist aufgetreten.";
	}, [error]);

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: 'SYSTEMDIAGNOSE WIRD GESTARTET...', className: 'info' },
		{ text: 'Speichermodule werden gescannt...', className: 'info', delayAfter: 500 },
		{ text: '[OK] Speicherintegritätsprüfung bestanden.', className: 'ok' },
		{ text: 'Anwendungsstatus wird überprüft...', className: 'info', delayAfter: 500 },
		{ text: `[FEHLER] Unbehandelte Ausnahme erkannt: ${errorMessage}`, className: 'fail', delayAfter: 800 },
		{ text: 'FEHLER 500: Interner Serverfehler.', className: 'fail' },
		{ text: 'Ein kritischer Fehler ist bei der Verarbeitung der Anfrage aufgetreten.', className: 'info' },
		{ text: 'Der Systemadministrator wurde benachrichtigt.', className: 'info' },
		{ text: 'Wiederherstellungsoptionen werden vorbereitet...', className: 'warn' },
	], [errorMessage]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SYSTEM_DIAGNOSTIC.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default ErrorPage;
========================================================================
FILE: frontend\src\pages\error\ErrorTrigger.jsx
========================================================================

import { useEffect } from 'react';

const ErrorTrigger = () => {
	useEffect(() => {
		// This will cause a rendering error that the boundary will catch.
		throw new Error("Dies ist ein simulierter Rendering-Fehler zum Testen der 500-Seite.");
	}, []);

	return <div>You should not see this.</div>;
};

export default ErrorTrigger;
========================================================================
FILE: frontend\src\pages\error\ForbiddenPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import { useAuthStore } from '../../store/authStore';

const ForbiddenPage = () => {
	const user = useAuthStore(state => state.user);

	const lines = useMemo(() => [
		{ text: 'Zugriffsversuch auf geschützten Bereich...', className: 'info' },
		{ text: `Benutzer wird authentifiziert: ${user?.username || 'GAST'}`, className: 'info', delayAfter: 500 },
		{ text: 'Berechtigungsstufe wird geprüft...', className: 'info', delayAfter: 800 },
		{ text: '[ZUGRIFF VERWEIGERT]', className: 'fail', speed: 80 },
		{ text: 'FEHLER 403: Unzureichende Berechtigungen.', className: 'fail' },
		{ text: 'Ihre aktuelle Rolle gewährt keinen Zugriff auf diese Ressource.', className: 'warn' },
		{ text: 'Dieser Versuch wurde protokolliert.', className: 'info' },
	], [user]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="full-screen-terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SECURITY.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<div className="terminal-footer">
				<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
					<i className="fas fa-arrow-left"></i> Zurück zum sicheren Bereich
				</Link>
			</div>
		</div>
	);
};

export default ForbiddenPage;
========================================================================
FILE: frontend\src\pages\error\NotFoundPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link, useLocation } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const NotFoundPage = () => {
	const location = useLocation();
	const path = location.pathname;

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: `Führe Befehl aus: find . -name "${path}"`, className: 'info', delayAfter: 800 },
		{ text: `find: '${path}': Datei oder Verzeichnis nicht gefunden`, className: 'warn', delayAfter: 500 },
		{ text: 'FEHLER 404: Ressource nicht gefunden.', className: 'fail' },
		{ text: 'Vorschlag: Die angeforderte Ressource ist nicht verfügbar. Versuchen Sie, zum Dashboard zurückzukehren.', className: 'info' },
		{ text: `Führe aus: cd /home`, className: 'info' },
	], [path]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">bash</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{index < 1 ? '$' : '>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default NotFoundPage;
========================================================================
FILE: frontend\src\router\AdminRoute.jsx
========================================================================

import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const AdminRoute = () => {
	const isAdmin = useAuthStore((state) => state.isAdmin);

	// Check for authentication is handled by ProtectedRoute, this just checks for admin role.
	if (!isAdmin) {
		// Instead of rendering a component directly, we navigate to a dedicated route for 403.
		// This keeps the URL consistent with the error being shown.
		return <Navigate to="/forbidden" replace />;
	}

	return <Outlet />;
};

export default AdminRoute;
========================================================================
FILE: frontend\src\router\index.jsx
========================================================================

import React, { lazy, Suspense } from 'react';
import { createBrowserRouter, Navigate, Outlet } from 'react-router-dom';

// Layouts and Core Components
import App from '../App';
import MinimalLayout from '../components/layout/MinimalLayout';
import ErrorLayout from '../components/layout/ErrorLayout';
import ProtectedRoute from './ProtectedRoute';
import AdminRoute from './AdminRoute';

// Eagerly load the LoginPage, Error Pages, and the new ChatPage
import LoginPage from '../pages/LoginPage';
import ErrorPage from '../pages/error/ErrorPage';
import NotFoundPage from '../pages/error/NotFoundPage';
import ChatPage from '../pages/ChatPage'; // Eagerly load ChatPage

// Lazy load all other pages
const DashboardPage = lazy(() => import('../pages/DashboardPage'));
const StoragePage = lazy(() => import('../pages/StoragePage'));
const StorageItemDetailsPage = lazy(() => import('../pages/StorageItemDetailsPage'));
const QrActionPage = lazy(() => import('../pages/QrActionPage'));
const EventsPage = lazy(() => import('../pages/EventsPage'));
const EventDetailsPage = lazy(() => import('../pages/EventDetailsPage'));
const LehrgaengePage = lazy(() => import('../pages/LehrgaengePage'));
const MeetingDetailsPage = lazy(() => import('../pages/MeetingDetailsPage'));
const ProfilePage = lazy(() => import('../pages/ProfilePage'));
const PasswordPage = lazy(() => import('../pages/PasswordPage'));
const FilesPage = lazy(() => import('../pages/FilesPage'));
const FeedbackPage = lazy(() => import('../pages/FeedbackPage'));
const EventFeedbackPage = lazy(() => import('../pages/EventFeedbackPage'));
const CalendarPage = lazy(() => import('../pages/CalendarPage'));
const PackKitPage = lazy(() => import('../pages/PackKitPage'));
const SearchResultsPage = lazy(() => import('../pages/SearchResultsPage'));
const ChangelogPage = lazy(() => import('../pages/ChangelogPage'));
const TeamDirectoryPage = lazy(() => import('../pages/TeamDirectoryPage'));
const AnnouncementsPage = lazy(() => import('../pages/AnnouncementsPage'));
const HelpListPage = lazy(() => import('../pages/HelpListPage'));
const HelpDetailsPage = lazy(() => import('../pages/HelpDetailsPage'));
const SettingsPage = lazy(() => import('../pages/SettingsPage'));

// Admin Pages
const AdminDashboardPage = lazy(() => import('../pages/admin/AdminDashboardPage'));
const AdminUsersIndex = lazy(() => import('../pages/admin/AdminUsersIndex'));
const AdminUsersPage = lazy(() => import('../pages/admin/AdminUsersPage'));
const AdminRequestsPage = lazy(() => import('../pages/admin/AdminRequestsPage'));
const AdminEventsIndex = lazy(() => import('../pages/admin/AdminEventsIndex'));
const AdminEventsPage = lazy(() => import('../pages/admin/AdminEventsPage'));
const AdminEventDebriefingPage = lazy(() => import('../pages/admin/AdminEventDebriefingPage'));
const AdminDebriefingsListPage = lazy(() => import('../pages/admin/AdminDebriefingsListPage'));
const AdminEventRolesPage = lazy(() => import('../pages/admin/AdminEventRolesPage'));
const AdminCoursesIndex = lazy(() => import('../pages/admin/AdminCoursesIndex'));
const AdminCoursesPage = lazy(() => import('../pages/admin/AdminCoursesPage'));
const AdminMeetingsPage = lazy(() => import('../pages/admin/AdminMeetingsPage'));
const AdminStorageIndex = lazy(() => import('../pages/admin/AdminStorageIndex'));
const AdminStoragePage = lazy(() => import('../pages/admin/AdminStoragePage'));
const AdminDefectivePage = lazy(() => import('../pages/admin/AdminDefectivePage'));
const AdminDamageReportsPage = lazy(() => import('../pages/admin/AdminDamageReportsPage'));
const AdminLogPage = lazy(() => import('../pages/admin/AdminLogPage'));
const AdminKitsPage = lazy(() => import('../pages/admin/AdminKitsPage'));
const AdminMatrixPage = lazy(() => import('../pages/admin/AdminMatrixPage'));
const AdminReportsPage = lazy(() => import('../pages/admin/AdminReportsPage'));
const AdminSystemPage = lazy(() => import('../pages/admin/AdminSystemPage'));
const AdminContentIndex = lazy(() => import('../pages/admin/AdminContentIndex'));
const AdminFilesPage = lazy(() => import('../pages/admin/AdminFilesPage'));
const AdminFeedbackPage = lazy(() => import('../pages/admin/AdminFeedbackPage'));
const AdminAchievementsPage = lazy(() => import('../pages/admin/AdminAchievementsPage'));
const AdminWikiPage = lazy(() => import('../pages/admin/AdminWikiPage'));
const AdminNotificationsPage = lazy(() => import('../pages/admin/AdminNotificationsPage'));
const AdminVenuesPage = lazy(() => import('../pages/admin/AdminVenuesPage'));
const AdminChecklistTemplatesPage = lazy(() => import('../pages/admin/AdminChecklistTemplatesPage'));
const AdminChangelogPage = lazy(() => import('../pages/admin/AdminChangelogPage'));
const AdminAnnouncementsPage = lazy(() => import('../pages/admin/AdminAnnouncementsPage'));
const AdminTrainingRequestsPage = lazy(() => import('../pages/admin/AdminTrainingRequestsPage'));
const AdminDocumentationPage = lazy(() => import('../pages/admin/AdminDocumentationPage'));
const AdminReportsIndex = lazy(() => import('../pages/admin/AdminReportsIndex'));


import ErrorTrigger from '../pages/error/ErrorTrigger';
import ForbiddenPage from '../pages/error/ForbiddenPage';

const router = createBrowserRouter([
	{
		path: '/',
		element: (
			<ProtectedRoute>
				<App />
			</ProtectedRoute>
		),
		errorElement: <ErrorLayout><ErrorPage /></ErrorLayout>,
		children: [
			{ index: true, element: <Navigate to="/home" replace /> },
			{ path: 'home', element: <DashboardPage /> },
			{ path: 'lager', element: <StoragePage /> },
			{ path: 'lager/details/:itemId', element: <StorageItemDetailsPage /> },
			{ path: 'veranstaltungen', element: <EventsPage /> },
			{ path: 'veranstaltungen/details/:eventId', element: <EventDetailsPage /> },
			{ path: 'lehrgaenge', element: <LehrgaengePage /> },
			{ path: 'lehrgaenge/details/:meetingId', element: <MeetingDetailsPage /> },
			{ path: 'profil', element: <ProfilePage /> },
			{ path: 'profil/einstellungen', element: <SettingsPage /> },
			{ path: 'passwort', element: <PasswordPage /> },
			{ path: 'dateien', element: <FilesPage /> },
			{ path: 'feedback', element: <FeedbackPage /> },
			{ path: 'feedback/event/:eventId', element: <EventFeedbackPage /> },
			{ path: 'kalender', element: <CalendarPage /> },
			{ path: 'suche', element: <SearchResultsPage /> },
			{ path: 'changelogs', element: <ChangelogPage /> },
			{ path: 'team', element: <TeamDirectoryPage /> },
			{ path: 'bulletin-board', element: <AnnouncementsPage /> },
			{ path: 'help', element: <HelpListPage /> },
			{ path: 'help/:pageKey', element: <HelpDetailsPage /> },
			{ path: 'chat', element: <ChatPage /> },
			{ path: 'chat/:conversationId', element: <ChatPage /> },
			{ path: 'test-500', element: <ErrorTrigger /> },

			{
				path: 'admin',
				element: <AdminRoute />,
				children: [
					{ index: true, element: <Navigate to="/admin/dashboard" replace /> },
					{ path: 'dashboard', element: <AdminDashboardPage /> },
					{
						path: 'mitglieder', element: <AdminUsersIndex />, children: [
							{ index: true, element: <AdminUsersPage /> },
							{ path: 'requests', element: <AdminRequestsPage /> },
							{ path: 'training-requests', element: <AdminTrainingRequestsPage /> },
						]
					},
					{
						path: 'veranstaltungen', element: <AdminEventsIndex />, children: [
							{ index: true, element: <AdminEventsPage /> },
							{ path: 'debriefings', element: <AdminDebriefingsListPage /> },
							{ path: 'roles', element: <AdminEventRolesPage /> },
							{ path: 'venues', element: <AdminVenuesPage /> },
							{ path: 'checklist-templates', element: <AdminChecklistTemplatesPage /> },
						]
					},
					{ path: 'veranstaltungen/:eventId/debriefing', element: <AdminEventDebriefingPage /> },
					{
						path: 'lehrgaenge', element: <AdminCoursesIndex />, children: [
							{ index: true, element: <AdminCoursesPage /> },
							{ path: 'matrix', element: <AdminMatrixPage /> },
						]
					},
					{ path: 'lehrgaenge/:courseId/meetings', element: <AdminMeetingsPage /> },
					{
						path: 'lager', element: <AdminStorageIndex />, children: [
							{ index: true, element: <AdminStoragePage /> },
							{ path: 'kits', element: <AdminKitsPage /> },
							{ path: 'defekte', element: <AdminDefectivePage /> },
							{ path: 'damage-reports', element: <AdminDamageReportsPage /> },
						]
					},
					{
						path: 'content', element: <AdminContentIndex />, children: [
							{ index: true, element: <AdminAnnouncementsPage /> },
							{ path: 'announcements', element: <AdminAnnouncementsPage /> },
							{ path: 'dateien', element: <AdminFilesPage /> },
							{ path: 'feedback', element: <AdminFeedbackPage /> },
							{ path: 'changelogs', element: <AdminChangelogPage /> },
							{ path: 'documentation', element: <AdminDocumentationPage /> },
							{ path: 'benachrichtigungen', element: <AdminNotificationsPage /> },
						]
					},
					{
						path: 'reports', element: <AdminReportsIndex />, children: [
							{ index: true, element: <AdminReportsPage /> },
							{ path: 'log', element: <AdminLogPage /> },
							{ path: 'system', element: <AdminSystemPage /> },
						]
					},
					// This route was incorrectly placed inside 'content'. Moved to be a direct child of 'admin'.
					{ path: 'benachrichtigungen', element: <AdminNotificationsPage /> },
					{ path: 'achievements', element: <AdminAchievementsPage /> },
					{ path: 'wiki', element: <AdminWikiPage /> },
				],
			},
		],
	},
	{
		path: '/pack-kit/:kitId',
		element: (
			<ProtectedRoute>
				<MinimalLayout />
			</ProtectedRoute>
		),
		children: [
			{
				index: true,
				element: <PackKitPage />
			}
		]
	},
	{
		path: '/lager/qr-aktion/:itemId',
		element: (
			<ProtectedRoute>
				<MinimalLayout />
			</ProtectedRoute>
		),
		children: [
			{
				index: true,
				element: <QrActionPage />
			}
		]
	},
	{
		path: '/login',
		element: <Suspense fallback={<div>Laden...</div>}><LoginPage /></Suspense>,
	},
	{
		path: '/forbidden',
		element: <ErrorLayout><ForbiddenPage /></ErrorLayout>,
	},
	{
		path: '*',
		element: <ErrorLayout><NotFoundPage /></ErrorLayout>,
	}
]);

export default router;
========================================================================
FILE: frontend\src\router\pageRoutes.js
========================================================================

// This file maps static frontend routes to their corresponding documentation page keys.
// It's used by the AppLayout to show the contextual help button.

const pageRoutes = {
	// User Pages
	'/home': 'dashboard',
	'/team': 'team_directory',
	'/chat': 'chat',
	'/lehrgaenge': 'lehrgaenge',
	'/veranstaltungen': 'events',
	'/lager': 'storage',
	'/dateien': 'files',
	'/kalender': 'calendar',
	'/feedback': 'feedback',
	'/changelogs': 'changelogs',
	'/profil': 'profile',
	'/profil/einstellungen': 'settings',
	'/passwort': 'password_change',
	'/suche': 'search_results',
	'/help': 'help_list',

	// Admin Pages
	'/admin/dashboard': 'admin_dashboard',
	'/admin/announcements': 'admin_announcements',
	'/admin/mitglieder': 'admin_users',
	'/admin/mitglieder/requests': 'admin_requests',
	'/admin/mitglieder/training-requests': 'admin_training_requests',
	'/admin/veranstaltungen': 'admin_events',
	'/admin/veranstaltungen/debriefings': 'admin_debriefings_list',
	'/admin/veranstaltungen/roles': 'admin_event_roles',
	'/admin/veranstaltungen/venues': 'admin_venues',
	'/admin/veranstaltungen/checklist-templates': 'admin_checklist_templates',
	'/admin/lehrgaenge': 'admin_courses',
	'/admin/lehrgaenge/matrix': 'admin_matrix',
	'/admin/lager': 'admin_storage',
	'/admin/lager/kits': 'admin_kits',
	'/admin/lager/defekte': 'admin_defective_items',
	'/admin/lager/damage-reports': 'admin_damage_reports',
	'/admin/content': 'admin_content_index',
	'/admin/content/dateien': 'admin_files',
	'/admin/content/feedback': 'admin_feedback',
	'/admin/content/changelogs': 'admin_changelogs',
	'/admin/content/documentation': 'admin_documentation',
	'/admin/reports': 'admin_reports',
	'/admin/reports/log': 'admin_log',
	'/admin/reports/system': 'admin_system',
	'/admin/benachrichtigungen': 'admin_notifications',
	'/admin/achievements': 'admin_achievements',
	'/admin/wiki': 'admin_wiki',
};

export default pageRoutes;
========================================================================
FILE: frontend\src\router\ProtectedRoute.jsx
========================================================================

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const ProtectedRoute = ({ children }) => {
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
	const location = useLocation();

	if (!isAuthenticated) {
		return <Navigate to="/login" state={{ from: location }} replace />;
	}

	return children;
};

export default ProtectedRoute;
========================================================================
FILE: frontend\src\services\apiClient.js
========================================================================

const BASE_URL = '/api/v1';

let onUnauthorizedCallback = () => { }; // Placeholder for the logout function

const apiClient = {
	setup: function(callbacks) {
		onUnauthorizedCallback = callbacks.onUnauthorized;
	},

	request: async function(endpoint, options = {}) {
		const headers = {
			...options.headers,
		};

		// Set Content-Type for JSON, but not for FormData, which needs the browser to set it.
		if (!(options.body instanceof FormData)) {
			headers['Content-Type'] = 'application/json';
		}

		try {
			const response = await fetch(`${BASE_URL}${endpoint}`, {
				...options,
				headers: headers,
				credentials: 'include'
			});

			if (response.status === 401) {
				onUnauthorizedCallback();
				throw new Error('Nicht autorisiert. Ihre Sitzung ist möglicherweise abgelaufen.');
			}
			if (response.status === 403) {
				throw new Error('Zugriff verweigert.');
			}

			if (response.status === 204) {
				return { success: true, message: 'Operation successful.', data: null };
			}

			const contentType = response.headers.get("content-type");
			if (!contentType || !contentType.includes("application/json")) {
				const textError = await response.text();
				console.error("Non-JSON API response:", textError);
				throw new Error(`Serververbindung fehlgeschlagen (Status: ${response.status}). Das Backend ist möglicherweise offline.`);
			}

			const result = await response.json();

			if (!response.ok) {
				if (response.status >= 500) {
					throw new Error("Ein interner Serverfehler ist aufgetreten. Bitte versuchen Sie es später erneut.");
				}
				throw new Error(result.message || `Ein Fehler ist aufgetreten (Status: ${response.status})`);
			}

			return result;

		} catch (error) {
			if (error instanceof TypeError && error.message === 'Failed to fetch') {
				console.error(`API Client Network Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
				throw new Error('Netzwerkfehler: Das Backend ist nicht erreichbar. Bitte überprüfen Sie, ob der Server läuft.');
			}
			console.error(`API Client Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
			throw error;
		}
	},

	get(endpoint) {
		return this.request(endpoint, { method: 'GET' });
	},

	post(endpoint, body) {
		const options = {
			method: 'POST',
			body: body instanceof FormData ? body : JSON.stringify(body),
		};
		return this.request(endpoint, options);
	},

	put(endpoint, body) {
		return this.request(endpoint, { method: 'PUT', body: JSON.stringify(body) });
	},

	delete(endpoint) {
		return this.request(endpoint, { method: 'DELETE' });
	},
};

export default apiClient;
========================================================================
FILE: frontend\src\store\authStore.js
========================================================================

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import apiClient from '../services/apiClient';

const hasAdminAccess = (roleName) => {
	// Frontend authorization check based on role.
	return roleName === 'ADMIN';
};

const defaultLayout = {
	sidebarPosition: 'left',
	navOrder: [], // Empty array means default order
	showHelpButton: true,
	dashboardWidgets: {
		recommendedEvents: true,
		assignedEvents: true,
		openTasks: true,
		upcomingEvents: true,
		recentConversations: true,
		upcomingMeetings: true,
		lowStockItems: false,
	},
};


export const useAuthStore = create(
	persist(
		(set, get) => ({
			user: null,
			navigationItems: [],
			isAuthenticated: false,
			isAdmin: false,
			theme: 'light',
			layout: defaultLayout,
			lastUpdatedEvent: null, // { id: eventId, nonce: Math.random() }
			login: async (username, password) => {
				try {
					// The login endpoint now returns the user object on success and sets the cookie
					const response = await apiClient.post('/auth/login', { username, password });
					if (response.success && response.data) {
						await get().fetchUserSession(); // Fetch full session data to be sure
						return true;
					}
					throw new Error(response.message || 'Anmeldung fehlgeschlagen');
				} catch (error) {
					console.error('Login failed:', error);
					get().logout();
					throw error;
				}
			},
			logout: async () => {
				try {
					await apiClient.post('/auth/logout');
				} catch (error) {
					console.error("Logout API call failed, clearing state anyway.", error);
				} finally {
					set({ user: null, navigationItems: [], isAuthenticated: false, isAdmin: false, theme: 'light', layout: defaultLayout, lastUpdatedEvent: null });
					localStorage.removeItem('auth-storage');
					document.documentElement.setAttribute('data-theme', 'light');
				}
			},
			fetchUserSession: async () => {
				try {
					const result = await apiClient.get('/auth/me');

					if (result.success && result.data.user && result.data.navigation) {
						const user = result.data.user;
						const newTheme = user.theme || 'light';
						let userLayout = defaultLayout;
						if (user.dashboardLayout) {
							try {
								// Deep merge the saved layout with defaults to handle new widgets
								const savedLayout = JSON.parse(user.dashboardLayout);
								userLayout = {
									...defaultLayout,
									...savedLayout,
									dashboardWidgets: {
										...defaultLayout.dashboardWidgets,
										...(savedLayout.dashboardWidgets || {})
									}
								};
							} catch (e) {
								console.error("Failed to parse user layout JSON", e);
							}
						}

						set({
							user: user,
							navigationItems: result.data.navigation,
							isAuthenticated: true,
							isAdmin: hasAdminAccess(user.roleName),
							theme: newTheme,
							layout: userLayout,
						});
						document.documentElement.setAttribute('data-theme', newTheme);
					} else {
						throw new Error(result.message || "Ungültige Sitzungsdaten vom Server.");
					}

				} catch (error) {
					console.error("Could not fetch user session. Token might be invalid.", error);
					get().logout();
					throw error;
				}
			},
			setTheme: async (newTheme) => {
				try {
					const result = await apiClient.put('/public/profile/theme', { theme: newTheme });
					if (result.success && result.data) {
						const updatedUser = result.data;
						set({
							user: updatedUser,
							theme: updatedUser.theme,
						});
						document.documentElement.setAttribute('data-theme', updatedUser.theme);
					} else {
						throw new Error(result.message || 'Server konnte das Theme nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save theme preference:", error);
				}
			},
			setLayout: async (newLayout) => {
				try {
					const result = await apiClient.put('/public/profile/layout', newLayout);
					if (result.success && result.data) {
						const updatedUser = result.data;
						let userLayout = defaultLayout;
						if (updatedUser.dashboardLayout) {
							try {
								const savedLayout = JSON.parse(updatedUser.dashboardLayout);
								userLayout = {
									...defaultLayout,
									...savedLayout,
									dashboardWidgets: {
										...defaultLayout.dashboardWidgets,
										...(savedLayout.dashboardWidgets || {})
									}
								};
							} catch (e) { console.error("Failed to parse updated layout", e); }
						}
						set({
							user: updatedUser,
							layout: userLayout,
						});
					} else {
						throw new Error(result.message || 'Server konnte das Layout nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save layout preferences:", error);
				}
			},
			triggerEventUpdate: (eventId) => {
				set({ lastUpdatedEvent: { id: eventId, nonce: Math.random() } });
			},
		}),
		{
			name: 'auth-storage',
			storage: createJSONStorage(() => localStorage),
			// We only persist non-sensitive UI state like theme. User/session data is fetched on load.
			partialize: (state) => ({ theme: state.theme }),
		}
	)
);
========================================================================
FILE: src\main\java\de\technikteam\TechnikTeamApplication.java
========================================================================

package de.technikteam;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "de.technikteam")
public class TechnikTeamApplication {

	public static void main(String[] args) {
		SpringApplication.run(TechnikTeamApplication.class, args);
	}

}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAchievementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/achievements")
@Tag(name = "Admin Achievements", description = "Endpoints for managing achievements.")
@SecurityRequirement(name = "bearerAuth")
public class AdminAchievementResource {

	private final AchievementDAO achievementDAO;

	@Autowired
	public AdminAchievementResource(AchievementDAO achievementDAO) {
		this.achievementDAO = achievementDAO;
	}

	@GetMapping
	@Operation(summary = "Get all achievements", description = "Retrieves a list of all available achievements.")
	public ResponseEntity<ApiResponse> getAllAchievements() {
		List<Achievement> achievements = achievementDAO.getAllAchievements();
		return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erfolgreich abgerufen.", achievements));
	}

	@PostMapping
	@Operation(summary = "Create an achievement", description = "Creates a new achievement definition.")
	public ResponseEntity<ApiResponse> createAchievement(@RequestBody Achievement achievement) {
		if (achievementDAO.createAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erstellt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Erstellen des Abzeichens.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an achievement", description = "Updates an existing achievement's details.")
	public ResponseEntity<ApiResponse> updateAchievement(@PathVariable int id, @RequestBody Achievement achievement) {
		achievement.setId(id);
		if (achievementDAO.updateAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren des Abzeichens.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an achievement", description = "Deletes an achievement definition.")
	public ResponseEntity<ApiResponse> deleteAchievement(@PathVariable int id) {
		if (achievementDAO.deleteAchievement(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen gelöscht.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Löschen des Abzeichens.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAnnouncementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.Announcement;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AnnouncementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/announcements")
@Tag(name = "Admin Announcements", description = "Endpoints for managing bulletin board announcements.")
public class AdminAnnouncementResource {

	private final AnnouncementService announcementService;

	@Autowired
	public AdminAnnouncementResource(AnnouncementService announcementService) {
		this.announcementService = announcementService;
	}

	@GetMapping
	@Operation(summary = "Get all announcements")
	public ResponseEntity<ApiResponse> getAllAnnouncements() {
		List<Announcement> announcements = announcementService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Announcements retrieved successfully.", announcements));
	}

	@PostMapping
	@Operation(summary = "Create a new announcement")
	public ResponseEntity<ApiResponse> createAnnouncement(@Valid @RequestBody Announcement announcement,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Announcement createdAnnouncement = announcementService.create(announcement, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Announcement created successfully.", createdAnnouncement),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an announcement")
	public ResponseEntity<ApiResponse> updateAnnouncement(@PathVariable int id,
			@Valid @RequestBody Announcement announcement, @AuthenticationPrincipal SecurityUser securityUser) {
		announcement.setId(id);
		Announcement updatedAnnouncement = announcementService.update(announcement, securityUser.getUser());
		if (updatedAnnouncement != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Announcement updated successfully.", updatedAnnouncement));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Announcement not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an announcement")
	public ResponseEntity<ApiResponse> deleteAnnouncement(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (announcementService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Announcement deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Announcement not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChangelogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ChangelogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/changelogs")
@Tag(name = "Admin Changelogs", description = "Endpoints for managing application changelogs.")
public class AdminChangelogResource {

	private final ChangelogService changelogService;

	@Autowired
	public AdminChangelogResource(ChangelogService changelogService) {
		this.changelogService = changelogService;
	}

	@GetMapping
	@Operation(summary = "Get all changelogs")
	public ResponseEntity<ApiResponse> getAllChangelogs() {
		List<Changelog> changelogs = changelogService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Changelogs retrieved successfully.", changelogs));
	}

	@PostMapping
	@Operation(summary = "Create a new changelog entry")
	public ResponseEntity<ApiResponse> createChangelog(@RequestBody Changelog changelog,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (changelogService.create(changelog, securityUser.getUser())) {
			return new ResponseEntity<>(new ApiResponse(true, "Changelog created successfully.", changelog),
					HttpStatus.CREATED);
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Failed to create changelog.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a changelog entry")
	public ResponseEntity<ApiResponse> updateChangelog(@PathVariable int id, @RequestBody Changelog changelog,
			@AuthenticationPrincipal SecurityUser securityUser) {
		changelog.setId(id);
		if (changelogService.update(changelog, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog updated successfully.", changelog));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a changelog entry")
	public ResponseEntity<ApiResponse> deleteChangelog(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (changelogService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChecklistTemplateResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ChecklistTemplateDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistTemplate;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/checklist-templates")
@Tag(name = "Admin Checklist Templates", description = "Endpoints for managing pre-flight checklist templates.")
@SecurityRequirement(name = "bearerAuth")
public class AdminChecklistTemplateResource {

	private final ChecklistTemplateDAO templateDAO;

	@Autowired
	public AdminChecklistTemplateResource(ChecklistTemplateDAO templateDAO) {
		this.templateDAO = templateDAO;
	}

	@GetMapping
	@Operation(summary = "Get all checklist templates")
	public ResponseEntity<ApiResponse> getAllTemplates() {
		List<ChecklistTemplate> templates = templateDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Vorlagen erfolgreich abgerufen.", templates));
	}

	@PostMapping
	@Operation(summary = "Create a new checklist template")
	public ResponseEntity<ApiResponse> createTemplate(@RequestBody ChecklistTemplate template) {
		ChecklistTemplate savedTemplate = templateDAO.save(template);
		return new ResponseEntity<>(new ApiResponse(true, "Vorlage erfolgreich erstellt.", savedTemplate),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a checklist template")
	public ResponseEntity<ApiResponse> updateTemplate(@PathVariable int id, @RequestBody ChecklistTemplate template) {
		template.setId(id);
		ChecklistTemplate updatedTemplate = templateDAO.save(template);
		return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich aktualisiert.", updatedTemplate));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a checklist template")
	public ResponseEntity<ApiResponse> deleteTemplate(@PathVariable int id) {
		if (templateDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Vorlage nicht gefunden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDamageReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.DamageReportDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.DamageReport;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/damage-reports")
@Tag(name = "Admin Damage Reports", description = "Endpoints for managing user-submitted damage reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDamageReportResource {

	private final DamageReportDAO damageReportDAO;
	private final StorageService storageService;

	@Autowired
	public AdminDamageReportResource(DamageReportDAO damageReportDAO, StorageService storageService) {
		this.damageReportDAO = damageReportDAO;
		this.storageService = storageService;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get all pending damage reports")
	public ResponseEntity<ApiResponse> getPendingReports() {
		List<DamageReport> reports = damageReportDAO.getPendingReports();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Meldungen abgerufen.", reports));
	}

	@PostMapping("/{reportId}/confirm")
	@Operation(summary = "Confirm a damage report")
	public ResponseEntity<ApiResponse> confirmReport(@PathVariable int reportId,
			@RequestBody Map<String, Integer> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			int quantity = payload.getOrDefault("quantity", 1);
			storageService.confirmDamageReport(reportId, quantity, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung bestätigt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{reportId}/reject")
	@Operation(summary = "Reject a damage report")
	public ResponseEntity<ApiResponse> rejectReport(@PathVariable int reportId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String adminNotes = payload.get("adminNotes");
		try {
			storageService.rejectDamageReport(reportId, adminNotes, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung abgelehnt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDashboardResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminDashboardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin/dashboard")
@Tag(name = "Admin Dashboard", description = "Endpoints for the administrative dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDashboardResource {

	private final AdminDashboardService dashboardService;

	@Autowired
	public AdminDashboardResource(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
	}

	@GetMapping
	@Operation(summary = "Get all data for the admin dashboard")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		// The service method doesn't require the user, but this demonstrates the
		// pattern.
		return ResponseEntity.ok(
				new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardService.getDashboardData()));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDocumentationResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.PageDocumentation;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.PageDocumentationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/admin/documentation")
@Tag(name = "Admin Documentation", description = "Endpoints for managing page documentation.")
public class AdminDocumentationResource {

	private final PageDocumentationService documentationService;

	@Autowired
	public AdminDocumentationResource(PageDocumentationService documentationService) {
		this.documentationService = documentationService;
	}

	@GetMapping
	@Operation(summary = "Get all documentation pages")
	public ResponseEntity<ApiResponse> getAllDocs() {
		List<PageDocumentation> docs = documentationService.findAll(true);
		return ResponseEntity.ok(new ApiResponse(true, "Documentation pages retrieved.", docs));
	}

	@GetMapping("/{pageKey}")
	@Operation(summary = "Get a single documentation page by key")
	public ResponseEntity<ApiResponse> getDocByKey(@PathVariable String pageKey) {
		Optional<PageDocumentation> doc = documentationService.findByKey(pageKey);
		return doc.map(d -> ResponseEntity.ok(new ApiResponse(true, "Documentation retrieved.", d)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Documentation not found.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new documentation page")
	public ResponseEntity<ApiResponse> createDoc(@Valid @RequestBody PageDocumentation doc,
			@AuthenticationPrincipal SecurityUser securityUser) {
		PageDocumentation createdDoc = documentationService.create(doc, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Documentation created successfully.", createdDoc),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a documentation page")
	public ResponseEntity<ApiResponse> updateDoc(@PathVariable int id, @Valid @RequestBody PageDocumentation doc,
			@AuthenticationPrincipal SecurityUser securityUser) {
		doc.setId(id);
		PageDocumentation updatedDoc = documentationService.update(doc, securityUser.getUser());
		if (updatedDoc != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Documentation updated successfully.", updatedDoc));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a documentation page")
	public ResponseEntity<ApiResponse> deleteDoc(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (documentationService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Documentation deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventDebriefingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventDebriefingDTO;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventDebriefingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventDebriefing;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventDebriefingService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/admin/events")
@Tag(name = "Admin Event Debriefings", description = "Endpoints for managing post-event reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventDebriefingResource {

	private final EventDebriefingDAO debriefingDAO;
	private final EventDebriefingService debriefingService;
	private final EventDAO eventDAO;

	@Autowired
	public AdminEventDebriefingResource(EventDebriefingDAO debriefingDAO, EventDebriefingService debriefingService,
			EventDAO eventDAO) {
		this.debriefingDAO = debriefingDAO;
		this.debriefingService = debriefingService;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/debriefings")
	@Operation(summary = "Get all debriefing reports")
	public ResponseEntity<ApiResponse> getAllDebriefings() {
		List<EventDebriefing> debriefings = debriefingDAO.findAll().stream().map(debriefingService::enrichDebriefing)
				.collect(Collectors.toList());
		return ResponseEntity.ok(new ApiResponse(true, "Debriefings abgerufen.", debriefings));
	}

	@GetMapping("/{eventId}/debriefing")
	@Operation(summary = "Get a debriefing for a specific event")
	public ResponseEntity<ApiResponse> getDebriefingForEvent(@PathVariable int eventId) {
		Optional<EventDebriefing> debriefingOpt = debriefingDAO.findByEventId(eventId);
		if (debriefingOpt.isPresent()) {
			return ResponseEntity.ok(new ApiResponse(true, "Debriefing abgerufen.",
					debriefingService.enrichDebriefing(debriefingOpt.get())));
		} else {
			return ResponseEntity.ok(new ApiResponse(true, "Kein Debriefing für dieses Event vorhanden.", null));
		}
	}

	@PostMapping("/{eventId}/debriefing")
	@Operation(summary = "Create or update a debriefing for an event")
	public ResponseEntity<ApiResponse> saveDebriefing(@PathVariable int eventId,
			@Valid @RequestBody EventDebriefingDTO dto, @AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Event nicht gefunden.", null));
		}

		try {
			EventDebriefing savedDebriefing = debriefingService.saveDebriefing(eventId, dto, user);
			return new ResponseEntity<>(new ApiResponse(true, "Debriefing erfolgreich gespeichert.", savedDebriefing),
					HttpStatus.CREATED);
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventUpdateRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events")
@Tag(name = "Admin Events", description = "Endpoints for managing events.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;

	@Autowired
	public AdminEventResource(EventDAO eventDAO, EventService eventService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(1); // Default system user ID
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all events", description = "Retrieves a list of all events in the system, sorted by date.")
	public ResponseEntity<ApiResponse> getAllEvents() {
		List<Event> events = eventDAO.getAllEvents();
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@PostMapping
	@Operation(summary = "Create a new event", description = "Creates a new event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> createEvent(@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file) {
		try {
			User adminUser = getSystemUser();
			Event event = new Event();
			mapDtoToEvent(eventData, event);

			int newEventId = eventService.createOrUpdateEvent(event, false, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return new ResponseEntity<>(
					new ApiResponse(true, "Veranstaltung erfolgreich erstellt.", Map.of("id", newEventId)),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Erstellen der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update an event", description = "Updates an existing event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> updateEvent(@PathVariable int id,
			@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file) {
		try {
			User adminUser = getSystemUser();
			Event event = eventDAO.getEventById(id);
			if (event == null) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
			}
			mapDtoToEvent(eventData, event);
			event.setId(id); // Ensure ID is set for update

			eventService.createOrUpdateEvent(event, true, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Fehler beim Aktualisieren der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone an event", description = "Creates a deep copy of an existing event, including its details, requirements, and tasks.")
	public ResponseEntity<ApiResponse> cloneEvent(@PathVariable int id) {
		try {
			Event clonedEvent = eventService.cloneEvent(id, getSystemUser());
			return new ResponseEntity<>(new ApiResponse(true, "Event erfolgreich geklont.", clonedEvent),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Events fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event", description = "Permanently deletes an event and all associated data.")
	public ResponseEntity<ApiResponse> deleteEvent(@PathVariable int id) {
		if (eventDAO.deleteEvent(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich gelöscht.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Löschen der Veranstaltung.", null));
		}
	}

	private void mapDtoToEvent(EventUpdateRequest dto, Event event) {
		event.setName(dto.name());
		event.setEventDateTime(dto.eventDateTime());
		event.setEndDateTime(dto.endDateTime());
		event.setDescription(dto.description());
		event.setLocation(dto.location());
		event.setStatus(dto.status());
		event.setLeaderUserId(dto.leaderUserId() != null && dto.leaderUserId() != 0 ? dto.leaderUserId() : 0);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventRoleResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.EventRoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventRole;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/event-roles")
@Tag(name = "Admin Event Roles", description = "Endpoints for managing predefined event roles.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventRoleResource {

	private final EventRoleDAO eventRoleDAO;

	@Autowired
	public AdminEventRoleResource(EventRoleDAO eventRoleDAO) {
		this.eventRoleDAO = eventRoleDAO;
	}

	@GetMapping
	@Operation(summary = "Get all event roles")
	public ResponseEntity<ApiResponse> getAllRoles() {
		List<EventRole> roles = eventRoleDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Rollen erfolgreich abgerufen.", roles));
	}

	@PostMapping
	@Operation(summary = "Create a new event role")
	public ResponseEntity<ApiResponse> createRole(@Valid @RequestBody EventRole role) {
		if (eventRoleDAO.create(role)) {
			return new ResponseEntity<>(new ApiResponse(true, "Rolle erfolgreich erstellt.", role), HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Rolle konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an event role")
	public ResponseEntity<ApiResponse> updateRole(@PathVariable int id, @Valid @RequestBody EventRole role) {
		role.setId(id);
		if (eventRoleDAO.update(role)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich aktualisiert.", role));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event role")
	public ResponseEntity<ApiResponse> deleteRole(@PathVariable int id) {
		if (eventRoleDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFeedbackResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/feedback")
@Tag(name = "Admin Feedback", description = "Endpoints for managing user feedback.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;

	@Autowired
	public AdminFeedbackResource(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get all feedback submissions", description = "Retrieves all feedback submissions from all users, ordered by status.")
	public ResponseEntity<ApiResponse> getAllSubmissions() {
		List<FeedbackSubmission> submissions = submissionDAO.getAllSubmissions();
		return ResponseEntity.ok(new ApiResponse(true, "Alle Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PutMapping("/{id}/status")
	@Operation(summary = "Update feedback status", description = "Updates the status of a specific feedback submission.")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int id, @RequestBody Map<String, String> payload) {
		String newStatus = payload.get("status");
		FeedbackSubmission submission = submissionDAO.getSubmissionById(id);
		if (submission == null) {
			return ResponseEntity.notFound().build();
		}
		if (submissionDAO.updateStatusAndTitle(id, newStatus, submission.getDisplayTitle())) {
			return ResponseEntity.ok(new ApiResponse(true, "Status aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFileResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.CategoryRequest;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/admin/files")
@Tag(name = "Admin Files", description = "Endpoints for managing files and categories.")
public class AdminFileResource {

	private final FileDAO fileDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminFileResource(FileDAO fileDAO, FileService fileService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	@PostMapping
	@Operation(summary = "Upload a new file")
	public ResponseEntity<ApiResponse> uploadFile(@RequestParam("file") MultipartFile file,
			@RequestParam(required = false) Integer categoryId, @RequestParam String requiredRole,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, categoryId, requiredRole,
					securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Datei erfolgreich hochgeladen.", savedFile),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei konnte nicht hochgeladen werden: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a file")
	public ResponseEntity<ApiResponse> deleteFile(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (fileService.deleteFile(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich gelöscht.", Map.of("deletedId", id)));
			} else {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Datei nicht gefunden.", null));
			}
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Datei konnte aufgrund eines Serverfehlers nicht gelöscht werden.", null));
		}
	}

	@PostMapping("/categories")
	@Operation(summary = "Create a new file category")
	public ResponseEntity<ApiResponse> createCategory(@Valid @RequestBody CategoryRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (fileDAO.createCategory(request.name())) {
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_FILE_CATEGORY_API",
					"Category '" + request.name() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kategorie erfolgreich erstellt.", null),
					HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false,
				"Kategorie konnte nicht erstellt werden. Der Name existiert möglicherweise bereits.", null));
	}

	@DeleteMapping("/categories/{id}")
	@Operation(summary = "Delete a file category")
	public ResponseEntity<ApiResponse> deleteCategory(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String categoryName = fileDAO.getCategoryNameById(id);
		if (categoryName != null && fileDAO.deleteCategory(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_FILE_CATEGORY_API",
					"Category '" + categoryName + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kategorie erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kategorie nicht gefunden oder konnte nicht gelöscht werden.", null));
	}

	@GetMapping
	@Operation(summary = "Get all files grouped by category (Admin View)")
	public ResponseEntity<ApiResponse> getAllFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		Map<String, List<de.technikteam.model.File>> groupedFiles = fileDAO
				.getAllFilesGroupedByCategory(securityUser.getUser());
		List<de.technikteam.model.File> rawFiles = fileDAO.getAllFilesForAdmin();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("grouped", groupedFiles);
		responseData.put("raw", rawFiles);

		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", responseData));
	}

	@GetMapping("/categories")
	@Operation(summary = "Get all file categories")
	public ResponseEntity<ApiResponse> getAllCategories() {
		List<FileCategory> categories = fileDAO.getAllCategories();
		return ResponseEntity.ok(new ApiResponse(true, "Kategorien erfolgreich abgerufen.", categories));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFormDataResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/users/form-data")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFormDataResource {

	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;

	@Autowired
	public AdminFormDataResource(RoleDAO roleDAO, PermissionDAO permissionDAO) {
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get data for user forms", description = "Retrieves all roles and grouped permissions needed to populate admin forms for creating or editing users.")
	public ResponseEntity<ApiResponse> getFormDataForUserForms() {
		List<Role> roles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			if (key.contains("_")) {
				return key.substring(0, key.indexOf("_"));
			}
			return "SYSTEM";
		}));

		Map<String, Object> formData = Map.of("roles", roles, "groupedPermissions", groupedPermissions);

		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", formData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminNotificationResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.NotificationRequest;
import de.technikteam.config.Permissions;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/api/v1/admin/notifications")
@Tag(name = "Admin Notifications", description = "Endpoints for sending and receiving notifications.")
@SecurityRequirement(name = "bearerAuth")
public class AdminNotificationResource {

	private final NotificationService notificationService;

	@Autowired
	public AdminNotificationResource(NotificationService notificationService) {
		this.notificationService = notificationService;
	}

	@GetMapping("/sse")
	@Operation(summary = "Subscribe to SSE notifications", description = "Establishes a Server-Sent Events connection for real-time notifications.")
	public SseEmitter handleSse(@AuthenticationPrincipal SecurityUser securityUser) {
		return notificationService.register(securityUser.getUser());
	}

	@PostMapping
	@Operation(summary = "Send a broadcast notification", description = "Sends a real-time notification to a specified group of users.")
	public ResponseEntity<ApiResponse> sendNotification(@Valid @RequestBody NotificationRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User adminUser = securityUser.getUser();

		try {
			int recipients = notificationService.sendBroadcastNotification(request, adminUser);
			return ResponseEntity
					.ok(new ApiResponse(true, "Benachrichtigung an " + recipients + " Empfänger gesendet.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Senden der Benachrichtigung fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.ProfileRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/requests")
@Tag(name = "Admin Requests", description = "Endpoints for managing user-submitted requests.")
public class AdminRequestResource {

	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService requestService;
	private final UserDAO userDAO;

	@Autowired
	public AdminRequestResource(ProfileChangeRequestDAO requestDAO, ProfileRequestService requestService,
			UserDAO userDAO) {
		this.requestDAO = requestDAO;
		this.requestService = requestService;
		this.userDAO = userDAO;
	}

	private User getSystemUser() {
		// Use the default admin user, which is guaranteed to exist by the
		// InitialAdminCreator
		User user = userDAO.getUserByUsername("admin");
		if (user == null) {
			// This is a critical state and should not happen in a properly initialized
			// system.
			// Throw a runtime exception to make the problem visible in the logs.
			throw new IllegalStateException("The default 'admin' user could not be found in the database.");
		}
		return user;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get pending requests", description = "Retrieves a list of all profile change requests that are pending review.")
	public ResponseEntity<ApiResponse> getPendingRequests() {
		List<ProfileChangeRequest> requests = requestDAO.getPendingRequests();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Anträge erfolgreich abgerufen.", requests));
	}

	@PostMapping("/{id}/approve")
	@Operation(summary = "Approve a request", description = "Approves a profile change request and applies the changes to the user's profile.")
	public ResponseEntity<ApiResponse> approveRequest(
			@Parameter(description = "ID of the request to approve") @PathVariable int id) {
		try {
			if (requestService.approveRequest(id, getSystemUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag genehmigt und Benutzer aktualisiert.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht genehmigt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/deny")
	@Operation(summary = "Deny a request", description = "Denies a profile change request.")
	public ResponseEntity<ApiResponse> denyRequest(
			@Parameter(description = "ID of the request to deny") @PathVariable int id) {
		try {
			if (requestService.denyRequest(id, getSystemUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag abgelehnt.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht abgelehnt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminStorageRelationsResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.service.StorageItemRelationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/storage/{itemId}/relations")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
public class AdminStorageRelationsResource {

	private final StorageItemRelationService relationService;

	@Autowired
	public AdminStorageRelationsResource(StorageItemRelationService relationService) {
		this.relationService = relationService;
	}

	@GetMapping
	@Operation(summary = "Get related items for a storage item")
	public ResponseEntity<ApiResponse> getRelatedItems(@PathVariable int itemId) {
		return ResponseEntity
				.ok(new ApiResponse(true, "Related items retrieved.", relationService.findRelatedItems(itemId)));
	}

	@PutMapping
	@Operation(summary = "Update related items for a storage item")
	public ResponseEntity<ApiResponse> updateRelatedItems(@PathVariable int itemId,
			@RequestBody Map<String, List<Integer>> payload) {
		List<Integer> relatedItemIds = payload.get("relatedItemIds");
		if (relatedItemIds == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Payload must contain 'relatedItemIds'.", null));
		}
		relationService.updateRelations(itemId, relatedItemIds);
		return ResponseEntity.ok(new ApiResponse(true, "Related items updated successfully.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminTrainingRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.TrainingRequest;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.TrainingRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/training-requests")
@Tag(name = "Admin Training Requests", description = "Endpoints for managing user-initiated training requests.")
public class AdminTrainingRequestResource {

	private final TrainingRequestService trainingRequestService;

	@Autowired
	public AdminTrainingRequestResource(TrainingRequestService trainingRequestService) {
		this.trainingRequestService = trainingRequestService;
	}

	@GetMapping
	@Operation(summary = "Get all training requests")
	public ResponseEntity<ApiResponse> getAllRequests() {
		List<TrainingRequest> requests = trainingRequestService.findAllWithInterestCount();
		return ResponseEntity.ok(new ApiResponse(true, "Training requests retrieved successfully.", requests));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a training request")
	public ResponseEntity<ApiResponse> deleteRequest(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (trainingRequestService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Training request deleted successfully.", null));
		}
		return ResponseEntity.notFound().build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminVenueResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.Venue;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import de.technikteam.dao.VenueDAO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/admin/venues")
@Tag(name = "Admin Venues", description = "Endpoints for managing event venues and maps.")
public class AdminVenueResource {

	private final VenueDAO venueDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminVenueResource(VenueDAO venueDAO, FileService fileService, AdminLogService adminLogService) {
		this.venueDAO = venueDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all venues")
	public ResponseEntity<ApiResponse> getAllVenues() {
		List<Venue> venues = venueDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Venues retrieved successfully.", venues));
	}

	@PostMapping
	@Operation(summary = "Create a new venue")
	public ResponseEntity<ApiResponse> createVenue(@RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage) throws IOException {
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER", getSystemUser(),
					"venues");
			venue.setMapImagePath(savedFile.getFilepath());
		}
		Venue createdVenue = venueDAO.create(venue);
		adminLogService.log(getSystemUser().getUsername(), "VENUE_CREATE",
				"Venue '" + createdVenue.getName() + "' created.");
		return new ResponseEntity<>(new ApiResponse(true, "Venue created successfully.", createdVenue),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a venue")
	public ResponseEntity<ApiResponse> updateVenue(@PathVariable int id, @RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage) throws IOException {
		venue.setId(id);
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER", getSystemUser(),
					"venues");
			venue.setMapImagePath(savedFile.getFilepath());
		} else if (venue.getMapImagePath() == null) {
			// Preserve existing image if a new one is not uploaded but path is not null in
			// DTO
			Optional<Venue> existingVenue = venueDAO.findById(id);
			existingVenue.ifPresent(v -> venue.setMapImagePath(v.getMapImagePath()));
		}

		if (venueDAO.update(venue)) {
			adminLogService.log(getSystemUser().getUsername(), "VENUE_UPDATE",
					"Venue '" + venue.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue updated successfully.", venue));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a venue")
	public ResponseEntity<ApiResponse> deleteVenue(@PathVariable int id) {
		Optional<Venue> venue = venueDAO.findById(id);
		if (venue.isPresent() && venueDAO.delete(id)) {
			adminLogService.log(getSystemUser().getUsername(), "VENUE_DELETE",
					"Venue '" + venue.get().getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ChecklistResource.java
========================================================================

package de.technikteam.api.v1;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.ChecklistDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.websocket.ChatSessionManager;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events/{eventId}/checklist")
@Tag(name = "Event Checklists", description = "Endpoints for managing event inventory checklists.")
public class ChecklistResource {

	private final ChecklistDAO checklistDAO;
	private final ChatSessionManager sessionManager;
	private final Gson gson;

	@Autowired
	public ChecklistResource(ChecklistDAO checklistDAO, ChatSessionManager sessionManager) {
		this.checklistDAO = checklistDAO;
		this.sessionManager = sessionManager;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@GetMapping
	@Operation(summary = "Get the checklist for an event")
	public ResponseEntity<ApiResponse> getChecklist(@PathVariable int eventId) {
		List<ChecklistItem> checklist = checklistDAO.getChecklistForEvent(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "Checkliste erfolgreich abgerufen.", checklist));
	}

	@PostMapping("/generate")
	@Operation(summary = "Generate or refresh a checklist from reservations")
	public ResponseEntity<ApiResponse> generateChecklist(@PathVariable int eventId) {
		int rowsAffected = checklistDAO.generateChecklistFromReservations(eventId);
		return ResponseEntity
				.ok(new ApiResponse(true, rowsAffected + " Einträge in der Checkliste erstellt/aktualisiert.", null));
	}

	@PutMapping("/{checklistItemId}/status")
	@Operation(summary = "Update the status of a checklist item")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int eventId, @PathVariable int checklistItemId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String status = payload.get("status");
		if (status == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Status ist erforderlich.", null));
		}

		if (checklistDAO.updateChecklistItemStatus(checklistItemId, status, securityUser.getUser().getId())) {
			ChecklistItem updatedItem = checklistDAO.getChecklistItemById(checklistItemId);

			Map<String, Object> broadcastPayload = Map.of("type", "checklist_update", "payload", updatedItem);
			sessionManager.broadcast(String.valueOf(eventId), gson.toJson(broadcastPayload));

			return ResponseEntity.ok(new ApiResponse(true, "Status erfolgreich aktualisiert.", updatedItem));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\CourseResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/courses")
@Tag(name = "Admin Courses", description = "Endpoints for managing course templates.")
public class CourseResource {

	private final CourseDAO courseDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public CourseResource(CourseDAO courseDAO, AdminLogService adminLogService) {
		this.courseDAO = courseDAO;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all course templates")
	public ResponseEntity<ApiResponse> getAllCourses() {
		List<Course> courses = courseDAO.getAllCourses();
		return ResponseEntity.ok(new ApiResponse(true, "Lehrgänge erfolgreich abgerufen.", courses));
	}

	@PostMapping
	@Operation(summary = "Create a new course template")
	public ResponseEntity<ApiResponse> createCourse(@RequestBody Course course) {
		if (courseDAO.createCourse(course)) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_COURSE_API",
					"Course '" + course.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Lehrgang erfolgreich erstellt.", course),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Lehrgang konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a course template")
	public ResponseEntity<ApiResponse> updateCourse(@PathVariable int id, @RequestBody Course course) {
		course.setId(id);
		if (courseDAO.updateCourse(course)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_COURSE_API",
					"Course '" + course.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich aktualisiert.", course));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a course template")
	public ResponseEntity<ApiResponse> deleteCourse(@PathVariable int id) {
		Course course = courseDAO.getCourseById(id);
		if (course != null && courseDAO.deleteCourse(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_COURSE_API",
					"Course '" + course.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\EventTaskResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventTaskService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events/{eventId}/tasks")
@Tag(name = "Event Tasks", description = "Endpoints for managing tasks within an event.")
public class EventTaskResource {

	private static final Logger logger = LogManager.getLogger(EventTaskResource.class);
	private final EventTaskService eventTaskService;

	@Autowired
	public EventTaskResource(EventTaskService eventTaskService) {
		this.eventTaskService = eventTaskService;
	}

	@PostMapping
	@Operation(summary = "Create or update an event task")
	public ResponseEntity<ApiResponse> saveTask(@PathVariable int eventId, @RequestBody EventTask task,
			@AuthenticationPrincipal SecurityUser securityUser) {
		logger.debug("Received request to save task for event {}: {}", eventId, task.getDescription());
		try {
			task.setEventId(eventId);
			// Assuming userIds, itemIds etc. are part of the task DTO or handled
			// differently
			int taskId = eventTaskService.saveTaskAndHandleMentions(task,
					task.getAssignedUsers().stream().mapToInt(User::getId).toArray(), null, null, null, // Simplified
																										// for now,
																										// assuming
																										// these are not
																										// sent in this
																										// payload
					task.getDependsOn().stream().mapToInt(EventTask::getId).toArray(), securityUser.getUser());
			logger.info("Task {} for event {} saved successfully with ID: {}", task.getDescription(), eventId, taskId);
			return new ResponseEntity<>(new ApiResponse(true, "Task saved successfully.", Map.of("taskId", taskId)),
					HttpStatus.OK);
		} catch (Exception e) {
			logger.error("Failed to save task for event {}", eventId, e);
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Failed to save task: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{taskId}/action")
	@Operation(summary = "Perform a user action on a task (status change, claim, unclaim)")
	public ResponseEntity<ApiResponse> performTaskAction(@PathVariable int eventId, @PathVariable int taskId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String action = payload.get("action");
		String status = payload.get("status");
		logger.debug("Received action '{}' for task {} in event {}", action, taskId, eventId);

		try {
			eventTaskService.performUserTaskAction(eventId, taskId, action, status, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich ausgeführt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (SecurityException e) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			logger.error("Error performing task action", e);
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein interner Fehler ist aufgetreten.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\KitResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/kits")
@Tag(name = "Admin Kits", description = "Endpoints for managing inventory kits.")
public class KitResource {

	private final InventoryKitDAO kitDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public KitResource(InventoryKitDAO kitDAO, AdminLogService adminLogService) {
		this.kitDAO = kitDAO;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all kits with their items")
	public ResponseEntity<ApiResponse> getAllKits() {
		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		return ResponseEntity.ok(new ApiResponse(true, "Kits erfolgreich abgerufen.", kits));
	}

	@PostMapping
	@Operation(summary = "Create a new kit")
	public ResponseEntity<ApiResponse> createKit(@RequestBody InventoryKit kit) {
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			kit.setId(newId);
			adminLogService.log(getSystemUser().getUsername(), "CREATE_KIT_API",
					"Kit '" + kit.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kit erfolgreich erstellt.", kit), HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Kit konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a kit's metadata")
	public ResponseEntity<ApiResponse> updateKit(@PathVariable int id, @RequestBody InventoryKit kit) {
		kit.setId(id);
		if (kitDAO.updateKit(kit)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_KIT_API",
					"Kit '" + kit.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich aktualisiert.", kit));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a kit")
	public ResponseEntity<ApiResponse> deleteKit(@PathVariable int id) {
		InventoryKit kit = kitDAO.getKitById(id);
		if (kit != null && kitDAO.deleteKit(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_KIT_API",
					"Kit '" + kit.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\LogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
@Tag(name = "Admin Logs", description = "Endpoints for viewing the admin action log.")
@SecurityRequirement(name = "bearerAuth")
public class LogResource {

	private final AdminLogDAO logDAO;

	@Autowired
	public LogResource(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	@GetMapping
	@Operation(summary = "Get admin action logs", description = "Retrieves a list of all administrative actions. Can be limited.")
	public ResponseEntity<ApiResponse> getLogs(@RequestParam(required = false) Integer limit) {
		List<AdminLog> logs;
		if (limit != null) {
			logs = logDAO.getRecentLogs(limit);
		} else {
			logs = logDAO.getAllLogs();
		}
		return ResponseEntity.ok(new ApiResponse(true, "Protokolle erfolgreich abgerufen.", logs));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MatrixResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/matrix")
@Tag(name = "Admin Matrix", description = "Endpoints for the qualification matrix.")
@SecurityRequirement(name = "bearerAuth")
public class MatrixResource {

	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;

	@Autowired
	public MatrixResource(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get qualification matrix data")
	public ResponseEntity<ApiResponse> getMatrixData() {
		List<User> allUsers = userDAO.getAllUsers();
		List<Course> allCourses = courseDAO.getAllCourses();

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			meetingsByCourse.put(course.getId(), meetingDAO.getMeetingsForCourse(course.getId()));
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("users", allUsers);
		responseData.put("courses", allCourses);
		responseData.put("meetingsByCourse", meetingsByCourse);
		responseData.put("attendanceMap", attendanceMap);

		return ResponseEntity.ok(new ApiResponse(true, "Matrixdaten erfolgreich abgerufen.", responseData));
	}

	@PutMapping("/attendance")
	@Operation(summary = "Update meeting attendance")
	public ResponseEntity<ApiResponse> updateAttendance(@RequestBody MeetingAttendance attendance) {
		boolean success = meetingAttendanceDAO.setAttendance(attendance.getUserId(), attendance.getMeetingId(),
				attendance.getAttended(), attendance.getRemarks());
		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Teilnahme aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren der Teilnahme.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MeetingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MeetingRequest;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/meetings")
@Tag(name = "Admin Meetings", description = "Endpoints for managing specific training meetings.")
public class MeetingResource {

	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;
	private final EventService eventService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public MeetingResource(MeetingDAO meetingDAO, AdminLogService adminLogService, EventService eventService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		this.eventService = eventService;
		this.richTextPolicy = richTextPolicy;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all meetings for a course")
	public ResponseEntity<ApiResponse> getMeetingsForCourse(@RequestParam int courseId) {
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single meeting by ID")
	public ResponseEntity<ApiResponse> getMeetingById(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich abgerufen.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Termin nicht gefunden.", null));
	}

	@PostMapping
	@Operation(summary = "Create a new meeting")
	public ResponseEntity<ApiResponse> createMeeting(@Valid @RequestBody MeetingRequest request) {
		Meeting meeting = new Meeting();
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		int newId = meetingDAO.createMeeting(meeting);
		if (newId > 0) {
			meeting.setId(newId);
			adminLogService.log(getSystemUser().getUsername(), "CREATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Termin erfolgreich erstellt.", meeting),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Termin konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a meeting")
	public ResponseEntity<ApiResponse> updateMeeting(@PathVariable int id, @Valid @RequestBody MeetingRequest request) {
		Meeting meeting = new Meeting();
		meeting.setId(id);
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		if (meetingDAO.updateMeeting(meeting)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich aktualisiert.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone a meeting")
	public ResponseEntity<ApiResponse> cloneMeeting(@PathVariable int id) {
		try {
			Meeting clonedMeeting = eventService.cloneMeeting(id, getSystemUser());
			return new ResponseEntity<>(new ApiResponse(true, "Meeting erfolgreich geklont.", clonedMeeting),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Meetings fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a meeting")
	public ResponseEntity<ApiResponse> deleteMeeting(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null && meetingDAO.deleteMeeting(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_MEETING_API",
					"Meeting '" + meeting.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ReportDAO;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/reports")
@Tag(name = "Admin Reports", description = "Endpoints for generating reports and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class ReportResource {

	private final ReportDAO reportDAO;

	@Autowired
	public ReportResource(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@GetMapping("/dashboard")
	@Operation(summary = "Get dashboard report data", description = "Retrieves aggregated data for the admin dashboard, including event trends and user activity.")
	public ResponseEntity<ApiResponse> getDashboardReport() {
		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("eventTrend", reportDAO.getEventCountByMonth(12));
		dashboardData.put("userActivity", reportDAO.getUserParticipationStats(10));
		dashboardData.put("totalInventoryValue", reportDAO.getTotalInventoryValue());
		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\StorageResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/storage")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
public class StorageResource {

	private final StorageDAO storageDAO;
	private final StorageService storageService;
	private final AdminLogService adminLogService;

	@Autowired
	public StorageResource(StorageDAO storageDAO, StorageService storageService, AdminLogService adminLogService) {
		this.storageDAO = storageDAO;
		this.storageService = storageService;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all storage items")
	public ResponseEntity<ApiResponse> getAllItems() {
		List<StorageItem> items = storageDAO.getAllItems();
		return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich abgerufen.", items));
	}

	@PostMapping
	@Operation(summary = "Create a new storage item")
	public ResponseEntity<ApiResponse> createItem(@RequestBody StorageItem item) {
		if (storageDAO.createItem(item)) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Artikel erfolgreich erstellt.", item),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Artikel konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a storage item's defect/repair status")
	public ResponseEntity<ApiResponse> updateItemStatus(@PathVariable int id,
			@RequestBody Map<String, Object> payload) {
		try {
			// This endpoint is now specifically for defect/repair actions
			storageService.handleItemStatusUpdate(id, payload, getSystemUser());
			return ResponseEntity.ok(new ApiResponse(true, "Artikelstatus erfolgreich aktualisiert.", null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update a storage item's core details")
	public ResponseEntity<ApiResponse> updateItemDetails(@PathVariable int id, @ModelAttribute StorageItem item) {
		item.setId(id);
		if (storageDAO.updateItem(item)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich aktualisiert.", item));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a storage item")
	public ResponseEntity<ApiResponse> deleteItem(@PathVariable int id) {
		StorageItem item = storageDAO.getItemById(id);
		if (item != null && storageDAO.deleteItem(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\SystemResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/system")
@Tag(name = "Admin System", description = "Endpoints for retrieving system information and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class SystemResource {

	private final SystemInfoService systemInfoService;

	@Autowired
	public SystemResource(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
	}

	@GetMapping("/stats")
	@Operation(summary = "Get system statistics", description = "Retrieves current system statistics like CPU load, memory usage, and disk space.")
	public ResponseEntity<ApiResponse> getSystemStats() {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		return ResponseEntity.ok(new ApiResponse(true, "Systemstatistiken erfolgreich abgerufen.", stats));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\UserResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.UserCreateRequest;
import de.technikteam.api.v1.dto.UserUpdateRequest;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.service.UserService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.security.SecureRandom;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
public class UserResource {

	private final UserService userService;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public UserResource(UserService userService, UserDAO userDAO, AdminLogService adminLogService,
			LoginAttemptService loginAttemptService) {
		this.userService = userService;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.loginAttemptService = loginAttemptService;
	}

	private String getSystemUsername() {
		return "SYSTEM";
	}

	@GetMapping
	@Operation(summary = "Get all users", description = "Retrieves a list of all users in the system.")
	public ResponseEntity<ApiResponse> getAllUsers() {
		List<User> users = userDAO.getAllUsers();
		return ResponseEntity.ok(new ApiResponse(true, "Users retrieved successfully", users));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get user by ID", description = "Retrieves a single user by their ID, including their permissions.")
	public ResponseEntity<ApiResponse> getUserById(
			@Parameter(description = "ID of the user to retrieve") @PathVariable int id) {
		User user = userDAO.getUserById(id);
		if (user != null) {
			return ResponseEntity.ok(new ApiResponse(true, "User retrieved successfully", user));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found", null));
		}
	}

	@PostMapping
	@Operation(summary = "Create a new user", description = "Creates a new user with a specified role and individual permissions.")
	public ResponseEntity<ApiResponse> createUser(@Valid @RequestBody UserCreateRequest createRequest) {
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(createRequest.password());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "Password does not meet policy: " + validationResult.getMessage(), null));
		}

		User newUser = new User();
		newUser.setUsername(createRequest.username());
		newUser.setRoleId(createRequest.roleId());
		newUser.setEmail(createRequest.email());
		newUser.setClassYear(createRequest.classYear() != null ? createRequest.classYear() : 0);
		newUser.setClassName(createRequest.className());

		String[] permissionIds = createRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		int newUserId = userService.createUserWithPermissions(newUser, createRequest.password(), permissionIds,
				getSystemUsername());
		if (newUserId > 0) {
			User createdUser = userDAO.getUserById(newUserId);
			return new ResponseEntity<>(new ApiResponse(true, "User created successfully", createdUser),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "User could not be created (username or email may already exist).", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a user", description = "Updates an existing user's profile details, role, and individual permissions.")
	public ResponseEntity<ApiResponse> updateUser(
			@Parameter(description = "ID of the user to update") @PathVariable int id,
			@Valid @RequestBody UserUpdateRequest updateRequest) {

		User userToUpdate = userDAO.getUserById(id);
		if (userToUpdate == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found.", null));
		}

		userToUpdate.setUsername(updateRequest.username());
		userToUpdate.setRoleId(updateRequest.roleId());
		userToUpdate.setEmail(updateRequest.email());
		userToUpdate.setClassYear(updateRequest.classYear() != null ? updateRequest.classYear() : 0);
		userToUpdate.setClassName(updateRequest.className());
		userToUpdate.setAdminNotes(updateRequest.adminNotes());

		String[] permissionIds = updateRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		if (userService.updateUserWithPermissions(userToUpdate, permissionIds)) {
			adminLogService.log(getSystemUsername(), "UPDATE_USER_API",
					"User '" + userToUpdate.getUsername() + "' (ID: " + id + ") updated via API.");
			User refreshedUser = userDAO.getUserById(id);
			return ResponseEntity.ok(new ApiResponse(true, "User updated successfully", refreshedUser));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to update user.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a user", description = "Permanently deletes a user from the system.")
	public ResponseEntity<ApiResponse> deleteUser(
			@Parameter(description = "ID of the user to delete") @PathVariable int id) {

		User userToDelete = userDAO.getUserById(id);
		if (userToDelete == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to delete not found.", null));
		}

		if (userToDelete.getId() == 1) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "The default admin account cannot be deleted.", null));
		}

		if (userDAO.deleteUser(id)) {
			adminLogService.log(getSystemUsername(), "DELETE_USER_API",
					"User '" + userToDelete.getUsername() + "' (ID: " + id + ") deleted via API.");
			return ResponseEntity.ok(new ApiResponse(true, "User deleted successfully", Map.of("deletedUserId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete user.", null));
		}
	}

	@PostMapping("/{id}/reset-password")
	@Operation(summary = "Reset user's password", description = "Resets a user's password to a new, randomly generated password.")
	public ResponseEntity<ApiResponse> resetPassword(
			@Parameter(description = "ID of the user whose password will be reset") @PathVariable int id) {

		User userToReset = userDAO.getUserById(id);
		if (userToReset == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to reset not found.", null));
		}

		String newPassword = generateRandomPassword(12);
		if (userDAO.changePassword(id, newPassword)) {
			adminLogService.log(getSystemUsername(), "RESET_PASSWORD_API",
					"Password for user '" + userToReset.getUsername() + "' (ID: " + id + ") reset via API.");
			return ResponseEntity
					.ok(new ApiResponse(true, "Password for " + userToReset.getUsername() + " has been reset.",
							Map.of("username", userToReset.getUsername(), "newPassword", newPassword)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Password could not be reset.", null));
		}
	}

	@PostMapping("/{id}/unlock")
	@Operation(summary = "Unlock a user account", description = "Unlocks a user account that was locked due to too many failed login attempts.")
	public ResponseEntity<ApiResponse> unlockUser(
			@Parameter(description = "ID of the user to unlock") @PathVariable int id) {

		User userToUnlock = userDAO.getUserById(id);
		if (userToUnlock == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to unlock not found.", null));
		}

		loginAttemptService.clearLoginAttempts(userToUnlock.getUsername());
		adminLogService.log(getSystemUsername(), "UNLOCK_USER_API",
				"User account '" + userToUnlock.getUsername() + "' (ID: " + id + ") unlocked via API.");
		return ResponseEntity.ok(new ApiResponse(true,
				"User account '" + userToUnlock.getUsername() + "' has been unlocked.", Map.of("unlockedUserId", id)));
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\WikiResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.WikiUpdateRequest;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.WikiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/wiki")
@Tag(name = "Admin Wiki", description = "Endpoints for managing the technical documentation wiki.")
public class WikiResource {

	private final WikiService wikiService;
	private final WikiDAO wikiDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public WikiResource(WikiService wikiService, WikiDAO wikiDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.wikiService = wikiService;
		this.wikiDAO = wikiDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get wiki navigation tree", description = "Retrieves the entire wiki page structure as a hierarchical tree.")
	public ResponseEntity<ApiResponse> getWikiTree() {
		Map<String, Object> treeData = wikiService.getWikiTreeAsData();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Struktur erfolgreich abgerufen.", treeData));
	}

	@GetMapping("/list")
	@Operation(summary = "Get a flat list of all wiki pages", description = "Retrieves a simple list of all wiki pages with their ID and path, suitable for populating dropdowns.")
	public ResponseEntity<ApiResponse> getWikiList() {
		List<WikiEntry> entries = wikiDAO.getAllWikiEntries();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Liste erfolgreich abgerufen.", entries));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single wiki page", description = "Retrieves the content of a single wiki page by its ID.")
	public ResponseEntity<ApiResponse> getWikiEntryById(
			@Parameter(description = "ID of the wiki page to retrieve") @PathVariable int id) {
		Optional<WikiEntry> entryOptional = wikiDAO.getWikiEntryById(id);
		return entryOptional.map(entry -> ResponseEntity.ok(new ApiResponse(true, "Inhalt geladen.", entry)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new wiki page", description = "Creates a new documentation page in the wiki.")
	public ResponseEntity<ApiResponse> createWikiEntry(@Valid @RequestBody WikiEntry newEntry) {
		if (newEntry.getFilePath() == null || newEntry.getFilePath().isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Dateipfad darf nicht leer sein.", null));
		}
		if (wikiDAO.findByFilePath(newEntry.getFilePath()).isPresent()) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Ein Eintrag mit diesem Dateipfad existiert bereits.", null));
		}

		newEntry.setContent(richTextPolicy.sanitize(newEntry.getContent()));
		Optional<WikiEntry> createdEntryOptional = wikiDAO.createWikiEntry(newEntry);
		if (createdEntryOptional.isPresent()) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_WIKI_PAGE",
					"Created wiki page: " + createdEntryOptional.get().getFilePath());
			return new ResponseEntity<>(
					new ApiResponse(true, "Seite erfolgreich erstellt.", createdEntryOptional.get()),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Seite konnte nicht in der Datenbank erstellt werden.", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a wiki page", description = "Updates the content of an existing wiki page.")
	public ResponseEntity<ApiResponse> updateWikiEntry(
			@Parameter(description = "ID of the wiki page to update") @PathVariable int id,
			@Valid @RequestBody WikiUpdateRequest updateRequest) {

		String sanitizedContent = richTextPolicy.sanitize(updateRequest.content());
		if (wikiDAO.updateWikiContent(id, sanitizedContent)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_WIKI_PAGE", "Updated wiki page ID: " + id);
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false,
					"Seite konnte nicht aktualisiert werden. Sie existiert möglicherweise nicht.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a wiki page", description = "Permanently deletes a wiki page.")
	public ResponseEntity<ApiResponse> deleteWikiEntry(
			@Parameter(description = "ID of the wiki page to delete") @PathVariable int id) {

		Optional<WikiEntry> entryToDelete = wikiDAO.getWikiEntryById(id);
		if (entryToDelete.isEmpty()) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null));
		}

		if (wikiDAO.deleteWikiEntry(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_WIKI_PAGE",
					"Deleted wiki page: " + entryToDelete.get().getFilePath());
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich gelöscht.", Map.of("deletedId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Löschen der Seite.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\AuthResource.java
========================================================================

package de.technikteam.api.v1.auth;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AuthService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.dao.UserDAO;
import de.technikteam.util.NavigationRegistry;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/auth")
@Tag(name = "Authentication", description = "Endpoints for user authentication.")
public class AuthResource {
	private static final Logger logger = LogManager.getLogger(AuthResource.class);

	private final UserDAO userDAO;
	private final AuthService authService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public AuthResource(UserDAO userDAO, AuthService authService, LoginAttemptService loginAttemptService) {
		this.userDAO = userDAO;
		this.authService = authService;
		this.loginAttemptService = loginAttemptService;
	}

	@PostMapping("/login")
	@Operation(summary = "User Login", description = "Authenticates a user with username and password. On success, it sets an HttpOnly cookie with the JWT and returns user session data.", requestBody = @RequestBody(description = "User credentials for login.", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = LoginRequest.class))))
	public ResponseEntity<ApiResponse> login(
			@org.springframework.web.bind.annotation.RequestBody LoginRequest loginRequest, HttpServletRequest request,
			HttpServletResponse response) {
		String username = loginRequest.username();
		String password = loginRequest.password();
		String ipAddress = getClientIp(request);

		if (loginAttemptService.isLockedOut(username, ipAddress)) {
			logger.warn("Blocked login attempt for locked-out user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Konto ist vorübergehend gesperrt.", null),
					HttpStatus.FORBIDDEN);
		}

		User user = userDAO.validateUser(username, password);
		if (user != null) {
			loginAttemptService.clearLoginAttempts(username);
			authService.addJwtCookie(user, response);
			logger.info("JWT cookie set successfully for user '{}'", username);
			// Return user data but not the token itself
			return ResponseEntity.ok(new ApiResponse(true, "Anmeldung erfolgreich", user));
		} else {
			loginAttemptService.recordFailedLogin(username, ipAddress);
			logger.warn("Failed API login attempt for user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Falscher Benutzername oder Passwort.", null),
					HttpStatus.UNAUTHORIZED);
		}
	}

	@GetMapping("/csrf-token")
	@Operation(summary = "Get CSRF Token", description = "An endpoint that does nothing but allows the client to make a GET request to receive the initial XSRF-TOKEN cookie from the server.")
	public ResponseEntity<ApiResponse> getCsrfToken(HttpServletRequest request) {
		// By accessing the token, we ensure it's generated and added to the response.
		CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
		if (csrfToken != null) {
			logger.info("CSRF token explicitly requested and provided.");
		}
		return ResponseEntity.ok(new ApiResponse(true, "CSRF token provided in cookie.", null));
	}

	@GetMapping("/me")
	@Operation(summary = "Get current user session", description = "Retrieves the user object and navigation items for the currently authenticated user.", security = @SecurityRequirement(name = "bearerAuth"))
	public ResponseEntity<ApiResponse> getCurrentUser(@AuthenticationPrincipal SecurityUser securityUser,
			HttpServletRequest request) {
		// Explicitly load the CSRF token to ensure the XSRF-TOKEN cookie is set on the
		// response
		// for the very first authenticated GET request the client makes.
		CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
		logger.info("CSRF token loaded during /me request: {}", csrfToken != null ? "OK" : "NULL");

		if (securityUser == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Keine aktive Sitzung gefunden.", null),
					HttpStatus.UNAUTHORIZED);
		}

		User authenticatedUser = securityUser.getUser();
		List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(authenticatedUser);
		Map<String, Object> responseData = Map.of("user", authenticatedUser, "navigation", navigationItems);
		return ResponseEntity.ok(new ApiResponse(true, "Current user session retrieved.", responseData));
	}

	@PostMapping("/logout")
	@Operation(summary = "User Logout", description = "Logs out the user by clearing the JWT authentication cookie.")
	public ResponseEntity<ApiResponse> logout(HttpServletResponse response) {
		authService.clearJwtCookie(response);
		return ResponseEntity.ok(new ApiResponse(true, "Abmeldung erfolgreich", null));
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\LoginRequest.java
========================================================================

package de.technikteam.api.v1.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/**
 * A Data Transfer Object (DTO) representing the credentials for a login
 * request. Using a dedicated DTO provides type safety and allows for
 * declarative validation.
 */
public record LoginRequest(
		@NotBlank(message = "Username cannot be blank") @Schema(description = "The user's unique username.", example = "admin", required = true) String username,

		@NotBlank(message = "Password cannot be blank") @Schema(description = "The user's password.", example = "admin123", required = true) String password) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\CategoryRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record CategoryRequest(
		@NotBlank(message = "Kategoriename darf nicht leer sein") @Size(min = 2, max = 100, message = "Kategoriename muss zwischen 2 und 100 Zeichen lang sein") @Schema(description = "The name for the new file category.", required = true) String name) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventDebriefingDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;
import java.util.List;

public record EventDebriefingDTO(@NotNull @Schema(description = "Summary of what went well.") String whatWentWell,
		@NotNull @Schema(description = "Summary of what could be improved.") String whatToImprove,
		@Schema(description = "Notes about specific equipment performance.") String equipmentNotes,
		@Schema(description = "List of user IDs for crew members who performed exceptionally.") List<Integer> standoutCrewMemberIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;

public record EventUpdateRequest(@NotBlank @Schema(description = "Name of the event") String name,
		@NotNull @Schema(description = "Start date and time of the event") LocalDateTime eventDateTime,
		@Schema(description = "End date and time of the event") LocalDateTime endDateTime,
		@Schema(description = "Detailed description of the event") String description,
		@Schema(description = "Location of the event") String location,
		@Schema(description = "Current status of the event (e.g., GEPLANT, LAUFEND)") String status,
		@Schema(description = "ID of the user leading the event") Integer leaderUserId,
		@Schema(description = "Required role for viewing attachments") String requiredRole,
		@Schema(description = "Reminder time in minutes before the event starts") Integer reminderMinutes,
		@Schema(description = "Array of course IDs for skill requirements") List<String> requiredCourseIds,
		@Schema(description = "Array of required person counts for skills") List<String> requiredPersons,
		@Schema(description = "Array of item IDs for reservations") List<String> itemIds,
		@Schema(description = "Array of quantities for reserved items") List<String> quantities) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\GeneralFeedbackRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record GeneralFeedbackRequest(
		@NotBlank(message = "Betreff darf nicht leer sein") @Size(max = 255, message = "Betreff darf nicht länger als 255 Zeichen sein") @Schema(description = "The subject line of the feedback.", required = true) String subject,

		@NotBlank(message = "Inhalt darf nicht leer sein") @Schema(description = "The detailed content of the feedback.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\MeetingRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

public record MeetingRequest(
		@NotNull(message = "Kurs-ID darf nicht null sein") @Schema(description = "The ID of the parent course for this meeting.", required = true) Integer courseId,

		@NotBlank(message = "Meeting-Name darf nicht leer sein") @Schema(description = "The name of the meeting.", required = true, example = "Teil 1: Grundlagen") String name,

		@NotNull(message = "Datum und Uhrzeit des Meetings dürfen nicht null sein") @FutureOrPresent(message = "Das Datum des Meetings muss in der Gegenwart oder Zukunft liegen") @Schema(description = "The start date and time of the meeting.", required = true) LocalDateTime meetingDateTime,

		@Schema(description = "The optional end date and time of the meeting.") LocalDateTime endDateTime,

		@Schema(description = "The ID of the user leading the meeting.") Integer leaderUserId,

		@Schema(description = "A description of the meeting's content.") String description,

		@Schema(description = "The location of the meeting.") String location) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\NotificationRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record NotificationRequest(
		@NotBlank(message = "Titel darf nicht leer sein") @Size(max = 100, message = "Titel darf 100 Zeichen nicht überschreiten") @Schema(description = "The title of the notification.", required = true) String title,

		@NotBlank(message = "Beschreibung darf nicht leer sein") @Schema(description = "The main content of the notification.", required = true) String description,

		@NotBlank(message = "Stufe darf nicht leer sein") @Schema(description = "The severity level of the notification.", required = true, allowableValues = {
				"Informational", "Important", "Warning" }) String level,

		@NotBlank(message = "Zieltyp darf nicht leer sein") @Schema(description = "The target audience type.", required = true, allowableValues = {
				"ALL", "EVENT", "MEETING" }) String targetType,

		@Schema(description = "The ID of the event or meeting if targetType is EVENT or MEETING.") Integer targetId){
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\PasswordChangeRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

public record PasswordChangeRequest(
		@NotBlank(message = "Aktuelles Passwort darf nicht leer sein") @Schema(description = "The user's current password.", required = true) String currentPassword,

		@NotBlank(message = "Neues Passwort darf nicht leer sein") @Schema(description = "The desired new password. Must meet the password policy.", required = true) String newPassword,

		@NotBlank(message = "Bestätigungspasswort darf nicht leer sein") @Schema(description = "Confirmation of the new password.", required = true) String confirmPassword) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\ProfileChangeRequestDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;

public record ProfileChangeRequestDTO(
		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's new email address.") String email,

		@Schema(description = "The user's new class year.") Integer classYear,

		@Schema(description = "The user's new class name.") String className,

		@Schema(description = "The user's new profile icon class (e.g., 'fa-user-ninja').") String profileIconClass) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserCreateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserCreateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotBlank(message = "Passwort darf nicht leer sein") @Schema(description = "The user's initial password. Must meet the password policy.", required = true) String password,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserUpdateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@Schema(description = "Admin-only notes about the user.") String adminNotes,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\WikiUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record WikiUpdateRequest(
		@NotNull(message = "Inhalt darf nicht null sein") @Schema(description = "The full Markdown content of the wiki page.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicAnnouncementResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.Announcement;
import de.technikteam.model.ApiResponse;
import de.technikteam.service.AnnouncementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/announcements")
@Tag(name = "Public Announcements", description = "Endpoints for viewing bulletin board announcements.")
@SecurityRequirement(name = "bearerAuth")
public class PublicAnnouncementResource {

	private final AnnouncementService announcementService;

	@Autowired
	public PublicAnnouncementResource(AnnouncementService announcementService) {
		this.announcementService = announcementService;
	}

	@GetMapping
	@Operation(summary = "Get all announcements")
	public ResponseEntity<ApiResponse> getAllAnnouncements() {
		List<Announcement> announcements = announcementService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Announcements retrieved successfully.", announcements));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarEntriesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/calendar")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarEntriesResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarEntriesResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/entries")
	@Operation(summary = "Get calendar entries", description = "Retrieves a combined list of upcoming events and meetings for display in a calendar.")
	public ResponseEntity<ApiResponse> getCalendarEntries() {
		List<Map<String, Object>> entries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", event.getId());
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("end", event.getEndDateTime());
			entry.put("type", "Event");
			entry.put("url", "/veranstaltungen/details/" + event.getId());
			entries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", meeting.getId());
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("end", meeting.getEndDateTime());
			entry.put("type", "Lehrgang");
			entry.put("url", "/lehrgaenge/details/" + meeting.getId());
			entries.add(entry);
		}

		return ResponseEntity.ok(new ApiResponse(true, "Kalendereinträge erfolgreich abgerufen.", entries));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.*;
import net.fortuna.ical4j.util.RandomUidGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayOutputStream;
import java.net.URI;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

@RestController
@RequestMapping("/api/v1/public")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/calendar.ics")
	@Operation(summary = "Get iCalendar Feed", description = "Provides an iCalendar (.ics) feed of all upcoming events and meetings.", responses = {
			@ApiResponse(responseCode = "200", description = "iCalendar feed generated successfully", content = @Content(mediaType = "text/calendar")),
			@ApiResponse(responseCode = "500", description = "Internal server error while generating the feed") })
	public ResponseEntity<byte[]> getICalendarFeed(HttpServletRequest request) {
		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-//TechnikTeam Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
					+ request.getContextPath();
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());
				if (event.getEventDateTime() != null) {
					vEvent.getProperties().add(new DtStart(
							new DateTime(Date.from(event.getEventDateTime().atZone(systemZone).toInstant()))));
				}
				if (event.getEndDateTime() != null) {
					vEvent.getProperties().add(
							new DtEnd(new DateTime(Date.from(event.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				vEvent.getProperties().add(new Url(new URI(baseUrl + "/veranstaltungen/details/" + event.getId())));
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());
				if (meeting.getMeetingDateTime() != null) {
					vMeeting.getProperties().add(new DtStart(
							new DateTime(Date.from(meeting.getMeetingDateTime().atZone(systemZone).toInstant()))));
				}
				if (meeting.getEndDateTime() != null) {
					vMeeting.getProperties().add(new DtEnd(
							new DateTime(Date.from(meeting.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				vMeeting.getProperties().add(new Url(new URI(baseUrl + "/lehrgaenge/details/" + meeting.getId())));
				calendar.getComponents().add(vMeeting);
			}

			ByteArrayOutputStream boas = new ByteArrayOutputStream();
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, boas);

			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.parseMediaType("text/calendar"));
			headers.setContentDispositionFormData("attachment", "technikteam-calendar.ics");

			return new ResponseEntity<>(boas.toByteArray(), headers, HttpStatus.OK);

		} catch (Exception e) {
			return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChangelogResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChangelogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/public/changelog")
@Tag(name = "Public Changelog", description = "Endpoints for user-facing changelog features.")
public class PublicChangelogResource {

	private final ChangelogDAO changelogDAO;

	@Autowired
	public PublicChangelogResource(ChangelogDAO changelogDAO) {
		this.changelogDAO = changelogDAO;
	}

	@GetMapping
	@Operation(summary = "Get all changelogs")
	public ResponseEntity<ApiResponse> getAllChangelogs() {
		List<Changelog> changelogs = changelogDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Changelogs retrieved.", changelogs));
	}

	@GetMapping("/latest-unseen")
	@Operation(summary = "Get the latest unseen changelog for the current user")
	public ResponseEntity<ApiResponse> getLatestUnseenChangelog(@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.ok(new ApiResponse(true, "User not authenticated.", null));
		}
		Optional<Changelog> changelog = changelogDAO.findLatestUnseen(securityUser.getUser().getId());
		return ResponseEntity.ok(new ApiResponse(true, "Latest unseen changelog retrieved.", changelog.orElse(null)));
	}

	@PostMapping("/{id}/mark-seen")
	@Operation(summary = "Mark a changelog as seen by the current user")
	public ResponseEntity<ApiResponse> markAsSeen(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.status(401).body(new ApiResponse(false, "User not authenticated.", null));
		}
		if (changelogDAO.markAsSeen(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog marked as seen.", null));
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Could not mark as seen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChatResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChatDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/chat")
@Tag(name = "Public Chat", description = "Endpoints for user direct messaging.")
@SecurityRequirement(name = "bearerAuth")
public class PublicChatResource {

	private final ChatDAO chatDAO;
	private final FileService fileService;

	@Autowired
	public PublicChatResource(ChatDAO chatDAO, FileService fileService) {
		this.chatDAO = chatDAO;
		this.fileService = fileService;
	}

	@GetMapping("/conversations")
	@Operation(summary = "Get user's conversations")
	public ResponseEntity<ApiResponse> getConversations(@AuthenticationPrincipal SecurityUser securityUser) {
		return ResponseEntity.ok(new ApiResponse(true, "Gespräche abgerufen.",
				chatDAO.getConversationsForUser(securityUser.getUser().getId())));
	}

	@GetMapping("/conversations/{id}")
	@Operation(summary = "Get a single conversation's details")
	public ResponseEntity<ApiResponse> getConversationById(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			throw new AccessDeniedException("Sie sind kein Mitglied dieses Gesprächs.");
		}
		ChatConversation conversation = chatDAO.getConversationById(id);
		return ResponseEntity.ok(new ApiResponse(true, "Gespräch abgerufen.", conversation));
	}

	@GetMapping("/conversations/{id}/messages")
	@Operation(summary = "Get messages for a conversation")
	public ResponseEntity<ApiResponse> getMessages(@PathVariable int id, @RequestParam(defaultValue = "50") int limit,
			@RequestParam(defaultValue = "0") int offset, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			throw new AccessDeniedException("Sie sind kein Mitglied dieses Gesprächs.");
		}
		return ResponseEntity.ok(
				new ApiResponse(true, "Nachrichten abgerufen.", chatDAO.getMessagesForConversation(id, limit, offset)));
	}

	@PostMapping("/conversations")
	@Operation(summary = "Find or create a conversation with a user")
	public ResponseEntity<ApiResponse> findOrCreateConversation(@RequestBody Map<String, Integer> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Integer otherUserId = payload.get("userId");
		if (otherUserId == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Benutzer-ID fehlt.", null));
		}
		int conversationId = chatDAO.findOrCreateConversation(securityUser.getUser().getId(), otherUserId);
		return ResponseEntity.ok(
				new ApiResponse(true, "Gespräch gefunden oder erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/group")
	@Operation(summary = "Create a new group conversation")
	public ResponseEntity<ApiResponse> createGroupConversation(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String name = (String) payload.get("name");
		@SuppressWarnings("unchecked")
		List<Integer> participantIds = (List<Integer>) payload.get("participantIds");

		if (name == null || name.isBlank() || participantIds == null || participantIds.isEmpty()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Gruppenname und Teilnehmer sind erforderlich.", null));
		}

		int conversationId = chatDAO.createGroupConversation(name, securityUser.getUser().getId(), participantIds);
		return ResponseEntity.status(HttpStatus.CREATED)
				.body(new ApiResponse(true, "Gruppe erfolgreich erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/{id}/participants")
	@Operation(summary = "Add participants to a group")
	public ResponseEntity<ApiResponse> addParticipants(@PathVariable int id,
			@RequestBody Map<String, List<Integer>> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		ChatConversation conversation = chatDAO.getConversationById(id);
		if (conversation == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Gespräch nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		if (!conversation.isGroupChat() || conversation.getCreatorId() != securityUser.getUser().getId()) {
			throw new AccessDeniedException("Nur der Ersteller der Gruppe kann Mitglieder hinzufügen.");
		}
		List<Integer> userIds = payload.get("userIds");
		if (userIds == null || userIds.isEmpty()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Keine Benutzer-IDs angegeben.", null));
		}

		chatDAO.addParticipantsToGroup(id, userIds);
		return ResponseEntity.ok(new ApiResponse(true, "Teilnehmer erfolgreich hinzugefügt.", null));
	}

	@PostMapping("/conversations/{id}/leave")
	@Operation(summary = "Leave a group conversation")
	public ResponseEntity<ApiResponse> leaveGroup(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (chatDAO.leaveGroup(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Gruppe erfolgreich verlassen.", null));
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Verlassen der Gruppe fehlgeschlagen.", null));
	}

	@DeleteMapping("/conversations/{id}")
	@Operation(summary = "Delete a group conversation")
	public ResponseEntity<ApiResponse> deleteGroup(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		ChatConversation conversation = chatDAO.getConversationById(id);
		if (conversation == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Gespräch nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		User currentUser = securityUser.getUser();
		if (!conversation.isGroupChat()
				|| (conversation.getCreatorId() != currentUser.getId() && !currentUser.hasAdminAccess())) {
			throw new AccessDeniedException("Nur der Ersteller der Gruppe oder ein Admin kann diese löschen.");
		}
		if (chatDAO.deleteGroup(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Gruppe erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Löschen der Gruppe fehlgeschlagen.", null));
	}

	@PostMapping("/upload")
	@Operation(summary = "Upload a file for chat")
	public ResponseEntity<ApiResponse> uploadChatFile(@RequestParam("file") MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"chat");
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDashboardResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.ChatDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.Meeting;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/dashboard")
@Tag(name = "Public Dashboard", description = "Endpoints for the user-facing dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class PublicDashboardResource {

	private final EventDAO eventDAO;
	private final EventTaskDAO eventTaskDAO;
	private final ChatDAO chatDAO;
	private final MeetingDAO meetingDAO;
	private final StorageDAO storageDAO;

	@Autowired
	public PublicDashboardResource(EventDAO eventDAO, EventTaskDAO eventTaskDAO, ChatDAO chatDAO, MeetingDAO meetingDAO,
			StorageDAO storageDAO) {
		this.eventDAO = eventDAO;
		this.eventTaskDAO = eventTaskDAO;
		this.chatDAO = chatDAO;
		this.meetingDAO = meetingDAO;
		this.storageDAO = storageDAO;
	}

	@GetMapping
	@Operation(summary = "Get dashboard data", description = "Retrieves all necessary data for the user's main dashboard view.")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getAllActiveAndUpcomingEvents(); // Simplified for now
		List<Event> recommendedEvents = eventDAO.getPersonalizedEventFeed(user.getId(), 3);
		List<ChatConversation> recentConversations = chatDAO.getConversationsForUser(user.getId());
		List<Meeting> signedUpMeetings = meetingDAO.getUpcomingMeetingsForUser(user);
		List<StorageItem> lowStockItems = storageDAO.getLowStockItems(5);

		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("assignedEvents", assignedEvents);
		dashboardData.put("openTasks", openTasks);
		dashboardData.put("upcomingEvents", upcomingEvents);
		dashboardData.put("recommendedEvents", recommendedEvents);
		dashboardData.put("recentConversations", recentConversations.stream().limit(5).toList());
		dashboardData.put("upcomingMeetings", signedUpMeetings.stream()
				.filter(m -> "ANGEMELDET".equals(m.getUserAttendanceStatus())).limit(5).toList());
		dashboardData.put("lowStockItems", lowStockItems);

		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDocumentationResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.PageDocumentation;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.PageDocumentationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/public/documentation")
@Tag(name = "Public Documentation", description = "Endpoints for viewing page documentation.")
public class PublicDocumentationResource {

	private final PageDocumentationService documentationService;

	@Autowired
	public PublicDocumentationResource(PageDocumentationService documentationService) {
		this.documentationService = documentationService;
	}

	@GetMapping
	@Operation(summary = "Get all accessible documentation pages")
	public ResponseEntity<ApiResponse> getAllDocs(@AuthenticationPrincipal SecurityUser securityUser) {
		boolean isAdmin = securityUser != null && securityUser.getUser().hasAdminAccess();
		List<PageDocumentation> docs = documentationService.findAll(isAdmin);
		return ResponseEntity.ok(new ApiResponse(true, "Documentation pages retrieved.", docs));
	}

	@GetMapping("/{pageKey}")
	@Operation(summary = "Get a single documentation page by key")
	public ResponseEntity<ApiResponse> getDocByKey(@PathVariable String pageKey,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Optional<PageDocumentation> docOpt = documentationService.findByKey(pageKey);
		if (docOpt.isPresent()) {
			PageDocumentation doc = docOpt.get();
			boolean isAdmin = securityUser != null && securityUser.getUser().hasAdminAccess();
			if (doc.isAdminOnly() && !isAdmin) {
				return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, "Access denied.", null));
			}
			return ResponseEntity.ok(new ApiResponse(true, "Documentation retrieved.", doc));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventGalleryResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventPhoto;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventGalleryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
public class PublicEventGalleryResource {

	private final EventGalleryService galleryService;

	@Autowired
	public PublicEventGalleryResource(EventGalleryService galleryService) {
		this.galleryService = galleryService;
	}

	@GetMapping("/{eventId}/gallery")
	@Operation(summary = "Get all photos for an event gallery")
	public ResponseEntity<ApiResponse> getGallery(@PathVariable int eventId) {
		List<EventPhoto> photos = galleryService.findPhotosByEventId(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "Gallery photos retrieved.", photos));
	}

	@PostMapping("/{eventId}/gallery")
	@Operation(summary = "Upload a photo to an event gallery")
	public ResponseEntity<ApiResponse> uploadPhoto(@PathVariable int eventId, @RequestParam("file") MultipartFile file,
			@RequestParam("caption") String caption, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			EventPhoto photo = galleryService.addPhotoToGallery(eventId, file, caption, securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Photo uploaded successfully.", photo),
					HttpStatus.CREATED);
		} catch (IOException | IllegalArgumentException | SecurityException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@DeleteMapping("/gallery/{photoId}")
	@Operation(summary = "Delete a photo from a gallery")
	public ResponseEntity<ApiResponse> deletePhoto(@PathVariable int photoId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			galleryService.deletePhoto(photoId, securityUser.getUser());
			return ResponseEntity
					.ok(new ApiResponse(true, "Photo deleted successfully.", Map.of("deletedId", photoId)));
		} catch (SecurityException e) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, e.getMessage(), null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete photo file.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
@SecurityRequirement(name = "bearerAuth")
public class PublicEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;
	private final EventCustomFieldDAO customFieldDAO;
	private final FileService fileService;

	@Autowired
	public PublicEventResource(EventDAO eventDAO, EventService eventService, EventCustomFieldDAO customFieldDAO,
			FileService fileService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
		this.customFieldDAO = customFieldDAO;
		this.fileService = fileService;
	}

	@GetMapping
	@Operation(summary = "Get upcoming events for user", description = "Retrieves a list of upcoming events, indicating the user's current attendance and qualification status for each.")
	public ResponseEntity<ApiResponse> getUpcomingEventsForUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Event> events = eventDAO.getUpcomingEventsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get event details", description = "Retrieves detailed information for a single event.")
	public ResponseEntity<ApiResponse> getEventDetails(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Event event = eventDAO.getEventById(id);
		if (event == null) {
			return ResponseEntity.status(404).body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		// Enrich with user-specific status
		if (securityUser != null) {
			String status = eventDAO.getUserAttendanceStatus(id, securityUser.getUser().getId());
			event.setUserAttendanceStatus(status);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungsdetails erfolgreich abgerufen.", event));
	}

	@PostMapping("/{id}/signup")
	@Operation(summary = "Sign up for an event", description = "Allows the current user to sign up for an event and submit custom field responses.")
	public ResponseEntity<ApiResponse> signUpForEvent(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> customFieldResponses) {
		User user = securityUser.getUser();
		eventDAO.signUpForEvent(user.getId(), id);
		if (customFieldResponses != null) {
			customFieldResponses.forEach((key, value) -> {
				if (key.startsWith("customfield_")) {
					int fieldId = Integer.parseInt(key.substring("customfield_".length()));
					EventCustomFieldResponse response = new EventCustomFieldResponse();
					response.setFieldId(fieldId);
					response.setUserId(user.getId());
					response.setResponseValue(value);
					customFieldDAO.saveResponse(response);
				}
			});
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich für die Veranstaltung angemeldet.", null));
	}

	@PostMapping("/{id}/signoff")
	@Operation(summary = "Sign off from an event", description = "Allows the current user to sign off from an event.")
	public ResponseEntity<ApiResponse> signOffFromEvent(
			@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> payload) {
		User user = securityUser.getUser();
		String reason = payload.get("reason");
		Event event = eventDAO.getEventById(id);
		if ("LAUFEND".equals(event.getStatus())) {
			eventService.signOffUserFromRunningEvent(user.getId(), user.getUsername(), id, reason);
		} else {
			eventDAO.signOffFromEvent(user.getId(), id);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich von der Veranstaltung abgemeldet.", null));
	}

	@GetMapping("/{id}/custom-fields")
	@Operation(summary = "Get custom fields for an event", description = "Retrieves the list of custom fields required for signing up for a specific event.")
	public ResponseEntity<ApiResponse> getEventCustomFields(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(id);
		return ResponseEntity.ok(new ApiResponse(true, "Zusatzfelder erfolgreich abgerufen.", fields));
	}

	@PostMapping("/{eventId}/chat/upload")
	@Operation(summary = "Upload a file to an event chat")
	public ResponseEntity<ApiResponse> uploadEventChatFile(@PathVariable int eventId,
			@RequestParam("file") MultipartFile file, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!eventDAO.isUserAssociatedWithEvent(eventId, securityUser.getUser().getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN)
					.body(new ApiResponse(false, "Nicht berechtigt, Dateien in diesem Chat hochzuladen.", null));
		}
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"eventchat/" + eventId);
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFeedbackResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.api.v1.dto.GeneralFeedbackRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/feedback")
@Tag(name = "Public Feedback", description = "Endpoints for users to submit and view feedback.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;
	private final EventFeedbackDAO eventFeedbackDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicFeedbackResource(FeedbackSubmissionDAO submissionDAO, EventFeedbackDAO eventFeedbackDAO,
			EventDAO eventDAO) {
		this.submissionDAO = submissionDAO;
		this.eventFeedbackDAO = eventFeedbackDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/user")
	@Operation(summary = "Get user's feedback submissions", description = "Retrieves a list of all general feedback submissions made by the current user.")
	public ResponseEntity<ApiResponse> getMyFeedbackSubmissions(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<FeedbackSubmission> submissions = submissionDAO.getSubmissionsByUserId(user.getId());
		return ResponseEntity.ok(new ApiResponse(true, "Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PostMapping("/general")
	@Operation(summary = "Submit general feedback", description = "Allows a user to submit a new general feedback entry.")
	public ResponseEntity<ApiResponse> submitGeneralFeedback(@Valid @RequestBody GeneralFeedbackRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		FeedbackSubmission submission = new FeedbackSubmission();
		submission.setUserId(user.getId());
		submission.setSubject(request.subject());
		submission.setContent(request.content());

		if (submissionDAO.createSubmission(submission)) {
			return new ResponseEntity<>(new ApiResponse(true, "Feedback erfolgreich übermittelt.", submission),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Feedback konnte nicht gespeichert werden.", null));
		}
	}

	@GetMapping("/forms")
	@Operation(summary = "Get feedback form for an event", description = "Retrieves the feedback form for a specific event and checks if the user has already submitted a response.")
	public ResponseEntity<ApiResponse> getEventFeedbackForm(
			@Parameter(description = "ID of the event") @RequestParam int eventId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		FeedbackForm form = eventFeedbackDAO.getFeedbackFormForEvent(eventId);
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Kein Feedback-Formular für diese Veranstaltung.", null));
		}
		boolean alreadySubmitted = eventFeedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId());

		Map<String, Object> responseData = Map.of("event", event, "form", form, "alreadySubmitted", alreadySubmitted);
		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/event")
	@Operation(summary = "Submit event feedback", description = "Submits a user's rating and comments for an event feedback form.")
	public ResponseEntity<ApiResponse> submitEventFeedback(@RequestBody FeedbackResponse response,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		response.setUserId(user.getId());

		// --- REMEDIATION START ---
		FeedbackForm form = eventFeedbackDAO.getFormById(response.getFormId());
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Feedback-Formular nicht gefunden.", null));
		}
		// Check if user was actually assigned to the event for which they are giving
		// feedback
		if (!eventDAO.isUserAssociatedWithEvent(form.getEventId(), user.getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false,
					"Sie können nur Feedback für Veranstaltungen abgeben, an denen Sie teilgenommen haben.", null));
		}
		// --- REMEDIATION END ---

		if (eventFeedbackDAO.saveFeedbackResponse(response)) {
			return ResponseEntity.ok(new ApiResponse(true, "Event-Feedback erfolgreich übermittelt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Event-Feedback konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFilesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.File;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFilesResource {

	private final FileDAO fileDAO;

	@Autowired
	public PublicFilesResource(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@GetMapping
	@Operation(summary = "Get all accessible files grouped by category", description = "Retrieves files visible to the current user, grouped by their category.")
	public ResponseEntity<ApiResponse> getFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, List<File>> files = fileDAO.getAllFilesGroupedByCategory(user);
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", files));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFileStreamResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.*;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
public class PublicFileStreamResource {
	private static final Logger logger = LogManager.getLogger(PublicFileStreamResource.class);

	private final FileDAO fileDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final Path fileStorageLocation;

	@Autowired
	public PublicFileStreamResource(FileDAO fileDAO, AttachmentDAO attachmentDAO, EventDAO eventDAO,
			MeetingDAO meetingDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.attachmentDAO = attachmentDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	@GetMapping("/download/{id}")
	@Operation(summary = "Download a file", description = "Downloads a file (general or attachment) by its database ID after checking permissions.")
	@ApiResponse(responseCode = "200", description = "File content", content = @Content(mediaType = "application/octet-stream"))
	public ResponseEntity<Resource> downloadFile(
			@Parameter(description = "ID of the file or attachment record") @PathVariable int id) {
		String filePathFromDb = null;
		String filenameForDownload = null;

		Attachment attachment = attachmentDAO.getAttachmentById(id);
		if (attachment != null) {
			filePathFromDb = attachment.getFilepath();
			filenameForDownload = attachment.getFilename();
		} else {
			de.technikteam.model.File dbFile = fileDAO.getFileById(id);
			if (dbFile != null) {
				filePathFromDb = dbFile.getFilepath();
				filenameForDownload = dbFile.getFilename();
			}
		}

		if (filePathFromDb == null)
			return ResponseEntity.notFound().build();

		return serveFile(filePathFromDb, filenameForDownload, false);
	}

	@GetMapping("/images/{filename:.+}")
	@Operation(summary = "Get an inventory image", description = "Retrieves an inventory image for display. The filename usually corresponds to a storage item's image path.")
	@ApiResponse(responseCode = "200", description = "Image content", content = @Content(mediaType = "image/*"))
	public ResponseEntity<Resource> getImage(
			@Parameter(description = "The filename of the image") @PathVariable String filename) {
		return serveFile("images/" + filename, filename, true);
	}

	private ResponseEntity<Resource> serveFile(String relativePath, String originalFilename, boolean inline) {
		try {
			Path filePath = this.fileStorageLocation.resolve(relativePath).normalize();
			if (!filePath.startsWith(this.fileStorageLocation)) {
				logger.warn("Path Traversal Attack attempt detected for path '{}'", filePath);
				return ResponseEntity.status(403).build();
			}

			Resource resource = new UrlResource(filePath.toUri());
			if (resource.exists() || resource.isReadable()) {
				String contentType = "application/octet-stream"; // fallback
				try {
					contentType = Files.probeContentType(filePath);
				} catch (IOException e) {
					logger.warn("Could not determine content type for file {}", filePath);
				}

				String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+",
						"%20");
				String disposition = inline ? "inline" : "attachment";

				return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))
						.header(HttpHeaders.CONTENT_DISPOSITION, disposition + "; filename*=UTF-8''" + encodedFilename)
						.body(resource);
			} else {
				logger.error("File not found or not readable at path: {}", filePath);
				return ResponseEntity.notFound().build();
			}
		} catch (MalformedURLException ex) {
			logger.error("Malformed URL for file path: {}", relativePath, ex);
			return ResponseEntity.notFound().build();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicMeetingResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/meetings")
@Tag(name = "Public Meetings", description = "Endpoints for user interactions with training meetings.")
@SecurityRequirement(name = "bearerAuth")
public class PublicMeetingResource {

	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO attendanceDAO;

	@Autowired
	public PublicMeetingResource(MeetingDAO meetingDAO, MeetingAttendanceDAO attendanceDAO) {
		this.meetingDAO = meetingDAO;
		this.attendanceDAO = attendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get upcoming meetings for user", description = "Retrieves a list of upcoming meetings, indicating the user's current attendance status for each.")
	public ResponseEntity<ApiResponse> getUpcomingMeetings(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@PostMapping("/{id}/{action}")
	@Operation(summary = "Sign up or off from a meeting", description = "Allows the current user to sign up for or sign off from a specific meeting.")
	public ResponseEntity<ApiResponse> handleMeetingAction(
			@Parameter(description = "ID of the meeting") @PathVariable int id,
			@Parameter(description = "Action to perform. Must be 'signup' or 'signoff'.") @PathVariable String action,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		boolean success;
		if ("signup".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, true, "");
		} else if ("signoff".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, false, "");
		} else {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Unbekannte Aktion.", null));
		}

		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich ausgeführt.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Aktion konnte nicht verarbeitet werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicProfileResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.PasswordChangeRequest;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.*;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/profile")
@Tag(name = "Public Profile", description = "Endpoints for managing the current user's profile.")
@SecurityRequirement(name = "bearerAuth")
public class PublicProfileResource {

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final AchievementDAO achievementDAO;
	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService profileRequestService;

	@Autowired
	public PublicProfileResource(UserDAO userDAO, EventDAO eventDAO, UserQualificationsDAO qualificationsDAO,
			AchievementDAO achievementDAO, ProfileChangeRequestDAO requestDAO,
			ProfileRequestService profileRequestService) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.achievementDAO = achievementDAO;
		this.requestDAO = requestDAO;
		this.profileRequestService = profileRequestService;
	}

	@GetMapping
	@Operation(summary = "Get current user's profile data", description = "Retrieves a comprehensive set of data for the authenticated user's profile page.")
	public ResponseEntity<ApiResponse> getMyProfile(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user);
		profileData.put("eventHistory", eventDAO.getEventHistoryForUser(user.getId()));
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(user.getId()));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(user.getId()));
		profileData.put("passkeys", Collections.emptyList()); // Passkeys removed
		profileData.put("hasPendingRequest", requestDAO.hasPendingRequest(user.getId()));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@GetMapping("/{userId}")
	@Operation(summary = "Get another user's public profile data", description = "Retrieves a public-safe subset of another user's profile data.")
	public ResponseEntity<ApiResponse> getUserProfile(@PathVariable int userId) {
		User user = userDAO.getUserById(userId);
		if (user == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Benutzer nicht gefunden.", null));
		}

		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user); // The DTO is already safe, no password hash
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(userId));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(userId));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@PostMapping("/request-change")
	@Operation(summary = "Request a profile data change", description = "Submits a request for an administrator to approve changes to the user's profile data.")
	public ResponseEntity<ApiResponse> requestProfileChange(@Valid @RequestBody ProfileChangeRequestDTO requestDTO,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			profileRequestService.createChangeRequest(securityUser.getUser(), requestDTO);
			return ResponseEntity.ok(new ApiResponse(true, "Änderungsantrag erfolgreich eingereicht.", null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Ihr Antrag konnte nicht gespeichert werden: " + e.getMessage(), null));
		}
	}

	@PutMapping("/theme")
	@Operation(summary = "Update user theme", description = "Updates the user's preferred theme (light/dark).")
	public ResponseEntity<ApiResponse> updateUserTheme(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String theme = payload.get("theme");
		if (theme != null && (theme.equals("light") || theme.equals("dark"))) {
			if (userDAO.updateUserTheme(user.getId(), theme)) {
				User updatedUser = userDAO.getUserById(user.getId());
				return ResponseEntity.ok(new ApiResponse(true, "Theme aktualisiert.", updatedUser));
			}
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Ungültiges Theme angegeben.", null));
	}

	@PutMapping("/chat-color")
	@Operation(summary = "Update chat color", description = "Updates the user's preferred color for chat messages.")
	public ResponseEntity<ApiResponse> updateChatColor(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String chatColor = payload.get("chatColor");
		if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
			return ResponseEntity.ok(new ApiResponse(true, "Chatfarbe aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Chatfarbe konnte nicht gespeichert werden.", null));
		}
	}

	@PutMapping("/password")
	@Operation(summary = "Change password", description = "Allows the authenticated user to change their own password after verifying their current one.")
	public ResponseEntity<ApiResponse> updatePassword(@Valid @RequestBody PasswordChangeRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		if (userDAO.validateUser(user.getUsername(), request.currentPassword()) == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Das aktuelle Passwort ist nicht korrekt.", null));
		}
		if (!request.newPassword().equals(request.confirmPassword())) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Die neuen Passwörter stimmen nicht überein.", null));
		}
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(request.newPassword());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, validationResult.getMessage(), null));
		}
		if (userDAO.changePassword(user.getId(), request.newPassword())) {
			return ResponseEntity.ok(new ApiResponse(true, "Ihr Passwort wurde erfolgreich geändert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Passwort konnte nicht geändert werden.", null));
		}
	}

	@PutMapping("/layout")
	@Operation(summary = "Update layout preferences", description = "Saves the user's custom layout and navigation preferences.")
	public ResponseEntity<ApiResponse> updateDashboardLayout(@RequestBody Object layout,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String layoutJson = new Gson().toJson(layout);
		if (userDAO.updateDashboardLayout(user.getId(), layoutJson)) {
			User updatedUser = userDAO.getUserById(user.getId());
			return ResponseEntity.ok(new ApiResponse(true, "Layout-Einstellungen gespeichert.", updatedUser));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Layout konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicSearchResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.SearchService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/public/search")
@Tag(name = "Public Search", description = "Endpoints for site-wide content search.")
@SecurityRequirement(name = "bearerAuth")
public class PublicSearchResource {

	private final SearchService searchService;

	@Autowired
	public PublicSearchResource(SearchService searchService) {
		this.searchService = searchService;
	}

	@GetMapping
	@Operation(summary = "Perform a site-wide search", description = "Searches across events, inventory, and documentation for a given query.")
	public ResponseEntity<ApiResponse> search(@Parameter(description = "The search term.") @RequestParam String query,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (query == null || query.trim().length() < 3) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Der Suchbegriff muss mindestens 3 Zeichen lang sein.", null));
		}

		User user = securityUser.getUser();
		return ResponseEntity.ok(new ApiResponse(true, "Suchergebnisse erfolgreich abgerufen.",
				searchService.performSearch(query, user)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageDetailsResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.StorageLogEntry;
import de.technikteam.service.StorageItemRelationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageDetailsResource {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;
	private final StorageItemRelationService relationService;

	@Autowired
	public PublicStorageDetailsResource(StorageDAO storageDAO, StorageLogDAO storageLogDAO,
			MaintenanceLogDAO maintenanceLogDAO, StorageItemRelationService relationService) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
		this.relationService = relationService;
	}

	@GetMapping("/{itemId}")
	@Operation(summary = "Get a single storage item by ID", description = "Retrieves detailed information for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemById(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Artikel nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Artikeldetails erfolgreich abgerufen.", item));
	}

	@GetMapping("/{itemId}/history")
	@Operation(summary = "Get history for a storage item", description = "Retrieves the transaction and maintenance history for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemHistory(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		List<StorageLogEntry> transactions = storageLogDAO.getHistoryForItem(itemId);
		List<MaintenanceLogEntry> maintenance = maintenanceLogDAO.getHistoryForItem(itemId);

		Map<String, Object> historyData = new HashMap<>();
		historyData.put("transactions", transactions);
		historyData.put("maintenance", maintenance);

		return ResponseEntity.ok(new ApiResponse(true, "Verlauf erfolgreich abgerufen.", historyData));
	}

	@GetMapping("/{itemId}/reservations")
	@Operation(summary = "Get future reservations for a storage item", description = "Retrieves a list of events for which the item is reserved in the future.")
	public ResponseEntity<ApiResponse> getStorageItemReservations(@PathVariable int itemId) {
		List<Map<String, Object>> reservations = storageDAO.getFutureReservationsForItem(itemId);
		return ResponseEntity.ok(new ApiResponse(true, "Reservierungen erfolgreich abgerufen.", reservations));
	}

	@GetMapping("/{itemId}/relations")
	@Operation(summary = "Get related items for a storage item")
	public ResponseEntity<ApiResponse> getRelatedItems(@PathVariable int itemId) {
		return ResponseEntity
				.ok(new ApiResponse(true, "Related items retrieved.", relationService.findRelatedItems(itemId)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageResource {

	private final StorageService storageService;
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicStorageResource(StorageService storageService, StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageService = storageService;
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping
	@Operation(summary = "Get all storage data for display", description = "Retrieves all storage items grouped by location and a list of active events for the transaction modal.")
	public ResponseEntity<ApiResponse> getStoragePageData() {
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("storageData", storageData);
		responseData.put("activeEvents", activeEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Lagerdaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/transactions")
	@Operation(summary = "Perform a storage transaction", description = "Checks out or checks in a specified quantity of a storage item.")
	public ResponseEntity<ApiResponse> performTransaction(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		try {
			int itemId = ((Number) payload.get("itemId")).intValue();
			int quantity = ((Number) payload.get("quantity")).intValue();
			String type = (String) payload.get("type");
			String notes = (String) payload.get("notes");
			Integer eventId = payload.get("eventId") != null && !payload.get("eventId").toString().isEmpty()
					? ((Number) payload.get("eventId")).intValue()
					: null;

			if (storageService.processTransaction(itemId, quantity, type, user, eventId, notes)) {
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				return ResponseEntity
						.ok(new ApiResponse(true, "Erfolgreich " + quantity + " Stück " + action + ".", null));
			} else {
				return ResponseEntity.badRequest().body(new ApiResponse(false, "Transaktion fehlgeschlagen.", null));
			}
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{itemId}/report-damage")
	@Operation(summary = "Report damage for an item", description = "Allows a user to submit a damage report for a specific inventory item.")
	public ResponseEntity<ApiResponse> reportDamage(@PathVariable int itemId, @RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String description = payload.get("description");
		if (description == null || description.isBlank()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Eine Beschreibung ist erforderlich.", null));
		}

		try {
			storageService.createDamageReport(itemId, securityUser.getUser().getId(), description);
			return ResponseEntity.ok(
					new ApiResponse(true, "Schadensmeldung erfolgreich übermittelt. Ein Admin wird sie prüfen.", null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Meldung konnte nicht gespeichert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicTrainingRequestResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.TrainingRequest;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.TrainingRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/training-requests")
@Tag(name = "Public Training Requests", description = "Endpoints for user-initiated training requests.")
public class PublicTrainingRequestResource {

	private final TrainingRequestService trainingRequestService;

	@Autowired
	public PublicTrainingRequestResource(TrainingRequestService trainingRequestService) {
		this.trainingRequestService = trainingRequestService;
	}

	@PostMapping
	@Operation(summary = "Submit a new training request")
	public ResponseEntity<ApiResponse> submitRequest(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String topic = payload.get("topic");
		if (topic == null || topic.isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Topic cannot be empty.", null));
		}
		TrainingRequest request = trainingRequestService.create(topic, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Training request submitted successfully.", request),
				HttpStatus.CREATED);
	}

	@PostMapping("/{id}/interest")
	@Operation(summary = "Register interest in a training request")
	public ResponseEntity<ApiResponse> registerInterest(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (trainingRequestService.registerInterest(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Interest registered successfully.", null));
		}
		return ResponseEntity.notFound().build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}

		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\GlobalExceptionHandler.java
========================================================================

package de.technikteam.config;

import de.technikteam.model.ApiResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

	private static final Logger logger = LogManager.getLogger(GlobalExceptionHandler.class);

	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
		String errors = ex.getBindingResult().getFieldErrors().stream()
				.map(error -> error.getField() + ": " + error.getDefaultMessage()).collect(Collectors.joining(", "));
		ApiResponse apiResponse = new ApiResponse(false, "Validierung fehlgeschlagen: " + errors, null);
		return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
	}

	@ExceptionHandler(AccessDeniedException.class)
	public ResponseEntity<ApiResponse> handleAccessDeniedException(AccessDeniedException ex) {
		ApiResponse apiResponse = new ApiResponse(false,
				ex.getMessage() != null ? ex.getMessage() : "Zugriff verweigert.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
	}

	@ExceptionHandler(Exception.class)
	public ResponseEntity<ApiResponse> handleAllExceptions(Exception ex) {
		logger.error("An unexpected internal server error occurred", ex);
		ApiResponse apiResponse = new ApiResponse(false,
				"Ein unerwarteter interner Serverfehler ist aufgetreten. Bitte kontaktieren Sie den Support.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.INTERNAL_SERVER_ERROR);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\InitialAdminCreator.java
========================================================================

package de.technikteam.config;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

@Component
public class InitialAdminCreator implements CommandLineRunner {

	private static final Logger logger = LogManager.getLogger(InitialAdminCreator.class);

	private final UserDAO userDAO;
	private final UserService userService;
	private final PermissionDAO permissionDAO;

	@Autowired
	public InitialAdminCreator(UserDAO userDAO, UserService userService, PermissionDAO permissionDAO) {
		this.userDAO = userDAO;
		this.userService = userService;
		this.permissionDAO = permissionDAO;
	}

	@Override
	public void run(String... args) throws Exception {
		if (userDAO.getUserByUsername("admin") == null) {
			logger.warn("############################################################");
			logger.warn("##              FIRST TIME SETUP DETECTED                 ##");
			logger.warn("##     Creating default 'admin' user with a random pass   ##");
			logger.warn("############################################################");

			User adminUser = new User();
			adminUser.setUsername("admin");
			adminUser.setRoleId(1); // Assuming 1 is the ADMIN role ID

			String randomPassword = generateRandomPassword(16);

			// Grant both master admin and notification permissions by default
			List<String> permissionIds = new ArrayList<>();
			Integer adminPermissionId = permissionDAO.getPermissionIdByKey(Permissions.ACCESS_ADMIN_PANEL);
			if (adminPermissionId != null) {
				permissionIds.add(String.valueOf(adminPermissionId));
			} else {
				logger.error(
						"FATAL: Could not find the essential ACCESS_ADMIN_PANEL permission. Admin user will lack full rights.");
			}

			Integer notificationPermissionId = permissionDAO.getPermissionIdByKey(Permissions.NOTIFICATION_SEND);
			if (notificationPermissionId != null) {
				permissionIds.add(String.valueOf(notificationPermissionId));
			} else {
				logger.error(
						"FATAL: Could not find the NOTIFICATION_SEND permission. Admin user will not be able to send notifications.");
			}

			userService.createUserWithPermissions(adminUser, randomPassword, permissionIds.toArray(new String[0]),
					"SYSTEM");

			logger.warn("############################################################");
			logger.warn("##                ADMIN USER CREATED                      ##");
			logger.warn("##                                                        ##");
			logger.warn("##    Username: admin                                     ##");
			logger.warn("##    Password: " + randomPassword + "                     ##");
			logger.warn("##                                                        ##");
			logger.warn("##   !!! PLEASE COPY THIS PASSWORD AND STORE IT SAFELY.   ##");
			logger.warn("##             IT WILL NOT BE SHOWN AGAIN.                ##");
			logger.warn("############################################################");
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON) and
 * deserialization (JSON to Java), preventing reflection issues with the Java
 * Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

	private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

	@Override
	public void write(JsonWriter out, LocalDateTime value) throws IOException {
		if (value == null) {
			out.nullValue();
		} else {
			out.value(value.format(FORMATTER));
		}
	}

	@Override
	public LocalDateTime read(JsonReader in) throws IOException {
		if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
			in.nextNull();
			return null;
		}
		String value = in.nextString();
		return LocalDateTime.parse(value, FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\OpenApiConfig.java
========================================================================

package de.technikteam.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

	@Bean
	public OpenAPI customOpenAPI() {
		final String securitySchemeName = "bearerAuth";
		return new OpenAPI()
				.info(new Info().title("TechnikTeam API").version("v1.0.0").description(
						"This is the complete REST API for the TechnikTeam Event & Crew Management System."))
				.addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
				.components(new Components().addSecuritySchemes(securitySchemeName, new SecurityScheme()
						.name(securitySchemeName).type(SecurityScheme.Type.HTTP).scheme("bearer").bearerFormat("JWT")));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\Permissions.java
========================================================================

package de.technikteam.config;

/**
 * A central repository for all permission key constants used throughout the
 * application. This prevents the use of "magic strings" for permission checks,
 * reducing typos and making the code more maintainable and readable.
 */
public final class Permissions {

	private Permissions() {
	}

	// --- GLOBAL ---
	public static final String ACCESS_ADMIN_PANEL = "ACCESS_ADMIN_PANEL";

	// --- USER MANAGEMENT ---
	public static final String USER_CREATE = "USER_CREATE";
	public static final String USER_READ = "USER_READ";
	public static final String USER_UPDATE = "USER_UPDATE";
	public static final String USER_DELETE = "USER_DELETE";
	public static final String USER_PASSWORD_RESET = "USER_PASSWORD_RESET";

	// --- EVENT MANAGEMENT ---
	public static final String EVENT_CREATE = "EVENT_CREATE";
	public static final String EVENT_READ = "EVENT_READ";
	public static final String EVENT_UPDATE = "EVENT_UPDATE";
	public static final String EVENT_DELETE = "EVENT_DELETE";
	public static final String EVENT_MANAGE_ASSIGNMENTS = "EVENT_MANAGE_ASSIGNMENTS";
	public static final String EVENT_MANAGE_TASKS = "EVENT_MANAGE_TASKS";
	public static final String EVENT_DEBRIEFING_VIEW = "EVENT_DEBRIEFING_VIEW";
	public static final String EVENT_DEBRIEFING_MANAGE = "EVENT_DEBRIEFING_MANAGE";

	// --- COURSE & MEETING MANAGEMENT ---
	public static final String COURSE_CREATE = "COURSE_CREATE";
	public static final String COURSE_READ = "COURSE_READ";
	public static final String COURSE_UPDATE = "COURSE_UPDATE";
	public static final String COURSE_DELETE = "COURSE_DELETE";

	// --- STORAGE & INVENTORY ---
	public static final String STORAGE_CREATE = "STORAGE_CREATE";
	public static final String STORAGE_READ = "STORAGE_READ";
	public static final String STORAGE_UPDATE = "STORAGE_UPDATE";
	public static final String STORAGE_DELETE = "STORAGE_DELETE";
	public static final String DAMAGE_REPORT_MANAGE = "DAMAGE_REPORT_MANAGE";

	// --- KIT MANAGEMENT ---
	public static final String KIT_CREATE = "KIT_CREATE";
	public static final String KIT_READ = "KIT_READ";
	public static final String KIT_UPDATE = "KIT_UPDATE";
	public static final String KIT_DELETE = "KIT_DELETE";

	// --- QUALIFICATIONS ---
	public static final String QUALIFICATION_READ = "QUALIFICATION_READ";
	public static final String QUALIFICATION_UPDATE = "QUALIFICATION_UPDATE";

	// --- FILE MANAGEMENT ---
	public static final String FILE_CREATE = "FILE_CREATE";
	public static final String FILE_READ = "FILE_READ";
	public static final String FILE_UPDATE = "FILE_UPDATE";
	public static final String FILE_DELETE = "FILE_DELETE";
	public static final String FILE_MANAGE = "FILE_MANAGE";

	// --- SYSTEM & REPORTING ---
	public static final String LOG_READ = "LOG_READ";
	public static final String REPORT_READ = "REPORT_READ";
	public static final String SYSTEM_READ = "SYSTEM_READ";

	// --- ACHIEVEMENTS ---
	public static final String ACHIEVEMENT_CREATE = "ACHIEVEMENT_CREATE";
	public static final String ACHIEVEMENT_UPDATE = "ACHIEVEMENT_UPDATE";
	public static final String ACHIEVEMENT_DELETE = "ACHIEVEMENT_DELETE";
	public static final String ACHIEVEMENT_VIEW = "ACHIEVEMENT_VIEW";

	// --- NOTIFICATIONS ---
	public static final String NOTIFICATION_SEND = "NOTIFICATION_SEND";

	// --- DOCUMENTATION ---
	public static final String DOCUMENTATION_MANAGE = "DOCUMENTATION_MANAGE";

	// --- NAVIGATION-SPECIFIC ---
	public static final String ADMIN_DASHBOARD_ACCESS = "ADMIN_DASHBOARD_ACCESS";
}
========================================================================
FILE: src\main\java\de\technikteam\config\SanitizerConfig.java
========================================================================

package de.technikteam.config;

import org.owasp.html.HtmlPolicyBuilder;
import org.owasp.html.PolicyFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SanitizerConfig {

	/**
	 * A policy factory that allows common text formatting and block-level elements.
	 * Suitable for rich text content like event descriptions. Allows: <b>, <i>,
	 * <u>, <s>, <sub>, <sup>,
	 * <p>
	 * , <blockquote>,
	 * <ul>
	 * ,
	 * <ol>
	 * ,
	 * <li>, <br>
	 * ,
	 * <h1>-
	 * <h6>
	 */
	@Bean("richTextPolicy")
	public PolicyFactory richTextPolicy() {
		return new HtmlPolicyBuilder().allowCommonBlockElements() // p, div, h1-h6, etc.
				.allowCommonInlineFormattingElements() // b, i, u, etc.
				.allowElements("br", "ul", "ol", "li", "blockquote", "s", "sub", "sup").toFactory();
	}

	/**
	 * A stricter policy that only allows inline formatting, no block elements.
	 * Suitable for single-line content or chat messages where block elements are
	 * undesirable. Allows: <b>, <i>, <u>, <s>, <sub>, <sup>
	 */
	@Bean("inlineFormattingPolicy")
	public PolicyFactory inlineFormattingPolicy() {
		return new HtmlPolicyBuilder().allowCommonInlineFormattingElements().allowElements("s", "sub", "sup")
				.toFactory();
	}

	/**
	 * A policy that strips all HTML, leaving only plain text. Useful for fields
	 * that should not contain any formatting.
	 */
	@Bean("plainTextPolicy")
	public PolicyFactory plainTextPolicy() {
		return new HtmlPolicyBuilder().toFactory(); // No elements allowed
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\WebMvcConfig.java
========================================================================

package de.technikteam.config;

import de.technikteam.security.RateLimitingInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
	private final RateLimitingInterceptor rateLimitingInterceptor;

	@Autowired
	public WebMvcConfig(RateLimitingInterceptor rateLimitingInterceptor) {
		this.rateLimitingInterceptor = rateLimitingInterceptor;
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		// Rate limiting is disabled as per the request to remove all verification.
		// registry.addInterceptor(rateLimitingInterceptor).addPathPatterns("/api/v1/auth/login")
		// .addPathPatterns("/api/v1/users/**").addPathPatterns("/api/v1/events/**")
		// .addPathPatterns("/api/v1/storage/**").addPathPatterns("/api/v1/kits/**")
		// .addPathPatterns("/api/v1/courses/**").addPathPatterns("/api/v1/meetings/**")
		// .addPathPatterns("/api/v1/feedback/**").addPathPatterns("/api/v1/public/feedback/**")
		// .addPathPatterns("/api/v1/public/profile/**");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Achievement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AchievementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Achievement> achievementRowMapper = (rs, rowNum) -> {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	};

	public List<Achievement> getAllAchievements() {
		String sql = "SELECT * FROM achievements ORDER BY name";
		try {
			return jdbcTemplate.query(sql, achievementRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all achievements", e);
			return List.of();
		}
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, achievementRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching achievement by ID {}", id, e);
			return null;
		}
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, achievement.getAchievementKey(), achievement.getName(),
					achievement.getDescription(), achievement.getIconClass()) > 0;
		} catch (Exception e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, achievement.getName(), achievement.getDescription(),
					achievement.getIconClass(), achievement.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try {
			// First, delete dependencies in user_achievements
			jdbcTemplate.update("DELETE FROM user_achievements WHERE achievement_id = ?", id);
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		String sql = "SELECT a.*, ua.earned_at FROM achievements a JOIN user_achievements ua ON a.id = ua.achievement_id WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Achievement ach = achievementRowMapper.mapRow(rs, rowNum);
				ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
				return ach;
			}, userId);
		} catch (Exception e) {
			logger.error("Error fetching achievements for user {}", userId, e);
			return List.of();
		}
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			return false; // Already has it, not an error
		}
		String sql = "INSERT INTO user_achievements (user_id, achievement_id) SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try {
			return jdbcTemplate.update(sql, userId, achievementKey) > 0;
		} catch (Exception e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
			return false;
		}
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT COUNT(*) FROM user_achievements ua JOIN achievements a ON ua.achievement_id = a.id WHERE ua.user_id = ? AND a.achievement_key = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId, achievementKey);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AdminLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		try {
			jdbcTemplate.update(sql, log.getAdminUsername(), log.getActionType(), log.getDetails());
		} catch (Exception e) {
			logger.error("Failed to create admin log for user '{}'.", log.getAdminUsername(), e);
		}
	}

	public List<AdminLog> getAllLogs() {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			});
		} catch (Exception e) {
			logger.error("Failed to fetch admin logs from the database.", e);
			return List.of();
		}
	}

	public List<AdminLog> getRecentLogs(int limit) {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			}, limit);
		} catch (Exception e) {
			logger.error("Failed to fetch recent admin logs from the database.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AnnouncementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Announcement;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class AnnouncementDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AnnouncementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Announcement> rowMapper = (rs, rowNum) -> {
		Announcement announcement = new Announcement();
		announcement.setId(rs.getInt("id"));
		announcement.setTitle(rs.getString("title"));
		announcement.setContent(rs.getString("content"));
		announcement.setAuthorUserId(rs.getInt("author_user_id"));
		announcement.setAuthorUsername(rs.getString("author_username"));
		announcement.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return announcement;
	};

	public List<Announcement> findAll() {
		String sql = "SELECT a.*, u.username as author_username FROM announcements a JOIN users u ON a.author_user_id = u.id ORDER BY a.created_at DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<Announcement> findById(int id) {
		String sql = "SELECT a.*, u.username as author_username FROM announcements a JOIN users u ON a.author_user_id = u.id WHERE a.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public Announcement create(Announcement announcement) {
		String sql = "INSERT INTO announcements (title, content, author_user_id) VALUES (?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, announcement.getTitle());
			ps.setString(2, announcement.getContent());
			ps.setInt(3, announcement.getAuthorUserId());
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		announcement.setId(newId);
		return announcement;
	}

	public Announcement update(Announcement announcement) {
		String sql = "UPDATE announcements SET title = ?, content = ? WHERE id = ?";
		jdbcTemplate.update(sql, announcement.getTitle(), announcement.getContent(), announcement.getId());
		return announcement;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM announcements WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AttachmentDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Attachment> attachmentRowMapper = (rs, rowNum) -> {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	};

	public boolean addAttachment(Attachment attachment) {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, attachment.getParentType(), attachment.getParentId(),
					attachment.getFilename(), attachment.getFilepath(), attachment.getRequiredRole()) > 0;
		} catch (Exception e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try {
			return jdbcTemplate.query(sql, attachmentRowMapper, parentType, parentId);
		} catch (Exception e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
			return List.of();
		}
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, attachmentRowMapper, attachmentId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
			return null;
		}
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, attachmentId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChangelogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.model.Changelog;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.lang.reflect.Type;
import java.sql.Date;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Repository
public class ChangelogDAO {

	private final JdbcTemplate jdbcTemplate;
	private final Gson gson = new Gson();
	private final Type listType = new TypeToken<List<Integer>>() {
	}.getType();

	@Autowired
	public ChangelogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Changelog> rowMapper = (rs, rowNum) -> {
		Changelog cl = new Changelog();
		cl.setId(rs.getInt("id"));
		cl.setVersion(rs.getString("version"));
		cl.setReleaseDate(rs.getDate("release_date").toLocalDate());
		cl.setTitle(rs.getString("title"));
		cl.setNotes(rs.getString("notes"));
		String seenByJson = rs.getString("seen_by_users");
		cl.setSeenByUserIds(gson.fromJson(seenByJson, listType));
		return cl;
	};

	public Optional<Changelog> findById(int id) {
		String sql = "SELECT * FROM changelogs WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public List<Changelog> findAll() {
		String sql = "SELECT * FROM changelogs ORDER BY release_date DESC, version DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<Changelog> findLatestUnseen(int userId) {
		// FIX: Correctly use JSON_CONTAINS by passing the value to check as a string.
		String sql = "SELECT * FROM changelogs WHERE NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$') ORDER BY release_date DESC, version DESC LIMIT 1";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, String.valueOf(userId)));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public boolean markAsSeen(int changelogId, int userId) {
		// FIX: Correctly use JSON_CONTAINS by passing the value to check as a string.
		String sql = "UPDATE changelogs SET seen_by_users = JSON_ARRAY_APPEND(seen_by_users, '$', ?) WHERE id = ? AND NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$')";
		return jdbcTemplate.update(sql, userId, changelogId, String.valueOf(userId)) > 0;
	}

	public boolean create(Changelog changelog) {
		String sql = "INSERT INTO changelogs (version, release_date, title, notes) VALUES (?, ?, ?, ?)";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes()) > 0;
	}

	public boolean update(Changelog changelog) {
		String sql = "UPDATE changelogs SET version = ?, release_date = ?, title = ?, notes = ? WHERE id = ?";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes(), changelog.getId()) > 0;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM changelogs WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChatMessage;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class ChatDAO {

	private final JdbcTemplate jdbcTemplate;
	private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

	@Autowired
	public ChatDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
	}

	private final RowMapper<ChatMessage> chatMessageRowMapper = (rs, rowNum) -> {
		ChatMessage m = new ChatMessage();
		m.setId(rs.getLong("id"));
		m.setConversationId(rs.getInt("conversation_id"));
		m.setSenderId(rs.getInt("sender_id"));
		m.setSenderUsername(rs.getString("sender_username"));
		m.setMessageText(rs.getString("message_text"));
		m.setStatus(rs.getString("status"));
		m.setChatColor(rs.getString("chat_color"));
		m.setEdited(rs.getBoolean("edited"));
		if (rs.getTimestamp("edited_at") != null) {
			m.setEditedAt(rs.getTimestamp("edited_at").toLocalDateTime());
		}
		m.setDeleted(rs.getBoolean("is_deleted"));
		if (rs.getTimestamp("deleted_at") != null) {
			m.setDeletedAt(rs.getTimestamp("deleted_at").toLocalDateTime());
		}
		m.setDeletedByUserId(rs.getObject("deleted_by_user_id", Integer.class));
		m.setDeletedByUsername(rs.getString("deleted_by_username"));
		m.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
		return m;
	};

	/**
	 * Soft-delete a message. This method executes in its own transaction so that
	 * the deletion is committed immediately and not rolled back by outer
	 * transactions.
	 *
	 * For non-admin deletions, the method first verifies that the deleter is the
	 * original sender.
	 *
	 * @param messageId      id of the message to delete
	 * @param deletersUserId id of the user requesting the delete
	 * @param isAdmin        whether the deleter has admin privileges for this
	 *                       conversation
	 * @return true if a row was updated (message marked deleted), false otherwise
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public boolean deleteMessage(long messageId, int deletersUserId, boolean isAdmin) {
		User deleter = jdbcTemplate.queryForObject("SELECT id, username FROM users WHERE id = ?", (rs, rowNum) -> {
			User u = new User();
			u.setId(rs.getInt("id"));
			u.setUsername(rs.getString("username"));
			return u;
		}, deletersUserId);
		if (deleter == null)
			return false;

		String condition = " WHERE id = ? AND is_deleted = FALSE";
		if (!isAdmin) {
			condition += " AND sender_id = ?";
		}

		String deletedMessageText = "Diese Nachricht wurde von " + deleter.getUsername() + " gelöscht!";
		String sql = "UPDATE chat_messages SET is_deleted = TRUE, message_text = ?, deleted_by_user_id = ?, deleted_at = NOW()"
				+ condition;

		int updated;
		if (isAdmin) {
			updated = jdbcTemplate.update(sql, deletedMessageText, deletersUserId, messageId);
		} else {
			updated = jdbcTemplate.update(sql, deletedMessageText, deletersUserId, messageId, deletersUserId);
		}
		return updated > 0;
	}

	public List<ChatMessage> getMessagesForConversation(int conversationId, int limit, int offset) {
		String sql = """
				    SELECT cm.*, u.username as sender_username, u.chat_color, u_del.username as deleted_by_username
				    FROM chat_messages cm
				    JOIN users u ON cm.sender_id = u.id
				    LEFT JOIN users u_del ON cm.deleted_by_user_id = u_del.id
				    WHERE cm.conversation_id = ?
				    ORDER BY cm.sent_at DESC
				    LIMIT ? OFFSET ?
				""";
		return jdbcTemplate.query(sql, chatMessageRowMapper, conversationId, limit, offset);
	}

	public ChatMessage getMessageById(long messageId) {
		try {
			String sql = """
					    SELECT cm.*, u.username as sender_username, u.chat_color, u_del.username as deleted_by_username
					    FROM chat_messages cm
					    JOIN users u ON cm.sender_id = u.id
					    LEFT JOIN users u_del ON cm.deleted_by_user_id = u_del.id
					    WHERE cm.id = ?
					""";
			return jdbcTemplate.queryForObject(sql, chatMessageRowMapper, messageId);
		} catch (Exception e) {
			return null;
		}
	}

	public ChatConversation getConversationById(int conversationId) {
		String sql = "SELECT * FROM chat_conversations WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				ChatConversation conv = new ChatConversation();
				conv.setId(rs.getInt("id"));
				conv.setName(rs.getString("name"));
				conv.setGroupChat(rs.getBoolean("is_group_chat"));
				conv.setCreatorId(rs.getInt("creator_id"));
				conv.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				conv.setParticipants(getParticipantsForConversation(conversationId));
				return conv;
			}, conversationId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		}
	}

	public List<ChatConversation> getConversationsForUser(int userId) {
		String sql = """
				    SELECT
				        c.id, c.name, c.is_group_chat,
				        other_p.user_id as other_participant_id,
				        other_u.username as other_participant_username,
				        (SELECT cm.message_text FROM chat_messages cm WHERE cm.conversation_id = c.id AND cm.is_deleted = FALSE ORDER BY cm.sent_at DESC LIMIT 1) as last_message,
				        (SELECT cm.sent_at FROM chat_messages cm WHERE cm.conversation_id = c.id ORDER BY cm.sent_at DESC LIMIT 1) as last_message_timestamp
				    FROM chat_conversations c
				    JOIN chat_participants p ON c.id = p.conversation_id
				    LEFT JOIN chat_participants other_p ON c.id = other_p.conversation_id AND other_p.user_id != ? AND c.is_group_chat = false
				    LEFT JOIN users other_u ON other_p.user_id = other_u.id
				    WHERE p.user_id = ?
				    ORDER BY last_message_timestamp DESC;
				""";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			ChatConversation conv = new ChatConversation();
			conv.setId(rs.getInt("id"));
			conv.setName(rs.getString("name"));
			conv.setGroupChat(rs.getBoolean("is_group_chat"));
			conv.setOtherParticipantId(rs.getInt("other_participant_id"));
			conv.setOtherParticipantUsername(rs.getString("other_participant_username"));
			conv.setLastMessage(rs.getString("last_message"));
			if (rs.getTimestamp("last_message_timestamp") != null) {
				conv.setLastMessageTimestamp(rs.getTimestamp("last_message_timestamp").toLocalDateTime());
			}
			return conv;
		}, userId, userId);
	}

	public List<User> getParticipantsForConversation(int conversationId) {
		String sql = "SELECT u.id, u.username FROM users u JOIN chat_participants cp ON u.id = cp.user_id WHERE cp.conversation_id = ?";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			User user = new User();
			user.setId(rs.getInt("id"));
			user.setUsername(rs.getString("username"));
			return user;
		}, conversationId);
	}

	@Transactional
	public boolean updateMessagesStatusToRead(List<Long> messageIds, int conversationId, int readerId) {
		if (messageIds == null || messageIds.isEmpty()) {
			return false;
		}
		// FIX: Use NamedParameterJdbcTemplate to avoid SQL injection
		MapSqlParameterSource parameters = new MapSqlParameterSource();
		parameters.addValue("ids", messageIds);
		parameters.addValue("conversationId", conversationId);
		parameters.addValue("readerId", readerId);

		String sql = "UPDATE chat_messages SET status = 'READ' WHERE id IN (:ids) AND conversation_id = :conversationId AND sender_id != :readerId AND status != 'READ'";

		return namedParameterJdbcTemplate.update(sql, parameters) > 0;
	}

	public boolean updateMessage(long messageId, int userId, String newText) {
		String sql = "UPDATE chat_messages SET message_text = ?, edited = TRUE, edited_at = NOW() WHERE id = ? AND sender_id = ? AND is_deleted = FALSE AND sent_at >= NOW() - INTERVAL 24 HOUR";
		return jdbcTemplate.update(sql, newText, messageId, userId) > 0;
	}

	@Transactional
	public ChatMessage createMessage(ChatMessage message) {
		String sql = "INSERT INTO chat_messages (conversation_id, sender_id, message_text, status) VALUES (?, ?, ?, 'SENT')";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, message.getConversationId());
			ps.setInt(2, message.getSenderId());
			ps.setString(3, message.getMessageText());
			return ps;
		}, keyHolder);
		message.setId(Objects.requireNonNull(keyHolder.getKey()).longValue());
		message.setStatus("SENT");
		return message;
	}

	@Transactional
	public int findOrCreateConversation(int userId1, int userId2) {
		String findSql = """
				    SELECT cp1.conversation_id FROM chat_participants cp1
				    JOIN chat_participants cp2 ON cp1.conversation_id = cp2.conversation_id
				    JOIN chat_conversations c ON cp1.conversation_id = c.id
				    WHERE cp1.user_id = ? AND cp2.user_id = ? AND c.is_group_chat = false;
				""";
		try {
			return jdbcTemplate.queryForObject(findSql, Integer.class, userId1, userId2);
		} catch (EmptyResultDataAccessException e) {
			String createConvSql = "INSERT INTO chat_conversations (is_group_chat, creator_id) VALUES (false, ?)";
			GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(createConvSql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, userId1);
				return ps;
			}, keyHolder);
			int newConversationId = Objects.requireNonNull(keyHolder.getKey()).intValue();

			String addParticipantsSql = "INSERT INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
			jdbcTemplate.update(addParticipantsSql, newConversationId, userId1);
			jdbcTemplate.update(addParticipantsSql, newConversationId, userId2);

			return newConversationId;
		}
	}

	@Transactional
	public int createGroupConversation(String name, int creatorId, List<Integer> participantIds) {
		String createConvSql = "INSERT INTO chat_conversations (is_group_chat, name, creator_id) VALUES (true, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(createConvSql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			ps.setInt(2, creatorId);
			return ps;
		}, keyHolder);
		int newConversationId = Objects.requireNonNull(keyHolder.getKey()).intValue();

		String addParticipantsSql = "INSERT INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
		// Add the creator as well
		if (!participantIds.contains(creatorId)) {
			participantIds.add(creatorId);
		}
		for (Integer participantId : participantIds) {
			jdbcTemplate.update(addParticipantsSql, newConversationId, participantId);
		}

		return newConversationId;
	}

	public boolean isUserInConversation(int conversationId, int userId) {
		String sql = "SELECT COUNT(*) FROM chat_participants WHERE conversation_id = ? AND user_id = ?";
		Integer count = jdbcTemplate.queryForObject(sql, Integer.class, conversationId, userId);
		return count != null && count > 0;
	}

	@Transactional
	public void addParticipantsToGroup(int conversationId, List<Integer> userIds) {
		String sql = "INSERT IGNORE INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
		jdbcTemplate.batchUpdate(sql, userIds, 100, (ps, userId) -> {
			ps.setInt(1, conversationId);
			ps.setInt(2, userId);
		});
	}

	@Transactional
	public boolean leaveGroup(int conversationId, int userId) {
		return jdbcTemplate.update("DELETE FROM chat_participants WHERE conversation_id = ? AND user_id = ?",
				conversationId, userId) > 0;
	}

	@Transactional
	public boolean deleteGroup(int conversationId) {
		return jdbcTemplate.update("DELETE FROM chat_conversations WHERE id = ?", conversationId) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChecklistDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChecklistItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ChecklistDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ChecklistDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ChecklistItem> checklistItemRowMapper = (rs, rowNum) -> {
		ChecklistItem item = new ChecklistItem();
		item.setId(rs.getInt("id"));
		item.setEventId(rs.getInt("event_id"));
		item.setItemId(rs.getInt("item_id"));
		item.setItemName(rs.getString("item_name"));
		item.setQuantity(rs.getInt("quantity"));
		item.setStatus(rs.getString("status"));
		item.setLastUpdatedByUserId(rs.getObject("last_updated_by_user_id", Integer.class));
		item.setLastUpdatedByUsername(rs.getString("last_updated_by_username"));
		item.setLastUpdatedAt(rs.getTimestamp("last_updated_at").toLocalDateTime());
		return item;
	};

	public List<ChecklistItem> getChecklistForEvent(int eventId) {
		String sql = "SELECT ci.*, si.name as item_name, u.username as last_updated_by_username "
				+ "FROM event_inventory_checklist ci " + "JOIN storage_items si ON ci.item_id = si.id "
				+ "LEFT JOIN users u ON ci.last_updated_by_user_id = u.id " + "WHERE ci.event_id = ? ORDER BY si.name";
		return jdbcTemplate.query(sql, checklistItemRowMapper, eventId);
	}

	public int generateChecklistFromReservations(int eventId) {
		String sql = "INSERT INTO event_inventory_checklist (event_id, item_id, quantity, status) "
				+ "SELECT event_id, item_id, reserved_quantity, 'PENDING' FROM event_storage_reservations "
				+ "WHERE event_id = ? " + "ON DUPLICATE KEY UPDATE quantity = VALUES(quantity)";
		return jdbcTemplate.update(sql, eventId);
	}

	public boolean updateChecklistItemStatus(int checklistItemId, String status, int userId) {
		String sql = "UPDATE event_inventory_checklist SET status = ?, last_updated_by_user_id = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, userId, checklistItemId) > 0;
	}

	public ChecklistItem getChecklistItemById(int checklistItemId) {
		String sql = "SELECT ci.*, si.name as item_name, u.username as last_updated_by_username "
				+ "FROM event_inventory_checklist ci " + "JOIN storage_items si ON ci.item_id = si.id "
				+ "LEFT JOIN users u ON ci.last_updated_by_user_id = u.id " + "WHERE ci.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, checklistItemRowMapper, checklistItemId);
		} catch (Exception e) {
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChecklistTemplateDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChecklistTemplate;
import de.technikteam.model.ChecklistTemplateItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class ChecklistTemplateDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ChecklistTemplateDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public ChecklistTemplate save(ChecklistTemplate template) {
		if (template.getId() > 0) {
			updateTemplate(template);
		} else {
			int newId = createTemplate(template);
			template.setId(newId);
		}

		// Sync items
		jdbcTemplate.update("DELETE FROM preflight_checklist_items WHERE template_id = ?", template.getId());
		if (template.getItems() != null && !template.getItems().isEmpty()) {
			String itemSql = "INSERT INTO preflight_checklist_items (template_id, item_text, display_order) VALUES (?, ?, ?)";
			jdbcTemplate.batchUpdate(itemSql, template.getItems(), 100, (ps, item) -> {
				ps.setInt(1, template.getId());
				ps.setString(2, item.getItemText());
				ps.setInt(3, template.getItems().indexOf(item));
			});
		}
		return template;
	}

	private int createTemplate(ChecklistTemplate template) {
		String sql = "INSERT INTO preflight_checklist_templates (name, description) VALUES (?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, template.getName());
			ps.setString(2, template.getDescription());
			return ps;
		}, keyHolder);
		return Objects.requireNonNull(keyHolder.getKey()).intValue();
	}

	private void updateTemplate(ChecklistTemplate template) {
		String sql = "UPDATE preflight_checklist_templates SET name = ?, description = ? WHERE id = ?";
		jdbcTemplate.update(sql, template.getName(), template.getDescription(), template.getId());
	}

	public List<ChecklistTemplate> findAll() {
		String sql = "SELECT t.id as template_id, t.name, t.description, i.id as item_id, i.item_text, i.display_order "
				+ "FROM preflight_checklist_templates t "
				+ "LEFT JOIN preflight_checklist_items i ON t.id = i.template_id " + "ORDER BY t.name, i.display_order";

		Map<Integer, ChecklistTemplate> templateMap = new LinkedHashMap<>();
		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int templateId = rs.getInt("template_id");
			ChecklistTemplate template = templateMap.computeIfAbsent(templateId, id -> {
				try {
					ChecklistTemplate newTemplate = new ChecklistTemplate();
					newTemplate.setId(id);
					newTemplate.setName(rs.getString("name"));
					newTemplate.setDescription(rs.getString("description"));
					newTemplate.setItems(new ArrayList<>());
					return newTemplate;
				} catch (SQLException e) {
					throw new RuntimeException("Failed to map template", e);
				}
			});

			if (rs.getObject("item_id") != null) {
				ChecklistTemplateItem item = new ChecklistTemplateItem();
				item.setId(rs.getInt("item_id"));
				item.setTemplateId(templateId);
				item.setItemText(rs.getString("item_text"));
				item.setDisplayOrder(rs.getInt("display_order"));
				template.getItems().add(item);
			}
		});
		return new ArrayList<>(templateMap.values());
	}

	public boolean delete(int id) {
		return jdbcTemplate.update("DELETE FROM preflight_checklist_templates WHERE id = ?", id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Course;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public CourseDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Course> courseRowMapper = (rs, rowNum) -> {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	};

	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription()) > 0;
		} catch (Exception e) {
			logger.error("Error creating course: {}", course.getName(), e);
			return false;
		}
	}

	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, courseRowMapper, courseId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching course by ID: {}", courseId, e);
			return null;
		}
	}

	public List<Course> getAllCourses() {
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		try {
			return jdbcTemplate.query(sql, courseRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all courses.", e);
			return List.of();
		}
	}

	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription(),
					course.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating course: {}", course.getName(), e);
			return false;
		}
	}

	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		try {
			// Manually delete related data due to foreign key constraints
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE required_course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM user_qualifications WHERE course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM meetings WHERE course_id = ?", courseId);

			return jdbcTemplate.update(sql, courseId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\DamageReportDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.DamageReport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class DamageReportDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public DamageReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<DamageReport> reportRowMapper = (rs, rowNum) -> {
		DamageReport report = new DamageReport();
		report.setId(rs.getInt("id"));
		report.setItemId(rs.getInt("item_id"));
		report.setReporterUserId(rs.getInt("reporter_user_id"));
		report.setReportDescription(rs.getString("report_description"));
		report.setReportedAt(rs.getTimestamp("reported_at").toLocalDateTime());
		report.setStatus(rs.getString("status"));
		report.setReviewedByAdminId(rs.getObject("reviewed_by_admin_id", Integer.class));
		if (rs.getTimestamp("reviewed_at") != null) {
			report.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		report.setAdminNotes(rs.getString("admin_notes"));
		// Joined fields
		report.setItemName(rs.getString("item_name"));
		report.setReporterUsername(rs.getString("reporter_username"));
		return report;
	};

	public DamageReport createReport(int itemId, int reporterUserId, String description) {
		String sql = "INSERT INTO damage_reports (item_id, reporter_user_id, report_description) VALUES (?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, itemId);
			ps.setInt(2, reporterUserId);
			ps.setString(3, description);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		return getReportById(newId).orElse(null);
	}

	public List<DamageReport> getPendingReports() {
		String sql = "SELECT dr.*, si.name as item_name, u.username as reporter_username FROM damage_reports dr "
				+ "JOIN storage_items si ON dr.item_id = si.id " + "JOIN users u ON dr.reporter_user_id = u.id "
				+ "WHERE dr.status = 'PENDING' ORDER BY dr.reported_at ASC";
		return jdbcTemplate.query(sql, reportRowMapper);
	}

	public Optional<DamageReport> getReportById(int id) {
		String sql = "SELECT dr.*, si.name as item_name, u.username as reporter_username FROM damage_reports dr "
				+ "JOIN storage_items si ON dr.item_id = si.id " + "JOIN users u ON dr.reporter_user_id = u.id "
				+ "WHERE dr.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, reportRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public boolean updateStatus(int reportId, String status, int adminId, String adminNotes) {
		String sql = "UPDATE damage_reports SET status = ?, reviewed_by_admin_id = ?, reviewed_at = ?, admin_notes = ? WHERE id = ?";
		return jdbcTemplate.update(sql, ps -> {
			ps.setString(1, status);
			ps.setInt(2, adminId);
			ps.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now()));
			if (adminNotes != null) {
				ps.setString(4, adminNotes);
			} else {
				ps.setNull(4, Types.VARCHAR);
			}
			ps.setInt(5, reportId);
		}) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventChatDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventChatMessage> chatMessageRowMapper = (rs, rowNum) -> {
		EventChatMessage message = new EventChatMessage();
		message.setId(rs.getInt("id"));
		message.setEventId(rs.getInt("event_id"));
		message.setUserId(rs.getInt("user_id"));
		message.setUsername(rs.getString("username"));
		message.setMessageText(rs.getString("message_text"));
		message.setEdited(rs.getBoolean("edited"));
		if (rs.getTimestamp("edited_at") != null) {
			message.setEditedAt(rs.getTimestamp("edited_at").toLocalDateTime());
		}
		message.setDeleted(rs.getBoolean("is_deleted"));
		message.setDeletedByUserId(rs.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(rs.getString("deleted_by_username"));
		message.setChatColor(rs.getString("chat_color"));
		if (rs.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(rs.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
		return message;
	};

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, message.getEventId());
				ps.setInt(2, message.getUserId());
				ps.setString(3, message.getUsername());
				ps.setString(4, message.getMessageText());
				return ps;
			}, keyHolder);

			int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
			return getMessageById(newId);
		} catch (Exception e) {
			logger.error("Error posting chat message for event {}", message.getEventId(), e);
			return null;
		}
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try {
			return jdbcTemplate.query(sql, chatMessageRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching chat messages for event {}", eventId, e);
			return List.of();
		}
	}

	public EventChatMessage getMessageById(int messageId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, chatMessageRowMapper, messageId);
		} catch (Exception e) {
			logger.error("Error fetching message by ID {}", messageId, e);
			return null;
		}
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE, edited_at = NOW() WHERE id = ? AND user_id = ? AND is_deleted = FALSE AND sent_at >= NOW() - INTERVAL 24 HOUR";
		try {
			return jdbcTemplate.update(sql, newText, messageId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating message ID {}", messageId, e);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql = isAdmin
				? "UPDATE event_chat_messages SET is_deleted = TRUE, message_text = '', deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ?"
				: "UPDATE event_chat_messages SET is_deleted = TRUE, message_text = '', deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ? AND user_id = ?";
		try {
			if (isAdmin) {
				return jdbcTemplate.update(sql, deletersUserId, messageId) > 0;
			} else {
				return jdbcTemplate.update(sql, deletersUserId, messageId, deletersUserId) > 0;
			}
		} catch (Exception e) {
			logger.error("Error soft-deleting message ID {}:", messageId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventCustomFieldDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields) {
		try {
			jdbcTemplate.update("DELETE FROM event_custom_fields WHERE event_id = ?", eventId);

			if (fields != null && !fields.isEmpty()) {
				String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
				jdbcTemplate.batchUpdate(insertSql, fields, 100, (ps, field) -> {
					ps.setInt(1, eventId);
					ps.setString(2, field.getFieldName());
					ps.setString(3, field.getFieldType());
					ps.setBoolean(4, field.isRequired());
					ps.setString(5, field.getFieldOptions());
				});
			}
		} catch (Exception e) {
			logger.error("Error in transaction for saving custom fields for event {}", eventId, e);
			// Transactional annotation will handle rollback
			throw new RuntimeException(e);
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				EventCustomField field = new EventCustomField();
				field.setId(rs.getInt("id"));
				field.setEventId(rs.getInt("event_id"));
				field.setFieldName(rs.getString("field_name"));
				field.setFieldType(rs.getString("field_type"));
				field.setRequired(rs.getBoolean("is_required"));
				field.setFieldOptions(rs.getString("field_options"));
				return field;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
			return List.of();
		}
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try {
			jdbcTemplate.update(sql, response.getFieldId(), response.getUserId(), response.getResponseValue());
		} catch (Exception e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Event;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);
	private final JdbcTemplate jdbcTemplate;
	private final EventTaskDAO eventTaskDAO;

	@Autowired
	public EventDAO(JdbcTemplate jdbcTemplate, EventTaskDAO eventTaskDAO) {
		this.jdbcTemplate = jdbcTemplate;
		this.eventTaskDAO = eventTaskDAO;
	}

	private final RowMapper<Event> eventRowMapper = (rs, rowNum) -> {
		Event event = new Event();
		event.setId(rs.getInt("id"));
		event.setName(rs.getString("name"));
		event.setDescription(rs.getString("description"));
		event.setLocation(rs.getString("location"));
		event.setStatus(rs.getString("status"));
		event.setEventDateTime(rs.getTimestamp("event_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			event.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(rs, "leader_user_id")) {
			event.setLeaderUserId(rs.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(rs, "leader_username")) {
			event.setLeaderUsername(rs.getString("leader_username"));
		}
		return event;
	};

	private final RowMapper<User> simpleUserRowMapper = (rs, rowNum) -> new User(rs.getInt("id"),
			rs.getString("username"), rs.getString("role"));

	public List<Event> getUpcomingEventsForUser(User user) {
		String sql = "SELECT e.*, u_leader.username AS leader_username, " + "COALESCE("
				+ "    (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), "
				+ "    (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), "
				+ "    'OFFEN'" + ") AS user_attendance_status, " + "(" + "    SELECT COUNT(*) = 0 "
				+ "    FROM event_skill_requirements esr " + "    WHERE esr.event_id = e.id " + "    AND NOT EXISTS ("
				+ "        SELECT 1 FROM user_qualifications uq "
				+ "        WHERE uq.user_id = ? AND uq.course_id = esr.required_course_id AND uq.status = 'BESTANDEN'"
				+ "    )" + ") AS is_user_qualified " + "FROM events e "
				+ "LEFT JOIN users u_leader ON e.leader_user_id = u_leader.id "
				+ "WHERE e.status IN ('GEPLANT', 'LAUFEND') AND e.event_datetime >= NOW() - INTERVAL 1 DAY "
				+ "ORDER BY e.event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_attendance_status"));
				event.setUserQualified(rs.getBoolean("is_user_qualified"));
				return event;
			}, user.getId(), user.getId(), user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming events for user {}: {}", user.getUsername(), e.getMessage());
			return List.of();
		}
	}

	public List<Event> getPersonalizedEventFeed(int userId, int limit) {
		String sql = "SELECT e.*, u_leader.username AS leader_username " + "FROM events e "
				+ "LEFT JOIN users u_leader ON e.leader_user_id = u_leader.id "
				+ "WHERE e.status = 'GEPLANT' AND e.event_datetime >= NOW() "
				// User is qualified for ALL requirements
				+ "AND NOT EXISTS ( " + "    SELECT 1 FROM event_skill_requirements esr "
				+ "    WHERE esr.event_id = e.id AND NOT EXISTS ( " + "        SELECT 1 FROM user_qualifications uq "
				+ "        WHERE uq.user_id = ? AND uq.course_id = esr.required_course_id AND uq.status = 'BESTANDEN' "
				+ "    ) " + ") "
				// User is NOT already attending
				+ "AND NOT EXISTS ( " + "    SELECT 1 FROM event_attendance ea "
				+ "    WHERE ea.event_id = e.id AND ea.user_id = ? AND ea.signup_status = 'ANGEMELDET' " + ") "
				+ "AND NOT EXISTS ( " + "    SELECT 1 FROM event_assignments eas "
				+ "    WHERE eas.event_id = e.id AND eas.user_id = ? " + ") " + "ORDER BY e.event_datetime ASC ";
		if (limit > 0) {
			sql += "LIMIT ?";
		}
		try {
			if (limit > 0) {
				return jdbcTemplate.query(sql, eventRowMapper, userId, userId, userId, limit);
			} else {
				return jdbcTemplate.query(sql, eventRowMapper, userId, userId, userId);
			}
		} catch (Exception e) {
			logger.error("Error fetching personalized event feed for user {}: {}", userId, e.getMessage());
			return List.of();
		}
	}

	public List<Event> getEventHistoryForUser(int userId) {
		String sql = "SELECT e.*, COALESCE( (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), 'OFFEN' ) AS user_status FROM events e WHERE EXISTS ( SELECT 1 FROM event_attendance WHERE event_id = e.id AND user_id = ? UNION SELECT 1 FROM event_assignments WHERE event_id = e.id AND user_id = ? ) ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_status"));
				return event;
			}, userId, userId, userId, userId);
		} catch (Exception e) {
			logger.error("Error fetching event history for user {}", userId, e);
			return List.of();
		}
	}

	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id WHERE e.id = ?";
		try {
			Event event = jdbcTemplate.queryForObject(sql, eventRowMapper, eventId);
			if (event != null) {
				event.setEventTasks(eventTaskDAO.getTasksForEvent(eventId));
				event.setAssignedAttendees(getAssignedUsersForEvent(eventId));
			}
			return event;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching event by ID: {}", eventId, e);
			return null;
		}
	}

	public List<Event> getAllEvents() {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all events.", e);
			return List.of();
		}
	}

	public List<Event> getActiveEvents() {
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active events.", e);
			return List.of();
		}
	}

	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, 'GEPLANT', ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, event.getName());
				ps.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
				if (event.getEndDateTime() != null)
					ps.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
				else
					ps.setNull(3, Types.TIMESTAMP);
				ps.setString(4, event.getDescription());
				ps.setString(5, event.getLocation());
				if (event.getLeaderUserId() > 0)
					ps.setInt(6, event.getLeaderUserId());
				else
					ps.setNull(6, Types.INTEGER);
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating event {}", event.getName(), e);
			return 0;
		}
	}

	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, event.getName(), Timestamp.valueOf(event.getEventDateTime()),
					event.getEndDateTime() != null ? Timestamp.valueOf(event.getEndDateTime()) : null,
					event.getDescription(), event.getLocation(), event.getStatus(),
					event.getLeaderUserId() > 0 ? event.getLeaderUserId() : null, event.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating event {}", event.getName(), e);
			return false;
		}
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, eventId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting event with ID: {}", eventId, e);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-up for user {} and event {}", userId, eventId, e);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-off for user {} and event {}", userId, eventId, e);
		}
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		try {
			jdbcTemplate.update("DELETE FROM event_assignments WHERE event_id = ?", eventId);
			if (userIds != null && userIds.length > 0) {
				String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
				jdbcTemplate.batchUpdate(insertSql, List.of(userIds), 100, (ps, userId) -> {
					ps.setInt(1, eventId);
					ps.setInt(2, Integer.parseInt(userId));
				});
			}
		} catch (Exception e) {
			logger.error("Error during user assignment for event ID: {}.", eventId, e);
		}
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				SkillRequirement req = new SkillRequirement();
				req.setRequiredCourseId(rs.getInt("required_course_id"));
				req.setCourseName(rs.getString("course_name"));
				req.setRequiredPersons(rs.getInt("required_persons"));
				return req;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching skill requirements for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		try {
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE event_id = ?", eventId);
			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				String sql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(requiredCourseIds), 100, (ps, courseId) -> {
					// This is a bit clumsy but necessary to align arrays
					int index = List.of(requiredCourseIds).indexOf(courseId);
					if (!courseId.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(courseId));
						ps.setInt(3, Integer.parseInt(requiredPersons[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving skill requirements for event ID: {}.", eventId, e);
		}
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		try {
			jdbcTemplate.update("DELETE FROM event_storage_reservations WHERE event_id = ?", eventId);
			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				String sql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(itemIds), 100, (ps, itemIdStr) -> {
					int index = List.of(itemIds).indexOf(itemIdStr);
					if (!itemIdStr.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(itemIdStr));
						ps.setInt(3, Integer.parseInt(quantities[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving reservations for event ID: {}.", eventId, e);
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageItem item = new StorageItem();
				item.setId(rs.getInt("id"));
				item.setName(rs.getString("name"));
				item.setQuantity(rs.getInt("reserved_quantity"));
				return item;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching reserved items for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		String sql = "SELECT * FROM events WHERE status NOT IN ('ABGESCHLOSSEN', 'ABGESAGT') AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active/upcoming events for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithEvent(int eventId, int userId) {
		String sql = "SELECT COUNT(*) FROM (SELECT 1 FROM event_attendance WHERE event_id = ? AND user_id = ? AND signup_status = 'ANGEMELDET' UNION ALL SELECT 1 FROM event_assignments WHERE event_id = ? AND user_id = ?) AS combined";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, eventId, userId, eventId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for event {} and user {}", eventId, userId, e);
			return false;
		}
	}

	public String getUserAttendanceStatus(int eventId, int userId) {
		String sql = "SELECT COALESCE("
				+ "    (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = ? AND user_id = ?), "
				+ "    (SELECT signup_status FROM event_attendance WHERE event_id = ? AND user_id = ?), "
				+ "    'OFFEN'" + ") AS user_status";
		try {
			return jdbcTemplate.queryForObject(sql, String.class, eventId, userId, eventId, userId);
		} catch (Exception e) {
			logger.error("Error fetching user attendance status for event {} user {}", eventId, userId, e);
			return "OFFEN";
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u JOIN event_assignments ea ON u.id = ea.user_id LEFT JOIN roles r ON u.role_id = r.id WHERE ea.event_id = ?";
		try {
			return jdbcTemplate.query(sql, simpleUserRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching assigned users for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching completed event history for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.event_datetime >= NOW() ORDER BY e.event_datetime ASC";
		if (limit > 0) {
			sql += " LIMIT ?";
		}
		try {
			if (limit > 0) {
				return jdbcTemplate.query(sql, eventRowMapper, userId, limit);
			} else {
				return jdbcTemplate.query(sql, eventRowMapper, userId);
			}
		} catch (Exception e) {
			logger.error("Error fetching assigned events for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getUpcomingEvents(int limit) {
		String sql = "SELECT * FROM events WHERE event_datetime > NOW() ORDER BY event_datetime ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error fetching upcoming events with limit {}", limit, e);
			return List.of();
		}
	}

	public List<Event> search(String query) {
		String sql = "SELECT * FROM events WHERE name LIKE ? OR description LIKE ? OR location LIKE ? ORDER BY event_datetime DESC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching events for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventDebriefingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventDebriefing;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public class EventDebriefingDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventDebriefingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventDebriefing> debriefingRowMapper = (rs, rowNum) -> {
		EventDebriefing d = new EventDebriefing();
		d.setId(rs.getInt("id"));
		d.setEventId(rs.getInt("event_id"));
		d.setAuthorUserId(rs.getInt("author_user_id"));
		d.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		d.setWhatWentWell(rs.getString("what_went_well"));
		d.setWhatToImprove(rs.getString("what_to_improve"));
		d.setEquipmentNotes(rs.getString("equipment_notes"));
		d.setStandoutCrewMembers(rs.getString("standout_crew_members"));
		// Joined fields
		d.setEventName(rs.getString("event_name"));
		d.setAuthorUsername(rs.getString("author_username"));
		return d;
	};

	public Optional<EventDebriefing> findByEventId(int eventId) {
		String sql = "SELECT ed.*, e.name as event_name, u.username as author_username " + "FROM event_debriefings ed "
				+ "JOIN events e ON ed.event_id = e.id " + "JOIN users u ON ed.author_user_id = u.id "
				+ "WHERE ed.event_id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, debriefingRowMapper, eventId));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public List<EventDebriefing> findAll() {
		String sql = "SELECT ed.*, e.name as event_name, u.username as author_username " + "FROM event_debriefings ed "
				+ "JOIN events e ON ed.event_id = e.id " + "JOIN users u ON ed.author_user_id = u.id "
				+ "ORDER BY ed.submitted_at DESC";
		return jdbcTemplate.query(sql, debriefingRowMapper);
	}

	public EventDebriefing save(EventDebriefing debriefing) {
		String sql = "INSERT INTO event_debriefings (event_id, author_user_id, what_went_well, what_to_improve, equipment_notes, standout_crew_members) "
				+ "VALUES (?, ?, ?, ?, ?, ?) " + "ON DUPLICATE KEY UPDATE "
				+ "author_user_id = VALUES(author_user_id), " + "submitted_at = CURRENT_TIMESTAMP, "
				+ "what_went_well = VALUES(what_went_well), " + "what_to_improve = VALUES(what_to_improve), "
				+ "equipment_notes = VALUES(equipment_notes), "
				+ "standout_crew_members = VALUES(standout_crew_members)";

		jdbcTemplate.update(sql, debriefing.getEventId(), debriefing.getAuthorUserId(), debriefing.getWhatWentWell(),
				debriefing.getWhatToImprove(), debriefing.getEquipmentNotes(), debriefing.getStandoutCrewMembers());
		return findByEventId(debriefing.getEventId()).orElse(null);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventFeedbackDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventFeedbackDAO {
	private static final Logger logger = LogManager.getLogger(EventFeedbackDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventFeedbackDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, form.getEventId());
				ps.setString(2, form.getTitle());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
			return 0;
		}
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try {
			return jdbcTemplate.update(sql, response.getFormId(), response.getUserId(), response.getRating(),
					response.getComments()) > 0;
		} catch (Exception e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
			return false;
		}
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, eventId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
			return null;
		}
	}

	public FeedbackForm getFormById(int formId) {
		String sql = "SELECT * FROM feedback_forms WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, formId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for form ID {}", formId, e);
			return null;
		}
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FeedbackResponse response = new FeedbackResponse();
				response.setId(rs.getInt("id"));
				response.setFormId(rs.getInt("form_id"));
				response.setUserId(rs.getInt("user_id"));
				response.setUsername(rs.getString("username"));
				response.setRating(rs.getInt("rating"));
				response.setComments(rs.getString("comments"));
				response.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
				return response;
			}, formId);
		} catch (Exception e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
			return List.of();
		}
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT COUNT(*) FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, formId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user feedback submission status.", e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventPhotoDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventPhoto;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class EventPhotoDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventPhotoDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventPhoto> rowMapper = (rs, rowNum) -> {
		EventPhoto photo = new EventPhoto();
		photo.setId(rs.getInt("id"));
		photo.setEventId(rs.getInt("event_id"));
		photo.setFileId(rs.getInt("file_id"));
		photo.setUploaderUserId(rs.getInt("uploader_user_id"));
		photo.setCaption(rs.getString("caption"));
		photo.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		// Joined fields
		photo.setFilepath(rs.getString("filepath"));
		photo.setUploaderUsername(rs.getString("username"));
		return photo;
	};

	public List<EventPhoto> findByEventId(int eventId) {
		String sql = "SELECT ep.*, f.filepath, u.username FROM event_photos ep " + "JOIN files f ON ep.file_id = f.id "
				+ "JOIN users u ON ep.uploader_user_id = u.id " + "WHERE ep.event_id = ? ORDER BY ep.uploaded_at DESC";
		return jdbcTemplate.query(sql, rowMapper, eventId);
	}

	public Optional<EventPhoto> findById(int id) {
		String sql = "SELECT ep.*, f.filepath, u.username FROM event_photos ep " + "JOIN files f ON ep.file_id = f.id "
				+ "JOIN users u ON ep.uploader_user_id = u.id " + "WHERE ep.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public EventPhoto create(EventPhoto photo) {
		String sql = "INSERT INTO event_photos (event_id, file_id, uploader_user_id, caption) VALUES (?, ?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, photo.getEventId());
			ps.setInt(2, photo.getFileId());
			ps.setInt(3, photo.getUploaderUserId());
			ps.setString(4, photo.getCaption());
			return ps;
		}, keyHolder);
		photo.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
		return photo;
	}

	public boolean delete(int id) {
		return jdbcTemplate.update("DELETE FROM event_photos WHERE id = ?", id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventRoleDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventRole;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class EventRoleDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventRoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventRole> rowMapper = (rs, rowNum) -> {
		EventRole role = new EventRole();
		role.setId(rs.getInt("id"));
		role.setName(rs.getString("name"));
		role.setDescription(rs.getString("description"));
		role.setIconClass(rs.getString("icon_class"));
		role.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return role;
	};

	public List<EventRole> findAll() {
		String sql = "SELECT * FROM event_roles ORDER BY name ASC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public boolean create(EventRole role) {
		String sql = "INSERT INTO event_roles (name, description, icon_class) VALUES (?, ?, ?)";
		return jdbcTemplate.update(sql, role.getName(), role.getDescription(), role.getIconClass()) > 0;
	}

	public boolean update(EventRole role) {
		String sql = "UPDATE event_roles SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		return jdbcTemplate.update(sql, role.getName(), role.getDescription(), role.getIconClass(), role.getId()) > 0;
	}

	public boolean delete(int id) {
		// ON DELETE SET NULL will handle un-assigning from event_assignments
		String sql = "DELETE FROM event_roles WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventTaskDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds,
			int[] dependencyIds) {
		boolean isUpdate = task.getId() > 0;
		logger.debug("DAO saveTask called for task '{}'. Is update: {}", task.getDescription(), isUpdate);
		if (isUpdate) {
			updateTask(task);
		} else {
			int newId = createTask(task);
			task.setId(newId);
		}

		if (task.getId() == 0) {
			logger.error("Failed to create or find task ID for task: {}", task.getDescription());
			throw new RuntimeException("Failed to create or find task ID.");
		}

		clearAssociations(task.getId());
		saveUserAssignments(task.getId(), userIds);
		saveItemRequirements(task.getId(), itemIds, itemQuantities);
		saveKitRequirements(task.getId(), kitIds);
		saveDependencies(task.getId(), dependencyIds);

		logger.info("Successfully saved task ID {}", task.getId());
		return task.getId();
	}

	private int createTask(EventTask task) {
		logger.debug("DAO createTask: eventId={}, description='{}'", task.getEventId(), task.getDescription());
		String taskSql = "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, task.getEventId());
			ps.setString(2, task.getDescription());
			ps.setString(3, task.getDetails());
			ps.setInt(4, task.getDisplayOrder());
			ps.setInt(5, task.getRequiredPersons());
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		logger.debug("DAO createTask successful. New task ID: {}", newId);
		return newId;
	}

	private void updateTask(EventTask task) {
		logger.debug("DAO updateTask for task ID: {}", task.getId());
		String taskSql = "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?";
		jdbcTemplate.update(taskSql, task.getDescription(), task.getDetails(), task.getStatus(), task.getDisplayOrder(),
				task.getRequiredPersons(), task.getId());
	}

	private void clearAssociations(int taskId) {
		jdbcTemplate.update("DELETE FROM event_task_assignments WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_storage_items WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_kits WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_dependencies WHERE task_id = ?", taskId);
	}

	private void saveUserAssignments(int taskId, int[] userIds) {
		if (userIds == null || userIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		List<Integer> userIdList = Arrays.stream(userIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, userIdList, 100, (ps, userId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, userId);
		});
	}

	private void saveItemRequirements(int taskId, String[] itemIds, String[] itemQuantities) {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;
		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		List<String> itemIdList = List.of(itemIds);
		jdbcTemplate.batchUpdate(sql, itemIdList, 100, (ps, itemIdStr) -> {
			if (itemIdStr != null && !itemIdStr.isEmpty()) {
				int index = itemIdList.indexOf(itemIdStr);
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(itemIdStr));
				ps.setInt(3, Integer.parseInt(itemQuantities[index]));
			}
		});
	}

	private void saveKitRequirements(int taskId, String[] kitIds) {
		if (kitIds == null || kitIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		List<String> kitIdList = List.of(kitIds);
		jdbcTemplate.batchUpdate(sql, kitIdList, 100, (ps, kitIdStr) -> {
			if (kitIdStr != null && !kitIdStr.isEmpty()) {
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(kitIdStr));
			}
		});
	}

	private void saveDependencies(int taskId, int[] dependencyIds) {
		if (dependencyIds == null || dependencyIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_dependencies (task_id, depends_on_task_id) VALUES (?, ?)";
		List<Integer> dependencyIdList = Arrays.stream(dependencyIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, dependencyIdList, 100, (ps, dependencyId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, dependencyId);
		});
	}

	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, u.id as user_id, u.username, si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, ik.id as kit_id, ik.name as kit_name FROM event_tasks t LEFT JOIN event_task_assignments ta ON t.id = ta.task_id LEFT JOIN users u ON ta.user_id = u.id LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id LEFT JOIN storage_items si ON tsi.item_id = si.id LEFT JOIN event_task_kits tk ON t.id = tk.task_id LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id WHERE t.event_id = ? ORDER BY FIELD(t.status, 'OFFEN', 'IN_ARBEIT', 'ERLEDIGT'), CASE WHEN t.status = 'OFFEN' AND ta.user_id IS NULL THEN 0 ELSE 1 END, t.updated_at DESC";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int currentTaskId = rs.getInt("id");
			EventTask task = tasksById.computeIfAbsent(currentTaskId, id -> mapResultSetToTask(rs));

			int currentUserId = rs.getInt("user_id");
			if (currentUserId > 0 && task.getAssignedUsers().stream().noneMatch(u -> u.getId() == currentUserId)) {
				User user = new User();
				user.setId(currentUserId);
				user.setUsername(rs.getString("username"));
				task.getAssignedUsers().add(user);
			}
			int currentItemId = rs.getInt("item_id");
			if (currentItemId > 0 && task.getRequiredItems().stream().noneMatch(i -> i.getId() == currentItemId)) {
				StorageItem item = new StorageItem();
				item.setId(currentItemId);
				item.setName(rs.getString("item_name"));
				item.setQuantity(rs.getInt("item_quantity"));
				task.getRequiredItems().add(item);
			}
			int currentKitId = rs.getInt("kit_id");
			if (currentKitId > 0 && task.getRequiredKits().stream().noneMatch(k -> k.getId() == currentKitId)) {
				InventoryKit kit = new InventoryKit();
				kit.setId(currentKitId);
				kit.setName(rs.getString("kit_name"));
				task.getRequiredKits().add(kit);
			}
		}, eventId);

		// Now fetch and assemble dependencies
		if (!tasksById.isEmpty()) {
			String depSql = "SELECT * FROM event_task_dependencies WHERE task_id IN ("
					+ tasksById.keySet().stream().map(String::valueOf).collect(Collectors.joining(",")) + ")";
			jdbcTemplate.query(depSql, rs -> {
				int taskId = rs.getInt("task_id");
				int dependsOnId = rs.getInt("depends_on_task_id");
				EventTask task = tasksById.get(taskId);
				EventTask parentTask = tasksById.get(dependsOnId);
				if (task != null && parentTask != null) {
					task.getDependsOn().add(parentTask);
					parentTask.getDependencyFor().add(task);
				}
			});
		}

		return new ArrayList<>(tasksById.values());
	}

	private EventTask mapResultSetToTask(ResultSet rs) {
		try {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setDetails(rs.getString("details"));
			task.setStatus(rs.getString("status"));
			task.setDisplayOrder(rs.getInt("display_order"));
			task.setRequiredPersons(rs.getInt("required_persons"));
			task.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
			task.setAssignedUsers(new ArrayList<>());
			task.setRequiredItems(new ArrayList<>());
			task.setRequiredKits(new ArrayList<>());
			task.setDependsOn(new ArrayList<>());
			task.setDependencyFor(new ArrayList<>());
			return task;
		} catch (SQLException e) {
			throw new RuntimeException("Failed to map ResultSet to EventTask", e);
		}
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, taskId) > 0;
	}

	public boolean assignUserToTask(int taskId, int userId) {
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		try {
			return jdbcTemplate.update(sql, taskId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error assigning user {} to task {}", userId, taskId, e);
			return false;
		}
	}

	public boolean unassignUserFromTask(int taskId, int userId) {
		String sql = "DELETE FROM event_task_assignments WHERE task_id = ? AND user_id = ?";
		try {
			return jdbcTemplate.update(sql, taskId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error un-assigning user {} from task {}", userId, taskId, e);
			return false;
		}
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		String sql = "SELECT t.*, e.name as event_name FROM event_tasks t JOIN event_task_assignments ta ON t.id = ta.task_id JOIN events e ON t.event_id = e.id WHERE ta.user_id = ? AND t.status = 'OFFEN' ORDER BY e.event_datetime ASC";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setStatus(rs.getString("status"));
			task.setEventName(rs.getString("event_name"));
			return task;
		}, userId);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\FeedbackSubmissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackSubmission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class FeedbackSubmissionDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackSubmissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FeedbackSubmissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<FeedbackSubmission> submissionRowMapper = (rs, rowNum) -> {
		FeedbackSubmission sub = new FeedbackSubmission();
		sub.setId(rs.getInt("id"));
		sub.setUserId(rs.getInt("user_id"));
		sub.setUsername(rs.getString("username"));
		sub.setSubject(rs.getString("subject"));
		sub.setDisplayTitle(rs.getString("display_title"));
		sub.setContent(rs.getString("content"));
		sub.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		sub.setStatus(rs.getString("status"));
		sub.setDisplayOrder(rs.getInt("display_order"));
		return sub;
	};

	public boolean createSubmission(FeedbackSubmission submission) {
		String sql = "INSERT INTO feedback_submissions (user_id, subject, content) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, submission.getUserId(), submission.getSubject(),
					submission.getContent()) > 0;
		} catch (Exception e) {
			logger.error("Error creating feedback submission for user {}", submission.getUserId(), e);
			return false;
		}
	}

	public List<FeedbackSubmission> getAllSubmissions() {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id ORDER BY FIELD(fs.status, 'NEW', 'VIEWED', 'PLANNED', 'REJECTED', 'COMPLETED'), fs.display_order ASC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all feedback submissions", e);
			return List.of();
		}
	}

	public FeedbackSubmission getSubmissionById(int submissionId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, submissionRowMapper, submissionId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback submission by ID {}", submissionId, e);
			return null;
		}
	}

	public List<FeedbackSubmission> getSubmissionsByUserId(int userId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.user_id = ? ORDER BY fs.submitted_at DESC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching feedback submissions for user {}", userId, e);
			return List.of();
		}
	}

	public boolean updateStatusAndTitle(int submissionId, String newStatus, String displayTitle) {
		String sql = "UPDATE feedback_submissions SET status = ?, display_title = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, newStatus, displayTitle, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status and title for submission {}", submissionId, e);
			return false;
		}
	}

	public boolean deleteSubmission(int submissionId) {
		String sql = "DELETE FROM feedback_submissions WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting submission {}", submissionId, e);
			return false;
		}
	}

}
========================================================================
FILE: src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FileDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<File> fileRowMapper = (rs, rowNum) -> {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getObject("category_id", Integer.class));
		file.setNeedsWarning(rs.getBoolean("needs_warning"));
		file.setRequiredRole(rs.getString("required_role"));

		String categoryName = rs.getString("fc_category_name");
		file.setCategoryName(categoryName != null ? categoryName : "Ohne Kategorie");

		logger.trace("Mapped file: ID={}, Name={}, CategoryID={}, CategoryName={}", file.getId(), file.getFilename(),
				file.getCategoryId(), file.getCategoryName());
		return file;
	};

	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		logger.debug("Grouping all files by category for user: {}",
				user != null ? user.getUsername() : "SYSTEM (Admin Context)");
		List<File> files = (user != null && user.hasAdminAccess()) ? getAllFilesForAdmin() : getAllFiles(user);

		Map<String, List<File>> groupedFiles = files.stream()
				.filter(file -> file.getFilepath() == null
						|| (!file.getFilepath().startsWith("chat/") && !file.getFilepath().startsWith("eventchat/")))
				.collect(Collectors.groupingBy(File::getCategoryName));

		if (logger.isTraceEnabled()) {
			groupedFiles.forEach((category, fileList) -> logger.trace("Category '{}' contains {} files: {}", category,
					fileList.size(), fileList.stream().map(File::getFilename).collect(Collectors.joining(", "))));
		}
		return groupedFiles;
	}

	public List<File> getAllFiles(User user) {
		StringBuilder sql = new StringBuilder("SELECT f.id, f.filename, f.filepath, f.uploaded_at, f.category_id, "
				+ "f.needs_warning, f.required_role, " + "fc.name AS fc_category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id ");

		if (user != null && !user.hasAdminAccess()) {
			sql.append("WHERE f.required_role = 'NUTZER' ");
		}

		sql.append("ORDER BY CASE WHEN fc.name IS NULL THEN 1 ELSE 0 END, fc.name, f.filename");
		logger.debug("Executing getAllFiles SQL for user '{}': {}", user != null ? user.getUsername() : "SYSTEM", sql);

		try {
			List<File> files = jdbcTemplate.query(sql.toString(), fileRowMapper);
			logger.debug("Fetched {} total file records from database.", files.size());
			return files;
		} catch (Exception e) {
			logger.error("Error while fetching files.", e);
			return List.of();
		}
	}

	public List<File> getAllFilesForAdmin() {
		String sql = "SELECT f.id, f.filename, f.filepath, f.uploaded_at, f.category_id, "
				+ "f.needs_warning, f.required_role, " + "fc.name AS fc_category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id "
				+ "ORDER BY CASE WHEN fc.name IS NULL THEN 1 ELSE 0 END, fc.name, f.filename";
		logger.debug("Executing getAllFilesForAdmin SQL.");
		try {
			List<File> files = jdbcTemplate.query(sql, fileRowMapper);
			logger.debug("Fetched {} total file records for admin view.", files.size());
			return files;
		} catch (Exception e) {
			logger.error("Error while fetching all files for admin.", e);
			return List.of();
		}
	}

	public int createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role, needs_warning) VALUES (?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, file.getFilename());
				ps.setString(2, file.getFilepath());
				if (file.getCategoryId() != null && file.getCategoryId() > 0) {
					ps.setInt(3, file.getCategoryId());
				} else {
					ps.setNull(3, Types.INTEGER);
				}
				ps.setString(4, file.getRequiredRole());
				ps.setBoolean(5, file.isNeedsWarning());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating file record for '{}'", file.getFilename(), e);
			return 0;
		}
	}

	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	public boolean reassignFileToCategory(int fileId, int categoryId) {
		String sql = "UPDATE files SET category_id = ? WHERE id = ?";
		try {
			Object newCategoryId = categoryId > 0 ? categoryId : null;
			return jdbcTemplate.update(sql, newCategoryId, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error reassigning file {} to category {}", fileId, categoryId, e);
			return false;
		}
	}

	public List<FileCategory> getAllCategories() {
		String sql = "SELECT * FROM file_categories ORDER BY name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				return cat;
			});
		} catch (Exception e) {
			logger.error("Error fetching file categories.", e);
			return List.of();
		}
	}

	public File getFileById(int fileId) {
		String sql = "SELECT f.id, f.filename, f.filepath, f.uploaded_at, f.category_id, "
				+ "f.needs_warning, f.required_role, " + "fc.name AS fc_category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id WHERE f.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, fileRowMapper, fileId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error while fetching file with ID: {}", fileId, e);
			return null;
		}
	}

	public boolean deleteFile(int fileId) {
		String sql = "DELETE FROM files WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	public boolean createCategory(String categoryName) {
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try {
			return jdbcTemplate.update(sql, categoryName) > 0;
		} catch (Exception e) {
			logger.error("Error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	public boolean deleteCategory(int categoryId) {
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try {
			jdbcTemplate.update("UPDATE files SET category_id = NULL WHERE category_id = ?", categoryId);
			return jdbcTemplate.update(sql, categoryId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, String.class, categoryId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
			return null;
		}
	}
}

========================================================================
FILE: src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public InventoryKitDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<InventoryKit> kitRowMapper = (rs, rowNum) -> {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>());
		return kit;
	};

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, kit.getName());
				ps.setString(2, kit.getDescription());
				ps.setString(3, kit.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
			return 0;
		}
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, kit.getName(), kit.getDescription(), kit.getLocation(), kit.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, kitRowMapper, kitId);
		} catch (EmptyResultDataAccessException e) {
			return null; // Expected case when not found
		} catch (Exception e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
			return null;
		}
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try {
			// First, delete dependencies in the linking table
			jdbcTemplate.update("DELETE FROM inventory_kit_items WHERE kit_id = ?", kitId);
			// Then, delete the kit itself
			return jdbcTemplate.update(sql, kitId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, ki.item_id, ki.quantity, si.name as item_name FROM inventory_kits k LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id LEFT JOIN storage_items si ON ki.item_id = si.id ORDER BY k.name, si.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int kitId = rs.getInt("id");
			InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
				try {
					return kitRowMapper.mapRow(rs, 0);
				} catch (SQLException e) {
					// This is a safe way to handle checked exceptions within a lambda
					throw new RuntimeException("Failed to map ResultSet to InventoryKit", e);
				}
			});
			if (rs.getInt("item_id") > 0) {
				InventoryKitItem item = new InventoryKitItem();
				item.setKitId(kitId);
				item.setItemId(rs.getInt("item_id"));
				item.setQuantity(rs.getInt("quantity"));
				item.setItemName(rs.getString("item_name"));
				kit.getItems().add(item);
			}
		});
		return new ArrayList<>(kitMap.values());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MaintenanceLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, log.getItemId(), log.getUserId(), log.getAction(), log.getNotes(),
					log.getCost()) > 0;
		} catch (Exception e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml JOIN users u ON ml.user_id = u.id WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MaintenanceLogEntry entry = new MaintenanceLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
				entry.setAction(rs.getString("action"));
				entry.setNotes(rs.getString("notes"));
				entry.setCost(rs.getDouble("cost"));
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingAttendanceDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";
		try {
			jdbcTemplate.update(sql, userId, meetingId, attended, remarks);
			return true;
		} catch (Exception e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	public List<MeetingAttendance> getAllAttendance() {
		String sql = "SELECT * FROM meeting_attendance";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MeetingAttendance attendance = new MeetingAttendance();
				attendance.setUserId(rs.getInt("user_id"));
				attendance.setMeetingId(rs.getInt("meeting_id"));
				attendance.setAttended(rs.getBoolean("attended"));
				attendance.setRemarks(rs.getString("remarks"));
				return attendance;
			});
		} catch (Exception e) {
			logger.error("SQL error fetching all attendance records.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Meeting> meetingRowMapper = (rs, rowNum) -> {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null)
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));
		return meeting;
	};

	private final RowMapper<User> userRowMapper = (rs, rowNum) -> {
		User user = new User();
		user.setId(rs.getInt("id"));
		user.setUsername(rs.getString("username"));
		return user;
	};

	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, meeting.getCourseId());
				ps.setString(2, meeting.getName());
				ps.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
				if (meeting.getEndDateTime() != null)
					ps.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
				else
					ps.setNull(4, Types.TIMESTAMP);
				if (meeting.getLeaderUserId() > 0)
					ps.setInt(5, meeting.getLeaderUserId());
				else
					ps.setNull(5, Types.INTEGER);
				ps.setString(6, meeting.getDescription());
				ps.setString(7, meeting.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating meeting: {}", meeting.getName(), e);
			return 0;
		}
	}

	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, meetingRowMapper, meetingId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching meeting by ID: {}", meetingId, e);
			return null;
		}
	}

	public List<Meeting> getMeetingsForCourse(int courseId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, courseId);
		} catch (Exception e) {
			logger.error("Error fetching meetings for course ID: {}", courseId, e);
			return List.of();
		}
	}

	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, meeting.getName(), Timestamp.valueOf(meeting.getMeetingDateTime()),
					meeting.getEndDateTime() != null ? Timestamp.valueOf(meeting.getEndDateTime()) : null,
					meeting.getLeaderUserId() > 0 ? meeting.getLeaderUserId() : null, meeting.getDescription(),
					meeting.getLocation(), meeting.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		try {
			jdbcTemplate.update("DELETE FROM meeting_attendance WHERE meeting_id = ?", meetingId);
			return jdbcTemplate.update(sql, meetingId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Meeting meeting = meetingRowMapper.mapRow(rs, rowNum);
				if (rs.getObject("attended") != null) {
					meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
				} else {
					meeting.setUserAttendanceStatus("OFFEN");
				}
				return meeting;
			}, user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for user {}", user.getId(), e);
			return List.of();
		}
	}

	public List<Meeting> getAllUpcomingMeetings() {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
		String sql = "SELECT COUNT(*) FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, meetingId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
			return false;
		}
	}

	public List<Meeting> search(String query) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.name LIKE ? OR m.description LIKE ? OR c.name LIKE ? ORDER BY m.meeting_datetime DESC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching meetings for query '{}'", query, e);
			return List.of();
		}
	}

	public List<User> getParticipantUsersForMeeting(int meetingId) {
		String sql = "SELECT u.id, u.username FROM users u JOIN meeting_attendance ma ON u.id = ma.user_id WHERE ma.meeting_id = ? AND ma.attended = 1";
		try {
			return jdbcTemplate.query(sql, userRowMapper, meetingId);
		} catch (Exception e) {
			logger.error("Error fetching participant users for meeting {}", meetingId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PageDocumentationDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.PageDocumentation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class PageDocumentationDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PageDocumentationDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<PageDocumentation> rowMapper = (rs, rowNum) -> {
		PageDocumentation doc = new PageDocumentation();
		doc.setId(rs.getInt("id"));
		doc.setPageKey(rs.getString("page_key"));
		doc.setTitle(rs.getString("title"));
		doc.setPagePath(rs.getString("page_path"));
		doc.setFeatures(rs.getString("features"));
		doc.setRelatedPages(rs.getString("related_pages"));
		doc.setAdminOnly(rs.getBoolean("admin_only"));
		doc.setWikiEntryId(rs.getObject("wiki_entry_id", Integer.class));
		doc.setCategory(rs.getString("category"));
		doc.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		doc.setUpdatedAt(rs.getTimestamp("updated_at").toLocalDateTime());
		return doc;
	};

	public List<PageDocumentation> findAll(boolean isAdmin) {
		String sql = "SELECT * FROM page_documentation";
		if (!isAdmin) {
			sql += " WHERE admin_only = FALSE";
		}
		sql += " ORDER BY category, title ASC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<PageDocumentation> findById(int id) {
		String sql = "SELECT * FROM page_documentation WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public Optional<PageDocumentation> findByKey(String pageKey) {
		String sql = "SELECT * FROM page_documentation WHERE page_key = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, pageKey));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public PageDocumentation create(PageDocumentation doc) {
		String sql = "INSERT INTO page_documentation (page_key, title, page_path, features, related_pages, admin_only, wiki_entry_id, category) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, doc.getPageKey());
			ps.setString(2, doc.getTitle());
			ps.setString(3, doc.getPagePath());
			ps.setString(4, doc.getFeatures());
			ps.setString(5, doc.getRelatedPages());
			ps.setBoolean(6, doc.isAdminOnly());
			if (doc.getWikiEntryId() != null) {
				ps.setInt(7, doc.getWikiEntryId());
			} else {
				ps.setNull(7, Types.INTEGER);
			}
			ps.setString(8, doc.getCategory());
			return ps;
		}, keyHolder);
		doc.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
		return doc;
	}

	public PageDocumentation update(PageDocumentation doc) {
		String sql = "UPDATE page_documentation SET title = ?, page_path = ?, features = ?, related_pages = ?, admin_only = ?, wiki_entry_id = ?, category = ? WHERE id = ?";
		jdbcTemplate.update(sql, doc.getTitle(), doc.getPagePath(), doc.getFeatures(), doc.getRelatedPages(),
				doc.isAdminOnly(), doc.getWikiEntryId(), doc.getCategory(), doc.getId());
		return doc;
	}

	public boolean delete(int id) {
		return jdbcTemplate.update("DELETE FROM page_documentation WHERE id = ?", id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Repository
public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PermissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Permission> getAllPermissions() {
		String sql = "SELECT * FROM permissions ORDER BY description";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				return p;
			});
		} catch (Exception e) {
			logger.error("Error fetching all permissions", e);
			return List.of();
		}
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try {
			List<Integer> ids = jdbcTemplate.queryForList(sql, Integer.class, userId);
			return new HashSet<>(ids);
		} catch (Exception e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
			return Set.of();
		}
	}

	public Integer getPermissionIdByKey(String key) {
		String sql = "SELECT id FROM permissions WHERE permission_key = ?";
		try {
			return jdbcTemplate.queryForObject(sql, Integer.class, key);
		} catch (EmptyResultDataAccessException e) {
			logger.warn("Could not find permission with key: {}", key);
			return null;
		} catch (Exception e) {
			logger.error("Error fetching permission ID for key {}", key, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ProfileChangeRequestDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ProfileChangeRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ProfileChangeRequestDAO {
	private static final Logger logger = LogManager.getLogger(ProfileChangeRequestDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ProfileChangeRequestDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ProfileChangeRequest> requestRowMapper = (rs, rowNum) -> {
		ProfileChangeRequest request = new ProfileChangeRequest();
		request.setId(rs.getInt("id"));
		request.setUserId(rs.getInt("user_id"));
		request.setRequestedChanges(rs.getString("requested_changes"));
		request.setStatus(rs.getString("status"));
		request.setRequestedAt(rs.getTimestamp("requested_at").toLocalDateTime());
		request.setUsername(rs.getString("username"));
		if (rs.getObject("reviewed_by_admin_id") != null) {
			request.setReviewedByAdminId(rs.getInt("reviewed_by_admin_id"));
		}
		if (rs.getTimestamp("reviewed_at") != null) {
			request.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		if (rs.getMetaData().getColumnCount() > 8) { // Simple check if admin_username is present
			request.setReviewedByAdminName(rs.getString("admin_username"));
		}
		return request;
	};

	public boolean createRequest(ProfileChangeRequest request) {
		String sql = "INSERT INTO profile_change_requests (user_id, requested_changes, status) VALUES (?, ?, 'PENDING')";
		try {
			return jdbcTemplate.update(sql, request.getUserId(), request.getRequestedChanges()) > 0;
		} catch (Exception e) {
			logger.error("Error creating profile change request for user {}", request.getUserId(), e);
			return false;
		}
	}

	public ProfileChangeRequest getRequestById(int id) {
		String sql = "SELECT pcr.*, u.username as username, a.username as admin_username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id LEFT JOIN users a ON pcr.reviewed_by_admin_id = a.id WHERE pcr.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, requestRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching request by ID {}", id, e);
			return null;
		}
	}

	public List<ProfileChangeRequest> getPendingRequests() {
		String sql = "SELECT pcr.*, u.username as username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id WHERE pcr.status = 'PENDING' ORDER BY pcr.requested_at ASC";
		try {
			return jdbcTemplate.query(sql, requestRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching pending requests", e);
			return List.of();
		}
	}

	public boolean hasPendingRequest(int userId) {
		String sql = "SELECT COUNT(*) FROM profile_change_requests WHERE user_id = ? AND status = 'PENDING'";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for pending request for user {}", userId, e);
			return false;
		}
	}

	public boolean updateRequestStatus(int requestId, String status, int adminId) {
		String sql = "UPDATE profile_change_requests SET status = ?, reviewed_by_admin_id = ?, reviewed_at = NOW() WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, status, adminId, requestId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status for request {}", requestId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Map<String, Object>> getEventParticipationSummary() {
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating event participation summary.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserActivityStats() {
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating user activity stats.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating inventory usage frequency report.", e);
			return List.of();
		}
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		try {
			Double totalValue = jdbcTemplate.queryForObject(sql, Double.class);
			return totalValue != null ? totalValue : 0.0;
		} catch (Exception e) {
			logger.error("Error calculating total inventory value.", e);
			return 0.0;
		}
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		String sql = "SELECT DATE_FORMAT(event_datetime, '%Y-%m') AS month, COUNT(*) AS count " + "FROM events "
				+ "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), months);
		} catch (Exception e) {
			logger.error("Error generating event count by month report.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), limit);
		} catch (Exception e) {
			logger.error("Error generating user participation stats.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.concurrent.TimeUnit;

@Repository
public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);
	private final JdbcTemplate jdbcTemplate;
	private final LoadingCache<String, List<Role>> roleCache;
	private static final String ALL_ROLES_KEY = "ALL_ROLES";

	@Autowired
	public RoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.roleCache = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.HOURS).maximumSize(1)
				.build(key -> fetchAllRolesFromDb());
	}

	public List<Role> getAllRoles() {
		logger.debug("Fetching all roles from cache.");
		return roleCache.get(ALL_ROLES_KEY);
	}

	private List<Role> fetchAllRolesFromDb() {
		logger.info("Cache miss for roles. Fetching all roles from database.");
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				return role;
			});
		} catch (Exception e) {
			logger.error("Error fetching all roles from DB", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ScheduledNotificationDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ScheduledNotification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public class ScheduledNotificationDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ScheduledNotificationDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createOrUpdateReminder(String type, int entityId, List<Integer> userIds, LocalDateTime sendAt,
			String title, String description, String url) {
		// First, delete any existing reminders for this entity to prevent duplicates
		deleteReminders(type, entityId);

		// If a valid send time and user list are provided, create new reminders
		if (sendAt != null && userIds != null && !userIds.isEmpty()) {
			String sql = "INSERT INTO scheduled_notifications (target_user_id, notification_type, related_entity_id, send_at, title, description, url) VALUES (?, ?, ?, ?, ?, ?, ?)";
			jdbcTemplate.batchUpdate(sql, userIds, 100, (ps, userId) -> {
				ps.setInt(1, userId);
				ps.setString(2, type);
				ps.setInt(3, entityId);
				ps.setTimestamp(4, Timestamp.valueOf(sendAt));
				ps.setString(5, title);
				ps.setString(6, description);
				ps.setString(7, url);
			});
		}
	}

	public void deleteReminders(String type, int entityId) {
		String sql = "DELETE FROM scheduled_notifications WHERE notification_type = ? AND related_entity_id = ?";
		jdbcTemplate.update(sql, type, entityId);
	}

	public List<ScheduledNotification> findPendingNotifications() {
		String sql = "SELECT * FROM scheduled_notifications WHERE status = 'PENDING' AND send_at <= NOW()";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			ScheduledNotification n = new ScheduledNotification();
			n.setId(rs.getInt("id"));
			n.setTargetUserId(rs.getInt("target_user_id"));
			n.setTitle(rs.getString("title"));
			n.setDescription(rs.getString("description"));
			n.setUrl(rs.getString("url"));
			return n;
		});
	}

	public void markAsSent(List<Integer> ids) {
		if (ids.isEmpty())
			return;
		String sql = "UPDATE scheduled_notifications SET status = 'SENT' WHERE id IN ("
				+ ids.stream().map(String::valueOf).collect(java.util.stream.Collectors.joining(",")) + ")";
		jdbcTemplate.update(sql);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StatisticsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int getUserCount() {
		return getCount("SELECT COUNT(*) FROM users");
	}

	public int getActiveEventCount() {
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	private int getCount(String sql) {
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
			return count != null ? count : 0;
		} catch (Exception e) {
			logger.error("SQL error executing count query: {}", sql, e);
			return 0;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Repository
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<StorageItem> storageItemRowMapper = (rs, rowNum) -> {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setCategory(rs.getString("category"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	};

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream()
				.collect(Collectors.groupingBy(
						item -> item.getLocation() != null && !item.getLocation().isBlank() ? item.getLocation().trim()
								: "Unbekannt"));
	}

	public List<StorageItem> getAllItems() {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id ORDER BY si.location, si.name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all storage items.", e);
			return List.of();
		}
	}

	public List<StorageItem> getDefectiveItems() {
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching defective items.", e);
			return List.of();
		}
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id WHERE si.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, storageItemRowMapper, itemId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching storage item by ID: {}", itemId, e);
			return null;
		}
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try {
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getWeightKg(),
					item.getPriceEur(), item.getImagePath()) > 0;
		} catch (Exception e) {
			logger.error("Error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try {
			Object holderId = item.getCurrentHolderUserId() > 0 ? item.getCurrentHolderUserId() : null;
			Object eventId = item.getAssignedEventId() > 0 ? item.getAssignedEventId() : null;
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getDefectiveQuantity(),
					item.getDefectReason(), item.getWeightKg(), item.getPriceEur(), item.getImagePath(),
					item.getStatus(), holderId, eventId, item.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, itemId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public List<StorageItem> getLowStockItems(int limit) {
		String sql = "SELECT * FROM storage_items WHERE (quantity - defective_quantity) < (max_quantity * 0.25) AND max_quantity > 0 ORDER BY (quantity - defective_quantity) / max_quantity ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error while fetching low stock items.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getFutureReservationsForItem(int itemId) {
		String sql = "SELECT e.name as event_name, e.event_datetime, e.end_datetime "
				+ "FROM event_storage_reservations esr " + "JOIN events e ON esr.event_id = e.id "
				+ "WHERE esr.item_id = ? AND e.status IN ('GEPLANT', 'LAUFEND') AND e.event_datetime >= NOW() "
				+ "ORDER BY e.event_datetime ASC";
		try {
			return jdbcTemplate.queryForList(sql, itemId);
		} catch (Exception e) {
			logger.error("Error fetching future reservations for item {}", itemId, e);
			return List.of();
		}
	}

	public List<StorageItem> search(String query) {
		String sql = "SELECT * FROM storage_items WHERE name LIKE ? OR location LIKE ? OR cabinet LIKE ? OR compartment LIKE ? ORDER BY name ASC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, searchTerm, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching storage items for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageItemRelationDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class StorageItemRelationDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageItemRelationDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<StorageItem> itemMapper = (rs, rowNum) -> {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setQuantity(rs.getInt("quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		return item;
	};

	public List<StorageItem> findRelatedItems(int itemId) {
		String sql = "SELECT si.* FROM storage_items si JOIN storage_item_relations sir ON si.id = sir.related_item_id WHERE sir.item_id = ?";
		return jdbcTemplate.query(sql, itemMapper, itemId);
	}

	public void updateRelations(int itemId, List<Integer> relatedItemIds) {
		jdbcTemplate.update("DELETE FROM storage_item_relations WHERE item_id = ?", itemId);

		if (relatedItemIds != null && !relatedItemIds.isEmpty()) {
			String sql = "INSERT INTO storage_item_relations (item_id, related_item_id) VALUES (?, ?)";
			jdbcTemplate.batchUpdate(sql, relatedItemIds, 100, (ps, relatedId) -> {
				ps.setInt(1, itemId);
				ps.setInt(2, relatedId);
			});
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;

@Repository
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		try {
			Object eventIdObj = eventId > 0 ? eventId : null;
			int[] types = { Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.VARCHAR, Types.INTEGER };
			return jdbcTemplate.update(sql, new Object[] { itemId, userId, quantityChange, notes, eventIdObj },
					types) > 0;
		} catch (Exception e) {
			logger.error("Error logging storage transaction for item {}", itemId, e);
			return false;
		}
	}

	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT sl.*, u.username FROM storage_log sl JOIN users u ON sl.user_id = u.id WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageLogEntry entry = new StorageLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setQuantityChange(rs.getInt("quantity_change"));
				entry.setNotes(rs.getString("notes"));
				entry.setEventId(rs.getInt("event_id"));
				entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\TodoDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Repository
public class TodoDAO {
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public TodoDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<TodoCategory> getAllCategoriesWithTasks() {
		Map<Integer, TodoCategory> categoryMap = new LinkedHashMap<>();
		String sql = "SELECT c.id as cat_id, c.name as cat_name, c.display_order as cat_order, "
				+ "t.id as task_id, t.category_id as task_cat_id, t.content as task_content, "
				+ "t.is_completed as task_completed, t.display_order as task_order "
				+ "FROM todo_categories c LEFT JOIN todo_tasks t ON c.id = t.category_id "
				+ "ORDER BY c.display_order, t.display_order";

		jdbcTemplate.query(sql, rs -> {
			int categoryId = rs.getInt("cat_id");
			TodoCategory category = categoryMap.computeIfAbsent(categoryId, id -> {
				try {
					TodoCategory newCat = new TodoCategory();
					newCat.setId(id);
					newCat.setName(rs.getString("cat_name"));
					newCat.setDisplayOrder(rs.getInt("cat_order"));
					return newCat;
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			});

			if (rs.getObject("task_id") != null) {
				TodoTask task = new TodoTask();
				task.setId(rs.getInt("task_id"));
				task.setCategoryId(rs.getInt("task_cat_id"));
				task.setContent(rs.getString("task_content"));
				task.setCompleted(rs.getBoolean("task_completed"));
				task.setDisplayOrder(rs.getInt("task_order"));
				category.getTasks().add(task);
			}
		});
		return new ArrayList<>(categoryMap.values());
	}

	public TodoCategory createCategory(String name) {
		String sql = "INSERT INTO todo_categories (name, display_order) "
				+ "SELECT ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_categories";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoCategory newCategory = new TodoCategory();
		newCategory.setId(newId);
		newCategory.setName(name);
		return newCategory;
	}

	public TodoTask createTask(int categoryId, String content) {
		String sql = "INSERT INTO todo_tasks (category_id, content, display_order) "
				+ "SELECT ?, ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_tasks WHERE category_id = ?";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, categoryId);
			ps.setString(2, content);
			ps.setInt(3, categoryId);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoTask newTask = new TodoTask();
		newTask.setId(newId);
		newTask.setCategoryId(categoryId);
		newTask.setContent(content);
		return newTask;
	}

	public boolean updateTaskContent(int taskId, String content) {
		String sql = "UPDATE todo_tasks SET content = ? WHERE id = ?";
		return jdbcTemplate.update(sql, content, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, boolean isCompleted) {
		String sql = "UPDATE todo_tasks SET is_completed = ? WHERE id = ?";
		return jdbcTemplate.update(sql, isCompleted, taskId) > 0;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM todo_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean deleteCategory(int categoryId) {
		jdbcTemplate.update("DELETE FROM todo_tasks WHERE category_id = ?", categoryId);
		String sql = "DELETE FROM todo_categories WHERE id = ?";
		return jdbcTemplate.update(sql, categoryId) > 0;
	}

	public void updateCategoryOrder(List<Integer> categoryIds) {
		String sql = "UPDATE todo_categories SET display_order = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, categoryIds, 100, (ps, categoryId) -> {
			ps.setInt(1, categoryIds.indexOf(categoryId));
			ps.setInt(2, categoryId);
		});
	}

	public void updateTaskOrders(List<Integer> taskIds, int categoryId) {
		String sql = "UPDATE todo_tasks SET display_order = ?, category_id = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, taskIds, 100, (ps, taskId) -> {
			ps.setInt(1, taskIds.indexOf(taskId));
			ps.setInt(2, categoryId);
			ps.setInt(3, taskId);
		});
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\TrainingRequestDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.TrainingRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class TrainingRequestDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public TrainingRequestDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<TrainingRequest> rowMapper = (rs, rowNum) -> {
		TrainingRequest request = new TrainingRequest();
		request.setId(rs.getInt("id"));
		request.setTopic(rs.getString("topic"));
		request.setRequesterUserId(rs.getInt("requester_user_id"));
		request.setRequesterUsername(rs.getString("requester_username"));
		request.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		if (rs.getMetaData().getColumnCount() > 5) { // Check if interest_count is present
			request.setInterestCount(rs.getInt("interest_count"));
		}
		return request;
	};

	public Optional<TrainingRequest> findById(int id) {
		String sql = "SELECT tr.*, u.username as requester_username, "
				+ "(SELECT COUNT(*) FROM training_request_interest WHERE request_id = tr.id) as interest_count "
				+ "FROM training_requests tr JOIN users u ON tr.requester_user_id = u.id WHERE tr.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public List<TrainingRequest> findAllWithInterestCount() {
		String sql = "SELECT tr.*, u.username as requester_username, "
				+ "(SELECT COUNT(*) FROM training_request_interest WHERE request_id = tr.id) as interest_count "
				+ "FROM training_requests tr JOIN users u ON tr.requester_user_id = u.id ORDER BY interest_count DESC, tr.created_at DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public TrainingRequest create(String topic, int requesterUserId) {
		String sql = "INSERT INTO training_requests (topic, requester_user_id) VALUES (?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, topic);
			ps.setInt(2, requesterUserId);
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		return findById(newId).orElse(null);
	}

	public boolean delete(int id) {
		return jdbcTemplate.update("DELETE FROM training_requests WHERE id = ?", id) > 0;
	}

	public boolean addInterest(int requestId, int userId) {
		try {
			return jdbcTemplate.update("INSERT INTO training_request_interest (request_id, user_id) VALUES (?, ?)",
					requestId, userId) > 0;
		} catch (DuplicateKeyException e) {
			// User has already registered interest, which is not an error state.
			return true;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<User> userRowMapper = (resultSet, rowNum) -> {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		user.setPasswordHash(resultSet.getString("password_hash"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "profile_icon_class")) {
			user.setProfileIconClass(resultSet.getString("profile_icon_class"));
		}
		if (DaoUtils.hasColumn(resultSet, "admin_notes")) {
			user.setAdminNotes(resultSet.getString("admin_notes"));
		}
		if (DaoUtils.hasColumn(resultSet, "dashboard_layout")) {
			user.setDashboardLayout(resultSet.getString("dashboard_layout"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	};

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, this.userRowMapper, username);
			String storedHash = user.getPasswordHash();

			if (storedHash != null && passwordEncoder.matches(password, storedHash)) {
				user.setPermissions(getPermissionsForUser(user.getId()));
				return user;
			}
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, username);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(user.getId()));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by username: {}", username, e);
			return null;
		}
	}

	public Set<String> getPermissionsForUser(int userId) {
		String sql = "SELECT p.permission_key FROM permissions p "
				+ "JOIN user_permissions up ON p.id = up.permission_id " + "WHERE up.user_id = ?";
		try {
			List<String> permissionKeys = jdbcTemplate.queryForList(sql, String.class, userId);
			return new HashSet<>(permissionKeys);
		} catch (Exception e) {
			logger.error("Error fetching permissions for user {}", userId, e);
			return Set.of();
		}
	}

	@Transactional
	public boolean updateUserPermissions(int userId, String[] permissionIds) {
		jdbcTemplate.update("DELETE FROM user_permissions WHERE user_id = ?", userId);
		if (permissionIds != null && permissionIds.length > 0) {
			List<Object[]> batchArgs = Arrays.stream(permissionIds)
					.map(idStr -> new Object[] { userId, Integer.parseInt(idStr) }).collect(Collectors.toList());
			jdbcTemplate.batchUpdate("INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)", batchArgs);
		}
		return true;
	}

	public int createUser(User user, String password) {
		String hashedPassword = passwordEncoder.encode(password);
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, user.getUsername());
				ps.setString(2, hashedPassword);
				ps.setInt(3, user.getRoleId());
				ps.setInt(4, user.getClassYear());
				ps.setString(5, user.getClassName());
				// Treat empty string as NULL to avoid unique constraint violation
				if (user.getEmail() != null && !user.getEmail().isEmpty()) {
					ps.setString(6, user.getEmail());
				} else {
					ps.setNull(6, Types.VARCHAR);
				}
				ps.setString(7, "light");
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating user {}", user.getUsername(), e);
			return 0;
		}
	}

	public boolean updateUser(User user) {
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ?, profile_icon_class = ?, admin_notes = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, user.getUsername(), user.getRoleId(), user.getClassYear(),
					user.getClassName(), user.getEmail(), user.getProfileIconClass(), user.getAdminNotes(),
					user.getId()) > 0;
		} catch (Exception e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, theme, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating theme for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, chatColor, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating chat color for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateDashboardLayout(int userId, String layoutJson) {
		String sql = "UPDATE users SET dashboard_layout = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, layoutJson, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating dashboard layout for user ID {}", userId, e);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, hashedPassword, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}

	public List<User> getAllUsers() {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		try {
			return jdbcTemplate.query(sql, userRowMapper);
		} catch (Exception e) {
			logger.error("SQL error fetching all users", e);
			return List.of();
		}
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, userId);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(userId));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by ID with permissions: {}", userId, e);
			return null;
		}
	}

	public List<Integer> findUserIdsByPermission(String permissionKey) {
		String sql = "SELECT up.user_id FROM user_permissions up JOIN permissions p ON up.permission_id = p.id WHERE p.permission_key = ?";
		try {
			return jdbcTemplate.queryForList(sql, Integer.class, permissionKey);
		} catch (Exception e) {
			logger.error("Error fetching user IDs by permission key '{}'", permissionKey, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.UserQualification;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.List;

@Repository
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserQualificationsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private UserQualification mapResultSetToUserQualification(ResultSet rs, int rowNum) throws SQLException {
		UserQualification uq = new UserQualification();
		if (DaoUtils.hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	public List<UserQualification> getQualificationsForUser(int userId) {
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id WHERE uq.user_id = ?";
		try {
			return jdbcTemplate.query(sql, this::mapResultSetToUserQualification, userId);
		} catch (Exception e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
			return List.of();
		}
	}

	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try {
				jdbcTemplate.update(deleteSql, userId, courseId);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try {
				jdbcTemplate.update(upsertSql, userId, courseId, status, completionDate, remarks);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\VenueDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Venue;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class VenueDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public VenueDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Venue> venueRowMapper = (rs, rowNum) -> {
		Venue venue = new Venue();
		venue.setId(rs.getInt("id"));
		venue.setName(rs.getString("name"));
		venue.setAddress(rs.getString("address"));
		venue.setNotes(rs.getString("notes"));
		venue.setMapImagePath(rs.getString("map_image_path"));
		venue.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return venue;
	};

	public List<Venue> findAll() {
		String sql = "SELECT * FROM venues ORDER BY name ASC";
		return jdbcTemplate.query(sql, venueRowMapper);
	}

	public Optional<Venue> findById(int id) {
		String sql = "SELECT * FROM venues WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, venueRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public Venue create(Venue venue) {
		String sql = "INSERT INTO venues (name, address, notes, map_image_path) VALUES (?, ?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, venue.getName());
			ps.setString(2, venue.getAddress());
			ps.setString(3, venue.getNotes());
			ps.setString(4, venue.getMapImagePath());
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		venue.setId(newId);
		return venue;
	}

	public boolean update(Venue venue) {
		String sql = "UPDATE venues SET name = ?, address = ?, notes = ?, map_image_path = ? WHERE id = ?";
		return jdbcTemplate.update(sql, venue.getName(), venue.getAddress(), venue.getNotes(), venue.getMapImagePath(),
				venue.getId()) > 0;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM venues WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\WikiDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class WikiDAO {
	private static final Logger logger = LogManager.getLogger(WikiDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public WikiDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<WikiEntry> wikiEntryRowMapper = (rs, rowNum) -> {
		WikiEntry entry = new WikiEntry();
		entry.setId(rs.getInt("id"));
		entry.setFilePath(rs.getString("file_path"));
		entry.setContent(rs.getString("content"));
		return entry;
	};

	public Optional<WikiEntry> getWikiEntryById(int id) {
		String sql = "SELECT * FROM wiki_documentation WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by ID {}", id, e);
			return Optional.empty();
		}
	}

	public Optional<WikiEntry> findByFilePath(String filePath) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, filePath));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by file_path {}", filePath, e);
			return Optional.empty();
		}
	}

	public List<WikiEntry> getAllWikiEntries() {
		String sql = "SELECT * FROM wiki_documentation ORDER BY file_path";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all wiki entries", e);
			return List.of();
		}
	}

	public boolean updateWikiContent(int id, String content) {
		String sql = "UPDATE wiki_documentation SET content = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, content, id) > 0;
		} catch (Exception e) {
			logger.error("Error updating wiki content for ID {}", id, e);
			return false;
		}
	}

	public Optional<WikiEntry> createWikiEntry(WikiEntry entry) {
		String sql = "INSERT INTO wiki_documentation (file_path, content) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, entry.getFilePath());
				ps.setString(2, entry.getContent());
				return ps;
			}, keyHolder);
			entry.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
			return Optional.of(entry);
		} catch (Exception e) {
			logger.error("Error creating wiki entry for path {}", entry.getFilePath(), e);
			return Optional.empty();
		}
	}

	public boolean deleteWikiEntry(int id) {
		String sql = "DELETE FROM wiki_documentation WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting wiki entry with ID {}", id, e);
			return false;
		}
	}

	public List<WikiEntry> search(String query) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path LIKE ? OR content LIKE ? ORDER BY file_path ASC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching wiki entries for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Announcement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class Announcement {
	private int id;
	private String title;
	private String content;
	private int authorUserId;
	private String authorUsername; // Transient
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public int getAuthorUserId() {
		return authorUserId;
	}

	public void setAuthorUserId(int authorUserId) {
		this.authorUserId = authorUserId;
	}

	public String getAuthorUsername() {
		return authorUsername;
	}

	public void setAuthorUsername(String authorUsername) {
		this.authorUsername = authorUsername;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ApiResponse.java
========================================================================

package de.technikteam.model;

/**
 * A standard wrapper for all API responses. This object is returned by all
 * Actions and processed by the FrontControllerServlet. It contains a success
 * flag, a message, and a generic data payload.
 */
public class ApiResponse {

	private final boolean success;
	private final String message;
	private final Object data;

	public ApiResponse(boolean success, String message, Object data) {
		this.success = success;
		this.message = message;
		this.data = data;
	}

	public boolean isSuccess() {
		return success;
	}

	public String getMessage() {
		return message;
	}

	public Object getData() {
		return data;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; 
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Changelog.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;
import java.util.List;

public class Changelog {
	private int id;
	private String version;
	private LocalDate releaseDate;
	private String title;
	private String notes;
	private List<Integer> seenByUserIds; // Mapped from JSON

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getVersion() {
		return version;
	}

	public void setVersion(String version) {
		this.version = version;
	}

	public LocalDate getReleaseDate() {
		return releaseDate;
	}

	public void setReleaseDate(LocalDate releaseDate) {
		this.releaseDate = releaseDate;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public List<Integer> getSeenByUserIds() {
		return seenByUserIds;
	}

	public void setSeenByUserIds(List<Integer> seenByUserIds) {
		this.seenByUserIds = seenByUserIds;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChatConversation.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class ChatConversation {
	private int id;
	private boolean isGroupChat;
	private String name;
	private Integer creatorId;
	private LocalDateTime createdAt;

	// Transient fields for UI
	private int otherParticipantId;
	private String otherParticipantUsername;
	private String lastMessage;
	private LocalDateTime lastMessageTimestamp;
	private List<User> participants;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public boolean isGroupChat() {
		return isGroupChat;
	}

	public void setGroupChat(boolean groupChat) {
		isGroupChat = groupChat;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getCreatorId() {
		return creatorId;
	}

	public void setCreatorId(Integer creatorId) {
		this.creatorId = creatorId;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getOtherParticipantId() {
		return otherParticipantId;
	}

	public void setOtherParticipantId(int otherParticipantId) {
		this.otherParticipantId = otherParticipantId;
	}

	public String getOtherParticipantUsername() {
		return otherParticipantUsername;
	}

	public void setOtherParticipantUsername(String otherParticipantUsername) {
		this.otherParticipantUsername = otherParticipantUsername;
	}

	public String getLastMessage() {
		return lastMessage;
	}

	public void setLastMessage(String lastMessage) {
		this.lastMessage = lastMessage;
	}

	public LocalDateTime getLastMessageTimestamp() {
		return lastMessageTimestamp;
	}

	public void setLastMessageTimestamp(LocalDateTime lastMessageTimestamp) {
		this.lastMessageTimestamp = lastMessageTimestamp;
	}

	public List<User> getParticipants() {
		return participants;
	}

	public void setParticipants(List<User> participants) {
		this.participants = participants;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ChatMessage {
	private long id;
	private int conversationId;
	private int senderId;
	private String senderUsername;
	private String messageText;
	private String status; // SENT, DELIVERED, READ
	private LocalDateTime sentAt;
	private String chatColor;
	private boolean edited;
	private LocalDateTime editedAt;
	private boolean isDeleted;
	private LocalDateTime deletedAt;
	private Integer deletedByUserId;
	private String deletedByUsername; // Transient

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public int getConversationId() {
		return conversationId;
	}

	public void setConversationId(int conversationId) {
		this.conversationId = conversationId;
	}

	public int getSenderId() {
		return senderId;
	}

	public void setSenderId(int senderId) {
		this.senderId = senderId;
	}

	public String getSenderUsername() {
		return senderUsername;
	}

	public void setSenderUsername(String senderUsername) {
		this.senderUsername = senderUsername;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public LocalDateTime getEditedAt() {
		return editedAt;
	}

	public void setEditedAt(LocalDateTime editedAt) {
		this.editedAt = editedAt;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean deleted) {
		isDeleted = deleted;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public Integer getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(Integer deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistItem.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ChecklistItem {
	private int id;
	private int eventId;
	private int itemId;
	private String itemName;
	private int quantity;
	private String status;
	private Integer lastUpdatedByUserId;
	private String lastUpdatedByUsername;
	private LocalDateTime lastUpdatedAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Integer getLastUpdatedByUserId() {
		return lastUpdatedByUserId;
	}

	public void setLastUpdatedByUserId(Integer lastUpdatedByUserId) {
		this.lastUpdatedByUserId = lastUpdatedByUserId;
	}

	public String getLastUpdatedByUsername() {
		return lastUpdatedByUsername;
	}

	public void setLastUpdatedByUsername(String lastUpdatedByUsername) {
		this.lastUpdatedByUsername = lastUpdatedByUsername;
	}

	public LocalDateTime getLastUpdatedAt() {
		return lastUpdatedAt;
	}

	public void setLastUpdatedAt(LocalDateTime lastUpdatedAt) {
		this.lastUpdatedAt = lastUpdatedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistTemplate.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class ChecklistTemplate {
	private int id;
	private String name;
	private String description;
	private LocalDateTime createdAt;
	private List<ChecklistTemplateItem> items;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public List<ChecklistTemplateItem> getItems() {
		return items;
	}

	public void setItems(List<ChecklistTemplateItem> items) {
		this.items = items;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistTemplateItem.java
========================================================================

package de.technikteam.model;

public class ChecklistTemplateItem {
	private int id;
	private int templateId;
	private String itemText;
	private int displayOrder;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getTemplateId() {
		return templateId;
	}

	public void setTemplateId(int templateId) {
		this.templateId = templateId;
	}

	public String getItemText() {
		return itemText;
	}

	public void setItemText(String itemText) {
		this.itemText = itemText;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DamageReport.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class DamageReport {
	private int id;
	private int itemId;
	private int reporterUserId;
	private String reportDescription;
	private LocalDateTime reportedAt;
	private String status;
	private Integer reviewedByAdminId;
	private LocalDateTime reviewedAt;
	private String adminNotes;

	// Transient fields for easy display
	private String itemName;
	private String reporterUsername;
	private String reviewedByAdminUsername;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getReporterUserId() {
		return reporterUserId;
	}

	public void setReporterUserId(int reporterUserId) {
		this.reporterUserId = reporterUserId;
	}

	public String getReportDescription() {
		return reportDescription;
	}

	public void setReportDescription(String reportDescription) {
		this.reportDescription = reportDescription;
	}

	public LocalDateTime getReportedAt() {
		return reportedAt;
	}

	public void setReportedAt(LocalDateTime reportedAt) {
		this.reportedAt = reportedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}

	public String getAdminNotes() {
		return adminNotes;
	}

	public void setAdminNotes(String adminNotes) {
		this.adminNotes = adminNotes;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}

	public String getReporterUsername() {
		return reporterUsername;
	}

	public void setReporterUsername(String reporterUsername) {
		this.reporterUsername = reporterUsername;
	}

	public String getReviewedByAdminUsername() {
		return reviewedByAdminUsername;
	}

	public void setReviewedByAdminUsername(String reviewedByAdminUsername) {
		this.reviewedByAdminUsername = reviewedByAdminUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DashboardDataDTO.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.Map;

/**
 * A Data Transfer Object to encapsulate all data required for the dynamic admin
 * dashboard.
 */
public class DashboardDataDTO {
	private List<Event> upcomingEvents;
	private List<StorageItem> lowStockItems;
	private List<AdminLog> recentLogs;
	private List<Map<String, Object>> eventTrendData;

	public List<Event> getUpcomingEvents() {
		return upcomingEvents;
	}

	public void setUpcomingEvents(List<Event> upcomingEvents) {
		this.upcomingEvents = upcomingEvents;
	}

	public List<StorageItem> getLowStockItems() {
		return lowStockItems;
	}

	public void setLowStockItems(List<StorageItem> lowStockItems) {
		this.lowStockItems = lowStockItems;
	}

	public List<AdminLog> getRecentLogs() {
		return recentLogs;
	}

	public void setRecentLogs(List<AdminLog> recentLogs) {
		this.recentLogs = recentLogs;
	}

	public List<Map<String, Object>> getEventTrendData() {
		return eventTrendData;
	}

	public void setEventTrendData(List<Map<String, Object>> eventTrendData) {
		this.eventTrendData = eventTrendData;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;
	private List<ChecklistItem> checklistItems;

	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public List<ChecklistItem> getChecklistItems() {
		return checklistItems;
	}

	public void setChecklistItems(List<ChecklistItem> checklistItems) {
		this.checklistItems = checklistItems;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean isAnnouncement;
	private boolean edited;
	private LocalDateTime editedAt;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor;

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isAnnouncement() {
		return isAnnouncement;
	}

	public void setAnnouncement(boolean announcement) {
		isAnnouncement = announcement;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public LocalDateTime getEditedAt() {
		return editedAt;
	}

	public void setEditedAt(LocalDateTime editedAt) {
		this.editedAt = editedAt;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}