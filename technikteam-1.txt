
========================================================================
FILE: frontend\src\pages\admin\AdminFileEditorPage.jsx
========================================================================

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { View, Text, TextInput, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import MarkdownDisplay from 'react-native-markdown-display';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography } from '../../styles/theme';

const AdminFileEditorPage = () => {
	const route = useRoute();
    const navigation = useNavigation();
	const { fileId } = route.params;
	const { addToast } = useToast();
	const { isAdmin } = useAuthStore();
	const [content, setContent] = useState('');
	const [initialContent, setInitialContent] = useState(null);
	const [viewMode, setViewMode] = useState('edit');
	const [saveStatus, setSaveStatus] = useState('idle');
	const [error, setError] = useState('');

	const theme = useAuthStore(state => state.theme);
	const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const apiCall = useCallback(() => apiClient.get(`/admin/files/content/${fileId}`), [fileId]);
	const { data: fileData, loading, error: fetchError } = useApi(apiCall);

	useEffect(() => {
		if (fileData?.content !== null && fileData?.content !== undefined) {
			setContent(fileData.content);
			setInitialContent(fileData.content);
		}
	}, [fileData]);

	const handleSave = useCallback(async () => {
		if (saveStatus === 'saving' || content === initialContent) return;

		setSaveStatus('saving');
		setError('');
		try {
			const result = await apiClient.put(`/admin/files/content/${fileId}`, { content });
			if (result.success) {
				setInitialContent(content);
				setSaveStatus('saved');
				setTimeout(() => setSaveStatus('idle'), 2000);
			} else { throw new Error(result.message); }
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen.');
			setSaveStatus('idle');
			addToast(`Fehler beim Speichern: ${err.message}`, 'error');
		}
	}, [fileId, content, initialContent, saveStatus, addToast]);

    useEffect(() => {
		const interval = setInterval(handleSave, 5000);
		return () => clearInterval(interval);
	}, [handleSave]);

	const getSaveButtonContent = () => {
		switch (saveStatus) {
			case 'saving': return <ActivityIndicator color="#fff" />;
			case 'saved': return <Text style={styles.buttonText}>Gespeichert!</Text>;
			default: return <Text style={styles.buttonText}>Jetzt Speichern</Text>;
		}
	};

	if (loading) return <View style={styles.centered}><ActivityIndicator size="large" /></View>;
	if (fetchError) return <View style={styles.centered}><Text style={styles.errorText}>{fetchError}</Text></View>;

	return (
		<View style={styles.container}>
            <View style={styles.header}>
                <Text style={styles.title}>Editor: {fileData?.filename}</Text>
            </View>
            <View style={styles.controls}>
                <View style={styles.tabs}>
                    <TouchableOpacity style={[styles.tabButton, viewMode === 'edit' && styles.activeTab]} onPress={() => setViewMode('edit')}>
                        <Text style={[styles.tabText, viewMode === 'edit' && styles.activeTabText]}>Bearbeiten</Text>
                    </TouchableOpacity>
                    <TouchableOpacity style={[styles.tabButton, viewMode === 'preview' && styles.activeTab]} onPress={() => setViewMode('preview')}>
                        <Text style={[styles.tabText, viewMode === 'preview' && styles.activeTabText]}>Vorschau</Text>
                    </TouchableOpacity>
                </View>
                <TouchableOpacity style={[styles.button, saveStatus === 'saved' ? styles.successButton : styles.primaryButton]} onPress={handleSave} disabled={saveStatus === 'saving' || content === initialContent}>
                    {getSaveButtonContent()}
                </TouchableOpacity>
            </View>
            {error && <Text style={styles.errorText}>{error}</Text>}

			<View style={styles.editorContainer}>
				{viewMode === 'edit' ? (
					<TextInput
						value={content}
						onChangeText={setContent}
						style={styles.textArea}
                        multiline
                        textAlignVertical="top"
					/>
				) : (
					<ScrollView>
                        <View style={{padding: 10}}>
						    <MarkdownDisplay>{content}</MarkdownDisplay>
                        </View>
					</ScrollView>
				)}
			</View>
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { padding: 16 },
        controls: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 16, marginBottom: 16 },
        tabs: { flexDirection: 'row', borderWidth: 1, borderColor: colors.border, borderRadius: 8 },
        tabButton: { paddingVertical: 8, paddingHorizontal: 16 },
        activeTab: { backgroundColor: colors.primary },
        tabText: { color: colors.text },
        activeTabText: { color: colors.white },
        editorContainer: { flex: 1, borderWidth: 1, borderColor: colors.border, margin: 16, borderRadius: 8, backgroundColor: colors.surface },
        textArea: { flex: 1, padding: 10, fontSize: 14, fontFamily: 'monospace', color: colors.text },
    });
};

export default AdminFileEditorPage;
========================================================================
FILE: frontend\src\pages\admin\AdminFilesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, SectionList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
// NOTE: File picking requires a native library.
// import DocumentPicker from 'react-native-document-picker';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const AdminFilesPage = ({ navigation }) => {
	const filesApiCall = useCallback(() => apiClient.get('/admin/files'), []);
	const { data: fileApiResponse, loading, error, reload: reloadFiles } = useApi(filesApiCall);
    const { addToast } = useToast();

    const theme = useAuthStore(state => state.theme);
    const commonStyles = getCommonStyles(theme);
    const styles = { ...commonStyles, ...pageStyles(theme) };

	const sections = useMemo(() => {
		if (!fileApiResponse?.grouped) return [];
		return Object.entries(fileApiResponse.grouped).map(([categoryName, files]) => ({
			title: categoryName,
			data: files,
		}));
	}, [fileApiResponse]);

	const handleDeleteFile = (file) => {
		Alert.alert(`Datei "${file.filename}" löschen?`, "Diese Aktion kann nicht rückgängig gemacht werden.", [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
				try {
					const result = await apiClient.delete(`/admin/files/${file.id}`);
					if (result.success) {
						addToast('Datei gelöscht', 'success');
						reloadFiles();
					} else { throw new Error(result.message); }
				} catch (err) { addToast(err.message, 'error'); }
			}},
		]);
	};

    const renderItem = ({ item }) => {
        const isMarkdown = item.filename.toLowerCase().endsWith('.md');
        return (
            <View style={styles.fileRow}>
                <View style={styles.fileInfo}>
                    <Icon name="download" size={16} color={styles.fileIcon.color} />
                    <Text style={styles.fileName}>{item.filename}</Text>
                    <Text style={styles.fileMeta}>Sichtbarkeit: {item.requiredRole}</Text>
                </View>
                <View style={styles.fileActions}>
                    {isMarkdown && (
                        <TouchableOpacity onPress={() => navigation.navigate('AdminFileEditor', { fileId: item.id })}>
                            <Icon name="pen-alt" size={18} color={colors.textMuted} />
                        </TouchableOpacity>
                    )}
                    <TouchableOpacity onPress={() => handleDeleteFile(item)}>
                        <Icon name="trash" size={18} color={colors.danger} />
                    </TouchableOpacity>
                </View>
            </View>
        );
    };

    const renderSectionHeader = ({ section: { title } }) => (
        <View style={styles.sectionHeader}>
            <Icon name="folder" solid size={18} style={styles.folderIcon} />
            <Text style={styles.sectionTitle}>{title}</Text>
        </View>
    );

	return (
		<View style={styles.container}>
			<View style={styles.headerContainer}>
                <Icon name="file-upload" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>Datei-Verwaltung</Text>
			</View>
            <Text style={styles.subtitle}>Hier können Sie alle zentralen Dokumente und Vorlagen verwalten.</Text>
            
            {/* NOTE: File upload requires a native module and would open a modal */}
            <TouchableOpacity style={[styles.button, styles.successButton, { marginHorizontal: 16, marginBottom: 16}]}>
                <Icon name="upload" size={16} color="#fff" />
                <Text style={styles.buttonText}>Neue Datei hochladen</Text>
            </TouchableOpacity>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}

			<SectionList
                sections={sections}
                keyExtractor={(item) => item.id.toString()}
                renderItem={renderItem}
                renderSectionHeader={renderSectionHeader}
                ListEmptyComponent={<View style={styles.card}><Text>Keine Dateien gefunden.</Text></View>}
            />
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center', padding: 16 },
        headerIcon: { color: colors.heading, marginRight: 12 },
        sectionHeader: { flexDirection: 'row', alignItems: 'center', backgroundColor: colors.background, paddingVertical: 8, paddingHorizontal: 16, borderBottomWidth: 1, borderTopWidth: 1, borderColor: colors.border },
        folderIcon: { marginRight: 8, color: colors.textMuted },
        sectionTitle: { fontSize: typography.h4, fontWeight: 'bold', color: colors.heading },
        fileRow: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', padding: 16, backgroundColor: colors.surface, borderBottomWidth: 1, borderColor: colors.border },
        fileInfo: { flex: 1 },
        fileIcon: { color: colors.primary },
        fileName: { fontSize: typography.body, color: colors.text, marginLeft: 8 },
        fileMeta: { fontSize: typography.caption, color: colors.textMuted, marginLeft: 8, marginTop: 4 },
        fileActions: { flexDirection: 'row', gap: 24, alignItems: 'center' },
    });
};

export default AdminFilesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminGeoIpPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, TextInput, StyleSheet, FlatList, TouchableOpacity, Alert, ActivityIndicator } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { Picker } from '@react-native-picker/picker';

const AdminGeoIpPage = () => {
    const apiCall = useCallback(() => apiClient.get('/admin/geoip/rules'), []);
    const { data: rules, loading, error, reload } = useApi(apiCall);
    const [newRule, setNewRule] = useState({ countryCode: '', ruleType: 'BLOCK' });
    const [isSubmitting, setIsSubmitting] = useState(false);
    const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);

    const handleAddRule = async () => {
        if (newRule.countryCode.length !== 2) {
            addToast('Ländercode muss genau 2 Zeichen lang sein.', 'error');
            return;
        }
        setIsSubmitting(true);
        try {
            const result = await apiClient.post('/admin/geoip/rules', newRule);
            if (result.success) {
                addToast('Regel erfolgreich gespeichert.', 'success');
                setNewRule({ countryCode: '', ruleType: 'BLOCK' });
                reload();
            } else { throw new Error(result.message); }
        } catch (err) {
            addToast(`Fehler: ${err.message}`, 'error');
        } finally {
            setIsSubmitting(false);
        }
    };

    const handleDeleteRule = (countryCode) => {
        Alert.alert(`Regel für "${countryCode}" löschen?`, "Diese Aktion kann nicht rückgängig gemacht werden.", [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
                try {
                    const result = await apiClient.delete(`/admin/geoip/rules/${countryCode}`);
                    if (result.success) {
                        addToast('Regel erfolgreich gelöscht.', 'success');
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
            }},
		]);
    };
    
    const renderItem = ({ item }) => (
        <View style={styles.detailsListRow}>
            <Text style={styles.detailsListLabel}>{item.countryCode}</Text>
            <Text style={item.ruleType === 'BLOCK' ? {color: getThemeColors(theme).danger} : {color: getThemeColors(theme).success}}>{item.ruleType}</Text>
            <TouchableOpacity onPress={() => handleDeleteRule(item.countryCode)}>
                <Icon name="trash" size={18} color={getThemeColors(theme).danger} />
            </TouchableOpacity>
        </View>
    );

    return (
        <View style={styles.container}>
            <View style={styles.contentContainer}>
                <Text style={styles.title}><Icon name="globe-americas" size={24} /> GeoIP Filterregeln</Text>
                <Text style={styles.subtitle}>Verwalten Sie hier, aus welchen Ländern der Login erlaubt oder blockiert ist.</Text>
                
                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Neue Regel hinzufügen</Text>
                    <View style={styles.formGroup}>
                        <Text style={styles.label}>Ländercode (ISO 3166-1 alpha-2)</Text>
                        <TextInput style={styles.input} value={newRule.countryCode} onChangeText={val => setNewRule({...newRule, countryCode: val.toUpperCase()})} maxLength={2} autoCapitalize="characters" placeholder="z.B. DE, US, CN" />
                    </View>
                    <View style={styles.formGroup}>
                        <Text style={styles.label}>Regeltyp</Text>
                        <Picker selectedValue={newRule.ruleType} onValueChange={(val) => setNewRule({...newRule, ruleType: val})}>
                            <Picker.Item label="Blockieren" value="BLOCK" />
                            <Picker.Item label="Erlauben" value="ALLOW" />
                        </Picker>
                    </View>
                    <TouchableOpacity style={[styles.button, styles.successButton]} onPress={handleAddRule} disabled={isSubmitting}>
                        {isSubmitting ? <ActivityIndicator color="#fff" /> : <Text style={styles.buttonText}>Hinzufügen</Text>}
                    </TouchableOpacity>
                </View>

                <View style={styles.card}>
                    <Text style={styles.cardTitle}>Bestehende Regeln</Text>
                    {loading && <ActivityIndicator />}
                    {error && <Text style={styles.errorText}>{error}</Text>}
                    <FlatList
                        data={rules}
                        renderItem={renderItem}
                        keyExtractor={item => item.countryCode}
                    />
                </View>
            </View>
        </View>
    );
};

export default AdminGeoIpPage;
========================================================================
FILE: frontend\src\pages\admin\AdminKitsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert, Linking } from 'react-native';
import useApi from '../../hooks/useApi';
import useAdminData from '../../hooks/useAdminData';
import apiClient from '../../services/apiClient';
import KitModal from '../../components/admin/kits/KitModal';
import KitItemsForm from '../../components/admin/kits/KitItemsForm';
import Modal from '../../components/ui/Modal';
import QRCode from 'react-native-qrcode-svg';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';

const KitAccordion = ({ kit, onEdit, onDelete, onItemsUpdate, allStorageItems, storageReady }) => {
	const [isOpen, setIsOpen] = useState(false);
	const [isQrModalOpen, setIsQrModalOpen] = useState(false);
	const packKitUrl = `http://localhost:8081/TechnikTeam/pack-kit/${kit.id}`; // Hardcoded for native
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);

	return (
		<View style={styles.card}>
			<TouchableOpacity onPress={() => setIsOpen(!isOpen)} style={styles.accordionHeader}>
				<View style={{flexDirection: 'row', alignItems: 'center', flex: 1}}>
                    <Icon name={isOpen ? 'chevron-down' : 'chevron-right'} size={16} />
                    <View style={{marginLeft: 12}}>
                        <Text style={styles.cardTitle}>{kit.name}</Text>
                        <Text style={styles.subtitle}>{kit.description}</Text>
                    </View>
                </View>
                <TouchableOpacity style={[styles.button, {backgroundColor: getThemeColors(theme).primaryLight}]} onPress={() => setIsQrModalOpen(true)}>
                    <Text style={{color: getThemeColors(theme).primary}}>QR-Code</Text>
                </TouchableOpacity>
			</TouchableOpacity>

			{isOpen && (
				<View style={styles.accordionContent}>
					{!storageReady ? <ActivityIndicator /> : (
						<KitItemsForm kit={kit} allStorageItems={allStorageItems} onUpdateSuccess={onItemsUpdate} />
					)}
                    <View style={styles.cardActions}>
                        <TouchableOpacity style={[styles.button, styles.secondaryButton]} onPress={() => onEdit(kit)}>
                            <Text style={styles.buttonText}>Bearbeiten</Text>
                        </TouchableOpacity>
                        <TouchableOpacity style={[styles.button, styles.dangerOutlineButton]} onPress={() => onDelete(kit)}>
                            <Text style={styles.dangerOutlineButtonText}>Löschen</Text>
                        </TouchableOpacity>
                    </View>
				</View>
			)}

			<Modal isOpen={isQrModalOpen} onClose={() => setIsQrModalOpen(false)} title={`QR-Code für: ${kit.name}`}>
				<View style={{alignItems: 'center', padding: 16}}>
					<QRCode value={packKitUrl} size={256} />
					<Text style={{marginTop: 16}}>Scannen, um die Packliste zu öffnen.</Text>
					<Text style={{color: getThemeColors(theme).primary, marginTop: 8}} onPress={() => Linking.openURL(packKitUrl)}>{packKitUrl}</Text>
				</View>
			</Modal>
		</View>
	);
};

const AdminKitsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/kits'), []);
	const { data: kits, loading: kitsLoading, error: kitsError, reload } = useApi(apiCall);
	const { storageItems, loading: storageItemsLoading, error: storageItemsError } = useAdminData();
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingKit, setEditingKit] = useState(null);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);

	const openModal = (kit = null) => {
		setEditingKit(kit);
		setIsModalOpen(true);
	};

	const handleSuccess = () => {
		setIsModalOpen(false);
        setEditingKit(null);
		reload();
	};

	const handleDelete = (kit) => {
        Alert.alert(`Kit "${kit.name}" löschen?`, "Diese Aktion kann nicht rückgängig gemacht werden.", [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
				try {
					const result = await apiClient.delete(`/kits/${kit.id}`);
					if (result.success) {
						addToast('Kit erfolgreich gelöscht.', 'success');
						reload();
					} else { throw new Error(result.message); }
				} catch (err) { addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error'); }
			}},
		]);
	};
    
    const renderItem = ({ item }) => (
        <KitAccordion
            kit={item}
            onEdit={openModal}
            onDelete={handleDelete}
            onItemsUpdate={() => addToast('Kit-Inhalt gespeichert.', 'success')}
            allStorageItems={storageItems || []}
            storageReady={!storageItemsLoading}
        />
    );

	const loading = kitsLoading || storageItemsLoading;
	const error = kitsError || storageItemsError;

	return (
		<View style={styles.container}>
			<View style={styles.contentContainer}>
                <Text style={styles.title}><Icon name="box-open" size={24} /> Kit-Verwaltung</Text>
                <Text style={styles.subtitle}>Verwalten Sie hier wiederverwendbare Material-Zusammenstellungen.</Text>
                <TouchableOpacity style={[styles.button, styles.successButton]} onPress={() => openModal()}>
                    <Text style={styles.buttonText}>Neues Kit anlegen</Text>
                </TouchableOpacity>
            </View>

            {loading && <ActivityIndicator size="large" style={{marginTop: 20}} />}
			{error && <Text style={styles.errorText}>{error}</Text>}
			
            <FlatList
                data={kits}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={{ padding: 16 }}
            />

			{isModalOpen && (
				<KitModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSuccess={handleSuccess} kit={editingKit} />
			)}
		</View>
	);
};

export default AdminKitsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminLogPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useAuthStore } from '../../store/authStore';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography } from '../../styles/theme';

const AdminLogPage = () => {
	const navigation = useNavigation();
	const apiCall = useCallback(() => apiClient.get('/logs'), []);
	const { data: logs, loading, error, reload } = useApi(apiCall);
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
	const { addToast } = useToast();

    const theme = useAuthStore(state => state.theme);
    const commonStyles = getCommonStyles(theme);
    const styles = { ...commonStyles, ...pageStyles(theme) };

	const canRevoke = isAdmin || user?.permissions.includes('LOG_REVOKE');

	const handleRevoke = (log) => {
        Alert.alert(
            `Aktion widerrufen?`,
            `Möchten Sie die Aktion "${log.actionType}" (ID: ${log.id}) wirklich widerrufen? Dies führt die entsprechende Gegenaktion aus.`,
            [
                { text: 'Abbrechen', style: 'cancel' },
                { text: 'Widerrufen', style: 'destructive', onPress: async () => {
                    try {
                        const result = await apiClient.post(`/logs/${log.id}/revoke`);
                        if (result.success) {
                            addToast('Aktion erfolgreich widerrufen.', 'success');
                            reload();
                        } else { throw new Error(result.message); }
                    } catch (err) { addToast(`Widerrufen fehlgeschlagen: ${err.message}`, 'error'); }
                }}
            ]
        );
	};

    const renderItem = ({ item: log }) => {
        let context = {};
        try {
            if (log.context) context = JSON.parse(log.context);
        } catch (e) { /* ignore */ }
        const isRevocable = canRevoke && log.status === 'ACTIVE' && context.revocable === true;

        return (
            <View style={styles.card}>
                <View style={styles.cardHeader}>
                    <Text style={styles.cardTitle}>{log.actionType}</Text>
                    {log.status === 'REVOKED'
                        ? <Text style={[styles.badge, styles.infoBadge]}>Widerrufen</Text>
                        : <Text style={[styles.badge, styles.okBadge]}>Aktiv</Text>
                    }
                </View>
                <View style={styles.detailRow}>
                    <Text style={styles.label}>Wer:</Text>
                    <Text style={styles.value} onPress={() => log.adminUserId && navigation.navigate('UserProfile', { userId: log.adminUserId })}>{log.adminUsername}</Text>
                </View>
                <View style={styles.detailRow}>
                    <Text style={styles.label}>Wann:</Text>
                    <Text style={styles.value}>{new Date(log.actionTimestamp).toLocaleString('de-DE')}</Text>
                </View>
                <Text style={styles.detailsText}>{log.details}</Text>
                {canRevoke && (
                    <View style={styles.cardActions}>
                        <TouchableOpacity style={[styles.button, {backgroundColor: getThemeColors(theme).warning}, isRevocable ? {} : styles.disabledButton]} onPress={() => handleRevoke(log)} disabled={!isRevocable}>
                            <Text style={{color: '#000'}}>Widerrufen</Text>
                        </TouchableOpacity>
                    </View>
                )}
            </View>
        );
    };

	return (
		<View style={styles.container}>
			<View style={styles.headerContainer}>
                <Icon name="clipboard-list" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>Admin Aktions-Protokoll</Text>
			</View>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}
			
            <FlatList
                data={logs}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={styles.contentContainer}
                ListEmptyComponent={<View style={styles.card}><Text>Keine Log-Einträge gefunden.</Text></View>}
            />
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        cardHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 8 },
        cardTitle: { fontSize: typography.h4, fontWeight: 'bold' },
        badge: { paddingVertical: 4, paddingHorizontal: 10, borderRadius: 20, fontSize: 12, fontWeight: '600', color: colors.white },
        infoBadge: { backgroundColor: colors.textMuted },
        okBadge: { backgroundColor: colors.success },
        detailRow: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 4 },
        label: { fontWeight: 'bold', color: colors.textMuted },
        value: { color: colors.primary },
        detailsText: { marginTop: 12, paddingTop: 12, borderTopWidth: 1, borderColor: colors.border },
        cardActions: { flexDirection: 'row', justifyContent: 'flex-end', marginTop: 16 },
    });
};

export default AdminLogPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMatrixPage.jsx
========================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import AttendanceModal from '../../components/admin/matrix/AttendanceModal';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';

const CELL_WIDTH = 120;
const USER_COL_WIDTH = 150;

const AdminMatrixPage = () => {
    const navigation = useNavigation();
	const apiCall = useCallback(() => apiClient.get('/matrix'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const qualificationsApiCall = useCallback(() => apiClient.get('/admin/qualifications/all'), []);
	const { data: allQualifications } = useApi(qualificationsApiCall);
	const [modalData, setModalData] = useState(null);
    
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const { users, courses, meetingsByCourse, attendanceMap, completionMap } = data || {};

	const openModal = (cellData) => {
        setModalData(cellData);
	};

    const handleSuccess = () => {
		setModalData(null);
		reload();
	};

	if (loading) return <View style={styles.centered}><ActivityIndicator size="large" /></View>;
	if (error) return <View style={styles.centered}><Text style={styles.errorText}>{error}</Text></View>;

    const allMeetings = courses?.flatMap(course => meetingsByCourse[course.id] || [{id: `${course.id}-placeholder`, name: '-', courseId: course.id}]) || [];

	return (
		<View style={styles.container}>
			<Text style={styles.title}>Qualifikations-Matrix</Text>
			
            <View style={{flexDirection: 'row'}}>
                <View style={[styles.headerCell, {width: USER_COL_WIDTH}]}><Text style={styles.headerText}>Nutzer</Text></View>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <View>
                        <View style={{flexDirection: 'row'}}>
                            {courses?.map(course => (
                                <TouchableOpacity key={course.id} style={[styles.headerCell, styles.courseHeader, {width: (meetingsByCourse[course.id]?.length || 1) * CELL_WIDTH}]} onPress={() => navigation.navigate('AdminMeetings', {courseId: course.id})}>
                                    <Text style={styles.headerText}>{course.abbreviation}</Text>
                                </TouchableOpacity>
                            ))}
                        </View>
                        <View style={{flexDirection: 'row'}}>
                            {allMeetings.map(meeting => (
                                <TouchableOpacity key={meeting.id} style={[styles.headerCell, styles.meetingHeader, {width: CELL_WIDTH}]} onPress={() => navigation.navigate('MeetingDetails', {meetingId: meeting.id})}>
                                    <Text style={styles.headerText} numberOfLines={2}>{meeting.name}</Text>
                                </TouchableOpacity>
                            ))}
                        </View>
                    </View>
                </ScrollView>
            </View>

            <ScrollView>
                <View style={{flexDirection: 'row'}}>
                    <View style={{width: USER_COL_WIDTH}}>
                        {users?.map(user => (
                            <View key={user.id} style={[styles.cell, styles.userCell]}><Text style={styles.userText}>{user.username}</Text></View>
                        ))}
                    </View>
                    <ScrollView horizontal>
                         <View>
                            {users?.map(user => (
                                <View key={user.id} style={{flexDirection: 'row'}}>
                                    {courses?.map(course => {
                                        const hasCompletedCourse = completionMap[`${user.id}-${course.id}`];
                                        if(hasCompletedCourse) {
                                            return (
                                                <TouchableOpacity key={course.id} style={[styles.cell, {backgroundColor: colors.success, width: (meetingsByCourse[course.id]?.length || 1) * CELL_WIDTH}]}>
                                                    <Text style={{color: colors.white}}>Qualifiziert</Text>
                                                </TouchableOpacity>
                                            );
                                        }
                                        return (meetingsByCourse[course.id] || [{id: `${course.id}-placeholder`}]).map(meeting => {
                                             const attendance = attendanceMap[`${user.id}-${meeting.id}`];
                                             const attended = attendance ? attendance.attended : false;
                                             return (
                                                 <TouchableOpacity key={meeting.id} style={[styles.cell, {width: CELL_WIDTH}]} onPress={() => openModal({userId: user.id, meetingId: meeting.id /*... more data needed */})}>
                                                     {attended ? <Icon name="check" size={20} color={colors.success} /> : <Text style={{color: colors.textMuted}}>-</Text>}
                                                 </TouchableOpacity>
                                             );
                                        });
                                    })}
                                </View>
                            ))}
                        </View>
                    </ScrollView>
                </View>
            </ScrollView>

			{modalData && (
				<AttendanceModal isOpen={!!modalData} onClose={() => setModalData(null)} onSuccess={handleSuccess} cellData={modalData} />
			)}
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerCell: { backgroundColor: colors.background, padding: spacing.sm, borderWidth: 1, borderColor: colors.border, justifyContent: 'center', alignItems: 'center' },
        headerText: { fontWeight: 'bold', textAlign: 'center' },
        courseHeader: { borderBottomWidth: 0 },
        meetingHeader: { height: 60 },
        cell: { height: 50, borderWidth: 1, borderColor: colors.border, justifyContent: 'center', alignItems: 'center' },
        userCell: { backgroundColor: colors.surface, alignItems: 'flex-start', paddingLeft: spacing.sm },
        userText: { fontWeight: '500' },
    });
};


export default AdminMatrixPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMeetingsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Alert, ActivityIndicator, TextInput, ScrollView } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import RNPickerSelect from 'react-native-picker-select';

const AdminMeetingsPage = () => {
    const route = useRoute();
    const navigation = useNavigation();
    const { courseId } = route.params;
	const meetingsApiCall = useCallback(() => apiClient.get(`/meetings?courseId=${courseId}`), [courseId]);
	const { data: meetingsData, loading, error, reload } = useApi(meetingsApiCall);
    const { addToast } = useToast();

    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);

	const courseName = meetingsData?.[0]?.parentCourseName || 'Lehrgang';

	const handleDelete = (meeting) => {
        Alert.alert(`Meeting '${meeting.name}' löschen?`, "Diese Aktion kann nicht rückgängig gemacht werden.", [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
				try {
					const result = await apiClient.delete(`/meetings/${meeting.id}`);
					if (result.success) {
						addToast('Meeting gelöscht.', 'success');
						reload();
					} else { throw new Error(result.message); }
				} catch (err) { addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error'); }
			}},
		]);
	};
    
    const renderItem = ({ item: meeting }) => (
        <View style={styles.card}>
            <TouchableOpacity onPress={() => navigation.navigate('MeetingDetails', { meetingId: item.id })}>
                <Text style={styles.cardTitle}>{meeting.name}</Text>
            </TouchableOpacity>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Datum:</Text>
                <Text style={styles.value}>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</Text>
            </View>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Teilnehmer:</Text>
                <Text style={styles.value}>{meeting.participantCount || 0} / {meeting.maxParticipants || '∞'}</Text>
            </View>
            <View style={{flexDirection: 'row', justifyContent: 'flex-end', gap: 8, marginTop: 16}}>
                {/* Edit and Repeat would open modals */}
                <TouchableOpacity style={[styles.button, styles.secondaryButton]}><Text style={styles.buttonText}>Bearbeiten</Text></TouchableOpacity>
                <TouchableOpacity style={[styles.button, styles.dangerOutlineButton]} onPress={() => handleDelete(meeting)}>
                    <Text style={styles.dangerOutlineButtonText}>Löschen</Text>
                </TouchableOpacity>
            </View>
        </View>
    );

	return (
		<View style={styles.container}>
			<Text style={styles.title}>Meetings für "{courseName}"</Text>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}
			
            <FlatList
                data={meetingsData}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={styles.contentContainer}
                ListEmptyComponent={<View style={styles.card}><Text>Keine Meetings für diesen Lehrgang geplant.</Text></View>}
            />
		</View>
	);
};

export default AdminMeetingsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminNotificationsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, TextInput, TouchableOpacity, ScrollView, ActivityIndicator, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';
import { Picker } from '@react-native-picker/picker';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors } from '../../styles/theme';

const AdminNotificationsPage = () => {
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);
	const { addToast } = useToast();
	const [formData, setFormData] = useState({ title: '', description: '', level: 'Informational', targetType: 'ALL', targetId: '' });
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const fetchEvents = useCallback(() => apiClient.get('/events'), []);
	const fetchMeetings = useCallback(() => apiClient.get('/meetings?courseId=0'), []);

	const { data: events, loading: eventsLoading } = useApi(fetchEvents);
	const { data: meetings, loading: meetingsLoading } = useApi(fetchMeetings);

	const sendNotification = async () => {
		setIsSubmitting(true);
		setError('');
		try {
			const payload = { ...formData, targetId: formData.targetId ? parseInt(formData.targetId, 10) : null };
			const result = await apiClient.post('/admin/notifications', payload);
			if (result.success) {
				addToast(result.message, 'success');
				setFormData({ title: '', description: '', level: 'Informational', targetType: 'ALL', targetId: '' });
			} else { throw new Error(result.message); }
		} catch (err) {
			setError(err.message || 'Senden fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

    const handleSendPress = () => {
        if (!formData.title || !formData.description) {
			setError('Titel und Beschreibung sind erforderlich.');
			return;
		}
        if (formData.level === 'Warning') {
            Alert.alert(
                "WARNUNG: Notfall-Benachrichtigung",
                "Diese Stufe sollte nur für echte Notfälle verwendet werden. Sind Sie sicher?",
                [ { text: "Abbrechen", style: "cancel" }, { text: "Ja, senden", style: "destructive", onPress: sendNotification } ]
            );
        } else {
            sendNotification();
        }
    }

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<Text style={styles.title}>Benachrichtigungen senden</Text>
            <Text style={styles.subtitle}>Erstellen und versenden Sie hier systemweite Benachrichtigungen an Benutzergruppen.</Text>
			
            <View style={styles.card}>
                <Text style={styles.cardTitle}>Neue Benachrichtigung</Text>
				{error && <Text style={styles.errorText}>{error}</Text>}
				
                <View style={styles.formGroup}>
                    <Text style={styles.label}>Titel</Text>
                    <TextInput style={styles.input} value={formData.title} onChangeText={val => setFormData({...formData, title: val})} />
                </View>
                <View style={styles.formGroup}>
                    <Text style={styles.label}>Beschreibung</Text>
                    <TextInput style={[styles.input, styles.textArea]} value={formData.description} onChangeText={val => setFormData({...formData, description: val})} multiline />
                </View>
                <View style={styles.formGroup}>
                    <Text style={styles.label}>Stufe</Text>
                    <Picker selectedValue={formData.level} onValueChange={val => setFormData({...formData, level: val})}>
                        <Picker.Item label="Informational" value="Informational" />
                        <Picker.Item label="Important" value="Important" />
                        <Picker.Item label="Warning (Notfall)" value="Warning" />
                    </Picker>
                </View>
                <View style={styles.formGroup}>
                    <Text style={styles.label}>Zielgruppe</Text>
                    <Picker selectedValue={formData.targetType} onValueChange={val => setFormData({...formData, targetType: val, targetId: ''})}>
                        <Picker.Item label="Alle Benutzer" value="ALL" />
                        <Picker.Item label="Event-Teilnehmer" value="EVENT" />
                        <Picker.Item label="Meeting-Teilnehmer" value="MEETING" />
                    </Picker>
                </View>

                {formData.targetType === 'EVENT' && (
                    <View style={styles.formGroup}>
                        <Text style={styles.label}>Spezifisches Event</Text>
                        <Picker selectedValue={formData.targetId} onValueChange={val => setFormData({...formData, targetId: val})}>
                            <Picker.Item label="-- Bitte auswählen --" value="" />
                            {events?.map(e => <Picker.Item key={e.id} label={e.name} value={e.id} />)}
                        </Picker>
                    </View>
                )}
                {formData.targetType === 'MEETING' && (
                     <View style={styles.formGroup}>
                        <Text style={styles.label}>Spezifisches Meeting</Text>
                        <Picker selectedValue={formData.targetId} onValueChange={val => setFormData({...formData, targetId: val})}>
                            <Picker.Item label="-- Bitte auswählen --" value="" />
                            {meetings?.map(m => <Picker.Item key={m.id} label={`${m.parentCourseName}: ${m.name}`} value={m.id} />)}
                        </Picker>
                    </View>
                )}
				<TouchableOpacity style={[styles.button, styles.successButton]} onPress={handleSendPress} disabled={isSubmitting}>
					{isSubmitting ? <ActivityIndicator color="#fff" /> : <Text style={styles.buttonText}>Benachrichtigung senden</Text>}
				</TouchableOpacity>
			</View>
		</ScrollView>
	);
};

export default AdminNotificationsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminReportsIndex.jsx
========================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ScrollView } from 'react-native';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const AdminReportsIndex = ({ navigation }) => {
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const baseLinks = [
		{ to: 'AdminReports', label: 'Berichte & Analysen', icon: 'chart-pie', perm: 'REPORT_READ' },
		{ to: 'AdminLog', label: 'Aktions-Log', icon: 'clipboard-list', perm: 'LOG_READ' },
	];

	const can = (permission) => {
		return isAdmin || user?.permissions.includes(permission);
	};

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.header}>
				<Icon name="chart-line" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>Berichte &amp; Logs</Text>
			</View>
			<Text style={styles.subtitle}>Analysieren Sie die Anwendungsnutzung und überwachen Sie Systemaktivitäten.</Text>

            <View style={styles.grid}>
                {baseLinks.filter(link => can(link.perm)).map(link => (
                    <TouchableOpacity key={link.to} style={styles.card} onPress={() => navigation.navigate(link.to)}>
                        <Icon name={link.icon} size={48} color={colors.primary} />
                        <Text style={styles.cardTitle}>{link.label}</Text>
                    </TouchableOpacity>
                ))}
            </View>
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        grid: {
            flexDirection: 'row',
            flexWrap: 'wrap',
            justifyContent: 'space-between',
        },
        card: {
            width: '48%',
            backgroundColor: colors.surface,
            borderRadius: 8,
            paddingVertical: 32,
            paddingHorizontal: 16,
            marginBottom: 16,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 1,
            borderColor: colors.border,
        },
        cardTitle: {
            fontSize: 16,
            fontWeight: 'bold',
            textAlign: 'center',
            color: colors.text,
            marginTop: 16,
        },
    });
}

export default AdminReportsIndex;
========================================================================
FILE: frontend\src\pages\admin\AdminReportsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator, Linking } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import EventTrendChart from '../../components/admin/dashboard/EventTrendChart';
import UserActivityChart from '../../components/admin/reports/UserActivityChart';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';

const AdminReportsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/reports/dashboard'), []);
	const { data: reportData, loading, error } = useApi(apiCall);
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const getCsvLink = (reportType) => `http://10.0.2.2:8081/TechnikTeam/api/v1/reports/${reportType}?export=csv`;

	if (loading) return <View style={styles.centered}><ActivityIndicator size="large" /></View>;
	if (error) return <View style={styles.centered}><Text style={styles.errorText}>{error}</Text></View>;
	if (!reportData) return <View style={styles.centered}><Text>Keine Berichtsdaten verfügbar.</Text></View>;

	const { eventTrend, userActivity, totalInventoryValue } = reportData;

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.headerContainer}>
                <Icon name="chart-pie" size={24} style={styles.headerIcon} />
			    <Text style={styles.title}>Berichte & Analysen</Text>
            </View>
			<Text style={styles.subtitle}>Hier finden Sie zusammengefasste Daten und Analysen über die Anwendungsnutzung.</Text>

			<View style={styles.card}>
				<Text style={styles.cardTitle}>Event-Trend (Letzte 12 Monate)</Text>
				<EventTrendChart trendData={eventTrend} />
			</View>

			<View style={styles.card}>
				<Text style={styles.cardTitle}>Top 10 Aktivste Benutzer</Text>
				<UserActivityChart activityData={userActivity} />
			</View>

			<View style={styles.card}>
				<Text style={styles.cardTitle}>Sonstige Berichte & Exporte</Text>
                <View style={styles.exportRow}>
                    <Text style={styles.exportLabel}>Teilnahme-Zusammenfassung</Text>
                    <TouchableOpacity style={styles.exportButton} onPress={() => Linking.openURL(getCsvLink('event-participation'))}>
                        <Icon name="file-csv" size={16} color={colors.white} />
                        <Text style={styles.buttonText}>CSV</Text>
                    </TouchableOpacity>
                </View>
                <View style={styles.exportRow}>
                    <Text style={styles.exportLabel}>Nutzungsfrequenz (Material)</Text>
                    <TouchableOpacity style={styles.exportButton} onPress={() => Linking.openURL(getCsvLink('inventory-usage'))}>
                         <Icon name="file-csv" size={16} color={colors.white} />
                        <Text style={styles.buttonText}>CSV</Text>
                    </TouchableOpacity>
                </View>
                <View style={styles.exportRow}>
                    <Text style={styles.exportLabel}>Vollständige Benutzeraktivität</Text>
                    <TouchableOpacity style={styles.exportButton} onPress={() => Linking.openURL(getCsvLink('user-activity'))}>
                         <Icon name="file-csv" size={16} color={colors.white} />
                        <Text style={styles.buttonText}>CSV</Text>
                    </TouchableOpacity>
                </View>
                <View style={styles.exportRow}>
                    <Text style={styles.exportLabel}>Gesamtwert des Lagers</Text>
                    <Text style={styles.inventoryValue}>
                        {new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalInventoryValue)}
                    </Text>
                </View>
			</View>
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        exportRow: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingVertical: spacing.md, borderBottomWidth: 1, borderColor: colors.border },
        exportLabel: { fontSize: typography.body, color: colors.text },
        exportButton: { flexDirection: 'row', gap: 8, backgroundColor: colors.success, paddingVertical: 8, paddingHorizontal: 12, borderRadius: 6 },
        inventoryValue: { fontWeight: 'bold', fontSize: typography.body, color: colors.text },
    });
};

export default AdminReportsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminRequestsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography } from '../../styles/theme';

const AdminRequestsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/requests/pending'), []);
	const { data: requests, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const handleAction = (requestId, action) => {
		const confirmationText = action === 'approve' ? 'Änderungen wirklich übernehmen?' : 'Antrag wirklich ablehnen?';
        Alert.alert('Aktion bestätigen', confirmationText, [
            { text: 'Abbrechen', style: 'cancel' },
            { text: action === 'approve' ? 'Genehmigen' : 'Ablehnen', style: 'default', onPress: async () => {
                try {
                    const result = await apiClient.post(`/requests/${requestId}/${action}`);
                    if (result.success) {
                        addToast(`Antrag erfolgreich ${action === 'approve' ? 'genehmigt' : 'abgelehnt'}.`, 'success');
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
            }}
        ]);
	};

	const renderChanges = (changesJson) => {
		try {
			const changes = JSON.parse(changesJson);
			return (
				<View>
					{Object.entries(changes).map(([key, value]) => (
						<Text key={key} style={styles.changeText}><Text style={{fontWeight: 'bold'}}>{key}:</Text> {value}</Text>
					))}
				</View>
			);
		} catch (e) {
			return <Text style={styles.errorText}>Fehler beim Parsen der Änderungen.</Text>;
		}
	};
    
    const renderItem = ({ item }) => (
        <View style={styles.card}>
            <Text style={styles.cardTitle}>Antrag von {item.username}</Text>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Beantragt am:</Text>
                <Text style={styles.value}>{new Date(item.requestedAt).toLocaleString('de-DE')}</Text>
            </View>
            <View style={{marginTop: 8}}>
                <Text style={styles.label}>Änderungen:</Text>
                {renderChanges(item.requestedChanges)}
            </View>
            <View style={styles.cardActions}>
                <TouchableOpacity style={[styles.button, styles.successButton]} onPress={() => handleAction(item.id, 'approve')}>
                    <Text style={styles.buttonText}>Genehmigen</Text>
                </TouchableOpacity>
                 <TouchableOpacity style={[styles.button, styles.dangerButton]} onPress={() => handleAction(item.id, 'deny')}>
                    <Text style={styles.buttonText}>Ablehnen</Text>
                </TouchableOpacity>
            </View>
        </View>
    );

	return (
		<View style={styles.container}>
			<View style={styles.headerContainer}>
                <Icon name="inbox" size={24} style={styles.headerIcon} />
			    <Text style={styles.title}>Offene Anträge</Text>
            </View>
			<Text style={styles.subtitle}>Hier sehen Sie alle von Benutzern beantragten Änderungen an Stammdaten.</Text>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}

			<FlatList
                data={requests}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={styles.contentContainer}
                ListEmptyComponent={<View style={styles.card}><Text>Keine offenen Anträge vorhanden.</Text></View>}
            />
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        cardActions: { flexDirection: 'row', justifyContent: 'flex-end', gap: 8, marginTop: 16 },
        changeText: { fontSize: typography.body, color: colors.text, marginLeft: 8 }
    });
};

export default AdminRequestsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminStorageIndex.jsx
========================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ScrollView } from 'react-native';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const AdminStorageIndex = ({ navigation }) => {
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const baseLinks = [
		{ to: 'AdminStorage', label: 'Lager Verwalten', icon: 'warehouse', perm: 'STORAGE_READ' },
		{ to: 'AdminKits', label: 'Kit-Verwaltung', icon: 'box-open', perm: 'KIT_READ' },
		{ to: 'AdminDefective', label: 'Defekte Artikel', icon: 'wrench', perm: 'STORAGE_READ' },
		{ to: 'AdminDamageReports', label: 'Schadensmeldungen', icon: 'tools', perm: 'DAMAGE_REPORT_MANAGE' },
	];

	const can = (permission) => {
		return isAdmin || user?.permissions.includes(permission);
	};

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.header}>
				<Icon name="boxes" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>Lager &amp; Material</Text>
			</View>
			<Text style={styles.subtitle}>Verwalten Sie hier das Inventar, Material-Sets und gemeldete Schäden.</Text>

            <View style={styles.grid}>
                {baseLinks.filter(link => can(link.perm)).map(link => (
                    <TouchableOpacity key={link.to} style={styles.card} onPress={() => navigation.navigate(link.to)}>
                        <Icon name={link.icon} size={48} color={colors.primary} />
                        <Text style={styles.cardTitle}>{link.label}</Text>
                    </TouchableOpacity>
                ))}
            </View>
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        grid: {
            flexDirection: 'row',
            flexWrap: 'wrap',
            justifyContent: 'space-between',
        },
        card: {
            width: '48%',
            backgroundColor: colors.surface,
            borderRadius: 8,
            paddingVertical: 32,
            paddingHorizontal: 16,
            marginBottom: 16,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 1,
            borderColor: colors.border,
        },
        cardTitle: {
            fontSize: 16,
            fontWeight: 'bold',
            textAlign: 'center',
            color: colors.text,
            marginTop: 16,
        },
    });
}

export default AdminStorageIndex;
========================================================================
FILE: frontend\src\pages\admin\AdminStoragePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StorageItemModal from '../../components/admin/storage/StorageItemModal';
import Lightbox from '../../components/ui/Lightbox';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import QRCode from 'react-native-qrcode-svg';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography } from '../../styles/theme';

const HealthIndicator = ({ item }) => {
	let color = '#28a745'; // success
	if (item.defectiveQuantity > 0) color = '#dc3545'; // danger
	else if (item.maxQuantity > 0 && item.availableQuantity < item.maxQuantity) color = '#ffc107'; // warning
	return <View style={{ width: 10, height: 10, borderRadius: 5, backgroundColor: color }} />;
};

const AdminStoragePage = () => {
    const navigation = useNavigation();
	const apiCall = useCallback(() => apiClient.get('/storage'), []);
	const { data: items, loading, error, reload } = useApi(apiCall);
	const [modalState, setModalState] = useState({ isOpen: false, item: null, mode: 'edit' });
	const [lightboxSrc, setLightboxSrc] = useState('');
	const [qrCodeItem, setQrCodeItem] = useState(null);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const openModal = (mode, item = null) => setModalState({ isOpen: true, item, mode });
	const handleSuccess = () => { setModalState({ isOpen: false, item: null, mode: 'edit' }); reload(); };

	const handleDelete = (item) => {
		Alert.alert(`Artikel "${item.name}" löschen?`, "", [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
				try {
					const result = await apiClient.delete(`/storage/${item.id}`);
					if (result.success) {
						addToast('Artikel gelöscht.', 'success');
						reload();
					} else { throw new Error(result.message); }
				} catch (err) { addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error'); }
			}},
		]);
	};

	const getImagePath = (path) => `/api/v1/public/files/images/${path.split('/').pop()}`;

    const renderItem = ({ item }) => (
        <View style={styles.card}>
            <View style={styles.cardHeader}>
                <HealthIndicator item={item} />
                <TouchableOpacity onPress={() => navigation.navigate('StorageItemDetails', { itemId: item.id })}>
                    <Text style={styles.cardTitle}>{item.name}</Text>
                </TouchableOpacity>
                {item.imagePath && (
                    <TouchableOpacity onPress={() => setLightboxSrc(getImagePath(item.imagePath))}>
                        <Icon name="camera" size={18} color={getThemeColors(theme).textMuted} />
                    </TouchableOpacity>
                )}
            </View>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Verfügbar:</Text>
                <Text style={styles.value}>{item.availableQuantity}/{item.maxQuantity} {item.defectiveQuantity > 0 && `(${item.defectiveQuantity} def.)`}</Text>
            </View>
            <View style={styles.cardActions}>
                <TouchableOpacity style={styles.actionButton} onPress={() => openModal('edit', item)}><Text>Bearbeiten</Text></TouchableOpacity>
                <TouchableOpacity style={styles.actionButton} onPress={() => openModal('defect', item)}><Text>Defekt</Text></TouchableOpacity>
                {item.defectiveQuantity > 0 && (
                    <TouchableOpacity style={styles.actionButton} onPress={() => openModal('repair', item)}><Text>Repariert</Text></TouchableOpacity>
                )}
                <TouchableOpacity style={styles.actionButton} onPress={() => setQrCodeItem(item)}><Text>QR</Text></TouchableOpacity>
                <TouchableOpacity style={styles.actionButton} onPress={() => handleDelete(item)}><Text style={{color: getThemeColors(theme).danger}}>Löschen</Text></TouchableOpacity>
            </View>
        </View>
    );

	return (
		<View style={styles.container}>
            <TouchableOpacity style={[styles.button, styles.successButton, {margin: 16}]} onPress={() => openModal('create')}>
                <Icon name="plus" size={16} color="#fff" />
                <Text style={styles.buttonText}>Neuen Artikel anlegen</Text>
            </TouchableOpacity>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}

			<FlatList
                data={items}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={{paddingHorizontal: 16}}
            />

			{modalState.isOpen && <StorageItemModal isOpen={modalState.isOpen} onClose={() => setModalState({isOpen: false, item: null, mode: 'edit'})} onSuccess={handleSuccess} item={modalState.item} initialMode={modalState.mode} />}
			{qrCodeItem && (
				<Modal isOpen={!!qrCodeItem} onClose={() => setQrCodeItem(null)} title={`QR-Code für: ${qrCodeItem.name}`}>
					<View style={{alignItems: 'center', padding: 16}}>
						<QRCode value={`http://localhost:8081/TechnikTeam/lager/qr-aktion/${qrCodeItem.id}`} size={256} />
						<Text style={{marginTop: 16}}>Scannen für schnelle Aktionen.</Text>
					</View>
				</Modal>
			)}
			{lightboxSrc && <Lightbox src={lightboxSrc} onClose={() => setLightboxSrc('')} />}
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        cardHeader: { flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 8 },
        cardTitle: { fontSize: typography.h4, fontWeight: 'bold' },
        cardActions: { flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginTop: 12, justifyContent: 'flex-end' },
        actionButton: { padding: 8, backgroundColor: colors.background, borderRadius: 6 },
    });
};

export default AdminStoragePage;
========================================================================
FILE: frontend\src\pages\admin\AdminSystemIndex.jsx
========================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ScrollView, Linking } from 'react-native';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const AdminSystemIndex = ({ navigation }) => {
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const baseLinks = [
		{ to: 'AdminSystemStatus', label: 'System-Status', icon: 'server', perm: 'SYSTEM_READ' },
		{ to: 'AdminAuthLog', label: 'Auth Log', icon: 'history', perm: 'LOG_READ' },
		{ to: 'AdminGeoIp', label: 'GeoIP Filter', icon: 'globe-americas', perm: 'ACCESS_ADMIN_PANEL' },
		{ to: 'AdminWiki', label: 'Technische Wiki', icon: 'book-reader', perm: 'ACCESS_ADMIN_PANEL' },
		{ to: 'http://10.0.2.2:8081/TechnikTeam/swagger-ui.html', label: 'API Docs (Swagger)', icon: 'code', perm: 'ACCESS_ADMIN_PANEL', isExternal: true },
	];

	const can = (permission) => {
		return isAdmin || user?.permissions.includes(permission);
	};

    const handlePress = (link) => {
        if (link.isExternal) {
            Linking.openURL(link.to);
        } else {
            navigation.navigate(link.to);
        }
    };

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.header}>
				<Icon name="cogs" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>System &amp; Entwicklung</Text>
			</View>
			<Text style={styles.subtitle}>Technische Verwaltung, Dokumentation und Systemüberwachung.</Text>

            <View style={styles.grid}>
                {baseLinks.filter(link => can(link.perm)).map(link => (
                    <TouchableOpacity key={link.to} style={styles.card} onPress={() => handlePress(link)}>
                        <Icon name={link.icon} size={48} color={colors.primary} />
                        <Text style={styles.cardTitle}>{link.label}</Text>
                    </TouchableOpacity>
                ))}
            </View>
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        grid: {
            flexDirection: 'row',
            flexWrap: 'wrap',
            justifyContent: 'space-between',
        },
        card: {
            width: '48%',
            backgroundColor: colors.surface,
            borderRadius: 8,
            paddingVertical: 32,
            paddingHorizontal: 16,
            marginBottom: 16,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 1,
            borderColor: colors.border,
        },
        cardTitle: {
            fontSize: 16,
            fontWeight: 'bold',
            textAlign: 'center',
            color: colors.text,
            marginTop: 16,
        },
    });
}

export default AdminSystemIndex;
========================================================================
FILE: frontend\src\pages\admin\AdminSystemPage.jsx
========================================================================

import React, { useCallback, useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator, TextInput, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';
import { RadioButton } from 'react-native-paper'; // Example for radio buttons

const MaintenanceModeManager = () => {
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);
	const apiCall = useCallback(() => apiClient.get('/admin/system/maintenance'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [mode, setMode] = useState('OFF');
	const [message, setMessage] = useState('');
	const { addToast } = useToast();

	useEffect(() => {
		if (data) {
			setMode(data.mode || 'OFF');
			setMessage(data.message || '');
		}
	}, [data]);

	const handleSubmit = () => {
		const newStatus = { mode, message };
		const actionText = { OFF: 'deaktivieren', SOFT: 'aktivieren (Warnung)', HARD: 'aktivieren (Sperre)'}[mode];
        Alert.alert('Bestätigen', `Sind Sie sicher, dass Sie den Wartungsmodus ${actionText} möchten?`, [
            { text: 'Abbrechen', style: 'cancel'},
            { text: 'Ja', onPress: async () => {
                setIsSubmitting(true);
                try {
                    const result = await apiClient.post('/admin/system/maintenance', newStatus);
                    if (result.success) {
                        addToast(result.message, 'success');
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(err.message, 'error'); } finally { setIsSubmitting(false); }
            }}
        ]);
	};

	if (loading) return <ActivityIndicator />;
	if (error) return <Text style={styles.errorText}>{error}</Text>;

	return (
		<View style={styles.card}>
			<Text style={styles.cardTitle}>Wartungsmodus</Text>
			<Text style={styles.subtitle}>Steuern Sie den globalen Zugriffsstatus der Anwendung.</Text>
            
            <RadioButton.Group onValueChange={newValue => setMode(newValue)} value={mode}>
                <View style={styles.radioRow}><RadioButton value="OFF" /><Text>Aus</Text></View>
                <View style={styles.radioRow}><RadioButton value="SOFT" /><Text>Warnung (Banner)</Text></View>
                <View style={styles.radioRow}><RadioButton value="HARD" /><Text>Sperre (Nur Admins)</Text></View>
            </RadioButton.Group>
			
            <Text style={styles.label}>Angezeigte Nachricht</Text>
			<TextInput style={[styles.input, styles.textArea]} value={message} onChangeText={setMessage} multiline placeholder="z.B. Führen gerade Datenbank-Updates durch."/>
			
            <TouchableOpacity style={[styles.button, styles.successButton]} onPress={handleSubmit} disabled={isSubmitting}>
				{isSubmitting ? <ActivityIndicator color="#fff"/> : <Text style={styles.buttonText}>Status aktualisieren</Text>}
			</TouchableOpacity>
		</View>
	);
};

const AdminSystemPage = () => {
	const apiCall = useCallback(() => apiClient.get('/system/stats'), []);
	const { data: stats, loading, error } = useApi(apiCall);
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const formatPercent = (value) => `${value.toFixed(1)}%`;
	const formatGB = (value) => `${value.toFixed(2)} GB`;

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.headerContainer}>
                <Icon name="server" size={24} style={styles.headerIcon} />
			    <Text style={styles.title}>Systeminformationen</Text>
            </View>
			<Text style={styles.subtitle}>Live-Statistiken über den Zustand des Servers.</Text>

			<MaintenanceModeManager />

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}
			{stats && (
				<>
                    <View style={styles.card}>
                        <Text style={styles.cardTitle}>CPU & Speicher</Text>
                        <View style={styles.detailRow}><Text style={styles.label}>CPU-Auslastung:</Text><Text style={styles.value}>{stats.cpuLoad > 0 ? formatPercent(stats.cpuLoad) : 'Wird geladen...'}</Text></View>
                        <View style={styles.detailRow}><Text style={styles.label}>RAM-Nutzung:</Text><Text style={styles.value}>{formatGB(stats.usedMemory)} / {formatGB(stats.totalMemory)}</Text></View>
                    </View>
                    <View style={styles.card}>
                        <Text style={styles.cardTitle}>Festplattenspeicher</Text>
                        <View style={styles.detailRow}><Text style={styles.label}>Speichernutzung:</Text><Text style={styles.value}>{formatGB(stats.usedDiskSpace)} / {formatGB(stats.totalDiskSpace)}</Text></View>
                    </View>
                    <View style={styles.card}>
                        <Text style={styles.cardTitle}>Laufzeit & Energie</Text>
                        <View style={styles.detailRow}><Text style={styles.label}>Server-Laufzeit:</Text><Text style={styles.value}>{stats.uptime}</Text></View>
                        <View style={styles.detailRow}><Text style={styles.label}>Batteriestatus:</Text><Text style={styles.value}>{stats.batteryPercentage >= 0 ? `${stats.batteryPercentage}%` : 'Nicht verfügbar'}</Text></View>
                    </View>
				</>
			)}
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        radioRow: { flexDirection: 'row', alignItems: 'center' },
    });
};

export default AdminSystemPage;
========================================================================
FILE: frontend\src\pages\admin\AdminTrainingRequestsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography } from '../../styles/theme';

const AdminTrainingRequestsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/training-requests'), []);
	const { data: requests, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const handleDelete = (request) => {
        Alert.alert(`Anfrage löschen?`, `Anfrage für "${request.topic}" wirklich löschen?`, [
			{ text: 'Abbrechen', style: 'cancel' },
			{ text: 'Löschen', style: 'destructive', onPress: async () => {
				try {
					const result = await apiClient.delete(`/admin/training-requests/${request.id}`);
					if (result.success) {
						addToast('Anfrage gelöscht', 'success');
						reload();
					} else { throw new Error(result.message); }
				} catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
			}},
		]);
	};

    const renderItem = ({ item }) => (
        <View style={styles.card}>
            <Text style={styles.cardTitle}>{item.topic}</Text>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Angefragt von:</Text>
                <Text style={styles.value}>{item.requesterUsername}</Text>
            </View>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Datum:</Text>
                <Text style={styles.value}>{new Date(item.createdAt).toLocaleDateString('de-DE')}</Text>
            </View>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Interessenten:</Text>
                <Text style={styles.value}>{item.interestCount}</Text>
            </View>
            <View style={styles.cardActions}>
                <TouchableOpacity style={[styles.button, styles.dangerOutlineButton]} onPress={() => handleDelete(item)}>
                    <Text style={styles.dangerOutlineButtonText}>Löschen</Text>
                </TouchableOpacity>
            </View>
        </View>
    );

	return (
		<View style={styles.container}>
            <View style={styles.headerContainer}>
                <Icon name="question-circle" size={24} style={styles.headerIcon} />
			    <Text style={styles.title}>Lehrgangsanfragen</Text>
            </View>
			<Text style={styles.subtitle}>Hier sehen Sie alle von Benutzern eingereichten Wünsche für neue Lehrgänge.</Text>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}

			<FlatList
                data={requests}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
                contentContainerStyle={styles.contentContainer}
            />
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        headerContainer: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        cardActions: { flexDirection: 'row', justifyContent: 'flex-end', marginTop: 16 }
    });
};

export default AdminTrainingRequestsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminUsersIndex.jsx
========================================================================

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, ScrollView } from 'react-native';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const AdminUsersIndex = ({ navigation }) => {
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const baseLinks = [
		{ to: 'AdminUsers', label: 'Benutzer Verwalten', icon: 'users-cog', perm: 'USER_READ' },
		{ to: 'AdminRequests', label: 'Profilanträge', icon: 'inbox', perm: 'USER_UPDATE' },
		{ to: 'AdminTrainingRequests', label: 'Lehrgangsanfragen', icon: 'question-circle', perm: 'COURSE_CREATE' },
		{ to: 'AdminAchievements', label: 'Abzeichen', icon: 'award', perm: 'ACHIEVEMENT_VIEW' },
	];

	const can = (permission) => {
		return isAdmin || user?.permissions.includes(permission);
	};

	return (
		<ScrollView style={styles.container} contentContainerStyle={styles.contentContainer}>
			<View style={styles.header}>
				<Icon name="user-friends" size={24} style={styles.headerIcon} />
				<Text style={styles.title}>Benutzer &amp; Anträge</Text>
			</View>
			<Text style={styles.subtitle}>Verwalten Sie hier die Mitglieder des Teams und ihre Anträge.</Text>

            <View style={styles.grid}>
                {baseLinks.filter(link => can(link.perm)).map(link => (
                    <TouchableOpacity key={link.to} style={styles.card} onPress={() => navigation.navigate(link.to)}>
                        <Icon name={link.icon} size={48} color={colors.primary} />
                        <Text style={styles.cardTitle}>{link.label}</Text>
                    </TouchableOpacity>
                ))}
            </View>
		</ScrollView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { flexDirection: 'row', alignItems: 'center' },
        headerIcon: { color: colors.heading, marginRight: 12 },
        grid: {
            flexDirection: 'row',
            flexWrap: 'wrap',
            justifyContent: 'space-between',
        },
        card: {
            width: '48%',
            backgroundColor: colors.surface,
            borderRadius: 8,
            paddingVertical: 32,
            paddingHorizontal: 16,
            marginBottom: 16,
            alignItems: 'center',
            justifyContent: 'center',
            borderWidth: 1,
            borderColor: colors.border,
        },
        cardTitle: {
            fontSize: 16,
            fontWeight: 'bold',
            textAlign: 'center',
            color: colors.text,
            marginTop: 16,
        },
    });
}

export default AdminUsersIndex;
========================================================================
FILE: frontend\src\pages\admin\AdminUsersPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert, TextInput } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import UserModal from '../../components/admin/users/UserModal';
import useAdminData from '../../hooks/useAdminData';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';
import Icon from 'react-native-vector-icons/FontAwesome5';

const SuspendUserModal = ({ isOpen, onClose, user, onSuccess }) => {
    const theme = useAuthStore(state => state.theme);
    const styles = getCommonStyles(theme);
	const [duration, setDuration] = useState('7d');
	const [reason, setReason] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async () => {
		setIsSubmitting(true);
		setError('');
		try {
			const result = await apiClient.post(`/admin/users/${user.id}/suspend`, { duration, reason });
			if (result.success) {
				addToast(`Benutzer ${user.username} wurde gesperrt.`, 'success');
				onSuccess();
			} else { throw new Error(result.message); }
		} catch (err) {
			setError(err.message || 'Sperren fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={`Benutzer sperren: ${user.username}`}>
			<View>
				{error && <Text style={styles.errorText}>{error}</Text>}
				<Text style={styles.label}>Dauer (z.B. 1h, 7d, indefinite)</Text>
				<TextInput style={styles.input} value={duration} onChangeText={setDuration} />
				<Text style={styles.label}>Grund</Text>
				<TextInput style={[styles.input, styles.textArea]} value={reason} onChangeText={setReason} multiline/>
				<TouchableOpacity style={[styles.button, styles.dangerButton]} onPress={handleSubmit} disabled={isSubmitting}>
                    {isSubmitting ? <ActivityIndicator color="#fff"/> : <Text style={styles.buttonText}>Benutzer sperren</Text>}
				</TouchableOpacity>
			</View>
		</Modal>
	);
};

const AdminUsersPage = () => {
    const navigation = useNavigation();
	const apiCall = useCallback(() => apiClient.get('/users'), []);
	const { data: users, loading, error, reload } = useApi(apiCall);
	const adminFormData = useAdminData();
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingUser, setEditingUser] = useState(null);
    const [suspendingUser, setSuspendingUser] = useState(null);

	const openModal = (user = null) => { setEditingUser(user); setIsModalOpen(true); };
	const handleSuccess = () => { setIsModalOpen(false); setEditingUser(null); setSuspendingUser(null); reload(); };

	const handleResetPassword = (user) => {
        Alert.alert(`Passwort für ${user.username} zurücksetzen?`, "Ein neues, temporäres Passwort wird generiert.", [
            { text: 'Abbrechen', style: 'cancel' },
            { text: 'Zurücksetzen', onPress: async () => {
                try {
                    const result = await apiClient.post(`/users/${user.id}/reset-password`);
                    if (result.success) {
                        Alert.alert('Passwort zurückgesetzt', `Das neue Passwort für ${result.data.username} ist: ${result.data.newPassword}\n\nBitte geben Sie es sicher weiter.`, [{text: 'OK'}]);
                        addToast('Passwort zurückgesetzt.', 'success');
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
            }},
        ]);
	};
    
    const handleUnsuspend = (user) => {
        Alert.alert(`Benutzer "${user.username}" entsperren?`, "", [
            { text: 'Abbrechen', style: 'cancel' },
            { text: 'Entsperren', onPress: async () => {
                try {
                    const result = await apiClient.post(`/admin/users/${user.id}/unsuspend`);
                    if (result.success) {
                        addToast('Benutzer erfolgreich entsperrt.', 'success');
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Entsperren fehlgeschlagen: ${err.message}`, 'error'); }
            }},
        ]);
    }
    
    const renderItem = ({ item: user }) => {
        const isLocked = user.isLocked || user.status === 'SUSPENDED';
        return (
            <View style={styles.card}>
                <View style={{flexDirection: 'row', justifyContent: 'space-between'}}>
                    <Text style={styles.cardTitle}>{user.username}</Text>
                    <Text style={isLocked ? styles.badgeDanger : styles.badgeSuccess}>{isLocked ? 'Gesperrt' : 'Aktiv'}</Text>
                </View>
                <Text>ID: {user.id} | Rolle: {user.roleName}</Text>
                <View style={styles.actionsContainer}>
                    <TouchableOpacity style={styles.actionButton} onPress={() => openModal(user)}><Text>Bearbeiten</Text></TouchableOpacity>
                    <TouchableOpacity style={styles.actionButton} onPress={() => navigation.navigate('UserProfile', { userId: user.id })}><Text>Profil</Text></TouchableOpacity>
                    <TouchableOpacity style={styles.actionButton} onPress={() => handleResetPassword(user)}><Text>Reset PW</Text></TouchableOpacity>
                    {isLocked ? (
                        <TouchableOpacity style={[styles.actionButton, {backgroundColor: colors.success}]} onPress={() => handleUnsuspend(user)}><Text style={{color: colors.white}}>Entsperren</Text></TouchableOpacity>
                    ) : (
                        <TouchableOpacity style={[styles.actionButton, {backgroundColor: colors.warning}]} onPress={() => setSuspendingUser(user)} disabled={user.roleName === 'ADMIN'}><Text style={{color: colors.black}}>Sperren</Text></TouchableOpacity>
                    )}
                </View>
            </View>
        );
    };

	return (
		<View style={styles.container}>
			<TouchableOpacity style={[styles.button, styles.successButton, {margin: 16}]} onPress={() => openModal()}>
                <Icon name="user-plus" size={16} color="#fff" />
                <Text style={styles.buttonText}>Neuen Benutzer anlegen</Text>
            </TouchableOpacity>
			{(loading || adminFormData.loading) && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}
			<FlatList data={users} renderItem={renderItem} keyExtractor={item => item.id.toString()} contentContainerStyle={{paddingHorizontal: 16}} />
			{isModalOpen && !adminFormData.loading && <UserModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSuccess={handleSuccess} user={editingUser} roles={adminFormData.roles} groupedPermissions={adminFormData.groupedPermissions} />}
            {suspendingUser && <SuspendUserModal isOpen={!!suspendingUser} onClose={() => setSuspendingUser(null)} onSuccess={handleSuccess} user={suspendingUser} />}
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        badgeSuccess: { backgroundColor: colors.success, color: colors.white, paddingHorizontal: 8, paddingVertical: 4, borderRadius: 12, overflow: 'hidden' },
        badgeDanger: { backgroundColor: colors.danger, color: colors.white, paddingHorizontal: 8, paddingVertical: 4, borderRadius: 12, overflow: 'hidden' },
        actionsContainer: { flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginTop: 12 },
        actionButton: { backgroundColor: colors.primaryLight, padding: 8, borderRadius: 6 },
    });
};

export default AdminUsersPage;
========================================================================
FILE: frontend\src\pages\admin\AdminVenuesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import VenueModal from '../../components/admin/venues/VenueModal';
import { useToast } from '../../context/ToastContext';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';

const AdminVenuesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/venues'), []);
	const { data: venues, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingVenue, setEditingVenue] = useState(null);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const commonStyles = getCommonStyles(theme);
    const styles = { ...commonStyles, ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const openModal = (venue = null) => {
		setEditingVenue(venue);
		setIsModalOpen(true);
	};
    
    const handleSuccess = () => {
        setIsModalOpen(false);
        setEditingVenue(null);
        reload();
    };

	const handleDelete = (venue) => {
        Alert.alert(`Ort "${venue.name}" löschen?`, "", [
            { text: 'Abbrechen', style: 'cancel' },
            { text: 'Löschen', style: 'destructive', onPress: async () => {
                try {
                    const result = await apiClient.delete(`/admin/venues/${venue.id}`);
                    if (result.success) {
                        addToast('Ort erfolgreich gelöscht', 'success');
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
            }}
        ]);
	};
    
    const renderItem = ({ item }) => (
        <View style={styles.card}>
            <Text style={styles.cardTitle}>{item.name}</Text>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Adresse:</Text>
                <Text style={styles.value} numberOfLines={1}>{item.address || '-'}</Text>
            </View>
            <View style={styles.detailRow}>
                <Text style={styles.label}>Karte:</Text>
                <Text style={styles.value}>{item.mapImagePath ? 'Ja' : 'Nein'}</Text>
            </View>
             <View style={styles.cardActions}>
                <TouchableOpacity style={[styles.button, styles.secondaryButton]} onPress={() => openModal(item)}><Text style={styles.buttonText}>Bearbeiten</Text></TouchableOpacity>
                <TouchableOpacity style={[styles.button, styles.dangerOutlineButton]} onPress={() => handleDelete(item)}><Text style={styles.dangerOutlineButtonText}>Löschen</Text></TouchableOpacity>
            </View>
        </View>
    );

	return (
		<View style={styles.container}>
            <View style={styles.headerContainer}>
                <Icon name="map-marked-alt" size={24} style={styles.headerIcon} />
			    <Text style={styles.title}>Veranstaltungsorte</Text>
            </View>
			<Text style={styles.subtitle}>Verwalten Sie hier die Orte und die zugehörigen Raumpläne.</Text>
            <TouchableOpacity style={[styles.button, styles.successButton, { alignSelf: 'flex-start' }]} onPress={() => openModal()}>
                <Icon name="plus" size={16} color="#fff" />
                <Text style={styles.buttonText}>Neuer Ort</Text>
            </TouchableOpacity>

			{loading && <ActivityIndicator size="large" />}
			{error && <Text style={styles.errorText}>{error}</Text>}

			<FlatList
                data={venues}
                renderItem={renderItem}
                keyExtractor={item => item.id.toString()}
            />

			{isModalOpen && <VenueModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSuccess={handleSuccess} venue={editingVenue} />}
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        container: { flex: 1, padding: spacing.md },
        headerContainer: { flexDirection: 'row', alignItems: 'center', marginBottom: spacing.sm },
        headerIcon: { color: colors.heading, marginRight: 12 },
        cardActions: { flexDirection: 'row', justifyContent: 'flex-end', gap: 8, marginTop: 16 },
    });
};

export default AdminVenuesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminWikiPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator, TextInput, Alert } from 'react-native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import MarkdownDisplay from 'react-native-markdown-display';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';
import WikiPageModal from '../../components/admin/wiki/WikiPageModal';

const WikiTreeNode = ({ name, node, onSelect, selectedId, level = 0 }) => {
    const theme = useAuthStore(state => state.theme);
    const colors = getThemeColors(theme);
    const styles = pageStyles(theme);
    const [isOpen, setIsOpen] = useState(true);

    if (node.id) { // It's a file
        return (
            <TouchableOpacity onPress={() => onSelect(node)} style={[styles.treeItem, { paddingLeft: level * spacing.md }, selectedId === node.id && styles.activeTreeItem]}>
                <Icon name="file-alt" style={styles.treeIcon} />
                <Text style={{color: colors.text}}>{name}</Text>
            </TouchableOpacity>
        );
    }

    // It's a directory
    return (
        <View>
            <TouchableOpacity onPress={() => setIsOpen(!isOpen)} style={[styles.treeItem, { paddingLeft: level * spacing.md }]}>
                <Icon name={isOpen ? "folder-open" : "folder"} solid style={styles.treeIcon} />
                <Text style={{fontWeight: 'bold', color: colors.text}}>{name}</Text>
            </TouchableOpacity>
            {isOpen && (
                <View>
                    {Object.entries(node).map(([childName, childNode]) => (
                        <WikiTreeNode key={childName} name={childName} node={childNode} onSelect={onSelect} selectedId={selectedId} level={level + 1} />
                    ))}
                </View>
            )}
        </View>
    );
};

const AdminWikiPage = () => {
	const treeApiCall = useCallback(() => apiClient.get('/wiki'), []);
	const { data: wikiTree, loading, error, reload } = useApi(treeApiCall);
	const [selectedEntry, setSelectedEntry] = useState(null);
	const [isEditing, setIsEditing] = useState(false);
	const [editContent, setEditContent] = useState('');
	const [isModalOpen, setIsModalOpen] = useState(false);
	const { addToast } = useToast();
    const theme = useAuthStore(state => state.theme);
    const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };

	const handleSelectEntry = async (entry) => {
		try {
			const result = await apiClient.get(`/wiki/${entry.id}`);
			if (result.success) {
				setSelectedEntry(result.data);
				setEditContent(result.data.content);
				setIsEditing(false);
			}
		} catch (err) { addToast(`Fehler beim Laden: ${err.message}`, 'error'); }
	};

	const handleSave = async () => {
		if (!selectedEntry) return;
		try {
			const result = await apiClient.put(`/wiki/${selectedEntry.id}`, { content: editContent });
			if (result.success) {
				addToast('Seite gespeichert', 'success');
				await handleSelectEntry(selectedEntry);
			} else { throw new Error(result.message); }
		} catch (err) { addToast(`Fehler beim Speichern: ${err.message}`, 'error'); }
	};
    
	const handleDelete = () => {
        if (!selectedEntry) return;
        Alert.alert(`Seite "${selectedEntry.filePath}" löschen?`, "", [
            { text: 'Abbrechen', style: 'cancel' },
            { text: 'Löschen', style: 'destructive', onPress: async () => {
                try {
                    const result = await apiClient.delete(`/wiki/${selectedEntry.id}`);
                    if (result.success) {
                        addToast('Seite gelöscht', 'success');
                        setSelectedEntry(null);
                        reload();
                    } else { throw new Error(result.message); }
                } catch (err) { addToast(`Fehler: ${err.message}`, 'error'); }
            }}
        ]);
	};
    
	if (loading) return <View style={styles.centered}><ActivityIndicator size="large"/></View>;
	if (error) return <View style={styles.centered}><Text style={styles.errorText}>{error}</Text></View>;

    if (!selectedEntry) {
        return (
            <View style={styles.container}>
                <View style={styles.sidebarHeader}>
                    <Text style={styles.title}>Wiki-Verzeichnis</Text>
                    <TouchableOpacity onPress={() => setIsModalOpen(true)}><Icon name="plus" size={20} /></TouchableOpacity>
                </View>
                <ScrollView contentContainerStyle={styles.contentContainer}>
                    {wikiTree && Object.entries(wikiTree).map(([name, node]) => (
                        <WikiTreeNode key={name} name={name} node={node} onSelect={handleSelectEntry} selectedId={null} />
                    ))}
                </ScrollView>
                <WikiPageModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onSuccess={() => {setIsModalOpen(false); reload();}} parentPath={""}/>
            </View>
        );
    }

	return (
		<View style={styles.container}>
            <View style={styles.contentHeader}>
                <TouchableOpacity onPress={() => setSelectedEntry(null)}><Icon name="arrow-left" size={20} /></TouchableOpacity>
                <Text style={styles.contentTitle} numberOfLines={1}>{selectedEntry.filePath}</Text>
                <TouchableOpacity onPress={handleDelete}><Icon name="trash" size={20} color={getThemeColors(theme).danger} /></TouchableOpacity>
            </View>
			
            <View style={styles.controls}>
                {isEditing ? (
                    <>
                        <TouchableOpacity onPress={handleSave} style={[styles.button, styles.successButton]}><Text style={styles.buttonText}>Speichern</Text></TouchableOpacity>
                        <TouchableOpacity onPress={() => setIsEditing(false)} style={[styles.button, styles.secondaryButton]}><Text style={styles.buttonText}>Abbrechen</Text></TouchableOpacity>
                    </>
                ) : (
                    <TouchableOpacity onPress={() => setIsEditing(true)} style={[styles.button, styles.secondaryButton]}><Text style={styles.buttonText}>Bearbeiten</Text></TouchableOpacity>
                )}
            </View>
			
            {isEditing ? (
                <TextInput value={editContent} onChangeText={setEditContent} multiline style={styles.textArea} />
            ) : (
                <ScrollView style={{padding: spacing.md}}><MarkdownDisplay>{selectedEntry.content}</MarkdownDisplay></ScrollView>
            )}
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        sidebarHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: spacing.md },
        treeItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: spacing.sm },
        activeTreeItem: { backgroundColor: colors.primaryLight },
        treeIcon: { marginRight: spacing.sm, color: colors.textMuted, width: 20 },
        contentHeader: { flexDirection: 'row', alignItems: 'center', gap: spacing.md, padding: spacing.md, borderBottomWidth: 1, borderColor: colors.border },
        contentTitle: { fontSize: typography.h4, fontWeight: 'bold', flex: 1 },
        controls: { flexDirection: 'row', gap: spacing.sm, padding: spacing.md },
        textArea: { flex: 1, padding: spacing.md, fontSize: 14, fontFamily: 'monospace', color: colors.text, textAlignVertical: 'top', borderWidth: 1, borderColor: colors.border, borderRadius: 8 },
    });
};

export default AdminWikiPage;
========================================================================
FILE: frontend\src\pages\error\ErrorPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getThemeColors } from '../../styles/theme';

const ErrorPage = ({ navigation, error: propError }) => {
    const defaultError = { message: "Ein unbekannter Fehler ist aufgetreten." };
	const error = propError || defaultError;
	console.error(error);
    const theme = useAuthStore(state => state.theme);
    const pageStyles = styles(theme);

	const errorMessage = error?.message || "Ein unbekannter Fehler ist aufgetreten.";

	const lines = useMemo(() => [
		{ text: 'SYSTEMDIAGNOSE WIRD GESTARTET...', style: pageStyles.info },
		{ text: 'Speichermodule werden gescannt...', style: pageStyles.info, delayAfter: 500 },
		{ text: '[OK] Speicherintegritätsprüfung bestanden.', style: pageStyles.ok },
		{ text: 'Anwendungsstatus wird überprüft...', style: pageStyles.info, delayAfter: 500 },
		{ text: `[FEHLER] Unbehandelte Ausnahme erkannt: ${errorMessage}`, style: pageStyles.fail, delayAfter: 800 },
		{ text: 'FEHLER 500: Interner Serverfehler.', style: pageStyles.fail },
		{ text: 'Ein kritischer Fehler ist aufgetreten.', style: pageStyles.info },
		{ text: 'Wiederherstellungsoptionen werden vorbereitet...', style: pageStyles.warn },
	], [errorMessage, pageStyles]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<View style={pageStyles.terminal}>
			<View style={pageStyles.terminalHeader}>
				<View style={[pageStyles.headerDot, pageStyles.redDot]} />
				<View style={[pageStyles.headerDot, pageStyles.yellowDot]} />
				<View style={[pageStyles.headerDot, pageStyles.greenDot]} />
				<Text style={pageStyles.headerTitle}>SYSTEM_DIAGNOSTIC.LOG</Text>
			</View>
			<ScrollView style={pageStyles.terminalBody} ref={containerRef} contentContainerStyle={{ flexGrow: 1 }}>
				{renderedLines.map((line, index) => (
					<View key={index} style={pageStyles.terminalLine}>
						<Text style={pageStyles.prompt}>{'>'}</Text>
						<Text style={[pageStyles.lineText, line.style]}>{line.text}</Text>
						{index === renderedLines.length - 1 && !isComplete && <View style={pageStyles.cursor} />}
					</View>
				))}
			</ScrollView>
			{isComplete && (
				<TouchableOpacity style={pageStyles.button} onPress={() => navigation.navigate('Dashboard')}>
					<Icon name="home" size={16} color="#fff" />
					<Text style={pageStyles.buttonText}>Zum Dashboard</Text>
				</TouchableOpacity>
			)}
		</View>
	);
};

const getTerminalColors = () => ({
    terminalBg: '#010409',
    terminalHeaderBg: '#0d1117',
    terminalBorder: '#30363d',
    terminalText: '#c9d1d9',
    terminalTextMuted: '#8b949e',
    terminalPrompt: '#58a6ff',
});

const styles = (theme) => {
    const terminalColors = getTerminalColors();
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        terminal: { backgroundColor: terminalColors.terminalBg, borderWidth: 1, borderColor: terminalColors.terminalBorder, borderRadius: 8, padding: 16, width: '100%', maxWidth: 800, maxHeight: '80%' },
        terminalHeader: { flexDirection: 'row', alignItems: 'center', paddingBottom: 16, borderBottomWidth: 1, borderColor: terminalColors.terminalBorder, marginBottom: 16 },
        headerDot: { width: 12, height: 12, borderRadius: 6, marginRight: 8 },
        redDot: { backgroundColor: '#ff5f56' },
        yellowDot: { backgroundColor: '#ffbd2e' },
        greenDot: { backgroundColor: '#27c93f' },
        headerTitle: { color: terminalColors.terminalTextMuted, flex: 1, textAlign: 'center' },
        terminalBody: { flex: 1 },
        terminalLine: { flexDirection: 'row', marginBottom: 4 },
        prompt: { color: terminalColors.terminalPrompt, marginRight: 8 },
        lineText: { color: terminalColors.terminalText, flexShrink: 1, fontFamily: 'monospace' },
        cursor: { width: 8, height: 18, backgroundColor: terminalColors.terminalText, marginLeft: 2 },
        button: { opacity: 1, marginTop: 16, backgroundColor: colors.primary, paddingVertical: 10, paddingHorizontal: 20, borderRadius: 6, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8 },
        buttonText: { color: colors.white, fontWeight: '500' },
        info: { color: terminalColors.terminalTextMuted },
        ok: { color: colors.success },
        warn: { color: colors.warning },
        fail: { color: colors.danger },
    });
};

export default ErrorPage;
========================================================================
FILE: frontend\src\pages\error\ErrorTrigger.jsx
========================================================================

import { useEffect } from 'react';
import { View } from 'react-native';

const ErrorTrigger = () => {
	useEffect(() => {
		// This will cause a rendering error that the boundary will catch.
		throw new Error("Dies ist ein simulierter Rendering-Fehler zum Testen der 500-Seite.");
	}, []);

	return <View />; // Must return a valid component
};

export default ErrorTrigger;
========================================================================
FILE: frontend\src\pages\error\ForbiddenPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, SafeAreaView, StatusBar } from 'react-native';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import { useAuthStore } from '../../store/authStore';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { getThemeColors } from '../../styles/theme';

const ForbiddenPage = ({ navigation }) => {
	const user = useAuthStore(state => state.user);
    const theme = useAuthStore(state => state.theme);
    const isDarkMode = theme === 'dark';
    const pageStyles = styles(theme);

	const lines = useMemo(() => [
		{ text: 'Zugriffsversuch auf geschützten Bereich...', style: pageStyles.info },
		{ text: `Benutzer wird authentifiziert: ${user?.username || 'GAST'}`, style: pageStyles.info, delayAfter: 500 },
		{ text: 'Berechtigungsstufe wird geprüft...', style: pageStyles.info, delayAfter: 800 },
		{ text: '[ZUGRIFF VERWEIGERT]', style: pageStyles.fail, speed: 80 },
		{ text: 'FEHLER 403: Unzureichende Berechtigungen.', style: pageStyles.fail },
		{ text: 'Ihre aktuelle Rolle gewährt keinen Zugriff auf diese Ressource.', style: pageStyles.warn },
		{ text: 'Dieser Versuch wurde protokolliert.', style: pageStyles.info },
	], [user, pageStyles]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<SafeAreaView style={pageStyles.fullScreenTerminal}>
            <StatusBar barStyle={isDarkMode ? 'light-content' : 'dark-content'} />
			<View style={pageStyles.terminalHeader}>
				<View style={[pageStyles.headerDot, pageStyles.redDot]} />
				<View style={[pageStyles.headerDot, pageStyles.yellowDot]} />
				<View style={[pageStyles.headerDot, pageStyles.greenDot]} />
				<Text style={pageStyles.headerTitle}>SECURITY.LOG</Text>
			</View>
			<ScrollView style={pageStyles.terminalBody} ref={containerRef} contentContainerStyle={{ flexGrow: 1 }}>
				{renderedLines.map((line, index) => (
					<View key={index} style={pageStyles.terminalLine}>
						<Text style={pageStyles.prompt}>{'>'}</Text>
						<Text style={[pageStyles.lineText, line.style]}>{line.text}</Text>
						{index === renderedLines.length - 1 && !isComplete && <View style={pageStyles.cursor} />}
					</View>
				))}
			</ScrollView>
			<View style={pageStyles.terminalFooter}>
				{isComplete && (
					<TouchableOpacity style={pageStyles.button} onPress={() => navigation.navigate('Dashboard')}>
						<Icon name="arrow-left" size={16} color="#fff" />
						<Text style={pageStyles.buttonText}>Zurück zum sicheren Bereich</Text>
					</TouchableOpacity>
				)}
			</View>
		</SafeAreaView>
	);
};

const getTerminalColors = () => ({
    terminalBg: '#010409',
    terminalHeaderBg: '#0d1117',
    terminalBorder: '#30363d',
    terminalText: '#c9d1d9',
    terminalTextMuted: '#8b949e',
    terminalPrompt: '#58a6ff',
});

const styles = (theme) => {
    const terminalColors = getTerminalColors();
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        fullScreenTerminal: { flex: 1, backgroundColor: terminalColors.terminalBg },
        terminalHeader: { flexDirection: 'row', alignItems: 'center', padding: 16, backgroundColor: terminalColors.terminalHeaderBg, borderBottomWidth: 1, borderColor: terminalColors.terminalBorder },
        headerDot: { width: 12, height: 12, borderRadius: 6, marginRight: 8 },
        redDot: { backgroundColor: '#ff5f56' },
        yellowDot: { backgroundColor: '#ffbd2e' },
        greenDot: { backgroundColor: '#27c93f' },
        headerTitle: { color: terminalColors.terminalTextMuted, flex: 1, textAlign: 'center' },
        terminalBody: { flex: 1, padding: 16 },
        terminalLine: { flexDirection: 'row', marginBottom: 4 },
        prompt: { color: terminalColors.terminalPrompt, marginRight: 8 },
        lineText: { color: terminalColors.terminalText, flexShrink: 1, fontFamily: 'monospace' },
        cursor: { width: 8, height: 18, backgroundColor: terminalColors.terminalText, marginLeft: 2 },
        terminalFooter: { padding: 16, borderTopWidth: 1, borderTopColor: terminalColors.terminalBorder },
        button: { opacity: 1, backgroundColor: colors.primary, paddingVertical: 10, paddingHorizontal: 20, borderRadius: 6, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8 },
        buttonText: { color: colors.white, fontWeight: '500' },
        info: { color: terminalColors.terminalTextMuted },
        warn: { color: colors.warning },
        fail: { color: colors.danger },
    });
};

export default ForbiddenPage;
========================================================================
FILE: frontend\src\pages\error\MaintenancePage.jsx
========================================================================

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, SafeAreaView } from 'react-native';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, spacing, typography } from '../../styles/theme';
import { useAuthStore } from '../../store/authStore';

const MaintenancePage = ({ navigation }) => {
    const theme = useAuthStore.getState().theme;
    const commonStyles = getCommonStyles(theme);
    const styles = { ...commonStyles, ...pageStyles(theme) };
    const colors = getThemeColors(theme);
    const message = useAuthStore.getState().maintenanceStatus.message || "Wir führen gerade einige Wartungsarbeiten durch. Die Anwendung ist in Kürze wieder für Sie verfügbar.";


	return (
		<SafeAreaView style={styles.container}>
			<View style={styles.contentContainer}>
				<Icon name="tools" size={80} color={colors.primary} style={styles.icon} />
				<Text style={styles.title}>Anwendung im Wartungsmodus</Text>
				<Text style={styles.message}>{message}</Text>
				<Text style={styles.patienceText}>Vielen Dank für Ihre Geduld!</Text>
				<View style={styles.adminSection}>
					<Text style={styles.adminText}>
						Administratoren können sich weiterhin anmelden, um den Wartungsmodus zu deaktivieren.
					</Text>
					<TouchableOpacity style={[styles.button, styles.secondaryButton]} onPress={() => navigation.navigate('Login')}>
						<Text style={styles.buttonText}>Zur Login-Seite</Text>
					</TouchableOpacity>
				</View>
			</View>
		</SafeAreaView>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        contentContainer: {
            flex: 1,
            justifyContent: 'center',
            alignItems: 'center',
            padding: spacing.lg,
        },
        icon: {
            marginBottom: spacing.xl,
        },
        title: {
            fontSize: typography.h1,
            fontWeight: 'bold',
            textAlign: 'center',
            marginBottom: spacing.md,
            color: colors.heading,
        },
        message: {
            fontSize: typography.h4,
            textAlign: 'center',
            color: colors.textMuted,
            marginBottom: spacing.sm,
        },
        patienceText: {
            fontSize: typography.body,
            textAlign: 'center',
            color: colors.text,
        },
        adminSection: {
            marginTop: spacing.xl,
            alignItems: 'center',
        },
        adminText: {
            fontSize: typography.small,
            color: colors.textMuted,
            textAlign: 'center',
            marginBottom: spacing.md,
        },
    });
};

export default MaintenancePage;
========================================================================
FILE: frontend\src\pages\error\NotFoundPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import Icon from 'react-native-vector-icons/FontAwesome5';
import { useAuthStore } from '../../store/authStore';
import { getThemeColors, typography, spacing } from '../../styles/theme';

const NotFoundPage = () => {
const navigation = useNavigation();
const route = useRoute();
const path = route.name || '/unbekannt';
const theme = useAuthStore(state => state.theme);
const pageStyles = styles(theme);
const lines = useMemo(() => [
	{ text: `Führe Befehl aus: find . -name "${path}"`, style: pageStyles.info, delayAfter: 800 },
	{ text: `find: '${path}': Datei oder Verzeichnis nicht gefunden`, style: pageStyles.warn, delayAfter: 500 },
	{ text: 'FEHLER 404: Ressource nicht gefunden.', style: pageStyles.fail },
	{ text: 'Vorschlag: Die angeforderte Ressource ist nicht verfügbar.', style: pageStyles.info },
	{ text: `Führe aus: cd /home`, style: pageStyles.info },
], [path, pageStyles]);

const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

return (
	<View style={pageStyles.terminal}>
		<View style={pageStyles.terminalHeader}>
			<View style={[pageStyles.headerDot, pageStyles.redDot]} />
			<View style={[pageStyles.headerDot, pageStyles.yellowDot]} />
			<View style={[pageStyles.headerDot, pageStyles.greenDot]} />
			<Text style={pageStyles.headerTitle}>bash</Text>
		</View>
		<ScrollView style={pageStyles.terminalBody} ref={containerRef} contentContainerStyle={{ flexGrow: 1 }}>
			{renderedLines.map((line, index) => (
				<View key={index} style={pageStyles.terminalLine}>
					<Text style={pageStyles.prompt}>{index < 1 ? '$' : '>'}</Text>
					<Text style={[pageStyles.lineText, line.style]}>{line.text}</Text>
					{index === renderedLines.length - 1 && !isComplete && <View style={pageStyles.cursor} />}
				</View>
			))}
		</ScrollView>
		{isComplete && (
			<TouchableOpacity style={pageStyles.button} onPress={() => navigation.navigate('Dashboard')}>
				<Icon name="home" size={16} color="#fff" />
				<Text style={pageStyles.buttonText}>Zum Dashboard</Text>
			</TouchableOpacity>
		)}
	</View>
);
};

const getTerminalColors = () => ({
terminalBg: '#010409',
terminalHeaderBg: '#0d1117',
terminalBorder: '#30363d',
terminalText: '#c9d1d9',
terminalTextMuted: '#8b949e',
terminalPrompt: '#58a6ff',
});

const styles = (theme) => {
const terminalColors = getTerminalColors();
const colors = getThemeColors(theme);
return StyleSheet.create({
terminal: { backgroundColor: terminalColors.terminalBg, borderWidth: 1, borderColor: terminalColors.terminalBorder, borderRadius: 8, padding: 16, width: '100%', maxWidth: 800, maxHeight: '80%' },
terminalHeader: { flexDirection: 'row', alignItems: 'center', paddingBottom: 16, borderBottomWidth: 1, borderColor: terminalColors.terminalBorder, marginBottom: 16 },
headerDot: { width: 12, height: 12, borderRadius: 6, marginRight: 8 },
redDot: { backgroundColor: '#ff5f56' },
yellowDot: { backgroundColor: '#ffbd2e' },
greenDot: { backgroundColor: '#27c93f' },
headerTitle: { color: terminalColors.terminalTextMuted, flex: 1, textAlign: 'center' },
terminalBody: { flex: 1 },
terminalLine: { flexDirection: 'row', marginBottom: 4 },
prompt: { color: terminalColors.terminalPrompt, marginRight: 8 },
lineText: { color: terminalColors.terminalText, flexShrink: 1, fontFamily: 'monospace' },
cursor: { width: 8, height: 18, backgroundColor: terminalColors.terminalText, marginLeft: 2 },
button: { opacity: 1, marginTop: 16, backgroundColor: colors.primary, paddingVertical: 10, paddingHorizontal: 20, borderRadius: 6, flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8 },
buttonText: { color: colors.white, fontWeight: '500' },
info: { color: terminalColors.terminalTextMuted },
warn: { color: colors.warning },
fail: { color: colors.danger },
});
};

export default NotFoundPage;
========================================================================
FILE: frontend\src\pages\files\FileEditorPage.jsx
========================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, TextInput, StyleSheet, ScrollView, TouchableOpacity, ActivityIndicator } from 'react-native';
import { useRoute, useNavigation } from '@react-navigation/native';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import MarkdownDisplay from 'react-native-markdown-display';
import { useAuthStore } from '../../store/authStore';
import { getCommonStyles } from '../../styles/commonStyles';
import { getThemeColors, typography, spacing } from '../../styles/theme';

const FileEditorPage = () => {
	const route = useRoute();
    const navigation = useNavigation();
	const { fileId } = route.params;
	const { addToast } = useToast();
	const { isAdmin } = useAuthStore();
	const [content, setContent] = useState('');
	const [initialContent, setInitialContent] = useState(null);
	const [viewMode, setViewMode] = useState('edit');
	const [saveStatus, setSaveStatus] = useState('idle');
	const [error, setError] = useState('');

	const theme = useAuthStore(state => state.theme);
	const styles = { ...getCommonStyles(theme), ...pageStyles(theme) };
    const colors = getThemeColors(theme);

	const apiCall = useCallback(() => {
		const endpoint = isAdmin ? `/admin/files/content/${fileId}` : `/public/files/content/${fileId}`;
		return apiClient.get(endpoint);
	}, [fileId, isAdmin]);

	const { data: fileData, loading, error: fetchError } = useApi(apiCall);

	useEffect(() => {
		if (fileData?.content !== null && fileData?.content !== undefined) {
			setContent(fileData.content);
			setInitialContent(fileData.content);
		}
	}, [fileData]);

	const handleSave = useCallback(async () => {
		if (saveStatus === 'saving' || content === initialContent) return;

		setSaveStatus('saving');
		setError('');
		try {
			const endpoint = isAdmin ? `/admin/files/content/${fileId}` : `/public/files/content/${fileId}`;
			const result = await apiClient.put(endpoint, { content });
			if (result.success) {
				setInitialContent(content);
				setSaveStatus('saved');
				setTimeout(() => setSaveStatus('idle'), 2000);
			} else { throw new Error(result.message); }
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen.');
			setSaveStatus('idle');
			addToast(`Fehler beim Speichern: ${err.message}`, 'error');
		}
	}, [fileId, isAdmin, content, initialContent, saveStatus, addToast]);

    useEffect(() => {
		const interval = setInterval(handleSave, 5000);
		return () => clearInterval(interval);
	}, [handleSave]);

	const getSaveButtonContent = () => {
		switch (saveStatus) {
			case 'saving': return <ActivityIndicator color="#fff" />;
			case 'saved': return <Text style={styles.buttonText}>Gespeichert!</Text>;
			default: return <Text style={styles.buttonText}>Jetzt Speichern</Text>;
		}
	};

	if (loading) return <View style={styles.centered}><ActivityIndicator size="large" /></View>;
	if (fetchError) return <View style={styles.centered}><Text style={styles.errorText}>{fetchError}</Text></View>;

	return (
		<View style={styles.container}>
            <View style={styles.header}>
                <Text style={styles.title}>Editor: {fileData?.filename}</Text>
            </View>
            <View style={styles.controls}>
                <View style={styles.tabs}>
                    <TouchableOpacity style={[styles.tabButton, viewMode === 'edit' && styles.activeTab]} onPress={() => setViewMode('edit')}>
                        <Text style={[styles.tabText, viewMode === 'edit' && {color: colors.white}]}>Bearbeiten</Text>
                    </TouchableOpacity>
                    <TouchableOpacity style={[styles.tabButton, viewMode === 'preview' && styles.activeTab]} onPress={() => setViewMode('preview')}>
                        <Text style={[styles.tabText, viewMode === 'preview' && {color: colors.white}]}>Vorschau</Text>
                    </TouchableOpacity>
                </View>
                <TouchableOpacity style={[styles.button, saveStatus === 'saved' ? styles.successButton : styles.primaryButton]} onPress={handleSave} disabled={saveStatus === 'saving' || content === initialContent}>
                    {getSaveButtonContent()}
                </TouchableOpacity>
            </View>
            {error && <Text style={styles.errorText}>{error}</Text>}

			<View style={styles.editorContainer}>
				{viewMode === 'edit' ? (
					<TextInput value={content} onChangeText={setContent} style={styles.textArea} multiline textAlignVertical="top" />
				) : (
					<ScrollView><View style={{padding: 10}}><MarkdownDisplay>{content}</MarkdownDisplay></View></ScrollView>
				)}
			</View>
		</View>
	);
};

const pageStyles = (theme) => {
    const colors = getThemeColors(theme);
    return StyleSheet.create({
        header: { padding: 16 },
        controls: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 16, marginBottom: 16 },
        tabs: { flexDirection: 'row', borderWidth: 1, borderColor: colors.border, borderRadius: 8, overflow: 'hidden' },
        tabButton: { paddingVertical: 8, paddingHorizontal: 16 },
        activeTab: { backgroundColor: colors.primary },
        tabText: { color: colors.text },
        editorContainer: { flex: 1, borderWidth: 1, borderColor: colors.border, margin: 16, borderRadius: 8, backgroundColor: colors.surface },
        textArea: { flex: 1, padding: 10, fontSize: 14, fontFamily: 'monospace', color: colors.text },
    });
};

export default FileEditorPage;
========================================================================
FILE: frontend\src\router\AdminRoute.jsx
========================================================================

import React from 'react';
import { useAuthStore } from '../store/authStore';
import ForbiddenPage from '../pages/error/ForbiddenPage';

const AdminRoute = ({ children }) => {
	const isAdmin = useAuthStore((state) => state.isAdmin);

	// In React Navigation, we render the component directly
	// instead of using a Navigate component. The navigator
	// will handle displaying this screen.
	if (!isAdmin) {
		return <ForbiddenPage />;
	}

	return children;
};

export default AdminRoute;
========================================================================
FILE: frontend\src\router\index.jsx
========================================================================

import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { useAuthStore } from '../store/authStore';

// Custom Components
import Sidebar from '../components/layout/Sidebar';
import Header from '../components/layout/Header'; // Import the custom header

// --- Import ALL Screen Components ---
import LoginPage from '../pages/LoginPage';
import DashboardPage from '../pages/DashboardPage';
// ... import all other pages ...
import AnnouncementsPage from '../pages/AnnouncementsPage';
import NotificationsPage from '../pages/NotificationsPage';
import TeamDirectoryPage from '../pages/TeamDirectoryPage';
import UserProfilePage from '../pages/UserProfilePage';
import ChatPage from '../pages/ChatPage';
import LehrgaengePage from '../pages/LehrgaengePage';
import MeetingDetailsPage from '../pages/MeetingDetailsPage';
import EventsPage from '../pages/EventsPage';
import EventDetailsPage from '../pages/EventDetailsPage';
import StoragePage from '../pages/StoragePage';
import StorageItemDetailsPage from '../pages/StorageItemDetailsPage';
import FilesPage from '../pages/FilesPage';
import FileEditorPage from '../pages/files/FileEditorPage';
import CalendarPage from '../pages/CalendarPage';
import FeedbackPage from '../pages/FeedbackPage';
import EventFeedbackPage from '../pages/EventFeedbackPage';
import ChangelogPage from '../pages/ChangelogPage';
import ProfilePage from '../pages/ProfilePage';
import SettingsPage from '../pages/SettingsPage';
import PasswordPage from '../pages/PasswordPage';
import SearchResultsPage from '../pages/SearchResultsPage';
import HelpListPage from '../pages/HelpListPage';
import HelpDetailsPage from '../pages/HelpDetailsPage';
import AdminDashboardPage from '../pages/admin/AdminDashboardPage';
import AdminUsersIndex from '../pages/admin/AdminUsersIndex';
import AdminEventsIndex from '../pages/admin/AdminEventsIndex';
import AdminStorageIndex from '../pages/admin/AdminStorageIndex';
import AdminCoursesIndex from '../pages/admin/AdminCoursesIndex';
import AdminContentIndex from '../pages/admin/AdminContentIndex';
import AdminReportsIndex from '../pages/admin/AdminReportsIndex';
import AdminSystemIndex from '../pages/admin/AdminSystemIndex';
import PackKitPage from '../pages/PackKitPage';
import QrActionPage from '../pages/QrActionPage';
import ForbiddenPage from '../pages/error/ForbiddenPage';
import MaintenancePage from '../pages/error/MaintenancePage';


const Drawer = createDrawerNavigator();
const Stack = createStackNavigator();

const MainDrawerNavigator = () => {
    return (
        <Drawer.Navigator
            drawerContent={(props) => <Sidebar {...props} />}
            screenOptions={{
                // Use our custom Header component for all screens in the drawer
                header: (props) => <Header {...props} />,
                headerShown: true
            }}
        >
            {/* User Screens */}
            <Drawer.Screen name="Dashboard" component={DashboardPage} />
            <Drawer.Screen name="Anschlagbrett" component={AnnouncementsPage} />
            <Drawer.Screen name="Benachrichtigungen" component={NotificationsPage} />
            <Drawer.Screen name="Team" component={TeamDirectoryPage} />
            <Drawer.Screen name="Chat" component={ChatPage} />
            <Drawer.Screen name="Lehrgänge" component={LehrgaengePage} />
            <Drawer.Screen name="Veranstaltungen" component={EventsPage} />
            <Drawer.Screen name="Lager" component={StoragePage} />
            <Drawer.Screen name="Dateien" component={FilesPage} />
            <Drawer.Screen name="Kalender" component={CalendarPage} />
            <Drawer.Screen name="Feedback" component={FeedbackPage} />
            <Drawer.Screen name="Changelogs" component={ChangelogPage} />

            {/* Admin Index Screens */}
            <Drawer.Screen name="Admin Dashboard" component={AdminDashboardPage} />
            <Drawer.Screen name="Benutzer & Anträge" component={AdminUsersIndex} />
            <Drawer.Screen name="Event Management" component={AdminEventsIndex} />
            <Drawer.Screen name="Lager & Material" component={AdminStorageIndex} />
            <Drawer.Screen name="Lehrgänge & Skills" component={AdminCoursesIndex} />
            <Drawer.Screen name="Inhalte & Kommunikation" component={AdminContentIndex} />
            <Drawer.Screen name="Berichte" component={AdminReportsIndex} />
            <Drawer.Screen name="System & Entwicklung" component={AdminSystemIndex} />
        </Drawer.Navigator>
    );
};

const AppStack = () => {
    return (
        <Stack.Navigator>
            <Stack.Screen name="MainDrawer" component={MainDrawerNavigator} options={{ headerShown: false }}/>
            
            {/* Detail screens that should have their own header (or no header) */}
            <Stack.Screen name="UserProfile" component={UserProfilePage} />
            <Stack.Screen name="MeetingDetails" component={MeetingDetailsPage} />
            <Stack.Screen name="EventDetails" component={EventDetailsPage} />
            <Stack.Screen name="StorageItemDetails" component={StorageItemDetailsPage} />
            <Stack.Screen name="Profile" component={ProfilePage} />
            <Stack.Screen name="Settings" component={SettingsPage} />
            <Stack.Screen name="PasswordChange" component={PasswordPage} />
            <Stack.Screen name="Search" component={SearchResultsPage} />
            <Stack.Screen name="HelpList" component={HelpListPage} />
            <Stack.Screen name="HelpDetails" component={HelpDetailsPage} />
            {/* Add other detail/stack screens here */}
        </Stack.Navigator>
    );
};

const AuthStack = () => {
    return (
        <Stack.Navigator screenOptions={{ headerShown: false }}>
            <Stack.Screen name="Login" component={LoginPage} />
        </Stack.Navigator>
    );
};

const RootNavigator = () => {
	const { isAuthenticated, maintenanceStatus, isAdmin } = useAuthStore();

    if (maintenanceStatus.mode === 'HARD' && !isAdmin) {
        return (
            <Stack.Navigator screenOptions={{ headerShown: false }}>
                <Stack.Screen name="Maintenance" component={MaintenancePage} />
                <Stack.Screen name="Login" component={LoginPage} />
            </Stack.Navigator>
        );
    }

	return isAuthenticated ? <AppStack /> : <AuthStack />;
};

export default RootNavigator;
========================================================================
FILE: frontend\src\router\navigation.js
========================================================================

import { createNavigationContainerRef } from '@react-navigation/native';

export const navigationRef = createNavigationContainerRef();

export function navigate(name, params) {
  if (navigationRef.isReady()) {
    navigationRef.navigate(name, params);
  }
}
========================================================================
FILE: frontend\src\router\pageRoutes.js
========================================================================

// This file maps static frontend routes to their corresponding documentation page keys.
// It's used by the AppLayout to show the contextual help button.
// In React Native, this would be used by a custom header component to show a help icon.

const pageRoutes = {
	// User Pages
	'Dashboard': 'dashboard',
	'Team': 'team_directory',
	'Chat': 'chat',
	'Lehrgänge': 'lehrgaenge',
	'Veranstaltungen': 'events',
	'Lager': 'storage',
	'Dateien': 'files',
	'Kalender': 'calendar',
	'Feedback': 'feedback',
	'Changelogs': 'changelogs',
	'Profile': 'profile',
	'Settings': 'settings',
	'PasswordChange': 'password_change',
	'Search': 'search_results',
	'HelpList': 'help_list',
	'HelpDetails': 'help_details',
	'Notifications': 'notifications',

	// Admin Pages (by Route Name)
	'AdminDashboard': 'admin_dashboard',
	'AdminUsersIndex': 'admin_users_index',
	'AdminUsers': 'admin_users',
	'AdminRequests': 'admin_requests',
	'AdminTrainingRequests': 'admin_training_requests',
	'AdminAchievements': 'admin_achievements',
	'AdminEventsIndex': 'admin_events_index',
	'AdminEvents': 'admin_events',
	'AdminDebriefingsList': 'admin_debriefings_list',
	'AdminEventRoles': 'admin_event_roles',
	'AdminVenues': 'admin_venues',
	'AdminChecklistTemplates': 'admin_checklist_templates',
	'AdminCoursesIndex': 'admin_courses_index',
	'AdminCourses': 'admin_courses',
	'AdminMatrix': 'admin_matrix',
	'AdminStorageIndex': 'admin_storage_index',
	'AdminStorage': 'admin_storage',
	'AdminKits': 'admin_kits',
	'AdminDefective': 'admin_defective_items',
	'AdminDamageReports': 'admin_damage_reports',
	'AdminContentIndex': 'admin_content_index',
	'AdminAnnouncements': 'admin_announcements',
	'AdminFiles': 'admin_files',
	'AdminFeedback': 'admin_feedback',
	'AdminChangelogs': 'admin_changelogs',
	'AdminDocumentation': 'admin_documentation',
	'AdminNotifications': 'admin_notifications',
	'AdminReportsIndex': 'admin_reports_index',
	'AdminReports': 'admin_reports',
	'AdminLog': 'admin_log',
	'AdminSystemIndex': 'admin_system_index',
	'AdminSystemStatus': 'admin_system',
	'AdminAuthLog': 'admin_auth_log',
	'AdminWiki': 'admin_wiki',
};

export default pageRoutes;
========================================================================
FILE: frontend\src\router\ProtectedRoute.jsx
========================================================================

import React from 'react';
import { useAuthStore } from '../store/authStore';
import LoginPage from '../pages/LoginPage';

const ProtectedRoute = ({ children }) => {
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

	// In React Navigation, the navigator itself will conditionally render
	// the auth stack (LoginPage) or the main app stack. This component
	// is a conceptual placeholder for that logic. If used directly,
	// it would render the LoginPage for unauthenticated users.
	if (!isAuthenticated) {
		return <LoginPage />;
	}

	return children;
};

export default ProtectedRoute;
========================================================================
FILE: frontend\src\services\apiClient.js
========================================================================

import { Platform } from 'react-native';

const ANDROID_API_URL = 'http://10.0.2.2:8081/TechnikTeam/api/v1';
// For web, we use a relative path. The browser will handle the host and protocol (HTTPS).
const WEB_API_URL = '/TechnikTeam/api/v1';

const BASE_URL = Platform.OS === 'web' ? WEB_API_URL : ANDROID_API_URL;

let onUnauthorizedCallback = () => {};
let onMaintenanceCallback = () => {};
let authToken = null;

const apiClient = {
	setup: function(callbacks) {
		onUnauthorizedCallback = callbacks.onUnauthorized;
		onMaintenanceCallback = callbacks.onMaintenance;
	},
	setAuthToken: function(token) {
		authToken = token;
	},
	request: async function(endpoint, options = {}) {
		const headers = { ...options.headers };
		if (authToken) {
			headers['Authorization'] = `Bearer ${authToken}`;
		}
		if (!(options.body instanceof FormData)) {
			headers['Content-Type'] = 'application/json';
		}
		try {
			const response = await fetch(`${BASE_URL}${endpoint}`, {
				...options,
				headers: headers,
			});
			const contentType = response.headers.get("content-type");
			const isJson = contentType && contentType.includes("application/json");
			if (response.status === 503) {
				onMaintenanceCallback();
				throw new Error('Die Anwendung befindet sich im Wartungsmodus.');
			}
			if (response.status === 401) {
				if (isJson) {
					const errorResult = await response.json();
					if (errorResult.message) throw new Error(errorResult.message);
				}
				onUnauthorizedCallback();
				throw new Error('Nicht autorisiert. Ihre Sitzung ist möglicherweise abgelaufen.');
			}
			if (response.status === 403) {
				if (isJson) {
					const errorResult = await response.json();
					throw new Error(errorResult.message || 'Zugriff verweigert.');
				}
				throw new Error('Zugriff verweigert.');
			}
			if (response.status === 204) {
				return { success: true, message: 'Operation successful.', data: null };
			}
			if (!isJson) {
				const textError = await response.text();
				console.error("Non-JSON API response:", textError);
				throw new Error(`Serververbindung fehlgeschlagen (Status: ${response.status}).`);
			}
			const result = await response.json();
			if (!response.ok) {
				if (response.status >= 500) {
					throw new Error("Ein interner Serverfehler ist aufgetreten.");
				}
				throw new Error(result.message || `Ein Fehler ist aufgetreten (Status: ${response.status})`);
			}
			return result;
		} catch (error) {
			if (error.message.includes('Network request failed') || error.message.includes('Failed to fetch')) {
				console.error(`API Client Network Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
				throw new Error('Netzwerkfehler: Das Backend ist nicht erreichbar.');
			}
			console.error(`API Client Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
			throw error;
		}
	},
	get(endpoint) {
		return this.request(endpoint, { method: 'GET' });
	},
	post(endpoint, body) {
		const options = { method: 'POST', body: body instanceof FormData ? body : JSON.stringify(body) };
		return this.request(endpoint, options);
	},
	put(endpoint, body) {
		return this.request(endpoint, { method: 'PUT', body: JSON.stringify(body) });
	},
	delete(endpoint) {
		return this.request(endpoint, { method: 'DELETE' });
	},
};

export default apiClient;
========================================================================
FILE: frontend\src\store\authStore.js
========================================================================

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import apiClient from '../services/apiClient';
import { storage, setToken, removeToken } from '../lib/storage';

const hasAdminAccess = (roleName) => {
	// Frontend authorization check based on role.
	return roleName === 'ADMIN';
};

const defaultLayout = {
	sidebarPosition: 'left',
	navOrder: [], // Empty array means default order
	showHelpButton: true,
	dashboardWidgets: {
		recommendedEvents: true,
		assignedEvents: true,
		openTasks: true,
		upcomingEvents: true,
		recentConversations: true,
		upcomingMeetings: true,
		lowStockItems: false,
	},
};

export const useAuthStore = create(
	persist(
		(set, get) => ({
			user: null,
			navigationItems: [],
			isAuthenticated: false,
			isAdmin: false,
			theme: 'light',
			layout: defaultLayout,
			lastUpdatedEvent: null, // { id: eventId, nonce: Math.random() }
			maintenanceStatus: { mode: 'OFF', message: '' },
			previousLogin: null,
			login: async (username, password) => {
				try {
					const response = await apiClient.post('/auth/login', { username, password });
					if (response.success && response.data) {
						if (response.message === '2FA_REQUIRED') {
							return { status: '2FA_REQUIRED', token: response.data.token };
						}
						
						const { session, token } = response.data;
						const { user, navigation, maintenanceStatus, previousLogin } = session;

						await setToken(token);
						apiClient.setAuthToken(token);

						const newTheme = user.theme || 'light';

						set({
							user: user,
							navigationItems: navigation,
							isAuthenticated: true,
							isAdmin: hasAdminAccess(user.roleName),
							theme: newTheme,
							maintenanceStatus: maintenanceStatus || { mode: 'OFF', message: '' },
							previousLogin: previousLogin,
						});
						return { status: 'SUCCESS' };
					}
					throw new Error(response.message || 'Anmeldung fehlgeschlagen');
				} catch (error) {
					console.error('Login failed:', error);
					get().logout();
					throw error;
				}
			},
			completeLoginWithToken: async (token) => {
				await setToken(token);
				apiClient.setAuthToken(token);
				await get().fetchUserSession();
			},
			logout: async () => {
				try {
					await apiClient.post('/auth/logout');
				} catch (error) {
					console.error("Logout API call failed, clearing state anyway.", error);
				} finally {
					await removeToken();
					apiClient.setAuthToken(null);
					set({ user: null, navigationItems: [], isAuthenticated: false, isAdmin: false, theme: 'light', layout: defaultLayout, lastUpdatedEvent: null, maintenanceStatus: { mode: 'OFF', message: '' }, previousLogin: null });
				}
			},
			fetchUserSession: async () => {
				try {
					const result = await apiClient.get('/auth/me');

					if (result.success && result.data.user && result.data.navigation) {
						const { user, navigation, maintenanceStatus } = result.data;
						const newTheme = user.theme || 'light';
						let userLayout = defaultLayout;
						if (user.dashboardLayout) {
							try {
								const savedLayout = JSON.parse(user.dashboardLayout);
								userLayout = {
									...defaultLayout,
									...savedLayout,
									dashboardWidgets: {
										...defaultLayout.dashboardWidgets,
										...(savedLayout.dashboardWidgets || {})
									}
								};
							} catch (e) {
								console.error("Failed to parse user layout JSON", e);
							}
						}

						set({
							user: user,
							navigationItems: navigation,
							isAuthenticated: true,
							isAdmin: hasAdminAccess(user.roleName),
							theme: newTheme,
							layout: userLayout,
							maintenanceStatus: maintenanceStatus || { mode: 'OFF', message: '' },
						});
					} else {
						throw new Error(result.message || "Ungültige Sitzungsdaten vom Server.");
					}

				} catch (error) {
					console.error("Could not fetch user session. Token might be invalid.", error);
					get().logout();
					throw error;
				}
			},
			setTheme: async (newTheme) => {
				try {
					const result = await apiClient.put('/public/profile/theme', { theme: newTheme });
					if (result.success && result.data) {
						const updatedUser = result.data;
						set({
							user: updatedUser,
							theme: updatedUser.theme,
						});
					} else {
						throw new Error(result.message || 'Server konnte das Theme nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save theme preference:", error);
				}
			},
			setLayout: async (newLayout) => {
				try {
					const result = await apiClient.put('/public/profile/layout', newLayout);
					if (result.success && result.data) {
						const updatedUser = result.data;
						let userLayout = defaultLayout;
						if (updatedUser.dashboardLayout) {
							try {
								const savedLayout = JSON.parse(updatedUser.dashboardLayout);
								userLayout = {
									...defaultLayout,
									...savedLayout,
									dashboardWidgets: {
										...defaultLayout.dashboardWidgets,
										...(savedLayout.dashboardWidgets || {})
									}
								};
							} catch (e) { console.error("Failed to parse updated layout", e); }
						}
						set({
							user: updatedUser,
							layout: userLayout,
						});
					} else {
						throw new Error(result.message || 'Server konnte das Layout nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save layout preferences:", error);
				}
			},
			triggerEventUpdate: (eventId) => {
				set({ lastUpdatedEvent: { id: eventId, nonce: Math.random() } });
			},
			setUnseenNotificationCount: (count) => {
				set(state => ({
					user: state.user ? { ...state.user, unseenNotificationsCount: count } : null
				}));
			},
			incrementUnseenNotificationCount: () => {
				set(state => ({
					user: state.user ? { ...state.user, unseenNotificationsCount: (state.user.unseenNotificationsCount || 0) + 1 } : null
				}));
			},
			setMaintenanceStatus: (status) => {
				set({ maintenanceStatus: status });
			},
		}),
		{
			name: 'auth-storage',
			storage: createJSONStorage(() => storage), // Use our universal storage wrapper
			partialize: (state) => ({ theme: state.theme }),
		}
	)
);
========================================================================
FILE: frontend\src\styles\commonStyles.js
========================================================================

import { StyleSheet } from 'react-native';
import { getThemeColors, typography, spacing, borders, shadows } from './theme';

export const getCommonStyles = (theme) => {
	const colors = getThemeColors(theme);

	return StyleSheet.create({
		// Layout & Containers
		container: {
			flex: 1,
			backgroundColor: colors.background,
		},
		contentContainer: {
			padding: spacing.md,
		},
		card: {
			backgroundColor: colors.surface,
			borderRadius: borders.radius,
			padding: spacing.md,
			marginBottom: spacing.md,
			borderWidth: borders.width,
			borderColor: colors.border,
			...shadows.sm,
		},
		centered: {
			flex: 1,
			justifyContent: 'center',
			alignItems: 'center',
		},

		// Typography
		title: {
			fontSize: typography.h2,
			fontWeight: typography.fontWeights.bold,
			color: colors.heading,
			marginBottom: spacing.md,
		},
		subtitle: {
			fontSize: typography.body,
			color: colors.textMuted,
			marginBottom: spacing.md,
		},
		bodyText: {
			fontSize: typography.body,
			color: colors.text,
			lineHeight: typography.body * 1.5,
		},
		errorText: {
			color: colors.danger,
			textAlign: 'center',
			marginVertical: spacing.sm,
		},
		infoMessage: {
			backgroundColor: colors.primaryLight,
			padding: spacing.md,
			borderRadius: borders.radius,
			color: colors.primary,
		},

		// Buttons
		button: {
			paddingVertical: 12,
			paddingHorizontal: 20,
			borderRadius: borders.radius,
			alignItems: 'center',
			justifyContent: 'center',
			flexDirection: 'row',
			gap: spacing.sm,
		},
		buttonText: {
			color: colors.white,
			fontWeight: typography.fontWeights.medium,
			fontSize: typography.body,
		},
		primaryButton: {
			backgroundColor: colors.primary,
		},
		successButton: {
			backgroundColor: colors.success,
		},
		dangerButton: {
			backgroundColor: colors.danger,
		},
		secondaryButton: {
			backgroundColor: colors.textMuted,
		},
		outlineButton: {
			backgroundColor: 'transparent',
			borderWidth: borders.width,
		},
		dangerOutlineButton: {
			borderColor: colors.danger,
		},
		dangerOutlineButtonText: {
			color: colors.danger,
		},
        disabledButton: {
            opacity: 0.65,
        },

		// Forms
		formGroup: {
			marginBottom: spacing.md,
		},
		label: {
			fontSize: typography.small,
			fontWeight: typography.fontWeights.medium,
			color: colors.textMuted,
			marginBottom: spacing.sm,
		},
		input: {
			height: 48,
			borderWidth: borders.width,
			borderColor: colors.border,
			borderRadius: borders.radius,
			paddingHorizontal: spacing.md,
			backgroundColor: colors.surface,
			color: colors.text,
			fontSize: typography.body,
		},
        textArea: {
            minHeight: 120,
            textAlignVertical: 'top',
        },
        
        // Lists
        detailsList: {
            flexDirection: 'column',
        },
        detailsListRow: {
            flexDirection: 'row',
            justifyContent: 'space-between',
            alignItems: 'center',
            paddingVertical: spacing.md,
            borderBottomWidth: borders.width,
            borderBottomColor: colors.border,
        },
        detailsListLabel: {
            fontWeight: typography.fontWeights.bold,
            color: colors.text,
        },
        detailsListValue: {
            color: colors.textMuted,
        },
	});
};
========================================================================
FILE: frontend\src\styles\theme.js
========================================================================

import { Dimensions } from 'react-native';

const { width, height } = Dimensions.get('window');

const lightColors = {
	primary: '#007bff',
	primaryHover: '#0056b3', // Note: Hover is less relevant, but good for active states
	primaryLight: 'rgba(0, 123, 255, 0.1)',
	background: '#f8f9fa',
	surface: '#ffffff',
	text: '#212529',
	heading: '#002B5B',
	textMuted: '#6c757d',
	border: '#dee2e6',
	success: '#28a745',
	danger: '#dc3545',
	warning: '#ffc107',
	info: '#0dcaf0',
	white: '#ffffff',
	black: '#000000',
};

const darkColors = {
	primary: '#58a6ff',
	primaryHover: '#80b6ff',
	primaryLight: 'rgba(88, 166, 255, 0.15)',
	background: '#0d1117',
	surface: '#161b22',
	text: '#c9d1d9',
	heading: '#58a6ff',
	textMuted: '#8b949e',
	border: '#30363d',
	success: '#56d364',
	danger: '#f87171',
	warning: '#f0b72f',
	info: '#67d4ed',
	white: '#ffffff',
	black: '#000000',
};

export const getThemeColors = (theme = 'light') => {
	return theme === 'dark' ? darkColors : lightColors;
};

export const typography = {
	h1: 28,
	h2: 24,
	h3: 20,
	h4: 18,
	body: 16,
	small: 14,
	caption: 12,
	fontWeights: {
		normal: '400',
		medium: '500',
		bold: '700',
	},
};

export const spacing = {
	xs: 4,
	sm: 8,
	md: 16,
	lg: 24,
	xl: 32,
};

export const borders = {
	radius: 8,
	width: 1,
};

export const shadows = {
	sm: {
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 1 },
		shadowOpacity: 0.18,
		shadowRadius: 1.00,
		elevation: 1,
	},
	md: {
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 2 },
		shadowOpacity: 0.23,
		shadowRadius: 2.62,
		elevation: 4,
	},
	lg: {
		shadowColor: "#000",
		shadowOffset: { width: 0, height: 4 },
		shadowOpacity: 0.30,
		shadowRadius: 4.65,
		elevation: 8,
	},
};

export const dimensions = {
	width,
	height,
};
========================================================================
FILE: src\main\java\de\technikteam\TechnikTeamApplication.java
========================================================================

package de.technikteam;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "de.technikteam")
public class TechnikTeamApplication {

	public static void main(String[] args) {
		SpringApplication.run(TechnikTeamApplication.class, args);
	}

}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAchievementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/achievements")
@Tag(name = "Admin Achievements", description = "Endpoints for managing achievements.")
@SecurityRequirement(name = "bearerAuth")
public class AdminAchievementResource {

	private final AchievementDAO achievementDAO;

	@Autowired
	public AdminAchievementResource(AchievementDAO achievementDAO) {
		this.achievementDAO = achievementDAO;
	}

	@GetMapping
	@Operation(summary = "Get all achievements", description = "Retrieves a list of all available achievements.")
	public ResponseEntity<ApiResponse> getAllAchievements() {
		List<Achievement> achievements = achievementDAO.getAllAchievements();
		return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erfolgreich abgerufen.", achievements));
	}

	@PostMapping
	@Operation(summary = "Create an achievement", description = "Creates a new achievement definition.")
	public ResponseEntity<ApiResponse> createAchievement(@RequestBody Achievement achievement) {
		if (achievementDAO.createAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erstellt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Erstellen des Abzeichens.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an achievement", description = "Updates an existing achievement's details.")
	public ResponseEntity<ApiResponse> updateAchievement(@PathVariable int id, @RequestBody Achievement achievement) {
		achievement.setId(id);
		if (achievementDAO.updateAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren des Abzeichens.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an achievement", description = "Deletes an achievement definition.")
	public ResponseEntity<ApiResponse> deleteAchievement(@PathVariable int id) {
		if (achievementDAO.deleteAchievement(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen gelöscht.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Löschen des Abzeichens.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAnnouncementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.Announcement;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AnnouncementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/announcements")
@Tag(name = "Admin Announcements", description = "Endpoints for managing bulletin board announcements.")
public class AdminAnnouncementResource {

	private final AnnouncementService announcementService;

	@Autowired
	public AdminAnnouncementResource(AnnouncementService announcementService) {
		this.announcementService = announcementService;
	}

	@GetMapping
	@Operation(summary = "Get all announcements")
	public ResponseEntity<ApiResponse> getAllAnnouncements() {
		List<Announcement> announcements = announcementService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Announcements retrieved successfully.", announcements));
	}

	@PostMapping
	@Operation(summary = "Create a new announcement")
	public ResponseEntity<ApiResponse> createAnnouncement(@Valid @RequestBody Announcement announcement,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Announcement createdAnnouncement = announcementService.create(announcement, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Announcement created successfully.", createdAnnouncement),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an announcement")
	public ResponseEntity<ApiResponse> updateAnnouncement(@PathVariable int id,
			@Valid @RequestBody Announcement announcement, @AuthenticationPrincipal SecurityUser securityUser) {
		announcement.setId(id);
		Announcement updatedAnnouncement = announcementService.update(announcement, securityUser.getUser());
		if (updatedAnnouncement != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Announcement updated successfully.", updatedAnnouncement));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Announcement not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an announcement")
	public ResponseEntity<ApiResponse> deleteAnnouncement(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (announcementService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Announcement deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Announcement not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAuthLogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AuthenticationLogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.AuthenticationLog;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/auth-log")
@Tag(name = "Admin Authentication Log", description = "Endpoints for viewing authentication history.")
@SecurityRequirement(name = "bearerAuth")
public class AdminAuthLogResource {

    private static final Logger logger = LogManager.getLogger(AdminAuthLogResource.class);
    private final AuthenticationLogDAO authLogDAO;
    private final AuthService authService;
    private final AdminLogService adminLogService;

    @Autowired
    public AdminAuthLogResource(AuthenticationLogDAO authLogDAO, AuthService authService, AdminLogService adminLogService) {
        this.authLogDAO = authLogDAO;
        this.authService = authService;
        this.adminLogService = adminLogService;
    }

    @GetMapping
    @Operation(summary = "Get recent authentication logs")
    public ResponseEntity<ApiResponse> getAuthLogs(@RequestParam(defaultValue = "100") int limit) {
        logger.debug("Request received to get auth logs with limit: {}", limit);
        List<AuthenticationLog> logs = authLogDAO.getLogs(limit);
        logger.debug("Returning {} auth log entries.", logs.size());
        return ResponseEntity.ok(new ApiResponse(true, "Authentication logs retrieved successfully.", logs));
    }

    @PostMapping("/revoke-session")
    @Operation(summary = "Revoke a user session via JWT ID")
    public ResponseEntity<ApiResponse> revokeSession(@RequestBody Map<String, String> payload,
            @AuthenticationPrincipal SecurityUser securityUser) {
        String jti = payload.get("jti");
        logger.info("Request received from admin '{}' to revoke session with JTI: {}", securityUser.getUsername(), jti);
        if (jti == null || jti.isBlank()) {
            logger.warn("Revoke session request failed: JTI is missing.");
            return ResponseEntity.badRequest().body(new ApiResponse(false, "JWT ID (jti) is required.", null));
        }

        if (authService.isTokenRevoked(jti)) {
            logger.warn("Attempted to revoke an already-revoked session with JTI: {}", jti);
            return ResponseEntity.badRequest().body(new ApiResponse(false, "Diese Sitzung wurde bereits widerrufen.", null));
        }

        AuthenticationLog logToRevoke = authLogDAO.getLogByJti(jti);
        authService.revokeToken(jti);

        if (logToRevoke != null) {
            String details = String.format("Session for user '%s' (IP: %s, Login: %s) revoked.",
                    logToRevoke.getUsername(), logToRevoke.getIpAddress(), logToRevoke.getTimestamp());
            adminLogService.log(securityUser.getUsername(), "SESSION_REVOKE", details);
        }

        logger.info("Session with JTI '{}' was successfully added to the blocklist.", jti);
        return ResponseEntity.ok(new ApiResponse(true, "Session successfully revoked. The user will be logged out on their next action.", null));
    }
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChangelogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ChangelogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/changelogs")
@Tag(name = "Admin Changelogs", description = "Endpoints for managing application changelogs.")
public class AdminChangelogResource {

	private final ChangelogService changelogService;

	@Autowired
	public AdminChangelogResource(ChangelogService changelogService) {
		this.changelogService = changelogService;
	}

	@GetMapping
	@Operation(summary = "Get all changelogs")
	public ResponseEntity<ApiResponse> getAllChangelogs() {
		List<Changelog> changelogs = changelogService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Changelogs retrieved successfully.", changelogs));
	}

	@PostMapping
	@Operation(summary = "Create a new changelog entry")
	public ResponseEntity<ApiResponse> createChangelog(@RequestBody Changelog changelog,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (changelogService.create(changelog, securityUser.getUser())) {
			return new ResponseEntity<>(new ApiResponse(true, "Changelog created successfully.", changelog),
					HttpStatus.CREATED);
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Failed to create changelog.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a changelog entry")
	public ResponseEntity<ApiResponse> updateChangelog(@PathVariable int id, @RequestBody Changelog changelog,
			@AuthenticationPrincipal SecurityUser securityUser) {
		changelog.setId(id);
		if (changelogService.update(changelog, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog updated successfully.", changelog));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a changelog entry")
	public ResponseEntity<ApiResponse> deleteChangelog(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (changelogService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChecklistTemplateResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.ChecklistTemplateItemValidationDTO;
import de.technikteam.dao.ChecklistTemplateDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistTemplate;
import de.technikteam.service.ChecklistTemplateService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/checklist-templates")
@Tag(name = "Admin Checklist Templates", description = "Endpoints for managing pre-flight checklist templates.")
@SecurityRequirement(name = "bearerAuth")
public class AdminChecklistTemplateResource {

	private final ChecklistTemplateDAO templateDAO;
	private final ChecklistTemplateService templateService;

	@Autowired
	public AdminChecklistTemplateResource(ChecklistTemplateDAO templateDAO, ChecklistTemplateService templateService) {
		this.templateDAO = templateDAO;
		this.templateService = templateService;
	}

	@GetMapping
	@Operation(summary = "Get all checklist templates")
	public ResponseEntity<ApiResponse> getAllTemplates() {
		List<ChecklistTemplate> templates = templateDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Vorlagen erfolgreich abgerufen.", templates));
	}

	@PostMapping
	@Operation(summary = "Create a new checklist template")
	public ResponseEntity<ApiResponse> createTemplate(@RequestBody ChecklistTemplate template) {
		try {
			ChecklistTemplate savedTemplate = templateDAO.save(template);
			return new ResponseEntity<>(new ApiResponse(true, "Vorlage erfolgreich erstellt.", savedTemplate),
					HttpStatus.CREATED);
		} catch (DuplicateKeyException e) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Eine Vorlage mit diesem Namen existiert bereits.", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a checklist template")
	public ResponseEntity<ApiResponse> updateTemplate(@PathVariable int id, @RequestBody ChecklistTemplate template) {
		template.setId(id);
		try {
			ChecklistTemplate updatedTemplate = templateDAO.save(template);
			return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich aktualisiert.", updatedTemplate));
		} catch (DuplicateKeyException e) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Eine andere Vorlage mit diesem Namen existiert bereits.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a checklist template")
	public ResponseEntity<ApiResponse> deleteTemplate(@PathVariable int id) {
		if (templateDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Vorlage nicht gefunden.", null));
	}

	@GetMapping("/{id}/apply-preview")
	@Operation(summary = "Get template items with current availability for event planning")
	public ResponseEntity<ApiResponse> getTemplateForEventApplication(@PathVariable int id) {
		List<ChecklistTemplateItemValidationDTO> items = templateService.getTemplateForEventApplication(id);
		return ResponseEntity.ok(new ApiResponse(true, "Template preview retrieved.", items));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDamageReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.DamageReportDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.DamageReport;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/damage-reports")
@Tag(name = "Admin Damage Reports", description = "Endpoints for managing user-submitted damage reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDamageReportResource {

	private final DamageReportDAO damageReportDAO;
	private final StorageService storageService;

	@Autowired
	public AdminDamageReportResource(DamageReportDAO damageReportDAO, StorageService storageService) {
		this.damageReportDAO = damageReportDAO;
		this.storageService = storageService;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get all pending damage reports")
	public ResponseEntity<ApiResponse> getPendingReports() {
		List<DamageReport> reports = damageReportDAO.getPendingReports();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Meldungen abgerufen.", reports));
	}

	@PostMapping("/{reportId}/confirm")
	@Operation(summary = "Confirm a damage report")
	public ResponseEntity<ApiResponse> confirmReport(@PathVariable int reportId,
			@RequestBody Map<String, Integer> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			int quantity = payload.getOrDefault("quantity", 1);
			storageService.confirmDamageReport(reportId, quantity, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung bestätigt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{reportId}/reject")
	@Operation(summary = "Reject a damage report")
	public ResponseEntity<ApiResponse> rejectReport(@PathVariable int reportId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String adminNotes = payload.get("adminNotes");
		try {
			storageService.rejectDamageReport(reportId, adminNotes, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung abgelehnt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDashboardResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminDashboardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin/dashboard")
@Tag(name = "Admin Dashboard", description = "Endpoints for the administrative dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDashboardResource {

	private final AdminDashboardService dashboardService;

	@Autowired
	public AdminDashboardResource(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
	}

	@GetMapping
	@Operation(summary = "Get all data for the admin dashboard")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		return ResponseEntity.ok(
				new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardService.getDashboardData()));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDocumentationResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.PageDocumentation;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.PageDocumentationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/admin/documentation")
@Tag(name = "Admin Documentation", description = "Endpoints for managing page documentation.")
public class AdminDocumentationResource {

	private final PageDocumentationService documentationService;

	@Autowired
	public AdminDocumentationResource(PageDocumentationService documentationService) {
		this.documentationService = documentationService;
	}

	@GetMapping
	@Operation(summary = "Get all documentation pages")
	public ResponseEntity<ApiResponse> getAllDocs() {
		List<PageDocumentation> docs = documentationService.findAll(true);
		return ResponseEntity.ok(new ApiResponse(true, "Documentation pages retrieved.", docs));
	}

	@GetMapping("/{pageKey}")
	@Operation(summary = "Get a single documentation page by key")
	public ResponseEntity<ApiResponse> getDocByKey(@PathVariable String pageKey) {
		Optional<PageDocumentation> doc = documentationService.findByKey(pageKey);
		return doc.map(d -> ResponseEntity.ok(new ApiResponse(true, "Documentation retrieved.", d)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Documentation not found.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new documentation page")
	public ResponseEntity<ApiResponse> createDoc(@Valid @RequestBody PageDocumentation doc,
			@AuthenticationPrincipal SecurityUser securityUser) {
		PageDocumentation createdDoc = documentationService.create(doc, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Documentation created successfully.", createdDoc),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a documentation page")
	public ResponseEntity<ApiResponse> updateDoc(@PathVariable int id, @Valid @RequestBody PageDocumentation doc,
			@AuthenticationPrincipal SecurityUser securityUser) {
		doc.setId(id);
		PageDocumentation updatedDoc = documentationService.update(doc, securityUser.getUser());
		if (updatedDoc != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Documentation updated successfully.", updatedDoc));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a documentation page")
	public ResponseEntity<ApiResponse> deleteDoc(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (documentationService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Documentation deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventDebriefingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventDebriefingDTO;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventDebriefingDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventDebriefing;
import de.technikteam.model.FeedbackResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventDebriefingService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/admin/events")
@Tag(name = "Admin Event Debriefings", description = "Endpoints for managing post-event reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventDebriefingResource {

	private final EventDebriefingDAO debriefingDAO;
	private final EventDebriefingService debriefingService;
	private final EventDAO eventDAO;
	private final EventFeedbackDAO feedbackDAO;

	@Autowired
	public AdminEventDebriefingResource(EventDebriefingDAO debriefingDAO, EventDebriefingService debriefingService,
			EventDAO eventDAO, EventFeedbackDAO feedbackDAO) {
		this.debriefingDAO = debriefingDAO;
		this.debriefingService = debriefingService;
		this.eventDAO = eventDAO;
		this.feedbackDAO = feedbackDAO;
	}

	@GetMapping("/debriefings")
	@Operation(summary = "Get all debriefing reports")
	public ResponseEntity<ApiResponse> getAllDebriefings() {
		List<EventDebriefing> debriefings = debriefingDAO.findAll().stream().map(debriefingService::enrichDebriefing)
				.collect(Collectors.toList());
		return ResponseEntity.ok(new ApiResponse(true, "Debriefings abgerufen.", debriefings));
	}

	@GetMapping("/{eventId}/debriefing")
	@Operation(summary = "Get a debriefing for a specific event")
	public ResponseEntity<ApiResponse> getDebriefingForEvent(@PathVariable int eventId) {
		Optional<EventDebriefing> debriefingOpt = debriefingDAO.findByEventId(eventId);
		if (debriefingOpt.isPresent()) {
			return ResponseEntity.ok(new ApiResponse(true, "Debriefing abgerufen.",
					debriefingService.enrichDebriefing(debriefingOpt.get())));
		} else {
			return ResponseEntity.ok(new ApiResponse(true, "Kein Debriefing für dieses Event vorhanden.", null));
		}
	}

	@PostMapping("/{eventId}/debriefing")
	@Operation(summary = "Create or update a debriefing for an event")
	public ResponseEntity<ApiResponse> saveDebriefing(@PathVariable int eventId,
			@Valid @RequestBody EventDebriefingDTO dto, @AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Event nicht gefunden.", null));
		}

		try {
			EventDebriefing savedDebriefing = debriefingService.saveDebriefing(eventId, dto, user);
			return new ResponseEntity<>(new ApiResponse(true, "Debriefing erfolgreich gespeichert.", savedDebriefing),
					HttpStatus.CREATED);
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@GetMapping("/{eventId}/feedback-summary")
	@Operation(summary = "Get aggregated user feedback for an event")
	public ResponseEntity<ApiResponse> getFeedbackSummary(@PathVariable int eventId) {
		List<FeedbackResponse> responses = feedbackDAO.getResponsesForEvent(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "User feedback summary retrieved.", responses));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventAssignmentDTO;
import de.technikteam.api.v1.dto.EventUpdateRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import de.technikteam.security.SecurityUser;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events")
@Tag(name = "Admin Events", description = "Endpoints for managing events.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;

	@Autowired
	public AdminEventResource(EventDAO eventDAO, EventService eventService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
	}

	@GetMapping
	@Operation(summary = "Get all events", description = "Retrieves a list of all events in the system, sorted by date.")
	public ResponseEntity<ApiResponse> getAllEvents() {
		List<Event> events = eventDAO.getAllEvents();
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@PostMapping
	@Operation(summary = "Create a new event", description = "Creates a new event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> createEvent(@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			Event event = new Event();
			mapDtoToEvent(eventData, event);

			int newEventId = eventService.createOrUpdateEvent(event, false, securityUser.getUser(),
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return new ResponseEntity<>(
					new ApiResponse(true, "Veranstaltung erfolgreich erstellt.", Map.of("id", newEventId)),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Erstellen der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update an event", description = "Updates an existing event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> updateEvent(@PathVariable int id,
			@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			Event event = eventDAO.getEventById(id);
			if (event == null) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
			}
			mapDtoToEvent(eventData, event);
			event.setId(id); 

			eventService.createOrUpdateEvent(event, true, securityUser.getUser(),
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Fehler beim Aktualisieren der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone an event", description = "Creates a deep copy of an existing event, including its details, requirements, and tasks.")
	public ResponseEntity<ApiResponse> cloneEvent(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			Event clonedEvent = eventService.cloneEvent(id, securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Event erfolgreich geklont.", clonedEvent),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Events fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event", description = "Permanently deletes an event and all associated data.")
	public ResponseEntity<ApiResponse> deleteEvent(@PathVariable int id) {
		if (eventDAO.deleteEvent(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich gelöscht.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Löschen der Veranstaltung.", null));
		}
	}

	@PostMapping("/{eventId}/assignments")
	@Operation(summary = "Update team assignments for an event", description = "Sets the entire team for an event, including their roles.")
	public ResponseEntity<ApiResponse> updateAssignments(@PathVariable int eventId,
			@RequestBody List<EventAssignmentDTO> assignments, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			eventService.updateTeamAssignmentsAndNotify(eventId, assignments, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Team-Zuweisungen erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Aktualisieren der Zuweisungen: " + e.getMessage(), null));
		}
	}

	private void mapDtoToEvent(EventUpdateRequest dto, Event event) {
		event.setName(dto.name());
		event.setEventDateTime(dto.eventDateTime());
		event.setEndDateTime(dto.endDateTime());
		event.setDescription(dto.description());
		event.setLocation(dto.location());
		event.setStatus(dto.status());
		event.setLeaderUserId(dto.leaderUserId() != null && dto.leaderUserId() != 0 ? dto.leaderUserId() : 0);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventRoleResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.EventRoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventRole;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/event-roles")
@Tag(name = "Admin Event Roles", description = "Endpoints for managing predefined event roles.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventRoleResource {

	private final EventRoleDAO eventRoleDAO;

	@Autowired
	public AdminEventRoleResource(EventRoleDAO eventRoleDAO) {
		this.eventRoleDAO = eventRoleDAO;
	}

	@GetMapping
	@Operation(summary = "Get all event roles")
	public ResponseEntity<ApiResponse> getAllRoles() {
		List<EventRole> roles = eventRoleDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Rollen erfolgreich abgerufen.", roles));
	}

	@PostMapping
	@Operation(summary = "Create a new event role")
	public ResponseEntity<ApiResponse> createRole(@Valid @RequestBody EventRole role) {
		if (eventRoleDAO.create(role)) {
			return new ResponseEntity<>(new ApiResponse(true, "Rolle erfolgreich erstellt.", role), HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Rolle konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an event role")
	public ResponseEntity<ApiResponse> updateRole(@PathVariable int id, @Valid @RequestBody EventRole role) {
		role.setId(id);
		if (eventRoleDAO.update(role)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich aktualisiert.", role));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event role")
	public ResponseEntity<ApiResponse> deleteRole(@PathVariable int id) {
		if (eventRoleDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFeedbackResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/feedback")
@Tag(name = "Admin Feedback", description = "Endpoints for managing user feedback.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;

	@Autowired
	public AdminFeedbackResource(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get all feedback submissions", description = "Retrieves all feedback submissions from all users, ordered by status.")
	public ResponseEntity<ApiResponse> getAllSubmissions() {
		List<FeedbackSubmission> submissions = submissionDAO.getAllSubmissions();
		return ResponseEntity.ok(new ApiResponse(true, "Alle Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PutMapping("/{id}/status")
	@Operation(summary = "Update feedback status", description = "Updates the status of a specific feedback submission.")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int id, @RequestBody Map<String, String> payload) {
		String newStatus = payload.get("status");
		FeedbackSubmission submission = submissionDAO.getSubmissionById(id);
		if (submission == null) {
			return ResponseEntity.notFound().build();
		}
		if (submissionDAO.updateStatusAndTitle(id, newStatus, submission.getDisplayTitle())) {
			return ResponseEntity.ok(new ApiResponse(true, "Status aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFileResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.CategoryRequest;
import de.technikteam.api.v1.dto.FileContentUpdateRequest;
import de.technikteam.api.v1.dto.FileRenameRequest;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/admin/files")
@Tag(name = "Admin Files", description = "Endpoints for managing files and categories.")
public class AdminFileResource {

	private final FileDAO fileDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminFileResource(FileDAO fileDAO, FileService fileService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	@PostMapping
	@Operation(summary = "Upload a new file")
	public ResponseEntity<ApiResponse> uploadFile(@RequestParam("file") MultipartFile file,
			@RequestParam(required = false) Integer categoryId, @RequestParam String requiredRole,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, categoryId, requiredRole,
					securityUser.getUser(), "docs");
			return new ResponseEntity<>(new ApiResponse(true, "Datei erfolgreich hochgeladen.", savedFile),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei konnte nicht hochgeladen werden: " + e.getMessage(), null));
		}
	}

	@PostMapping("/replace/{id}")
	@Operation(summary = "Replace an existing file")
	public ResponseEntity<ApiResponse> replaceFile(@PathVariable int id, @RequestParam("file") MultipartFile file,
			@RequestParam(required = false) Integer categoryId, @RequestParam String requiredRole,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File updatedFile = fileService.replaceFile(id, file, categoryId, requiredRole,
					securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich ersetzt.", updatedFile));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei konnte nicht ersetzt werden: " + e.getMessage(), null));
		}
	}

	@GetMapping("/content/{id}")
	@Operation(summary = "Get a file's text content for editing")
	public ResponseEntity<ApiResponse> getFileContent(@PathVariable int id) {
		try {
			String content = fileService.getFileContent(id);
			de.technikteam.model.File file = fileDAO.getFileById(id);
			file.setContent(content);
			return ResponseEntity.ok(new ApiResponse(true, "File content retrieved.", file));
		} catch (IOException | SecurityException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PutMapping("/content/{id}")
	@Operation(summary = "Update a file's text content")
	public ResponseEntity<ApiResponse> updateFileContent(@PathVariable int id,
			@Valid @RequestBody FileContentUpdateRequest request, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (fileService.updateFileContent(id, request.content(), securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Datei-Inhalt erfolgreich gespeichert.", null));
			} else {
				return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
						.body(new ApiResponse(false, "Speichern des Datei-Inhalts fehlgeschlagen.", null));
			}
		} catch (IOException | SecurityException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PutMapping("/{id}/rename")
	@Operation(summary = "Rename a file")
	public ResponseEntity<ApiResponse> renameFile(@PathVariable int id, @Valid @RequestBody FileRenameRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		de.technikteam.model.File file = fileDAO.getFileById(id);
		if (file == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Datei nicht gefunden.", null));
		}
		if (fileDAO.renameFile(id, request.newName())) {
			adminLogService.log(securityUser.getUser().getUsername(), "FILE_RENAME",
					"File '" + file.getFilename() + "' (ID: " + id + ") renamed to '" + request.newName() + "'.");
			return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich umbenannt.", null));
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Datei konnte nicht umbenannt werden.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a file")
	public ResponseEntity<ApiResponse> deleteFile(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (fileService.deleteFile(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich gelöscht.", Map.of("deletedId", id)));
			} else {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Datei nicht gefunden.", null));
			}
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Datei konnte aufgrund eines Serverfehlers nicht gelöscht werden.", null));
		}
	}

	@PostMapping("/categories")
	@Operation(summary = "Create a new file category")
	public ResponseEntity<ApiResponse> createCategory(@Valid @RequestBody CategoryRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (fileDAO.createCategory(request.name())) {
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_FILE_CATEGORY_API",
					"Category '" + request.name() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kategorie erfolgreich erstellt.", null),
					HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false,
				"Kategorie konnte nicht erstellt werden. Der Name existiert möglicherweise bereits.", null));
	}

	@PutMapping("/categories/{id}")
	@Operation(summary = "Rename a file category")
	public ResponseEntity<ApiResponse> renameCategory(@PathVariable int id, @Valid @RequestBody CategoryRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String oldName = fileDAO.getCategoryNameById(id);
		if (oldName == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Kategorie nicht gefunden.", null));
		}
		if (fileDAO.renameCategory(id, request.name())) {
			adminLogService.log(securityUser.getUser().getUsername(), "RENAME_FILE_CATEGORY_API",
					"Category '" + oldName + "' renamed to '" + request.name() + "'.");
			return ResponseEntity.ok(new ApiResponse(true, "Kategorie erfolgreich umbenannt.", null));
		}
		return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false,
				"Kategorie konnte nicht umbenannt werden. Der neue Name existiert möglicherweise bereits.", null));
	}

	@DeleteMapping("/categories/{id}")
	@Operation(summary = "Delete a file category")
	public ResponseEntity<ApiResponse> deleteCategory(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String categoryName = fileDAO.getCategoryNameById(id);
		if (categoryName != null && fileDAO.deleteCategory(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_FILE_CATEGORY_API",
					"Category '" + categoryName + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kategorie erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kategorie nicht gefunden oder konnte nicht gelöscht werden.", null));
	}

	@GetMapping
	@Operation(summary = "Get all files grouped by category (Admin View)")
	public ResponseEntity<ApiResponse> getAllFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		Map<String, List<de.technikteam.model.File>> groupedFiles = fileDAO
				.getAllFilesGroupedByCategory(securityUser.getUser());
		List<de.technikteam.model.File> rawFiles = fileDAO.getAllFilesForAdmin();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("grouped", groupedFiles);
		responseData.put("raw", rawFiles);

		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", responseData));
	}

	@GetMapping("/categories")
	@Operation(summary = "Get all file categories")
	public ResponseEntity<ApiResponse> getAllCategories() {
		List<FileCategory> categories = fileDAO.getAllCategories();
		return ResponseEntity.ok(new ApiResponse(true, "Kategorien erfolgreich abgerufen.", categories));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFormDataResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Course;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/form-data")
@Tag(name = "Admin Form Data", description = "Endpoints for populating admin forms.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFormDataResource {

	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;
	private final CourseDAO courseDAO;

	@Autowired
	public AdminFormDataResource(RoleDAO roleDAO, PermissionDAO permissionDAO, CourseDAO courseDAO) {
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
		this.courseDAO = courseDAO;
	}

	@GetMapping("/users")
	@Operation(summary = "Get data for user forms", description = "Retrieves all roles and grouped permissions needed to populate admin forms for creating or editing users.")
	public ResponseEntity<ApiResponse> getFormDataForUserForms() {
		List<Role> roles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			if (key.contains("_")) {
				return key.substring(0, key.indexOf("_"));
			}
			return "SYSTEM";
		}));

		Map<String, Object> formData = Map.of("roles", roles, "groupedPermissions", groupedPermissions);

		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", formData));
	}

	@GetMapping("/achievements")
	@Operation(summary = "Get data for achievement forms", description = "Retrieves all courses for use in achievement conditions.")
	public ResponseEntity<ApiResponse> getFormDataForAchievementForms() {
		List<Course> courses = courseDAO.getAllCourses();
		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten für Abzeichen erfolgreich abgerufen.",
				Map.of("courses", courses)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminGeoIpResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.GeoIpRuleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.GeoIpRule;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/geoip/rules")
@Tag(name = "Admin GeoIP", description = "Endpoints for managing GeoIP filtering rules.")
@PreAuthorize("hasRole('ADMIN')")
public class AdminGeoIpResource {

    private final GeoIpRuleDAO geoIpRuleDAO;
    private final AdminLogService adminLogService;

    @Autowired
    public AdminGeoIpResource(GeoIpRuleDAO geoIpRuleDAO, AdminLogService adminLogService) {
        this.geoIpRuleDAO = geoIpRuleDAO;
        this.adminLogService = adminLogService;
    }

    @GetMapping
    @Operation(summary = "Get all GeoIP rules")
    public ResponseEntity<ApiResponse> getAllRules() {
        List<GeoIpRule> rules = geoIpRuleDAO.findAllRules();
        return ResponseEntity.ok(new ApiResponse(true, "GeoIP rules retrieved.", rules));
    }

    @PostMapping
    @Operation(summary = "Add or update a GeoIP rule")
    public ResponseEntity<ApiResponse> saveRule(@Valid @RequestBody GeoIpRule rule,
                                                @AuthenticationPrincipal SecurityUser securityUser) {
        if (rule.getCountryCode() == null || rule.getCountryCode().length() != 2) {
            return ResponseEntity.badRequest().body(new ApiResponse(false, "Invalid country code.", null));
        }
        if (!"ALLOW".equals(rule.getRuleType()) && !"BLOCK".equals(rule.getRuleType())) {
            return ResponseEntity.badRequest().body(new ApiResponse(false, "Invalid rule type. Must be ALLOW or BLOCK.", null));
        }

        geoIpRuleDAO.saveRule(rule);
        adminLogService.log(securityUser.getUsername(), "GEOIP_RULE_SET",
                String.format("Set GeoIP rule for country %s to %s", rule.getCountryCode(), rule.getRuleType()));
        return ResponseEntity.ok(new ApiResponse(true, "GeoIP rule saved.", rule));
    }

    @DeleteMapping("/{countryCode}")
    @Operation(summary = "Delete a GeoIP rule")
    public ResponseEntity<ApiResponse> deleteRule(@PathVariable String countryCode,
                                                  @AuthenticationPrincipal SecurityUser securityUser) {
        if (geoIpRuleDAO.deleteRule(countryCode)) {
            adminLogService.log(securityUser.getUsername(), "GEOIP_RULE_DELETE",
                    String.format("Deleted GeoIP rule for country %s", countryCode));
            return ResponseEntity.ok(new ApiResponse(true, "GeoIP rule deleted.", null));
        }
        return ResponseEntity.notFound().build();
    }
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminKitItemsResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKitItem;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/kits/{kitId}/items")
@Tag(name = "Admin Kits", description = "Endpoints for managing inventory kits.")
public class AdminKitItemsResource {

	private final InventoryKitDAO kitDAO;

	@Autowired
	public AdminKitItemsResource(InventoryKitDAO kitDAO) {
		this.kitDAO = kitDAO;
	}

	@PutMapping
	@Operation(summary = "Update the items within a kit")
	public ResponseEntity<ApiResponse> updateKitItems(@PathVariable int kitId,
			@RequestBody List<InventoryKitItem> items) {
		try {
			kitDAO.updateKitItems(kitId, items);
			return ResponseEntity.ok(new ApiResponse(true, "Kit-Inhalt erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Aktualisieren des Kit-Inhalts: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminMeetingManagementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.MeetingSignupService;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/meetings")
@Tag(name = "Admin Meetings", description = "Admin endpoints for managing meetings, waitlists and repeats.")
@SecurityRequirement(name = "bearerAuth")
public class AdminMeetingManagementResource {

	private final MeetingSignupService signupService;
	private final MeetingDAO meetingDAO;

	@Autowired
	public AdminMeetingManagementResource(MeetingSignupService signupService, MeetingDAO meetingDAO) {
		this.signupService = signupService;
		this.meetingDAO = meetingDAO;
	}

	@Operation(summary = "Get enrolled users for a meeting (admin)")
	@GetMapping("/{meetingId}/participants")
	public ResponseEntity<ApiResponse> getParticipants(@PathVariable int meetingId) {
		List<User> participants = meetingDAO.getEnrolledUsersForMeeting(meetingId);
		return ResponseEntity.ok(new ApiResponse(true, "Teilnehmerliste abgerufen.", participants));
	}

	@Operation(summary = "Get waitlist for a meeting (admin)")
	@GetMapping("/{meetingId}/waitlist")
	public ResponseEntity<ApiResponse> getWaitlist(@PathVariable int meetingId) {
		List<User> waitlisted = signupService.getWaitlist(meetingId);
		Map<String, Object> data = new HashMap<>();
		data.put("waitlist", waitlisted);
		return ResponseEntity.ok(new ApiResponse(true, "Waitlist abgerufen.", data));
	}

	@Operation(summary = "Promote a user from a meeting's waitlist to enrolled status (admin)")
	@PostMapping("/{meetingId}/promote")
	public ResponseEntity<ApiResponse> promoteUser(@PathVariable int meetingId,
			@RequestBody Map<String, Integer> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		Integer userId = payload.get("userId");
		if (userId == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "userId ist erforderlich.", null));
		}
		if (securityUser == null || securityUser.getUser() == null) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, "Nicht autorisiert.", null));
		}
		int adminId = securityUser.getUser().getId();
		boolean ok = signupService.promoteUserFromWaitlist(meetingId, userId, adminId);
		if (ok) {
			return ResponseEntity.ok(new ApiResponse(true, "Nutzer erfolgreich befördert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Beförderung fehlgeschlagen.", null));
		}
	}

	@Operation(summary = "Create a repeat meeting for an existing meeting (admin). This links the new meeting via parent_meeting_id.")
	@PostMapping("/{meetingId}/repeat")
	public ResponseEntity<ApiResponse> createRepeatMeeting(@PathVariable int meetingId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		Meeting original = meetingDAO.getMeetingById(meetingId);
		if (original == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Original-Meeting nicht gefunden.", null));
		}

		try {
			Meeting newMeeting = new Meeting();
			newMeeting.setCourseId(original.getCourseId());
			newMeeting.setParentMeetingId(original.getId());
			newMeeting.setName(payload.getOrDefault("name", original.getName()));
			if (payload.containsKey("meetingDateTime")) {
				newMeeting.setMeetingDateTime(LocalDateTime.parse(payload.get("meetingDateTime")));
			} else {
				return ResponseEntity.badRequest().body(new ApiResponse(false, "meetingDateTime fehlt.", null));
			}
			if (payload.containsKey("endDateTime")) {
				newMeeting.setEndDateTime(LocalDateTime.parse(payload.get("endDateTime")));
			}
			if (payload.containsKey("leaderUserId")) {
				newMeeting.setLeaderUserId(Integer.parseInt(payload.get("leaderUserId")));
			} else {
				newMeeting.setLeaderUserId(original.getLeaderUserId());
			}
			newMeeting.setDescription(payload.getOrDefault("description", original.getDescription()));
			newMeeting.setLocation(payload.getOrDefault("location", original.getLocation()));

			int newId = meetingDAO.createMeeting(newMeeting);
			if (newId > 0) {
				Map<String, Object> data = new HashMap<>();
				data.put("id", newId);
				return ResponseEntity.ok(new ApiResponse(true, "Repeat-Meeting erstellt.", data));
			} else {
				return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
						.body(new ApiResponse(false, "Konnte Meeting nicht erstellen.", null));
			}
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminNotificationResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.NotificationRequest;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AuthService;
import de.technikteam.service.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/api/v1/admin/notifications")
@Tag(name = "Admin Notifications", description = "Endpoints for sending and receiving notifications.")
@SecurityRequirement(name = "bearerAuth")
public class AdminNotificationResource {

	private final NotificationService notificationService;
	private final AuthService authService;

	@Autowired
	public AdminNotificationResource(NotificationService notificationService, AuthService authService) {
		this.notificationService = notificationService;
		this.authService = authService;
	}

	@PostMapping
	@Operation(summary = "Send a broadcast notification", description = "Sends a real-time notification to a specified group of users.")
	@PreAuthorize("hasRole('ADMIN') or hasAuthority('NOTIFICATION_SEND')")
	public ResponseEntity<ApiResponse> sendNotification(@Valid @RequestBody NotificationRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User adminUser = securityUser.getUser();

		try {
			int recipients = notificationService.sendBroadcastNotification(request, adminUser);
			return ResponseEntity
					.ok(new ApiResponse(true, "Benachrichtigung an " + recipients + " Empfänger gesendet.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Senden der Benachrichtigung fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/requests")
@Tag(name = "Admin Requests", description = "Endpoints for managing user-submitted requests.")
public class AdminRequestResource {

	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService requestService;
	private final UserDAO userDAO;

	@Autowired
	public AdminRequestResource(ProfileChangeRequestDAO requestDAO, ProfileRequestService requestService,
			UserDAO userDAO) {
		this.requestDAO = requestDAO;
		this.requestService = requestService;
		this.userDAO = userDAO;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get pending requests", description = "Retrieves a list of all profile change requests that are pending review.")
	public ResponseEntity<ApiResponse> getPendingRequests() {
		List<ProfileChangeRequest> requests = requestDAO.getPendingRequests();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Anträge erfolgreich abgerufen.", requests));
	}

	@PostMapping("/{id}/approve")
	@Operation(summary = "Approve a request", description = "Approves a profile change request and applies the changes to the user's profile.")
	public ResponseEntity<ApiResponse> approveRequest(
			@Parameter(description = "ID of the request to approve") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (requestService.approveRequest(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag genehmigt und Benutzer aktualisiert.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht genehmigt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/deny")
	@Operation(summary = "Deny a request", description = "Denies a profile change request.")
	public ResponseEntity<ApiResponse> denyRequest(
			@Parameter(description = "ID of the request to deny") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (requestService.denyRequest(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag abgelehnt.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht abgelehnt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminStorageRelationsResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.service.StorageItemRelationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/storage/{itemId}/relations")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
public class AdminStorageRelationsResource {

	private final StorageItemRelationService relationService;

	@Autowired
	public AdminStorageRelationsResource(StorageItemRelationService relationService) {
		this.relationService = relationService;
	}

	@GetMapping
	@Operation(summary = "Get related items for a storage item")
	public ResponseEntity<ApiResponse> getRelatedItems(@PathVariable int itemId) {
		return ResponseEntity
				.ok(new ApiResponse(true, "Related items retrieved.", relationService.findRelatedItems(itemId)));
	}

	@PutMapping
	@Operation(summary = "Update related items for a storage item")
	public ResponseEntity<ApiResponse> updateRelatedItems(@PathVariable int itemId,
			@RequestBody Map<String, List<Integer>> payload) {
		List<Integer> relatedItemIds = payload.get("relatedItemIds");
		if (relatedItemIds == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Payload must contain 'relatedItemIds'.", null));
		}
		relationService.updateRelations(itemId, relatedItemIds);
		return ResponseEntity.ok(new ApiResponse(true, "Related items updated successfully.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminSystemResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MaintenanceStatusDTO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.SystemInfoService;
import de.technikteam.service.SystemSettingsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/system")
@Tag(name = "Admin System", description = "Endpoints for retrieving system information and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class AdminSystemResource {

	private final SystemInfoService systemInfoService;
	private final SystemSettingsService settingsService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminSystemResource(SystemInfoService systemInfoService, SystemSettingsService settingsService,
			AdminLogService adminLogService) {
		this.systemInfoService = systemInfoService;
		this.settingsService = settingsService;
		this.adminLogService = adminLogService;
	}

	@GetMapping("/stats")
	@Operation(summary = "Get system statistics", description = "Retrieves current system statistics like CPU load, memory usage, and disk space.")
	public ResponseEntity<ApiResponse> getSystemStats() {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		return ResponseEntity.ok(new ApiResponse(true, "Systemstatistiken erfolgreich abgerufen.", stats));
	}

	@GetMapping("/maintenance")
	@Operation(summary = "Get maintenance mode status")
	public ResponseEntity<ApiResponse> getMaintenanceMode() {
		MaintenanceStatusDTO status = settingsService.getMaintenanceStatus();
		return ResponseEntity.ok(new ApiResponse(true, "Wartungsmodus-Status abgerufen.", status));
	}

	@PostMapping("/maintenance")
	@Operation(summary = "Set maintenance mode status")
	public ResponseEntity<ApiResponse> setMaintenanceMode(@RequestBody MaintenanceStatusDTO status,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (status == null || status.mode() == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Payload must contain 'mode'.", null));
		}
		settingsService.setMaintenanceMode(status);
		adminLogService.log(securityUser.getUser().getUsername(), "MAINTENANCE_MODE_UPDATE",
				"Maintenance mode set to " + status.mode() + ". Message: " + status.message());
		return ResponseEntity.ok(new ApiResponse(true, "Wartungsmodus erfolgreich aktualisiert.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminTrainingRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.TrainingRequest;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.TrainingRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/training-requests")
@Tag(name = "Admin Training Requests", description = "Endpoints for managing user-initiated training requests.")
public class AdminTrainingRequestResource {

	private final TrainingRequestService trainingRequestService;

	@Autowired
	public AdminTrainingRequestResource(TrainingRequestService trainingRequestService) {
		this.trainingRequestService = trainingRequestService;
	}

	@GetMapping
	@Operation(summary = "Get all training requests")
	public ResponseEntity<ApiResponse> getAllRequests() {
		List<TrainingRequest> requests = trainingRequestService.findAllWithInterestCount();
		return ResponseEntity.ok(new ApiResponse(true, "Training requests retrieved successfully.", requests));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a training request")
	public ResponseEntity<ApiResponse> deleteRequest(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (trainingRequestService.delete(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "Training request deleted successfully.", null));
		}
		return ResponseEntity.notFound().build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminUserManagementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminUserManagementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;

@RestController
@RequestMapping("/api/v1/admin/users")
@Tag(name = "Admin Users", description = "Admin endpoints for managing users, including suspension.")
@SecurityRequirement(name = "bearerAuth")
public class AdminUserManagementResource {

	private final AdminUserManagementService adminService;

	@Autowired
	public AdminUserManagementResource(AdminUserManagementService adminService) {
		this.adminService = adminService;
	}

	@PostMapping("/{userId}/suspend")
	public ResponseEntity<ApiResponse> suspendUser(@PathVariable int userId, @RequestBody SuspendRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (request == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Request body required.", null));
		}
		try {
			boolean success = adminService.suspendUser(userId, request.duration, request.reason,
					securityUser.getUser());
			if (success) {
				return ResponseEntity.ok(new ApiResponse(true, "User suspended successfully.", null));
			} else {
				return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
						.body(new ApiResponse(false, "Failed to suspend user.", null));
			}
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (AccessDeniedException e) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{userId}/unsuspend")
	public ResponseEntity<ApiResponse> unsuspendUser(@PathVariable int userId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		boolean success = adminService.unsuspendUser(userId, securityUser.getUser());
		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "User unsuspended and unlocked.", null));
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Failed to unsuspend user.", null));
	}

	public record SuspendRequest(String duration, String reason) {
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminVenueResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.Venue;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import de.technikteam.dao.VenueDAO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/admin/venues")
@Tag(name = "Admin Venues", description = "Endpoints for managing event venues and maps.")
public class AdminVenueResource {

	private final VenueDAO venueDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminVenueResource(VenueDAO venueDAO, FileService fileService, AdminLogService adminLogService) {
		this.venueDAO = venueDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all venues")
	public ResponseEntity<ApiResponse> getAllVenues() {
		List<Venue> venues = venueDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Venues retrieved successfully.", venues));
	}

	@PostMapping
	@Operation(summary = "Create a new venue")
	public ResponseEntity<ApiResponse> createVenue(@RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage,
			@AuthenticationPrincipal SecurityUser securityUser) throws IOException {
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER",
					securityUser.getUser(), "venues");
			venue.setMapImagePath(savedFile.getFilepath());
		}
		Venue createdVenue = venueDAO.create(venue);
		adminLogService.log(securityUser.getUser().getUsername(), "VENUE_CREATE",
				"Venue '" + createdVenue.getName() + "' created.");
		return new ResponseEntity<>(new ApiResponse(true, "Venue created successfully.", createdVenue),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a venue")
	public ResponseEntity<ApiResponse> updateVenue(@PathVariable int id, @RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage,
			@AuthenticationPrincipal SecurityUser securityUser) throws IOException {
		venue.setId(id);
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER",
					securityUser.getUser(), "venues");
			venue.setMapImagePath(savedFile.getFilepath());
		} else if (venue.getMapImagePath() == null) {
			Optional<Venue> existingVenue = venueDAO.findById(id);
			existingVenue.ifPresent(v -> venue.setMapImagePath(v.getMapImagePath()));
		}

		if (venueDAO.update(venue)) {
			adminLogService.log(securityUser.getUser().getUsername(), "VENUE_UPDATE",
					"Venue '" + venue.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue updated successfully.", venue));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a venue")
	public ResponseEntity<ApiResponse> deleteVenue(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Optional<Venue> venue = venueDAO.findById(id);
		if (venue.isPresent() && venueDAO.delete(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "VENUE_DELETE",
					"Venue '" + venue.get().getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ChecklistResource.java
========================================================================

package de.technikteam.api.v1;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.ChecklistDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.websocket.ChatSessionManager;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events/{eventId}/checklist")
@Tag(name = "Event Checklists", description = "Endpoints for managing event inventory checklists.")
public class ChecklistResource {

	private final ChecklistDAO checklistDAO;
	private final ChatSessionManager sessionManager;
	private final Gson gson;

	@Autowired
	public ChecklistResource(ChecklistDAO checklistDAO, ChatSessionManager sessionManager) {
		this.checklistDAO = checklistDAO;
		this.sessionManager = sessionManager;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@GetMapping
	@Operation(summary = "Get the checklist for an event")
	public ResponseEntity<ApiResponse> getChecklist(@PathVariable int eventId) {
		List<ChecklistItem> checklist = checklistDAO.getChecklistForEvent(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "Checkliste erfolgreich abgerufen.", checklist));
	}

	@PostMapping("/generate")
	@Operation(summary = "Generate or refresh a checklist from reservations")
	public ResponseEntity<ApiResponse> generateChecklist(@PathVariable int eventId) {
		int rowsAffected = checklistDAO.generateChecklistFromReservations(eventId);
		return ResponseEntity
				.ok(new ApiResponse(true, rowsAffected + " Einträge in der Checkliste erstellt/aktualisiert.", null));
	}

	@PutMapping("/{checklistItemId}/status")
	@Operation(summary = "Update the status of a checklist item")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int eventId, @PathVariable int checklistItemId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String status = payload.get("status");
		if (status == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Status ist erforderlich.", null));
		}

		if (checklistDAO.updateChecklistItemStatus(checklistItemId, status, securityUser.getUser().getId())) {
			ChecklistItem updatedItem = checklistDAO.getChecklistItemById(checklistItemId);

			Map<String, Object> broadcastPayload = Map.of("type", "checklist_update", "payload", updatedItem);
			sessionManager.broadcast(String.valueOf(eventId), gson.toJson(broadcastPayload));

			return ResponseEntity.ok(new ApiResponse(true, "Status erfolgreich aktualisiert.", updatedItem));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\CourseResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MeetingRequest;
import de.technikteam.dao.CourseDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/courses")
@Tag(name = "Admin Courses", description = "Endpoints for managing course templates.")
public class CourseResource {

	private final CourseDAO courseDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public CourseResource(CourseDAO courseDAO, AdminLogService adminLogService) {
		this.courseDAO = courseDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all course templates")
	public ResponseEntity<ApiResponse> getAllCourses() {
		List<Course> courses = courseDAO.getAllCourses();
		return ResponseEntity.ok(new ApiResponse(true, "Lehrgänge erfolgreich abgerufen.", courses));
	}

	@PostMapping
	@Operation(summary = "Create a new course template")
	public ResponseEntity<ApiResponse> createCourse(@RequestBody Course course,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Course createdCourse = courseDAO.createCourse(course);
		if (createdCourse != null) {
			adminLogService.logCourseCreation(securityUser.getUser().getUsername(), createdCourse);
			return new ResponseEntity<>(new ApiResponse(true, "Lehrgang erfolgreich erstellt.", createdCourse),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Lehrgang konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a course template")
	public ResponseEntity<ApiResponse> updateCourse(@PathVariable int id, @RequestBody Course course,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Course originalCourse = courseDAO.getCourseById(id);
		if (originalCourse == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Vorlage nicht gefunden.", null));
		}
		course.setId(id);
		if (courseDAO.updateCourse(course)) {
			adminLogService.logCourseUpdate(securityUser.getUser().getUsername(), originalCourse, course);
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich aktualisiert.", course));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a course template")
	public ResponseEntity<ApiResponse> deleteCourse(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Course course = courseDAO.getCourseById(id);
		if (course != null && courseDAO.deleteCourse(id)) {
			adminLogService.logCourseDeletion(securityUser.getUser().getUsername(), course);
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\EventTaskResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventTaskService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events/{eventId}/tasks")
@Tag(name = "Event Tasks", description = "Endpoints for managing tasks within an event.")
public class EventTaskResource {

	private static final Logger logger = LogManager.getLogger(EventTaskResource.class);
	private final EventTaskService eventTaskService;

	@Autowired
	public EventTaskResource(EventTaskService eventTaskService) {
		this.eventTaskService = eventTaskService;
	}

	@PostMapping
	@Operation(summary = "Create or update an event task")
	public ResponseEntity<ApiResponse> saveTask(@PathVariable int eventId, @RequestBody EventTask task,
			@AuthenticationPrincipal SecurityUser securityUser) {
		logger.debug("Received request to save task for event {}: {}", eventId, task.getDescription());
		try {
			task.setEventId(eventId);
			int taskId = eventTaskService.saveTaskAndHandleMentions(task,
					task.getAssignedUsers().stream().mapToInt(User::getId).toArray(), null, null, null, 
					task.getDependsOn().stream().mapToInt(EventTask::getId).toArray(), securityUser.getUser());
			logger.info("Task {} for event {} saved successfully with ID: {}", task.getDescription(), eventId, taskId);
			return new ResponseEntity<>(new ApiResponse(true, "Task saved successfully.", Map.of("taskId", taskId)),
					HttpStatus.OK);
		} catch (Exception e) {
			logger.error("Failed to save task for event {}", eventId, e);
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Failed to save task: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{taskId}/action")
	@Operation(summary = "Perform a user action on a task (status change, claim, unclaim)")
	public ResponseEntity<ApiResponse> performTaskAction(@PathVariable int eventId, @PathVariable int taskId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String action = payload.get("action");
		String status = payload.get("status");
		logger.debug("Received action '{}' for task {} in event {}", action, taskId, eventId);

		try {
			eventTaskService.performUserTaskAction(eventId, taskId, action, status, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich ausgeführt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (SecurityException e) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			logger.error("Error performing task action", e);
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein interner Fehler ist aufgetreten.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\KitResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/kits")
@Tag(name = "Admin Kits", description = "Endpoints for managing inventory kits.")
public class KitResource {

	private final InventoryKitDAO kitDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public KitResource(InventoryKitDAO kitDAO, AdminLogService adminLogService) {
		this.kitDAO = kitDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all kits with their items")
	public ResponseEntity<ApiResponse> getAllKits() {
		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		return ResponseEntity.ok(new ApiResponse(true, "Kits erfolgreich abgerufen.", kits));
	}

	@PostMapping
	@Operation(summary = "Create a new kit")
	public ResponseEntity<ApiResponse> createKit(@RequestBody InventoryKit kit,
			@AuthenticationPrincipal SecurityUser securityUser) {
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			kit.setId(newId);
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_KIT_API",
					"Kit '" + kit.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kit erfolgreich erstellt.", kit), HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Kit konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a kit's metadata")
	public ResponseEntity<ApiResponse> updateKit(@PathVariable int id, @RequestBody InventoryKit kit,
			@AuthenticationPrincipal SecurityUser securityUser) {
		kit.setId(id);
		if (kitDAO.updateKit(kit)) {
			adminLogService.log(securityUser.getUser().getUsername(), "UPDATE_KIT_API",
					"Kit '" + kit.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich aktualisiert.", kit));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a kit")
	public ResponseEntity<ApiResponse> deleteKit(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		InventoryKit kit = kitDAO.getKitById(id);
		if (kit != null && kitDAO.deleteKit(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_KIT_API",
					"Kit '" + kit.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\LogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.ApiResponse;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
@Tag(name = "Admin Logs", description = "Endpoints for viewing and managing the admin action log.")
@SecurityRequirement(name = "bearerAuth")
public class LogResource {

	private final AdminLogDAO logDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public LogResource(AdminLogDAO logDAO, AdminLogService adminLogService) {
		this.logDAO = logDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get admin action logs", description = "Retrieves a list of all administrative actions. Can be limited.")
	public ResponseEntity<ApiResponse> getLogs(@RequestParam(required = false) Integer limit) {
		List<AdminLog> logs;
		if (limit != null) {
			logs = logDAO.getRecentLogs(limit);
		} else {
			logs = logDAO.getAllLogs();
		}
		return ResponseEntity.ok(new ApiResponse(true, "Protokolle erfolgreich abgerufen.", logs));
	}

	@PostMapping("/{logId}/revoke")
	@Operation(summary = "Revoke an admin action", description = "Revokes a previously logged administrative action, if the action is reversible.")
	public ResponseEntity<ApiResponse> revokeLogAction(@PathVariable long logId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			adminLogService.revokeAction(logId, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich widerrufen.", null));
		} catch (UnsupportedOperationException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein unerwarteter Fehler ist aufgetreten.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MatrixResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.dao.UserQualificationsDAO;
import de.technikteam.model.*;
import de.technikteam.service.AchievementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/matrix")
@Tag(name = "Admin Matrix", description = "Endpoints for the qualification matrix.")
@SecurityRequirement(name = "bearerAuth")
public class MatrixResource {

	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final AchievementService achievementService;

	@Autowired
	public MatrixResource(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO, UserQualificationsDAO qualificationsDAO,
			AchievementService achievementService) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.achievementService = achievementService;
	}

	@GetMapping
	@Operation(summary = "Get qualification matrix data")
	public ResponseEntity<ApiResponse> getMatrixData() {
		List<User> allUsers = userDAO.getAllUsers();
		List<Course> allCourses = courseDAO.getAllCourses();

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			meetingsByCourse.put(course.getId(), meetingDAO.getMeetingsForCourse(course.getId()));
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));

		Map<String, Boolean> completionMap = new HashMap<>();
		for (User user : allUsers) {
			for (Course course : allCourses) {
				boolean hasCompleted = qualificationsDAO.hasUserCompletedCourse(user.getId(), course.getId());
				completionMap.put(user.getId() + "-" + course.getId(), hasCompleted);
			}
		}

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("users", allUsers);
		responseData.put("courses", allCourses);
		responseData.put("meetingsByCourse", meetingsByCourse);
		responseData.put("attendanceMap", attendanceMap);
		responseData.put("completionMap", completionMap);

		return ResponseEntity.ok(new ApiResponse(true, "Matrixdaten erfolgreich abgerufen.", responseData));
	}

	@PutMapping("/attendance")
	@Operation(summary = "Update meeting attendance")
	public ResponseEntity<ApiResponse> updateAttendance(@RequestBody MeetingAttendance attendance) {
		boolean success = meetingAttendanceDAO.setAttendance(attendance.getUserId(), attendance.getMeetingId(),
				attendance.getAttended(), attendance.getRemarks());
		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Teilnahme aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren der Teilnahme.", null));
	}

	@PutMapping("/qualification")
	@Operation(summary = "Update a user's course qualification status")
	public ResponseEntity<ApiResponse> updateQualification(@RequestBody UserQualification qualification) {
		boolean success = qualificationsDAO.updateQualificationStatus(qualification.getUserId(),
				qualification.getCourseId(), qualification.getStatus(), qualification.getCompletionDate(),
				qualification.getRemarks());
		if (success) {
			if ("BESTANDEN".equals(qualification.getStatus())) {
				User user = userDAO.getUserById(qualification.getUserId());
				if (user != null) {
					achievementService.checkAndGrantAchievements(user, "QUALIFICATION_GAINED",
							qualification.getCourseId());
				}
			}
			return ResponseEntity.ok(new ApiResponse(true, "Qualifikationsstatus aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren des Qualifikationsstatus.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MeetingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MeetingRequest;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/meetings")
@Tag(name = "Admin Meetings", description = "Endpoints for managing specific training meetings.")
public class MeetingResource {

	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;
	private final EventService eventService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public MeetingResource(MeetingDAO meetingDAO, AdminLogService adminLogService, EventService eventService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		this.eventService = eventService;
		this.richTextPolicy = richTextPolicy;
	}

	@GetMapping
	@Operation(summary = "Get all meetings for a course")
	public ResponseEntity<ApiResponse> getMeetingsForCourse(@RequestParam int courseId) {
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single meeting by ID")
	public ResponseEntity<ApiResponse> getMeetingById(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich abgerufen.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Termin nicht gefunden.", null));
	}

	@PostMapping
	@Operation(summary = "Create a new meeting")
	public ResponseEntity<ApiResponse> createMeeting(@Valid @RequestBody MeetingRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Meeting meeting = new Meeting();
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		int newId = meetingDAO.createMeeting(meeting);
		if (newId > 0) {
			meeting.setId(newId);
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Termin erfolgreich erstellt.", meeting),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Termin konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a meeting")
	public ResponseEntity<ApiResponse> updateMeeting(@PathVariable int id, @Valid @RequestBody MeetingRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Meeting meeting = new Meeting();
		meeting.setId(id);
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		if (meetingDAO.updateMeeting(meeting)) {
			adminLogService.log(securityUser.getUser().getUsername(), "UPDATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich aktualisiert.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone a meeting")
	public ResponseEntity<ApiResponse> cloneMeeting(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			Meeting clonedMeeting = eventService.cloneMeeting(id, securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Meeting erfolgreich geklont.", clonedMeeting),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Meetings fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a meeting")
	public ResponseEntity<ApiResponse> deleteMeeting(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null && meetingDAO.deleteMeeting(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_MEETING_API",
					"Meeting '" + meeting.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ReportDAO;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/reports")
@Tag(name = "Admin Reports", description = "Endpoints for generating reports and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class ReportResource {

	private final ReportDAO reportDAO;

	@Autowired
	public ReportResource(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@GetMapping("/dashboard")
	@Operation(summary = "Get dashboard report data", description = "Retrieves aggregated data for the admin dashboard, including event trends and user activity.")
	public ResponseEntity<ApiResponse> getDashboardReport() {
		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("eventTrend", reportDAO.getEventCountByMonth(12));
		dashboardData.put("userActivity", reportDAO.getUserParticipationStats(10));
		dashboardData.put("totalInventoryValue", reportDAO.getTotalInventoryValue());
		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\StorageResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/storage")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
public class StorageResource {

	private final StorageDAO storageDAO;
	private final StorageService storageService;
	private final AdminLogService adminLogService;
	private final FileService fileService;

	@Autowired
	public StorageResource(StorageDAO storageDAO, StorageService storageService, AdminLogService adminLogService,
			FileService fileService) {
		this.storageDAO = storageDAO;
		this.storageService = storageService;
		this.adminLogService = adminLogService;
		this.fileService = fileService;
	}

	@GetMapping
	@Operation(summary = "Get all storage items")
	public ResponseEntity<ApiResponse> getAllItems() {
		List<StorageItem> items = storageDAO.getAllItems();
		return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich abgerufen.", items));
	}

	@PostMapping
	@Operation(summary = "Create a new storage item")
	public ResponseEntity<ApiResponse> createItem(@ModelAttribute StorageItem item,
			@RequestParam(value = "imageFile", required = false) MultipartFile imageFile,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (imageFile != null && !imageFile.isEmpty()) {
				de.technikteam.model.File savedFile = fileService.storeFile(imageFile, null, "NUTZER",
						securityUser.getUser(), "images");
				item.setImagePath(savedFile.getFilepath());
			}

			if (storageDAO.createItem(item)) {
				adminLogService.log(securityUser.getUser().getUsername(), "CREATE_STORAGE_ITEM_API",
						"Item '" + item.getName() + "' created.");
				return new ResponseEntity<>(new ApiResponse(true, "Artikel erfolgreich erstellt.", item),
						HttpStatus.CREATED);
			}
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Artikel konnte nicht erstellt werden.", null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Erstellen des Artikels: " + e.getMessage(), null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a storage item's defect/repair status")
	public ResponseEntity<ApiResponse> updateItemStatus(@PathVariable int id, @RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			storageService.handleItemStatusUpdate(id, payload, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Artikelstatus erfolgreich aktualisiert.", null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update a storage item's core details")
	public ResponseEntity<ApiResponse> updateItemDetails(@PathVariable int id, @ModelAttribute StorageItem item,
			@RequestParam(value = "imageFile", required = false) MultipartFile imageFile,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			item.setId(id);
			if (imageFile != null && !imageFile.isEmpty()) {
				de.technikteam.model.File savedFile = fileService.storeFile(imageFile, null, "NUTZER",
						securityUser.getUser(), "images");
				item.setImagePath(savedFile.getFilepath());
			}

			if (storageDAO.updateItem(item)) {
				adminLogService.log(securityUser.getUser().getUsername(), "UPDATE_STORAGE_ITEM_API",
						"Item '" + item.getName() + "' updated.");
				return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich aktualisiert.", item));
			}
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Artikel nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Aktualisieren des Artikels: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a storage item")
	public ResponseEntity<ApiResponse> deleteItem(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		StorageItem item = storageDAO.getItemById(id);
		if (item != null && storageDAO.deleteItem(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\SystemResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/system")
@Tag(name = "Admin System", description = "Endpoints for retrieving system information and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class SystemResource {

	private final SystemInfoService systemInfoService;

	@Autowired
	public SystemResource(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
	}

	@GetMapping("/stats")
	@Operation(summary = "Get system statistics", description = "Retrieves current system statistics like CPU load, memory usage, and disk space.")
	public ResponseEntity<ApiResponse> getSystemStats() {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		return ResponseEntity.ok(new ApiResponse(true, "Systemstatistiken erfolgreich abgerufen.", stats));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\UserResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.UserCreateRequest;
import de.technikteam.api.v1.dto.UserUpdateRequest;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.service.UserService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.security.SecureRandom;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
public class UserResource {

	private final UserService userService;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public UserResource(UserService userService, UserDAO userDAO, AdminLogService adminLogService,
			LoginAttemptService loginAttemptService) {
		this.userService = userService;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.loginAttemptService = loginAttemptService;
	}

	@GetMapping
	@Operation(summary = "Get all users", description = "Retrieves a list of all users in the system.")
	public ResponseEntity<ApiResponse> getAllUsers(@RequestParam(required = false) Integer eventId) {
		List<User> users;
		if (eventId != null) {
			users = userDAO.getQualifiedAndAvailableUsersForEvent(eventId);
		} else {
			users = userDAO.getAllUsers();
		}
		return ResponseEntity.ok(new ApiResponse(true, "Users retrieved successfully", users));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get user by ID", description = "Retrieves a single user by their ID, including their permissions.")
	public ResponseEntity<ApiResponse> getUserById(
			@Parameter(description = "ID of the user to retrieve") @PathVariable int id) {
		User user = userDAO.getUserById(id);
		if (user != null) {
			return ResponseEntity.ok(new ApiResponse(true, "User retrieved successfully", user));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found", null));
		}
	}

	@PostMapping
	@Operation(summary = "Create a new user", description = "Creates a new user with a specified role and individual permissions.")
	public ResponseEntity<ApiResponse> createUser(@Valid @RequestBody UserCreateRequest createRequest,
			@AuthenticationPrincipal SecurityUser securityUser) {
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(createRequest.password());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "Password does not meet policy: " + validationResult.getMessage(), null));
		}

		User newUser = new User();
		newUser.setUsername(createRequest.username());
		newUser.setRoleId(createRequest.roleId());
		newUser.setEmail(createRequest.email());
		newUser.setClassYear(createRequest.classYear() != null ? createRequest.classYear() : 0);
		newUser.setClassName(createRequest.className());

		String[] permissionIds = createRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		int newUserId = userService.createUserWithPermissions(newUser, createRequest.password(), permissionIds,
				securityUser.getUser().getUsername());
		if (newUserId > 0) {
			User createdUser = userDAO.getUserById(newUserId);
			return new ResponseEntity<>(new ApiResponse(true, "User created successfully", createdUser),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "User could not be created (username or email may already exist).", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a user", description = "Updates an existing user's profile details, role, and individual permissions.")
	public ResponseEntity<ApiResponse> updateUser(
			@Parameter(description = "ID of the user to update") @PathVariable int id,
			@Valid @RequestBody UserUpdateRequest updateRequest, @AuthenticationPrincipal SecurityUser securityUser) {

		User originalUser = userDAO.getUserById(id);
		if (originalUser == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found.", null));
		}

		User userToUpdate = userDAO.getUserById(id);
		userToUpdate.setUsername(updateRequest.username());
		userToUpdate.setRoleId(updateRequest.roleId());
		userToUpdate.setEmail(updateRequest.email());
		userToUpdate.setClassYear(updateRequest.classYear() != null ? updateRequest.classYear() : 0);
		userToUpdate.setClassName(updateRequest.className());
		userToUpdate.setAdminNotes(updateRequest.adminNotes());

		String[] permissionIds = updateRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		if (userService.updateUserWithPermissions(userToUpdate, permissionIds)) {
			User refreshedUser = userDAO.getUserById(id);
			adminLogService.logUserUpdate(securityUser.getUser().getUsername(), originalUser, refreshedUser);
			return ResponseEntity.ok(new ApiResponse(true, "User updated successfully", refreshedUser));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to update user.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a user", description = "Permanently deletes a user from the system.")
	public ResponseEntity<ApiResponse> deleteUser(
			@Parameter(description = "ID of the user to delete") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User userToDelete = userDAO.getUserById(id);
		if (userToDelete == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to delete not found.", null));
		}

		if (userToDelete.getId() == 1) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "The default admin account cannot be deleted.", null));
		}

		if (userService.deleteUser(id, securityUser.getUser())) {
			return ResponseEntity.ok(new ApiResponse(true, "User deleted successfully", Map.of("deletedUserId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete user.", null));
		}
	}

	@PostMapping("/{id}/reset-password")
	@Operation(summary = "Reset user's password", description = "Resets a user's password to a new, randomly generated password.")
	public ResponseEntity<ApiResponse> resetPassword(
			@Parameter(description = "ID of the user whose password will be reset") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User userToReset = userDAO.getUserById(id);
		if (userToReset == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to reset not found.", null));
		}

		String newPassword = generateRandomPassword(12);
		if (userDAO.changePassword(id, newPassword)) {
			adminLogService.log(securityUser.getUser().getUsername(), "RESET_PASSWORD_API",
					"Password for user '" + userToReset.getUsername() + "' (ID: " + id + ") reset via API.");
			return ResponseEntity
					.ok(new ApiResponse(true, "Password for " + userToReset.getUsername() + " has been reset.",
							Map.of("username", userToReset.getUsername(), "newPassword", newPassword)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Password could not be reset.", null));
		}
	}

	@PostMapping("/{id}/unlock")
	@Operation(summary = "Unlock a user account", description = "Unlocks a user account that was locked due to too many failed login attempts.")
	public ResponseEntity<ApiResponse> unlockUser(
			@Parameter(description = "ID of the user to unlock") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User userToUnlock = userDAO.getUserById(id);
		if (userToUnlock == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to unlock not found.", null));
		}

		loginAttemptService.clearLoginAttempts(userToUnlock.getUsername());
		adminLogService.log(securityUser.getUser().getUsername(), "UNLOCK_USER_API",
				"User account '" + userToUnlock.getUsername() + "' (ID: " + id + ") unlocked via API.");
		return ResponseEntity.ok(new ApiResponse(true,
				"User account '" + userToUnlock.getUsername() + "' has been unlocked.", Map.of("unlockedUserId", id)));
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\WikiResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.WikiUpdateRequest;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.WikiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/wiki")
@Tag(name = "Admin Wiki", description = "Endpoints for managing the technical documentation wiki.")
public class WikiResource {

	private final WikiService wikiService;
	private final WikiDAO wikiDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public WikiResource(WikiService wikiService, WikiDAO wikiDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.wikiService = wikiService;
		this.wikiDAO = wikiDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	@GetMapping
	@Operation(summary = "Get wiki navigation tree", description = "Retrieves the entire wiki page structure as a hierarchical tree.")
	public ResponseEntity<ApiResponse> getWikiTree() {
		Map<String, Object> treeData = wikiService.getWikiTreeAsData();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Struktur erfolgreich abgerufen.", treeData));
	}

	@GetMapping("/list")
	@Operation(summary = "Get a flat list of all wiki pages", description = "Retrieves a simple list of all wiki pages with their ID and path, suitable for populating dropdowns.")
	public ResponseEntity<ApiResponse> getWikiList() {
		List<WikiEntry> entries = wikiDAO.getAllWikiEntries();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Liste erfolgreich abgerufen.", entries));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single wiki page", description = "Retrieves the content of a single wiki page by its ID.")
	public ResponseEntity<ApiResponse> getWikiEntryById(
			@Parameter(description = "ID of the wiki page to retrieve") @PathVariable int id) {
		Optional<WikiEntry> entryOptional = wikiDAO.getWikiEntryById(id);
		return entryOptional.map(entry -> ResponseEntity.ok(new ApiResponse(true, "Inhalt geladen.", entry)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new wiki page", description = "Creates a new documentation page in the wiki.")
	public ResponseEntity<ApiResponse> createWikiEntry(@Valid @RequestBody WikiEntry newEntry,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (newEntry.getFilePath() == null || newEntry.getFilePath().isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Dateipfad darf nicht leer sein.", null));
		}
		if (wikiDAO.findByFilePath(newEntry.getFilePath()).isPresent()) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Ein Eintrag mit diesem Dateipfad existiert bereits.", null));
		}

		newEntry.setContent(richTextPolicy.sanitize(newEntry.getContent()));
		Optional<WikiEntry> createdEntryOptional = wikiDAO.createWikiEntry(newEntry);
		if (createdEntryOptional.isPresent()) {
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_WIKI_PAGE",
					"Created wiki page: " + createdEntryOptional.get().getFilePath());
			return new ResponseEntity<>(
					new ApiResponse(true, "Seite erfolgreich erstellt.", createdEntryOptional.get()),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Seite konnte nicht in der Datenbank erstellt werden.", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a wiki page", description = "Updates the content of an existing wiki page.")
	public ResponseEntity<ApiResponse> updateWikiEntry(
			@Parameter(description = "ID of the wiki page to update") @PathVariable int id,
			@Valid @RequestBody WikiUpdateRequest updateRequest, @AuthenticationPrincipal SecurityUser securityUser) {

		String sanitizedContent = richTextPolicy.sanitize(updateRequest.content());
		if (wikiDAO.updateWikiContent(id, sanitizedContent)) {
			adminLogService.log(securityUser.getUser().getUsername(), "UPDATE_WIKI_PAGE",
					"Updated wiki page ID: " + id);
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false,
					"Seite konnte nicht aktualisiert werden. Sie existiert möglicherweise nicht.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a wiki page", description = "Permanently deletes a wiki page.")
	public ResponseEntity<ApiResponse> deleteWikiEntry(
			@Parameter(description = "ID of the wiki page to delete") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		Optional<WikiEntry> entryToDelete = wikiDAO.getWikiEntryById(id);
		if (entryToDelete.isEmpty()) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null));
		}

		if (wikiDAO.deleteWikiEntry(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_WIKI_PAGE",
					"Deleted wiki page: " + entryToDelete.get().getFilePath());
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich gelöscht.", Map.of("deletedId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Löschen der Seite.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\AuthResource.java
========================================================================

package de.technikteam.api.v1.auth;

import de.technikteam.api.v1.dto.TwoFactorVerificationRequest;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.security.UserSuspendedException;
import de.technikteam.service.*;
import de.technikteam.dao.TwoFactorAuthDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.util.NavigationRegistry;
import io.jsonwebtoken.Claims;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/auth")
@Tag(name = "Authentication", description = "Endpoints for user authentication.")
public class AuthResource {
	private static final Logger logger = LogManager.getLogger(AuthResource.class);

	private final UserDAO userDAO;
	private final AuthService authService;
	private final LoginAttemptService loginAttemptService;
	private final AuthenticationLogService authLogService;
	private final SystemSettingsService settingsService;
	private final TwoFactorAuthDAO twoFactorAuthDAO;
	private final TwoFactorAuthService twoFactorAuthService;
	private final GeoIpService geoIpService;
	private final UserAgentService userAgentService;

	@Autowired
	public AuthResource(UserDAO userDAO, AuthService authService, LoginAttemptService loginAttemptService,
			AuthenticationLogService authLogService, SystemSettingsService settingsService,
			TwoFactorAuthDAO twoFactorAuthDAO, TwoFactorAuthService twoFactorAuthService,
			GeoIpService geoIpService, UserAgentService userAgentService) {
		this.userDAO = userDAO;
		this.authService = authService;
		this.loginAttemptService = loginAttemptService;
		this.authLogService = authLogService;
		this.settingsService = settingsService;
		this.twoFactorAuthDAO = twoFactorAuthDAO;
		this.twoFactorAuthService = twoFactorAuthService;
		this.geoIpService = geoIpService;
		this.userAgentService = userAgentService;
	}

	@PostMapping("/login")
	@Operation(summary = "User Login", description = "Authenticates a user with username and password. On success, it sets an HttpOnly cookie with the JWT and returns user session data.", requestBody = @RequestBody(description = "User credentials for login.", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = LoginRequest.class))))
	public ResponseEntity<ApiResponse> login(
			@org.springframework.web.bind.annotation.RequestBody LoginRequest loginRequest, HttpServletRequest request,
			HttpServletResponse response) {
		String username = loginRequest.username();
		String password = loginRequest.password();
		String ipAddress = getClientIp(request);
		String userAgent = request.getHeader("User-Agent");
		logger.info("Login attempt for user '{}' from IP address: {}", username, ipAddress);

		if (geoIpService.isIpBlocked(ipAddress)) {
			logger.warn("Blocked login attempt for user '{}' from blocked country. IP: {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Zugriff von Ihrem Standort aus verweigert.", null),
					HttpStatus.FORBIDDEN);
		}

		if (loginAttemptService.isLockedOut(username, ipAddress)) {
			logger.warn("Blocked login attempt for locked-out user '{}' from IP {}", username, ipAddress);
			long remainingSeconds = loginAttemptService.getRemainingLockoutSeconds(username);
			String message = String.format(
					"Konto ist vorübergehend gesperrt. Bitte versuchen Sie es in %d Sekunden erneut.",
					remainingSeconds);
			return new ResponseEntity<>(new ApiResponse(false, message, null), HttpStatus.FORBIDDEN);
		}

		try {
			User user = userDAO.validateUser(username, password);
			if (user != null) {
				loginAttemptService.clearLoginAttempts(username);

				// Risk-Based 2FA Check
				boolean needs2fa = false;
				if (user.isTotpEnabled()) {
					boolean isKnownIp = twoFactorAuthDAO.isIpKnownForUser(user.getId(), ipAddress);
					LocalDateTime lastLoginTime = authLogService.getTimestampOfLastLogin(user.getId());

					if (!isKnownIp) {
						needs2fa = true;
						logger.info("2FA required for user '{}': Unrecognized IP subnet.", username);
					} else if (lastLoginTime != null && lastLoginTime.isBefore(LocalDateTime.now().minusDays(30))) {
						needs2fa = true;
						logger.info("2FA required for user '{}': Inactivity period exceeded.", username);
					}
				}

				if (needs2fa) {
					String preAuthToken = authService.generatePreAuthToken(user.getId());
					return ResponseEntity.ok(new ApiResponse(true, "2FA_REQUIRED", Map.of("token", preAuthToken)));
				}

				// If no 2FA is needed, proceed with full login
				twoFactorAuthDAO.addKnownIpForUser(user.getId(), ipAddress);
				String token = authService.generateToken(user);
				authService.addJwtCookie(user, response);
				logger.info("JWT cookie set successfully for user '{}'", username);

				Claims claims = authService.parseTokenClaims(token);
				Map<String, String> agentDetails = userAgentService.parseUserAgent(userAgent);
				String countryCode = geoIpService.getCountryCode(ipAddress);
				authLogService.logLoginSuccess(user.getId(), username, ipAddress, claims.getId(),
						claims.getExpiration().toInstant(), userAgent, agentDetails.get("deviceType"), countryCode);

				List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(user);
				Map<String, Object> sessionData = new HashMap<>();
				sessionData.put("user", user);
				sessionData.put("navigation", navigationItems);
				sessionData.put("previousLogin", authLogService.getPreviousLoginInfo(user.getId()));
				sessionData.put("maintenanceStatus", settingsService.getMaintenanceStatus());

				Map<String, Object> responseData = new HashMap<>();
				responseData.put("session", sessionData);
				responseData.put("token", token);

				return ResponseEntity.ok(new ApiResponse(true, "Anmeldung erfolgreich", responseData));
			} else {
				loginAttemptService.recordFailedLogin(username, ipAddress);
				authLogService.logLoginFailure(username, ipAddress);
				logger.warn("Failed API login attempt for user '{}' from IP {}", username, ipAddress);
				return new ResponseEntity<>(new ApiResponse(false, "Falscher Benutzername oder Passwort.", null),
						HttpStatus.UNAUTHORIZED);
			}
		} catch (UserSuspendedException e) {
			return new ResponseEntity<>(new ApiResponse(false, e.getMessage(), null), HttpStatus.FORBIDDEN);
		}
	}

	@PostMapping("/verify-2fa")
	@Operation(summary = "Verify 2FA Token", description = "Verifies a TOTP or backup code to complete a login attempt from an unknown location.")
	public ResponseEntity<ApiResponse> verifyTwoFactor(@RequestBody TwoFactorVerificationRequest verificationRequest,
			HttpServletRequest request, HttpServletResponse response) {
		try {
			User user = authService.validatePreAuthTokenAndGetUser(verificationRequest.preAuthToken());
			if (user == null) {
				return new ResponseEntity<>(new ApiResponse(false, "Invalid or expired pre-authentication token.", null), HttpStatus.FORBIDDEN);
			}
			String ipAddress = getClientIp(request);
			String userAgent = request.getHeader("User-Agent");

			boolean isValid = false;
			if (verificationRequest.backupCode() != null && !verificationRequest.backupCode().isBlank()) {
				isValid = twoFactorAuthService.verifyBackupCode(user.getId(), verificationRequest.backupCode());
			} else if (verificationRequest.token() != null && !verificationRequest.token().isBlank()) {
				String decryptedSecret = twoFactorAuthService.decrypt(user.getTotpSecret());
				isValid = twoFactorAuthService.verifyCode(decryptedSecret, verificationRequest.token());
			}

			if (isValid) {
				twoFactorAuthDAO.addKnownIpForUser(user.getId(), ipAddress);
				// Generate final, full-privilege token
				String finalToken = authService.generateToken(user);
				authService.addJwtCookie(user, response);

				// Log successful login with all details
				Claims claims = authService.parseTokenClaims(finalToken);
				Map<String, String> agentDetails = userAgentService.parseUserAgent(userAgent);
				String countryCode = geoIpService.getCountryCode(ipAddress);
				authLogService.logLoginSuccess(user.getId(), user.getUsername(), ipAddress, claims.getId(),
						claims.getExpiration().toInstant(), userAgent, agentDetails.get("deviceType"), countryCode);

				return ResponseEntity.ok(new ApiResponse(true, "2FA verification successful.", Map.of("token", finalToken)));
			} else {
				return new ResponseEntity<>(new ApiResponse(false, "Invalid code.", null), HttpStatus.UNAUTHORIZED);
			}
		} catch (Exception e) {
			return new ResponseEntity<>(new ApiResponse(false, "Verification failed: " + e.getMessage(), null), HttpStatus.FORBIDDEN);
		}
	}

	@GetMapping("/csrf-token")
	@Operation(summary = "Get CSRF Token", description = "An endpoint that does nothing but allows the client to make a GET request to receive the initial XSRF-TOKEN cookie from the server.")
	public ResponseEntity<ApiResponse> getCsrfToken(HttpServletRequest request) {
		CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
		if (csrfToken != null) {
			logger.info("CSRF token explicitly requested and provided.");
		}
		return ResponseEntity.ok(new ApiResponse(true, "CSRF token provided in cookie.", null));
	}

	@GetMapping("/me")
	@Operation(summary = "Get current user session", description = "Retrieves the user object and navigation items for the currently authenticated user.", security = @SecurityRequirement(name = "bearerAuth"))
	public ResponseEntity<ApiResponse> getCurrentUser(@AuthenticationPrincipal SecurityUser securityUser,
			HttpServletRequest request) {
		CsrfToken csrfToken = (CsrfToken) request.getAttribute(CsrfToken.class.getName());
		logger.info("CSRF token loaded during /me request: {}", csrfToken != null ? "OK" : "NULL");

		if (securityUser == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Keine aktive Sitzung gefunden.", null),
					HttpStatus.UNAUTHORIZED);
		}

		User authenticatedUser = userDAO.getUserById(securityUser.getUser().getId());
		List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(authenticatedUser);
		Map<String, Object> responseData = new HashMap<>();
		responseData.put("user", authenticatedUser);
		responseData.put("navigation", navigationItems);
		responseData.put("maintenanceStatus", settingsService.getMaintenanceStatus());

		return ResponseEntity.ok(new ApiResponse(true, "Current user session retrieved.", responseData));
	}

	@PostMapping("/logout")
	@Operation(summary = "User Logout", description = "Logs out the user by clearing the JWT authentication cookie.")
	public ResponseEntity<ApiResponse> logout(@AuthenticationPrincipal SecurityUser securityUser,
			HttpServletRequest request, HttpServletResponse response) {
		if (securityUser != null) {
			authLogService.logLogout(securityUser.getUser().getId(), securityUser.getUsername(), getClientIp(request));
		}
		authService.clearJwtCookie(response);
		return ResponseEntity.ok(new ApiResponse(true, "Abmeldung erfolgreich", null));
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\LoginRequest.java
========================================================================

package de.technikteam.api.v1.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/**
 * A Data Transfer Object (DTO) representing the credentials for a login
 * request. Using a dedicated DTO provides type safety and allows for
 * declarative validation.
 */
public record LoginRequest(
		@NotBlank(message = "Username cannot be blank") @Schema(description = "The user's unique username.", example = "admin", required = true) String username,

		@NotBlank(message = "Password cannot be blank") @Schema(description = "The user's password.", example = "admin123", required = true) String password) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\CategoryRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record CategoryRequest(
		@NotBlank(message = "Kategoriename darf nicht leer sein") @Size(min = 2, max = 100, message = "Kategoriename muss zwischen 2 und 100 Zeichen lang sein") @Schema(description = "The name for the new file category.", required = true) String name) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\ChecklistTemplateItemValidationDTO.java
========================================================================

package de.technikteam.api.v1.dto;

public record ChecklistTemplateItemValidationDTO(int itemId, String itemName, int requestedQuantity,
		int availableQuantity) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventAssignmentDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record EventAssignmentDTO(@NotNull @Schema(description = "The ID of the user being assigned.") Integer userId,

		@Schema(description = "The ID of the event role they are assigned to. Can be null for 'Unassigned'.") Integer roleId) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventDebriefingDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;
import java.util.List;

public record EventDebriefingDTO(@NotNull @Schema(description = "Summary of what went well.") String whatWentWell,
		@NotNull @Schema(description = "Summary of what could be improved.") String whatToImprove,
		@Schema(description = "Notes about specific equipment performance.") String equipmentNotes,
		@Schema(description = "List of user IDs for crew members who performed exceptionally.") List<Integer> standoutCrewMemberIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;

public record EventUpdateRequest(@NotBlank @Schema(description = "Name of the event") String name,
		@NotNull @Schema(description = "Start date and time of the event") LocalDateTime eventDateTime,
		@Schema(description = "End date and time of the event") LocalDateTime endDateTime,
		@Schema(description = "Detailed description of the event") String description,
		@Schema(description = "Location of the event") String location,
		@Schema(description = "Current status of the event (e.g., GEPLANT, LAUFEND)") String status,
		@Schema(description = "ID of the user leading the event") Integer leaderUserId,
		@Schema(description = "Required role for viewing attachments") String requiredRole,
		@Schema(description = "Reminder time in minutes before the event starts") Integer reminderMinutes,
		@Schema(description = "Array of course IDs for skill requirements") List<String> requiredCourseIds,
		@Schema(description = "Array of required person counts for skills") List<String> requiredPersons,
		@Schema(description = "Array of item IDs for reservations") List<String> itemIds,
		@Schema(description = "Array of quantities for reserved items") List<String> quantities) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\FileContentUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import jakarta.validation.constraints.NotNull;

public record FileContentUpdateRequest(@NotNull(message = "Content cannot be null.") String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\FileRenameRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record FileRenameRequest(
		@NotBlank(message = "Der neue Name darf nicht leer sein.") @Size(max = 255, message = "Der Dateiname darf maximal 255 Zeichen lang sein.") String newName) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\GeneralFeedbackRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record GeneralFeedbackRequest(
		@NotBlank(message = "Betreff darf nicht leer sein") @Size(max = 255, message = "Betreff darf nicht länger als 255 Zeichen sein") @Schema(description = "The subject line of the feedback.", required = true) String subject,

		@NotBlank(message = "Inhalt darf nicht leer sein") @Schema(description = "The detailed content of the feedback.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\MaintenanceStatusDTO.java
========================================================================

package de.technikteam.api.v1.dto;

public record MaintenanceStatusDTO(String mode, String message) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\MeetingRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

public record MeetingRequest(
		@NotNull(message = "Kurs-ID darf nicht null sein") @Schema(description = "The ID of the parent course for this meeting.", required = true) Integer courseId,

		@NotBlank(message = "Meeting-Name darf nicht leer sein") @Schema(description = "The name of the meeting.", required = true, example = "Teil 1: Grundlagen") String name,

		@NotNull(message = "Datum und Uhrzeit des Meetings dürfen nicht null sein") @FutureOrPresent(message = "Das Datum des Meetings muss in der Gegenwart oder Zukunft liegen") @Schema(description = "The start date and time of the meeting.", required = true) LocalDateTime meetingDateTime,

		@Schema(description = "The optional end date and time of the meeting.") LocalDateTime endDateTime,

		@Schema(description = "The ID of the user leading the meeting.") Integer leaderUserId,

		@Schema(description = "A description of the meeting's content.") String description,

		@Schema(description = "The location of the meeting.") String location,

		@Min(value = 1, message = "Maximale Teilnehmerzahl muss mindestens 1 sein") @Schema(description = "The maximum number of participants for the meeting. Null for unlimited.") Integer maxParticipants,

		@Schema(description = "The date and time after which signups are closed.") LocalDateTime signupDeadline) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\NotificationRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

@SuppressWarnings("deprecation") // Suppress warning for Schema on record components, which is a known issue
public record NotificationRequest(
		@NotBlank(message = "Titel darf nicht leer sein") @Size(max = 100, message = "Titel darf 100 Zeichen nicht überschreiten") @Schema(description = "The title of the notification.", required = true) String title,

		@NotBlank(message = "Beschreibung darf nicht leer sein") @Schema(description = "The main content of the notification.", required = true) String description,

		@NotBlank(message = "Stufe darf nicht leer sein") @Schema(description = "The severity level of the notification.", required = true, allowableValues = {
				"Informational", "Important", "Warning" }) String level,

		@NotBlank(message = "Zieltyp darf nicht leer sein") @Schema(description = "The target audience type.", required = true, allowableValues = {
				"ALL", "EVENT", "MEETING" }) String targetType,

		@Schema(description = "The ID of the event or meeting if targetType is EVENT or MEETING.") Integer targetId){
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\PasswordChangeRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

public record PasswordChangeRequest(
		@NotBlank(message = "Aktuelles Passwort darf nicht leer sein") @Schema(description = "The user's current password.", required = true) String currentPassword,

		@NotBlank(message = "Neues Passwort darf nicht leer sein") @Schema(description = "The desired new password. Must meet the password policy.", required = true) String newPassword,

		@NotBlank(message = "Bestätigungspasswort darf nicht leer sein") @Schema(description = "Confirmation of the new password.", required = true) String confirmPassword) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\ProfileChangeRequestDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;

public record ProfileChangeRequestDTO(
		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's new email address.") String email,

		@Schema(description = "The user's new class year.") Integer classYear,

		@Schema(description = "The user's new class name.") String className,

		@Schema(description = "The user's new profile icon class (e.g., 'fa-user-ninja').") String profileIconClass) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\TwoFactorSetupDTO.java
========================================================================

package de.technikteam.api.v1.dto;

public record TwoFactorSetupDTO(String secret, String qrCodeDataUri) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\TwoFactorVerificationRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import jakarta.validation.constraints.NotBlank;

public record TwoFactorVerificationRequest(
        @NotBlank String preAuthToken,
        String token,
        String backupCode
) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserCreateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserCreateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotBlank(message = "Passwort darf nicht leer sein") @Schema(description = "The user's initial password. Must meet the password policy.", required = true) String password,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserUpdateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@Schema(description = "Admin-only notes about the user.") String adminNotes,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\WikiUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record WikiUpdateRequest(
		@NotNull(message = "Inhalt darf nicht null sein") @Schema(description = "The full Markdown content of the wiki page.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicAnnouncementResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.Announcement;
import de.technikteam.model.ApiResponse;
import de.technikteam.service.AnnouncementService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/announcements")
@Tag(name = "Public Announcements", description = "Endpoints for viewing bulletin board announcements.")
@SecurityRequirement(name = "bearerAuth")
public class PublicAnnouncementResource {

	private final AnnouncementService announcementService;

	@Autowired
	public PublicAnnouncementResource(AnnouncementService announcementService) {
		this.announcementService = announcementService;
	}

	@GetMapping
	@Operation(summary = "Get all announcements")
	public ResponseEntity<ApiResponse> getAllAnnouncements() {
		List<Announcement> announcements = announcementService.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Announcements retrieved successfully.", announcements));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarEntriesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/calendar")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarEntriesResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarEntriesResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/entries")
	@Operation(summary = "Get calendar entries", description = "Retrieves a combined list of upcoming events and meetings for display in a calendar.")
	public ResponseEntity<ApiResponse> getCalendarEntries() {
		List<Map<String, Object>> entries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", event.getId());
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("end", event.getEndDateTime());
			entry.put("type", "Event");
			entry.put("url", "/veranstaltungen/details/" + event.getId());
			entries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", meeting.getId());
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("end", meeting.getEndDateTime());
			entry.put("type", "Lehrgang");
			entry.put("url", "/lehrgaenge/details/" + meeting.getId());
			entries.add(entry);
		}

		return ResponseEntity.ok(new ApiResponse(true, "Kalendereinträge erfolgreich abgerufen.", entries));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import de.technikteam.service.ConfigurationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.*;
import net.fortuna.ical4j.util.RandomUidGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayOutputStream;
import java.net.URI;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

@RestController
@RequestMapping("/api/v1/public")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final ConfigurationService configService;

	@Autowired
	public PublicCalendarResource(EventDAO eventDAO, MeetingDAO meetingDAO, ConfigurationService configService) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.configService = configService;
	}

	@GetMapping("/calendar.ics")
	@Operation(summary = "Get iCalendar Feed", description = "Provides an iCalendar (.ics) feed of all upcoming events and meetings.", responses = {
			@ApiResponse(responseCode = "200", description = "iCalendar feed generated successfully", content = @Content(mediaType = "text/calendar")),
			@ApiResponse(responseCode = "500", description = "Internal server error while generating the feed") })
	public ResponseEntity<byte[]> getICalendarFeed() {
		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-/ Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = configService.getProperty("app.base-url");
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());
				if (event.getEventDateTime() != null) {
					vEvent.getProperties().add(new DtStart(
							new DateTime(Date.from(event.getEventDateTime().atZone(systemZone).toInstant()))));
				}
				if (event.getEndDateTime() != null) {
					vEvent.getProperties().add(
							new DtEnd(new DateTime(Date.from(event.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				vEvent.getProperties().add(new Url(new URI(baseUrl + "/veranstaltungen/details/" + event.getId())));
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());
				if (meeting.getMeetingDateTime() != null) {
					vMeeting.getProperties().add(new DtStart(
							new DateTime(Date.from(meeting.getMeetingDateTime().atZone(systemZone).toInstant()))));
				}
				if (meeting.getEndDateTime() != null) {
					vMeeting.getProperties().add(new DtEnd(
							new DateTime(Date.from(meeting.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				vMeeting.getProperties().add(new Url(new URI(baseUrl + "/lehrgaenge/details/" + meeting.getId())));
				calendar.getComponents().add(vMeeting);
			}

			ByteArrayOutputStream boas = new ByteArrayOutputStream();
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, boas);

			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.parseMediaType("text/calendar"));
			headers.setContentDispositionFormData("attachment", "technikteam-calendar.ics");

			return new ResponseEntity<>(boas.toByteArray(), headers, HttpStatus.OK);

		} catch (Exception e) {
			return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChangelogResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChangelogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/public/changelog")
@Tag(name = "Public Changelog", description = "Endpoints for user-facing changelog features.")
public class PublicChangelogResource {

	private final ChangelogDAO changelogDAO;

	@Autowired
	public PublicChangelogResource(ChangelogDAO changelogDAO) {
		this.changelogDAO = changelogDAO;
	}

	@GetMapping
	@Operation(summary = "Get all changelogs")
	public ResponseEntity<ApiResponse> getAllChangelogs() {
		List<Changelog> changelogs = changelogDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Changelogs retrieved.", changelogs));
	}

	@GetMapping("/latest-unseen")
	@Operation(summary = "Get the latest unseen changelog for the current user")
	public ResponseEntity<ApiResponse> getLatestUnseenChangelog(@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.ok(new ApiResponse(true, "User not authenticated.", null));
		}
		Optional<Changelog> changelog = changelogDAO.findLatestUnseen(securityUser.getUser().getId());
		return ResponseEntity.ok(new ApiResponse(true, "Latest unseen changelog retrieved.", changelog.orElse(null)));
	}

	@PostMapping("/{id}/mark-seen")
	@Operation(summary = "Mark a changelog as seen by the current user")
	public ResponseEntity<ApiResponse> markAsSeen(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.status(401).body(new ApiResponse(false, "User not authenticated.", null));
		}
		if (changelogDAO.markAsSeen(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog marked as seen.", null));
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Could not mark as seen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChatResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChatDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ChatService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/chat")
@Tag(name = "Public Chat", description = "Endpoints for user direct messaging.")
@SecurityRequirement(name = "bearerAuth")
public class PublicChatResource {

	private final ChatDAO chatDAO;
	private final FileService fileService;
	private final ChatService chatService;

	@Autowired
	public PublicChatResource(ChatDAO chatDAO, FileService fileService, ChatService chatService) {
		this.chatDAO = chatDAO;
		this.fileService = fileService;
		this.chatService = chatService;
	}

	@GetMapping("/conversations")
	@Operation(summary = "Get user's conversations")
	public ResponseEntity<ApiResponse> getConversations(@AuthenticationPrincipal SecurityUser securityUser) {
		return ResponseEntity.ok(new ApiResponse(true, "Gespräche abgerufen.",
				chatDAO.getConversationsForUser(securityUser.getUser().getId())));
	}

	@GetMapping("/conversations/{id}")
	@Operation(summary = "Get a single conversation's details")
	public ResponseEntity<ApiResponse> getConversationById(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			throw new AccessDeniedException("Sie sind kein Mitglied dieses Gesprächs.");
		}
		ChatConversation conversation = chatDAO.getConversationById(id);
		return ResponseEntity.ok(new ApiResponse(true, "Gespräch abgerufen.", conversation));
	}

	@GetMapping("/conversations/{id}/messages")
	@Operation(summary = "Get messages for a conversation")
	public ResponseEntity<ApiResponse> getMessages(@PathVariable int id, @RequestParam(defaultValue = "50") int limit,
			@RequestParam(defaultValue = "0") int offset, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			throw new AccessDeniedException("Sie sind kein Mitglied dieses Gesprächs.");
		}
		return ResponseEntity.ok(
				new ApiResponse(true, "Nachrichten abgerufen.", chatDAO.getMessagesForConversation(id, limit, offset)));
	}

	@PostMapping("/conversations")
	@Operation(summary = "Find or create a conversation with a user")
	public ResponseEntity<ApiResponse> findOrCreateConversation(@RequestBody Map<String, Integer> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Integer otherUserId = payload.get("userId");
		if (otherUserId == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Benutzer-ID fehlt.", null));
		}
		int conversationId = chatDAO.findOrCreateConversation(securityUser.getUser().getId(), otherUserId);
		return ResponseEntity.ok(
				new ApiResponse(true, "Gespräch gefunden oder erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/group")
	@Operation(summary = "Create a new group conversation")
	public ResponseEntity<ApiResponse> createGroupConversation(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String name = (String) payload.get("name");
		@SuppressWarnings("unchecked")
		List<Integer> participantIds = (List<Integer>) payload.get("participantIds");

		if (name == null || name.isBlank() || participantIds == null || participantIds.isEmpty()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Gruppenname und Teilnehmer sind erforderlich.", null));
		}

		int conversationId = chatService.createGroupConversation(name, securityUser.getUser(), participantIds);
		return ResponseEntity.status(HttpStatus.CREATED)
				.body(new ApiResponse(true, "Gruppe erfolgreich erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/{id}/participants")
	@Operation(summary = "Add participants to a group")
	public ResponseEntity<ApiResponse> addParticipants(@PathVariable int id,
			@RequestBody Map<String, List<Integer>> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		ChatConversation conversation = chatDAO.getConversationById(id);
		if (conversation == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Gespräch nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		if (!conversation.isGroupChat() || conversation.getCreatorId() != securityUser.getUser().getId()) {
			throw new AccessDeniedException("Nur der Ersteller der Gruppe kann Mitglieder hinzufügen.");
		}
		List<Integer> userIds = payload.get("userIds");
		if (userIds == null || userIds.isEmpty()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Keine Benutzer-IDs angegeben.", null));
		}

		chatDAO.addParticipantsToGroup(id, userIds);
		return ResponseEntity.ok(new ApiResponse(true, "Teilnehmer erfolgreich hinzugefügt.", null));
	}

	@DeleteMapping("/conversations/{id}/participants/{userId}")
	@Operation(summary = "Remove a participant from a group")
	public ResponseEntity<ApiResponse> removeParticipant(@PathVariable int id, @PathVariable int userId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (chatService.removeParticipantFromGroup(id, userId, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Teilnehmer erfolgreich entfernt.", null));
			}
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Entfernen des Teilnehmers fehlgeschlagen.", null));
		} catch (IllegalArgumentException e) {
			return new ResponseEntity<>(new ApiResponse(false, e.getMessage(), null), HttpStatus.BAD_REQUEST);
		} catch (AccessDeniedException e) {
			return new ResponseEntity<>(new ApiResponse(false, e.getMessage(), null), HttpStatus.FORBIDDEN);
		}
	}

	@PostMapping("/conversations/{id}/leave")
	@Operation(summary = "Leave a group conversation")
	public ResponseEntity<ApiResponse> leaveGroup(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (chatService.leaveGroup(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Gruppe erfolgreich verlassen.", null));
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Verlassen der Gruppe fehlgeschlagen.", null));
	}

	@DeleteMapping("/conversations/{id}")
	@Operation(summary = "Delete a group conversation")
	public ResponseEntity<ApiResponse> deleteGroup(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (chatService.deleteGroup(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Gruppe erfolgreich gelöscht.", null));
			}
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Löschen der Gruppe fehlgeschlagen.", null));
		} catch (IllegalArgumentException e) {
			return new ResponseEntity<>(new ApiResponse(false, e.getMessage(), null), HttpStatus.NOT_FOUND);
		} catch (AccessDeniedException e) {
			return new ResponseEntity<>(new ApiResponse(false, e.getMessage(), null), HttpStatus.FORBIDDEN);
		}
	}

	@PostMapping("/upload")
	@Operation(summary = "Upload a file for chat")
	public ResponseEntity<ApiResponse> uploadChatFile(@RequestParam("file") MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"chat");
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDashboardResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.ChatDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.Meeting;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/dashboard")
@Tag(name = "Public Dashboard", description = "Endpoints for the user-facing dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class PublicDashboardResource {

	private final EventDAO eventDAO;
	private final EventTaskDAO eventTaskDAO;
	private final ChatDAO chatDAO;
	private final MeetingDAO meetingDAO;
	private final StorageDAO storageDAO;

	@Autowired
	public PublicDashboardResource(EventDAO eventDAO, EventTaskDAO eventTaskDAO, ChatDAO chatDAO, MeetingDAO meetingDAO,
			StorageDAO storageDAO) {
		this.eventDAO = eventDAO;
		this.eventTaskDAO = eventTaskDAO;
		this.chatDAO = chatDAO;
		this.meetingDAO = meetingDAO;
		this.storageDAO = storageDAO;
	}

	@GetMapping
	@Operation(summary = "Get dashboard data", description = "Retrieves all necessary data for the user's main dashboard view.")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getAllActiveAndUpcomingEvents(); 
		List<Event> recommendedEvents = eventDAO.getPersonalizedEventFeed(user.getId(), 3);
		List<ChatConversation> recentConversations = chatDAO.getConversationsForUser(user.getId());
		List<Meeting> signedUpMeetings = meetingDAO.getUpcomingMeetingsForUser(user);
		List<StorageItem> lowStockItems = storageDAO.getLowStockItems(5);

		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("assignedEvents", assignedEvents);
		dashboardData.put("openTasks", openTasks);
		dashboardData.put("upcomingEvents", upcomingEvents);
		dashboardData.put("recommendedEvents", recommendedEvents);
		dashboardData.put("recentConversations", recentConversations.stream().limit(5).toList());
		dashboardData.put("upcomingMeetings", signedUpMeetings.stream()
				.filter(m -> "ANGEMELDET".equals(m.getUserAttendanceStatus())).limit(5).toList());
		dashboardData.put("lowStockItems", lowStockItems);

		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDocumentationResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.PageDocumentation;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.PageDocumentationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/public/documentation")
@Tag(name = "Public Documentation", description = "Endpoints for viewing page documentation.")
public class PublicDocumentationResource {

	private final PageDocumentationService documentationService;

	@Autowired
	public PublicDocumentationResource(PageDocumentationService documentationService) {
		this.documentationService = documentationService;
	}

	@GetMapping
	@Operation(summary = "Get all accessible documentation pages")
	public ResponseEntity<ApiResponse> getAllDocs(@AuthenticationPrincipal SecurityUser securityUser) {
		boolean isAdmin = securityUser != null && securityUser.getUser().hasAdminAccess();
		List<PageDocumentation> docs = documentationService.findAll(isAdmin);
		return ResponseEntity.ok(new ApiResponse(true, "Documentation pages retrieved.", docs));
	}

	@GetMapping("/{pageKey}")
	@Operation(summary = "Get a single documentation page by key")
	public ResponseEntity<ApiResponse> getDocByKey(@PathVariable String pageKey,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Optional<PageDocumentation> docOpt = documentationService.findByKey(pageKey);
		if (docOpt.isPresent()) {
			PageDocumentation doc = docOpt.get();
			boolean isAdmin = securityUser != null && securityUser.getUser().hasAdminAccess();
			if (doc.isAdminOnly() && !isAdmin) {
				return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, "Access denied.", null));
			}
			return ResponseEntity.ok(new ApiResponse(true, "Documentation retrieved.", doc));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Documentation not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventGalleryResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventPhoto;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventGalleryService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
public class PublicEventGalleryResource {

	private final EventGalleryService galleryService;

	@Autowired
	public PublicEventGalleryResource(EventGalleryService galleryService) {
		this.galleryService = galleryService;
	}

	@GetMapping("/{eventId}/gallery")
	@Operation(summary = "Get all photos for an event gallery")
	public ResponseEntity<ApiResponse> getGallery(@PathVariable int eventId) {
		List<EventPhoto> photos = galleryService.findPhotosByEventId(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "Gallery photos retrieved.", photos));
	}

	@PostMapping("/{eventId}/gallery")
	@Operation(summary = "Upload a photo to an event gallery")
	public ResponseEntity<ApiResponse> uploadPhoto(@PathVariable int eventId, @RequestParam("file") MultipartFile file,
			@RequestParam("caption") String caption, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			EventPhoto photo = galleryService.addPhotoToGallery(eventId, file, caption, securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Photo uploaded successfully.", photo),
					HttpStatus.CREATED);
		} catch (IOException | IllegalArgumentException | SecurityException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@DeleteMapping("/gallery/{photoId}")
	@Operation(summary = "Delete a photo from a gallery")
	public ResponseEntity<ApiResponse> deletePhoto(@PathVariable int photoId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			galleryService.deletePhoto(photoId, securityUser.getUser());
			return ResponseEntity
					.ok(new ApiResponse(true, "Photo deleted successfully.", Map.of("deletedId", photoId)));
		} catch (SecurityException e) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false, e.getMessage(), null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete photo file.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
@SecurityRequirement(name = "bearerAuth")
public class PublicEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;
	private final EventCustomFieldDAO customFieldDAO;
	private final FileService fileService;

	@Autowired
	public PublicEventResource(EventDAO eventDAO, EventService eventService, EventCustomFieldDAO customFieldDAO,
			FileService fileService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
		this.customFieldDAO = customFieldDAO;
		this.fileService = fileService;
	}

	@GetMapping
	@Operation(summary = "Get upcoming events for user", description = "Retrieves a list of upcoming events, indicating the user's current attendance and qualification status for each.")
	public ResponseEntity<ApiResponse> getUpcomingEventsForUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Event> events = eventDAO.getUpcomingEventsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get event details", description = "Retrieves detailed information for a single event.")
	public ResponseEntity<ApiResponse> getEventDetails(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Event event = eventDAO.getEventById(id);
		if (event == null) {
			return ResponseEntity.status(404).body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		if (securityUser != null) {
			String status = eventDAO.getUserAttendanceStatus(id, securityUser.getUser().getId());
			event.setUserAttendanceStatus(status);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungsdetails erfolgreich abgerufen.", event));
	}

	@PostMapping("/{id}/signup")
	@Operation(summary = "Sign up for an event", description = "Allows the current user to sign up for an event and submit custom field responses.")
	public ResponseEntity<ApiResponse> signUpForEvent(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> customFieldResponses) {
		User user = securityUser.getUser();
		eventDAO.signUpForEvent(user.getId(), id);
		if (customFieldResponses != null) {
			customFieldResponses.forEach((key, value) -> {
				if (key.startsWith("customfield_")) {
					int fieldId = Integer.parseInt(key.substring("customfield_".length()));
					EventCustomFieldResponse response = new EventCustomFieldResponse();
					response.setFieldId(fieldId);
					response.setUserId(user.getId());
					response.setResponseValue(value);
					customFieldDAO.saveResponse(response);
				}
			});
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich für die Veranstaltung angemeldet.", null));
	}

	@PostMapping("/{id}/signoff")
	@Operation(summary = "Sign off from an event", description = "Allows the current user to sign off from an event.")
	public ResponseEntity<ApiResponse> signOffFromEvent(
			@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> payload) {
		User user = securityUser.getUser();
		String reason = payload.get("reason");
		Event event = eventDAO.getEventById(id);
		if ("LAUFEND".equals(event.getStatus())) {
			eventService.signOffUserFromRunningEvent(user.getId(), user.getUsername(), id, reason);
		} else {
			eventDAO.signOffFromEvent(user.getId(), id);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich von der Veranstaltung abgemeldet.", null));
	}

	@GetMapping("/{id}/custom-fields")
	@Operation(summary = "Get custom fields for an event", description = "Retrieves the list of custom fields required for signing up for a specific event.")
	public ResponseEntity<ApiResponse> getEventCustomFields(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(id);
		return ResponseEntity.ok(new ApiResponse(true, "Zusatzfelder erfolgreich abgerufen.", fields));
	}

	@PostMapping("/{eventId}/chat/upload")
	@Operation(summary = "Upload a file to an event chat")
	public ResponseEntity<ApiResponse> uploadEventChatFile(@PathVariable int eventId,
			@RequestParam("file") MultipartFile file, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!eventDAO.isUserAssociatedWithEvent(eventId, securityUser.getUser().getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN)
					.body(new ApiResponse(false, "Nicht berechtigt, Dateien in diesem Chat hochzuladen.", null));
		}
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"eventchat/" + eventId);
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFeedbackResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.api.v1.dto.GeneralFeedbackRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/feedback")
@Tag(name = "Public Feedback", description = "Endpoints for users to submit and view feedback.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;
	private final EventFeedbackDAO eventFeedbackDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicFeedbackResource(FeedbackSubmissionDAO submissionDAO, EventFeedbackDAO eventFeedbackDAO,
			EventDAO eventDAO) {
		this.submissionDAO = submissionDAO;
		this.eventFeedbackDAO = eventFeedbackDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/user")
	@Operation(summary = "Get user's feedback submissions", description = "Retrieves a list of all general feedback submissions made by the current user.")
	public ResponseEntity<ApiResponse> getMyFeedbackSubmissions(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<FeedbackSubmission> submissions = submissionDAO.getSubmissionsByUserId(user.getId());
		return ResponseEntity.ok(new ApiResponse(true, "Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PostMapping("/general")
	@Operation(summary = "Submit general feedback", description = "Allows a user to submit a new general feedback entry.")
	public ResponseEntity<ApiResponse> submitGeneralFeedback(@Valid @RequestBody GeneralFeedbackRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		FeedbackSubmission submission = new FeedbackSubmission();
		submission.setUserId(user.getId());
		submission.setSubject(request.subject());
		submission.setContent(request.content());

		if (submissionDAO.createSubmission(submission)) {
			return new ResponseEntity<>(new ApiResponse(true, "Feedback erfolgreich übermittelt.", submission),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Feedback konnte nicht gespeichert werden.", null));
		}
	}

	@GetMapping("/forms")
	@Operation(summary = "Get feedback form for an event", description = "Retrieves the feedback form for a specific event and checks if the user has already submitted a response.")
	public ResponseEntity<ApiResponse> getEventFeedbackForm(
			@Parameter(description = "ID of the event") @RequestParam int eventId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		FeedbackForm form = eventFeedbackDAO.getFeedbackFormForEvent(eventId);
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Kein Feedback-Formular für diese Veranstaltung.", null));
		}
		boolean alreadySubmitted = eventFeedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId());

		Map<String, Object> responseData = Map.of("event", event, "form", form, "alreadySubmitted", alreadySubmitted);
		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/event")
	@Operation(summary = "Submit event feedback", description = "Submits a user's rating and comments for an event feedback form.")
	public ResponseEntity<ApiResponse> submitEventFeedback(@RequestBody FeedbackResponse response,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		response.setUserId(user.getId());

		FeedbackForm form = eventFeedbackDAO.getFormById(response.getFormId());
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Feedback-Formular nicht gefunden.", null));
		}
		if (!eventDAO.isUserAssociatedWithEvent(form.getEventId(), user.getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false,
					"Sie können nur Feedback für Veranstaltungen abgeben, an denen Sie teilgenommen haben.", null));
		}

		if (eventFeedbackDAO.saveFeedbackResponse(response)) {
			return ResponseEntity.ok(new ApiResponse(true, "Event-Feedback erfolgreich übermittelt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Event-Feedback konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFileEditorResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.api.v1.dto.FileContentUpdateRequest;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.File;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;

@RestController
@RequestMapping("/api/v1/public/files/content")
@Tag(name = "Public Files", description = "Endpoints for editing public files.")
public class PublicFileEditorResource {

    private final FileService fileService;
    private final FileDAO fileDAO;

    @Autowired
    public PublicFileEditorResource(FileService fileService, FileDAO fileDAO) {
        this.fileService = fileService;
        this.fileDAO = fileDAO;
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get a public file's text content for editing")
    public ResponseEntity<ApiResponse> getFileContent(@PathVariable int id, @AuthenticationPrincipal SecurityUser securityUser) {
        try {
            File file = fileDAO.getFileById(id);
            if (file == null) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Datei nicht gefunden.", null));
            }
            if (!"NUTZER".equals(file.getRequiredRole()) && !securityUser.getUser().hasAdminAccess()) {
                throw new AccessDeniedException("Sie haben keine Berechtigung, den Inhalt dieser Datei anzuzeigen.");
            }
            String content = fileService.getFileContent(id);
            file.setContent(content);
            return ResponseEntity.ok(new ApiResponse(true, "File content retrieved.", file));
        } catch (IOException | SecurityException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ApiResponse(false, e.getMessage(), null));
        }
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update a public file's text content")
    public ResponseEntity<ApiResponse> updateFileContent(@PathVariable int id, @Valid @RequestBody FileContentUpdateRequest request,
                                                         @AuthenticationPrincipal SecurityUser securityUser) {
        try {
            File file = fileDAO.getFileById(id);
            if (file == null) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Datei nicht gefunden.", null));
            }
            if (!"NUTZER".equals(file.getRequiredRole()) && !securityUser.getUser().hasAdminAccess()) {
                throw new AccessDeniedException("Sie haben keine Berechtigung, den Inhalt dieser Datei zu bearbeiten.");
            }

            if (fileService.updateFileContent(id, request.content(), securityUser.getUser())) {
                return ResponseEntity.ok(new ApiResponse(true, "Datei-Inhalt erfolgreich gespeichert.", null));
            } else {
                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                        .body(new ApiResponse(false, "Speichern des Datei-Inhalts fehlgeschlagen.", null));
            }
        } catch (IOException | SecurityException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(new ApiResponse(false, e.getMessage(), null));
        }
    }
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFilesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.File;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFilesResource {

	private final FileDAO fileDAO;

	@Autowired
	public PublicFilesResource(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@GetMapping
	@Operation(summary = "Get all accessible files grouped by category", description = "Retrieves files visible to the current user, grouped by their category.")
	public ResponseEntity<ApiResponse> getFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, List<File>> files = fileDAO.getAllFilesGroupedByCategory(user);
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", files));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFileStreamResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.*;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
public class PublicFileStreamResource {
	private static final Logger logger = LogManager.getLogger(PublicFileStreamResource.class);

	private final FileDAO fileDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final Path fileStorageLocation;

	@Autowired
	public PublicFileStreamResource(FileDAO fileDAO, AttachmentDAO attachmentDAO, EventDAO eventDAO,
			MeetingDAO meetingDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.attachmentDAO = attachmentDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	@GetMapping("/download/{id}")
	@Operation(summary = "Download a file", description = "Downloads a file (general or attachment) by its database ID after checking permissions.")
	@ApiResponse(responseCode = "200", description = "File content", content = @Content(mediaType = "application/octet-stream"))
	public ResponseEntity<Resource> downloadFile(
			@Parameter(description = "ID of the file or attachment record") @PathVariable int id) {
		String filePathFromDb = null;
		String filenameForDownload = null;

		Attachment attachment = attachmentDAO.getAttachmentById(id);
		if (attachment != null) {
			filePathFromDb = attachment.getFilepath();
			filenameForDownload = attachment.getFilename();
		} else {
			de.technikteam.model.File dbFile = fileDAO.getFileById(id);
			if (dbFile != null) {
				filePathFromDb = dbFile.getFilepath();
				filenameForDownload = dbFile.getFilename();
			}
		}

		if (filePathFromDb == null)
			return ResponseEntity.notFound().build();

		return serveFile(filePathFromDb, filenameForDownload, false);
	}

	@GetMapping("/images/{filename:.+}")
	@Operation(summary = "Get an inventory image", description = "Retrieves an inventory image for display. The filename usually corresponds to a storage item's image path.")
	@ApiResponse(responseCode = "200", description = "Image content", content = @Content(mediaType = "image/*"))
	public ResponseEntity<Resource> getImage(
			@Parameter(description = "The filename of the image") @PathVariable String filename) {
		return serveFile("images/" + filename, filename, true);
	}

	private ResponseEntity<Resource> serveFile(String relativePath, String originalFilename, boolean inline) {
		try {
			Path filePath = this.fileStorageLocation.resolve(relativePath).normalize();
			if (!filePath.startsWith(this.fileStorageLocation)) {
				logger.warn("Path Traversal Attack attempt detected for path '{}'", filePath);
				return ResponseEntity.status(403).build();
			}

			Resource resource = new UrlResource(filePath.toUri());
			if (resource.exists() || resource.isReadable()) {
				String contentType = "application/octet-stream"; 
				try {
					contentType = Files.probeContentType(filePath);
				} catch (IOException e) {
					logger.warn("Could not determine content type for file {}", filePath);
				}

				String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+",
						"%20");
				String disposition = inline ? "inline" : "attachment";

				return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))
						.header(HttpHeaders.CONTENT_DISPOSITION, disposition + "; filename*=UTF-8''" + encodedFilename)
						.body(resource);
			} else {
				logger.error("File not found or not readable at path: {}", filePath);
				return ResponseEntity.notFound().build();
			}
		} catch (MalformedURLException ex) {
			logger.error("Malformed URL for file path: {}", relativePath, ex);
			return ResponseEntity.notFound().build();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicKitResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKit;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/public/kits")
@Tag(name = "Public Kits", description = "Endpoints for viewing inventory kits.")
@SecurityRequirement(name = "bearerAuth")
public class PublicKitResource {

	private final InventoryKitDAO kitDAO;

	@Autowired
	public PublicKitResource(InventoryKitDAO kitDAO) {
		this.kitDAO = kitDAO;
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single kit with its items")
	public ResponseEntity<ApiResponse> getKitById(@PathVariable int id) {
		InventoryKit kit = kitDAO.getKitWithItemsById(id);
		if (kit != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Kit details retrieved.", kit));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Kit not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicMeetingResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Attachment;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.MeetingSignupService;
import de.technikteam.service.TrainingHubService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/meetings")
@Tag(name = "Public Meetings", description = "Endpoints for user interactions with training meetings.")
@SecurityRequirement(name = "bearerAuth")
public class PublicMeetingResource {

	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO attendanceDAO;
	private final AttachmentDAO attachmentDAO;
	private final MeetingSignupService signupService;
	private final TrainingHubService trainingHubService;

	@Autowired
	public PublicMeetingResource(MeetingDAO meetingDAO, MeetingAttendanceDAO attendanceDAO, AttachmentDAO attachmentDAO,
			MeetingSignupService signupService, TrainingHubService trainingHubService) {
		this.meetingDAO = meetingDAO;
		this.attendanceDAO = attendanceDAO;
		this.attachmentDAO = attachmentDAO;
		this.signupService = signupService;
		this.trainingHubService = trainingHubService;
	}

	@GetMapping
	@Operation(summary = "Get upcoming meetings grouped by course for a user", description = "Retrieves a list of courses, each containing its upcoming meetings and the user's status for both the course and each meeting.")
	public ResponseEntity<ApiResponse> getUpcomingMeetings(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		return ResponseEntity.ok(new ApiResponse(true, "Kurse und Termine erfolgreich abgerufen.",
				trainingHubService.getCoursesWithMeetingsForUser(user)));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get meeting details")
	public ResponseEntity<ApiResponse> getMeetingDetails(
			@Parameter(description = "ID of the meeting") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Meeting nicht gefunden.", null));
		}

		String userRole = (securityUser != null && securityUser.getUser() != null)
				? securityUser.getUser().getRoleName()
				: "NUTZER";

		List<Attachment> attachments = attachmentDAO.getAttachmentsForParent("MEETING", id, userRole);

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("meeting", meeting);
		responseData.put("attachments", attachments);

		return ResponseEntity.ok(new ApiResponse(true, "Meeting-Details erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/{id}/{action}")
	@Operation(summary = "Sign up or off from a meeting", description = "Allows the current user to sign up for or sign off from a specific meeting.")
	public ResponseEntity<ApiResponse> handleMeetingAction(
			@Parameter(description = "ID of the meeting") @PathVariable int id,
			@Parameter(description = "Action to perform. Must be 'signup' or 'signoff'.") @PathVariable String action,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		if ("signup".equalsIgnoreCase(action)) {
			MeetingSignupService.SignupResult result = signupService.signupOrWaitlist(user.getId(), id, user.getId());
			Map<String, Object> data = new HashMap<>();
			data.put("status", result.status.name());

			if (result.status == MeetingSignupService.SignupStatus.ENROLLED
					|| result.status == MeetingSignupService.SignupStatus.WAITLISTED) {
				return ResponseEntity.ok(new ApiResponse(true, result.message, data));
			} else if (result.status == MeetingSignupService.SignupStatus.ALREADY_ENROLLED) {
				return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false, result.message, data));
			} else {
				return ResponseEntity.internalServerError().body(new ApiResponse(false, result.message, data));
			}
		} else if ("signoff".equalsIgnoreCase(action)) {
			if (signupService.signoffFromMeeting(user.getId(), id)) {
				return ResponseEntity.ok(new ApiResponse(true, "Abmeldung erfolgreich.", null));
			} else {
				return ResponseEntity.internalServerError()
						.body(new ApiResponse(false, "Abmeldung konnte nicht verarbeitet werden.", null));
			}
		} else {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Unbekannte Aktion.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicNotificationResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.UserNotificationDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.UserNotification;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/notifications")
@Tag(name = "Public Notifications", description = "Endpoints for viewing and managing user notifications.")
@SecurityRequirement(name = "bearerAuth")
public class PublicNotificationResource {

	private final UserNotificationDAO userNotificationDAO;
	private final NotificationService notificationService;

	@Autowired
	public PublicNotificationResource(UserNotificationDAO userNotificationDAO,
			NotificationService notificationService) {
		this.userNotificationDAO = userNotificationDAO;
		this.notificationService = notificationService;
	}

	@GetMapping("/sse")
	@Operation(summary = "Subscribe to SSE notifications", description = "Establishes a Server-Sent Events connection for real-time notifications.")
	public ResponseEntity<SseEmitter> handleSse(@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
		}

		SseEmitter emitter = notificationService.register(securityUser.getUser());
		if (emitter == null) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
		}

		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.TEXT_EVENT_STREAM);
		headers.setCacheControl("no-cache");
		headers.setConnection("keep-alive");

		return new ResponseEntity<>(emitter, headers, HttpStatus.OK);
	}

	@GetMapping
	@Operation(summary = "Get all notifications for the current user")
	public ResponseEntity<ApiResponse> getNotifications(@AuthenticationPrincipal SecurityUser securityUser) {
		List<UserNotification> notifications = userNotificationDAO.findByUser(securityUser.getUser().getId());
		return ResponseEntity.ok(new ApiResponse(true, "Benachrichtigungen abgerufen.", notifications));
	}

	@PostMapping("/mark-all-seen")
	@Operation(summary = "Mark all of the user's notifications as seen")
	public ResponseEntity<ApiResponse> markAllAsSeen(@AuthenticationPrincipal SecurityUser securityUser) {
		userNotificationDAO.markAllAsSeen(securityUser.getUser().getId());
		return ResponseEntity.ok(new ApiResponse(true, "Alle Benachrichtigungen als gelesen markiert.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicProfileResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.PasswordChangeRequest;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.api.v1.dto.TwoFactorSetupDTO;
import de.technikteam.dao.*;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import de.technikteam.service.TwoFactorAuthService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/profile")
@Tag(name = "Public Profile", description = "Endpoints for managing the current user's profile.")
@SecurityRequirement(name = "bearerAuth")
public class PublicProfileResource {
    private static final Logger logger = LogManager.getLogger(PublicProfileResource.class);

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final AchievementDAO achievementDAO;
	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService profileRequestService;
	private final TwoFactorAuthService twoFactorAuthService;

	@Autowired
	public PublicProfileResource(UserDAO userDAO, EventDAO eventDAO, UserQualificationsDAO qualificationsDAO,
			AchievementDAO achievementDAO, ProfileChangeRequestDAO requestDAO,
			ProfileRequestService profileRequestService, TwoFactorAuthService twoFactorAuthService) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.achievementDAO = achievementDAO;
		this.requestDAO = requestDAO;
		this.profileRequestService = profileRequestService;
		this.twoFactorAuthService = twoFactorAuthService;
	}

	@GetMapping
	@Operation(summary = "Get current user's profile data", description = "Retrieves a comprehensive set of data for the authenticated user's profile page.")
	public ResponseEntity<ApiResponse> getMyProfile(@AuthenticationPrincipal SecurityUser securityUser) {
	    logger.debug("Fetching full profile data for user '{}'", securityUser.getUsername());
		User user = userDAO.getUserById(securityUser.getUser().getId()); // Fetch latest user data
		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user);
		profileData.put("eventHistory", eventDAO.getEventHistoryForUser(user.getId()));
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(user.getId()));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(user.getId()));
		profileData.put("passkeys", Collections.emptyList());
		profileData.put("hasPendingRequest", requestDAO.hasPendingRequest(user.getId()));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@GetMapping("/{userId}")
	@Operation(summary = "Get another user's public profile data", description = "Retrieves a public-safe subset of another user's profile data.")
	public ResponseEntity<ApiResponse> getUserProfile(@PathVariable int userId) {
        logger.debug("Fetching public profile data for user ID {}", userId);
		User user = userDAO.getUserById(userId);
		if (user == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Benutzer nicht gefunden.", null));
		}

		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user);
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(userId));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(userId));
		profileData.put("eventHistory", eventDAO.getEventHistoryForUser(userId));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@PostMapping("/request-change")
	@Operation(summary = "Request a profile data change", description = "Submits a request for an administrator to approve changes to the user's profile data.")
	public ResponseEntity<ApiResponse> requestProfileChange(@Valid @RequestBody ProfileChangeRequestDTO requestDTO,
			@AuthenticationPrincipal SecurityUser securityUser) {
        logger.info("Received profile change request from user '{}' with data: {}", securityUser.getUsername(), requestDTO);
		try {
			profileRequestService.createChangeRequest(securityUser.getUser(), requestDTO);
			return ResponseEntity.ok(new ApiResponse(true, "Änderungsantrag erfolgreich eingereicht.", null));
		} catch (Exception e) {
		    logger.error("Error creating profile change request for user '{}'", securityUser.getUsername(), e);
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Ihr Antrag konnte nicht gespeichert werden: " + e.getMessage(), null));
		}
	}

	@PostMapping("/register-device")
	@Operation(summary = "Register a device token for push notifications")
	public ResponseEntity<ApiResponse> registerDevice(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String token = payload.get("token");
		logger.debug("Received request to register FCM token for user '{}'", securityUser.getUsername());
		if (token == null || token.isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Token is required.", null));
		}
		if (userDAO.updateFcmToken(securityUser.getUser().getId(), token)) {
			return ResponseEntity.ok(new ApiResponse(true, "Device token registered successfully.", null));
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Failed to register token.", null));
	}

	@PutMapping("/theme")
	@Operation(summary = "Update user theme", description = "Updates the user's preferred theme (light/dark).")
	public ResponseEntity<ApiResponse> updateUserTheme(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String theme = payload.get("theme");
        logger.debug("User '{}' requested theme change to '{}'", user.getUsername(), theme);
		if (theme != null && (theme.equals("light") || theme.equals("dark"))) {
			if (userDAO.updateUserTheme(user.getId(), theme)) {
				User updatedUser = userDAO.getUserById(user.getId());
				return ResponseEntity.ok(new ApiResponse(true, "Theme aktualisiert.", updatedUser));
			}
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Ungültiges Theme angegeben.", null));
	}

	@PutMapping("/chat-color")
	@Operation(summary = "Update chat color", description = "Updates the user's preferred color for chat messages.")
	public ResponseEntity<ApiResponse> updateChatColor(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String chatColor = payload.get("chatColor");
        logger.debug("User '{}' requested chat color change to '{}'", user.getUsername(), chatColor);
		if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
			return ResponseEntity.ok(new ApiResponse(true, "Chatfarbe aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Chatfarbe konnte nicht gespeichert werden.", null));
		}
	}

	@PutMapping("/password")
	@Operation(summary = "Change password", description = "Allows the authenticated user to change their own password after verifying their current one.")
	public ResponseEntity<ApiResponse> updatePassword(@Valid @RequestBody PasswordChangeRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
        logger.info("Processing password change request for user '{}'", securityUser.getUsername());
		User user = securityUser.getUser();
		if (userDAO.validateUser(user.getUsername(), request.currentPassword()) == null) {
		    logger.warn("Password change failed for user '{}': Incorrect current password provided.", user.getUsername());
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Das aktuelle Passwort ist nicht korrekt.", null));
		}
		if (!request.newPassword().equals(request.confirmPassword())) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Die neuen Passwörter stimmen nicht überein.", null));
		}
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(request.newPassword());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, validationResult.getMessage(), null));
		}
		if (userDAO.changePassword(user.getId(), request.newPassword())) {
		    logger.info("Successfully changed password for user '{}'", user.getUsername());
			return ResponseEntity.ok(new ApiResponse(true, "Ihr Passwort wurde erfolgreich geändert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Passwort konnte nicht geändert werden.", null));
		}
	}

	@PutMapping("/layout")
	@Operation(summary = "Update layout preferences", description = "Saves the user's custom layout and navigation preferences.")
	public ResponseEntity<ApiResponse> updateDashboardLayout(@RequestBody Object layout,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String layoutJson = new Gson().toJson(layout);
        logger.debug("Updating layout for user '{}' with JSON: {}", user.getUsername(), layoutJson);
		if (userDAO.updateDashboardLayout(user.getId(), layoutJson)) {
			User updatedUser = userDAO.getUserById(user.getId());
			return ResponseEntity.ok(new ApiResponse(true, "Layout-Einstellungen gespeichert.", updatedUser));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Layout konnte nicht gespeichert werden.", null));
	}

	@PostMapping("/2fa/setup")
	@Operation(summary = "Start 2FA setup", description = "Generates a new TOTP secret and QR code for the user.")
	public ResponseEntity<ApiResponse> setup2FA(@AuthenticationPrincipal SecurityUser securityUser) {
	    logger.info("Initiating 2FA setup for user '{}'", securityUser.getUsername());
		try {
			TwoFactorSetupDTO setupData = twoFactorAuthService.generateNewSecretAndQrCode(securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "2FA setup data generated.", setupData));
		} catch (Exception e) {
		    logger.error("Error during 2FA setup for user '{}'", securityUser.getUsername(), e);
			return ResponseEntity.internalServerError().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/2fa/enable")
	@Operation(summary = "Verify and enable 2FA", description = "Verifies a TOTP token and enables 2FA for the user, returning backup codes.")
	public ResponseEntity<ApiResponse> enable2FA(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String secret = payload.get("secret");
		String token = payload.get("token");
        logger.info("Attempting to enable 2FA for user '{}'", securityUser.getUsername());
		if (secret == null || token == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Secret and token are required.", null));
		}
		try {
			List<String> backupCodes = twoFactorAuthService.enableTotpForUser(securityUser.getUser().getId(), secret, token);
			return ResponseEntity.ok(new ApiResponse(true, "2FA enabled successfully.", Map.of("backupCodes", backupCodes)));
		} catch (Exception e) {
		    logger.error("Failed to enable 2FA for user '{}': {}", securityUser.getUsername(), e.getMessage());
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/2fa/disable")
	@Operation(summary = "Disable 2FA", description = "Disables 2FA for the user after verifying a current TOTP token.")
	public ResponseEntity<ApiResponse> disable2FA(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String token = payload.get("token");
        logger.info("Attempting to disable 2FA for user '{}'", securityUser.getUsername());
		if (token == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Token is required.", null));
		}
		try {
			twoFactorAuthService.disableTotpForUser(securityUser.getUser().getId(), token);
			return ResponseEntity.ok(new ApiResponse(true, "2FA disabled successfully.", null));
		} catch (Exception e) {
            logger.error("Failed to disable 2FA for user '{}': {}", securityUser.getUsername(), e.getMessage());
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicSearchResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.SearchService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/public/search")
@Tag(name = "Public Search", description = "Endpoints for site-wide content search.")
@SecurityRequirement(name = "bearerAuth")
public class PublicSearchResource {

	private final SearchService searchService;

	@Autowired
	public PublicSearchResource(SearchService searchService) {
		this.searchService = searchService;
	}

	@GetMapping
	@Operation(summary = "Perform a site-wide search", description = "Searches across events, inventory, and documentation for a given query.")
	public ResponseEntity<ApiResponse> search(@Parameter(description = "The search term.") @RequestParam String query,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (query == null || query.trim().length() < 3) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Der Suchbegriff muss mindestens 3 Zeichen lang sein.", null));
		}

		User user = securityUser.getUser();
		return ResponseEntity.ok(new ApiResponse(true, "Suchergebnisse erfolgreich abgerufen.",
				searchService.performSearch(query, user)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicSessionResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.AuthenticationLogDAO;
import de.technikteam.dao.TwoFactorAuthDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.AuthenticationLog;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AuthService;
import io.jsonwebtoken.Claims;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/sessions")
@Tag(name = "Public Sessions", description = "Endpoints for managing user sessions.")
public class PublicSessionResource {

    private final AuthenticationLogDAO authLogDAO;
    private final TwoFactorAuthDAO twoFactorAuthDAO;
    private final AuthService authService;

    @Autowired
    public PublicSessionResource(AuthenticationLogDAO authLogDAO, TwoFactorAuthDAO twoFactorAuthDAO, AuthService authService) {
        this.authLogDAO = authLogDAO;
        this.twoFactorAuthDAO = twoFactorAuthDAO;
        this.authService = authService;
    }

    @GetMapping
    @Operation(summary = "Get all active sessions for the current user")
    public ResponseEntity<ApiResponse> getActiveSessions(@AuthenticationPrincipal SecurityUser securityUser) {
        List<AuthenticationLog> activeSessions = authLogDAO.getActiveSessionsForUser(securityUser.getUser().getId());
        return ResponseEntity.ok(new ApiResponse(true, "Active sessions retrieved.", activeSessions));
    }

    @PostMapping("/{logId}/name")
    @Operation(summary = "Name a device/session")
    public ResponseEntity<ApiResponse> nameDevice(@PathVariable long logId, @RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
        AuthenticationLog log = authLogDAO.getLogById(logId);
        if (log == null || !log.getUserId().equals(securityUser.getUser().getId())) {
            return ResponseEntity.status(403).body(new ApiResponse(false, "Permission denied.", null));
        }

        String deviceName = payload.get("deviceName");
        if (deviceName == null || deviceName.isBlank()) {
            return ResponseEntity.badRequest().body(new ApiResponse(false, "Device name cannot be empty.", null));
        }

        twoFactorAuthDAO.nameKnownIp(securityUser.getUser().getId(), log.getIpAddress(), deviceName);
        return ResponseEntity.ok(new ApiResponse(true, "Device named successfully.", null));
    }

    @PostMapping("/{jti}/revoke")
    @Operation(summary = "Revoke a specific session")
    public ResponseEntity<ApiResponse> revokeSession(@PathVariable String jti, @AuthenticationPrincipal SecurityUser securityUser) {
        AuthenticationLog logToRevoke = authLogDAO.getLogByJti(jti);
        if (logToRevoke == null || !logToRevoke.getUserId().equals(securityUser.getUser().getId())) {
            return ResponseEntity.status(403).body(new ApiResponse(false, "Permission denied to revoke this session.", null));
        }
        
        if (authService.isTokenRevoked(jti)) {
            return ResponseEntity.badRequest().body(new ApiResponse(false, "Diese Sitzung wurde bereits widerrufen.", null));
        }

        authService.revokeToken(jti);
        return ResponseEntity.ok(new ApiResponse(true, "Session revoked successfully.", null));
    }

    @PostMapping("/revoke-all")
    @Operation(summary = "Revoke all other sessions for the current user")
    public ResponseEntity<ApiResponse> revokeAllOtherSessions(@AuthenticationPrincipal SecurityUser securityUser) {
        String currentTokenJti = securityUser.getUser().getJti(); // Assuming JTI is added to SecurityUser
        List<AuthenticationLog> activeSessions = authLogDAO.getActiveSessionsForUser(securityUser.getUser().getId());
        
        int revokedCount = 0;
        for (AuthenticationLog session : activeSessions) {
            if (!session.getJti().equals(currentTokenJti)) {
                authService.revokeToken(session.getJti());
                revokedCount++;
            }
        }
        
        return ResponseEntity.ok(new ApiResponse(true, revokedCount + " other sessions have been revoked.", null));
    }
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageDetailsResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.StorageLogEntry;
import de.technikteam.service.StorageItemRelationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageDetailsResource {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;
	private final StorageItemRelationService relationService;

	@Autowired
	public PublicStorageDetailsResource(StorageDAO storageDAO, StorageLogDAO storageLogDAO,
			MaintenanceLogDAO maintenanceLogDAO, StorageItemRelationService relationService) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
		this.relationService = relationService;
	}

	@GetMapping("/{itemId}")
	@Operation(summary = "Get a single storage item by ID", description = "Retrieves detailed information for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemById(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Artikel nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Artikeldetails erfolgreich abgerufen.", item));
	}

	@GetMapping("/{itemId}/history")
	@Operation(summary = "Get history for a storage item", description = "Retrieves the transaction and maintenance history for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemHistory(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		List<StorageLogEntry> transactions = storageLogDAO.getHistoryForItem(itemId);
		List<MaintenanceLogEntry> maintenance = maintenanceLogDAO.getHistoryForItem(itemId);

		Map<String, Object> historyData = new HashMap<>();
		historyData.put("transactions", transactions);
		historyData.put("maintenance", maintenance);

		return ResponseEntity.ok(new ApiResponse(true, "Verlauf erfolgreich abgerufen.", historyData));
	}

	@GetMapping("/{itemId}/reservations")
	@Operation(summary = "Get future reservations for a storage item", description = "Retrieves a list of events for which the item is reserved in the future.")
	public ResponseEntity<ApiResponse> getStorageItemReservations(@PathVariable int itemId) {
		List<Map<String, Object>> reservations = storageDAO.getFutureReservationsForItem(itemId);
		return ResponseEntity.ok(new ApiResponse(true, "Reservierungen erfolgreich abgerufen.", reservations));
	}

	@GetMapping("/{itemId}/relations")
	@Operation(summary = "Get related items for a storage item")
	public ResponseEntity<ApiResponse> getRelatedItems(@PathVariable int itemId) {
		return ResponseEntity
				.ok(new ApiResponse(true, "Related items retrieved.", relationService.findRelatedItems(itemId)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageResource {

	private final StorageService storageService;
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicStorageResource(StorageService storageService, StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageService = storageService;
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping
	@Operation(summary = "Get all storage data for display", description = "Retrieves all storage items grouped by location and a list of active events for the transaction modal.")
	public ResponseEntity<ApiResponse> getStoragePageData() {
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("storageData", storageData);
		responseData.put("activeEvents", activeEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Lagerdaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/transactions")
	@Operation(summary = "Perform a storage transaction", description = "Checks out or checks in a specified quantity of a storage item.")
	public ResponseEntity<ApiResponse> performTransaction(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		try {
			int itemId = ((Number) payload.get("itemId")).intValue();
			int quantity = ((Number) payload.get("quantity")).intValue();
			String type = (String) payload.get("type");
			String notes = (String) payload.get("notes");
			Integer eventId = payload.get("eventId") != null && !payload.get("eventId").toString().isEmpty()
					? ((Number) payload.get("eventId")).intValue()
					: null;

			if (storageService.processTransaction(itemId, quantity, type, user, eventId, notes)) {
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				return ResponseEntity
						.ok(new ApiResponse(true, "Erfolgreich " + quantity + " Stück " + action + ".", null));
			} else {
				return ResponseEntity.badRequest().body(new ApiResponse(false, "Transaktion fehlgeschlagen.", null));
			}
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{itemId}/report-damage")
	@Operation(summary = "Report damage for an item", description = "Allows a user to submit a damage report for a specific inventory item.")
	public ResponseEntity<ApiResponse> reportDamage(@PathVariable int itemId, @RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String description = payload.get("description");
		if (description == null || description.isBlank()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Eine Beschreibung ist erforderlich.", null));
		}

		try {
			storageService.createDamageReport(itemId, securityUser.getUser().getId(), description);
			return ResponseEntity.ok(
					new ApiResponse(true, "Schadensmeldung erfolgreich übermittelt. Ein Admin wird sie prüfen.", null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Meldung konnte nicht gespeichert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicTrainingRequestResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.TrainingRequest;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.TrainingRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/training-requests")
@Tag(name = "Public Training Requests", description = "Endpoints for user-initiated training requests.")
public class PublicTrainingRequestResource {

	private final TrainingRequestService trainingRequestService;

	@Autowired
	public PublicTrainingRequestResource(TrainingRequestService trainingRequestService) {
		this.trainingRequestService = trainingRequestService;
	}

	@PostMapping
	@Operation(summary = "Submit a new training request")
	public ResponseEntity<ApiResponse> submitRequest(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String topic = payload.get("topic");
		if (topic == null || topic.isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Topic cannot be empty.", null));
		}
		TrainingRequest request = trainingRequestService.create(topic, securityUser.getUser());
		return new ResponseEntity<>(new ApiResponse(true, "Training request submitted successfully.", request),
				HttpStatus.CREATED);
	}

	@PostMapping("/{id}/interest")
	@Operation(summary = "Register interest in a training request")
	public ResponseEntity<ApiResponse> registerInterest(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (trainingRequestService.registerInterest(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Interest registered successfully.", null));
		}
		return ResponseEntity.notFound().build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}

		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\GlobalExceptionHandler.java
========================================================================

package de.technikteam.config;

import de.technikteam.model.ApiResponse;
import de.technikteam.security.UserSuspendedException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

	private static final Logger logger = LogManager.getLogger(GlobalExceptionHandler.class);

	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
		String errors = ex.getBindingResult().getFieldErrors().stream()
				.map(error -> error.getField() + ": " + error.getDefaultMessage()).collect(Collectors.joining(", "));
		ApiResponse apiResponse = new ApiResponse(false, "Validierung fehlgeschlagen: " + errors, null);
		return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
	}

	@ExceptionHandler(AccessDeniedException.class)
	public ResponseEntity<ApiResponse> handleAccessDeniedException(AccessDeniedException ex) {
		ApiResponse apiResponse = new ApiResponse(false,
				ex.getMessage() != null ? ex.getMessage() : "Zugriff verweigert.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
	}

	@ExceptionHandler(UserSuspendedException.class)
	public ResponseEntity<ApiResponse> handleUserSuspendedException(UserSuspendedException ex) {
		ApiResponse apiResponse = new ApiResponse(false, ex.getMessage(), null);
		return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
	}

	@ExceptionHandler(Exception.class)
	public ResponseEntity<ApiResponse> handleAllExceptions(Exception ex) {
		logger.error("An unexpected internal server error occurred", ex);
		ApiResponse apiResponse = new ApiResponse(false,
				"Ein unerwarteter interner Serverfehler ist aufgetreten. Bitte kontaktieren Sie den Support.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.INTERNAL_SERVER_ERROR);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\InitialAdminCreator.java
========================================================================

package de.technikteam.config;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Role;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

@Component
public class InitialAdminCreator implements CommandLineRunner {

	private static final Logger logger = LogManager.getLogger(InitialAdminCreator.class);

	private final UserDAO userDAO;
	private final UserService userService;
	private final PermissionDAO permissionDAO;
	private final RoleDAO roleDAO;

	@Autowired
	public InitialAdminCreator(UserDAO userDAO, UserService userService, PermissionDAO permissionDAO, RoleDAO roleDAO) {
		this.userDAO = userDAO;
		this.userService = userService;
		this.permissionDAO = permissionDAO;
		this.roleDAO = roleDAO;
	}

	@Override
	public void run(String... args) throws Exception {
		if (userDAO.getUserByUsername("admin") == null) {
			logger.warn("############################################################");
			logger.warn("##              FIRST TIME SETUP DETECTED                 ##");
			logger.warn("##     Creating default 'admin' user with a random pass   ##");
			logger.warn("############################################################");

			User adminUser = new User();
			adminUser.setUsername("admin");

			// Dynamically find the ADMIN role ID
			Role adminRole = roleDAO.getAllRoles().stream()
					.filter(role -> "ADMIN".equalsIgnoreCase(role.getRoleName()))
					.findFirst()
					.orElseThrow(() -> new RuntimeException("CRITICAL: 'ADMIN' role not found in database. Cannot create initial admin user."));
			adminUser.setRoleId(adminRole.getId());

//			String randomPassword = generateRandomPassword(8);
			String randomPassword = "TechnikTeam1+";

			List<String> permissionKeysToGrant = List.of(Permissions.ACCESS_ADMIN_PANEL, Permissions.NOTIFICATION_SEND,
					Permissions.LOG_READ, Permissions.LOG_REVOKE);
			List<String> permissionIds = new ArrayList<>();

			for (String key : permissionKeysToGrant) {
				Integer id = permissionDAO.getPermissionIdByKey(key);
				if (id != null) {
					permissionIds.add(String.valueOf(id));
				} else {
					logger.error(
							"FATAL: Could not find the essential permission '{}'. The default admin user will lack this right.",
							key);
				}
			}

			userService.createUserWithPermissions(adminUser, randomPassword, permissionIds.toArray(new String[0]),
					"SYSTEM");

			logger.warn("############################################################");
			logger.warn("##                ADMIN USER CREATED                      ##");
			logger.warn("##                                                        ##");
			logger.warn("##    Username: admin                                     ##");
			logger.warn("##    Password: " + randomPassword + "                     ##");
			logger.warn("##                                                        ##");
			logger.warn("##   !!! PLEASE COPY THIS PASSWORD AND STORE IT SAFELY.   ##");
			logger.warn("##             IT WILL NOT BE SHOWN AGAIN.                ##");
			logger.warn("############################################################");
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON) and
 * deserialization (JSON to Java), preventing reflection issues with the Java
 * Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

	private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

	@Override
	public void write(JsonWriter out, LocalDateTime value) throws IOException {
		if (value == null) {
			out.nullValue();
		} else {
			out.value(value.format(FORMATTER));
		}
	}

	@Override
	public LocalDateTime read(JsonReader in) throws IOException {
		if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
			in.nextNull();
			return null;
		}
		String value = in.nextString();
		return LocalDateTime.parse(value, FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\OpenApiConfig.java
========================================================================

package de.technikteam.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

	@Bean
	public OpenAPI customOpenAPI() {
		final String securitySchemeName = "bearerAuth";
		return new OpenAPI()
				.info(new Info().title("TechnikTeam API").version("v1.0.0").description(
						"This is the complete REST API for the TechnikTeam Event & Crew Management System."))
				.addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
				.components(new Components().addSecuritySchemes(securitySchemeName, new SecurityScheme()
						.name(securitySchemeName).type(SecurityScheme.Type.HTTP).scheme("bearer").bearerFormat("JWT")));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\Permissions.java
========================================================================

package de.technikteam.config;

/**
 * A central repository for all permission key constants used throughout the
 * application. This prevents the use of "magic strings" for permission checks,
 * reducing typos and making the code more maintainable and readable.
 */
public final class Permissions {

	private Permissions() {
	}

	// --- GLOBAL ---
	public static final String ACCESS_ADMIN_PANEL = "ACCESS_ADMIN_PANEL";

	// --- USER MANAGEMENT ---
	public static final String USER_CREATE = "USER_CREATE";
	public static final String USER_READ = "USER_READ";
	public static final String USER_UPDATE = "USER_UPDATE";
	public static final String USER_DELETE = "USER_DELETE";
	public static final String USER_PASSWORD_RESET = "USER_PASSWORD_RESET";

	// --- EVENT MANAGEMENT ---
	public static final String EVENT_CREATE = "EVENT_CREATE";
	public static final String EVENT_READ = "EVENT_READ";
	public static final String EVENT_UPDATE = "EVENT_UPDATE";
	public static final String EVENT_DELETE = "EVENT_DELETE";
	public static final String EVENT_MANAGE_ASSIGNMENTS = "EVENT_MANAGE_ASSIGNMENTS";
	public static final String EVENT_MANAGE_TASKS = "EVENT_MANAGE_TASKS";
	public static final String EVENT_DEBRIEFING_VIEW = "EVENT_DEBRIEFING_VIEW";
	public static final String EVENT_DEBRIEFING_MANAGE = "EVENT_DEBRIEFING_MANAGE";

	// --- COURSE & MEETING MANAGEMENT ---
	public static final String COURSE_CREATE = "COURSE_CREATE";
	public static final String COURSE_READ = "COURSE_READ";
	public static final String COURSE_UPDATE = "COURSE_UPDATE";
	public static final String COURSE_DELETE = "COURSE_DELETE";

	// --- STORAGE & INVENTORY ---
	public static final String STORAGE_CREATE = "STORAGE_CREATE";
	public static final String STORAGE_READ = "STORAGE_READ";
	public static final String STORAGE_UPDATE = "STORAGE_UPDATE";
	public static final String STORAGE_DELETE = "STORAGE_DELETE";
	public static final String DAMAGE_REPORT_MANAGE = "DAMAGE_REPORT_MANAGE";

	// --- KIT MANAGEMENT ---
	public static final String KIT_CREATE = "KIT_CREATE";
	public static final String KIT_READ = "KIT_READ";
	public static final String KIT_UPDATE = "KIT_UPDATE";
	public static final String KIT_DELETE = "KIT_DELETE";

	// --- QUALIFICATIONS ---
	public static final String QUALIFICATION_READ = "QUALIFICATION_READ";
	public static final String QUALIFICATION_UPDATE = "QUALIFICATION_UPDATE";

	// --- FILE MANAGEMENT ---
	public static final String FILE_CREATE = "FILE_CREATE";
	public static final String FILE_READ = "FILE_READ";
	public static final String FILE_UPDATE = "FILE_UPDATE";
	public static final String FILE_DELETE = "FILE_DELETE";
	public static final String FILE_MANAGE = "FILE_MANAGE";

	// --- SYSTEM & REPORTING ---
	public static final String LOG_READ = "LOG_READ";
	public static final String REPORT_READ = "REPORT_READ";
	public static final String SYSTEM_READ = "SYSTEM_READ";
	public static final String LOG_REVOKE = "LOG_REVOKE";

	// --- ACHIEVEMENTS ---
	public static final String ACHIEVEMENT_CREATE = "ACHIEVEMENT_CREATE";
	public static final String ACHIEVEMENT_UPDATE = "ACHIEVEMENT_UPDATE";
	public static final String ACHIEVEMENT_DELETE = "ACHIEVEMENT_DELETE";
	public static final String ACHIEVEMENT_VIEW = "ACHIEVEMENT_VIEW";

	// --- NOTIFICATIONS ---
	public static final String NOTIFICATION_SEND = "NOTIFICATION_SEND";

	// --- DOCUMENTATION ---
	public static final String DOCUMENTATION_MANAGE = "DOCUMENTATION_MANAGE";

	// --- NAVIGATION-SPECIFIC ---
	public static final String ADMIN_DASHBOARD_ACCESS = "ADMIN_DASHBOARD_ACCESS";
}
========================================================================
FILE: src\main\java\de\technikteam\config\SanitizerConfig.java
========================================================================

package de.technikteam.config;

import org.owasp.html.HtmlPolicyBuilder;
import org.owasp.html.PolicyFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SanitizerConfig {

	/**
	 * A policy factory that allows common text formatting and block-level elements.
	 * Suitable for rich text content like event descriptions. Allows: <b>, <i>,
	 * <u>, <s>, <sub>, <sup>,
	 * <p>
	 * , <blockquote>,
	 * <ul>
	 * ,
	 * <ol>
	 * ,
	 * <li>, <br>
	 * ,
	 * <h1>-
	 * <h6>
	 */
	@Bean("richTextPolicy")
	public PolicyFactory richTextPolicy() {
		return new HtmlPolicyBuilder().allowCommonBlockElements() // p, div, h1-h6, etc.
				.allowCommonInlineFormattingElements() // b, i, u, etc.
				.allowElements("br", "ul", "ol", "li", "blockquote", "s", "sub", "sup").toFactory();
	}

	/**
	 * A stricter policy that only allows inline formatting, no block elements.
	 * Suitable for single-line content or chat messages where block elements are
	 * undesirable. Allows: <b>, <i>, <u>, <s>, <sub>, <sup>
	 */
	@Bean("inlineFormattingPolicy")
	public PolicyFactory inlineFormattingPolicy() {
		return new HtmlPolicyBuilder().allowCommonInlineFormattingElements().allowElements("s", "sub", "sup")
				.toFactory();
	}

	/**
	 * A policy that strips all HTML, leaving only plain text. Useful for fields
	 * that should not contain any formatting.
	 */
	@Bean("plainTextPolicy")
	public PolicyFactory plainTextPolicy() {
		return new HtmlPolicyBuilder().toFactory(); 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\WebMvcConfig.java
========================================================================

package de.technikteam.config;

import de.technikteam.security.RateLimitingInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
	private final RateLimitingInterceptor rateLimitingInterceptor;

	@Autowired
	public WebMvcConfig(RateLimitingInterceptor rateLimitingInterceptor) {
		this.rateLimitingInterceptor = rateLimitingInterceptor;
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		// Rate limiting is disabled to remove all verification.
		// registry.addInterceptor(rateLimitingInterceptor).addPathPatterns("/api/v1/auth/login")
		// .addPathPatterns("/api/v1/users/**").addPathPatterns("/api/v1/events/**")
		// .addPathPatterns("/api/v1/storage/**").addPathPatterns("/api/v1/kits/**")
		// .addPathPatterns("/api/v1/courses/**").addPathPatterns("/api/v1/meetings/**")
		// .addPathPatterns("/api/v1/feedback/**").addPathPatterns("/api/v1/public/feedback/**")
		// .addPathPatterns("/api/v1/public/profile/**");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Achievement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AchievementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Achievement> achievementRowMapper = (rs, rowNum) -> {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	};

	public List<Achievement> getAllAchievements() {
		String sql = "SELECT * FROM achievements ORDER BY name";
		try {
			return jdbcTemplate.query(sql, achievementRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all achievements", e);
			return List.of();
		}
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, achievementRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching achievement by ID {}", id, e);
			return null;
		}
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, achievement.getAchievementKey(), achievement.getName(),
					achievement.getDescription(), achievement.getIconClass()) > 0;
		} catch (Exception e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, achievement.getName(), achievement.getDescription(),
					achievement.getIconClass(), achievement.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try {
			jdbcTemplate.update("DELETE FROM user_achievements WHERE achievement_id = ?", id);
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		String sql = "SELECT a.*, ua.earned_at FROM achievements a JOIN user_achievements ua ON a.id = ua.achievement_id WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Achievement ach = achievementRowMapper.mapRow(rs, rowNum);
				ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
				return ach;
			}, userId);
		} catch (Exception e) {
			logger.error("Error fetching achievements for user {}", userId, e);
			return List.of();
		}
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			return false; 
		}
		String sql = "INSERT INTO user_achievements (user_id, achievement_id) SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try {
			return jdbcTemplate.update(sql, userId, achievementKey) > 0;
		} catch (Exception e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
			return false;
		}
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT COUNT(*) FROM user_achievements ua JOIN achievements a ON ua.achievement_id = a.id WHERE ua.user_id = ? AND a.achievement_key = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId, achievementKey);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.AdminLog;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AdminLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<AdminLog> rowMapper = (rs, rowNum) -> {
		AdminLog logEntry = new AdminLog();
		logEntry.setId(rs.getInt("id"));
		logEntry.setAdminUsername(rs.getString("admin_username"));
		logEntry.setActionType(rs.getString("action_type"));
		logEntry.setDetails(rs.getString("details"));
		logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
		logEntry.setStatus(rs.getString("status"));
		logEntry.setContext(rs.getString("context"));
		logEntry.setRevokedByAdminId(rs.getObject("revoked_by_admin_id", Integer.class));
		if (rs.getTimestamp("revoked_at") != null) {
			logEntry.setRevokedAt(rs.getTimestamp("revoked_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(rs, "revoking_admin_username")) {
			logEntry.setRevokingAdminUsername(rs.getString("revoking_admin_username"));
		}
		if (DaoUtils.hasColumn(rs, "admin_user_id")) {
			logEntry.setAdminUserId(rs.getObject("admin_user_id", Integer.class));
		}
		return logEntry;
	};

	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details, context) VALUES (?, ?, ?, ?)";
		try {
			jdbcTemplate.update(sql, log.getAdminUsername(), log.getActionType(), log.getDetails(), log.getContext());
		} catch (Exception e) {
			logger.error("Failed to create admin log for user '{}'.", log.getAdminUsername(), e);
		}
	}

	public List<AdminLog> getAllLogs() {
		String sql = "SELECT l.*, u.id as admin_user_id, a.username as revoking_admin_username " + "FROM admin_logs l "
				+ "LEFT JOIN users u ON l.admin_username = u.username "
				+ "LEFT JOIN users a ON l.revoked_by_admin_id = a.id " + "ORDER BY l.action_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, rowMapper);
		} catch (Exception e) {
			logger.error("Failed to fetch admin logs from the database.", e);
			return List.of();
		}
	}

	public AdminLog getLogById(long logId) {
		String sql = "SELECT l.*, u.id as admin_user_id, a.username as revoking_admin_username " + "FROM admin_logs l "
				+ "LEFT JOIN users u ON l.admin_username = u.username "
				+ "LEFT JOIN users a ON l.revoked_by_admin_id = a.id " + "WHERE l.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, rowMapper, logId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Failed to fetch admin log with ID: {}", logId, e);
			return null;
		}
	}

	public boolean updateStatus(long logId, String status, int revokingAdminId) {
		String sql = "UPDATE admin_logs SET status = ?, revoked_by_admin_id = ?, revoked_at = NOW() WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, status, revokingAdminId, logId) > 0;
		} catch (Exception e) {
			logger.error("Failed to update status for log ID: {}", logId, e);
			return false;
		}
	}

	public List<AdminLog> getRecentLogs(int limit) {
		String sql = "SELECT l.*, u.id as admin_user_id, a.username as revoking_admin_username " + "FROM admin_logs l "
				+ "LEFT JOIN users u ON l.admin_username = u.username "
				+ "LEFT JOIN users a ON l.revoked_by_admin_id = a.id " + "ORDER BY l.action_timestamp DESC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, rowMapper, limit);
		} catch (Exception e) {
			logger.error("Failed to fetch recent admin logs from the database.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AnnouncementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Announcement;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class AnnouncementDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AnnouncementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Announcement> rowMapper = (rs, rowNum) -> {
		Announcement announcement = new Announcement();
		announcement.setId(rs.getInt("id"));
		announcement.setTitle(rs.getString("title"));
		announcement.setContent(rs.getString("content"));
		announcement.setAuthorUserId(rs.getInt("author_user_id"));
		announcement.setAuthorUsername(rs.getString("author_username"));
		announcement.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return announcement;
	};

	public List<Announcement> findAll() {
		String sql = "SELECT a.*, u.username as author_username FROM announcements a JOIN users u ON a.author_user_id = u.id ORDER BY a.created_at DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<Announcement> findById(int id) {
		String sql = "SELECT a.*, u.username as author_username FROM announcements a JOIN users u ON a.author_user_id = u.id WHERE a.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public Announcement create(Announcement announcement) {
		String sql = "INSERT INTO announcements (title, content, author_user_id) VALUES (?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, announcement.getTitle());
			ps.setString(2, announcement.getContent());
			ps.setInt(3, announcement.getAuthorUserId());
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		announcement.setId(newId);
		return announcement;
	}

	public Announcement update(Announcement announcement) {
		String sql = "UPDATE announcements SET title = ?, content = ? WHERE id = ?";
		jdbcTemplate.update(sql, announcement.getTitle(), announcement.getContent(), announcement.getId());
		return announcement;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM announcements WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AttachmentDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Attachment> attachmentRowMapper = (rs, rowNum) -> {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	};

	public boolean addAttachment(Attachment attachment) {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, attachment.getParentType(), attachment.getParentId(),
					attachment.getFilename(), attachment.getFilepath(), attachment.getRequiredRole()) > 0;
		} catch (Exception e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try {
			return jdbcTemplate.query(sql, attachmentRowMapper, parentType, parentId);
		} catch (Exception e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
			return List.of();
		}
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, attachmentRowMapper, attachmentId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
			return null;
		}
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, attachmentId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AuthenticationLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.AuthenticationLog;
import de.technikteam.util.DaoUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public class AuthenticationLogDAO {

    private final JdbcTemplate jdbcTemplate;

    @Autowired
    public AuthenticationLogDAO(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    private final RowMapper<AuthenticationLog> rowMapper = (rs, rowNum) -> {
        AuthenticationLog log = new AuthenticationLog();
        log.setId(rs.getLong("id"));
        log.setUserId(rs.getObject("user_id", Integer.class));
        log.setUsername(rs.getString("username"));
        log.setIpAddress(rs.getString("ip_address"));
        log.setUserAgent(rs.getString("user_agent"));
        log.setDeviceType(rs.getString("device_type"));
        log.setCountryCode(rs.getString("country_code"));
        log.setEventType(rs.getString("event_type"));
        log.setTimestamp(rs.getTimestamp("timestamp").toLocalDateTime());
        log.setJti(rs.getString("jti"));
        if (rs.getTimestamp("token_expiry") != null) {
            log.setTokenExpiry(rs.getTimestamp("token_expiry").toLocalDateTime());
        }
        if (DaoUtils.hasColumn(rs, "is_revoked")) {
            log.setRevoked(rs.getBoolean("is_revoked"));
        }
        return log;
    };

    public void createLog(AuthenticationLog log) {
        String sql = "INSERT INTO authentication_logs (user_id, username, ip_address, event_type, jti, token_expiry, user_agent, device_type, country_code) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)";
        Object[] args = {
                log.getUserId(), log.getUsername(), log.getIpAddress(), log.getEventType(), log.getJti(),
                log.getTokenExpiry() != null ? Timestamp.valueOf(log.getTokenExpiry()) : null,
                log.getUserAgent(), log.getDeviceType(), log.getCountryCode()
        };
        int[] types = {
                Types.INTEGER, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR,
                Types.TIMESTAMP, Types.VARCHAR, Types.VARCHAR, Types.VARCHAR
        };
        jdbcTemplate.update(sql, args, types);
    }

    public List<AuthenticationLog> getLogs(int limit) {
        String sql = "SELECT l.*, (b.jti IS NOT NULL) AS is_revoked " +
                     "FROM authentication_logs l " +
                     "LEFT JOIN jwt_blocklist b ON l.jti = b.jti " +
                     "WHERE l.event_type IN ('LOGIN_SUCCESS', 'LOGOUT') " +
                     "ORDER BY l.timestamp DESC LIMIT ?";
        return jdbcTemplate.query(sql, rowMapper, limit);
    }

    public AuthenticationLog getPreviousLoginInfo(int userId) {
        String sql = "SELECT * FROM authentication_logs WHERE user_id = ? AND event_type = 'LOGIN_SUCCESS' ORDER BY timestamp DESC LIMIT 1 OFFSET 1";
        try {
            return jdbcTemplate.queryForObject(sql, rowMapper, userId);
        } catch (EmptyResultDataAccessException e) {
            return null; // This is expected for the first-ever login
        }
    }

    public LocalDateTime getTimestampOfLastLogin(int userId) {
        String sql = "SELECT timestamp FROM authentication_logs WHERE user_id = ? AND event_type = 'LOGIN_SUCCESS' ORDER BY timestamp DESC LIMIT 1";
        try {
            return jdbcTemplate.queryForObject(sql, LocalDateTime.class, userId);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }
    
    public AuthenticationLog getLogByJti(String jti) {
        String sql = "SELECT * FROM authentication_logs WHERE jti = ?";
        try {
            return jdbcTemplate.queryForObject(sql, rowMapper, jti);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

    public AuthenticationLog getLogById(long logId) {
        String sql = "SELECT * FROM authentication_logs WHERE id = ?";
        try {
            return jdbcTemplate.queryForObject(sql, rowMapper, logId);
        } catch (EmptyResultDataAccessException e) {
            return null;
        }
    }

    public List<AuthenticationLog> getActiveSessionsForUser(int userId) {
        String sql = "SELECT l.*, (b.jti IS NOT NULL) AS is_revoked " +
                     "FROM authentication_logs l " +
                     "LEFT JOIN jwt_blocklist b ON l.jti = b.jti " +
                     "WHERE l.user_id = ? AND l.event_type = 'LOGIN_SUCCESS' AND l.token_expiry > NOW() AND b.jti IS NULL " +
                     "ORDER BY l.timestamp DESC";
        return jdbcTemplate.query(sql, rowMapper, userId);
    }
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChangelogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.model.Changelog;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.lang.reflect.Type;
import java.sql.Date;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Repository
public class ChangelogDAO {

	private final JdbcTemplate jdbcTemplate;
	private final Gson gson = new Gson();
	private final Type listType = new TypeToken<List<Integer>>() {
	}.getType();

	@Autowired
	public ChangelogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Changelog> rowMapper = (rs, rowNum) -> {
		Changelog cl = new Changelog();
		cl.setId(rs.getInt("id"));
		cl.setVersion(rs.getString("version"));
		cl.setReleaseDate(rs.getDate("release_date").toLocalDate());
		cl.setTitle(rs.getString("title"));
		cl.setNotes(rs.getString("notes"));
		String seenByJson = rs.getString("seen_by_users");
		cl.setSeenByUserIds(gson.fromJson(seenByJson, listType));
		return cl;
	};

	public Optional<Changelog> findById(int id) {
		String sql = "SELECT * FROM changelogs WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public List<Changelog> findAll() {
		String sql = "SELECT * FROM changelogs ORDER BY release_date DESC, version DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<Changelog> findLatestUnseen(int userId) {
		String sql = "SELECT * FROM changelogs WHERE NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$') ORDER BY release_date DESC, version DESC LIMIT 1";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, String.valueOf(userId)));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public boolean markAsSeen(int changelogId, int userId) {
		String sql = "UPDATE changelogs SET seen_by_users = JSON_ARRAY_APPEND(seen_by_users, '$', ?) WHERE id = ? AND NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$')";
		return jdbcTemplate.update(sql, userId, changelogId, String.valueOf(userId)) > 0;
	}

	public boolean create(Changelog changelog) {
		String sql = "INSERT INTO changelogs (version, release_date, title, notes) VALUES (?, ?, ?, ?)";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes()) > 0;
	}

	public boolean update(Changelog changelog) {
		String sql = "UPDATE changelogs SET version = ?, release_date = ?, title = ?, notes = ? WHERE id = ?";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes(), changelog.getId()) > 0;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM changelogs WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}