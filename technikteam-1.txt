
========================================================================
FILE: src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public InventoryKitDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<InventoryKit> kitRowMapper = (rs, rowNum) -> {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>());
		return kit;
	};

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, kit.getName());
				ps.setString(2, kit.getDescription());
				ps.setString(3, kit.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
			return 0;
		}
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, kit.getName(), kit.getDescription(), kit.getLocation(), kit.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, kitRowMapper, kitId);
		} catch (EmptyResultDataAccessException e) {
			return null; // Expected case when not found
		} catch (Exception e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
			return null;
		}
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try {
			// First, delete dependencies in the linking table
			jdbcTemplate.update("DELETE FROM inventory_kit_items WHERE kit_id = ?", kitId);
			// Then, delete the kit itself
			return jdbcTemplate.update(sql, kitId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, ki.item_id, ki.quantity, si.name as item_name FROM inventory_kits k LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id LEFT JOIN storage_items si ON ki.item_id = si.id ORDER BY k.name, si.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int kitId = rs.getInt("id");
			InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
				try {
					return kitRowMapper.mapRow(rs, 0);
				} catch (SQLException e) {
					// This is a safe way to handle checked exceptions within a lambda
					throw new RuntimeException("Failed to map ResultSet to InventoryKit", e);
				}
			});
			if (rs.getInt("item_id") > 0) {
				InventoryKitItem item = new InventoryKitItem();
				item.setKitId(kitId);
				item.setItemId(rs.getInt("item_id"));
				item.setQuantity(rs.getInt("quantity"));
				item.setItemName(rs.getString("item_name"));
				kit.getItems().add(item);
			}
		});
		return new ArrayList<>(kitMap.values());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MaintenanceLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, log.getItemId(), log.getUserId(), log.getAction(), log.getNotes(),
					log.getCost()) > 0;
		} catch (Exception e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml JOIN users u ON ml.user_id = u.id WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MaintenanceLogEntry entry = new MaintenanceLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
				entry.setAction(rs.getString("action"));
				entry.setNotes(rs.getString("notes"));
				entry.setCost(rs.getDouble("cost"));
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingAttendanceDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";
		try {
			jdbcTemplate.update(sql, userId, meetingId, attended, remarks);
			return true;
		} catch (Exception e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	public List<MeetingAttendance> getAllAttendance() {
		String sql = "SELECT * FROM meeting_attendance";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MeetingAttendance attendance = new MeetingAttendance();
				attendance.setUserId(rs.getInt("user_id"));
				attendance.setMeetingId(rs.getInt("meeting_id"));
				attendance.setAttended(rs.getBoolean("attended"));
				attendance.setRemarks(rs.getString("remarks"));
				return attendance;
			});
		} catch (Exception e) {
			logger.error("SQL error fetching all attendance records.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Meeting> meetingRowMapper = (rs, rowNum) -> {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null)
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));
		return meeting;
	};

	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, meeting.getCourseId());
				ps.setString(2, meeting.getName());
				ps.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
				if (meeting.getEndDateTime() != null)
					ps.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
				else
					ps.setNull(4, Types.TIMESTAMP);
				if (meeting.getLeaderUserId() > 0)
					ps.setInt(5, meeting.getLeaderUserId());
				else
					ps.setNull(5, Types.INTEGER);
				ps.setString(6, meeting.getDescription());
				ps.setString(7, meeting.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating meeting: {}", meeting.getName(), e);
			return 0;
		}
	}

	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, meetingRowMapper, meetingId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching meeting by ID: {}", meetingId, e);
			return null;
		}
	}

	public List<Meeting> getMeetingsForCourse(int courseId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, courseId);
		} catch (Exception e) {
			logger.error("Error fetching meetings for course ID: {}", courseId, e);
			return List.of();
		}
	}

	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, meeting.getName(), Timestamp.valueOf(meeting.getMeetingDateTime()),
					meeting.getEndDateTime() != null ? Timestamp.valueOf(meeting.getEndDateTime()) : null,
					meeting.getLeaderUserId() > 0 ? meeting.getLeaderUserId() : null, meeting.getDescription(),
					meeting.getLocation(), meeting.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		try {
			jdbcTemplate.update("DELETE FROM meeting_attendance WHERE meeting_id = ?", meetingId);
			return jdbcTemplate.update(sql, meetingId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Meeting meeting = meetingRowMapper.mapRow(rs, rowNum);
				if (rs.getObject("attended") != null) {
					meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
				} else {
					meeting.setUserAttendanceStatus("OFFEN");
				}
				return meeting;
			}, user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for user {}", user.getId(), e);
			return List.of();
		}
	}

	public List<Meeting> getAllUpcomingMeetings() {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
		String sql = "SELECT COUNT(*) FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, meetingId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Repository
public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PermissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Permission> getAllPermissions() {
		String sql = "SELECT * FROM permissions ORDER BY description";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				return p;
			});
		} catch (Exception e) {
			logger.error("Error fetching all permissions", e);
			return List.of();
		}
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try {
			List<Integer> ids = jdbcTemplate.queryForList(sql, Integer.class, userId);
			return new HashSet<>(ids);
		} catch (Exception e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
			return Set.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ProfileChangeRequestDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ProfileChangeRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ProfileChangeRequestDAO {
	private static final Logger logger = LogManager.getLogger(ProfileChangeRequestDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ProfileChangeRequestDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ProfileChangeRequest> requestRowMapper = (rs, rowNum) -> {
		ProfileChangeRequest request = new ProfileChangeRequest();
		request.setId(rs.getInt("id"));
		request.setUserId(rs.getInt("user_id"));
		request.setRequestedChanges(rs.getString("requested_changes"));
		request.setStatus(rs.getString("status"));
		request.setRequestedAt(rs.getTimestamp("requested_at").toLocalDateTime());
		request.setUsername(rs.getString("username"));
		if (rs.getObject("reviewed_by_admin_id") != null) {
			request.setReviewedByAdminId(rs.getInt("reviewed_by_admin_id"));
		}
		if (rs.getTimestamp("reviewed_at") != null) {
			request.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		if (rs.getMetaData().getColumnCount() > 8) { // Simple check if admin_username is present
			request.setReviewedByAdminName(rs.getString("admin_username"));
		}
		return request;
	};

	public boolean createRequest(ProfileChangeRequest request) {
		String sql = "INSERT INTO profile_change_requests (user_id, requested_changes, status) VALUES (?, ?, 'PENDING')";
		try {
			return jdbcTemplate.update(sql, request.getUserId(), request.getRequestedChanges()) > 0;
		} catch (Exception e) {
			logger.error("Error creating profile change request for user {}", request.getUserId(), e);
			return false;
		}
	}

	public ProfileChangeRequest getRequestById(int id) {
		String sql = "SELECT pcr.*, u.username as username, a.username as admin_username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id LEFT JOIN users a ON pcr.reviewed_by_admin_id = a.id WHERE pcr.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, requestRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching request by ID {}", id, e);
			return null;
		}
	}

	public List<ProfileChangeRequest> getPendingRequests() {
		String sql = "SELECT pcr.*, u.username as username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id WHERE pcr.status = 'PENDING' ORDER BY pcr.requested_at ASC";
		try {
			return jdbcTemplate.query(sql, requestRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching pending requests", e);
			return List.of();
		}
	}

	public boolean hasPendingRequest(int userId) {
		String sql = "SELECT COUNT(*) FROM profile_change_requests WHERE user_id = ? AND status = 'PENDING'";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for pending request for user {}", userId, e);
			return false;
		}
	}

	public boolean updateRequestStatus(int requestId, String status, int adminId) {
		String sql = "UPDATE profile_change_requests SET status = ?, reviewed_by_admin_id = ?, reviewed_at = NOW() WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, status, adminId, requestId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status for request {}", requestId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Map<String, Object>> getEventParticipationSummary() {
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating event participation summary.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserActivityStats() {
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating user activity stats.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating inventory usage frequency report.", e);
			return List.of();
		}
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		try {
			Double totalValue = jdbcTemplate.queryForObject(sql, Double.class);
			return totalValue != null ? totalValue : 0.0;
		} catch (Exception e) {
			logger.error("Error calculating total inventory value.", e);
			return 0.0;
		}
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		String sql = "SELECT DATE_FORMAT(event_datetime, '%Y-%m') AS month, COUNT(*) AS count " + "FROM events "
				+ "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), months);
		} catch (Exception e) {
			logger.error("Error generating event count by month report.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), limit);
		} catch (Exception e) {
			logger.error("Error generating user participation stats.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.concurrent.TimeUnit;

@Repository
public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);
	private final JdbcTemplate jdbcTemplate;
	private final LoadingCache<String, List<Role>> roleCache;
	private static final String ALL_ROLES_KEY = "ALL_ROLES";

	@Autowired
	public RoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.roleCache = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.HOURS).maximumSize(1)
				.build(key -> fetchAllRolesFromDb());
	}

	public List<Role> getAllRoles() {
		logger.debug("Fetching all roles from cache.");
		return roleCache.get(ALL_ROLES_KEY);
	}

	private List<Role> fetchAllRolesFromDb() {
		logger.info("Cache miss for roles. Fetching all roles from database.");
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				return role;
			});
		} catch (Exception e) {
			logger.error("Error fetching all roles from DB", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StatisticsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int getUserCount() {
		return getCount("SELECT COUNT(*) FROM users");
	}

	public int getActiveEventCount() {
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	private int getCount(String sql) {
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
			return count != null ? count : 0;
		} catch (Exception e) {
			logger.error("SQL error executing count query: {}", sql, e);
			return 0;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Repository
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<StorageItem> storageItemRowMapper = (rs, rowNum) -> {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	};

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream()
				.collect(Collectors.groupingBy(
						item -> item.getLocation() != null && !item.getLocation().isBlank() ? item.getLocation().trim()
								: "Unbekannt"));
	}

	public List<StorageItem> getAllItems() {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id ORDER BY si.location, si.name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all storage items.", e);
			return List.of();
		}
	}

	public List<StorageItem> getDefectiveItems() {
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching defective items.", e);
			return List.of();
		}
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id WHERE si.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, storageItemRowMapper, itemId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching storage item by ID: {}", itemId, e);
			return null;
		}
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try {
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getWeightKg(),
					item.getPriceEur(), item.getImagePath()) > 0;
		} catch (Exception e) {
			logger.error("Error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try {
			Object holderId = item.getCurrentHolderUserId() > 0 ? item.getCurrentHolderUserId() : null;
			Object eventId = item.getAssignedEventId() > 0 ? item.getAssignedEventId() : null;
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getDefectiveQuantity(),
					item.getDefectReason(), item.getWeightKg(), item.getPriceEur(), item.getImagePath(),
					item.getStatus(), holderId, eventId, item.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, itemId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public List<StorageItem> getLowStockItems(int limit) {
		String sql = "SELECT * FROM storage_items WHERE (quantity - defective_quantity) < (max_quantity * 0.25) AND max_quantity > 0 ORDER BY (quantity - defective_quantity) / max_quantity ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error while fetching low stock items.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;

@Repository
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		try {
			Object eventIdObj = eventId > 0 ? eventId : null;
			int[] types = { Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.VARCHAR, Types.INTEGER };
			return jdbcTemplate.update(sql, new Object[] { itemId, userId, quantityChange, notes, eventIdObj },
					types) > 0;
		} catch (Exception e) {
			logger.error("Error logging storage transaction for item {}", itemId, e);
			return false;
		}
	}

	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT sl.*, u.username FROM storage_log sl JOIN users u ON sl.user_id = u.id WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageLogEntry entry = new StorageLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setQuantityChange(rs.getInt("quantity_change"));
				entry.setNotes(rs.getString("notes"));
				entry.setEventId(rs.getInt("event_id"));
				entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\TodoDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Repository
public class TodoDAO {
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public TodoDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<TodoCategory> getAllCategoriesWithTasks() {
		Map<Integer, TodoCategory> categoryMap = new LinkedHashMap<>();
		String sql = "SELECT c.id as cat_id, c.name as cat_name, c.display_order as cat_order, "
				+ "t.id as task_id, t.category_id as task_cat_id, t.content as task_content, "
				+ "t.is_completed as task_completed, t.display_order as task_order "
				+ "FROM todo_categories c LEFT JOIN todo_tasks t ON c.id = t.category_id "
				+ "ORDER BY c.display_order, t.display_order";

		jdbcTemplate.query(sql, rs -> {
			int categoryId = rs.getInt("cat_id");
			TodoCategory category = categoryMap.computeIfAbsent(categoryId, id -> {
				try {
					TodoCategory newCat = new TodoCategory();
					newCat.setId(id);
					newCat.setName(rs.getString("cat_name"));
					newCat.setDisplayOrder(rs.getInt("cat_order"));
					return newCat;
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			});

			if (rs.getObject("task_id") != null) {
				TodoTask task = new TodoTask();
				task.setId(rs.getInt("task_id"));
				task.setCategoryId(rs.getInt("task_cat_id"));
				task.setContent(rs.getString("task_content"));
				task.setCompleted(rs.getBoolean("task_completed"));
				task.setDisplayOrder(rs.getInt("task_order"));
				category.getTasks().add(task);
			}
		});
		return new ArrayList<>(categoryMap.values());
	}

	public TodoCategory createCategory(String name) {
		String sql = "INSERT INTO todo_categories (name, display_order) "
				+ "SELECT ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_categories";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoCategory newCategory = new TodoCategory();
		newCategory.setId(newId);
		newCategory.setName(name);
		return newCategory;
	}

	public TodoTask createTask(int categoryId, String content) {
		String sql = "INSERT INTO todo_tasks (category_id, content, display_order) "
				+ "SELECT ?, ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_tasks WHERE category_id = ?";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, categoryId);
			ps.setString(2, content);
			ps.setInt(3, categoryId);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoTask newTask = new TodoTask();
		newTask.setId(newId);
		newTask.setCategoryId(categoryId);
		newTask.setContent(content);
		return newTask;
	}

	public boolean updateTaskContent(int taskId, String content) {
		String sql = "UPDATE todo_tasks SET content = ? WHERE id = ?";
		return jdbcTemplate.update(sql, content, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, boolean isCompleted) {
		String sql = "UPDATE todo_tasks SET is_completed = ? WHERE id = ?";
		return jdbcTemplate.update(sql, isCompleted, taskId) > 0;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM todo_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean deleteCategory(int categoryId) {
		jdbcTemplate.update("DELETE FROM todo_tasks WHERE category_id = ?", categoryId);
		String sql = "DELETE FROM todo_categories WHERE id = ?";
		return jdbcTemplate.update(sql, categoryId) > 0;
	}

	public void updateCategoryOrder(List<Integer> categoryIds) {
		String sql = "UPDATE todo_categories SET display_order = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, categoryIds, 100, (ps, categoryId) -> {
			ps.setInt(1, categoryIds.indexOf(categoryId));
			ps.setInt(2, categoryId);
		});
	}

	public void updateTaskOrders(List<Integer> taskIds, int categoryId) {
		String sql = "UPDATE todo_tasks SET display_order = ?, category_id = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, taskIds, 100, (ps, taskId) -> {
			ps.setInt(1, taskIds.indexOf(taskId));
			ps.setInt(2, categoryId);
			ps.setInt(3, taskId);
		});
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.config.Permissions;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.*;

@Repository
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<User> userRowMapper = (resultSet, rowNum) -> {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		user.setPasswordHash(resultSet.getString("password_hash"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "profile_picture_path")) {
			user.setProfilePicturePath(resultSet.getString("profile_picture_path"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	};

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, this.userRowMapper, username);
			String storedHash = user.getPasswordHash();

			if (storedHash != null && passwordEncoder.matches(password, storedHash)) {
				user.setPermissions(getPermissionsForUser(user.getId()));
				return user;
			}
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, username);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(user.getId()));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by username: {}", username, e);
			return null;
		}
	}

	public Set<String> getPermissionsForUser(int userId) {
		String sql = "SELECT p.permission_key FROM permissions p JOIN user_permissions up ON p.id = up.permission_id WHERE up.user_id = ? "
				+ "UNION " + "SELECT ? FROM users WHERE id = ? AND role_id = 1"; // 1 = ADMIN role ID
		try {
			List<String> permissionsList = jdbcTemplate.queryForList(sql, String.class, userId,
					Permissions.ACCESS_ADMIN_PANEL, userId);
			return new HashSet<>(permissionsList);
		} catch (Exception e) {
			logger.error("Could not fetch permissions for user ID: {}", userId, e);
			return new HashSet<>();
		}
	}

	public boolean updateUserPermissions(int userId, String[] permissionIds) {
		try {
			jdbcTemplate.update("DELETE FROM user_permissions WHERE user_id = ?", userId);
			if (permissionIds != null && permissionIds.length > 0) {
				String insertSql = "INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)";
				jdbcTemplate.batchUpdate(insertSql, List.of(permissionIds), 100, (ps, permId) -> {
					ps.setInt(1, userId);
					ps.setInt(2, Integer.parseInt(permId));
				});
			}
			return true;
		} catch (Exception e) {
			logger.error("Error updating user permissions for user {}", userId, e);
			return false;
		}
	}

	public int createUser(User user, String password) {
		String hashedPassword = passwordEncoder.encode(password);
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, user.getUsername());
				ps.setString(2, hashedPassword);
				ps.setInt(3, user.getRoleId());
				ps.setInt(4, user.getClassYear());
				ps.setString(5, user.getClassName());
				ps.setString(6, user.getEmail());
				ps.setString(7, "light");
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating user {}", user.getUsername(), e);
			return 0;
		}
	}

	public boolean updateUser(User user) {
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ?, profile_picture_path = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, user.getUsername(), user.getRoleId(), user.getClassYear(),
					user.getClassName(), user.getEmail(), user.getProfilePicturePath(), user.getId()) > 0;
		} catch (Exception e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, theme, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating theme for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, chatColor, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating chat color for user ID {}", userId, e);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, hashedPassword, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}

	public List<User> getAllUsers() {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		try {
			return jdbcTemplate.query(sql, userRowMapper);
		} catch (Exception e) {
			logger.error("SQL error fetching all users", e);
			return List.of();
		}
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, userId);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(userId));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by ID with permissions: {}", userId, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.UserQualification;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.List;

@Repository
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserQualificationsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private UserQualification mapResultSetToUserQualification(ResultSet rs, int rowNum) throws SQLException {
		UserQualification uq = new UserQualification();
		if (DaoUtils.hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	public List<UserQualification> getQualificationsForUser(int userId) {
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id WHERE uq.user_id = ?";
		try {
			return jdbcTemplate.query(sql, this::mapResultSetToUserQualification, userId);
		} catch (Exception e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
			return List.of();
		}
	}

	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try {
				jdbcTemplate.update(deleteSql, userId, courseId);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try {
				jdbcTemplate.update(upsertSql, userId, courseId, status, completionDate, remarks);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\WikiDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class WikiDAO {
	private static final Logger logger = LogManager.getLogger(WikiDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public WikiDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<WikiEntry> wikiEntryRowMapper = (rs, rowNum) -> {
		WikiEntry entry = new WikiEntry();
		entry.setId(rs.getInt("id"));
		entry.setFilePath(rs.getString("file_path"));
		entry.setContent(rs.getString("content"));
		return entry;
	};

	public Optional<WikiEntry> getWikiEntryById(int id) {
		String sql = "SELECT * FROM wiki_documentation WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by ID {}", id, e);
			return Optional.empty();
		}
	}

	public Optional<WikiEntry> findByFilePath(String filePath) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, filePath));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by file_path {}", filePath, e);
			return Optional.empty();
		}
	}

	public List<WikiEntry> getAllWikiEntries() {
		String sql = "SELECT * FROM wiki_documentation ORDER BY file_path";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all wiki entries", e);
			return List.of();
		}
	}

	public boolean updateWikiContent(int id, String content) {
		String sql = "UPDATE wiki_documentation SET content = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, content, id) > 0;
		} catch (Exception e) {
			logger.error("Error updating wiki content for ID {}", id, e);
			return false;
		}
	}

	public Optional<WikiEntry> createWikiEntry(WikiEntry entry) {
		String sql = "INSERT INTO wiki_documentation (file_path, content) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, entry.getFilePath());
				ps.setString(2, entry.getContent());
				return ps;
			}, keyHolder);
			entry.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
			return Optional.of(entry);
		} catch (Exception e) {
			logger.error("Error creating wiki entry for path {}", entry.getFilePath(), e);
			return Optional.empty();
		}
	}

	public boolean deleteWikiEntry(int id) {
		String sql = "DELETE FROM wiki_documentation WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting wiki entry with ID {}", id, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ApiResponse.java
========================================================================

package de.technikteam.model;

/**
 * A standard wrapper for all API responses. This object is returned by all
 * Actions and processed by the FrontControllerServlet. It contains a success
 * flag, a message, and a generic data payload.
 */
public class ApiResponse {

	private final boolean success;
	private final String message;
	private final Object data;

	public ApiResponse(boolean success, String message, Object data) {
		this.success = success;
		this.message = message;
		this.data = data;
	}

	public boolean isSuccess() {
		return success;
	}

	public String getMessage() {
		return message;
	}

	public Object getData() {
		return data;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; 
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DashboardDataDTO.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.Map;

/**
 * A Data Transfer Object to encapsulate all data required for the dynamic admin
 * dashboard.
 */
public class DashboardDataDTO {
	private List<Event> upcomingEvents;
	private List<StorageItem> lowStockItems;
	private List<AdminLog> recentLogs;
	private List<Map<String, Object>> eventTrendData;

	public List<Event> getUpcomingEvents() {
		return upcomingEvents;
	}

	public void setUpcomingEvents(List<Event> upcomingEvents) {
		this.upcomingEvents = upcomingEvents;
	}

	public List<StorageItem> getLowStockItems() {
		return lowStockItems;
	}

	public void setLowStockItems(List<StorageItem> lowStockItems) {
		this.lowStockItems = lowStockItems;
	}

	public List<AdminLog> getRecentLogs() {
		return recentLogs;
	}

	public void setRecentLogs(List<AdminLog> recentLogs) {
		this.recentLogs = recentLogs;
	}

	public List<Map<String, Object>> getEventTrendData() {
		return eventTrendData;
	}

	public void setEventTrendData(List<Map<String, Object>> eventTrendData) {
		this.eventTrendData = eventTrendData;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;

	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean edited;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor; 

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details;
	private String status;
	private String eventName;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers;
	private List<StorageItem> requiredItems;
	private List<InventoryKit> requiredKits;

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackSubmission.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single feedback submission from a user. Corresponds to the
 * `feedback_submissions` table.
 */
public class FeedbackSubmission {
	private int id;
	private int userId;
	private String username; 
	private String subject;
	private String displayTitle; 
	private String content;
	private LocalDateTime submittedAt;
	private String status;
	private int displayOrder;

	public String getFormattedSubmittedAt() {
		return DateFormatter.formatDateTime(this.submittedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public String getDisplayTitle() {
		return displayTitle;
	}

	public void setDisplayTitle(String displayTitle) {
		this.displayTitle = displayTitle;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;
	private String content;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ProfileChangeRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single request from a user to change their profile data.
 * Corresponds to the `profile_change_requests` table.
 */
public class ProfileChangeRequest {
	private int id;
	private int userId;
	private String username; 
	private String requestedChanges; 
	private String status;
	private LocalDateTime requestedAt;
	private Integer reviewedByAdminId;
	private String reviewedByAdminName; 
	private LocalDateTime reviewedAt;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRequestedChanges() {
		return requestedChanges;
	}

	public void setRequestedChanges(String requestedChanges) {
		this.requestedChanges = requestedChanges;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getRequestedAt() {
		return requestedAt;
	}

	public void setRequestedAt(LocalDateTime requestedAt) {
		this.requestedAt = requestedAt;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public String getReviewedByAdminName() {
		return reviewedByAdminName;
	}

	public void setReviewedByAdminName(String reviewedByAdminName) {
		this.reviewedByAdminName = reviewedByAdminName;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "Vergriffen";
		}
		if (maxQuantity == 0) {
			return "Auf Lager"; 
		}
		if (available >= maxQuantity) {
			return "Vollständig";
		}
		if ((double) available / maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "status-danger";
		}
		if (maxQuantity > 0 && (double) available / maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoCategory.java
========================================================================

package de.technikteam.model;

import java.util.ArrayList;
import java.util.List;

public class TodoCategory {
	private int id;
	private String name;
	private int displayOrder;
	private List<TodoTask> tasks = new ArrayList<>();

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public List<TodoTask> getTasks() {
		return tasks;
	}

	public void setTasks(List<TodoTask> tasks) {
		this.tasks = tasks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoTask.java
========================================================================

package de.technikteam.model;

public class TodoTask {
	private int id;
	private int categoryId;
	private String content;
	private boolean isCompleted;
	private int displayOrder;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCompleted(boolean completed) {
		isCompleted = completed;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import de.technikteam.config.Permissions;

import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;
	private String profilePicturePath;

	@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
	private String passwordHash;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	public boolean hasAdminAccess() {
		if (permissions == null) {
			return false;
		}
		return permissions.contains(Permissions.ACCESS_ADMIN_PANEL) || permissions.stream().anyMatch(
				p -> !p.equals(Permissions.FILE_READ) && !p.equals(Permissions.FILE_UPDATE) && (p.contains("_READ")
						|| p.contains("_MANAGE") || p.contains("_CREATE") || p.contains("_DELETE")));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getProfilePicturePath() {
		return profilePicturePath;
	}

	public void setProfilePicturePath(String profilePicturePath) {
		this.profilePicturePath = profilePicturePath;
	}

	public String getPasswordHash() {
		return passwordHash;
	}

	public void setPasswordHash(String passwordHash) {
		this.passwordHash = passwordHash;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\WikiEntry.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single documentation entry from the `wiki_documentation` table.
 */
public class WikiEntry {
	private int id;
	private String filePath;
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilePath() {
		return filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\JwtAuthFilter.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.AuthService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

	private final AuthService authService;

	@Autowired
	public JwtAuthFilter(AuthService authService) {
		this.authService = authService;
	}

	@Override
	protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull FilterChain filterChain) throws ServletException, IOException {

		if (request.getCookies() == null) {
			filterChain.doFilter(request, response);
			return;
		}

		final String token = Arrays.stream(request.getCookies())
				.filter(cookie -> AuthService.AUTH_COOKIE_NAME.equals(cookie.getName())).map(Cookie::getValue)
				.findFirst().orElse(null);

		if (token == null) {
			filterChain.doFilter(request, response);
			return;
		}

		UserDetails userDetails = authService.validateTokenAndGetUser(token);

		if (userDetails != null && SecurityContextHolder.getContext().getAuthentication() == null) {
			UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null,
					userDetails.getAuthorities());
			authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
			SecurityContextHolder.getContext().setAuthentication(authToken);
		}

		filterChain.doFilter(request, response);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\RateLimitingInterceptor.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.RateLimitingService;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.concurrent.TimeUnit;

@Component
public class RateLimitingInterceptor implements HandlerInterceptor {

	private final RateLimitingService rateLimitingService;

	@Autowired
	public RateLimitingInterceptor(RateLimitingService rateLimitingService) {
		this.rateLimitingService = rateLimitingService;
	}

	@Override
	public boolean preHandle(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull Object handler) throws Exception {
		String ipAddress = getClientIp(request);
		Bucket bucket = rateLimitingService.resolveBucket(ipAddress);
		ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

		if (probe.isConsumed()) {
			response.addHeader("X-Rate-Limit-Remaining", String.valueOf(probe.getRemainingTokens()));
			return true;
		} else {
			long waitForRefill = TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill());
			response.addHeader("X-Rate-Limit-Retry-After-Seconds", String.valueOf(waitForRefill));
			response.sendError(HttpStatus.TOO_MANY_REQUESTS.value(),
					"Sie haben Ihr API-Anfragekontingent ausgeschöpft. Bitte versuchen Sie es später erneut.");
			return false;
		}
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityConfig.java
========================================================================

package de.technikteam.security;

import de.technikteam.dao.UserDAO;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig {

	private final JwtAuthFilter jwtAuthFilter;
	private final UserDAO userDAO;

	public SecurityConfig(JwtAuthFilter jwtAuthFilter, UserDAO userDAO) {
		this.jwtAuthFilter = jwtAuthFilter;
		this.userDAO = userDAO;
	}

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler();
		requestHandler.setCsrfRequestAttributeName(null);

		http.csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
				.csrfTokenRequestHandler(requestHandler).ignoringRequestMatchers("/api/v1/auth/**") // ADD THIS LINE
		).authorizeHttpRequests(auth -> auth
				.requestMatchers("/api/v1/auth/**", "/api/v1/public/calendar.ics", "/api/v1/public/files/avatars/**",
						"/swagger-ui.html", "/swagger-ui/**", "/v3/api-docs/**")
				.permitAll().anyRequest().authenticated())
				.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
				.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin())
						.httpStrictTransportSecurity(hsts -> hsts.includeSubDomains(true).maxAgeInSeconds(31536000))
						.contentSecurityPolicy(csp -> csp.policyDirectives(
								"default-src 'self'; script-src 'self'; style-src 'self' https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com; object-src 'none'; base-uri 'self';")))
				.httpBasic(AbstractHttpConfigurer::disable).formLogin(AbstractHttpConfigurer::disable);

		return http.build();
	}

	@Bean
	public UserDetailsService userDetailsService() {
		return username -> {
			de.technikteam.model.User user = userDAO.getUserByUsername(username);
			if (user == null) {
				throw new UsernameNotFoundException("User not found: " + username);
			}
			return new SecurityUser(user);
		};
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityUser.java
========================================================================

package de.technikteam.security;

import de.technikteam.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.stream.Collectors;

public class SecurityUser implements UserDetails, Serializable {

	private static final long serialVersionUID = 1L;
	private final User user;

	public SecurityUser(User user) {
		this.user = user;
	}

	public User getUser() {
		return user;
	}

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		if (user.getPermissions() == null) {
			return Collections.emptyList();
		}
		return user.getPermissions().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
	}

	@Override
	public String getPassword() {
		return user.getPasswordHash();
	}

	@Override
	public String getUsername() {
		return user.getUsername();
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);

	private final AchievementDAO achievementDAO;
	private final EventDAO eventDAO;

	@Autowired
	public AchievementService(AchievementDAO achievementDAO, EventDAO eventDAO) {
		this.achievementDAO = achievementDAO;
		this.eventDAO = eventDAO;
	}

	@Transactional
	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// Placeholder for future implementation
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminDashboardService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.ReportDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.DashboardDataDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminDashboardService {
	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final AdminLogDAO adminLogDAO;
	private final ReportDAO reportDAO;

	private static final int WIDGET_LIMIT = 5;
	private static final int TREND_MONTHS = 12;

	@Autowired
	public AdminDashboardService(EventDAO eventDAO, StorageDAO storageDAO, AdminLogDAO adminLogDAO,
			ReportDAO reportDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.adminLogDAO = adminLogDAO;
		this.reportDAO = reportDAO;
	}

	public DashboardDataDTO getDashboardData() {
		DashboardDataDTO dto = new DashboardDataDTO();
		dto.setUpcomingEvents(eventDAO.getUpcomingEvents(WIDGET_LIMIT));
		dto.setLowStockItems(storageDAO.getLowStockItems(WIDGET_LIMIT));
		dto.setRecentLogs(adminLogDAO.getRecentLogs(WIDGET_LIMIT));
		dto.setEventTrendData(reportDAO.getEventCountByMonth(TREND_MONTHS));
		return dto;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private final AdminLogDAO logDAO;

	@Autowired
	public AdminLogService(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	private String sanitize(String input) {
		if (input == null) {
			return "";
		}
		// Replace newlines and carriage returns to prevent log injection
		return input.replace('\n', '_').replace('\r', '_');
	}

	public void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);
			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);
			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error(
					"KRITISCH: Fehler beim Schreiben in das Admin-Audit-Log! Daten: [Benutzer: {}, Aktion: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AuthService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;

@Service
public class AuthService {
	private static final Logger logger = LogManager.getLogger(AuthService.class);
	private static final String JWT_ISSUER = "TechnikTeamApp";
	public static final String AUTH_COOKIE_NAME = "TT_AUTH_TOKEN";
	private static final int COOKIE_MAX_AGE_SECONDS = 8 * 60 * 60; // 8 hours

	private final SecretKey secretKey;
	private final UserDAO userDAO;

	@Autowired
	public AuthService(UserDAO userDAO, ConfigurationService configService) {
		this.userDAO = userDAO;
		// TODO: SECURITY-AUDIT-FIX (CWE-547)
		// Loading secrets from properties files committed to version control is
		// insecure.
		// REMEDIATION: Refactor to read the JWT secret from an environment variable
		// (e.g., System.getenv("JWT_SECRET")) or a dedicated secrets management
		// service.
		String secret = configService.getProperty("jwt.secret");
		if (secret == null || secret.isBlank() || secret.length() < 32) {
			logger.fatal(
					"JWT-Secret ist nicht konfiguriert oder zu kurz (muss mindestens 32 Zeichen lang sein). Die Anwendung kann nicht sicher gestartet werden.");
			throw new RuntimeException("JWT-Secret ist nicht konfiguriert oder unsicher.");
		}
		this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
	}

	public String generateToken(User user) {
		Instant now = Instant.now();
		Instant expiry = now.plus(COOKIE_MAX_AGE_SECONDS, ChronoUnit.SECONDS);

		return Jwts.builder().issuer(JWT_ISSUER).subject(String.valueOf(user.getId())).issuedAt(Date.from(now))
				.expiration(Date.from(expiry)).signWith(secretKey).compact();
	}

	public void addJwtCookie(User user, HttpServletResponse response) {
		String token = generateToken(user);
		String header = String.format("%s=%s; Path=/; Max-Age=%d; HttpOnly; Secure; SameSite=Strict", AUTH_COOKIE_NAME,
				token, COOKIE_MAX_AGE_SECONDS);
		response.addHeader(HttpHeaders.SET_COOKIE, header);
	}

	public void clearJwtCookie(HttpServletResponse response) {
		Cookie cookie = new Cookie(AUTH_COOKIE_NAME, null);
		cookie.setHttpOnly(true);
		cookie.setSecure(true);
		cookie.setPath("/");
		cookie.setMaxAge(0); // Expire immediately
		response.addCookie(cookie);
	}

	public UserDetails validateTokenAndGetUser(String token) {
		try {
			Claims claims = Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload();

			int userId = Integer.parseInt(claims.getSubject());
			User user = userDAO.getUserById(userId);

			if (user == null) {
				logger.warn("JWT-Validierung erfolgreich, aber Benutzer mit ID {} existiert nicht mehr.", userId);
				return null;
			}
			return new SecurityUser(user);
		} catch (Exception e) {
			logger.warn("JWT-Verifizierung fehlgeschlagen: {}", e.getMessage());
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ConfigurationService.java
========================================================================

package de.technikteam.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConfigurationService {
	private static final Logger logger = LogManager.getLogger(ConfigurationService.class);

	@Value("${server.servlet.context-path:#{''}}")
	private String contextPath;

	@Value("${spring.datasource.url}")
	private String dbUrl;

	@Value("${spring.datasource.username}")
	private String dbUser;

	@Value("${spring.datasource.password}")
	private String dbPassword;

	@Value("${jwt.secret}")
	private String jwtSecret;

	@Value("${upload.directory}")
	private String uploadDirectory;

	public String getProperty(String key) {
		switch (key) {
		case "context.path":
			return contextPath;
		case "db.url":
			return dbUrl;
		case "db.user":
			return dbUser;
		case "db.password":
			return dbPassword;
		case "jwt.secret":
			return jwtSecret;
		case "upload.directory":
			return uploadDirectory;
		default:
			logger.warn("Attempted to access unknown property key: {}", key);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Event;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
public class EventService {
	private static final Logger logger = LogManager.getLogger(EventService.class);

	private final EventDAO eventDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public EventService(EventDAO eventDAO, AttachmentDAO attachmentDAO, EventCustomFieldDAO customFieldDAO,
			ConfigurationService configService, AdminLogService adminLogService,
			NotificationService notificationService, @Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.eventDAO = eventDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.configService = configService;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public int createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, String[] requiredCourseIds,
			String[] requiredPersons, String[] itemIds, String[] quantities, List<EventCustomField> customFields,
			MultipartFile file, String requiredRole) throws SQLException, IOException {

		// Sanitize HTML content before saving
		if (event.getDescription() != null) {
			String sanitizedDescription = richTextPolicy.sanitize(event.getDescription());
			event.setDescription(sanitizedDescription);
		}

		int eventId;
		if (isUpdate) {
			eventDAO.updateEvent(event);
			eventId = event.getId();
			adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
		} else {
			eventId = eventDAO.createEvent(event);
			event.setId(eventId);
			adminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
		}

		eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);
		eventDAO.saveReservations(eventId, itemIds, quantities);
		if (customFields != null) {
			customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
		}

		if (file != null && !file.isEmpty()) {
			handleAttachmentUpload(file, eventId, requiredRole, adminUser);
		}

		logger.info("Transaction for event ID {} committed successfully.", eventId);
		return eventId;
	}

	public void signOffUserFromRunningEvent(int userId, String username, int eventId, String reason) {
		eventDAO.signOffFromEvent(userId, eventId);
		Event event = eventDAO.getEventById(eventId);
		if (event != null && event.getLeaderUserId() > 0) {
			String notificationMessage = String.format("%s hat sich vom laufenden Event '%s' abgemeldet. Grund: %s",
					username, event.getName(), reason);

			Map<String, Object> payload = Map.of("type", "alert", "payload",
					Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + eventId));

			notificationService.sendNotificationToUser(event.getLeaderUserId(), payload);
			logger.info("Sent sign-off notification to event leader (ID: {}) for event '{}'", event.getLeaderUserId(),
					event.getName());
		}
	}

	private void handleAttachmentUpload(MultipartFile file, int eventId, String requiredRole, User adminUser)
			throws IOException {
		String uploadDir = configService.getProperty("upload.directory");
		String originalFileName = Paths.get(file.getOriginalFilename()).getFileName().toString();
		String uniqueFileName = UUID.randomUUID() + "-" + originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");

		Path targetPath = Paths.get(uploadDir, "events", uniqueFileName);
		Files.createDirectories(targetPath.getParent());
		Files.copy(file.getInputStream(), targetPath);

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(originalFileName);
		attachment.setFilepath("events/" + uniqueFileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			adminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + originalFileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Fehler beim Speichern des Anhangs in der Datenbank.");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\FileService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
public class FileService {

	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;
	private final Path fileStorageLocation;

	private static final long MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10 MB

	@Autowired
	public FileService(FileDAO fileDAO, ConfigurationService configService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser) throws IOException {

		// Security Validations
		if (multipartFile.getSize() > MAX_FILE_SIZE_BYTES) {
			throw new IOException("Dateigröße überschreitet das Limit von 10MB.");
		}
		if (!FileSignatureValidator.isFileTypeAllowed(multipartFile)) {
			throw new IOException("Ungültiger oder gefälschter Dateityp erkannt.");
		}

		String originalFileName = FilenameUtils.getName(multipartFile.getOriginalFilename());
		String sanitizedFileName = originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");
		String uniqueFileName = UUID.randomUUID() + "-" + sanitizedFileName;

		Path targetPath = this.fileStorageLocation.resolve(Paths.get("docs", uniqueFileName));
		Files.createDirectories(targetPath.getParent());
		Files.copy(multipartFile.getInputStream(), targetPath);

		de.technikteam.model.File file = new de.technikteam.model.File();
		file.setFilename(originalFileName);
		file.setFilepath("docs/" + uniqueFileName);
		file.setCategoryId(categoryId != null ? categoryId : 0);
		file.setRequiredRole(requiredRole);

		int newFileId = fileDAO.createFile(file);
		if (newFileId > 0) {
			adminLogService.log(adminUser.getUsername(), "UPLOAD_FILE",
					"Datei '" + originalFileName + "' hochgeladen.");
			return fileDAO.getFileById(newFileId);
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Fehler beim Speichern der Datei-Metadaten in der Datenbank.");
		}
	}

	public boolean deleteFile(int fileId, User adminUser) throws IOException {
		de.technikteam.model.File file = fileDAO.getFileById(fileId);
		if (file == null) {
			return false;
		}

		boolean success = fileDAO.deleteFile(fileId);
		if (success) {
			Path filePath = this.fileStorageLocation.resolve(file.getFilepath()).normalize();
			Files.deleteIfExists(filePath);
			adminLogService.log(adminUser.getUsername(), "DELETE_FILE",
					"Datei '" + file.getFilename() + "' (ID: " + fileId + ") gelöscht.");
		}
		return success;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\LoginAttemptService.java
========================================================================

package de.technikteam.service;

// TODO: SECURITY-AUDIT-FIX (CWE-307)
// The current lockout mechanism is based solely on username, which makes it vulnerable
// to targeted Denial of Service attacks where an attacker can lock out any known user.
// REMEDIATION: This service should be refactored to be primarily IP-based.
// 1. A database migration is required to change the login_attempts table to track failures by IP address.
// 2. The logic in isLockedOut() and recordFailedLogin() must be updated to use the client's IP address
//    as the key for tracking and enforcing lockouts.

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.LocalDateTime;

@Service
public class LoginAttemptService {
	private static final Logger logger = LogManager.getLogger(LoginAttemptService.class);
	private static final int MAX_ATTEMPTS = 5;
	private static final int LOCKOUT_MINUTES = 30;

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public LoginAttemptService(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean isLockedOut(String username, String ipAddress) {
		String sql = "SELECT last_attempt, attempts FROM login_attempts WHERE username = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				LocalDateTime lastAttempt = rs.getTimestamp("last_attempt").toLocalDateTime();
				int attempts = rs.getInt("attempts");
				if (attempts >= MAX_ATTEMPTS
						&& lastAttempt.isAfter(LocalDateTime.now().minusMinutes(LOCKOUT_MINUTES))) {
					return true;
				}
				// If lockout period expired, clear attempts and allow login
				clearLoginAttempts(username);
				return false;
			}, username);
		} catch (Exception e) {
			return false; // No record means not locked out
		}
	}

	public void recordFailedLogin(String username, String ipAddress) {
		String sql = "INSERT INTO login_attempts (username, attempts, last_attempt) VALUES (?, 1, ?) "
				+ "ON DUPLICATE KEY UPDATE attempts = attempts + 1, last_attempt = ?";
		Timestamp now = Timestamp.valueOf(LocalDateTime.now());
		jdbcTemplate.update(sql, username, now, now);

		String checkSql = "SELECT attempts FROM login_attempts WHERE username = ?";
		try {
			Integer currentAttempts = jdbcTemplate.queryForObject(checkSql, Integer.class, username);
			if (currentAttempts != null && currentAttempts >= MAX_ATTEMPTS) {
				logger.warn("Locking out user '{}' (from IP {}) due to {} failed login attempts.", username, ipAddress,
						currentAttempts);
			}
		} catch (Exception e) {
			logger.error("Could not check login attempts for user '{}' after failed login.", username, e);
		}
	}

	public void clearLoginAttempts(String username) {
		String sql = "DELETE FROM login_attempts WHERE username = ?";
		jdbcTemplate.update(sql, username);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);

	private final Map<Integer, List<SseEmitter>> emittersByUser = new ConcurrentHashMap<>();

	public NotificationService() {
		new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	public SseEmitter register(User user) {
		if (user == null) {
			logger.warn("Versuch, Benachrichtigungen für eine nicht authentifizierte Sitzung zu registrieren.");
			return null;
		}

		// Timeout set to a very long value. The connection will be kept alive by
		// heartbeats.
		SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		int userId = user.getId();

		emitter.onCompletion(() -> {
			logger.info("SSE Emitter für Benutzer {} beendet.", userId);
			removeEmitter(userId, emitter);
		});
		emitter.onTimeout(() -> {
			logger.warn("SSE Emitter für Benutzer {} hat Zeitüberschreitung.", userId);
			emitter.complete();
		});
		emitter.onError(e -> {
			logger.error("SSE Emitter Fehler für Benutzer {}: {}", userId, e.getMessage());
			emitter.complete();
		});

		emittersByUser.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);

		logger.info(
				"Neuer Client für SSE-Benachrichtigungen für Benutzer-ID {} registriert. Gesamtzahl der Clients für Benutzer: {}",
				userId, emittersByUser.get(userId).size());

		// Send a confirmation event
		try {
			emitter.send(SseEmitter.event().name("connected").data("Verbindung hergestellt"));
		} catch (IOException e) {
			logger.error("Fehler beim Senden der Verbindungsbestätigung an Benutzer {}", userId, e);
			emitter.complete();
		}

		return emitter;
	}

	public void broadcastUIUpdate(String type, Object payload) {
		logger.info("Sende UI-Update vom Typ '{}' an alle Clients.", type);
		Map<String, Object> message = Map.of("updateType", type, "data", payload);
		SseEmitter.SseEventBuilder event = SseEmitter.event().name("ui_update").data(message);

		emittersByUser.values().forEach(emitterList -> emitterList.forEach(emitter -> {
			try {
				emitter.send(event);
			} catch (IOException e) {
				logger.warn("Fehler beim Senden an einen Client (wahrscheinlich getrennt), wird entfernt. Fehler: {}",
						e.getMessage());
				emitter.complete();
			}
		}));
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null && !userEmitters.isEmpty()) {
			SseEmitter.SseEventBuilder event = SseEmitter.event().name("notification").data(payload);
			logger.info("Sende gezielte Benachrichtigung an Benutzer-ID {}: {}", userId, payload);

			userEmitters.forEach(emitter -> {
				try {
					emitter.send(event);
				} catch (IOException e) {
					logger.warn(
							"Fehler beim Senden der gezielten Benachrichtigung an Benutzer {} (Client wahrscheinlich getrennt), wird entfernt. Fehler: {}",
							userId, e.getMessage());
					emitter.complete();
				}
			});
		} else {
			logger.debug("Keine aktiven SSE-Clients für Benutzer-ID {} gefunden, um Benachrichtigung zu senden.",
					userId);
		}
	}

	private void removeEmitter(int userId, SseEmitter emitter) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null) {
			userEmitters.remove(emitter);
			if (userEmitters.isEmpty()) {
				emittersByUser.remove(userId);
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ProfileRequestService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

@Service
public class ProfileRequestService {

	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ConfigurationService configService;
	private final Gson gson;

	@Autowired
	public ProfileRequestService(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService,
			NotificationService notificationService, ConfigurationService configService, Gson gson) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.configService = configService;
		this.gson = gson;
	}

	@Transactional
	public void createChangeRequest(User currentUser, ProfileChangeRequestDTO requestDTO, MultipartFile profilePicture)
			throws IOException {
		Map<String, String> changes = new HashMap<>();
		if (requestDTO.email() != null && !Objects.equals(currentUser.getEmail(), requestDTO.email())) {
			changes.put("email", requestDTO.email());
		}
		if (requestDTO.classYear() != null && currentUser.getClassYear() != requestDTO.classYear()) {
			changes.put("classYear", String.valueOf(requestDTO.classYear()));
		}
		if (requestDTO.className() != null && !Objects.equals(currentUser.getClassName(), requestDTO.className())) {
			changes.put("className", requestDTO.className());
		}

		if (profilePicture != null && !profilePicture.isEmpty()) {
			if (!FileSignatureValidator.isFileTypeAllowed(profilePicture)) {
				throw new IOException("Ungültiger Dateityp für Profilbild. Nur JPG und PNG sind erlaubt.");
			}
			String tempPath = saveTemporaryProfilePicture(profilePicture);
			changes.put("profilePicturePath", tempPath);
		}

		if (changes.isEmpty()) {
			return; // No changes to request
		}

		ProfileChangeRequest pcr = new ProfileChangeRequest();
		pcr.setUserId(currentUser.getId());
		pcr.setRequestedChanges(gson.toJson(changes));

		if (!requestDAO.createRequest(pcr)) {
			throw new IOException("Ihr Antrag konnte nicht in der Datenbank gespeichert werden.");
		}
	}

	@Transactional
	public boolean approveRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		User userToUpdate = userDAO.getUserById(pcr.getUserId());
		if (userToUpdate == null) {
			requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
			throw new IllegalStateException(
					"Der zugehörige Benutzer existiert nicht mehr. Der Antrag wurde abgelehnt.");
		}

		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = gson.fromJson(pcr.getRequestedChanges(), type);

		for (Map.Entry<String, String> entry : changes.entrySet()) {
			String field = entry.getKey();
			String value = entry.getValue();
			switch (field) {
			case "email":
				userToUpdate.setEmail(value);
				break;
			case "classYear":
				userToUpdate.setClassYear(Integer.parseInt(value));
				break;
			case "className":
				userToUpdate.setClassName(value);
				break;
			case "profilePicturePath":
				String permanentPath = makeProfilePicturePermanent(value, userToUpdate.getProfilePicturePath());
				userToUpdate.setProfilePicturePath(permanentPath);
				break;
			}
		}

		if (userDAO.updateUser(userToUpdate)
				&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED_API", "Profile change for '"
					+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") approved via API.");

			String notificationMessage = "Your profile change has been approved.";
			Map<String, Object> payload = Map.of("type", "alert", "payload", Map.of("message", notificationMessage));
			notificationService.sendNotificationToUser(userToUpdate.getId(), payload);

			return true;
		}
		return false;
	}

	@Transactional
	public boolean denyRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		// If the request included a temporary file, delete it
		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = gson.fromJson(pcr.getRequestedChanges(), type);
		if (changes.containsKey("profilePicturePath")) {
			deleteTemporaryProfilePicture(changes.get("profilePicturePath"));
		}

		if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED_API", "Profile change for user ID "
					+ pcr.getUserId() + " (Request ID: " + requestId + ") denied via API.");
			return true;
		}
		return false;
	}

	private String saveTemporaryProfilePicture(MultipartFile file) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempDir = uploadDir.resolve("temp_avatars");
		Files.createDirectories(tempDir);

		String extension = FilenameUtils.getExtension(file.getOriginalFilename());
		String newFilename = UUID.randomUUID().toString() + "." + extension;
		Path targetPath = tempDir.resolve(newFilename);
		Files.copy(file.getInputStream(), targetPath);
		return newFilename;
	}

	private String makeProfilePicturePermanent(String tempFilename, String oldPermanentFilename) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempDir = uploadDir.resolve("temp_avatars");
		Path finalDir = uploadDir.resolve("avatars");
		Files.createDirectories(finalDir);

		Path sourcePath = tempDir.resolve(tempFilename);
		Path destinationPath = finalDir.resolve(tempFilename);

		if (Files.exists(sourcePath)) {
			Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

			// Delete the old profile picture if it exists
			if (oldPermanentFilename != null && !oldPermanentFilename.isBlank()) {
				Path oldPath = finalDir.resolve(oldPermanentFilename);
				Files.deleteIfExists(oldPath);
			}
			return tempFilename;
		}
		throw new IOException("Temporäres Profilbild nicht gefunden: " + tempFilename);
	}

	private void deleteTemporaryProfilePicture(String tempFilename) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempFile = uploadDir.resolve("temp_avatars").resolve(tempFilename);
		Files.deleteIfExists(tempFile);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\RateLimitingService.java
========================================================================

package de.technikteam.service;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RateLimitingService {

	private final Map<String, Bucket> cache = new ConcurrentHashMap<>();

	public Bucket resolveBucket(String apiKey) {
		return cache.computeIfAbsent(apiKey, this::newBucket);
	}

	private Bucket newBucket(String apiKey) {
		// Example: 10 requests per minute
		Bandwidth limit = Bandwidth.simple(10, Duration.ofMinutes(1));
		return Bucket.builder().addLimit(limit).build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\StorageService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StorageService {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public StorageService(StorageDAO storageDAO, StorageLogDAO storageLogDAO, EventDAO eventDAO,
			AdminLogService adminLogService) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public boolean processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null)
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");

		if ("checkout".equals(type)) {
			if (item.getAvailableQuantity() < quantity)
				throw new IllegalStateException("Nicht genügend Artikel zum Entnehmen verfügbar.");
			item.setQuantity(item.getQuantity() - quantity);
			item.setStatus("CHECKED_OUT");
			item.setCurrentHolderUserId(user.getId());
			item.setAssignedEventId(eventId != null ? eventId : 0);
		} else if ("checkin".equals(type)) {
			if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
				throw new IllegalStateException("Nicht genügend Platz, um diese Menge einzuräumen.");
			}
			item.setQuantity(item.getQuantity() + quantity);
			if (item.getQuantity() >= item.getMaxQuantity()) {
				item.setStatus("IN_STORAGE");
				item.setCurrentHolderUserId(0);
				item.setAssignedEventId(0);
			}
		} else {
			throw new IllegalArgumentException("Ungültiger Transaktionstyp: " + type);
		}

		storageDAO.updateItem(item);

		String finalNotes = notes;
		if ("checkout".equals(type) && eventId != null) {
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				String autoNote = "Für Event: " + event.getName();
				finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes : autoNote;
			}
		}
		int quantityChange = "checkin".equals(type) ? quantity : -quantity;
		storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes, eventId != null ? eventId : 0);

		String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
		String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, item.getName(), itemId, action,
				finalNotes);
		adminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

		return true;
	}

	@Transactional
	public boolean updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");
		}

		String logDetails;

		if ("UNREPAIRABLE".equals(status)) {
			if (item.getQuantity() < quantity || item.getDefectiveQuantity() < quantity) {
				throw new IllegalStateException(
						"Es können nicht mehr Artikel als irreparabel markiert werden, als vorhanden oder defekt sind.");
			}
			item.setQuantity(item.getQuantity() - quantity);
			item.setDefectiveQuantity(item.getDefectiveQuantity() - quantity);
			item.setDefectReason(reason);
			logDetails = String.format("Permanently removed %d x '%s' (ID: %d) from stock (unrepairable). Reason: %s",
					quantity, item.getName(), itemId, reason);
			adminLogService.log(adminUser.getUsername(), "ITEM_UNREPAIRABLE", logDetails);
		} else {
			int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
			if (item.getQuantity() < newDefectiveTotal) {
				throw new IllegalStateException(
						"Die Gesamtzahl der defekten Artikel kann die Gesamtmenge nicht überschreiten.");
			}
			item.setDefectiveQuantity(newDefectiveTotal);
			item.setDefectReason(reason);
			logDetails = String.format("Defect status for '%s' (ID: %d) updated: %d defective. Reason: %s",
					item.getName(), itemId, newDefectiveTotal, reason);
			adminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS", logDetails);
		}

		storageDAO.updateItem(item);
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

@Service
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getCpuLoad() * 100.0);

		long totalMemoryBytes = Runtime.getRuntime().totalMemory();
		long freeMemoryBytes = Runtime.getRuntime().freeMemory();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\TodoService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.TodoDAO;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class TodoService {
	private static final Logger logger = LogManager.getLogger(TodoService.class);
	private final TodoDAO todoDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public TodoService(TodoDAO todoDAO, AdminLogService adminLogService) {
		this.todoDAO = todoDAO;
		this.adminLogService = adminLogService;
	}

	public List<TodoCategory> getAllTodos() {
		return todoDAO.getAllCategoriesWithTasks();
	}

	@Transactional
	public TodoCategory createCategory(String name, User admin) {
		try {
			TodoCategory newCategory = todoDAO.createCategory(name);
			if (newCategory != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_CATEGORY",
						"To-Do Kategorie '" + name + "' erstellt.");
			}
			return newCategory;
		} catch (Exception e) {
			logger.error("Service error creating To-Do category '{}'", name, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public TodoTask createTask(int categoryId, String content, User admin) {
		try {
			TodoTask newTask = todoDAO.createTask(categoryId, content);
			if (newTask != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_TASK",
						"To-Do Aufgabe '" + content + "' in Kategorie ID " + categoryId + " erstellt.");
			}
			return newTask;
		} catch (Exception e) {
			logger.error("Service error creating To-Do task in category {}", categoryId, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public boolean updateTask(int taskId, String content, Boolean isCompleted, User admin) {
		boolean success = false;
		if (content != null) {
			success = todoDAO.updateTaskContent(taskId, content);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_TASK", "Aufgabe ID " + taskId + " aktualisiert.");
		}
		if (isCompleted != null) {
			success = todoDAO.updateTaskStatus(taskId, isCompleted);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_STATUS",
						"Status für Aufgabe ID " + taskId + " auf '" + isCompleted + "' gesetzt.");
		}
		return success;
	}

	@Transactional
	public boolean deleteTask(int taskId, User admin) {
		if (todoDAO.deleteTask(taskId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_TASK", "Aufgabe ID " + taskId + " gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean deleteCategory(int categoryId, User admin) {
		if (todoDAO.deleteCategory(categoryId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_CATEGORY",
					"Kategorie ID " + categoryId + " und alle zugehörigen Aufgaben gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean reorder(Map<String, List<Integer>> reorderData, User admin) {
		List<Integer> categoryOrder = reorderData.get("categoryOrder");
		if (categoryOrder != null) {
			todoDAO.updateCategoryOrder(categoryOrder);
		}

		for (Map.Entry<String, List<Integer>> entry : reorderData.entrySet()) {
			if (entry.getKey().startsWith("category-")) {
				int categoryId = Integer.parseInt(entry.getKey().substring("category-".length()));
				todoDAO.updateTaskOrders(entry.getValue(), categoryId);
			}
		}
		adminLogService.log(admin.getUsername(), "TODO_REORDER", "To-Do-Listen neu sortiert.");
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\UserService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
	private static final Logger logger = LogManager.getLogger(UserService.class);

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public UserService(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public int createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername) {
		int newUserId = userDAO.createUser(user, password);
		if (newUserId > 0) {
			userDAO.updateUserPermissions(newUserId, permissionIds);
			logger.info("Transaction for creating user '{}' committed successfully.", user.getUsername());

			String logDetails = String.format(
					"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %s) erstellt und Berechtigungen zugewiesen.",
					user.getUsername(), newUserId, user.getRoleId(), user.getClassName());
			adminLogService.log(adminUsername, "CREATE_USER", logDetails);

			return newUserId;
		} else {
			throw new RuntimeException("Benutzererstellung lieferte eine ungültige ID zurück.");
		}
	}

	@Transactional
	public boolean updateUserWithPermissions(User user, String[] permissionIds) {
		boolean profileUpdated = userDAO.updateUser(user);
		boolean permissionsUpdated = userDAO.updateUserPermissions(user.getId(), permissionIds);
		logger.info("Transaction for updating user '{}' committed successfully.", user.getUsername());
		return profileUpdated || permissionsUpdated;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\WikiService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.WikiDAO;
import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Service
public class WikiService {
	private static final Logger logger = LogManager.getLogger(WikiService.class);
	private final WikiDAO wikiDAO;

	@Autowired
	public WikiService(WikiDAO wikiDAO) {
		this.wikiDAO = wikiDAO;
	}

	/**
	 * Fetches all wiki entries and organizes them into a hierarchical tree
	 * structure. The structure is a map of maps, where the final value is a
	 * WikiEntry object.
	 *
	 * @return A Map representing the root of the file tree.
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getWikiTreeAsData() {
		List<WikiEntry> allEntries = wikiDAO.getAllWikiEntries();
		Map<String, Object> rootNode = new LinkedHashMap<>();

		for (WikiEntry entry : allEntries) {
			String[] pathParts = entry.getFilePath().split("/");
			Map<String, Object> currentNode = rootNode;

			for (int i = 0; i < pathParts.length - 1; i++) {
				String part = pathParts[i];
				// This cast is safe within this algorithm as we are intentionally building a
				// nested map structure.
				currentNode = (Map<String, Object>) currentNode.computeIfAbsent(part,
						k -> new LinkedHashMap<String, Object>());
			}

			String fileName = pathParts[pathParts.length - 1];
			if (!fileName.isEmpty()) {
				currentNode.put(fileName, entry);
			}
		}
		logger.debug("Successfully built wiki tree with {} root elements.", rootNode.size());
		return rootNode;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\FileSignatureValidator.java
========================================================================

package de.technikteam.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FileSignatureValidator {
	private static final Logger logger = LogManager.getLogger(FileSignatureValidator.class);

	private static final Map<String, List<byte[]>> MAGIC_NUMBERS = new HashMap<>();

	static {
		// JPEG
		MAGIC_NUMBERS.put("image/jpeg", List.of(new byte[] { (byte) 0xFF, (byte) 0xD8, (byte) 0xFF }));
		// PNG
		MAGIC_NUMBERS.put("image/png", List.of(new byte[] { (byte) 0x89, (byte) 0x50, (byte) 0x4E, (byte) 0x47 }));
		// GIF
		MAGIC_NUMBERS.put("image/gif", List.of(new byte[] { (byte) 0x47, (byte) 0x49, (byte) 0x46, (byte) 0x38 }));
		// PDF
		MAGIC_NUMBERS.put("application/pdf",
				List.of(new byte[] { (byte) 0x25, (byte) 0x50, (byte) 0x44, (byte) 0x46 }));
		// DOCX, XLSX, PPTX (PKZIP archive)
		List<byte[]> pkzip = List.of(new byte[] { (byte) 0x50, (byte) 0x4B, (byte) 0x03, (byte) 0x04 });
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.wordprocessingml.document", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.presentationml.presentation", pkzip);
	}

	private static final int MAX_HEADER_SIZE = 8;

	public static boolean isFileTypeAllowed(MultipartFile file) {
		if (file == null || file.isEmpty()) {
			return false;
		}
		String declaredMimeType = file.getContentType();
		List<byte[]> expectedSignatures = MAGIC_NUMBERS.get(declaredMimeType);

		if (expectedSignatures == null) {
			logger.warn("File upload blocked for undeclared MIME type: {}", declaredMimeType);
			return false; // Type not in our allowed map
		}

		try (InputStream is = file.getInputStream()) {
			byte[] header = new byte[MAX_HEADER_SIZE];
			int bytesRead = is.read(header);
			if (bytesRead < 1)
				return false;

			byte[] actualHeader = Arrays.copyOf(header, bytesRead);

			for (byte[] signature : expectedSignatures) {
				if (actualHeader.length >= signature.length) {
					byte[] headerToCompare = Arrays.copyOf(actualHeader, signature.length);
					if (Arrays.equals(headerToCompare, signature)) {
						return true; // Match found
					}
				}
			}
		} catch (IOException e) {
			logger.error("Could not read file header for validation", e);
			return false;
		}

		logger.warn("File signature mismatch. Declared MIME type: {}, but magic bytes do not match. Upload blocked.",
				declaredMimeType);
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

/**
 * DEPRECATED: This class is no longer used for security-sensitive sanitization.
 * The OWASP Java HTML Sanitizer is now used instead to provide robust
 * protection against Cross-Site Scripting (XSS) attacks. This class is retained
 * for historical purposes or non-security-related transformations if needed.
 */
public final class MarkdownUtil {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private MarkdownUtil() {
	}

	/**
	 * A simple, non-security-focused method to perform basic transformations.
	 *
	 * @param markdown The raw string.
	 * @return The transformed string.
	 */
	public static String transform(String markdown) {
		if (markdown == null || markdown.isEmpty()) {
			return markdown;
		}
		// Example transformation: none, as this is deprecated for security.
		return markdown;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Feedback", "/feedback", "fa-lightbulb", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(new NavigationItem("Anträge", "/admin/requests", "fa-inbox", Permissions.USER_UPDATE));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/admin/dateien", "fa-file-upload", Permissions.FILE_MANAGE));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgangs-Vorlagen", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Kit-Verwaltung", "/admin/kits", "fa-box-open", Permissions.KIT_READ));
		ALL_ITEMS
				.add(new NavigationItem("Feedback", "/admin/feedback", "fa-inbox", Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Abzeichen", "/admin/achievements", "fa-award", Permissions.ACHIEVEMENT_VIEW));
		ALL_ITEMS.add(new NavigationItem("Defekte Artikel", "/admin/defekte", "fa-wrench", Permissions.STORAGE_READ));
		ALL_ITEMS
				.add(new NavigationItem("Quali-Matrix", "/admin/matrix", "fa-th-list", Permissions.QUALIFICATION_READ));
		ALL_ITEMS.add(new NavigationItem("Berichte", "/admin/berichte", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(new NavigationItem("Aktions-Log", "/admin/log", "fa-clipboard-list", Permissions.LOG_READ));
		ALL_ITEMS.add(new NavigationItem("System", "/admin/system", "fa-server", Permissions.SYSTEM_READ));
		ALL_ITEMS.add(new NavigationItem("Wiki", "/admin/wiki", "fa-book-reader", Permissions.ACCESS_ADMIN_PANEL));
		ALL_ITEMS.add(new NavigationItem("API Docs", "/swagger-ui.html", "fa-code", Permissions.ACCESS_ADMIN_PANEL));
	}

	private NavigationRegistry() {
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null || user.getPermissions() == null) {
			return new ArrayList<>();
		}

		final Set<String> userPermissions = user.getPermissions();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items are always visible
			if (requiredPerm == null) {
				return true;
			}

			// Super-admins see all admin items
			if (userPermissions.contains(Permissions.ACCESS_ADMIN_PANEL)) {
				return true;
			}

			// Special case: The "Admin Dashboard" link is visible if the user has *any*
			// admin-level access.
			if (Permissions.ADMIN_DASHBOARD_ACCESS.equals(requiredPerm)) {
				return user.hasAdminAccess();
			}

			// Special case: The "Abzeichen" link is visible if user can perform any
			// achievement action.
			if (Permissions.ACHIEVEMENT_VIEW.equals(requiredPerm)) {
				return userPermissions.contains(Permissions.ACHIEVEMENT_CREATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_UPDATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_DELETE);
			}

			// Standard permission check for all other items
			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms as a thread-safe
 * Spring Component. It maps event IDs to a set of active sessions, allowing for
 * targeted broadcasting of messages.
 */
@Component
public class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByEvent = new ConcurrentHashMap<>();

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, WebSocketSession session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\EventChatSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class EventChatSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(EventChatSocketHandler.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private final EventChatDAO chatDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ChatSessionManager sessionManager;
	private final Gson gson;
	private final PolicyFactory inlineFormattingPolicy;

	@Autowired
	public EventChatSocketHandler(EventChatDAO chatDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService, ChatSessionManager sessionManager,
			@Qualifier("inlineFormattingPolicy") PolicyFactory inlineFormattingPolicy) {
		this.chatDAO = chatDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.sessionManager = sessionManager;
		this.inlineFormattingPolicy = inlineFormattingPolicy;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String eventId = getEventId(session);

		if (user == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Authentifizierung erforderlich."));
			return;
		}

		if (eventId == null || !eventDAO.isUserAssociatedWithEvent(Integer.parseInt(eventId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Keine Berechtigung für diesen Event-Chat."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("eventId", eventId);
		sessionManager.addSession(eventId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) {
		User user = (User) session.getAttributes().get("user");
		String eventId = (String) session.getAttributes().get("eventId");
		if (user == null || eventId == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message.getPayload(), Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = inlineFormattingPolicy.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = inlineFormattingPolicy.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload",
					Map.of("messageId", messageId, "newText", sanitizedText));
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload",
					Map.of("messageId", messageId, "originalUsername", payload.get("originalUsername"),
							"deletedByUsername", user.getUsername()));
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + event.getId()));
				notificationService.sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
		String eventId = (String) session.getAttributes().get("eventId");
		if (eventId != null) {
			sessionManager.removeSession(eventId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication) {
			Authentication auth = (Authentication) session.getPrincipal();
			if (auth.getPrincipal() instanceof SecurityUser) {
				return ((SecurityUser) auth.getPrincipal()).getUser();
			}
		}
		return null;
	}

	private String getEventId(WebSocketSession session) {
		// URI pattern is /ws/chat/{eventId}
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\WebSocketConfig.java
========================================================================

package de.technikteam.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	private final EventChatSocketHandler eventChatSocketHandler;

	@Autowired
	public WebSocketConfig(EventChatSocketHandler eventChatSocketHandler) {
		this.eventChatSocketHandler = eventChatSocketHandler;
	}

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(eventChatSocketHandler, "/ws/chat/{eventId}").setAllowedOrigins("*"); 
	}
}
========================================================================
FILE: src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<!-- For development, use a human-readable pattern -->
			<!-- <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} 
				- %msg%n"/> -->

			<!-- For production/structured logging, use JSON Template Layout -->
			<JsonTemplateLayout
				eventTemplateUri="classpath:Log4j2JsonTemplate.json" />
		</Console>
	</Appenders>
	<Loggers>
		<Root level="info">
			<AppenderRef ref="Console" />
		</Root>
		<!-- Set a more verbose level for our application's packages during development -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
		</Logger>
	</Loggers>
</Configuration>
========================================================================
FILE: src\main\resources\db\migration\V10__Populate_wiki_data_part5.sql
========================================================================

-- Flyway migration V10, Part 5

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/filter/CharacterEncodingFilter.java', '1.  **File Overview & Purpose**\n\n    This is a simple but critical utility filter that ensures all incoming requests and outgoing responses are handled using the UTF-8 character encoding. This is essential for correctly processing and displaying international characters, such as German umlauts (ä, ö, ü), which might be present in user input or database content.\n\n2.  **Architectural Role**\n\n    This class is a low-level infrastructure component in the **Web/Controller Tier**. It should be the first filter in the chain to ensure that character encoding is set before any other filter or servlet attempts to read request parameters or write to the response.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.Filter`)**: The interface it implements.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doFilter(ServletRequest request, ServletResponse response, FilterChain chain)`**:\n        *   **Purpose:** Sets the character encoding for the request and response.\n        *   **Logic:**\n            1.  It calls `request.setCharacterEncoding(\"UTF-8\")`. This must be done *before* any parameters are read from the request.\n            2.  It calls `response.setCharacterEncoding(\"UTF-8\")`. This informs the browser how to interpret the response body.\n            3.  It then calls `chain.doFilter(request, response)` to pass control to the next filter in the chain.'),
('src/main/java/de/technikteam/listener/AppContextListener.java', '1.  **File Overview & Purpose**\n\n    This is a Jakarta EE lifecycle listener that executes code when the web application is shut down. Its primary responsibility is to perform critical cleanup of resources that are managed outside the servlet container''s direct control, specifically the MySQL JDBC driver. This prevents memory leaks in long-running application servers like Tomcat.\n\n2.  **Architectural Role**\n\n    This is a core **Configuration** / **Infrastructure** component. It hooks into the servlet container''s lifecycle to ensure a clean shutdown of the application.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.ServletContextListener`)**: The interface it implements to listen for application startup and shutdown events.\n    *   **MySQL Connector/J (`com.mysql.cj.jdbc.AbandonedConnectionCleanupThread`)**: A specific class from the MySQL driver that manages a background thread. This listener explicitly shuts it down.\n    *   **java.sql.DriverManager**: The standard Java class for managing JDBC drivers.\n\n4.  **In-Depth Breakdown**\n\n    *   **`contextInitialized(ServletContextEvent sce)`**: This method is called when the application starts. It currently only logs an informational message.\n\n    *   **`contextDestroyed(ServletContextEvent sce)`**:\n        *   **Purpose:** This method is called by the servlet container just before the application is undeployed or the server is shut down.\n        *   **Logic:**\n            1.  **Shutdown MySQL Cleanup Thread:** It calls `AbandonedConnectionCleanupThread.checkedShutdown()` to gracefully stop a background thread started by the MySQL JDBC driver. This prevents the thread from outliving the application and causing a memory leak.\n            2.  **Deregister JDBC Driver:** It iterates through all registered JDBC drivers using `DriverManager.getDrivers()`. For each driver, it checks if the driver was loaded by the web application''s own classloader. If so, it calls `DriverManager.deregisterDriver()` to remove it. This is the crucial step to allow the classloader and the driver''s classes to be garbage collected, preventing a common source of memory leaks in Java web applications.'),
('src/main/java/de/technikteam/listener/ApplicationInitializerListener.java', '1.  **File Overview & Purpose**\n\n    This is a Jakarta EE lifecycle listener that runs once when the application context is first initialized. Its sole responsibility is to set up and execute database migrations using the Flyway library. This ensures that the database schema is at the correct version before the application starts handling requests.\n\n2.  **Architectural Role**\n\n    This is a critical **Configuration** / **Infrastructure** component. It acts as the bootstrap for the **DAO Tier**, ensuring the database schema is consistent with what the application''s code expects. It runs before any servlets or DAOs are instantiated.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.ServletContextListener`)**: The interface it implements.\n    *   **Flyway (`org.flywaydb.core.Flyway`)**: The core library used to manage and apply database migrations.\n    *   `ConfigurationService`: Used to retrieve the database connection details from `config.properties`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`contextInitialized(ServletContextEvent sce)`**:\n        *   **Purpose:** This method is called by the servlet container when the application starts up.\n        *   **Logic:**\n            1.  It instantiates a `ConfigurationService` to load the application''s properties.\n            2.  It configures a `Flyway` instance with the database URL, user, and password from the configuration.\n            3.  `locations(\"classpath:db/migration\")`: It tells Flyway to look for SQL migration scripts on the classpath in the `db/migration` folder.\n            4.  `baselineOnMigrate(true)`: This allows Flyway to automatically create its schema history table if it doesn''t exist, which is useful for the first-time deployment on an empty database.\n            5.  `flyway.migrate()`: This is the command that executes the migration. Flyway connects to the database, checks its history table, and applies any new, unapplied migration scripts in version order.\n            6.  **CORRECTION**: The code was updated to use the `result.migrationsExecuted` getter method instead of direct field access, resolving a compiler warning.\n            7.  It logs the outcome of the migration. If the migration fails (`!result.success`), it throws a `RuntimeException`, which will prevent the application from starting successfully.\n\n    *   **`contextDestroyed(ServletContextEvent sce)`**: This method is called on shutdown and currently only logs an informational message.'),
('src/main/java/de/technikteam/listener/SessionListener.java', '1.  **File Overview & Purpose**\n\n    This is a Jakarta EE lifecycle listener that monitors the creation and destruction of `HttpSession` objects. Its purpose is to keep the `SessionManager`''s central registry of active sessions up-to-date.\n\n2.  **Architectural Role**\n\n    This is an infrastructure component in the **Web/Controller Tier**. It provides the mechanism for the `SessionManager` to track all active user sessions across the application.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.http.HttpSessionListener`)**: The interface it implements to receive session lifecycle events.\n    *   `SessionManager`: The singleton class that this listener updates.\n\n4.  **In-Depth Breakdown**\n\n    *   **`sessionCreated(HttpSessionEvent se)`**\n        *   **Method Signature:** `public void sessionCreated(HttpSessionEvent se)`\n        *   **Purpose:** This method is called by the servlet container immediately after a new session is created.\n        *   **Logic:** It retrieves the new `HttpSession` from the event object and passes it to `SessionManager.addSession()` to add it to the central registry.\n        *   **Side Effects:** Adds a session to the `SessionManager`''s concurrent map.\n\n    *   **`sessionDestroyed(HttpSessionEvent se)`**\n        *   **Method Signature:** `public void sessionDestroyed(HttpSessionEvent se)`\n        *   **Purpose:** This method is called by the servlet container just before a session is invalidated (either due to timeout or an explicit `invalidate()` call).\n        *   **Logic:** It retrieves the `HttpSession` being destroyed and passes it to `SessionManager.removeSession()` to remove it from the central registry.\n        *   **Side Effects:** Removes a session from the `SessionManager`''s concurrent map.'),
('src/main/java/de/technikteam/model/Achievement.java', '1.  **File Overview & Purpose**\n\n    This is a Plain Old Java Object (POJO) that serves as the data model for an achievement. It represents a record from the `achievements` table and includes fields for its programmatic key, user-facing name, description, and associated FontAwesome icon. A transient field, `earnedAt`, is used to store when a specific user earned the achievement.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer achievement data between the `AchievementDAO`, `AchievementService`, and the servlets/JSPs.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: Used for the `earnedAt` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key.\n        *   `achievementKey`: A unique, immutable string identifier used programmatically to grant achievements (e.g., \"EVENT_PARTICIPANT_5\").\n        *   `name`: The user-visible name of the achievement (e.g., \"Erfahrener Techniker\").\n        *   `description`: A user-visible description of how to earn the achievement.\n        *   `iconClass`: The FontAwesome CSS class for the achievement''s icon (e.g., \"fa-star\").\n        *   `earnedAt`: A transient field populated when fetching achievements for a specific user, indicating when they received it.\n    *   **`getFormattedEarnedAt()`**: A convenience method that uses the `DateFormatter` utility to provide a display-ready date string for the JSP views.\n    *   **Getters and Setters**: Standard boilerplate methods for accessing and modifying the object''s properties.'),
('src/main/java/de/technikteam/model/AdminLog.java', '1.  **File Overview & Purpose**\n\n    This is a POJO representing a single audit log entry from the `admin_logs` table. It models an administrative action, capturing who performed it, what they did, when they did it, and any relevant details.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It''s created by the `AdminLogService` to be persisted by the `AdminLogDAO`, and it''s retrieved by the `AdminLogDAO` to be displayed in the `admin_log.jsp` view.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for the `getFormattedActionTimestamp()` convenience method.\n    *   `java.time.LocalDateTime`: Used for the `actionTimestamp` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the log entry.\n        *   `adminUsername`: The username of the administrator who performed the action.\n        *   `actionType`: A short, programmatic string identifying the type of action (e.g., \"CREATE_USER\", \"DELETE_EVENT\").\n        *   `details`: A human-readable text description of the action.\n        *   `actionTimestamp`: The exact date and time the action occurred.\n    *   **`getFormattedActionTimestamp()`**: A view-helper method that provides a pre-formatted string for the timestamp, suitable for direct use in JSPs.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/ApiResponse.java', '1.  **File Overview & Purpose**\n\n    This is a standard Data Transfer Object (DTO) used to create consistent JSON responses for all API endpoints. It enforces a uniform structure containing a success status, a human-readable message, and an optional data payload, which simplifies client-side handling of AJAX requests.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**, but its primary use is within the **Web/Controller Tier**. Servlets and Action classes create instances of `ApiResponse` to structure their JSON output before serialization with Gson.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `success` (boolean): `true` if the operation was successful, `false` otherwise.\n        *   `message` (String): A user-friendly message describing the outcome of the operation (e.g., \"User successfully created.\", \"Invalid password.\").\n        *   `data` (Object): An optional payload containing any relevant data to be sent back to the client (e.g., the newly created User object, a list of items).\n    *   **Static Factory Methods (`success`, `error`)**:\n        *   **Purpose:** These provide a convenient and readable way to construct `ApiResponse` objects without needing to call the constructor directly.\n        *   **Examples:**\n            *   `ApiResponse.success(\"Operation complete.\")`\n            *   `ApiResponse.error(\"Failed to find item.\")`\n            *   `ApiResponse.success(\"User found.\", userObject)'),
('src/main/java/de/technikteam/model/Attachment.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a file attachment record from the `attachments` table. It models a polymorphic relationship, linking a physical file to a parent entity (which can be either an ''EVENT'' or a ''MEETING'') and defines the visibility of the attachment based on user roles.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It''s used to transfer attachment metadata between the `AttachmentDAO`, services, and servlets.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `uploadedAt` timestamp.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the attachment record.\n        *   `parentType`: An enum-like string (`\"EVENT\"` or `\"MEETING\"`) indicating the type of entity this attachment belongs to.\n        *   `parentId`: The foreign key ID of the parent entity (e.g., the `event.id`).\n        *   `filename`: The original, user-facing name of the file.\n        *   `filepath`: The unique, sanitized path of the file on the server''s filesystem.\n        *   `uploadedAt`: The timestamp of when the file was uploaded.\n        *   `requiredRole`: An enum-like string (`\"NUTZER\"` or `\"ADMIN\"`) that determines the minimum role required to view and download the file.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/Course.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a \"course template\" from the `courses` table. It defines the general properties of a type of training or qualification, such as \"Grundlehrgang Tontechnik\", but does not represent a specific, schedulable event.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Model Tier**. It is used to transfer data about course templates between the `CourseDAO` and the `AdminCourseServlet` for management purposes.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the course.\n        *   `name`: The full, user-facing name of the course (e.g., \"Grundlehrgang Tontechnik\").\n        *   `abbreviation`: A short abbreviation (e.g., \"TON-GL\") used for display in compact views like the Qualification Matrix.\n        *   `description`: A general description of the course content and goals.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/DashboardDataDTO.java', '1.  **File Overview & Purpose**\n\n    This is a Data Transfer Object (DTO) designed to aggregate all the necessary information for rendering the dynamic widgets on the admin dashboard. It bundles data from multiple sources into a single object, simplifying the data retrieval process in the `AdminDashboardService` and its delivery to the `AdminDashboardApiServlet`.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Model Tier**. It acts as a data container, facilitating communication between the **Service Tier** (`AdminDashboardService`) and the **Web/Controller Tier** (`AdminDashboardApiServlet`).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `Event`, `StorageItem`, `AdminLog`: The model classes for the data it contains.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `upcomingEvents` (List<Event>): A list of the next few upcoming events.\n        *   `lowStockItems` (List<StorageItem>): A list of inventory items whose available quantity is below a certain threshold.\n        *   `recentLogs` (List<AdminLog>): A list of the most recent administrative actions.\n        *   `eventTrendData` (List<Map<String, Object>>): Time-series data for the event trend chart, with each map representing a month and its event count.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/Event.java', '1.  **File Overview & Purpose**\n\n    This is a comprehensive model representing a single event from the `events` table. It contains not only the core event data but also serves as an aggregator for all related information, such as assigned users, tasks, skill requirements, and reserved materials. It also includes transient fields for UI logic, like `isUserQualified`.\n\n2.  **Architectural Role**\n\n    This class is a central part of the **Model Tier**. It''s heavily used across all tiers: created and populated by the `EventDAO`, manipulated in the `EventService`, and passed to JSPs in the **View Tier** for detailed display.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for convenience methods that provide display-ready date strings.\n    *   `User`, `SkillRequirement`, `EventTask`, etc.: Other model classes that this class aggregates.\n\n4.  **In-Depth Breakdown**\n\n    *   **Core Fields:**\n        *   `id`, `name`, `eventDateTime`, `endDateTime`, `description`, `location`, `status`, `leaderUserId`: These map directly to columns in the `events` table.\n    *   **Aggregated Lists:**\n        *   `skillRequirements`, `assignedAttendees`, `eventTasks`, `chatMessages`, `attachments`, `reservedItems`, `customFields`: These are lists of related objects, populated by the `EventDAO` or `EventDetailsServlet` when a detailed view of the event is required. They are \"transient\" in the sense that they are not columns in the `events` table itself.\n    *   **Transient UI Fields:**\n        *   `userAttendanceStatus`: Stores the current user''s specific status for this event (e.g., \"ANGEMELDET\", \"ZUGEWIESEN\").\n        *   `isUserQualified`: A boolean flag indicating if the current user meets the skill requirements for this event.\n    *   **Convenience Methods:**\n        *   `getFormattedEventDateTime`, `getFormattedEventDateTimeRange`: Use the `DateFormatter` to provide JSP-ready strings for event times, encapsulating the formatting logic within the model.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V11__Populate_wiki_data_part6.sql
========================================================================

-- Flyway migration V11, Part 6

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/model/EventAttendance.java', '1.  **File Overview & Purpose**\n\n    This POJO models a single record from the `event_attendance` table. It represents a user''s sign-up status for a specific event, which is distinct from their final assignment to the event team.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It''s used to transfer data about user sign-ups between the `EventDAO` and servlets that need to check or display this information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `eventId`: Foreign key to the `events` table.\n        *   `userId`: Foreign key to the `users` table.\n        *   `username`: A transient field, populated from a JOIN, for display purposes.\n        *   `signupStatus`: An enum-like string (`\"ANGEMELDET\"` or `\"ABGEMELDET\"`) representing the user''s voluntary status.\n        *   `commitmentStatus`: An enum-like string (`\"BESTÄTIGT\"`, `\"OFFEN\"`, etc.) that an admin could potentially set, though this feature might not be fully implemented.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/EventChatMessage.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single message from the `event_chat_messages` table. It contains all the data for a chat message, including the content, sender information, timestamps, and state flags for edits and deletions.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It''s created and managed by the `EventChatDAO` and serialized to JSON by the `EventChatSocket` for real-time communication with the client-side chat interface.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime` and `DateTimeFormatter`: Used for handling and formatting timestamps.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`, `eventId`, `userId`, `username`, `messageText`, `sentAt`: Core message data.\n        *   `edited`: A boolean flag that is set to `true` if the message content has been updated.\n        *   `isDeleted`: A boolean flag for soft-deletes.\n        *   `deletedByUserId`, `deletedByUsername`, `deletedAt`: Fields to track who performed a soft delete and when.\n        *   `chatColor`: The sender''s preferred chat color, fetched via a JOIN in the DAO.\n    *   **Formatting Methods (`getFormattedSentAt`, `getFormattedDeletedAt`)**: Convenience methods to provide display-ready time strings for the UI.'),
('src/main/java/de/technikteam/model/EventCustomField.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a custom field definition for an event''s sign-up form, corresponding to a record in the `event_custom_fields` table. It defines the properties of a question asked to users during sign-up, such as its name, type (e.g., text, boolean), and whether it''s required.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer data about custom field definitions between the `EventCustomFieldDAO`, `EventService`, and the `EventCustomFieldsApiServlet` which provides this data to the frontend.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the custom field.\n        *   `eventId`: A foreign key linking this field to a specific event.\n        *   `fieldName`: The question or label for the field (e.g., \"T-Shirt Größe\").\n        *   `fieldType`: An enum-like string (`\"TEXT\"`, `\"BOOLEAN\"`, etc.) that determines the type of input rendered on the frontend.\n        *   `isRequired`: A boolean flag indicating if the user must provide an answer to sign up.\n        *   `fieldOptions`: A string (potentially JSON) to store options for field types like ''DROPDOWN'' or ''CHECKBOX_GROUP''.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/EventCustomFieldResponse.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a user''s response to a specific custom field for an event. It corresponds to a record in the `event_custom_field_responses` table, linking a user, a custom field, and their provided answer.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created by the `EventActionServlet` when a user submits their sign-up form and is passed to the `EventCustomFieldDAO` for persistence.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the response.\n        *   `fieldId`: A foreign key linking this response to a specific `EventCustomField`.\n        *   `userId`: A foreign key linking this response to the user who submitted it.\n        *   `responseValue`: The user''s answer, stored as a string.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/EventTask.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single task associated with an event, corresponding to a record in the `event_tasks` table. It contains the task''s description and status, and also serves as an aggregator for related data like assigned users, required items, and kits.\n\n2.  **Architectural Role**\n\n    This class is a central part of the **Model Tier**. It is used to transfer detailed task information between the `EventTaskDAO`, the `EventDetailsServlet`, and the JSP view.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `User`, `StorageItem`, `InventoryKit`: Model classes that this class aggregates in lists.\n\n4.  **In-Depth Breakdown**\n\n    *   **Core Fields:**\n        *   `id`, `eventId`, `description`, `details`, `status`, `displayOrder`, `requiredPersons`: These map directly to columns in the `event_tasks` table.\n    *   **Aggregated Lists:**\n        *   `assignedUsers`: A list of `User` objects directly assigned to this task.\n        *   `requiredItems`: A list of `StorageItem` objects needed for this task.\n        *   `requiredKits`: A list of `InventoryKit` objects needed for this task.\n    *   **Transient UI Fields:**\n        *   `eventName`: The name of the parent event, populated for display on the user dashboard.\n        *   `assignedUsernames`: A transient string field, which is not used. The getter method provides the same functionality dynamically.\n    *   **Convenience Methods:**\n        *   `getAssignedUsernames()`: A view-helper method that generates a comma-separated string of assigned usernames from the `assignedUsers` list, providing a display-ready value for JSPs.'),
('src/main/java/de/technikteam/model/FeedbackForm.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a feedback form, corresponding to a record in the `feedback_forms` table. It acts as a container for feedback responses related to a specific event.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created and retrieved by the `EventFeedbackDAO` and used by the `FeedbackServlet` to manage the event feedback process.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `createdAt` timestamp.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the feedback form.\n        *   `eventId`: A foreign key linking this form to a specific `Event`.\n        *   `title`: The title of the feedback form, typically including the event name.\n        *   `createdAt`: The timestamp of when the form record was created.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/FeedbackResponse.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a user''s submitted feedback for a specific event, corresponding to a record in the `feedback_responses` table. It captures a user''s rating and textual comments for a given feedback form.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created in the `FeedbackServlet` with data from a user''s form submission and is passed to the `EventFeedbackDAO` to be saved to the database.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `submittedAt` timestamp.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the response.\n        *   `formId`: A foreign key linking this response to a `FeedbackForm`.\n        *   `userId`: A foreign key linking this response to the submitting `User`.\n        *   `rating`: An integer representing the user''s rating (e.g., 1-5 stars).\n        *   `comments`: The user''s textual feedback or suggestions.\n        *   `submittedAt`: The timestamp of when the feedback was submitted.\n        *   `username`: A transient field, populated from a JOIN, for display purposes.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/FeedbackSubmission.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a general feedback submission (e.g., bug report, feature request) from a user, corresponding to a record in the `feedback_submissions` table. It includes details about the submission, its current status in the workflow, and its display order on the admin Kanban board.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer feedback data between the `FeedbackSubmissionDAO` and the servlets responsible for handling feedback (`FeedbackServlet`, `MyFeedbackServlet`, `AdminFeedbackServlet`).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for the `getFormattedSubmittedAt()` convenience method.\n    *   `java.time.LocalDateTime`: Used for the `submittedAt` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`, `userId`, `subject`, `content`, `submittedAt`: Core data of the submission.\n        *   `username`: Transient field for the submitter''s name.\n        *   `displayTitle`: An optional, admin-editable title to clarify the subject.\n        *   `status`: An enum-like string (`\"NEW\"`, `\"VIEWED\"`, `\"PLANNED\"`, etc.) representing its stage in the Kanban workflow.\n        *   `displayOrder`: An integer used to maintain the order of cards within a status column on the Kanban board.\n    *   **`getFormattedSubmittedAt()`**: A view-helper method providing a pre-formatted string for the submission timestamp.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/File.java', '1.  **File Overview & Purpose**\n\n    This POJO represents the metadata for a single file stored in the system, corresponding to a record in the `files` table. It holds information about the file''s name, its physical location on the server, its category, and access restrictions.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It''s used to transfer file metadata between the `FileDAO` and various servlets that display or manage files.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for the `getFormattedUploadedAt()` convenience method.\n    *   `java.time.LocalDateTime`: Used for the `uploadedAt` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`, `filename`, `filepath`, `categoryId`, `uploadedAt`: Core metadata mapping to table columns.\n        *   `categoryName`: A transient field, populated by a JOIN, for easy display in views.\n        *   `requiredRole`: An enum-like string (`\"NUTZER\"` or `\"ADMIN\"`) to control access.\n        *   `content`: A transient field used to hold the file''s text content when it is being read for the Markdown editor.\n    *   **`getFormattedUploadedAt()`**: A view-helper method that provides a display-ready timestamp.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/FileCategory.java', '1.  **File Overview & Purpose**\n\n    This is a simple POJO representing a category for organizing files, corresponding to a record in the `file_categories` table. It provides a way to group related documents in the UI.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used by the `FileDAO` and passed to the `AdminFileManagementServlet` to display and manage file categories.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the category.\n        *   `name`: The user-visible name of the category.\n    *   **Getters and Setters**: Standard methods for property access.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V12__Populate_wiki_data_part7.sql
========================================================================

-- Flyway migration V12, Part 7

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/model/InventoryKit.java', '1.  **File Overview & Purpose**\n\n    This POJO represents an \"inventory kit\" or a \"case,\" corresponding to a record in the `inventory_kits` table. A kit is a conceptual container that groups a predefined list of `StorageItem`s together, such as \"Audio Kit A\" or \"Lighting Case 1\".\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer data about kits between the `InventoryKitDAO` and the `AdminKitServlet` for management, and the `PackKitServlet` for displaying packing lists.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `InventoryKitItem`: The model class representing the items contained within this kit.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the kit.\n        *   `name`: The user-facing name of the kit (e.g., \"Mics and Stands\").\n        *   `description`: A brief description of the kit''s purpose.\n        *   `location`: The physical storage location of the assembled kit (e.g., \"Lager, Schrank 3\").\n        *   `items` (List<InventoryKitItem>): A list of the items and their quantities that belong to this kit. This is populated by a JOIN query in the DAO.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/InventoryKitItem.java', '1.  **File Overview & Purpose**\n\n    This POJO represents an entry in the `inventory_kit_items` junction table. It defines the relationship between an `InventoryKit` and a `StorageItem`, specifying the quantity of that item that belongs in the kit.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is primarily used within the `InventoryKit` model to represent the contents of a kit.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `kitId`: Foreign key to the `inventory_kits` table.\n        *   `itemId`: Foreign key to the `storage_items` table.\n        *   `quantity`: The number of this specific item that should be in the kit.\n        *   `itemName`: A transient field, populated from a JOIN in the DAO, to display the item''s name without needing to fetch the full `StorageItem` object.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/MaintenanceLogEntry.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single record from the `maintenance_log` table. It captures the history of maintenance actions performed on a specific `StorageItem`, including repairs, marking for maintenance, and associated notes or costs.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created by servlets like `AdminStorageServlet` to be persisted by the `MaintenanceLogDAO`, and is retrieved to be displayed on the `storage_item_details.jsp` page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for the `getFormattedLogDate()` convenience method.\n    *   `java.time.LocalDateTime`: Used for the `logDate` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the log entry.\n        *   `itemId`: Foreign key to the `storage_items` table.\n        *   `userId`: Foreign key to the `users` table, indicating who performed the action.\n        *   `logDate`: The timestamp of the maintenance action.\n        *   `action`: A string describing the action (e.g., \"Marked for Maintenance\", \"Returned to Service\").\n        *   `notes`: Free-text notes from the user about the action.\n        *   `cost`: The cost associated with the maintenance, if any.\n        *   `username`: A transient field, populated by a JOIN, for displaying the user''s name.\n    *   **`getFormattedLogDate()`**: A view-helper method to provide a pre-formatted timestamp string.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/Meeting.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a specific, schedulable session or \"meeting\" for a course, corresponding to a record in the `meetings` table. Unlike a `Course` which is a template, a `Meeting` has a concrete date, time, and location.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer data about scheduled meetings between the `MeetingDAO`, various servlets (e.g., `MeetingServlet`, `AdminMeetingServlet`), and the JSP views.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for convenience methods that provide display-ready date and time strings.\n    *   `java.time.LocalDateTime`: Used for the meeting''s start and end times.\n\n4.  **In-Depth Breakdown**\n\n    *   **Core Fields:**\n        *   `id`, `courseId`, `name`, `meetingDateTime`, `endDateTime`, `leaderUserId`, `description`, `location`: These map directly to columns in the `meetings` table.\n    *   **Transient UI Fields:**\n        *   `parentCourseName`: The name of the `Course` this meeting belongs to, populated by a JOIN.\n        *   `leaderUsername`: The name of the user leading the meeting, populated by a JOIN.\n        *   `userAttendanceStatus`: Stores the current logged-in user''s sign-up status for this meeting (`ANGEMELDET`, `ABGEMELDET`, `OFFEN`).\n    *   **Convenience Methods (`getFormatted...`)**: These methods use the `DateFormatter` to provide JSP-ready strings for the meeting''s date and time range, encapsulating formatting logic.'),
('src/main/java/de/technikteam/model/MeetingAttendance.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a user''s attendance record for a specific meeting, corresponding to a row in the `meeting_attendance` table. It tracks whether a user was present and allows for optional administrative remarks.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer attendance data between the `MeetingAttendanceDAO` and the servlets that manage and display this information, most notably the `MatrixServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `userId`: Foreign key to the `users` table.\n        *   `meetingId`: Foreign key to the `meetings` table.\n        *   `attended`: A boolean flag indicating if the user was present (`true`) or not (`false`).\n        *   `remarks`: An optional string for administrative notes, such as \"excused absence\".\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/NavigationItem.java', '1.  **File Overview & Purpose**\n\n    This is a simple, immutable POJO used to represent a single link in the application''s sidebar navigation. It holds all the necessary data to render a navigation item, including its label, URL, icon, and the permission required to view it.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. Instances of this class are created and managed exclusively by the `NavigationRegistry` utility and are stored in the user''s session to be rendered by the `main_header.jspf` fragment on every page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields (all `final`):**\n        *   `label`: The user-visible text of the link (e.g., \"Dashboard\").\n        *   `url`: The relative URL for the link (e.g., \"/home\").\n        *   `icon`: The FontAwesome CSS class for the link''s icon (e.g., \"fa-home\").\n        *   `requiredPermission`: The permission key (from the `Permissions` class) that a user must have to see this link. A `null` value indicates the link is visible to all authenticated users.\n    *   **Constructor and Getters**: A standard constructor to initialize the final fields and getters to access their values. There are no setters, making the object immutable.'),
('src/main/java/de/technikteam/model/ParticipationHistory.java', '1.  **File Overview & Purpose**\n\n    This is a Data Transfer Object (DTO) designed specifically for reporting purposes. It aggregates data from multiple tables (`users`, `events`, `event_attendance`, `event_assignments`) to create a flattened view of a user''s participation in an event. It does not map to a single database table.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Model Tier**. It is used by the `ReportDAO` to structure the results of complex analytical queries and is then passed to the `AdminReportServlet` for display or export.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `eventDate` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `username`: The name of the user.\n        *   `eventName`: The name of the event.\n        *   `eventDate`: The date and time of the event.\n        *   `status`: The user''s status for that event (e.g., \"ZUGEWIESEN\", \"ANGEMELDET\").\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/PasskeyCredential.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a WebAuthn/Passkey credential stored in the `user_passkeys` table. It holds all the necessary information for a user to perform a passwordless login, including the public key, credential ID, and a signature counter for security.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer credential data between the `PasskeyDAO` and the `PasskeyService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `createdAt` timestamp.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The internal primary key in the database.\n        *   `userId`: Foreign key linking the credential to a `User`.\n        *   `name`: A user-provided name for the device (e.g., \"My Laptop\").\n        *   `userHandle`: A unique identifier for the user, provided during registration.\n        *   `credentialId`: The globally unique, URL-safe Base64 encoded ID for this credential.\n        *   `publicKey`: The user''s public key, encoded as a string.\n        *   `signatureCount`: A counter that is incremented on each successful authentication to help prevent credential cloning.\n        *   `createdAt`: The timestamp of when the credential was registered.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/Permission.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single, defined permission from the `permissions` table. It models a granular action that can be assigned to a user, providing a structured object containing the permission''s unique key and a human-readable description.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used by the `PermissionDAO` to represent permission data retrieved from the database and is passed to the `AdminUserServlet` to populate the permissions checklist in the user editing modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the permission.\n        *   `permissionKey`: The unique string identifier for the permission (e.g., \"USER_CREATE\"). This key is used for programmatic checks.\n        *   `description`: A user-friendly description of what the permission allows (e.g., \"Kann neue Benutzer anlegen.\").\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/ProfileChangeRequest.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a user''s request to modify their own profile data, corresponding to a record in the `profile_change_requests` table. It captures who made the request, what changes they requested (as a JSON string), its current status, and who reviewed it.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer request data between the `ProfileChangeRequestDAO` and the servlets that handle the request workflow (`ProfileServlet` for creation, `AdminChangeRequestServlet` for review).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: For the `requestedAt` and `reviewedAt` timestamps.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the request.\n        *   `userId`: Foreign key of the user who made the request.\n        *   `username`: Transient field for the requester''s name, for display in the admin UI.\n        *   `requestedChanges`: A JSON string containing a map of the fields to be changed and their new values (e.g., `{\"email\":\"new@email.com\", \"className\":\"11a\"}`).\n        *   `status`: An enum-like string (`\"PENDING\"`, `\"APPROVED\"`, `\"DENIED\"`) indicating the state of the request.\n        *   `requestedAt`: Timestamp of when the request was submitted.\n        *   `reviewedByAdminId`: Foreign key of the admin who reviewed the request.\n        *   `reviewedByAdminName`: Transient field for the admin''s name.\n        *   `reviewedAt`: Timestamp of when the request was reviewed.\n    *   **Getters and Setters**: Standard methods for property access.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V13__Populate_wiki_data_part8.sql
========================================================================

-- Flyway migration V13, Part 8

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/model/Role.java', '1.  **File Overview & Purpose**\n\n    This is a simple POJO representing a user role from the `roles` table. It defines a high-level grouping of users (e.g., \"ADMIN\", \"NUTZER\").\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used by the `RoleDAO` to represent role data and is passed to the `AdminUserServlet` to populate the roles dropdown list.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the role.\n        *   `roleName`: The unique name of the role (e.g., \"ADMIN\").\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/SkillRequirement.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single skill requirement for an event, corresponding to a record in the `event_skill_requirements` table. It links an event to a specific course (acting as the \"skill\") and specifies how many people with that qualification are needed.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer data about an event''s personnel needs between the `EventDAO`, `EventService`, and the `AdminEventServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `requiredCourseId`: The foreign key ID of the `Course` that represents the required skill.\n        *   `requiredPersons`: The number of people with this skill needed for the event.\n        *   `courseName`: A transient field, populated by a JOIN, to display the name of the required course in the UI.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/StorageItem.java', '1.  **File Overview & Purpose**\n\n    This is a comprehensive model representing a single inventory item from the `storage_items` table. It contains all the core data about an item, such as its name, location, and quantities, as well as transient fields and convenience methods for UI display logic.\n\n2.  **Architectural Role**\n\n    This class is a central part of the **Model Tier**. It''s used across all tiers: managed by the `StorageDAO`, manipulated by the `StorageService`, and displayed in various views like `lager.jsp` and `admin_storage_list.jsp`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None.\n\n4.  **In-Depth Breakdown**\n\n    *   **Core Fields:**\n        *   Maps directly to the columns in the `storage_items` table: `id`, `name`, `location`, `cabinet`, `compartment`, `quantity` (total including defective), `maxQuantity`, `defectiveQuantity`, `defectReason`, `weightKg`, `priceEur`, `imagePath`, `status`, `currentHolderUserId`, `assignedEventId`.\n    *   **Transient UI Fields:**\n        *   `currentHolderUsername`: The name of the user who has checked out the item, populated by a JOIN.\n    *   **Convenience Methods:**\n        *   **`getAvailableQuantity()`**: Calculates the non-defective, available quantity (`quantity` - `defectiveQuantity`). This is a crucial piece of business logic encapsulated within the model.\n        *   **`getAvailabilityStatus()`**: Returns a human-readable status string (\"Vollständig\", \"Niedriger Bestand\", \"Vergriffen\") based on the available quantity relative to the maximum quantity.\n        *   **`getAvailabilityStatusCssClass()`**: Returns a corresponding CSS class (`status-ok`, `status-warn`, `status-danger`) for the availability status, simplifying JSP logic.'),
('src/main/java/de/technikteam/model/StorageLogEntry.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single transaction log entry from the `storage_log` table. It serves as a historical record of an item being checked in or out of the inventory.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created by the `StorageService` to be persisted by the `StorageLogDAO`, and is retrieved by the DAO to be displayed on the `storage_item_details.jsp` page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `DateFormatter`: Used for the `getFormattedTimestamp()` method.\n    *   `java.time.LocalDateTime` and `DateTimeFormatter`: For handling and formatting the transaction timestamp.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`, `itemId`, `userId`, `notes`, `eventId`, `transactionTimestamp`: These map directly to table columns.\n        *   `quantityChange`: An integer representing the change in quantity. It is negative for check-outs and positive for check-ins.\n        *   `username`: A transient field, populated by a JOIN, for displaying the name of the user who performed the transaction.\n    *   **Convenience Methods (`getFormattedTimestamp`, `getTransactionTimestampLocaleString`)**: Provide different formatted string representations of the `transactionTimestamp` for use in the UI.'),
('src/main/java/de/technikteam/model/SystemStatsDTO.java', '1.  **File Overview & Purpose**\n\n    This is a Data Transfer Object (DTO) designed to hold a snapshot of the server''s system-level statistics. It aggregates various metrics like CPU, RAM, and disk usage into a single, clean object for easy serialization and transport to the client.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is created by the `SystemInfoService` and serialized to JSON by the `SystemStatsApiServlet` to provide real-time data for the admin system status page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `cpuLoad` (double): The system-wide CPU load as a percentage (0.0 - 100.0).\n        *   `totalMemory` (long): Total physical RAM in Gigabytes.\n        *   `usedMemory` (long): Used physical RAM in Gigabytes.\n        *   `totalDiskSpace` (long): Total disk space of the root partition in Gigabytes.\n        *   `usedDiskSpace` (long): Used disk space of the root partition in Gigabytes.\n        *   `uptime` (String): A human-readable string representing the server uptime (e.g., \"5 Tage, 10 Stunden, 3 Minuten\").\n        *   `batteryPercentage` (int): The current battery level as a percentage (0-100), or -1 if not available.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/TodoCategory.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a category in the To-Do list feature, corresponding to a record in the `todo_categories` table. It acts as a container for a list of related `TodoTask` objects.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used by the `TodoDAO` and `TodoService` to structure the To-Do list data for the `AdminTodoApiServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `TodoTask`: The model class for the tasks contained within this category.\n    *   `java.util.List`: Used for the `tasks` collection.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the category.\n        *   `name`: The name of the category (e.g., \"Urgent Bugs\", \"Feature Ideas\").\n        *   `displayOrder`: An integer that determines the vertical sorting of categories on the board.\n        *   `tasks` (List<TodoTask>): A list of task objects that belong to this category.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/TodoTask.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a single task item in the To-Do list feature, corresponding to a record in the `todo_tasks` table. It contains the task''s content, its completion status, and its display order within its category.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used as a child object within the `TodoCategory` model and is managed by the `TodoDAO` and `TodoService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the task.\n        *   `categoryId`: A foreign key linking the task to its parent `TodoCategory`.\n        *   `content`: The text of the to-do item.\n        *   `isCompleted`: A boolean flag indicating whether the task is done.\n        *   `displayOrder`: An integer that determines the sorting of tasks within a category.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/User.java', '1.  **File Overview & Purpose**\n\n    This is the central model representing a user in the application, corresponding to a record in the `users` table. It holds all core profile information, as well as the user''s role and the complete, resolved set of their permissions. It includes a key business logic method `hasAdminAccess()` for authorization checks.\n\n2.  **Architectural Role**\n\n    This is a critical class in the **Model Tier**. A `User` object is stored in the `HttpSession` upon successful login and is accessed by nearly every other component in the application—from filters and servlets for authorization to DAOs for identifying the actor in log entries.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `Permissions`: The constants class is used within the `hasAdminAccess()` method.\n    *   `DateFormatter`: Used by the `getFormattedCreatedAt()` convenience method.\n\n4.  **In-Depth Breakdown**\n\n    *   **Core Fields:**\n        *   `id`, `username`, `roleId`, `createdAt`, `classYear`, `className`, `email`, `chatColor`, `theme`: These map to columns in the `users` table.\n    *   **Aggregated/Transient Fields:**\n        *   `roleName`: The name of the user''s role, populated by a JOIN in the `UserDAO`.\n        *   `permissions` (Set<String>): The complete set of permission keys the user has. This is populated at login time by the `UserDAO` by resolving both direct and role-based permissions.\n    *   **`hasAdminAccess()`**\n        *   **Method Signature:** `public boolean hasAdminAccess()`\n        *   **Purpose:** A crucial piece of business logic encapsulated in the model. It provides a single, reliable way to determine if a user should have access to administrative areas.\n        *   **Logic:** It returns `true` if the user has the master `ACCESS_ADMIN_PANEL` permission, or if they have *any* other permission that implies administrative capabilities (e.g., any `_CREATE`, `_DELETE`, `_MANAGE` permission). This is more flexible than just checking for the \"ADMIN\" role name.\n    *   **`getFormattedCreatedAt()`**: A view-helper method to provide a JSP-ready string for the user''s registration date.\n    *   **Constructors and Getters/Setters**: Includes a default constructor, a convenience constructor, and standard property accessors.'),
('src/main/java/de/technikteam/model/UserQualification.java', '1.  **File Overview & Purpose**\n\n    This POJO represents a user''s qualification, linking a user to a course. It corresponds to a record in the `user_qualifications` table and tracks the user''s status for that course (e.g., \"BESUCHT\", \"ABSOLVIERT\"), the date of completion, and any administrative remarks.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer qualification data between the `UserQualificationsDAO` and the servlets that display this information, such as the `ProfileServlet` and the `MatrixServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDate`: Used for the `completionDate` field.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `userId`: Foreign key to the `users` table.\n        *   `courseId`: Foreign key to the `courses` table.\n        *   `courseName`: A transient field, populated by a JOIN, for displaying the course''s name.\n        *   `status`: An enum-like string indicating the user''s progress in the course.\n        *   `completionDate`: The date on which the user achieved \"ABSOLVIERT\" status.\n        *   `remarks`: Optional administrative notes.\n    *   **Getters and Setters**: Standard methods for property access.'),
('src/main/java/de/technikteam/model/WikiEntry.java', '1.  **File Overview & Purpose**\n\n    This is a simple Plain Old Java Object (POJO) that serves as the data model for a single wiki documentation page. It represents a record from the `wiki_documentation` table.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer wiki data between the `WikiDAO`, the `WikiService`, and the administrative servlets that manage the wiki.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the wiki entry.\n        *   `filePath`: A unique string representing the path of the documented file within the project (e.g., \"src/main/java/de/technikteam/service/UserService.java\"). This is the key used for lookups.\n        *   `content`: A `longtext` field containing the Markdown documentation for the file.\n    *   **Getters and Setters**: Standard boilerplate methods for accessing and modifying the object''s properties.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V14__Populate_wiki_data_part9.sql
========================================================================

-- Flyway migration V14, Part 9

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/admin/action/Action.java', '1.  **File Overview & Purpose**\n\n    This is the interface that defines the contract for the Command pattern used in the `FrontControllerServlet`. Each class that implements this interface represents a single, self-contained, executable administrative action. This pattern promotes a clean separation of concerns, making the `FrontControllerServlet` a simple dispatcher and encapsulating all business logic for an action in its own class.\n\n2.  **Architectural Role**\n\n    This interface is a core part of the **Web/Controller Tier**''s design. It defines the structure for the command objects that are managed by Guice and executed by the Front Controller.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `ApiResponse` (Model): The standardized response object that all actions must return.\n    *   **Jakarta Servlet API**: For the `HttpServletRequest` and `HttpServletResponse` parameters.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Method Signature:** `ApiResponse execute(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException`\n        *   **Purpose:** This is the single method that all action classes must implement. It contains the complete logic for processing a specific request, including parameter validation, authorization checks, calls to service or DAO layers, and constructing the final `ApiResponse`.\n        *   **Parameters:**\n            *   `request`: The HTTP request object, providing access to parameters, the session, etc.\n            *   `response`: The HTTP response object, which can be used to send errors directly if needed.\n        *   **Returns:** An `ApiResponse` object summarizing the outcome of the action.'),
('src/main/java/de/technikteam/servlet/admin/action/ApproveChangeAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the business logic for approving a user''s profile change request. It retrieves the request, applies the changes to the target user''s profile, updates the request status, and triggers a real-time notification to force the user to log out for security reasons.\n\n2.  **Architectural Role**\n\n    This class is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It coordinates between the `ProfileChangeRequestDAO` and `UserDAO` to perform a multi-step, state-changing operation.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the necessary DAOs and services.\n    *   `ProfileChangeRequestDAO`: To fetch the request and update its status.\n    *   `UserDAO`: To fetch the user to be updated and save the changes.\n    *   `AdminLogService`: To create an audit trail for the approval.\n    *   `NotificationService`: To send a real-time logout notification to the affected user.\n    *   `SessionManager`: To invalidate all of the user''s active sessions.\n    *   **Gson**: To deserialize the `requestedChanges` JSON string into a `Map`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Performs the approval logic.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the admin has `USER_UPDATE` permission.\n            2.  **Data Retrieval:** Fetches the `ProfileChangeRequest` and the target `User` object.\n            3.  **Apply Changes:** It deserializes the JSON string of requested changes into a `Map`. It then iterates through this map and applies the new values to the `userToUpdate` object.\n            4.  **Database Updates:** It calls `userDAO.updateUser()` to save the changes and `requestDAO.updateRequestStatus()` to mark the request as \"APPROVED\".\n            5.  **Logging & Notification:** If the updates are successful, it logs the action, sends a real-time notification to the user, and calls `SessionManager.invalidateSessionsForUser()` to terminate all of the user''s sessions, forcing them to log back in and get a fresh user object.\n            6.  **Response:** Returns an `ApiResponse` indicating success or failure.'),
('src/main/java/de/technikteam/servlet/admin/action/CreateUserAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for creating a new user. It handles parameter validation, checks the password against the security policy, and calls the `UserService` to perform the transactional creation of the user and their permissions.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It acts as a controller for the user creation process, delegating the core transactional logic to the `UserService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserService` and `RoleDAO`.\n    *   `UserService`: The service that handles the transactional creation of a user and their permissions.\n    *   `RoleDAO`: Used to enrich the response object with the role name after creation.\n    *   `PasswordPolicyValidator`: To ensure the new user''s password meets security standards.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** The main execution method for the create user action.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the admin has `USER_CREATE` permission.\n            2.  **Parameter Retrieval:** Gets all user data (username, password, role, etc.) and permission IDs from the request.\n            3.  **Password Validation:** Calls `PasswordPolicyValidator.validate()` on the new password. If it fails, it immediately returns an error `ApiResponse`.\n            4.  **Object Creation:** Creates a new `User` model object and populates it with the form data.\n            5.  **Service Call:** Calls `userService.createUserWithPermissions()`, passing in the new user object, the password, and the permission IDs. This service method handles the database transaction.\n            6.  **Response:** If the service call is successful (returns a new user ID), it enriches the `User` object with its new role name and returns it in a successful `ApiResponse`. Otherwise, it returns an error response.'),
('src/main/java/de/technikteam/servlet/admin/action/DeleteFeedbackAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for deleting a feedback submission. It handles the database operation and logs the action.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is triggered by an AJAX call from the admin feedback board UI.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FeedbackSubmissionDAO` and `AdminLogService`.\n    *   `FeedbackSubmissionDAO`: The DAO used to perform the deletion.\n    *   `AdminLogService`: To create an audit trail of the deletion.\n    *   `NotificationService`: To broadcast a UI update to other connected admins.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Deletes a feedback submission record.\n        *   **Logic:**\n            1.  **Authorization:** Ensures the user has admin access.\n            2.  **Parameter Parsing:** Retrieves the `submissionId` from the request.\n            3.  **Database Deletion:** Calls `submissionDAO.deleteSubmission()`.\n            4.  **Logging & Notification:** If the deletion is successful, it logs the action and broadcasts a `feedback_deleted` UI update via the `NotificationService` so that the item disappears from the board for all other watching admins.\n            5.  **Response:** Returns an `ApiResponse` indicating success or failure.'),
('src/main/java/de/technikteam/servlet/admin/action/DeleteUserAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for deleting a user account. It includes several important security checks to prevent administrators from deleting themselves or other higher-privileged administrators.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It handles the user deletion process, which is a critical and destructive action.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserDAO` and `AdminLogService`.\n    *   `UserDAO`: The DAO used to delete the user record.\n    *   `AdminLogService`: To create an audit trail of the deletion.\n    *   `NotificationService`: To broadcast a UI update to other connected admins.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Performs a secure deletion of a user account.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the performing admin has the `USER_DELETE` permission.\n            2.  **Self-Deletion Check:** It verifies that the admin is not trying to delete their own account (`loggedInAdmin.getId() == userIdToDelete`).\n            3.  **Privilege Escalation Check:** It fetches the user to be deleted and checks if they have the master `ACCESS_ADMIN_PANEL` permission. If so, it only allows the deletion if the *performing* admin also has this master permission. This prevents a lower-level admin from deleting a superuser.\n            4.  **Database Deletion:** If all checks pass, it calls `userDAO.deleteUser()`.\n            5.  **Logging & Notification:** If the deletion is successful, it logs the action and broadcasts a `user_deleted` UI update so the user is removed from the user list for all watching admins.\n            6.  **Response:** Returns an `ApiResponse` indicating success or failure.'),
('src/main/java/de/technikteam/servlet/admin/action/DenyChangeAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for denying a user''s profile change request. It updates the request''s status in the database to \"DENIED\" and creates an audit log entry.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is called via an AJAX request from the admin requests page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `ProfileChangeRequestDAO` and `AdminLogService`.\n    *   `ProfileChangeRequestDAO`: The DAO used to fetch the request and update its status.\n    *   `AdminLogService`: To create an audit trail of the denial.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Processes the denial of a change request.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the admin has `USER_UPDATE` permission.\n            2.  **Data Validation:** It retrieves the request by its ID and ensures it is still in a \"PENDING\" state to prevent race conditions.\n            3.  **Database Update:** It calls `requestDAO.updateRequestStatus()`, passing the new status \"DENIED\" and the admin''s ID.\n            4.  **Logging:** If the update is successful, it logs the denial action.\n            5.  **Response:** Returns an `ApiResponse` indicating success or failure.'),
('src/main/java/de/technikteam/servlet/admin/action/GetFeedbackDetailsAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class is a simple data retrieval command. Its sole purpose is to fetch the full details of a single feedback submission from the database and return it as the data payload in an `ApiResponse`.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It serves as an API endpoint for the client-side JavaScript (`admin_feedback.js`) to populate the feedback details modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FeedbackSubmissionDAO`.\n    *   `FeedbackSubmissionDAO`: The DAO used to retrieve the feedback entry by its ID.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Fetches and returns the details of one feedback submission.\n        *   **Logic:**\n            1.  It parses the `submissionId` from the request parameters.\n            2.  It calls `submissionDAO.getSubmissionById()`.\n            3.  If a submission is found, it returns an `ApiResponse.success` with the `FeedbackSubmission` object as the data payload.\n            4.  If no submission is found, it returns an `ApiResponse.error`.'),
('src/main/java/de/technikteam/servlet/admin/action/ResetPasswordAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class handles the administrative function of resetting a user''s password. It generates a new, secure random password, updates the user''s password hash in the database, and returns the new password to the admin so it can be communicated to the user.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is a critical security-related action.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserDAO` and `AdminLogService`.\n    *   `UserDAO`: Used to save the new password hash.\n    *   `AdminLogService`: To create an audit trail of the password reset.\n    *   `java.security.SecureRandom`: Used to generate a cryptographically strong random password.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Resets a user''s password.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the admin has `USER_PASSWORD_RESET` permission.\n            2.  It fetches the target `User` object to ensure it exists.\n            3.  It calls the private `generateRandomPassword()` method to create a new, compliant password.\n            4.  It calls `userDAO.changePassword()` to hash and save the new password.\n            5.  If successful, it logs the action and returns an `ApiResponse.success`. The new password is included in the response''s data payload so the client-side script can display it to the admin.\n\n    *   **`generateRandomPassword(int length)`**: A private helper method that generates a secure, random password of a given length, containing a mix of character types.'),
('src/main/java/de/technikteam/servlet/admin/action/UnlockUserAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class provides the functionality to manually unlock a user account that has been locked due to too many failed login attempts. It interacts with the static `LoginAttemptManager` to clear the lockout status for a given username.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It provides an administrative override for the brute-force protection mechanism.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AdminLogService`.\n    *   `LoginServlet.LoginAttemptManager`: The static inner class that manages lockout state.\n    *   `AdminLogService`: To create an audit trail of the unlock action.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Unlocks a user account.\n        *   **Logic:**\n            1.  **Authorization:** Ensures the performing user is a full admin (`hasAdminAccess()`).\n            2.  It retrieves the `usernameToUnlock` from the request.\n            3.  It calls the static method `LoginServlet.LoginAttemptManager.clearLoginAttempts(usernameToUnlock)`, which removes all lockout and failed attempt records for that user from the in-memory maps.\n            4.  It logs the action and returns an `ApiResponse.success`.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V15__Populate_wiki_data_part10.sql
========================================================================

-- Flyway migration V15, Part 10

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/admin/action/UpdateFeedbackOrderAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class handles the complex logic of updating the feedback board after a drag-and-drop operation. It receives the ID of the moved item, its new status (based on the column it was dropped into), and the new order of all items in that destination column. It performs these updates within a single database transaction.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is the server-side endpoint for the drag-and-drop functionality on the feedback Kanban board.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FeedbackSubmissionDAO`, `AdminLogService`, and `DatabaseManager`.\n    *   `DatabaseManager`: To manage the database transaction.\n    *   `FeedbackSubmissionDAO`: Provides the transactional methods `updateStatus` and `updateOrderForStatus`.\n    *   `AdminLogService`: For auditing the reorder action.\n    *   **Gson**: For deserializing the JSON payload from the client.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Persists the new state of the Kanban board after a drag-and-drop.\n        *   **Logic:**\n            1.  **Transaction Management:** It opens a database connection and disables auto-commit.\n            2.  **Payload Parsing:** It retrieves the JSON payload containing the `submissionId`, `newStatus`, and the array of `orderedIds` for the destination column.\n            3.  **Database Updates:** It performs two separate updates within the transaction:\n                *   Calls `submissionDAO.updateStatus()` to change the status of the card that was moved.\n                *   Calls `submissionDAO.updateOrderForStatus()` with the list of all IDs in the destination column to perform a batch update of their `display_order`.\n            4.  **Commit/Rollback:** It commits the transaction if both operations succeed, or rolls back if an error occurs.\n            5.  **Logging & Response:** It logs the action and returns an `ApiResponse`.'),
('src/main/java/de/technikteam/servlet/admin/action/UpdateFeedbackStatusAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class handles updates to a feedback submission made via the details modal (not via drag-and-drop). It allows an admin to change a submission''s status and its optional display title.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is the endpoint for the save button in the feedback details modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FeedbackSubmissionDAO` and `AdminLogService`.\n    *   `FeedbackSubmissionDAO`: The DAO used to update the record.\n    *   `AdminLogService`: For auditing the status change.\n    *   `NotificationService`: To broadcast a UI update to other connected admins.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** Updates a feedback submission''s details.\n        *   **Logic:**\n            1.  **Authorization:** Ensures the user is an admin.\n            2.  **Parameter Parsing:** Retrieves `submissionId`, `newStatus`, and `displayTitle` from the request.\n            3.  **Database Update:** Calls `submissionDAO.updateStatusAndTitle()` to persist the changes.\n            4.  **Logging & Notification:** If successful, it logs the action and broadcasts a `feedback_status_updated` UI update to other clients, so they see the change in real-time.\n            5.  **Response:** Returns a standard `ApiResponse`.'),
('src/main/java/de/technikteam/servlet/admin/action/UpdateUserAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for updating an existing user''s profile and permissions. It constructs a `User` object with the new data and calls the `UserService` to perform the transactional update.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is the endpoint for the \"Save\" button in the user edit modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects `UserDAO`, `RoleDAO`, `UserService`, and `AdminLogService`.\n    *   `UserService`: The service that handles the transactional update of a user and their permissions.\n    *   `UserDAO`: To fetch the original user data for logging and comparison.\n    *   `AdminLogService`: To create a detailed audit log of what was changed.\n    *   `NotificationService`: To broadcast the user update to other clients.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** The main execution method for the update user action.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the admin has `USER_UPDATE` permission.\n            2.  **Fetch Original User:** Retrieves the original `User` object from the database to compare against the new values.\n            3.  **Build Updated User:** Creates a new `User` object and populates it with the data from the form submission.\n            4.  **Change Detection:** It compares each field of the new user object with the original one and builds a detailed `changes` string for the audit log (e.g., \"Benutzername von ''old'' zu ''new'', Rolle-ID von ''1'' zu ''3'', ...\").\n            5.  **Service Call:** Calls `userService.updateUserWithPermissions()` to perform the transactional database update.\n            6.  **Session Update (Self-Edit):** If an admin updates their own profile, it refreshes the `User` object in their session to immediately reflect the changes.\n            7.  **Logging & Notification:** It logs the action with the detailed `changes` string and broadcasts a `user_updated` UI update.\n            8.  **Response:** Returns an `ApiResponse.success` with the refreshed user object as the data payload.'),
('src/main/java/de/technikteam/servlet/admin/api/AdminTodoApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet provides a complete JSON API for the administrative To-Do list feature. It handles all CRUD and reordering operations for To-Do categories and tasks, allowing the frontend (`admin_todo.js`) to manage the entire feature asynchronously without full page reloads.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (specifically, the API sub-layer). It receives AJAX requests, validates them, calls the `TodoService` to perform the business logic and database operations, and returns a standardized `ApiResponse` in JSON format.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `TodoService`.\n    *   `TodoService`: The service layer component that contains the transactional logic for all To-Do list operations.\n    *   **Gson**: Used for both deserializing incoming JSON payloads (for the `doPut` method) and serializing the `ApiResponse` for the response.\n    *   `CSRFUtil`: For security validation on all state-changing requests (POST, PUT, DELETE).\n\n4.  **In-Depth Breakdown**\n\n    This servlet implements `doGet`, `doPost`, `doPut`, and `doDelete` to correspond to RESTful principles.\n\n    *   **`doGet(...)`**: Fetches and returns the entire list of categories with their nested tasks as a JSON array.\n    *   **`doPost(...)`**: Handles the creation of new items. It uses an `action` parameter to distinguish between creating a category (`\"createCategory\"`) and creating a task (`\"createTask\"`).\n    *   **`doPut(...)`**: Handles updates. It reads a JSON payload from the request body and uses an `action` parameter within that payload to differentiate between updating a task''s content/status (`\"updateTask\"`) and reordering items (`\"reorder\"`).\n    *   **`doDelete(...)`**: Handles deletion. It checks for either a `taskId` or `categoryId` parameter in the URL to determine what to delete.\n    *   **`sendJsonResponse(...)`**: A private helper method to standardize the process of setting the HTTP status code, content type, and writing the JSON response.'),
('src/main/java/de/technikteam/servlet/admin/api/CrewFinderApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves a specialized JSON API endpoint for the \"Crew Finder\" feature. Given an event ID, it identifies all users who are both qualified (meet all skill requirements) and available (not assigned to a conflicting event) for that specific event.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is called via an AJAX request from the event creation/editing modal in `admin_events_list.js`. It interacts directly with the `EventDAO` to execute the complex query required.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO`.\n    *   `EventDAO`: Contains the `getQualifiedAndAvailableUsersForEvent()` method, which performs the core database query.\n    *   **Gson**: Used to serialize the resulting list of `User` objects into a JSON array.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the GET request to find available crew members.\n        *   **Logic:**\n            1.  **Parameter Validation:** It requires an `eventId` parameter.\n            2.  **Authorization:** It performs a crucial authorization check to ensure the requesting user is either an admin or the leader of the specified event.\n            3.  **Data Fetching:** It calls `eventDAO.getQualifiedAndAvailableUsersForEvent(eventId)`. This single DAO call encapsulates the complex SQL logic involving subqueries and joins to determine user qualification and availability.\n            4.  **JSON Response:** It serializes the list of qualified `User` objects into JSON and writes it to the response.'),
('src/main/java/de/technikteam/servlet/api/AdminDashboardApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet acts as the JSON API endpoint for the dynamic widgets on the administrative dashboard. It is designed to be called periodically via AJAX from the client-side to refresh the dashboard with the latest data.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is the data source for the `admin_dashboard.js` script. It delegates the task of data aggregation to the `AdminDashboardService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AdminDashboardService`.\n    *   `AdminDashboardService`: The service that contains the business logic for gathering all the necessary dashboard data.\n    *   **Gson**: Used to serialize the `DashboardDataDTO` into a JSON object.\n    *   `LocalDateTimeAdapter`: A custom Gson adapter required to correctly serialize `LocalDateTime` objects within the DTO.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for dashboard data.\n        *   **Logic:**\n            1.  It calls `dashboardService.getDashboardData()` to get the fully populated `DashboardDataDTO`.\n            2.  It serializes this DTO object into a JSON string.\n            3.  It sets the response content type to `application/json` and writes the JSON string to the response.'),
('src/main/java/de/technikteam/servlet/api/CalendarApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves as a JSON API endpoint to provide event and meeting data for a full-featured calendar component on the client side. It fetches all upcoming events and meetings from the respective DAOs and formats them into a structure that is compatible with libraries like FullCalendar.js.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as a dedicated data source for the client-side calendar view, responding to AJAX requests from the `calendar.js` script. It directly interacts with the `EventDAO` and `MeetingDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO` and `MeetingDAO`.\n    *   `EventDAO`, `MeetingDAO`: DAOs used to fetch all active and upcoming calendar entries.\n    *   **Gson**: Used to serialize the list of calendar entries into a JSON array.\n    *   `LocalDateTimeAdapter`: A custom Gson adapter to ensure `LocalDateTime` objects are serialized into the correct ISO 8601 format that FullCalendar can parse.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests to fetch calendar data.\n        *   **Logic:**\n            1.  It calls `eventDAO.getAllActiveAndUpcomingEvents()` and `meetingDAO.getAllUpcomingMeetings()` to get the raw data.\n            2.  It iterates through both lists, creating a `Map<String, String>` for each entry.\n            3.  Each map is populated with keys that FullCalendar expects: `title`, `start`, `end`, and `url`.\n            4.  It also adds custom properties like `backgroundColor` and `borderColor` to visually distinguish between events and meetings in the calendar.\n            5.  Finally, it serializes the combined list of maps into a JSON string and writes it to the response.\n        *   **Side Effects:** Performs database reads.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V16__Populate_wiki_data_part11.sql
========================================================================

-- Flyway migration V16, Part 11

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/api/EventChatApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet provides a JSON API endpoint for fetching the chat history of a specific event. It is called by the client-side `eventDetails.js` script when a user opens an event details page to populate the chat box with previous messages.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It acts as the data source for the initial state of the event chat. It interacts directly with the `EventChatDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventChatDAO`.\n    *   `EventChatDAO`: The DAO used to retrieve the list of messages for an event.\n    *   **Gson**: Used to serialize the list of `EventChatMessage` objects into a JSON array.\n    *   `LocalDateTimeAdapter`: A custom adapter required for correct JSON serialization of `LocalDateTime` objects.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for an event''s chat history.\n        *   **Logic:**\n            1.  **Parameter Validation:** It expects an `eventId` parameter and returns a 400 Bad Request error if it is missing or invalid.\n            2.  **Data Fetching:** It calls `chatDAO.getMessagesForEvent(eventId)` to get the complete, ordered chat history.\n            3.  **JSON Response:** It serializes the returned list into a JSON string and writes it to the response.'),
('src/main/java/de/technikteam/servlet/api/EventCustomFieldsApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet provides a public JSON API endpoint to fetch the custom sign-up fields for a specific event. It is called by the client-side `events.js` script when a user clicks the \"Anmelden\" (Sign Up) button to dynamically build the sign-up modal form.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is a public-facing API, meaning it can be accessed without full admin rights, but the user must still be authenticated (as enforced by the `AuthenticationFilter`).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventCustomFieldDAO`.\n    *   `EventCustomFieldDAO`: The DAO used to retrieve the custom field definitions for an event.\n    *   **Gson**: Used to serialize the list of `EventCustomField` objects into a JSON array.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for an event''s custom sign-up fields.\n        *   **Logic:**\n            1.  **Parameter Validation:** It requires an `eventId` parameter.\n            2.  **Data Fetching:** It calls `customFieldDAO.getCustomFieldsForEvent(eventId)` to get the list of field definitions.\n            3.  **JSON Response:** It serializes the returned list into a JSON string and writes it to the response.'),
('src/main/java/de/technikteam/servlet/api/MarkdownApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is a dedicated endpoint for saving content from the real-time Markdown editor. It receives the updated content and file ID, validates the user''s permission, and persists the changes to the physical file on the server.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It handles state-changing POST requests from the `admin_editor.js` script. It interacts with the `FileDAO` to write to the file system and update the database record.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FileDAO` and `AdminLogService`.\n    *   `FileDAO`: Used to get the file''s path, update its physical content, and \"touch\" its database record to update the timestamp.\n    *   `AdminLogService`: To create an audit trail of the file modification.\n    *   `CSRFUtil`: For security validation.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the POST request to save Markdown content.\n        *   **Logic:**\n            1.  **Security:** It performs authentication, authorization (`FILE_UPDATE` permission), and CSRF token validation.\n            2.  **Parameter Validation:** It retrieves the `fileId` and `content` from the request.\n            3.  **Data Retrieval:** It fetches the `File` object from the database using the `fileId` to get its physical `filepath`.\n            4.  **Persistence:**\n                *   It calls `fileDAO.updateFileContent()` to overwrite the file on disk with the new content.\n                *   It calls `fileDAO.touchFileRecord()` to update the `uploaded_at` timestamp in the database, indicating a modification.\n            5.  **Logging & Feedback:** It logs the update action to the admin log and sets a success message in the session.\n            6.  **Redirect:** It redirects the user back to the editor page for the same file.'),
('src/main/java/de/technikteam/servlet/api/StorageHistoryApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet provides a JSON API endpoint for fetching the transaction history of a specific storage item. It is used by the `storage_item_details.jsp` page to dynamically load and display the log of check-ins and check-outs for an item.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It responds to AJAX requests from the client-side. It interacts directly with the `StorageLogDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `StorageLogDAO`.\n    *   `StorageLogDAO`: The DAO used to retrieve the transaction history for an item.\n    *   **Gson**: Used to serialize the list of `StorageLogEntry` objects into a JSON array.\n    *   `LocalDateTimeAdapter`: A custom adapter required for correct JSON serialization of `LocalDateTime` objects.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for an item''s history.\n        *   **Logic:**\n            1.  **Parameter Validation:** It expects an `itemId` parameter and returns a 400 Bad Request error if it''s missing or invalid.\n            2.  **Data Fetching:** It calls `logDAO.getHistoryForItem(itemId)` to get the complete transaction log for the specified item.\n            3.  **JSON Response:** It serializes the returned list into a JSON string and writes it to the response.'),
('src/main/java/de/technikteam/servlet/api/SystemStatsApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet provides a JSON API endpoint that exposes live system statistics of the server. It is designed to be polled by the administrative system status page to create a real-time monitoring dashboard.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is the data source for the `admin_system.js` script. It delegates the task of collecting system metrics to the `SystemInfoService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `SystemInfoService`.\n    *   `SystemInfoService`: The service that contains the logic for gathering OS-level statistics.\n    *   **Gson**: Used to serialize the `SystemStatsDTO` into a JSON object.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for system statistics.\n        *   **Logic:**\n            1.  It calls `systemInfoService.getSystemStats()` to get a fresh snapshot of the server''s CPU, RAM, disk, and other metrics.\n            2.  It serializes the resulting `SystemStatsDTO` object into a JSON string.\n            3.  It sets the response content type to `application/json` and writes the JSON string to the response.'),
('src/main/java/de/technikteam/servlet/api/UserPreferencesApiServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is a dedicated API endpoint for saving user-specific preferences. Currently, its only function is to handle the user''s choice of theme (light/dark) and persist it to the database.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It handles asynchronous POST requests from the `main.js` script, which are triggered when the user clicks the theme toggle switch. It interacts directly with the `UserDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserDAO`.\n    *   `UserDAO`: Used to update the theme preference in the `users` table.\n    *   `CSRFUtil`: For security validation.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the POST request to update the user''s theme.\n        *   **Logic:**\n            1.  **Security & Authentication:** It ensures a user is logged in and validates the CSRF token.\n            2.  **Parameter Validation:** It retrieves the `theme` parameter and validates it against a `Set` of allowed values (`\"light\"`, `\"dark\"`) to prevent arbitrary data being saved.\n            3.  **Database Update:** It calls `userDAO.updateUserTheme()` to persist the new theme preference.\n            4.  **Session Update:** If the database update is successful, it also updates the `theme` property of the `User` object in the current session. This ensures that subsequent page loads will render with the correct theme without needing a new database query.\n            5.  **Response:** It returns an HTTP 200 OK status on success or an appropriate error code on failure.'),
('src/main/java/de/technikteam/servlet/api/passkey/AuthenticationFinishServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is the server-side endpoint for completing a WebAuthn/Passkey authentication ceremony. It receives the credential assertion from the browser, validates it, and if successful, establishes a new user session.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It works in tandem with `AuthenticationStartServlet` and the `passkey_auth.js` script to handle passwordless logins. It delegates the complex validation logic to the `PasskeyService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyService`.\n    *   `PasskeyService`: The service that performs the (simulated) cryptographic verification of the passkey assertion.\n    *   **Gson**: Used to serialize the `ApiResponse`.\n    *   `CSRFUtil`, `NavigationRegistry`: For setting up the user session upon successful login.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the POST request containing the WebAuthn credential from the client.\n        *   **Logic:**\n            1.  It reads the JSON payload from the request body.\n            2.  It calls `passkeyService.finishAuthentication()` with the payload.\n            3.  **Success Path:** If the service returns a `User` object, the authentication was successful.\n                *   It establishes a new, clean session for the user.\n                *   It stores the `User` object, a new CSRF token, and the user''s navigation items in the session.\n                *   It returns an `ApiResponse.success` with the user object as the data payload.\n            4.  **Failure Path:** If the service returns `null`, the authentication failed. It returns an `ApiResponse.error` with an HTTP 401 Unauthorized status.'),
('src/main/java/de/technikteam/servlet/api/passkey/AuthenticationStartServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is the server-side endpoint for initiating a WebAuthn/Passkey authentication ceremony. It generates a cryptographic challenge and the necessary options for the browser''s `navigator.credentials.get()` API call.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is the first step in the passkey login flow, called via AJAX from `passkey_auth.js` when the user clicks the \"Login with Passkey\" button. It delegates the logic to the `PasskeyService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyService`.\n    *   `PasskeyService`: The service responsible for generating the challenge and options.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the POST request to start the authentication process.\n        *   **Logic:**\n            1.  It retrieves the `username` from the request.\n            2.  It calls `passkeyService.startAuthentication(username)`. The service generates a challenge (and in a real implementation, would store it in the session) and constructs the `PublicKeyCredentialRequestOptions` JSON.\n            3.  It sets the response content type to `application/json` and writes the JSON options string back to the client.'),
('src/main/java/de/technikteam/servlet/api/passkey/RegistrationFinishServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is the server-side endpoint for completing a WebAuthn/Passkey registration ceremony. It receives the new public key credential from the browser, validates it, and saves it to the database, associating it with the logged-in user.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is called via AJAX from `passkey_auth.js` after the user has successfully created a new passkey on their device. It delegates the validation and persistence logic to the `PasskeyService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyService`.\n    *   `PasskeyService`: The service that performs the (simulated) validation and saves the new credential via the `PasskeyDAO`.\n    *   **Gson**: Used to serialize the `ApiResponse`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the POST request containing the new credential data.\n        *   **Logic:**\n            1.  **Authentication:** It ensures that a user is currently logged into a session before allowing them to register a new device.\n            2.  It retrieves the user-provided `deviceName` from the URL parameters and the credential data (JSON) from the request body.\n            3.  It calls `passkeyService.finishRegistration()` with the user''s ID, the credential data, and the device name.\n            4.  Based on the boolean result from the service, it returns either an `ApiResponse.success` or an `ApiResponse.error` to the client.'),
('src/main/java/de/technikteam/servlet/api/passkey/RegistrationStartServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is the server-side endpoint for initiating a WebAuthn/Passkey registration ceremony. For an already authenticated user, it generates a cryptographic challenge and the necessary options for the browser''s `navigator.credentials.create()` API call.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier** (API sub-layer). It is the first step in the \"add a new device\" flow, called via AJAX from `passkey_auth.js` when a user clicks the \"Register New Device\" button on their profile page. It delegates the logic to the `PasskeyService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyService`.\n    *   `PasskeyService`: The service responsible for generating the challenge and options for registration.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles the GET request to start the registration process.\n        *   **Logic:**\n            1.  **Authentication:** It retrieves the `User` object from the session to ensure only a logged-in user can register a new device.\n            2.  It calls `passkeyService.startRegistration(user)`. The service generates a challenge (which, in a real implementation, would be stored in the session for later verification) and constructs the `PublicKeyCredentialCreationOptions` JSON.\n            3.  It sets the response content type to `application/json` and writes the JSON options string back to the client.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V17__Populate_wiki_data_part12.sql
========================================================================

-- Flyway migration V17, Part 12

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/http/SessionManager.java', '1.  **File Overview & Purpose**\n\n    This is a utility class that provides a centralized, static registry of all active `HttpSession` objects in the application. Its primary function is to allow services to find and invalidate all sessions belonging to a specific user, which is a crucial security feature after sensitive operations like a profile change approval.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Infrastructure/Utility** class that operates within the **Web/Controller Tier**. It is populated by the `SessionListener` and used by `Action` classes like `ApproveChangeAction`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.http.HttpSession`)**: The object type it manages.\n    *   `java.util.concurrent.ConcurrentHashMap`: Used to provide a thread-safe map for storing sessions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`SESSIONS` (static Map)**: A `ConcurrentHashMap` where the key is the session ID and the value is the `HttpSession` object. This map is the central registry.\n    *   **`addSession(HttpSession session)`**: A static method called by `SessionListener` when a new session is created. It adds the session to the map.\n    *   **`removeSession(HttpSession session)`**: A static method called by `SessionListener` when a session is destroyed. It removes the session from the map.\n    *   **`invalidateSessionsForUser(int userId)`**:\n        *   **Method Signature:** `public static void invalidateSessionsForUser(int userId)`\n        *   **Purpose:** The main functional method of the class. It finds all active sessions belonging to a specific user and invalidates them.\n        *   **Logic:** It iterates through the values of the `SESSIONS` map. For each session, it safely retrieves the `User` object, checks if the user''s ID matches the target `userId`, and if so, calls `session.invalidate()`. It includes error handling for already invalidated sessions.'),
('src/main/java/de/technikteam/servlet/CalendarServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for rendering the main calendar page (`/kalender`). It fetches all upcoming events and meetings and prepares several data structures to support different views: a full-grid monthly/weekly calendar for desktop and a simple chronological list for mobile devices.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It gathers data from the `EventDAO` and `MeetingDAO`, performs date-based calculations and groupings, and forwards the prepared data to the `calendar.jsp` view for rendering.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO` and `MeetingDAO`.\n    *   `EventDAO`, `MeetingDAO`: DAOs used to fetch calendar entries.\n    *   `java.time` API: Extensively used for date calculations, such as determining the current month, previous/next months, and the days of the week.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the calendar page.\n        *   **Logic:**\n            1.  **Date Calculation:** Determines the current month and year to display, allowing for navigation via URL parameters (`?year=...&month=...`).\n            2.  **Data Fetching:** Calls the DAOs to get lists of all upcoming `Event` and `Meeting` objects.\n            3.  **Data Aggregation:** Creates a unified list of all calendar entries and then groups them into a `Map<LocalDate, List<Map<String, Object>>>`, which is used by the JSP to place entries on the correct days in the monthly view grid.\n            4.  **Monthly View Data:** Calculates the `startDayOfWeekOffset` (how many empty cells to show before the 1st of the month) and the total `daysInMonth`.\n            5.  **Weekly View Data:** Calculates the start date of the current week and creates a list of maps, with each map representing a day of the week.\n            6.  **Mobile View Data:** Calls the `prepareMobileList` helper method to create a single, sorted chronological list for the mobile view.\n            7.  **Forwarding:** Sets all calculated data as request attributes and forwards the request to `calendar.jsp`.\n\n    *   **`prepareMobileList(...)`**: A private helper method that transforms the `Event` and `Meeting` objects into a unified list of maps, each containing display-ready information like the formatted day, month abbreviation, and a unique URL. It then sorts this list chronologically.'),
('src/main/java/de/technikteam/servlet/DownloadServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles secure file downloads for both general files (from `files` table) and specific attachments (from `attachments` table). It validates that the user is authenticated and authorized to access the requested file, protects against path traversal attacks, and serves the physical file with the correct headers.\n\n2.  **Architectural Role**\n\n    This class is a critical component of the **Web/Controller Tier**. It acts as a secure gateway between a user''s download request and the physical files stored on the server''s filesystem. It interacts with multiple DAOs to perform authorization checks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FileDAO`, `EventDAO`, `MeetingDAO`, `AttachmentDAO`, and `ConfigurationService`.\n    *   DAOs: Used to fetch file metadata and perform authorization checks (e.g., is the user associated with the event the attachment belongs to?).\n    *   `ConfigurationService`: Provides the base path to the file upload directory.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** Handles a GET request for a file download.\n        *   **Logic:**\n            1.  **Authentication:** Ensures a user is logged in.\n            2.  **Parameter Validation:** Checks for a valid `id` parameter.\n            3.  **Data Retrieval:** It first tries to find the ID in the `attachments` table. If not found, it checks the `files` table. This allows a single download endpoint for both types of files.\n            4.  **Authorization:** It calls `isUserAuthorizedForAttachment` or checks the `required_role` on the `File` object to determine if the user has permission to download the file. Admins are always authorized.\n            5.  **File Serving:** If all checks pass, it calls the `serveFile` helper method.\n            6.  **Error Handling:** Sends appropriate HTTP error codes (400, 401, 403, 404) for various failure scenarios.\n\n    *   **`isUserAuthorizedForAttachment(...)`**: A private helper that encapsulates the logic for checking if a non-admin user can access an attachment. The user must be associated with the parent event or meeting.\n\n    *   **`serveFile(...)`**:\n        *   **Purpose:** The core file-serving logic.\n        *   **Logic:**\n            1.  **Path Traversal Protection:** It constructs the full, canonical path to the requested file and ensures that this path is still within the configured upload directory. This is a critical security measure to prevent users from requesting files outside the intended folder (e.g., `?file=../../../../some/system/file`).\n            2.  **File Existence Check:** Verifies that the requested file exists and is a regular file.\n            3.  **Set Headers:** It sets the `Content-Type` to `application/octet-stream` to force a download prompt, sets the `Content-Length`, and sets the `Content-Disposition` header with a properly URL-encoded filename.\n            4.  **Streaming:** It opens a `FileInputStream` to the physical file and streams its bytes to the `HttpServletResponse`''s `OutputStream`.'),
('src/main/java/de/technikteam/servlet/EventActionServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles user actions related to events, such as signing up or signing off. It processes POST requests from the public events page (`events.jsp`) and updates the user''s attendance status in the database.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as a controller for user-initiated event actions. It interacts with the `EventDAO` and `EventCustomFieldDAO` for data persistence and the `EventService` for more complex business logic.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO`, `EventCustomFieldDAO`, and `EventService`.\n    *   `EventDAO`: Used for simple sign-up and sign-off operations.\n    *   `EventCustomFieldDAO`: Used to save user responses to any custom fields on the sign-up form.\n    *   `EventService`: Used for the special case of signing off from a running event, which involves sending a notification.\n    *   `CSRFUtil`: Used to validate the CSRF token on every POST request.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** The main method that handles all POST requests.\n        *   **Logic:**\n            1.  **Security:** Validates the CSRF token.\n            2.  **Parameter Validation:** Ensures a user is logged in and that `action` and `eventId` parameters are present.\n            3.  **Action Routing:** It uses a `switch` statement on the `action` parameter to delegate to the appropriate handler method.\n            *   `\"signup\"`: Calls `eventDAO.signUpForEvent` and then iterates through any custom field parameters from the request, saving each response via `customFieldDAO.saveResponse`.\n            *   `\"signoff\"`: Calls `eventDAO.signOffFromEvent` for a simple sign-off.\n            *   `\"signOffWithReason\"`: This special case is for events that are already running. It retrieves the reason from the request and calls `eventService.signOffUserFromRunningEvent`, which handles both the database update and sending a notification to the event leader.\n            4.  **Feedback & Redirect:** Sets a success or error message in the session and redirects the user back to the main events page.'),
('src/main/java/de/technikteam/servlet/EventDetailsServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for preparing and displaying the detailed view of a single event. It fetches the core event data and aggregates all related information, such as assigned team members, tasks, attachments, and chat messages, before forwarding the data to the `eventDetails.jsp` page for rendering.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as the controller for the event details page. It coordinates multiple DAOs to assemble a complete, aggregated view of an event.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects all necessary DAOs (`EventDAO`, `EventTaskDAO`, `EventChatDAO`, etc.).\n    *   **DAOs**: Each DAO is used to fetch a specific piece of related data (e.g., `taskDAO.getTasksForEvent`, `attachmentDAO.getAttachmentsForParent`).\n    *   **Gson**: Used to serialize various data lists (like users, items, kits) into JSON for use by the client-side JavaScript on the page.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** Handles GET requests for the event details page.\n        *   **Logic:**\n            1.  **Authentication & Parameter Validation:** Ensures a user is logged in and that a valid `id` parameter is provided.\n            2.  **Fetch Core Event:** Retrieves the main `Event` object using `eventDAO.getEventById`.\n            3.  **Authorization:** Performs a crucial authorization check. A user can only view the details if they are a global admin, the event leader, or are associated with the event (either signed up or assigned). If the check fails, it sends an HTTP 403 (Forbidden) error.\n            4.  **Data Aggregation:** If authorized, it proceeds to fetch all related data from the various DAOs and sets it on the `event` model object. This includes attachments (filtered by the user''s role), skill requirements, reserved items, assigned attendees, and tasks.\n            5.  **Chat History:** If the event''s status is \"LAUFEND\", it fetches the chat history from `chatDAO`.\n            6.  **JSON Serialization:** It serializes data needed for client-side modals (like the list of assigned users and all available items/kits for the task editor) into JSON strings and places them in request attributes.\n            7.  **Forwarding:** It sets the fully populated `event` object as a request attribute and forwards to `eventDetails.jsp`.'),
('src/main/java/de/technikteam/servlet/EventServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the main \"Veranstaltungen\" (Events) page. Its primary role is to fetch a list of all upcoming and active events, determine the current user''s qualification and sign-up status for each, and then pass this enriched data to the `events.jsp` view for rendering.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for the public event listing. It interacts with the `EventDAO` to retrieve data and applies business logic to determine user-specific states for each event.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO`.\n    *   `EventDAO`: Used to fetch all upcoming events and the specific events a user is qualified for.\n    *   `User` (Model): The logged-in user object, retrieved from the session.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the main events page.\n        *   **Logic:**\n            1.  **Authentication:** Ensures a user is logged in.\n            2.  **Fetch All Events:** It retrieves a list of *all* active and upcoming events via `eventDAO.getAllActiveAndUpcomingEvents()`.\n            3.  **Fetch Qualified Events:** It makes a second, more complex call to `eventDAO.getUpcomingEventsForUser()`. This method returns only the events for which the current user meets the skill requirements and also includes their current sign-up status (`ANGEMELDET`, `ABGEMELDET`, or `OFFEN`).\n            4.  **Data Enrichment:** It iterates through the list of all events. For each event, it checks if its ID is present in the list of qualified events.\n                *   If it is, it sets the `isUserQualified` flag to `true` and copies the `userAttendanceStatus` to the event object.\n                *   If it is not, `isUserQualified` remains `false` (its default), which will cause the \"Anmelden\" button to be disabled in the JSP.\n            5.  **Forwarding:** It sets the final, enriched list of all upcoming events as a request attribute and forwards to `events.jsp`.'),
('src/main/java/de/technikteam/servlet/FeedbackServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles all user interactions with the feedback system. It serves two distinct purposes based on the `action` parameter: displaying the general feedback form and handling its submission, as well as managing the event-specific feedback workflow.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as a controller for both general and event-specific feedback. It interacts with the `FeedbackSubmissionDAO` for general feedback and the `EventFeedbackDAO` for event-specific feedback.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects `EventFeedbackDAO`, `FeedbackSubmissionDAO`, and `EventDAO`.\n    *   `FeedbackSubmissionDAO`: For creating general feedback entries.\n    *   `EventFeedbackDAO`: For creating event feedback forms and saving responses.\n    *   `EventDAO`: To get event details when creating an event feedback form.\n    *   `CSRFUtil`: For security validation on all POST requests.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(...)`**:\n        *   **Purpose:** Renders the appropriate feedback form.\n        *   **Logic:** It checks the `action` parameter.\n            *   If `action=submitEventFeedback`, it calls `showSubmitEventFeedbackForm()` to display the star rating form for a specific event.\n            *   Otherwise, it forwards to the `feedback.jsp` page for general feedback.\n\n    *   **`doPost(...)`**:\n        *   **Purpose:** Handles the submission of feedback forms.\n        *   **Logic:** After validating the CSRF token, it routes based on the `action` parameter.\n            *   `\"submitGeneralFeedback\"`: Calls `handleGeneralFeedback()`.\n            *   `\"submitEventFeedbackResponse\"`: Calls `handleEventFeedbackResponse()`.\n\n    *   **`handleGeneralFeedback(...)`**:\n        *   **Purpose:** Validates and saves a general feedback submission.\n        *   **Logic:** It retrieves the subject and content from the request, performs validation, creates a `FeedbackSubmission` object, and saves it using `submissionDAO`. It sets appropriate session messages and redirects.\n\n    *   **`handleEventFeedbackResponse(...)`**:\n        *   **Purpose:** Saves a user''s response to an event feedback form.\n        *   **Logic:** It parses the form ID, rating, and comments, creates a `FeedbackResponse` object, and saves it using `eventFeedbackDAO`. It then redirects the user to their profile page.\n\n    *   **`showSubmitEventFeedbackForm(...)`**:\n        *   **Purpose:** Prepares the data for the event-specific feedback form.\n        *   **Logic:**\n            1.  It retrieves the `Event` object.\n            2.  It checks if a `FeedbackForm` already exists for this event using `eventFeedbackDAO`. If not, it creates one.\n            3.  It checks if the user has already submitted feedback for this form. If so, it redirects them to their profile with an info message.\n            4.  Otherwise, it sets the `event` and `form` objects as request attributes and forwards to `feedback_form.jsp`.'),
('src/main/java/de/technikteam/servlet/FileServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for displaying the public-facing \"Dateien & Dokumente\" page. It fetches the list of files and categories that the currently logged-in user is authorized to see and forwards this data to the `dateien.jsp` view for rendering.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as the controller for the public file listing page. It interacts directly with the `FileDAO` to retrieve data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FileDAO`.\n    *   `FileDAO`: The DAO used to fetch the list of files, grouped by category.\n    *   `User` (Model): The user object from the session, used to determine which files should be visible.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/dateien` page.\n        *   **Logic:**\n            1.  Retrieves the `User` object from the session.\n            2.  Calls `fileDAO.getAllFilesGroupedByCategory(user)`. This DAO method contains the authorization logic to filter out admin-only files if the user is not an admin.\n            3.  Sets the resulting map of grouped files as a request attribute named `fileData`.\n            4.  Forwards the request to `views/public/dateien.jsp`.'),
('src/main/java/de/technikteam/servlet/HomeServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves as the controller for the user''s main dashboard or home page. It is responsible for fetching personalized data for the logged-in user, such as their upcoming assigned events, their open tasks, and other general upcoming events they might be interested in.\n\n2.  **Architectural Role**\n\n    This class is a key component of the **Web/Controller Tier**. It acts as the entry point for the user after logging in. It interacts with the `EventDAO` and `EventTaskDAO` to aggregate the data needed for the dashboard widgets.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO` and `EventTaskDAO`.\n    *   `EventDAO`: Used to fetch the user''s assigned events and general upcoming events.\n    *   `EventTaskDAO`: Used to fetch the user''s open tasks across all events.\n    *   `User` (Model): The user object from the session, whose ID is used in the DAO queries.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/home` page.\n        *   **Logic:**\n            1.  **Authentication Check:** A crucial defensive check ensures that a `User` object exists in the session. If not, it redirects to the login page.\n            2.  **Data Fetching:** It makes three separate calls to the DAOs:\n                *   `eventDAO.getAssignedEventsForUser()`: Gets the top 5 events the user is *assigned* to.\n                *   `eventTaskDAO.getOpenTasksForUser()`: Gets all open tasks assigned to the user.\n                *   `eventDAO.getUpcomingEventsForUser()`: Gets the top 5 general upcoming events for which the user is qualified but not necessarily assigned.\n            3.  **Forwarding:** It sets the three lists of data as request attributes (`assignedEvents`, `openTasks`, `upcomingEvents`) and forwards the request to `views/public/home.jsp`.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V18__Populate_wiki_data_part13.sql
========================================================================

-- Flyway migration V18, Part 13

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/IcalServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet generates an iCalendar (`.ics`) feed of all active and upcoming events and meetings. This allows users to subscribe to the application''s schedule using external calendar applications like Google Calendar, Outlook, or Apple Calendar.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as a specialized API endpoint that produces data in the iCalendar format instead of HTML or JSON. It interacts with the `EventDAO` and `MeetingDAO` to source its data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO` and `MeetingDAO`.\n    *   **iCal4j (`net.fortuna.ical4j.*`)**: The core third-party library used to programmatically build the iCalendar data structure.\n    *   `EventDAO`, `MeetingDAO`: Used to fetch all public calendar entries.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests to `/calendar.ics`.\n        *   **Logic:**\n            1.  **Initialize Calendar:** Creates a new iCal4j `Calendar` object and sets the standard `PRODID` and `VERSION` properties.\n            2.  **Fetch Events & Meetings:** Retrieves all active and upcoming events and meetings from the DAOs.\n            3.  **Create VEvents:** It iterates through both lists. For each `Event` and `Meeting`, it creates a `VEvent` component.\n            4.  **Populate VEvent Properties:** It populates each `VEvent` with standard iCalendar properties:\n                *   `UID`: A unique identifier for the event.\n                *   `DTSTART` / `DTEND`: The start and end times. It correctly converts the Java `LocalDateTime` to a `java.util.Date` required by iCal4j.\n                *   `SUMMARY`: The event/meeting title.\n                *   `DESCRIPTION`: The event/meeting description.\n                *   `LOCATION`: The event/meeting location.\n                *   `URL`: A direct link back to the event/meeting details page within the application.\n            5.  **Set Response Headers:** It sets the `Content-Type` to `text/calendar` and the `Content-Disposition` to `inline`, suggesting to the browser that it should be opened by a calendar application.\n            6.  **Output:** Uses a `CalendarOutputter` from iCal4j to write the fully constructed calendar object to the servlet''s response stream.'),
('src/main/java/de/technikteam/servlet/ImageServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for securely serving images stored in the `images` subdirectory of the main upload folder. It prevents direct access to the filesystem, performs authorization checks, and includes protection against path traversal attacks.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as a secure proxy for image files, ensuring that only authenticated users can access them and that they cannot request files outside the designated image directory.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `ConfigurationService`.\n    *   `ConfigurationService`: Provides the base path for file uploads.\n    *   `User` (Model): Retrieved from the session for authentication and logging purposes.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for images.\n        *   **Logic:**\n            1.  **Authentication:** Checks for a valid user session.\n            2.  **Parameter Validation:** Ensures the `file` parameter is present.\n            3.  **Path Traversal Protection:** This is the most critical security feature.\n                *   It constructs the canonical (absolute) path for both the base image directory and the requested file.\n                *   It then checks if the canonical path of the requested file *starts with* the canonical path of the base directory. If not, it means the user is trying to access a file outside the intended directory (e.g., using `../`), a path traversal attack.\n                *   In case of a detected attack, it logs a `FATAL` error and returns a 403 Forbidden error.\n            4.  **File Existence Check:** Verifies that the requested file exists and is not a directory.\n            5.  **Set Headers:** It determines the MIME type of the image (e.g., `image/jpeg`, `image/png`) and sets the `Content-Type`, `Content-Length`, and `Content-Disposition: inline` headers. `inline` suggests that the browser should display the image directly rather than prompting for a download.\n            6.  **Streaming:** It streams the file''s bytes from a `FileInputStream` to the response''s `OutputStream`.'),
('src/main/java/de/technikteam/servlet/LoginServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles the user authentication process. It serves the login page (`login.jsp`) for GET requests and processes login form submissions for POST requests. It includes logic for validating credentials, managing failed login attempts, and implementing an escalating lockout mechanism to thwart brute-force attacks.\n\n2.  **Architectural Role**\n\n    This class is a central part of the **Web/Controller Tier**. It is the main entry point for user authentication. It interacts directly with the `UserDAO` to validate credentials and manages the `HttpSession` to establish a logged-in state.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserDAO`.\n    *   `UserDAO`: Used to validate the username and password against the database.\n    *   `NavigationRegistry`: Used to build the user-specific navigation menu after a successful login.\n    *   `CSRFUtil`: Used to generate and store a new CSRF token in the session upon successful login.\n\n4.  **In-Depth Breakdown**\n\n    *   **`LoginAttemptManager` (Inner Class):**\n        *   **Purpose:** A static inner class that encapsulates all logic related to tracking and managing failed login attempts.\n        *   **`MAX_ATTEMPTS`**: The number of failed attempts before a lockout is triggered.\n        *   **`LOCKOUT_DURATIONS_MS`**: An array defining the escalating lockout durations in milliseconds for subsequent lockouts.\n        *   **`isLockedOut(String username)`**: Checks if a user is currently within a lockout period.\n        *   **`recordFailedLogin(String username)`**: Increments the failed attempt counter for a user. If the count reaches the maximum, it initiates a lockout.\n        *   **`clearLoginAttempts(String username)`**: Resets all attempt counters and lockout information for a user, typically after a successful login.\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** Processes the login form submission.\n        *   **Logic:**\n            1.  Retrieves `username` and `password` from the request.\n            2.  **Lockout Check:** First, it checks if the user is currently locked out using `LoginAttemptManager.isLockedOut()`. If so, it sets session attributes to inform the JSP and redirects back.\n            3.  **Credential Validation:** It calls `userDAO.validateUser()`.\n            4.  **Success Path:** If `validateUser` returns a `User` object, it means the login was successful.\n                *   It clears any previous failed login attempts for that user.\n                *   It invalidates the old session and creates a new one to prevent session fixation attacks.\n                *   It stores the `User` object in the new session.\n                *   It generates a new CSRF token.\n                *   It builds the user''s navigation menu and stores it in the session.\n                *   It redirects the user to the `/home` page.\n            5.  **Failure Path:** If `validateUser` returns `null`, the login failed.\n                *   It records the failed attempt using `LoginAttemptManager.recordFailedLogin()`.\n                *   It sets error messages and the failed username in the session for the JSP to display.\n                *   It redirects the user back to the `/login` page.\n\n    *   **`doGet(...)`**: Simply forwards the request to the `login.jsp` view.'),
('src/main/java/de/technikteam/servlet/LogoutServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles the user logout process. It invalidates the current user''s session, effectively logging them out, and then redirects them to the login page with a success message.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It is the dedicated endpoint for terminating a user''s authenticated session.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.http.HttpSession`)**: Used to access and invalidate the user''s session.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests to the `/logout` URL.\n        *   **Logic:**\n            1.  It retrieves the current `HttpSession` without creating a new one (`request.getSession(false)`).\n            2.  If a session exists, it logs which user is logging out and then calls `session.invalidate()`. This is the core action that removes all session attributes and effectively logs the user out.\n            3.  It then creates a *new* session (`request.getSession(true)`) to store a \"successMessage\" that can be displayed on the login page.\n            4.  Finally, it redirects the user to the `/login` page.'),
('src/main/java/de/technikteam/servlet/MarkdownEditorServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the real-time Markdown editor page. It is responsible for fetching the content of a specific Markdown file, performing authorization checks to determine if the user can view or edit the file, and then forwarding the data to the `admin_editor.jsp` view.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for the collaborative editor view. It interacts with the `FileDAO` to retrieve file metadata and content.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FileDAO` and `ConfigurationService`.\n    *   `FileDAO`: Used to get the file''s metadata and read its physical content.\n    *   `ConfigurationService`: Provides the base path to the upload directory.\n    *   `User` (Model): The user object from the session, used for authorization.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/editor` page.\n        *   **Logic:**\n            1.  **Authentication & Parameter Validation:** Ensures a user is logged in and that a valid `fileId` is provided.\n            2.  **Fetch File Metadata:** Retrieves the `File` object from the database using `fileDAO.getFileById()`.\n            3.  **Authorization:** It checks the user''s permissions (`FILE_UPDATE` or `ACCESS_ADMIN_PANEL` for editing, `FILE_READ` for viewing). Based on the check, it sets an `editorMode` attribute (\"edit\" or \"view\") for the JSP. If the user has neither permission, it returns a 403 Forbidden error.\n            4.  **Fetch File Content:** It reads the physical file''s content from the disk using the path stored in the `dbFile` object. It includes error handling for cases where the file is in the database but missing from the disk.\n            5.  **Forwarding:** It sets the `file` object and its `fileContent` as request attributes and forwards to `admin_editor.jsp`.'),
('src/main/java/de/technikteam/servlet/MeetingActionServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet handles user actions related to meetings, specifically signing up for and signing off from a meeting. It processes POST requests from the public meetings list page (`lehrgaenge.jsp`).\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for user-initiated meeting attendance changes. It interacts directly with the `MeetingAttendanceDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `MeetingAttendanceDAO`.\n    *   `MeetingAttendanceDAO`: The DAO used to update the user''s attendance status.\n    *   `CSRFUtil`: Used for security validation.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles POST requests for meeting actions.\n        *   **Logic:**\n            1.  **Security & Validation:** It validates the CSRF token and ensures a user is logged in and that `action` and `meetingId` parameters are present.\n            2.  **Action Handling:**\n                *   If `action` is `\"signup\"`, it calls `attendanceDAO.setAttendance()` with `attended=true`.\n                *   If `action` is `\"signoff\"`, it calls `attendanceDAO.setAttendance()` with `attended=false`.\n            3.  **Feedback & Redirect:** It sets a success message in the session and redirects the user back to the `/lehrgaenge` page.'),
('src/main/java/de/technikteam/servlet/MeetingDetailsServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for preparing and displaying the detailed view of a single meeting. It fetches the meeting''s data and its associated file attachments, performs an authorization check, and forwards the information to the `meetingDetails.jsp` view.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for the meeting details page. It interacts with the `MeetingDAO` and `AttachmentDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `MeetingDAO` and `AttachmentDAO`.\n    *   `MeetingDAO`: Used to fetch the core meeting data and check for user association.\n    *   `AttachmentDAO`: Used to fetch attachments specific to this meeting.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the meeting details page.\n        *   **Logic:**\n            1.  **Authentication & Validation:** Ensures a user is logged in and a valid `id` parameter is present.\n            2.  **Fetch Meeting Data:** Retrieves the `Meeting` object from the DAO.\n            3.  **Authorization:** A user is authorized to view the details if they are an admin, the meeting leader, or a participant. If not, it sends a 403 Forbidden error.\n            4.  **Fetch Attachments:** It calls `attachmentDAO.getAttachmentsForParent()`, passing \"MEETING\" as the type and filtering by the user''s role to determine which attachments should be visible.\n            5.  **Forwarding:** Sets the `meeting` and `attachments` as request attributes and forwards to `meetingDetails.jsp`.'),
('src/main/java/de/technikteam/servlet/MeetingServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the main \"Lehrgänge\" (Courses/Meetings) page. It fetches the list of all upcoming meetings and determines the current user''s sign-up status for each one.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as the controller for the public listing of schedulable meetings. It interacts directly with the `MeetingDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `MeetingDAO`.\n    *   `MeetingDAO`: Used to fetch the upcoming meetings and the user''s status for each.\n    *   `User` (Model): The user object from the session, used to get user-specific data.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/lehrgaenge` page.\n        *   **Logic:**\n            1.  Retrieves the logged-in `User`.\n            2.  Calls `meetingDAO.getUpcomingMeetingsForUser(user)`. This single DAO call efficiently retrieves all upcoming meetings and, through a `LEFT JOIN`, also fetches the user''s attendance status (`ANGEMELDET`, `ABGEMELDET`, or `OFFEN`) for each.\n            3.  Sets the resulting list of `Meeting` objects as a request attribute.\n            4.  Forwards the request to `views/public/lehrgaenge.jsp`.'),
('src/main/java/de/technikteam/servlet/MyFeedbackServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the \"Mein Feedback\" page, which allows users to view the status of their own previously submitted feedback. It fetches all submissions made by the currently logged-in user.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for a user''s personal feedback history view. It interacts directly with the `FeedbackSubmissionDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `FeedbackSubmissionDAO`.\n    *   `FeedbackSubmissionDAO`: The DAO used to retrieve submissions by user ID.\n    *   `User` (Model): The user object from the session.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/my-feedback` page.\n        *   **Logic:**\n            1.  Ensures a user is logged in.\n            2.  Calls `submissionDAO.getSubmissionsByUserId()` using the logged-in user''s ID.\n            3.  Sets the resulting list of `FeedbackSubmission` objects as a request attribute.\n            4.  Forwards the request to `views/public/my_feedback.jsp`.'),
('src/main/java/de/technikteam/servlet/NotificationServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is the client-facing endpoint for establishing a Server-Sent Events (SSE) connection. Authenticated clients connect to this servlet to receive real-time push notifications from the server. This servlet''s only job is to register the client''s connection with the `NotificationService`.\n\n2.  **Architectural Role**\n\n    This is a specialized controller in the **Web/Controller Tier**. It handles the initial setup of the long-lived HTTP connection required for SSE. All subsequent communication is managed by the `NotificationService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `NotificationService`: The singleton service where the client connection is registered.\n    *   **Jakarta Servlet API (`AsyncContext`)**: The underlying mechanism used to keep the connection open asynchronously.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests to `/notifications`.\n        *   **Logic:**\n            1.  **Authentication:** It ensures a user is logged in. Unauthorized requests are rejected.\n            2.  **Set SSE Headers:** It sets the necessary HTTP headers for an SSE connection: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, and `Connection: keep-alive`.\n            3.  **Register with Service:** It calls `NotificationService.getInstance().register(request)`. This call is the core of the servlet; it starts an `AsyncContext`, effectively handing off the connection to the `NotificationService` to be managed for the duration of the SSE session.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V19__Populate_wiki_data_part14.sql
========================================================================

-- Flyway migration V19, Part 14

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/servlet/PackKitServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet generates a printable \"packing list\" page for a specific inventory kit. It is designed to be accessed via a QR code, providing a simple, mobile-friendly checklist of items that belong in a particular case or kit.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as a controller for a read-only, utility view. It interacts directly with the `InventoryKitDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `InventoryKitDAO`.\n    *   `InventoryKitDAO`: Used to fetch the kit''s details and its list of required items.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/pack-kit` URL.\n        *   **Logic:**\n            1.  **Parameter Validation:** It requires a `kitId` parameter.\n            2.  **Data Fetching:**\n                *   It retrieves the main `InventoryKit` object (for its name and description) using `kitDAO.getKitById()`.\n                *   It retrieves the list of `InventoryKitItem`s for that kit using `kitDAO.getItemsForKit()`.\n            3.  **Forwarding:** It sets the `kit` and `kitItems` as request attributes and forwards to `views/public/pack_kit.jsp`. This JSP is styled for a clean, printable view and has the main navigation hidden.'),
('src/main/java/de/technikteam/servlet/PasswordServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet manages the process for a logged-in user to change their own password. It handles rendering the password change form for GET requests and processes the form submission for POST requests, including validation of the current password, new password confirmation, and adherence to the password policy.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It is a self-contained controller for a specific user action. It interacts with the `UserDAO` for credential validation and updates, and uses the `PasswordPolicyValidator` for business logic.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `UserDAO`.\n    *   `UserDAO`: Used to validate the user''s current password and to save the new hashed password.\n    *   `PasswordPolicyValidator`: A utility class that enforces complexity requirements for new passwords.\n    *   `CSRFUtil`: Used to validate the CSRF token on the POST request.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(...)`**: Simply forwards the request to the `passwort.jsp` view, which contains the password change form.\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** Processes the password change form submission.\n        *   **Logic:**\n            1.  **Authentication & Security:** Ensures a user is logged in and validates the CSRF token.\n            2.  **Parameter Retrieval:** Gets the `currentPassword`, `newPassword`, and `confirmPassword` from the request.\n            3.  **Current Password Validation:** It calls `userDAO.validateUser()` with the current user''s name and the provided `currentPassword`. If this fails, it sets an error message and redirects back.\n            4.  **Confirmation Check:** It verifies that `newPassword` and `confirmPassword` are identical.\n            5.  **Policy Validation:** It calls `PasswordPolicyValidator.validate()` on the `newPassword`. If the new password does not meet the complexity requirements, it sets an error message with the specific reason and redirects.\n            6.  **Database Update:** If all checks pass, it calls `userDAO.changePassword()` to hash and save the new password.\n            7.  **Feedback & Redirect:** It sets a success or error message in the session and redirects the user back to the `/passwort` page.'),
('src/main/java/de/technikteam/servlet/ProfileServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves as the controller for the \"Mein Profil\" (My Profile) page. For GET requests, it aggregates and displays a comprehensive overview of the logged-in user''s data, including their profile information, event history, qualifications, achievements, and registered passkeys. For POST requests, it handles various profile-related actions like submitting a profile change request or deleting a passkey.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as a central hub for user-specific data display and modification. It interacts with a wide range of DAOs to collect the necessary information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects `EventDAO`, `UserQualificationsDAO`, `UserDAO`, `AchievementDAO`, `PasskeyDAO`, and `ProfileChangeRequestDAO`.\n    *   **DAOs**: Each DAO is used to fetch a specific slice of the user''s data.\n    *   **Gson**: Used to serialize the JSON payload for the profile change request.\n    *   `CSRFUtil`: For validating all POST actions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(...)`**:\n        *   **Purpose:** Gathers all data for the profile page.\n        *   **Logic:** It makes calls to multiple DAOs (`eventDAO.getEventHistoryForUser`, `qualificationsDAO.getQualificationsForUser`, etc.) to fetch all the different pieces of information. It also checks if the user has an outstanding change request using `requestDAO.hasPendingRequest()`. All retrieved data is set as request attributes before forwarding to `profile.jsp`.\n\n    *   **`doPost(...)`**:\n        *   **Purpose:** Handles various actions submitted from the profile page.\n        *   **Logic:** After validating the CSRF token, it uses a `switch` statement on the `action` parameter to route to the appropriate handler method.\n\n    *   **`handleDeletePasskey(...)`**: Deletes a user''s passkey credential after they confirm the action.\n\n    *   **`handleUpdateChatColor(...)`**: Updates the user''s preferred chat color in the database and in their current session object.\n\n    *   **`handleProfileChangeRequest(...)`**:\n        *   **Purpose:** Handles the submission of a profile data change request from the user. This is an AJAX endpoint.\n        *   **Logic:**\n            1.  It compares the submitted form values (`email`, `classYear`, `className`) with the values in the current user''s session object.\n            2.  It builds a `Map` containing only the fields that have actually changed.\n            3.  If there are no changes, it returns an error response.\n            4.  If there are changes, it serializes the `Map` to a JSON string.\n            5.  It creates a new `ProfileChangeRequest` object, sets the JSON string as the `requestedChanges`, and saves it to the database via the `requestDAO`.\n            6.  It returns a JSON `ApiResponse` indicating success or failure.'),
('src/main/java/de/technikteam/servlet/RootServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is mapped to the root URL (`/`) of the application. Its sole purpose is to act as a router, directing users to the appropriate starting page based on their authentication status.\n\n2.  **Architectural Role**\n\n    This is a simple entry point in the **Web/Controller Tier**. It ensures users landing on the base URL are sent to either the login page or their dashboard, preventing them from seeing a blank or error page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API**: The base `HttpServlet` class.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles all GET requests to the application''s root context.\n        *   **Logic:**\n            1.  It checks the `HttpSession` for a `User` object.\n            2.  If a `User` object exists (the user is logged in), it sends a redirect to the `/home` servlet.\n            3.  If no `User` object exists (the user is not logged in), it sends a redirect to the `/login` servlet.'),
('src/main/java/de/technikteam/servlet/StorageItemActionServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the dedicated \"QR Action\" page, which is designed to be accessed by scanning a QR code associated with an inventory item. It provides a simplified, mobile-friendly interface for performing a quick check-in or check-out transaction for a specific item.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as the controller for the QR code landing page. It interacts with the `StorageDAO` and `EventDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `StorageDAO` and `EventDAO`.\n    *   `StorageDAO`: To fetch the details of the specific item.\n    *   `EventDAO`: To fetch a list of active events to populate the \"assign to event\" dropdown.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests, typically from a QR code scan.\n        *   **Logic:**\n            1.  **Parameter Validation:** It requires an `id` parameter identifying the storage item.\n            2.  **Data Fetching:**\n                *   It retrieves the full `StorageItem` object using `storageDAO.getItemById()`.\n                *   It fetches all currently active events using `eventDAO.getActiveEvents()`.\n            3.  **Error Handling:** If the item ID is invalid or the item is not found, it sends an appropriate HTTP error.\n            4.  **Forwarding:** It sets the `item` and `activeEvents` as request attributes and forwards to `views/public/qr_action.jsp`. This JSP has a simplified layout without the main navigation, optimized for quick actions on a mobile device.'),
('src/main/java/de/technikteam/servlet/StorageItemDetailsServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet is responsible for displaying the detailed information page for a single inventory item. It aggregates the item''s core data, its transaction history, and its maintenance history into a single view.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It acts as the controller for the item details page. It coordinates calls to `StorageDAO`, `StorageLogDAO`, and `MaintenanceLogDAO` to build a complete picture of the item.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the three DAOs responsible for storage data.\n    *   `StorageDAO`: To fetch the main `StorageItem` object.\n    *   `StorageLogDAO`: To fetch the item''s checkout/checkin history.\n    *   `MaintenanceLogDAO`: To fetch the item''s repair/maintenance history.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the item details page.\n        *   **Logic:**\n            1.  **Parameter Validation:** It validates that a numerical `id` parameter is present.\n            2.  **Data Fetching:** It makes three separate DAO calls:\n                *   `storageDAO.getItemById()` to get the core item details.\n                *   `storageLogDAO.getHistoryForItem()` to get the transaction log.\n                *   `maintenanceLogDAO.getHistoryForItem()` to get the maintenance log.\n            3.  **Error Handling:** If the item is not found, it sends an HTTP 404 error.\n            4.  **Forwarding:** It sets the `item`, `history`, and `maintenanceHistory` as request attributes and forwards the request to `views/public/storage_item_details.jsp`.'),
('src/main/java/de/technikteam/servlet/StorageServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves the main public-facing \"Lager\" (Inventory) page. Its job is to fetch all inventory items, grouped by their physical location, and prepare the data for display in the `lager.jsp` view.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as the controller for the main inventory overview page. It interacts with the `StorageDAO` and `EventDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `StorageDAO` and `EventDAO`.\n    *   `StorageDAO`: Used to fetch all inventory items, grouped by location.\n    *   `EventDAO`: Used to fetch a list of active events to populate the dropdown in the transaction modal.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doGet(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles GET requests for the `/lager` page.\n        *   **Logic:**\n            1.  It calls `storageDAO.getAllItemsGroupedByLocation()` to retrieve all storage items, pre-organized into a `Map` where keys are location names and values are lists of items in that location.\n            2.  It calls `eventDAO.getActiveEvents()` to get a list of events that can be associated with a transaction.\n            3.  It sets both the `storageData` map and the `activeEvents` list as request attributes.\n            4.  It forwards the request to `views/public/lager.jsp`.'),
('src/main/java/de/technikteam/servlet/StorageTransactionServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet processes inventory transaction requests (check-ins and check-outs) submitted from the public inventory page (`lager.jsp`) or the QR action page (`qr_action.jsp`). It acts as the endpoint for these state-changing operations, delegating the complex transactional logic to the `StorageService`.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It receives form data, performs basic validation, and then calls the **Service Tier** (`StorageService`) to execute the core business logic. It should not contain any transaction management or complex logic itself.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `StorageService`.\n    *   `StorageService`: The service that handles the transactional logic of checking items in or out.\n    *   `CSRFUtil`: Used for security validation on the POST request.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**\n        *   **Purpose:** Handles POST requests to perform a storage transaction.\n        *   **Logic:**\n            1.  **Security & Validation:** It validates the CSRF token and retrieves the logged-in `User` from the session.\n            2.  **Parameter Parsing:** It parses all necessary parameters from the request: `itemId`, `quantity`, `type` (\"checkout\" or \"checkin\"), `notes`, and the optional `eventId`.\n            3.  **Service Call:** It calls `storageService.processTransaction()` with the parsed parameters. This single method call handles the entire transactional operation.\n            4.  **Feedback & Redirect:** Based on the boolean result from the service call, it sets either a `successMessage` or an `errorMessage` in the user''s session.\n            5.  It then redirects the user back to their original page (either `/lager` or the QR action page, determined by the `redirectUrl` parameter).'),
('src/main/java/de/technikteam/servlet/TaskActionServlet.java', '1.  **File Overview & Purpose**\n\n    This servlet serves as a dedicated controller for all actions related to event tasks. It handles a variety of POST requests for creating, updating, deleting, and changing the status of tasks, as well as user-specific actions like claiming or un-claiming a task.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Web/Controller Tier**. It acts as a command handler for task-related operations, primarily receiving requests from the `eventDetails.jsp` page. It coordinates between user actions and the `EventTaskDAO`, and performs necessary authorization checks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventTaskDAO`, `EventDAO`, and `AdminLogService`.\n    *   `EventTaskDAO`: The primary DAO for all task-related database operations.\n    *   `EventDAO`: Used to fetch event details for authorization checks (e.g., to verify if the current user is the event leader).\n    *   `AdminLogService`: To log administrative actions like creating or deleting tasks.\n    *   `CSRFUtil`: For security validation on all POST requests.\n\n4.  **In-Depth Breakdown**\n\n    *   **`doPost(HttpServletRequest request, HttpServletResponse response)`**:\n        *   **Purpose:** The main entry point that routes requests based on the `action` parameter.\n        *   **Logic:** After authenticating the user and validating the CSRF token, it uses a `switch` statement to delegate to the appropriate handler method (`handleSaveTask`, `handleDeleteTask`, etc.).\n\n    *   **`handleSaveTask(...)`**:\n        *   **Purpose:** Handles both creation and updating of a task.\n        *   **Logic:**\n            1.  Performs an authorization check: only an admin or the event leader can save a task.\n            2.  It constructs an `EventTask` object from the request parameters.\n            3.  It determines if it''s a create or update based on the presence of a `taskId`.\n            4.  It collects arrays of associated data (assigned user IDs, required item IDs, etc.) from the request.\n            5.  It calls the transactional `taskDAO.saveTask()` method, which handles saving the task and all its relationships.\n            6.  Logs the action and sets a session message before redirecting back to the event details page.\n\n    *   **`handleDeleteTask(...)`**:\n        *   **Purpose:** Deletes a task.\n        *   **Logic:** Performs an authorization check (admin or event leader), then calls `taskDAO.deleteTask()`, logs the action, sets a session message, and redirects.\n\n    *   **`handleUserTaskAction(...)`**:\n        *   **Purpose:** Handles actions that a regular participant can perform on a task.\n        *   **Logic:**\n            *   For `updateStatus` (e.g., marking as \"ERLEDIGT\"), it checks if the user is an admin, the leader, or an assignee of the task.\n            *   For `claim` and `unclaim`, it checks if the user is a participant in the event.\n            *   It then calls the appropriate `EventTaskDAO` method to perform the action.'),
('src/main/java/de/technikteam/util/CSRFUtil.java', '1.  **File Overview & Purpose**\n\n    This is a critical security utility class that provides methods to protect the application against Cross-Site Request Forgery (CSRF) attacks. It implements the synchronizer token pattern by generating a secure, random token, storing it in the user''s session, and providing a method to validate that incoming state-changing requests include this same token.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Security/Utility** component. It is used throughout the **Web/Controller Tier**. The `storeToken` method is called by the `LoginServlet`, and the `isTokenValid` method is called at the beginning of the `doPost` method of nearly every servlet that handles form submissions.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.security.SecureRandom`: Used to generate cryptographically strong random bytes for the token.\n    *   `java.util.Base64`: Used to encode the random bytes into a URL-safe string.\n\n4.  **In-Depth Breakdown**\n\n    *   **`storeToken(HttpSession session)`**:\n        *   **Purpose:** Generates a new CSRF token and saves it in the user''s session.\n        *   **Logic:** It calls the private `generateToken()` method and sets the result as a session attribute with the key `\"csrfToken\"`. This should be called upon successful login to establish the initial token.\n\n    *   **`generateToken()`**:\n        *   **Purpose:** A private helper to create a secure, random token.\n        *   **Logic:** It uses `SecureRandom` to generate 32 random bytes and then Base64-encodes them into a URL-safe, padding-free string.\n\n    *   **`isTokenValid(HttpServletRequest request)`**:\n        *   **Purpose:** The main validation method. It compares the token submitted in a request parameter with the token stored in the session.\n        *   **Logic:** It retrieves the token from the session and the token from the request parameter named `\"csrfToken\"`. It performs null/empty checks and then uses `Objects.equals()` for a timing-attack-safe comparison. It returns `true` only if both tokens exist and are identical.\n\n    *   **`getCsrfInputField(HttpSession session)`**: A utility method intended for use in JSPs (though the project uses direct EL `$${sessionScope.csrfToken}` instead). It generates the complete `<input type=\"hidden\" ...>` HTML tag needed in forms.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V1__Create_core_tables.sql
========================================================================

-- Flyway migration V1: Create all tables without constraints.

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
START TRANSACTION;
SET time_zone = "+00:00";

-- ===================================================================
-- CREATE ALL TABLES
-- ===================================================================

CREATE TABLE `achievements` (
  `id` int(11) NOT NULL,
  `achievement_key` varchar(50) NOT NULL,
  `name` varchar(100) NOT NULL,
  `description` text DEFAULT NULL,
  `icon_class` varchar(50) DEFAULT 'fa-award'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `admin_logs` (
  `id` int(11) NOT NULL,
  `admin_username` varchar(50) DEFAULT NULL,
  `action_type` varchar(255) DEFAULT NULL,
  `details` text DEFAULT NULL,
  `action_timestamp` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `attachments` (
  `id` int(11) NOT NULL,
  `parent_type` enum('EVENT','MEETING') NOT NULL,
  `parent_id` int(11) NOT NULL,
  `filename` varchar(255) NOT NULL,
  `filepath` varchar(255) NOT NULL,
  `required_role` enum('NUTZER','ADMIN') NOT NULL DEFAULT 'NUTZER',
  `uploaded_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `courses` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `abbreviation` varchar(20) DEFAULT NULL,
  `description` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `course_attendance` (
  `user_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `signup_status` enum('ANGEMELDET','ABGEMELDET') NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `events` (
  `id` int(11) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `event_datetime` datetime NOT NULL,
  `end_datetime` datetime DEFAULT NULL,
  `description` text DEFAULT NULL,
  `location` varchar(255) DEFAULT NULL,
  `status` enum('GEPLANT','KOMPLETT','LAUFEND','ABGESCHLOSSEN','ABGESAGT') NOT NULL DEFAULT 'GEPLANT',
  `leader_user_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_assignments` (
  `assignment_id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_attendance` (
  `user_id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `signup_status` enum('ANGEMELDET','ABGEMELDET') NOT NULL,
  `commitment_status` enum('BESTÄTIGT','OFFEN','ZUGESAGT') NOT NULL DEFAULT 'OFFEN'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_chat_messages` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `username` varchar(255) DEFAULT NULL,
  `message_text` text DEFAULT NULL,
  `edited` tinyint(1) NOT NULL DEFAULT 0,
  `is_deleted` tinyint(1) NOT NULL DEFAULT 0,
  `deleted_by_user_id` int(11) DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  `deleted_by_username` varchar(255) DEFAULT NULL,
  `sent_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_custom_fields` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `field_name` varchar(255) DEFAULT NULL,
  `field_type` enum('TEXT','BOOLEAN','DROPDOWN','CHECKBOX_GROUP') NOT NULL,
  `is_required` tinyint(1) NOT NULL DEFAULT 0,
  `field_options` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_custom_field_responses` (
  `id` int(11) NOT NULL,
  `field_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `response_value` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_skill_requirements` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `required_course_id` int(11) NOT NULL,
  `required_persons` int(11) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_storage_reservations` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `item_id` int(11) NOT NULL,
  `reserved_quantity` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_tasks` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `description` text NOT NULL,
  `status` varchar(20) NOT NULL DEFAULT 'OFFEN',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `display_order` int(11) NOT NULL DEFAULT 0,
  `required_persons` int(11) NOT NULL DEFAULT 0,
  `details` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_task_assignments` (
  `task_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_task_kits` (
  `task_id` int(11) NOT NULL,
  `kit_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `event_task_storage_items` (
  `task_id` int(11) NOT NULL,
  `item_id` int(11) NOT NULL,
  `quantity` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `feedback_forms` (
  `id` int(11) NOT NULL,
  `event_id` int(11) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `created_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `feedback_responses` (
  `id` int(11) NOT NULL,
  `form_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `rating` int(11) NOT NULL COMMENT 'e.g., 1 to 5 stars',
  `comments` text DEFAULT NULL,
  `submitted_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `feedback_submissions` (
  `id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `subject` varchar(255) NOT NULL,
  `display_title` varchar(255) DEFAULT NULL,
  `content` text NOT NULL,
  `submitted_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `status` enum('NEW','VIEWED','PLANNED','REJECTED','COMPLETED') NOT NULL DEFAULT 'NEW',
  `display_order` int(11) NOT NULL DEFAULT 0
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `files` (
  `id` int(11) NOT NULL,
  `filename` varchar(255) DEFAULT NULL,
  `filepath` varchar(512) DEFAULT NULL,
  `category_id` int(11) DEFAULT NULL,
  `required_role` varchar(20) DEFAULT NULL,
  `uploaded_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `file_categories` (
  `id` int(11) NOT NULL,
  `name` varchar(100) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `inventory_kits` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `description` text DEFAULT NULL,
  `location` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `inventory_kit_items` (
  `kit_id` int(11) NOT NULL,
  `item_id` int(11) NOT NULL,
  `quantity` int(11) NOT NULL DEFAULT 1
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `login_attempts` (
  `username` varchar(50) NOT NULL,
  `attempts` int(11) NOT NULL DEFAULT 0,
  `last_attempt` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `maintenance_log` (
  `id` int(11) NOT NULL,
  `item_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `log_date` timestamp NOT NULL DEFAULT current_timestamp(),
  `action` varchar(255) DEFAULT NULL,
  `notes` text DEFAULT NULL,
  `cost` decimal(10,2) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `meetings` (
  `id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `meeting_datetime` datetime NOT NULL,
  `end_datetime` datetime DEFAULT NULL,
  `leader_user_id` int(11) DEFAULT NULL,
  `description` text DEFAULT NULL,
  `location` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `meeting_attendance` (
  `user_id` int(11) NOT NULL,
  `meeting_id` int(11) NOT NULL,
  `attended` tinyint(1) DEFAULT 0,
  `remarks` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `permissions` (
  `id` int(11) NOT NULL,
  `permission_key` varchar(100) NOT NULL COMMENT 'e.g., USER_CREATE, EVENT_DELETE',
  `description` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `profile_change_requests` (
  `id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `requested_changes` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL CHECK (json_valid(`requested_changes`)),
  `status` enum('PENDING','APPROVED','DENIED') NOT NULL DEFAULT 'PENDING',
  `requested_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `reviewed_by_admin_id` int(11) DEFAULT NULL,
  `reviewed_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `roles` (
  `id` int(11) NOT NULL,
  `role_name` varchar(50) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `shared_documents` (
  `id` int(11) NOT NULL,
  `document_name` varchar(100) NOT NULL,
  `content` text DEFAULT NULL,
  `last_modified` timestamp NOT NULL DEFAULT current_timestamp() ON UPDATE current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `storage_items` (
  `id` int(11) NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `location` varchar(50) DEFAULT NULL,
  `cabinet` varchar(50) DEFAULT NULL,
  `compartment` varchar(50) DEFAULT NULL,
  `quantity` int(11) NOT NULL DEFAULT 1,
  `max_quantity` int(11) NOT NULL DEFAULT 0,
  `defective_quantity` int(11) NOT NULL DEFAULT 0,
  `defect_reason` text DEFAULT NULL,
  `weight_kg` decimal(10,2) DEFAULT NULL,
  `price_eur` decimal(10,2) DEFAULT NULL,
  `image_path` varchar(512) DEFAULT NULL,
  `status` enum('IN_STORAGE','CHECKED_OUT','ASSIGNED_TO_EVENT','MAINTENANCE') NOT NULL DEFAULT 'IN_STORAGE',
  `current_holder_user_id` int(11) DEFAULT NULL,
  `assigned_event_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `storage_log` (
  `id` int(11) NOT NULL,
  `item_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `quantity_change` int(11) NOT NULL,
  `notes` text DEFAULT NULL,
  `event_id` int(11) DEFAULT NULL,
  `transaction_timestamp` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `todo_categories` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `name` VARCHAR(255) NOT NULL,
    `display_order` INT NOT NULL,
    `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `todo_tasks` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `category_id` INT NOT NULL,
    `content` TEXT NOT NULL,
    `is_completed` BOOLEAN NOT NULL DEFAULT FALSE,
    `display_order` INT NOT NULL,
    `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `users` (
  `id` int(11) NOT NULL,
  `username` varchar(50) DEFAULT NULL,
  `password_hash` varchar(255) DEFAULT NULL,
  `role_id` int(11) DEFAULT NULL,
  `class_year` int(11) DEFAULT NULL,
  `class_name` varchar(10) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `chat_color` varchar(7) DEFAULT '#E9ECEF',
  `created_at` timestamp NOT NULL DEFAULT current_timestamp(),
  `theme` varchar(10) DEFAULT 'light'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `user_achievements` (
  `user_id` int(11) NOT NULL,
  `achievement_id` int(11) NOT NULL,
  `earned_at` timestamp NOT NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `user_passkeys` (
  `id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `credential_id` text NOT NULL,
  `public_key` text NOT NULL,
  `signature_count` bigint(20) NOT NULL,
  `user_handle` text NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT current_timestamp()
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `user_permissions` (
  `user_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `user_qualifications` (
  `user_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `completion_date` date DEFAULT NULL,
  `status` enum('BESUCHT','ABSOLVIERT', 'BESTANDEN', 'NICHT BESUCHT') NOT NULL DEFAULT 'BESUCHT',
  `remarks` text DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `wiki_documentation` (
  `id` int(11) NOT NULL,
  `file_path` varchar(512) NOT NULL,
  `content` longtext DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V20__Populate_wiki_data_part15.sql
========================================================================

-- Flyway migration V20, Part 15: Populate the wiki with the final set of documentation.

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/util/DaoUtils.java', '1.  **File Overview & Purpose**\n\n    This is a small utility class that provides common helper methods for DAO classes. Its purpose is to encapsulate reusable database-related logic, reducing code duplication across the DAO layer.\n\n2.  **Architectural Role**\n\n    This is a utility class for the **DAO (Data Access) Tier**.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.sql.ResultSet`: The JDBC class it operates on.\n\n4.  **In-Depth Breakdown**\n\n    *   **`hasColumn(ResultSet rs, String columnName)`**\n        *   **Method Signature:** `public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException`\n        *   **Purpose:** Safely checks if a given `ResultSet` contains a column with a specific name, ignoring case.\n        *   **Logic:** It retrieves the `ResultSetMetaData`, iterates through all columns, and compares the provided `columnName` with each column''s name in a case-insensitive manner.\n        *   **Use Case:** This is extremely useful in DAOs that perform complex JOINs where a column might be present in some results but not others (e.g., `holder_username` in `StorageDAO`). Using this check before calling `rs.getString(\"columnName\")` prevents a `SQLException` if the column doesn''t exist for a particular row.'),
('src/main/java/de/technikteam/util/MarkdownUtil.java', '1.  **File Overview & Purpose**\n\n    This is a security utility class designed to sanitize user-provided Markdown content. It strips out potentially dangerous HTML tags and attributes (like `<script>` tags and `onclick` handlers) to prevent Cross-Site Scripting (XSS) vulnerabilities before the content is stored or rendered.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Security/Utility** component. It is used in the **Web/Controller Tier** (specifically in WebSocket endpoints like `DocumentEditorSocket` and `EventChatSocket`) to clean user input before it is broadcast to other clients or saved.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.regex.Pattern`: The core Java class for regular expressions, used to define the sanitization rules.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Patterns:**\n        *   `SCRIPT_PATTERN`: Matches and removes entire `<script>...</script>` blocks.\n        *   `ON_ATTRIBUTE_PATTERN`: Matches and removes any HTML attribute that starts with \"on\" (e.g., `onclick`, `onmouseover`).\n        *   `JAVASCRIPT_URI_PATTERN`: Matches and neutralizes `href` or `src` attributes that use the `javascript:` pseudo-protocol.\n    *   **`sanitize(String markdown)`**\n        *   **Method Signature:** `public static String sanitize(String markdown)`\n        *   **Purpose:** Applies a series of regular expression replacements to remove malicious content from a string.\n        *   **Parameters:**\n            *   `markdown` (String): The raw, potentially unsafe, user-submitted string.\n        *   **Returns:** A sanitized version of the string, safe for rendering in an HTML context (after being processed by a Markdown parser).\n        *   **Side Effects:** None.'),
('src/main/java/de/technikteam/util/NavigationRegistry.java', '1.  **File Overview & Purpose**\n\n    This class serves as a centralized, static registry for all navigation links in the application''s sidebar. It defines the complete set of possible navigation items and provides a single method to generate a user-specific list of links based on their assigned permissions. This approach ensures a single source of truth for the site''s navigation structure and access control.\n\n2.  **Architectural Role**\n\n    This is a **Configuration/Utility** class that primarily supports the **Web/Controller Tier**. It is called by the `LoginServlet` to populate the user''s session with their authorized navigation menu, which is then rendered by `main_header.jspf` on every page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `Permissions`: The class containing all permission key constants.\n    *   `NavigationItem` (Model): The object used to represent each link.\n    *   `User` (Model): The user object, which contains the permissions used for filtering.\n\n4.  **In-Depth Breakdown**\n\n    *   **`ALL_ITEMS` (static List)**: A static list that is initialized once with `NavigationItem` objects for every possible link in the application, for both the user and admin sections. Each item is defined with its label, URL, icon, and the required permission key. Links available to all authenticated users have a `null` permission.\n    *   **`getNavigationItemsForUser(User user)`**\n        *   **Method Signature:** `public static List<NavigationItem> getNavigationItemsForUser(User user)`\n        *   **Purpose:** To filter the master `ALL_ITEMS` list down to only those items the provided user is authorized to see.\n        *   **Parameters:**\n            *   `user` (User): The currently logged-in user.\n        *   **Returns:** A `List` of `NavigationItem` objects that should be rendered in the sidebar for that user.\n        *   **Logic:** It uses a Java Stream to filter `ALL_ITEMS`. An item is included if:\n            1.  Its required permission is `null` (it''s a public link for logged-in users).\n            2.  The user has the master `ACCESS_ADMIN_PANEL` permission.\n            3.  The user has the specific permission required by the item.\n            4.  It handles special cases like `ADMIN_DASHBOARD_ACCESS` and `ACHIEVEMENT_VIEW`, which are meta-permissions that depend on the user having *any* other relevant admin permission.'),
('src/main/java/de/technikteam/util/PasswordPolicyValidator.java', '1.  **File Overview & Purpose**\n\n    This is a utility class for enforcing a strong password policy. It provides a single static method to validate a given password against a set of predefined complexity rules (minimum length, character types). This ensures that all new passwords set in the application, whether during user creation or a password change, meet the required security standards.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Security/Utility** component. It is used in the **Web/Controller Tier** by the `PasswordServlet` and in the **Service Tier** via the `CreateUserAction` to validate passwords before they are hashed and stored.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.regex.Pattern`: Used to define the regular expressions for checking character types.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Patterns & Constants**:\n        *   `MIN_LENGTH`: Defines the minimum required password length.\n        *   `HAS_UPPERCASE`, `HAS_LOWERCASE`, `HAS_DIGIT`, `HAS_SPECIAL_CHAR`: Pre-compiled `Pattern` objects for efficient checking of required character types.\n    *   **`ValidationResult` (Inner Class)**: A simple record-like class to return both a boolean `isValid` status and a user-friendly `message` explaining the result.\n    *   **`validate(String password)`**\n        *   **Method Signature:** `public static ValidationResult validate(String password)`\n        *   **Purpose:** The main validation logic.\n        *   **Logic:**\n            1.  It checks for null or empty passwords.\n            2.  It creates a list of error messages.\n            3.  It checks the password against each rule (`MIN_LENGTH`, `HAS_UPPERCASE`, etc.) and adds a descriptive error string to the list for each rule that fails.\n            4.  If the `errors` list is empty, it returns a successful `ValidationResult`.\n            5.  If there are errors, it joins them into a single, comprehensive error message (e.g., \"Das Passwort muss mindestens 10 Zeichen lang sein, mindestens einen Großbuchstaben enthalten.\") and returns a failed `ValidationResult`.'),
('src/main/java/de/technikteam/websocket/ChatSessionManager.java', '1.  **File Overview & Purpose**\n\n    This class is a thread-safe singleton manager for WebSocket sessions related to event chats. It maintains a map of active chat rooms, where each room (keyed by an event ID) contains a set of connected user sessions. This allows for targeted message broadcasting to all participants in a specific event''s chat.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure** component for the real-time communication feature, operating within the **Web/Controller Tier**. It is exclusively used by the `EventChatSocket` WebSocket endpoint to manage session lifecycle and broadcast messages.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`jakarta.websocket.Session`)**: The object representing a single client connection.\n    *   `java.util.concurrent.ConcurrentHashMap` & `CopyOnWriteArraySet`: Thread-safe collection classes are used to safely manage sessions from multiple concurrent WebSocket threads.\n\n4.  **In-Depth Breakdown**\n\n    *   **Singleton Implementation**: Uses a private constructor and a static `INSTANCE` field to ensure only one manager exists per application.\n    *   **`sessionsByEvent` (Map)**: The central data structure. The key is the `eventId` as a string, and the value is a `CopyOnWriteArraySet` of `Session` objects. `CopyOnWriteArraySet` is chosen for its thread-safety, being particularly efficient when reads and iterations are more common than writes (add/remove).\n    *   **`addSession(String eventId, Session session)`**: Adds a new user''s session to the set for the corresponding event room.\n    *   **`removeSession(String eventId, Session session)`**: Removes a user''s session when they disconnect. If a room becomes empty, it is removed from the main map to conserve memory.\n    *   **`broadcast(String eventId, String message)`**: Sends a message to *every* active and open session in a specific event room.\n    *   **`broadcastExcept(String eventId, String message, Session excludeSession)`**: Sends a message to every active session in a room *except* the one that originated the message. This is used to prevent a user from receiving an echo of their own message.'),
('src/main/java/de/technikteam/websocket/DocumentEditorSocket.java', '1.  **File Overview & Purpose**\n\n    This class is a WebSocket endpoint that enables real-time, collaborative editing of Markdown files. It manages WebSocket connections for specific document editing sessions, receives content updates from one client, sanitizes them, saves them to the file system, and broadcasts the changes to all other clients editing the same document.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It provides the server-side logic for the real-time editor feature. It interacts with the `DocumentSessionManager` for session handling, the `FileDAO` for persistence, and the `MarkdownUtil` for security.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Uses static injection to receive a `FileDAO` instance from Guice.\n    *   **Jakarta WebSocket API (`@ServerEndpoint`, `@OnOpen`, etc.)**: The core annotations for defining a WebSocket endpoint.\n    *   `DocumentSessionManager`: The singleton used to manage sessions for different document rooms.\n    *   `FileDAO`: To read the file path and write updated content to the disk.\n    *   `MarkdownUtil`: For sanitizing user-provided content to prevent XSS.\n    *   **Gson**: For parsing incoming JSON messages.\n\n4.  **In-Depth Breakdown**\n\n    *   **`onOpen(...)`**:\n        *   **Purpose:** Handles a new client connection.\n        *   **Logic:** It retrieves the `User` object from the `EndpointConfig` (placed there by the `GuiceAwareServerEndpointConfigurator`). It performs an authorization check to ensure the user has `FILE_UPDATE` permission. If authorized, it adds the session to the `DocumentSessionManager` for the given `fileId`. If not, it closes the connection.\n    *   **`onMessage(...)`**:\n        *   **Purpose:** Receives a message from a client.\n        *   **Logic:** It parses the incoming JSON message. If the message `type` is `\"content_update\"`, it calls `handleContentUpdate`.\n    *   **`handleContentUpdate(...)`**:\n        *   **Purpose:** The core logic for processing a content change.\n        *   **Logic:**\n            1.  It retrieves the `File` metadata from the `FileDAO` to get the physical `filepath`.\n            2.  It sanitizes the received `content` using `MarkdownUtil.sanitize()`.\n            3.  It calls `fileDAO.updateFileContent()` to write the new content to the physical file.\n            4.  It calls `fileDAO.touchFileRecord()` to update the file''s modification timestamp.\n            5.  It constructs a broadcast message and uses `DocumentSessionManager.broadcastExcept()` to send the updated content to all other clients in the same editing session.\n    *   **`onClose(...)`** and **`onError(...)`**: Standard methods to handle session disconnection and errors by removing the session from the manager and logging the error.'),
('src/main/java/de/technikteam/websocket/DocumentSessionManager.java', '1.  **File Overview & Purpose**\n\n    This class is a thread-safe singleton manager for WebSocket sessions related to the collaborative document editor. It mirrors the functionality of `ChatSessionManager` but is specifically for document editing rooms, mapping file IDs to sets of connected editor sessions.\n\n2.  **Architectural Role**\n\n    This is an **Infrastructure** component within the **Web/Controller Tier**. It is used exclusively by the `DocumentEditorSocket` to manage session lifecycle and broadcast document updates.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`jakarta.websocket.Session`)**: The object representing a single client connection.\n    *   `java.util.concurrent.ConcurrentHashMap` & `CopyOnWriteArraySet`: Thread-safe collections for managing sessions.\n\n4.  **In-Depth Breakdown**\n\n    This class''s implementation is nearly identical to `ChatSessionManager`, but for a different domain.\n    *   **Singleton Implementation**: Standard private constructor and `getInstance()` method.\n    *   **`sessionsByFile` (Map)**: The central map where the key is the `fileId` (as a string) and the value is a `CopyOnWriteArraySet` of `Session` objects.\n    *   **`addSession(String fileId, Session session)`**: Adds a session to the room for a given file.\n    *   **`removeSession(String fileId, Session session)`**: Removes a session and cleans up the room if it becomes empty.\n    *   **`broadcastExcept(String fileId, String message, Session excludeSession)`**: Broadcasts a message (the new document content) to all clients editing the file *except* the client who sent the update.'),
('src/main/java/de/technikteam/websocket/EventChatSocket.java', '1.  **File Overview & Purpose**\n\n    This class is the WebSocket endpoint that powers the real-time chat feature for events. It manages client connections for specific event chat rooms, processes incoming messages (new, edit, delete), persists them to the database, and broadcasts them to all participants in the room. It also handles advanced features like user mentions.\n\n2.  **Architectural Role**\n\n    This is a key component of the **Web/Controller Tier**. It provides the real-time communication layer for events. It interacts with the `ChatSessionManager` for session management and various DAOs (`EventChatDAO`, `EventDAO`, `UserDAO`) for data persistence and validation.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Uses static injection to receive DAO and service instances from Guice.\n    *   **Jakarta WebSocket API (`@ServerEndpoint`, etc.)**: The core WebSocket annotations.\n    *   `ChatSessionManager`: To manage sessions and broadcast messages.\n    *   `EventChatDAO`: To save, update, and delete messages in the database.\n    *   `EventDAO`: To verify user association with the event.\n    *   `UserDAO`: To look up users for mentions.\n    *   `NotificationService`: To send out-of-app notifications for mentions.\n    *   `MarkdownUtil`: For sanitizing message content.\n\n4.  **In-Depth Breakdown**\n\n    *   **`onOpen(...)`**: Handles new connections. It authorizes the user by checking if they are associated with the event (`eventDAO.isUserAssociatedWithEvent`). If so, it adds their session to the `ChatSessionManager`.\n    *   **`onMessage(...)`**: The main message router. It parses the incoming JSON message and delegates to a specific handler based on the message `type`.\n    *   **`handleNewMessage(...)`**: Sanitizes the message content, saves it to the database via `chatDAO.postMessage()`, broadcasts the saved message (now with an ID and timestamp) to all clients in the room, and calls `handleMentions()`.\n    *   **`handleUpdateMessage(...)`**: Handles a message edit request. It calls `chatDAO.updateMessage()`, which verifies that the user is the original author, and then broadcasts the update to all clients.\n    *   **`handleDeleteMessage(...)`**: Handles a message delete request. It calls `chatDAO.deleteMessage()`, which performs a soft delete and checks if the user is the author or an admin/leader. It then broadcasts a special `message_soft_deleted` event to clients.\n    *   **`handleMentions(...)`**: Parses the message text for `@username` patterns. For each valid mention of a user who is not the sender, it sends a targeted, out-of-app notification via the `NotificationService`.'),
('src/main/java/de/technikteam/websocket/GetHttpSessionConfigurator.java', '1.  **File Overview & Purpose**\n\n    This is a custom WebSocket `ServerEndpointConfig.Configurator`. Its purpose is to intercept the WebSocket handshake process to extract the `HttpSession` from the initial HTTP upgrade request. It then retrieves the authenticated `User` object from the session and places it into the WebSocket session''s user properties map, making it accessible to the WebSocket endpoint''s methods (`@OnOpen`, `@OnMessage`, etc.).\n\n2.  **Architectural Role**\n\n    This is a critical **Infrastructure/Configuration** component for the WebSocket layer. It bridges the gap between the standard HTTP session-based authentication and the WebSocket protocol, enabling secure, authenticated WebSocket communication.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`ServerEndpointConfig.Configurator`)**: The base class it extends.\n    *   `User` (Model): The object it retrieves from the `HttpSession`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`USER_PROPERTY_KEY`**: A static constant defining the key used to store the `User` object in the WebSocket session''s user properties.\n    *   **`servletContext`**: A static volatile field to hold a reference to the `ServletContext`, which is needed by the `GuiceAwareServerEndpointConfigurator`.\n    *   **`modifyHandshake(...)`**:\n        *   **Purpose:** This method is called by the WebSocket container during the handshake.\n        *   **Logic:**\n            1.  It accesses the `HttpSession` from the `HandshakeRequest`.\n            2.  If a session exists, it retrieves the `User` object stored under the attribute key `\"user\"`.\n            3.  If a `User` object is found, it adds it to the `ServerEndpointConfig`''s user properties map using the `USER_PROPERTY_KEY`. This makes the user object available within the WebSocket endpoint instance.\n            4.  It also caches a reference to the `ServletContext` for Guice integration.'),
('src/main/java/de/technikteam/websocket/GuiceAwareServerEndpointConfigurator.java', '1.  **File Overview & Purpose**\n\n    This is a custom WebSocket `ServerEndpointConfig.Configurator` that integrates Google Guice with the Jakarta WebSocket lifecycle. Its primary function is to ensure that WebSocket endpoint instances (like `EventChatSocket`) are created by the Guice `Injector` instead of the container''s default mechanism. This allows for dependency injection into the WebSocket classes.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure/Configuration** component that enables dependency injection for the WebSocket layer. It is declared on each `@ServerEndpoint` annotation (e.g., `@ServerEndpoint(value = \"/ws/chat/{eventId}\", configurator = GuiceAwareServerEndpointConfigurator.class)`).\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Guice (`com.google.inject.Injector`)**: The dependency injection container.\n    *   **Jakarta WebSocket API (`ServerEndpointConfig.Configurator`)**: The base class it extends.\n    *   `GetHttpSessionConfigurator`: It composes this configurator to also handle session extraction during the handshake.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getEndpointInstance(Class<T> endpointClass)`**:\n        *   **Purpose:** This method is called by the WebSocket container when it needs a new instance of an endpoint class. This override intercepts that call.\n        *   **Logic:**\n            1.  It retrieves the `ServletContext` (which was cached by `GetHttpSessionConfigurator`).\n            2.  It retrieves the Guice `Injector` from the `ServletContext` attributes (where it was placed by the `GuiceConfig` listener).\n            3.  It calls `injector.getInstance(endpointClass)` to have Guice create the endpoint instance. This handles constructor injection.\n            4.  It then calls `injector.injectMembers(instance)`. This crucial step performs member injection, including `@Inject` on static fields, which is the pattern used by the WebSocket endpoints in this project.\n        *   **Returns:** A fully dependency-injected instance of the WebSocket endpoint.\n\n    *   **`modifyHandshake(...)`**: This method is also overridden to ensure that the logic from `GetHttpSessionConfigurator` (extracting the user from the session) is also executed during the handshake process.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V21__Add_profile_picture_to_users.sql
========================================================================

-- Flyway migration V21: Add profile picture path to users table

ALTER TABLE `users`
ADD COLUMN `profile_picture_path` VARCHAR(255) DEFAULT NULL AFTER `theme`;

ALTER TABLE `profile_change_requests`
MODIFY COLUMN `requested_changes` LONGTEXT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL;
========================================================================
FILE: src\main\resources\db\migration\V22__Remove_Default_Admin_User.sql
========================================================================

-- Flyway migration V22: Remove the insecure, hardcoded default admin user

-- First remove permissions to avoid foreign key constraint issues.
DELETE up FROM user_permissions up
JOIN users u ON up.user_id = u.id
WHERE u.username = 'admin';

-- Then delete the user.
DELETE FROM users WHERE username = 'admin';
========================================================================
FILE: src\main\resources\db\migration\V2__Add_keys_and_indexes.sql
========================================================================

-- Flyway migration V2: Add all primary keys, unique constraints, and indexes.

START TRANSACTION;

ALTER TABLE `achievements` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `achievement_key` (`achievement_key`);
ALTER TABLE `admin_logs` ADD PRIMARY KEY (`id`);
ALTER TABLE `attachments` ADD PRIMARY KEY (`id`), ADD KEY `idx_attachments_parent` (`parent_type`,`parent_id`);
ALTER TABLE `courses` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `name` (`name`), ADD UNIQUE KEY `abbreviation` (`abbreviation`);
ALTER TABLE `course_attendance` ADD PRIMARY KEY (`user_id`,`course_id`), ADD KEY `course_id` (`course_id`);
ALTER TABLE `events` ADD PRIMARY KEY (`id`), ADD KEY `fk_event_leader` (`leader_user_id`);
ALTER TABLE `event_assignments` ADD PRIMARY KEY (`assignment_id`), ADD UNIQUE KEY `unique_assignment` (`event_id`,`user_id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `event_attendance` ADD PRIMARY KEY (`user_id`,`event_id`), ADD KEY `event_id` (`event_id`);
ALTER TABLE `event_chat_messages` ADD PRIMARY KEY (`id`), ADD KEY `event_id` (`event_id`), ADD KEY `event_chat_messages_ibfk_2` (`user_id`);
ALTER TABLE `event_custom_fields` ADD PRIMARY KEY (`id`), ADD KEY `event_id` (`event_id`);
ALTER TABLE `event_custom_field_responses` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `field_id` (`field_id`,`user_id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `event_skill_requirements` ADD PRIMARY KEY (`id`), ADD KEY `event_id` (`event_id`), ADD KEY `required_course_id` (`required_course_id`);
ALTER TABLE `event_storage_reservations` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `unique_event_item` (`event_id`,`item_id`), ADD KEY `item_id` (`item_id`);
ALTER TABLE `event_tasks` ADD PRIMARY KEY (`id`), ADD KEY `event_id` (`event_id`);
ALTER TABLE `event_task_assignments` ADD PRIMARY KEY (`task_id`,`user_id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `event_task_kits` ADD PRIMARY KEY (`task_id`,`kit_id`), ADD KEY `kit_id` (`kit_id`);
ALTER TABLE `event_task_storage_items` ADD PRIMARY KEY (`task_id`,`item_id`), ADD KEY `item_id` (`item_id`);
ALTER TABLE `feedback_forms` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `event_id_unique` (`event_id`);
ALTER TABLE `feedback_responses` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `form_user_unique` (`form_id`,`user_id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `feedback_submissions` ADD PRIMARY KEY (`id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `files` ADD PRIMARY KEY (`id`), ADD KEY `category_id` (`category_id`);
ALTER TABLE `file_categories` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `name` (`name`);
ALTER TABLE `inventory_kits` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `name` (`name`);
ALTER TABLE `inventory_kit_items` ADD PRIMARY KEY (`kit_id`,`item_id`), ADD KEY `item_id` (`item_id`);
ALTER TABLE `login_attempts` ADD PRIMARY KEY (`username`);
ALTER TABLE `maintenance_log` ADD PRIMARY KEY (`id`), ADD KEY `item_id` (`item_id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `meetings` ADD PRIMARY KEY (`id`), ADD KEY `course_id` (`course_id`), ADD KEY `fk_meeting_leader` (`leader_user_id`);
ALTER TABLE `meeting_attendance` ADD PRIMARY KEY (`user_id`,`meeting_id`), ADD KEY `meeting_id` (`meeting_id`);
ALTER TABLE `permissions` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `permission_key_unique` (`permission_key`);
ALTER TABLE `profile_change_requests` ADD PRIMARY KEY (`id`), ADD KEY `user_id` (`user_id`), ADD KEY `status` (`status`), ADD KEY `profile_change_requests_ibfk_2` (`reviewed_by_admin_id`);
ALTER TABLE `roles` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `role_name_unique` (`role_name`);
ALTER TABLE `shared_documents` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `document_name` (`document_name`), ADD UNIQUE KEY `idx_doc_name` (`document_name`);
ALTER TABLE `storage_items` ADD PRIMARY KEY (`id`), ADD KEY `fk_holder_user` (`current_holder_user_id`), ADD KEY `fk_assigned_event` (`assigned_event_id`);
ALTER TABLE `storage_log` ADD PRIMARY KEY (`id`), ADD KEY `item_id` (`item_id`), ADD KEY `user_id` (`user_id`), ADD KEY `fk_log_event` (`event_id`);
ALTER TABLE `todo_categories` ADD KEY `idx_todo_categories_display_order` (`display_order`);
ALTER TABLE `todo_tasks` ADD KEY `idx_todo_tasks_display_order` (`display_order`);
ALTER TABLE `users` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `username` (`username`), ADD UNIQUE KEY `email` (`email`), ADD KEY `fk_user_role` (`role_id`);
ALTER TABLE `user_achievements` ADD PRIMARY KEY (`user_id`,`achievement_id`), ADD KEY `achievement_id` (`achievement_id`);
ALTER TABLE `user_passkeys` ADD PRIMARY KEY (`id`), ADD KEY `user_id` (`user_id`);
ALTER TABLE `user_permissions` ADD PRIMARY KEY (`user_id`,`permission_id`), ADD KEY `permission_id` (`permission_id`);
ALTER TABLE `user_qualifications` ADD PRIMARY KEY (`user_id`,`course_id`), ADD KEY `course_id` (`course_id`);
ALTER TABLE `wiki_documentation` ADD PRIMARY KEY (`id`), ADD UNIQUE KEY `idx_wiki_file_path` (`file_path`);

-- Add all auto-increment settings
ALTER TABLE `achievements` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `admin_logs` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `attachments` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `courses` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `events` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_assignments` MODIFY `assignment_id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_chat_messages` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_custom_fields` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_custom_field_responses` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_skill_requirements` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_storage_reservations` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `event_tasks` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `feedback_forms` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `feedback_responses` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `feedback_submissions` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `files` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `file_categories` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `inventory_kits` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `maintenance_log` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `meetings` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `permissions` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `profile_change_requests` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `roles` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `shared_documents` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `storage_items` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `storage_log` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `users` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `user_passkeys` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;
ALTER TABLE `wiki_documentation` MODIFY `id` int(11) NOT NULL AUTO_INCREMENT;

COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V3__Add_foreign_keys.sql
========================================================================

-- Flyway migration V3: Add all foreign key constraints.

START TRANSACTION;

ALTER TABLE `course_attendance`
  ADD CONSTRAINT `course_attendance_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `course_attendance_ibfk_2` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE;

ALTER TABLE `events`
  ADD CONSTRAINT `fk_event_leader` FOREIGN KEY (`leader_user_id`) REFERENCES `users` (`id`) ON DELETE SET NULL;

ALTER TABLE `event_assignments`
  ADD CONSTRAINT `event_assignments_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_assignments_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_attendance`
  ADD CONSTRAINT `event_attendance_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_attendance_ibfk_2` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_chat_messages`
  ADD CONSTRAINT `event_chat_messages_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_chat_messages_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_custom_fields`
  ADD CONSTRAINT `event_custom_fields_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_custom_field_responses`
  ADD CONSTRAINT `event_custom_field_responses_ibfk_1` FOREIGN KEY (`field_id`) REFERENCES `event_custom_fields` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_custom_field_responses_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_skill_requirements`
  ADD CONSTRAINT `event_skill_requirements_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_skill_requirements_ibfk_2` FOREIGN KEY (`required_course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_storage_reservations`
  ADD CONSTRAINT `event_storage_reservations_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_storage_reservations_ibfk_2` FOREIGN KEY (`item_id`) REFERENCES `storage_items` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_tasks`
  ADD CONSTRAINT `event_tasks_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_task_assignments`
  ADD CONSTRAINT `event_task_assignments_ibfk_1` FOREIGN KEY (`task_id`) REFERENCES `event_tasks` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_task_assignments_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_task_kits`
  ADD CONSTRAINT `event_task_kits_ibfk_1` FOREIGN KEY (`task_id`) REFERENCES `event_tasks` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_task_kits_ibfk_2` FOREIGN KEY (`kit_id`) REFERENCES `inventory_kits` (`id`) ON DELETE CASCADE;

ALTER TABLE `event_task_storage_items`
  ADD CONSTRAINT `event_task_storage_items_ibfk_1` FOREIGN KEY (`task_id`) REFERENCES `event_tasks` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `event_task_storage_items_ibfk_2` FOREIGN KEY (`item_id`) REFERENCES `storage_items` (`id`) ON DELETE CASCADE;

ALTER TABLE `feedback_forms`
  ADD CONSTRAINT `feedback_forms_ibfk_1` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE CASCADE;

ALTER TABLE `feedback_responses`
  ADD CONSTRAINT `feedback_responses_ibfk_1` FOREIGN KEY (`form_id`) REFERENCES `feedback_forms` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `feedback_responses_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `feedback_submissions`
  ADD CONSTRAINT `feedback_submissions_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `files`
  ADD CONSTRAINT `files_ibfk_1` FOREIGN KEY (`category_id`) REFERENCES `file_categories` (`id`) ON DELETE SET NULL;

ALTER TABLE `inventory_kit_items`
  ADD CONSTRAINT `inventory_kit_items_ibfk_1` FOREIGN KEY (`kit_id`) REFERENCES `inventory_kits` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `inventory_kit_items_ibfk_2` FOREIGN KEY (`item_id`) REFERENCES `storage_items` (`id`) ON DELETE CASCADE;

ALTER TABLE `maintenance_log`
  ADD CONSTRAINT `maintenance_log_ibfk_1` FOREIGN KEY (`item_id`) REFERENCES `storage_items` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `maintenance_log_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`);

ALTER TABLE `meetings`
  ADD CONSTRAINT `fk_meeting_leader` FOREIGN KEY (`leader_user_id`) REFERENCES `users` (`id`) ON DELETE SET NULL,
  ADD CONSTRAINT `meetings_ibfk_1` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE;

ALTER TABLE `meeting_attendance`
  ADD CONSTRAINT `meeting_attendance_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `meeting_attendance_ibfk_2` FOREIGN KEY (`meeting_id`) REFERENCES `meetings` (`id`) ON DELETE CASCADE;

ALTER TABLE `profile_change_requests`
  ADD CONSTRAINT `profile_change_requests_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `profile_change_requests_ibfk_2` FOREIGN KEY (`reviewed_by_admin_id`) REFERENCES `users` (`id`) ON DELETE SET NULL;

ALTER TABLE `storage_items`
  ADD CONSTRAINT `fk_assigned_event` FOREIGN KEY (`assigned_event_id`) REFERENCES `events` (`id`) ON DELETE SET NULL,
  ADD CONSTRAINT `fk_holder_user` FOREIGN KEY (`current_holder_user_id`) REFERENCES `users` (`id`) ON DELETE SET NULL;

ALTER TABLE `storage_log`
  ADD CONSTRAINT `fk_log_event` FOREIGN KEY (`event_id`) REFERENCES `events` (`id`) ON DELETE SET NULL,
  ADD CONSTRAINT `storage_log_ibfk_1` FOREIGN KEY (`item_id`) REFERENCES `storage_items` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `storage_log_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `todo_tasks`
    ADD CONSTRAINT `fk_todo_category` FOREIGN KEY (`category_id`) REFERENCES `todo_categories`(`id`) ON DELETE CASCADE;

ALTER TABLE `users`
  ADD CONSTRAINT `fk_user_role` FOREIGN KEY (`role_id`) REFERENCES `roles` (`id`) ON DELETE SET NULL;

ALTER TABLE `user_achievements`
  ADD CONSTRAINT `user_achievements_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `user_achievements_ibfk_2` FOREIGN KEY (`achievement_id`) REFERENCES `achievements` (`id`) ON DELETE CASCADE;

ALTER TABLE `user_passkeys`
  ADD CONSTRAINT `user_passkeys_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE;

ALTER TABLE `user_permissions`
  ADD CONSTRAINT `user_permissions_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `user_permissions_ibfk_2` FOREIGN KEY (`permission_id`) REFERENCES `permissions` (`id`) ON DELETE CASCADE;

ALTER TABLE `user_qualifications`
  ADD CONSTRAINT `user_qualifications_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `users` (`id`) ON DELETE CASCADE,
  ADD CONSTRAINT `user_qualifications_ibfk_2` FOREIGN KEY (`course_id`) REFERENCES `courses` (`id`) ON DELETE CASCADE;

COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V4__Add_initial_data.sql
========================================================================

-- Flyway migration V4: Add essential seed data.

-- Add default roles
INSERT INTO `roles` (`id`, `role_name`) VALUES (1, 'ADMIN'), (2, 'NUTZER');

-- Add all permissions
INSERT INTO `permissions` (`id`, `permission_key`, `description`) VALUES
(1, 'ACCESS_ADMIN_PANEL', 'Globaler Zugriff auf alle Admin-Funktionen. Überschreibt alle anderen Berechtigungen.'),
(2, 'USER_CREATE', 'Kann neue Benutzer anlegen.'),
(3, 'USER_READ', 'Kann Benutzerliste und -details einsehen.'),
(4, 'USER_UPDATE', 'Kann Benutzerprofile und deren Berechtigungen bearbeiten.'),
(5, 'USER_DELETE', 'Kann Benutzer löschen.'),
(6, 'USER_PASSWORD_RESET', 'Kann Passwörter anderer Benutzer zurücksetzen.'),
(7, 'EVENT_CREATE', 'Kann neue Events erstellen.'),
(8, 'EVENT_READ', 'Kann die Event-Verwaltungsliste einsehen.'),
(9, 'EVENT_UPDATE', 'Kann bestehende Events bearbeiten (Details, Personalbedarf, Material).'),
(10, 'EVENT_DELETE', 'Kann Events löschen.'),
(11, 'EVENT_MANAGE_ASSIGNMENTS', 'Kann Benutzer zu Events zuweisen.'),
(12, 'EVENT_MANAGE_TASKS', 'Kann Aufgaben innerhalb eines Events erstellen, bearbeiten und löschen.'),
(13, 'COURSE_CREATE', 'Kann neue Lehrgangs-Vorlagen erstellen.'),
(14, 'COURSE_READ', 'Kann Lehrgangs-Vorlagen und deren Termine einsehen.'),
(15, 'COURSE_UPDATE', 'Kann Lehrgangs-Vorlagen bearbeiten.'),
(16, 'COURSE_DELETE', 'Kann Lehrgangs-Vorlagen löschen.'),
(17, 'STORAGE_CREATE', 'Kann neue Lagerartikel anlegen.'),
(18, 'STORAGE_READ', 'Kann die Lager-Verwaltungsliste einsehen.'),
(19, 'STORAGE_UPDATE', 'Kann Lagerartikel bearbeiten, inkl. Defekt-Status.'),
(20, 'STORAGE_DELETE', 'Kann Lagerartikel löschen.'),
(21, 'KIT_CREATE', 'Kann neue Material-Kits/Koffer erstellen.'),
(22, 'KIT_READ', 'Kann die Kit-Verwaltungsliste einsehen.'),
(23, 'KIT_UPDATE', 'Kann Kits und deren Inhalte bearbeiten.'),
(24, 'KIT_DELETE', 'Kann Kits löschen.'),
(25, 'QUALIFICATION_READ', 'Kann die Qualifikations-Matrix einsehen.'),
(26, 'QUALIFICATION_UPDATE', 'Kann Teilnahme und Qualifikationen in der Matrix bearbeiten.'),
(27, 'FILE_CREATE', 'Kann Dateien hochladen und Kategorien erstellen.'),
(28, 'FILE_READ', 'Kann die Datei-Verwaltungsseite einsehen.'),
(29, 'FILE_DELETE', 'Kann Dateien und Kategorien löschen.'),
(30, 'LOG_READ', 'Kann das Admin-Aktionsprotokoll einsehen.'),
(31, 'REPORT_READ', 'Kann die Berichts- und Analyse-Seite einsehen.'),
(32, 'SYSTEM_READ', 'Kann die Systemstatus-Seite einsehen.'),
(33, 'ACHIEVEMENT_CREATE', 'Kann neue Erfolge und Abzeichen erstellen.'),
(34, 'ACHIEVEMENT_UPDATE', 'Kann bestehende Erfolge und Abzeichen bearbeiten.'),
(35, 'ACHIEVEMENT_DELETE', 'Kann Erfolge und Abzeichen löschen.'),
(36, 'FILE_MANAGE', 'Kann die Datei-Verwaltungsseite einsehen und grundlegende Operationen durchführen.'),
(37, 'FILE_UPDATE', 'Kann den Inhalt von Dateien (z.B. im Markdown-Editor) bearbeiten und neue Versionen hochladen.'),
(38, 'ACHIEVEMENT_VIEW', 'Ermöglicht das Anzeigen des Admin-Menüpunkts für Abzeichen.'),
(39, 'ADMIN_DASHBOARD_ACCESS', 'Ermöglicht das Anzeigen des Admin-Menüpunkts für das Dashboard.');
========================================================================
FILE: src\main\resources\db\migration\V5__Add_storage_item_data.sql
========================================================================

-- Flyway migration V5: Insert initial set of storage items.

INSERT INTO `storage_items` (`id`, `name`, `location`, `cabinet`, `compartment`, `quantity`, `max_quantity`, `defective_quantity`, `defect_reason`, `weight_kg`, `price_eur`, `image_path`, `status`, `current_holder_user_id`, `assigned_event_id`) VALUES
(4, 'Movingheads', 'Oben', '1', '2', 2, 4, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(5, 'Tri leds', 'Oben', '1', '2', 2, 2, 0, NULL, 0.00, 0.00, '1000014818.jpg', 'IN_STORAGE', NULL, NULL),
(6, 'Par 56', 'Oben', '1', '3', 4, 14, 0, NULL, 0.00, 0.00, '1000014819.jpg', 'IN_STORAGE', NULL, NULL),
(7, 'Mischpult (alt)', 'Erdgeschoss', '2', '4', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2714.43.484538135326788297692.jpg', 'IN_STORAGE', NULL, NULL),
(8, 'Strand Lighting', 'Erdgeschoss', '2', '4', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2714.45.122077548250905478222.jpg', 'IN_STORAGE', NULL, NULL),
(10, 'DMX Kabel ', 'Erdgeschoss', '1', '/', 12, 12, 0, '', 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(11, 'Traversen', 'Oben', '1-3', '1', 4, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(12, 'Laser', 'Oben', '1', '3', 2, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(13, 'Led bars', 'Oben', '2', '2', 7, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(14, 'Mikrofonstativ', 'Erdgeschoss ', '2', '4', 6, 6, 0, NULL, 0.00, 0.00, '1000004426.jpg', 'IN_STORAGE', NULL, NULL),
(15, 'Par Scheinwerfer', 'Oben', '2', '3', 4, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(16, 'XLR Kabel (normal)', 'Erdgeschoss', '1', 'Hängend', 19, 19, 0, NULL, 0.00, 0.00, '2025-06-2716.17.57144115011978189604.jpg', 'IN_STORAGE', NULL, NULL),
(17, 'DMX dimmer', 'Oben', '2', '2', 6, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(18, 'Mehrfachstecker', 'Erdgeschoss', '2', 'Hängend', 12, 10, 0, NULL, 0.00, 0.00, '2025-06-2716.20.283964599778401908342.jpg', 'IN_STORAGE', NULL, NULL),
(19, 'Farbfolien', 'Oben', '4', '3', 0, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(20, 'Farbfolienhalter', 'Oben', '4', '2', 0, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(21, 'Plugboxen', 'Oben', '5', '2-4', 4, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(22, 'Große Lampe', 'Oben', '5', '4', 0, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(23, 'Mikrofonklemmen (groß)', 'Erdgeschoss', '2', '2', 10, 10, 0, NULL, 0.00, 0.00, '2025-06-2716.25.505575202287104074157.jpg', 'IN_STORAGE', NULL, NULL),
(24, 'leuchtmittel', 'Oben', '/', '1', 15, 0, 2, '', 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(25, 'Lampenstative', 'Oben', 'ganz hinten', '0', 4, 0, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(26, 'Mikrofonhalterung', 'Erdgeschoss', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '1000004428.jpg', 'IN_STORAGE', NULL, NULL),
(27, 'Mikrofonständer Zubehör ', 'Erdgeschoss', '2', '2', 7, 7, 0, NULL, 0.00, 0.00, '2025-06-2716.43.268863184837397618557.jpg', 'IN_STORAGE', NULL, NULL),
(28, 'XLR 1m', 'Erdgeschoss ', '2', 'Hängend', 14, 14, 0, NULL, 0.00, 0.00, '2025-06-2716.44.217215765873591130197.jpg', 'IN_STORAGE', NULL, NULL),
(29, 'Verlängerungskabel', 'Erdgeschoss', '1', 'Hängend', 17, 17, 0, NULL, 0.00, 0.00, '2025-06-2716.46.3329023597302231662.jpg', 'IN_STORAGE', NULL, NULL),
(30, 'Klinke (groß)', 'Erdgeschoss ', '1', 'Hängend', 7, 7, 0, NULL, 0.00, 0.00, '2025-06-2716.47.474256954529147799815.jpg', 'IN_STORAGE', NULL, NULL),
(31, 'Kat 5e', 'Erdgeschoss', '1', 'Hängend', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2716.48.438613619599782685040.jpg', 'IN_STORAGE', NULL, NULL),
(32, 'Tape (schwarz)', 'Erdgeschoss', '1', 'Hängend', 5, 5, 0, NULL, 0.00, 0.00, '2025-06-2716.50.189037015943349490192.jpg', 'IN_STORAGE', NULL, NULL),
(33, 'Isolierband (mehrfarbig)', 'Erdgeschoss', '1', 'Hängend', 13, 13, 0, NULL, 0.00, 0.00, '2025-06-2716.52.326139423796119518903.jpg', 'IN_STORAGE', NULL, NULL),
(34, 'Klettband', 'Erdgeschoss', '2', 'Hängend', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2716.54.436320883725802641087.jpg', 'IN_STORAGE', NULL, NULL),
(35, 'LAN Kabel', 'Erdgeschoss', '2', '1', 24, 24, 0, NULL, 0.00, 0.00, '2025-06-2717.00.06154248686898973087.jpg', 'IN_STORAGE', NULL, NULL),
(36, 'Kameramikrofon', 'Erdgeschoss', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2717.03.512938281413325712878.jpg', 'IN_STORAGE', NULL, NULL),
(37, 'Shotgun Mikrofon', 'Erdgeschoss ', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2717.06.098569123668927925595.jpg', 'IN_STORAGE', NULL, NULL),
(38, 'Oberflächenmikrofon', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2717.10.391795435121197552263.jpg', 'IN_STORAGE', NULL, NULL),
(39, 'Kaltgeräte Kabel', 'Erdgeschoss ', '2', '2', 77, 77, 0, NULL, 0.00, 0.00, '2025-06-2717.15.074914010989957328333.jpg', 'IN_STORAGE', NULL, NULL),
(40, 'Funkzubehör', 'Erdgeschoss', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2717.17.043830938027829171798.jpg', 'IN_STORAGE', NULL, NULL),
(41, 'Kaltgeräte Kabel (Daisy Chain)', 'Erdgeschoss', '1', '1', 11, 11, 1, 'Defekte Buchse ', 0.00, 0.00, '2025-06-2717.18.125709401359377594527.jpg', 'IN_STORAGE', NULL, NULL),
(42, 'Kennzeichnungsringe (mehrfarbig)', 'Erdgeschoss ', '2', '2', 7, 8, 0, NULL, 0.00, 0.00, '2025-06-2717.20.11195938865415073150.jpg', 'IN_STORAGE', NULL, NULL),
(43, 'Mikrofonklemmen (klein)', 'Erdgeschoss ', '2', '2', 13, 13, 0, NULL, 0.00, 0.00, '2025-06-2717.27.274588107262469783348.jpg', 'IN_STORAGE', NULL, NULL),
(44, 'HDMI Kabel', 'Erdgeschoss ', '2', '1', 10, 10, 0, NULL, 0.00, 0.00, '2025-06-2717.56.305143014867881008801.jpg', 'IN_STORAGE', NULL, NULL),
(45, 'Kabelmikrofon', 'Erdgeschoss', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2717.58.177946197060559751805.jpg', 'IN_STORAGE', NULL, NULL),
(46, 'Adapter (Klinke - VGA)', 'Erdgeschoss', '2', '2', 1, 1, 1, 'VGA Anschluss fehlen Pole', 0.00, 0.00, '2025-06-2717.59.556036963108161859221.jpg', 'IN_STORAGE', NULL, NULL),
(47, 'Adapterkabel (2 XLR - Klinke (klein))', 'Erdgeschoss ', '2', '1', 1, 1, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(48, 'Adapterkabel (Klinke - RCA)', 'Erdgeschoss ', '2', '1', 1, 1, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(49, 'Adapterkabel (2 Klinke - Klinke (klein))', 'Erdgeschoss ', '2', '1', 3, 3, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(50, 'Adapterkabel (Klinke (klein) - Klinke)', 'Erdgeschoss ', '2', '1', 2, 2, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(51, 'Adapterkabel (XLR - Klinke)', 'Erdgeschoss ', '2', '1', 9, 9, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(52, 'Klinke (klein)', 'Erdgeschoss', '2', '1', 1, 1, 0, NULL, 0.00, 0.00, NULL, 'IN_STORAGE', NULL, NULL),
(53, 'Adapter (Klinke (klein) - Chinch)', 'Erdgeschoss ', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2718.23.499020825943256947204.jpg', 'IN_STORAGE', NULL, NULL),
(54, 'Adapter (Klinke (klein) - Klinke (groß))', 'Erdgeschoss ', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2718.25.576661925063283895663.jpg', 'IN_STORAGE', NULL, NULL),
(55, 'Adapter (XLR (5-polig) - XLR (3-polig))', 'Erdgeschoss ', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2718.27.096864481674443203081.jpg', 'IN_STORAGE', NULL, NULL),
(56, 'Adapter (XLR - XLR)', 'Erdgeschoss', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2718.28.148498265326953710617.jpg', 'IN_STORAGE', NULL, NULL),
(57, 'Adapter (Klinke (groß) - Klinke (klein))', 'Erdgeschoss ', '2', '2', 2, 2, 0, NULL, 0.00, 0.00, '2025-06-2718.29.288337895956067779676.jpg', 'IN_STORAGE', NULL, NULL),
(58, 'Adapter (Klinke (klein) - Klinke (groß))', 'Erdgeschoss ', '2', '2', 8, 8, 0, NULL, 0.00, 0.00, '2025-06-2718.31.31210849178064261929.jpg', 'IN_STORAGE', NULL, NULL),
(59, 'Adapter (XLR (3-polig) - XLR (5-polig))', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2718.59.517877817548047227728.jpg', 'IN_STORAGE', NULL, NULL),
(60, 'Adapter (XLR - Chinch)', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2719.01.268681550318375427445.jpg', 'IN_STORAGE', NULL, NULL),
(61, 'Adapter (Klinke (groß) - 2 Klinke (groß))', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2719.03.262282293221670794195.jpg', 'IN_STORAGE', NULL, NULL),
(62, 'Adapter (Klinke (groß) - Klinke (klein))', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2719.04.443477670903409475836.jpg', 'IN_STORAGE', NULL, NULL),
(63, 'Adapter (Dell Strom)', 'Erdgeschoss ', '2', '2', 1, 1, 0, NULL, 0.00, 0.00, '2025-06-2719.09.478882073636558604076.jpg', 'IN_STORAGE', NULL, NULL),
(64, 'BNC Kabel ', 'Erdgeschoss ', '2', '1', 3, 0, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(65, 'Klinke (klein) - 2x RCA (Male)', 'Erdgeschoss ', '2', '1', 1, 1, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(66, 'Doppel RCA', 'Erdgeschoss ', '2', '1', 4, 4, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(67, 'Dreifach RCA', 'Erdgeschoss ', '2', '1', 3, 3, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(68, 'RCA', 'Erdgeschoss ', '2', '1', 1, 1, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(69, 'Nebelmaschine (klein) ', 'Erdgeschoss ', '1', '1', 1, 1, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(70, 'Nebelmaschine (groß)', 'Erdgeschoss ', '1', '0', 1, 1, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(71, 'Boden Nebelmaschine  ', 'Erdgeschoss ', '1', '0', 1, 1, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(72, 'Nebelfluid (divers)', 'Erdgeschoss ', '1', '1', 12, 12, 0, NULL, 0.00, 0.00, 'image.jpg', 'IN_STORAGE', NULL, NULL),
(73, 'Traversenbolzen', 'Erdgeschoss ', 'Riggingkiste', 'Riggingkiste', 13, 13, 0, NULL, 0.00, 0.00, '2025-06-2812.24.214632515314181386114.jpg', 'IN_STORAGE', NULL, NULL);

-- Set auto-increment start value
ALTER TABLE `storage_items` AUTO_INCREMENT = 75;
========================================================================
FILE: src\main\resources\db\migration\V6__Populate_wiki_data_part1.sql
========================================================================

-- Flyway migration V6, Part 1

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('pom.xml', '1.  **File Overview & Purpose**\n\n    This is the Project Object Model (POM) file for Maven, the build and dependency management tool for this project. It defines the project''s coordinates, dependencies, build settings, and plugins. It is the central configuration file for building the `TechnikTeam.jar` artifact.\n\n2.  **Architectural Role**\n\n    This is a core project configuration file, not belonging to a specific architectural tier. It defines the project''s structure and the libraries that will be available at runtime for all tiers.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Spring Boot Starters**: Provide a one-stop-shop for all the dependencies needed for a specific functionality (e.g., `spring-boot-starter-web`, `spring-boot-starter-security`).\n    *   **Flyway**: Manages database schema migrations, ensuring the database is always in a consistent and up-to-date state.\n    *   **MariaDB/MySQL Connector**: The JDBC driver for the database.\n    *   **Log4j 2**: A robust logging framework used for application-wide logging and auditing.\n    *   **JWT (jjwt)**: A library for creating and parsing JSON Web Tokens for stateless authentication.\n    *   **Swagger/Springdoc**: For automatic generation of API documentation.\n\n4.  **In-Depth Breakdown**\n\n    *   **`<parent>`**: Inherits default settings from the `spring-boot-starter-parent`, which manages dependency versions and default plugin configurations.\n    *   **`<properties>`**: Defines common version numbers for dependencies (`springdoc-openapi.version`, `jjwt.version`, etc.) and sets the project''s Java version to `21`.\n    *   **`<dependencies>`**: Contains the list of all external libraries the project depends on. Key groups include:\n        *   **Spring Boot**: Core starters for Web, Data JPA, Security, Validation, WebSocket, and Log4j2.\n        *   **Database**: `flyway-core`, `flyway-mysql`, and `mariadb-java-client` provide everything needed for database migration and connectivity.\n        *   **Security**: The `jjwt` artifacts for JWT handling and `webauthn-server-core` for Passkey support.\n        *   **API Documentation**: `springdoc-openapi-starter-webmvc-ui` integrates Swagger UI.\n        *   **Utilities**: Various libraries for tasks like iCalendar generation (`ical4j`), caching (`caffeine`), and JSON serialization (`gson` is included via Spring Boot).\n    *   **`<build>`**: Configures the Maven build process.\n        *   `spring-boot-maven-plugin`: Packages the application as an executable JAR.\n        *   `maven-compiler-plugin`: Configures the Java compiler version.'),
('src/main/java/de/technikteam/config/DateFormatter.java', '1.  **File Overview & Purpose**\n\n    This is a utility class providing static methods for consistent date and time formatting throughout the application. It ensures that all `java.time.LocalDateTime` objects are displayed in a standardized, German-locale format (e.g., \"10.06.2025, 17:45 Uhr\").\n\n2.  **Architectural Role**\n\n    This is a cross-cutting concern utility, used primarily in the **Model** and **Web/API** tiers. Models use it to provide pre-formatted strings for DTOs, ensuring a consistent user experience.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.time.LocalDateTime`: The modern Java date-time API object that this class formats.\n    *   `java.time.format.DateTimeFormatter`: The core Java class used for defining and applying date-time format patterns.\n\n4.  **In-Depth Breakdown**\n\n    *   **`formatDateTime(LocalDateTime ldt)`**\n        *   **Method Signature:** `public static String formatDateTime(LocalDateTime ldt)`\n        *   **Purpose:** Formats a `LocalDateTime` into a full date and time string.\n        *   **Parameters:**\n            *   `ldt` (LocalDateTime): The date-time object to format.\n        *   **Returns:** A formatted string like \"dd.MM.yyyy, HH:mm\" (e.g., \"10.06.2025, 17:45\"), or an empty string if the input is null.\n        *   **Side Effects:** None.\n\n    *   **`formatDate(LocalDateTime ldt)`**\n        *   **Method Signature:** `public static String formatDate(LocalDateTime ldt)`\n        *   **Purpose:** Formats a `LocalDateTime` into a date-only string.\n        *   **Parameters:**\n            *   `ldt` (LocalDateTime): The date-time object to format.\n        *   **Returns:** A formatted string like \"dd.MM.yyyy\" (e.g., \"10.06.2025\"), or an empty string if the input is null.\n        *   **Side Effects:** None.\n\n    *   **`formatDateTimeRange(LocalDateTime start, LocalDateTime end)`**\n        *   **Method Signature:** `public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end)`\n        *   **Purpose:** Intelligently formats a date range. It provides a more compact format if the start and end times are on the same day.\n        *   **Parameters:**\n            *   `start` (LocalDateTime): The start of the range.\n            *   `end` (LocalDateTime): The end of the range (can be null).\n        *   **Returns:** A user-friendly string representing the range.\n            *   If `end` is null: \"10.06.2025, 17:45 Uhr\"\n            *   If same day: \"10.06.2025, 17:45 - 19:00 Uhr\"\n            *   If different days: \"10.06.2025, 17:45 Uhr - 11.06.2025, 18:00 Uhr\"\n        *   **Side Effects:** None.'),
('src/main/java/de/technikteam/config/GlobalExceptionHandler.java', '1.  **File Overview & Purpose**\n\n    This class is a centralized, global exception handler for the Spring Boot application. Annotated with `@ControllerAdvice`, it intercepts exceptions thrown from any controller (`@RestController`) and transforms them into a standardized, user-friendly JSON `ApiResponse` object. This ensures that the frontend always receives a consistent error structure and prevents the leakage of sensitive stack traces.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Configuration** component that operates at the boundary of the **Web/API Tier**. It provides a uniform error handling policy for the entire REST API.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Spring Framework (`@ControllerAdvice`, `@ExceptionHandler`)**: Core annotations for creating a global exception handler.\n    *   `ApiResponse` (Model): The standard DTO used for all API responses, including errors.\n\n4.  **In-Depth Breakdown**\n\n    *   **`handleValidationExceptions(MethodArgumentNotValidException ex)`**\n        *   **Purpose:** Specifically handles exceptions thrown when `@Valid` validation fails on a request body (DTO).\n        *   **Logic:** It extracts all field validation errors, concatenates them into a single, human-readable message, and returns an `ApiResponse` with an HTTP 400 (Bad Request) status.\n\n    *   **`handleAccessDeniedException(AccessDeniedException ex)`**\n        *   **Purpose:** Handles exceptions thrown by Spring Security when a user, although authenticated, does not have the required permission/authority to access an endpoint (e.g., due to `@PreAuthorize` checks).\n        *   **Logic:** Returns a standard `ApiResponse` with a clear "Access Denied" message and an HTTP 403 (Forbidden) status.\n\n    *   **`handleAllExceptions(Exception ex)`**\n        *   **Purpose:** A catch-all handler for any other unhandled exceptions that may occur within the application.\n        *   **Logic:** It logs the exception (implicitly done by Spring Boot) and returns a generic "internal server error" `ApiResponse` with an HTTP 500 status. It includes the exception message in the data payload for debugging purposes (which might be stripped in a hardened production environment).'),
('src/main/java/de/technikteam/config/LocalDateTimeAdapter.java', '1.  **File Overview & Purpose**\n\n    This is a custom `TypeAdapter` for the Gson library, designed to handle both serialization and deserialization of `java.time.LocalDateTime` objects. It ensures these objects are consistently formatted as ISO 8601 strings (e.g., \"2025-07-25T10:30:00\") in JSON, which is a robust and standard way to exchange date-time information.\n\n2.  **Architectural Role**\n\n    This is a **Configuration** / **Utility** class. It is crucial for the **Web/API Tier** controllers that consume or produce JSON containing `LocalDateTime` objects. A `TypeAdapter` handles both directions of data conversion.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Gson (`com.google.gson.TypeAdapter`)**: The base class from the Gson library for creating custom serialization and deserialization logic.\n    *   `java.time.LocalDateTime`: The modern Java date-time API class this adapter handles.\n\n4.  **In-Depth Breakdown**\n\n    *   **`write(JsonWriter out, LocalDateTime value)`**\n        *   **Method Signature:** `public void write(JsonWriter out, LocalDateTime value) throws IOException`\n        *   **Purpose:** Serializes a `LocalDateTime` object to its JSON string representation.\n        *   **Parameters:**\n            *   `out` (JsonWriter): The Gson stream writer.\n            *   `value` (LocalDateTime): The object to write.\n        *   **Returns:** void.\n        *   **Side Effects:** Writes the ISO-formatted date-time string or `null` to the output JSON stream.\n\n    *   **`read(JsonReader in)`**\n        *   **Method Signature:** `public LocalDateTime read(JsonReader in) throws IOException`\n        *   **Purpose:** Deserializes an ISO-formatted date-time string from JSON into a `LocalDateTime` object.\n        *   **Parameters:**\n            *   `in` (JsonReader): The Gson stream reader.\n        *   **Returns:** A `LocalDateTime` object, or `null` if the JSON value was null.\n        *   **Side Effects:** Reads from the input JSON stream.'),
('src/main/java/de/technikteam/config/GuiceConfig.java', '1.  **File Overview & Purpose**\n\n    This class serves as the central configuration entry point for the Google Guice dependency injection framework. As a `GuiceServletContextListener`, it is automatically invoked by the servlet container on application startup, creating the main Guice `Injector` that will manage the lifecycle of all services, DAOs, and servlets.\n\n2.  **Architectural Role**\n\n    This is a core **Configuration** file that bootstraps the entire application''s architecture. It connects the servlet container''s lifecycle to the Guice dependency injection container.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Guice (`com.google.inject.Guice`)**: The main class from the Guice library used to create the injector.\n    *   **Guice Servlet (`com.google.inject.servlet.GuiceServletContextListener`)**: The base class that integrates Guice with the Jakarta Servlet lifecycle.\n    *   `ServiceModule.java`: The custom module where all the application''s bindings (dependencies) are defined.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getInjector()`**\n        *   **Method Signature:** `protected Injector getInjector()`\n        *   **Purpose:** This is the core method of the `GuiceServletContextListener`. It is called once by the container when the application starts. Its responsibility is to create and return the application''s central `Injector`.\n        *   **Parameters:** None.\n        *   **Returns:** The configured `Injector` instance.\n        *   **Side Effects:** It instantiates the `ServiceModule`, which in turn defines all the dependency injection bindings for the entire application. The returned injector is then stored in the `ServletContext` by the `GuiceFilter` for later use.'),
('src/main/java/de/technikteam/config/LocalDateAdapter.java', '1.  **File Overview & Purpose**\n\n    This is a custom serializer for the Gson library, specifically designed to handle the `java.time.LocalDate` class. Its purpose is to ensure `LocalDate` objects are consistently converted into a standard `YYYY-MM-DD` string format when serializing Java objects to JSON.\n\n2.  **Architectural Role**\n\n    This is a **Configuration** / **Utility** class that operates at the boundary between the **Service/Controller Tiers** and the **View/Client-Side Tier**. It is used by any servlet that needs to serialize data containing `LocalDate` objects into JSON for an API response.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Gson (`com.google.gson.JsonSerializer`)**: The core interface from the Gson library that this class implements to provide custom serialization logic.\n    *   **java.time.LocalDate**: The modern Java Date API class for representing a date without time-of-day.\n\n4.  **In-Depth Breakdown**\n\n    *   **`serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context)`**\n        *   **Method Signature:** `public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context)`\n        *   **Purpose:** This method is called by Gson whenever it encounters a `LocalDate` object during serialization. It formats the date into an ISO standard string.\n        *   **Parameters:**\n            *   `date` (LocalDate): The `LocalDate` object to be serialized.\n            *   `typeOfSrc` (Type): The specific generic type of the source object.\n            *   `context` (JsonSerializationContext): The context for serialization that Gson is using.\n        *   **Returns:** A `JsonPrimitive` containing the date as a string in `YYYY-MM-DD` format (e.g., \"2025-07-25\"), or `null` if the input date is null.\n        *   **Side Effects:** None.'),
('src/main/java/de/technikteam/config/Permissions.java', '1.  **File Overview & Purpose**\n\n    This final class acts as a central, static repository for all permission key constants used in the application. Its primary purpose is to eliminate \"magic strings\" when checking for user permissions, thereby improving code readability, maintainability, and preventing hard-to-find bugs from typos.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Configuration** file. It is used by the **Service Tier** (e.g., `AuthorizationService`), the **Web/Controller Tier** (e.g., `AdminFilter`, servlets), and the **View Tier** (JSPs) to perform consistent permission checks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This class is self-contained.\n\n4.  **In-Depth Breakdown**\n\n    The class contains a series of `public static final String` constants. Each constant represents a specific, granular permission within the system. The constants are grouped by functional area (e.g., User Management, Event Management) for clarity.\n\n    *   **`ACCESS_ADMIN_PANEL`**: The most powerful permission. It grants unrestricted access to all administrative functions, acting as a \"superuser\" or \"root\" key.\n    *   **`USER_*` constants**: Permissions related to creating, reading, updating, deleting, and resetting passwords for user accounts.\n    *   **`EVENT_*` constants**: Permissions for managing events, including creating, editing, deleting, assigning personnel, and managing tasks within an event.\n    *   **`ACHIEVEMENT_VIEW`**: A special key used specifically by the `NavigationRegistry` to determine if the \"Abzeichen\" link should be visible in the admin sidebar. It''s a meta-permission based on having any other achievement-related CRUD permission.\n    *   **`ADMIN_DASHBOARD_ACCESS`**: Another special key for the `NavigationRegistry` that grants visibility to the \"Admin Dashboard\" link if the user has *any* administrative permission.'),
('src/main/java/de/technikteam/config/ServiceModule.java', '1.  **File Overview & Purpose**\n\n    This is the core configuration module for the Google Guice dependency injection framework. It defines all the application''s bindings, instructing Guice how to create and wire together objects. It binds service interfaces to their implementations, registers DAOs as singletons, and maps URL patterns to their corresponding servlets.\n\n2.  **Architectural Role**\n\n    This is a central **Configuration** file that orchestrates the entire application''s object graph. It defines the relationships between the **Web/Controller**, **Service**, and **DAO** tiers.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Guice Servlet (`com.google.inject.servlet.ServletModule`)**: The base class for modules that configure servlets and filters.\n\n4.  **In-Depth Breakdown**\n\n    *   **`configureServlets()`**: This method contains all the binding logic.\n        *   **Service, DAO, and Action Bindings**: The first section uses `bind(ClassName.class).in(Scopes.SINGLETON);` to register all service, DAO, and action classes as singletons. This ensures that only one instance of each of these classes exists throughout the application''s lifecycle, which is crucial for managing shared resources like caches and database connections.\n        *   **Servlet Bindings**: The second section explicitly binds every servlet class in the application as a singleton. This is a prerequisite before they can be mapped to a URL.\n        *   **Servlet Mappings**: The final, large section uses `serve(\"url-pattern\").with(ServletClass.class);` to map URL patterns to the servlets that should handle them. This is the heart of the application''s routing.\n            *   It maps public-facing URLs like `/home` and `/lager`.\n            *   It maps all administrative URLs under `/admin/*`.\n            *   It maps all API endpoints under `/api/*`.\n            *   The `FrontControllerServlet` is mapped to `/admin/action/*` to handle various administrative POST actions using a Command pattern.');
COMMIT;
========================================================================
FILE: src\main\resources\db\migration\V7__Populate_wiki_data_part2.sql
========================================================================

-- Flyway migration V7, Part 2

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/dao/AchievementDAO.java', '1.  **File Overview & Purpose**\n\n    This Data Access Object (DAO) is responsible for all database interactions related to achievements. It handles CRUD (Create, Read, Update, Delete) operations on the `achievements` table and manages the relationship between users and achievements in the `user_achievements` junction table.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It directly interacts with the database to persist and retrieve achievement data. It is exclusively called by the `AchievementService` and administrative servlets like `AdminAchievementServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Used to inject the `DatabaseManager` for obtaining database connections.\n    *   `DatabaseManager`: Provides the connection pool for all database operations.\n    *   `Achievement` (Model): The data model object that this DAO creates and populates.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllAchievements()`**: Retrieves a list of all defined achievement templates from the `achievements` table.\n    *   **`getAchievementById(int id)`**: Fetches a single achievement template by its primary key.\n    *   **`createAchievement(Achievement achievement)`**: Inserts a new achievement template into the `achievements` table.\n    *   **`updateAchievement(Achievement achievement)`**: Updates an existing achievement template''s name, description, or icon. The `achievement_key` is immutable.\n    *   **`deleteAchievement(int id)`**: Deletes an achievement template from the `achievements` table.\n    *   **`getAchievementsForUser(int userId)`**: Retrieves all achievements that a specific user has earned, joining `achievements` and `user_achievements` tables. It also populates the `earnedAt` timestamp.\n    *   **`grantAchievementToUser(int userId, String achievementKey)`**: Grants an achievement to a user by inserting a record into the `user_achievements` table. It first checks if the user already has the achievement to prevent duplicates.\n    *   **`hasAchievement(int userId, String achievementKey)`**: Checks if a user has already earned a specific achievement.\n    *   **`mapResultSetToAchievement(ResultSet rs)`**: A private helper method to map a row from a `ResultSet` to an `Achievement` model object, reducing code duplication.'),
('src/main/java/de/technikteam/dao/AdminLogDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all interactions with the `admin_logs` table. Its sole purpose is to create and retrieve audit log entries, providing a history of administrative actions performed within the application.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It provides a structured way for the `AdminLogService` to persist audit trails to the database.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `AdminLog` (Model): The data model representing a single log entry.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createLog(AdminLog log)`**\n        *   **Method Signature:** `public void createLog(AdminLog log)`\n        *   **Purpose:** Inserts a new log entry into the `admin_logs` table.\n        *   **Parameters:**\n            *   `log` (AdminLog): The log entry object containing the admin''s username, action type, and details.\n        *   **Returns:** void.\n        *   **Side Effects:** Writes a new record to the database. It includes robust error logging to ensure that a failure to log does not crash the primary operation.\n\n    *   **`getAllLogs()`**\n        *   **Method Signature:** `public List<AdminLog> getAllLogs()`\n        *   **Purpose:** Retrieves all log entries from the database, ordered from newest to oldest.\n        *   **Parameters:** None.\n        *   **Returns:** A `List` of `AdminLog` objects.\n        *   **Side Effects:** Performs a database read.\n\n    *   **`getRecentLogs(int limit)`**\n        *   **Method Signature:** `public List<AdminLog> getRecentLogs(int limit)`\n        *   **Purpose:** Retrieves the most recent log entries up to a specified limit. Used for dashboard widgets.\n        *   **Parameters:**\n            *   `limit` (int): The maximum number of log entries to retrieve.\n        *   **Returns:** A `List` of `AdminLog` objects.\n        *   **Side Effects:** Performs a database read with a `LIMIT` clause.'),
('src/main/java/de/technikteam/dao/AttachmentDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for managing file attachments associated with parent entities like Events or Meetings. It provides a unified interface for CRUD operations on the `attachments` table, abstracting away the polymorphic relationship defined by the `parent_type` and `parent_id` columns.\n\n2.  **Architectural Role**\n\n    This is a **DAO (Data Access) Tier** class. It is called by services (`EventService`, `MeetingService`) and servlets (`AdminEventServlet`, `AdminMeetingServlet`) that need to manage attachments for their respective entities.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `Attachment` (Model): The data model object this DAO works with.\n\n4.  **In-Depth Breakdown**\n\n    *   **`addAttachment(Attachment attachment, Connection conn)`**: Inserts a new attachment record into the database within an existing transaction.\n    *   **`getAttachmentsForParent(String parentType, int parentId, String userRole)`**: Retrieves all attachments for a specific parent (e.g., all attachments for Event with ID 5). It filters the results based on the user''s role (`ADMIN` or `NUTZER`), ensuring non-admins cannot see admin-only files.\n    *   **`getAttachmentById(int attachmentId)`**: Fetches a single attachment''s metadata by its unique ID. This is used by the `DownloadServlet` to verify existence and get the file path.\n    *   **`deleteAttachment(int attachmentId)`**: Deletes an attachment record from the database. Note: This does not delete the physical file from the disk; that is the responsibility of the calling service or servlet.\n    *   **`mapResultSetToAttachment(ResultSet rs)`**: A private helper method to convert a database row into an `Attachment` object.'),
('src/main/java/de/technikteam/dao/MaintenanceLogDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database interactions with the `maintenance_log` table. Its purpose is to create and retrieve maintenance history for specific inventory items, tracking actions like repairs or marking an item for maintenance.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `StorageService` and `AdminStorageServlet` to log maintenance activities and by the `StorageItemDetailsServlet` to display an item''s maintenance history.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `MaintenanceLogEntry` (Model): The data model representing a single maintenance log entry.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createLog(MaintenanceLogEntry log)`**\n        *   **Method Signature:** `public boolean createLog(MaintenanceLogEntry log)`\n        *   **Purpose:** Inserts a new maintenance record into the `maintenance_log` table.\n        *   **Parameters:**\n            *   `log` (MaintenanceLogEntry): An object containing the item ID, user ID, action taken, notes, and any associated cost.\n        *   **Returns:** `true` on successful insertion, `false` otherwise.\n        *   **Side Effects:** Writes a new record to the database.\n\n    *   **`getHistoryForItem(int itemId)`**\n        *   **Method Signature:** `public List<MaintenanceLogEntry> getHistoryForItem(int itemId)`\n        *   **Purpose:** Retrieves the complete maintenance history for a specific storage item, ordered from newest to oldest. It joins with the `users` table to get the username of the person who performed the action.\n        *   **Parameters:**\n            *   `itemId` (int): The ID of the storage item.\n        *   **Returns:** A `List` of `MaintenanceLogEntry` objects.\n        *   **Side Effects:** Performs a database read.'),
('src/main/java/de/technikteam/dao/MeetingAttendanceDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO handles all database interactions for the `meeting_attendance` table. It is responsible for tracking which users have attended specific meetings, which is the basis for granting qualifications.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `AdminAttendanceServlet` and `MatrixServlet` to update and display attendance records.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `MeetingAttendance` (Model): The data model representing a user''s attendance at a meeting.\n\n4.  **In-Depth Breakdown**\n\n    *   **`setAttendance(int userId, int meetingId, boolean attended, String remarks)`**\n        *   **Method Signature:** `public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks)`\n        *   **Purpose:** Sets or updates a user''s attendance status for a meeting. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` SQL statement, which allows this single method to handle both initial registration and subsequent changes without needing to check for a pre-existing record.\n        *   **Parameters:** All parameters correspond to the columns in the `meeting_attendance` table.\n        *   **Returns:** `true` on success, `false` on SQL error.\n        *   **Side Effects:** Writes or updates a record in the database.\n\n    *   **`getAllAttendance()`**\n        *   **Method Signature:** `public List<MeetingAttendance> getAllAttendance()`\n        *   **Purpose:** Retrieves all attendance records from the database. This is used by the `MatrixServlet` to build a comprehensive map of all user attendance for display in the qualification matrix.\n        *   **Parameters:** None.\n        *   **Returns:** A `List` of all `MeetingAttendance` objects.\n        *   **Side Effects:** Performs a database read.\n\n    *   **`mapResultSetToAttendance(ResultSet rs)`**: A private helper method to map a database row to a `MeetingAttendance` object.'),
('src/main/java/de/technikteam/dao/MeetingDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations for the `meetings` table. It handles the CRUD lifecycle of individual, schedulable meeting instances, which are always children of a parent `Course`. It also manages user sign-ups for meetings via the `meeting_attendance` table.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is primarily used by the `AdminMeetingServlet` for managing meetings and by public-facing servlets like `MeetingServlet` and `MeetingDetailsServlet` to display meeting information to users.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `Meeting`, `User` (Models): The data models this DAO works with.\n\n4.  **In-Depth Breakdown**\n\n    *   **CRUD Operations (`createMeeting`, `getMeetingById`, `updateMeeting`, `deleteMeeting`)**: Standard methods for managing meeting records. `deleteMeeting` will cascade-delete all associated attendance records.\n    *   **Listing Methods (`getMeetingsForCourse`, `getAllMeetings`, `getAllUpcomingMeetings`)**: Various methods to retrieve lists of meetings, either for a specific course, for all courses, or only upcoming ones for the calendar view. These queries join with `courses` and `users` to enrich the `Meeting` object with the parent course name and leader''s username.\n    *   **User-Specific Queries (`getUpcomingMeetingsForUser`, `isUserAssociatedWithMeeting`)**:\n        *   `getUpcomingMeetingsForUser`: Fetches upcoming meetings for a specific user and calculates their attendance status (`ANGEMELDET`, `ABGEMELDET`, or `OFFEN`) for each.\n        *   `isUserAssociatedWithMeeting`: A simple check to see if a user is signed up for a meeting, used for authorization checks.\n    *   **`mapResultSetToMeeting(ResultSet rs)`**: A private helper to populate a `Meeting` object from a database row, including data from joined tables.'),
('src/main/java/de/technikteam/dao/PasskeyDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all database interactions related to WebAuthn/Passkey credentials. It handles the storage, retrieval, and management of public key credentials in the `user_passkeys` table, which enables passwordless authentication for users.\n\n2.  **Architectural Role**\n\n    This class is a critical component of the **DAO (Data Access) Tier**. It provides the persistence layer for the `PasskeyService`, allowing it to manage the lifecycle of user credentials securely.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `PasskeyCredential` (Model): The data model representing a stored credential.\n\n4.  **In-Depth Breakdown**\n\n    *   **`saveCredential(PasskeyCredential credential)`**: Inserts a new passkey record into the database after a user successfully completes the registration ceremony.\n    *   **`getCredentialsByUserId(int userId)`**: Retrieves all passkeys registered by a specific user. This is used during the authentication process where the server can suggest known credentials to the browser.\n    *   **`getCredentialById(String credentialId)`**: Fetches a single credential by its unique `credential_id` (a Base64URL string). This is the primary lookup method during an authentication ceremony to verify a user''s login attempt.\n    *   **`deleteCredential(int credentialDbId, int userId)`**: Removes a passkey from the database. It requires both the internal database ID and the user''s ID to ensure a user can only delete their own credentials.\n    *   **`updateSignatureCount(String credentialId, long newSignatureCount)`**: Updates the signature counter for a credential after a successful authentication. This is a security measure to help detect cloned authenticators.\n    *   **`mapResultSetToCredential(ResultSet rs)`**: A private helper method to map a database row to a `PasskeyCredential` object.'),
('src/main/java/de/technikteam/dao/PermissionDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO provides read-only access to the application''s permission system. Its primary responsibilities are to fetch all available permission definitions from the `permissions` table and to retrieve the specific set of permissions granted to an individual user from the `user_permissions` junction table.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `UserDAO` to populate a `User` object with their complete set of permissions upon login, and by the `AdminUserServlet` to display the list of all possible permissions in the user editing modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `Permission` (Model): The data model representing a single permission definition.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllPermissions()`**\n        *   **Method Signature:** `public List<Permission> getAllPermissions()`\n        *   **Purpose:** Retrieves a complete list of all permissions defined in the system.\n        *   **Parameters:** None.\n        *   **Returns:** A `List` of `Permission` objects.\n        *   **Side Effects:** Performs a database read on the `permissions` table.\n\n    *   **`getPermissionIdsForUser(int userId)`**\n        *   **Method Signature:** `public Set<Integer> getPermissionIdsForUser(int userId)`\n        *   **Purpose:** Fetches the set of primary key IDs for all permissions directly assigned to a specific user.\n        *   **Parameters:**\n            *   `userId` (int): The ID of the user.\n        *   **Returns:** A `Set` of integer permission IDs.\n        *   **Side Effects:** Performs a database read on the `user_permissions` table.'),
('src/main/java/de/technikteam/dao/ProfileChangeRequestDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages the lifecycle of user profile change requests. It handles all database operations for the `profile_change_requests` table, including creating new requests, fetching pending requests for administrators, and updating their status upon approval or denial.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `ProfileServlet` when a user submits a change request and by the `AdminChangeRequestServlet` and its associated `Action` classes (`ApproveChangeAction`, `DenyChangeAction`) for processing these requests.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `ProfileChangeRequest` (Model): The data model for a change request.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createRequest(ProfileChangeRequest request)`**: Inserts a new profile change request into the database with a ''PENDING'' status.\n    *   **`getRequestById(int id)`**: Retrieves a single request by its ID, joining with the `users` table to get the requester''s and reviewer''s usernames.\n    *   **`getPendingRequests()`**: Fetches all requests that currently have a ''PENDING'' status, for display on the admin requests page.\n    *   **`hasPendingRequest(int userId)`**: A quick check to determine if a user already has a pending request, used to prevent them from submitting multiple requests.\n    *   **`updateRequestStatus(int requestId, String status, int adminId)`**: Updates a request''s status to ''APPROVED'' or ''DENIED'', and records which admin reviewed it and when.\n    *   **`mapResultSetToRequest(ResultSet rs)`**: A private helper method to map a database row to a `ProfileChangeRequest` object.'),
('src/main/java/de/technikteam/dao/ReportDAO.java', '1.  **File Overview & Purpose**\n\n    This is a specialized DAO designed for generating analytical reports and summaries. Unlike other DAOs that focus on CRUD operations for single entities, this class contains complex, aggregate SQL queries that summarize data across multiple tables for administrative dashboards and dedicated report pages.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `AdminReportServlet` and `AdminDashboardService` to fetch data for visualization and export. It encapsulates the most complex SQL logic in the application.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getEventParticipationSummary()`**: Calculates the number of assigned participants for each event.\n    *   **`getUserActivityStats()`**: Aggregates statistics for each user, counting how many events they''ve signed up for and how many meetings they''ve attended.\n    *   **`getInventoryUsageFrequency()`**: Calculates the total number of times each inventory item has been checked out.\n    *   **`getTotalInventoryValue()`**: Calculates the total monetary value of all items in stock by multiplying quantity by price.\n    *   **`getEventCountByMonth(int months)`**: Generates a time-series dataset of how many events occurred each month over a given period, used for the trend chart on the dashboard.\n    *   **`getUserParticipationStats(int limit)`**: Retrieves the top N most active users based on the number of events they have been assigned to.');
COMMIT;