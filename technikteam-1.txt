
========================================================================
FILE: src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventTaskDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds) {
		boolean isUpdate = task.getId() > 0;
		if (isUpdate) {
			updateTask(task);
		} else {
			int newId = createTask(task);
			task.setId(newId);
		}

		if (task.getId() == 0) {
			throw new RuntimeException("Failed to create or find task ID.");
		}

		clearAssociations(task.getId());
		saveUserAssignments(task.getId(), userIds);
		saveItemRequirements(task.getId(), itemIds, itemQuantities);
		saveKitRequirements(task.getId(), kitIds);

		logger.info("Successfully saved task ID {}", task.getId());
		return task.getId();
	}

	private int createTask(EventTask task) {
		String taskSql = "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, task.getEventId());
			ps.setString(2, task.getDescription());
			ps.setString(3, task.getDetails());
			ps.setInt(4, task.getDisplayOrder());
			ps.setInt(5, task.getRequiredPersons());
			return ps;
		}, keyHolder);
		return Objects.requireNonNull(keyHolder.getKey()).intValue();
	}

	private void updateTask(EventTask task) {
		String taskSql = "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?";
		jdbcTemplate.update(taskSql, task.getDescription(), task.getDetails(), task.getStatus(), task.getDisplayOrder(),
				task.getRequiredPersons(), task.getId());
	}

	private void clearAssociations(int taskId) {
		jdbcTemplate.update("DELETE FROM event_task_assignments WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_storage_items WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_kits WHERE task_id = ?", taskId);
	}

	private void saveUserAssignments(int taskId, int[] userIds) {
		if (userIds == null || userIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		List<Integer> userIdList = Arrays.stream(userIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, userIdList, 100, (ps, userId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, userId);
		});
	}

	private void saveItemRequirements(int taskId, String[] itemIds, String[] itemQuantities) {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;
		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		List<String> itemIdList = List.of(itemIds);
		jdbcTemplate.batchUpdate(sql, itemIdList, 100, (ps, itemIdStr) -> {
			if (itemIdStr != null && !itemIdStr.isEmpty()) {
				int index = itemIdList.indexOf(itemIdStr);
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(itemIdStr));
				ps.setInt(3, Integer.parseInt(itemQuantities[index]));
			}
		});
	}

	private void saveKitRequirements(int taskId, String[] kitIds) {
		if (kitIds == null || kitIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		List<String> kitIdList = List.of(kitIds);
		jdbcTemplate.batchUpdate(sql, kitIdList, 100, (ps, kitIdStr) -> {
			if (kitIdStr != null && !kitIdStr.isEmpty()) {
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(kitIdStr));
			}
		});
	}

	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, u.id as user_id, u.username, si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, ik.id as kit_id, ik.name as kit_name FROM event_tasks t LEFT JOIN event_task_assignments ta ON t.id = ta.task_id LEFT JOIN users u ON ta.user_id = u.id LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id LEFT JOIN storage_items si ON tsi.item_id = si.id LEFT JOIN event_task_kits tk ON t.id = tk.task_id LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id WHERE t.event_id = ? ORDER BY t.display_order ASC, t.id ASC, u.username, si.name, ik.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int currentTaskId = rs.getInt("id");
			EventTask task = tasksById.computeIfAbsent(currentTaskId, id -> mapResultSetToTask(rs));

			int currentUserId = rs.getInt("user_id");
			if (currentUserId > 0 && task.getAssignedUsers().stream().noneMatch(u -> u.getId() == currentUserId)) {
				User user = new User();
				user.setId(currentUserId);
				user.setUsername(rs.getString("username"));
				task.getAssignedUsers().add(user);
			}
			int currentItemId = rs.getInt("item_id");
			if (currentItemId > 0 && task.getRequiredItems().stream().noneMatch(i -> i.getId() == currentItemId)) {
				StorageItem item = new StorageItem();
				item.setId(currentItemId);
				item.setName(rs.getString("item_name"));
				item.setQuantity(rs.getInt("item_quantity"));
				task.getRequiredItems().add(item);
			}
			int currentKitId = rs.getInt("kit_id");
			if (currentKitId > 0 && task.getRequiredKits().stream().noneMatch(k -> k.getId() == currentKitId)) {
				InventoryKit kit = new InventoryKit();
				kit.setId(currentKitId);
				kit.setName(rs.getString("kit_name"));
				task.getRequiredKits().add(kit);
			}
		}, eventId);

		return new ArrayList<>(tasksById.values());
	}

	private EventTask mapResultSetToTask(ResultSet rs) {
		try {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setDetails(rs.getString("details"));
			task.setStatus(rs.getString("status"));
			task.setDisplayOrder(rs.getInt("display_order"));
			task.setRequiredPersons(rs.getInt("required_persons"));
			task.setAssignedUsers(new ArrayList<>());
			task.setRequiredItems(new ArrayList<>());
			task.setRequiredKits(new ArrayList<>());
			return task;
		} catch (SQLException e) {
			throw new RuntimeException("Failed to map ResultSet to EventTask", e);
		}
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, taskId) > 0;
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		String sql = "SELECT t.*, e.name as event_name FROM event_tasks t JOIN event_task_assignments ta ON t.id = ta.task_id JOIN events e ON t.event_id = e.id WHERE ta.user_id = ? AND t.status = 'OFFEN' ORDER BY e.event_datetime ASC";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setStatus(rs.getString("status"));
			task.setEventName(rs.getString("event_name"));
			return task;
		}, userId);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\FeedbackSubmissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackSubmission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class FeedbackSubmissionDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackSubmissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FeedbackSubmissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<FeedbackSubmission> submissionRowMapper = (rs, rowNum) -> {
		FeedbackSubmission sub = new FeedbackSubmission();
		sub.setId(rs.getInt("id"));
		sub.setUserId(rs.getInt("user_id"));
		sub.setUsername(rs.getString("username"));
		sub.setSubject(rs.getString("subject"));
		sub.setDisplayTitle(rs.getString("display_title"));
		sub.setContent(rs.getString("content"));
		sub.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		sub.setStatus(rs.getString("status"));
		sub.setDisplayOrder(rs.getInt("display_order"));
		return sub;
	};

	public boolean createSubmission(FeedbackSubmission submission) {
		String sql = "INSERT INTO feedback_submissions (user_id, subject, content) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, submission.getUserId(), submission.getSubject(),
					submission.getContent()) > 0;
		} catch (Exception e) {
			logger.error("Error creating feedback submission for user {}", submission.getUserId(), e);
			return false;
		}
	}

	public List<FeedbackSubmission> getAllSubmissions() {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id ORDER BY FIELD(fs.status, 'NEW', 'VIEWED', 'PLANNED', 'REJECTED', 'COMPLETED'), fs.display_order ASC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all feedback submissions", e);
			return List.of();
		}
	}

	public FeedbackSubmission getSubmissionById(int submissionId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, submissionRowMapper, submissionId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback submission by ID {}", submissionId, e);
			return null;
		}
	}

	public List<FeedbackSubmission> getSubmissionsByUserId(int userId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.user_id = ? ORDER BY fs.submitted_at DESC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching feedback submissions for user {}", userId, e);
			return List.of();
		}
	}

	public boolean updateStatusAndTitle(int submissionId, String newStatus, String displayTitle) {
		String sql = "UPDATE feedback_submissions SET status = ?, display_title = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, newStatus, displayTitle, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status and title for submission {}", submissionId, e);
			return false;
		}
	}

	public boolean deleteSubmission(int submissionId) {
		String sql = "DELETE FROM feedback_submissions WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting submission {}", submissionId, e);
			return false;
		}
	}

}
========================================================================
FILE: src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FileDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<File> fileRowMapper = (rs, rowNum) -> {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));
		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}
		if (DaoUtils.hasColumn(rs, "category_name")) {
			file.setCategoryName(
					rs.getString("category_name") == null ? "Ohne Kategorie" : rs.getString("category_name"));
		} else {
			file.setCategoryName("Ohne Kategorie");
		}
		return file;
	};

	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		List<File> files = getAllFiles(user);
		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	public List<File> getAllFiles(User user) {
		StringBuilder sql = new StringBuilder(
				"SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id ");
		if (!user.hasAdminAccess()) {
			sql.append("WHERE f.required_role = 'NUTZER' ");
		}
		sql.append("ORDER BY fc.name, f.filename");

		try {
			return jdbcTemplate.query(sql.toString(), fileRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching files.", e);
			return List.of();
		}
	}

	public int createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, file.getFilename());
				ps.setString(2, file.getFilepath());
				if (file.getCategoryId() > 0) {
					ps.setInt(3, file.getCategoryId());
				} else {
					ps.setNull(3, Types.INTEGER);
				}
				ps.setString(4, file.getRequiredRole());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating file record for '{}'", file.getFilename(), e);
			return 0;
		}
	}

	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	public boolean reassignFileToCategory(int fileId, int categoryId) {
		String sql = "UPDATE files SET category_id = ? WHERE id = ?";
		try {
			Object newCategoryId = categoryId > 0 ? categoryId : null;
			return jdbcTemplate.update(sql, newCategoryId, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error reassigning file {} to category {}", fileId, categoryId, e);
			return false;
		}
	}

	public List<FileCategory> getAllCategories() {
		String sql = "SELECT * FROM file_categories ORDER BY name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				return cat;
			});
		} catch (Exception e) {
			logger.error("Error fetching file categories.", e);
			return List.of();
		}
	}

	public File getFileById(int fileId) {
		String sql = "SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id WHERE f.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, fileRowMapper, fileId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error while fetching file with ID: {}", fileId, e);
			return null;
		}
	}

	public boolean deleteFile(int fileId) {
		String sql = "DELETE FROM files WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	public boolean createCategory(String categoryName) {
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try {
			return jdbcTemplate.update(sql, categoryName) > 0;
		} catch (Exception e) {
			logger.error("Error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	public boolean deleteCategory(int categoryId) {
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try {
			// First, un-assign files from this category
			jdbcTemplate.update("UPDATE files SET category_id = NULL WHERE category_id = ?", categoryId);
			return jdbcTemplate.update(sql, categoryId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, String.class, categoryId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public InventoryKitDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<InventoryKit> kitRowMapper = (rs, rowNum) -> {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>());
		return kit;
	};

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, kit.getName());
				ps.setString(2, kit.getDescription());
				ps.setString(3, kit.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
			return 0;
		}
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, kit.getName(), kit.getDescription(), kit.getLocation(), kit.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, kitRowMapper, kitId);
		} catch (EmptyResultDataAccessException e) {
			return null; // Expected case when not found
		} catch (Exception e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
			return null;
		}
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try {
			// First, delete dependencies in the linking table
			jdbcTemplate.update("DELETE FROM inventory_kit_items WHERE kit_id = ?", kitId);
			// Then, delete the kit itself
			return jdbcTemplate.update(sql, kitId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, ki.item_id, ki.quantity, si.name as item_name FROM inventory_kits k LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id LEFT JOIN storage_items si ON ki.item_id = si.id ORDER BY k.name, si.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int kitId = rs.getInt("id");
			InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
				try {
					return kitRowMapper.mapRow(rs, 0);
				} catch (SQLException e) {
					// This is a safe way to handle checked exceptions within a lambda
					throw new RuntimeException("Failed to map ResultSet to InventoryKit", e);
				}
			});
			if (rs.getInt("item_id") > 0) {
				InventoryKitItem item = new InventoryKitItem();
				item.setKitId(kitId);
				item.setItemId(rs.getInt("item_id"));
				item.setQuantity(rs.getInt("quantity"));
				item.setItemName(rs.getString("item_name"));
				kit.getItems().add(item);
			}
		});
		return new ArrayList<>(kitMap.values());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MaintenanceLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, log.getItemId(), log.getUserId(), log.getAction(), log.getNotes(),
					log.getCost()) > 0;
		} catch (Exception e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml JOIN users u ON ml.user_id = u.id WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MaintenanceLogEntry entry = new MaintenanceLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
				entry.setAction(rs.getString("action"));
				entry.setNotes(rs.getString("notes"));
				entry.setCost(rs.getDouble("cost"));
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingAttendanceDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";
		try {
			jdbcTemplate.update(sql, userId, meetingId, attended, remarks);
			return true;
		} catch (Exception e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	public List<MeetingAttendance> getAllAttendance() {
		String sql = "SELECT * FROM meeting_attendance";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MeetingAttendance attendance = new MeetingAttendance();
				attendance.setUserId(rs.getInt("user_id"));
				attendance.setMeetingId(rs.getInt("meeting_id"));
				attendance.setAttended(rs.getBoolean("attended"));
				attendance.setRemarks(rs.getString("remarks"));
				return attendance;
			});
		} catch (Exception e) {
			logger.error("SQL error fetching all attendance records.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Meeting> meetingRowMapper = (rs, rowNum) -> {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null)
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));
		return meeting;
	};

	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, meeting.getCourseId());
				ps.setString(2, meeting.getName());
				ps.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
				if (meeting.getEndDateTime() != null)
					ps.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
				else
					ps.setNull(4, Types.TIMESTAMP);
				if (meeting.getLeaderUserId() > 0)
					ps.setInt(5, meeting.getLeaderUserId());
				else
					ps.setNull(5, Types.INTEGER);
				ps.setString(6, meeting.getDescription());
				ps.setString(7, meeting.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating meeting: {}", meeting.getName(), e);
			return 0;
		}
	}

	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, meetingRowMapper, meetingId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching meeting by ID: {}", meetingId, e);
			return null;
		}
	}

	public List<Meeting> getMeetingsForCourse(int courseId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, courseId);
		} catch (Exception e) {
			logger.error("Error fetching meetings for course ID: {}", courseId, e);
			return List.of();
		}
	}

	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, meeting.getName(), Timestamp.valueOf(meeting.getMeetingDateTime()),
					meeting.getEndDateTime() != null ? Timestamp.valueOf(meeting.getEndDateTime()) : null,
					meeting.getLeaderUserId() > 0 ? meeting.getLeaderUserId() : null, meeting.getDescription(),
					meeting.getLocation(), meeting.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		try {
			jdbcTemplate.update("DELETE FROM meeting_attendance WHERE meeting_id = ?", meetingId);
			return jdbcTemplate.update(sql, meetingId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Meeting meeting = meetingRowMapper.mapRow(rs, rowNum);
				if (rs.getObject("attended") != null) {
					meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
				} else {
					meeting.setUserAttendanceStatus("OFFEN");
				}
				return meeting;
			}, user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for user {}", user.getId(), e);
			return List.of();
		}
	}

	public List<Meeting> getAllUpcomingMeetings() {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
		String sql = "SELECT COUNT(*) FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, meetingId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PasskeyDAO.java
========================================================================

package de.technikteam.dao;

import com.yubico.webauthn.CredentialRepository;
import com.yubico.webauthn.RegisteredCredential;
import com.yubico.webauthn.data.ByteArray;
import com.yubico.webauthn.data.PublicKeyCredentialDescriptor;
import com.yubico.webauthn.data.UserIdentity;
import de.technikteam.model.PasskeyCredential;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

@Repository
public class PasskeyDAO implements CredentialRepository {
	private static final Logger logger = LogManager.getLogger(PasskeyDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PasskeyDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<PasskeyCredential> credentialRowMapper = (rs, rowNum) -> new PasskeyCredential(
			rs.getInt("id"), rs.getInt("user_id"), rs.getString("name"), rs.getString("user_handle"),
			rs.getString("credential_id"), rs.getString("public_key"), rs.getLong("signature_count"),
			rs.getTimestamp("created_at").toLocalDateTime());

	public boolean saveCredential(PasskeyCredential credential) {
		String sql = "INSERT INTO user_passkeys (user_id, name, user_handle, credential_id, public_key, signature_count) VALUES (?, ?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, credential.getUserId(), credential.getName(), credential.getUserHandle(),
					credential.getCredentialId(), credential.getPublicKey(), credential.getSignatureCount()) > 0;
		} catch (Exception e) {
			logger.error("Error saving passkey credential for user {}", credential.getUserId(), e);
			return false;
		}
	}

	public List<PasskeyCredential> getCredentialsByUserId(int userId) {
		String sql = "SELECT * FROM user_passkeys WHERE user_id = ?";
		try {
			return jdbcTemplate.query(sql, credentialRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error retrieving passkey credentials for user {}", userId, e);
			return List.of();
		}
	}

	public Optional<PasskeyCredential> getCredentialByCredentialId(ByteArray credentialId) {
		String sql = "SELECT * FROM user_passkeys WHERE credential_id = ?";
		try {
			return Optional
					.ofNullable(jdbcTemplate.queryForObject(sql, credentialRowMapper, credentialId.getBase64Url()));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error retrieving credential by ID", e);
			return Optional.empty();
		}
	}

	public boolean deleteCredential(int credentialDbId, int userId) {
		String sql = "DELETE FROM user_passkeys WHERE id = ? AND user_id = ?";
		try {
			return jdbcTemplate.update(sql, credentialDbId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting credential ID {} for user {}", credentialDbId, userId, e);
			return false;
		}
	}

	public boolean updateSignatureCount(ByteArray credentialId, long newSignatureCount) {
		String sql = "UPDATE user_passkeys SET signature_count = ? WHERE credential_id = ?";
		try {
			return jdbcTemplate.update(sql, newSignatureCount, credentialId.getBase64Url()) > 0;
		} catch (Exception e) {
			logger.error("Error updating signature count for credential", e);
			return false;
		}
	}

	@Override
	public Set<RegisteredCredential> getCredentialsByUserHandle(ByteArray userHandle) {
		String sql = "SELECT * FROM user_passkeys WHERE user_handle = ?";
		List<PasskeyCredential> creds = jdbcTemplate.query(sql, credentialRowMapper, userHandle.getBase64Url());
		return creds.stream()
				.map(dbCred -> RegisteredCredential.builder()
						.credentialId(ByteArray.fromBase64Url(dbCred.getCredentialId()))
						.userHandle(ByteArray.fromBase64Url(dbCred.getUserHandle()))
						.publicKeyCose(ByteArray.fromBase64Url(dbCred.getPublicKey()))
						.signatureCount(dbCred.getSignatureCount()).build())
				.collect(Collectors.toSet());
	}

	@Override
	public Optional<RegisteredCredential> getCredentialById(ByteArray credentialId) {
		return getCredentialByCredentialId(credentialId).map(
				dbCred -> RegisteredCredential.builder().credentialId(ByteArray.fromBase64Url(dbCred.getCredentialId()))
						.userHandle(ByteArray.fromBase64Url(dbCred.getUserHandle()))
						.publicKeyCose(ByteArray.fromBase64Url(dbCred.getPublicKey()))
						.signatureCount(dbCred.getSignatureCount()).build());
	}

	@Override
	public Optional<String> getUsernameForUserHandle(ByteArray userHandle) {
		String sql = "SELECT u.username FROM users u JOIN user_passkeys up ON u.id = up.user_id WHERE up.user_handle = ? LIMIT 1";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, String.class, userHandle.getBase64Url()));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	@Override
	public Optional<UserIdentity> getUserIdentityByUserHandle(ByteArray userHandle) {
		String sql = "SELECT u.username FROM users u JOIN user_passkeys up ON u.id = up.user_id WHERE up.user_handle = ? LIMIT 1";
		try {
			return Optional
					.ofNullable(jdbcTemplate.queryForObject(sql,
							(rs, rowNum) -> UserIdentity.builder().name(rs.getString("username"))
									.displayName(rs.getString("username")).id(userHandle).build(),
							userHandle.getBase64Url()));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	@Override
	public Set<RegisteredCredential> getCredentialsByUsername(String username) {
		String sql = "SELECT up.* FROM user_passkeys up JOIN users u ON up.user_id = u.id WHERE u.username = ?";
		List<PasskeyCredential> dbCreds = jdbcTemplate.query(sql, credentialRowMapper, username);
		return dbCreds.stream()
				.map(dbCred -> RegisteredCredential.builder()
						.credentialId(ByteArray.fromBase64Url(dbCred.getCredentialId()))
						.userHandle(ByteArray.fromBase64Url(dbCred.getUserHandle()))
						.publicKeyCose(ByteArray.fromBase64Url(dbCred.getPublicKey()))
						.signatureCount(dbCred.getSignatureCount()).build())
				.collect(Collectors.toSet());
	}

	@Override
	public Optional<ByteArray> getUserHandleForUsername(String username) {
		String sql = "SELECT up.user_handle FROM user_passkeys up JOIN users u ON up.user_id = u.id WHERE u.username = ? LIMIT 1";
		try {
			String handle = jdbcTemplate.queryForObject(sql, String.class, username);
			return Optional.ofNullable(handle).map(ByteArray::fromBase64Url);
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	@Override
	public Set<PublicKeyCredentialDescriptor> getCredentialIdsForUsername(String username) {
		String sql = "SELECT up.credential_id FROM user_passkeys up JOIN users u ON up.user_id = u.id WHERE u.username = ?";
		return jdbcTemplate.queryForList(sql, String.class, username).stream().map(ByteArray::fromBase64Url)
				.map(id -> PublicKeyCredentialDescriptor.builder().id(id).build()).collect(Collectors.toSet());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Repository
public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PermissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Permission> getAllPermissions() {
		String sql = "SELECT * FROM permissions ORDER BY description";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				return p;
			});
		} catch (Exception e) {
			logger.error("Error fetching all permissions", e);
			return List.of();
		}
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try {
			List<Integer> ids = jdbcTemplate.queryForList(sql, Integer.class, userId);
			return new HashSet<>(ids);
		} catch (Exception e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
			return Set.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ProfileChangeRequestDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ProfileChangeRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ProfileChangeRequestDAO {
	private static final Logger logger = LogManager.getLogger(ProfileChangeRequestDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ProfileChangeRequestDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ProfileChangeRequest> requestRowMapper = (rs, rowNum) -> {
		ProfileChangeRequest request = new ProfileChangeRequest();
		request.setId(rs.getInt("id"));
		request.setUserId(rs.getInt("user_id"));
		request.setRequestedChanges(rs.getString("requested_changes"));
		request.setStatus(rs.getString("status"));
		request.setRequestedAt(rs.getTimestamp("requested_at").toLocalDateTime());
		request.setUsername(rs.getString("username"));
		if (rs.getObject("reviewed_by_admin_id") != null) {
			request.setReviewedByAdminId(rs.getInt("reviewed_by_admin_id"));
		}
		if (rs.getTimestamp("reviewed_at") != null) {
			request.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		if (rs.getMetaData().getColumnCount() > 8) { // Simple check if admin_username is present
			request.setReviewedByAdminName(rs.getString("admin_username"));
		}
		return request;
	};

	public boolean createRequest(ProfileChangeRequest request) {
		String sql = "INSERT INTO profile_change_requests (user_id, requested_changes, status) VALUES (?, ?, 'PENDING')";
		try {
			return jdbcTemplate.update(sql, request.getUserId(), request.getRequestedChanges()) > 0;
		} catch (Exception e) {
			logger.error("Error creating profile change request for user {}", request.getUserId(), e);
			return false;
		}
	}

	public ProfileChangeRequest getRequestById(int id) {
		String sql = "SELECT pcr.*, u.username as username, a.username as admin_username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id LEFT JOIN users a ON pcr.reviewed_by_admin_id = a.id WHERE pcr.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, requestRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching request by ID {}", id, e);
			return null;
		}
	}

	public List<ProfileChangeRequest> getPendingRequests() {
		String sql = "SELECT pcr.*, u.username as username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id WHERE pcr.status = 'PENDING' ORDER BY pcr.requested_at ASC";
		try {
			return jdbcTemplate.query(sql, requestRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching pending requests", e);
			return List.of();
		}
	}

	public boolean hasPendingRequest(int userId) {
		String sql = "SELECT COUNT(*) FROM profile_change_requests WHERE user_id = ? AND status = 'PENDING'";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for pending request for user {}", userId, e);
			return false;
		}
	}

	public boolean updateRequestStatus(int requestId, String status, int adminId) {
		String sql = "UPDATE profile_change_requests SET status = ?, reviewed_by_admin_id = ?, reviewed_at = NOW() WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, status, adminId, requestId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status for request {}", requestId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Map<String, Object>> getEventParticipationSummary() {
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating event participation summary.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserActivityStats() {
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating user activity stats.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating inventory usage frequency report.", e);
			return List.of();
		}
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		try {
			Double totalValue = jdbcTemplate.queryForObject(sql, Double.class);
			return totalValue != null ? totalValue : 0.0;
		} catch (Exception e) {
			logger.error("Error calculating total inventory value.", e);
			return 0.0;
		}
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		String sql = "SELECT DATE_FORMAT(event_datetime, '%Y-%m') AS month, COUNT(*) AS count " + "FROM events "
				+ "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), months);
		} catch (Exception e) {
			logger.error("Error generating event count by month report.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), limit);
		} catch (Exception e) {
			logger.error("Error generating user participation stats.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.concurrent.TimeUnit;

@Repository
public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);
	private final JdbcTemplate jdbcTemplate;
	private final LoadingCache<String, List<Role>> roleCache;
	private static final String ALL_ROLES_KEY = "ALL_ROLES";

	@Autowired
	public RoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.roleCache = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.HOURS).maximumSize(1)
				.build(key -> fetchAllRolesFromDb());
	}

	public List<Role> getAllRoles() {
		logger.debug("Fetching all roles from cache.");
		return roleCache.get(ALL_ROLES_KEY);
	}

	private List<Role> fetchAllRolesFromDb() {
		logger.info("Cache miss for roles. Fetching all roles from database.");
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				return role;
			});
		} catch (Exception e) {
			logger.error("Error fetching all roles from DB", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StatisticsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int getUserCount() {
		return getCount("SELECT COUNT(*) FROM users");
	}

	public int getActiveEventCount() {
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	private int getCount(String sql) {
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
			return count != null ? count : 0;
		} catch (Exception e) {
			logger.error("SQL error executing count query: {}", sql, e);
			return 0;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Repository
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<StorageItem> storageItemRowMapper = (rs, rowNum) -> {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	};

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream()
				.collect(Collectors.groupingBy(
						item -> item.getLocation() != null && !item.getLocation().isBlank() ? item.getLocation().trim()
								: "Unbekannt"));
	}

	public List<StorageItem> getAllItems() {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id ORDER BY si.location, si.name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all storage items.", e);
			return List.of();
		}
	}

	public List<StorageItem> getDefectiveItems() {
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching defective items.", e);
			return List.of();
		}
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id WHERE si.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, storageItemRowMapper, itemId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching storage item by ID: {}", itemId, e);
			return null;
		}
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try {
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getWeightKg(),
					item.getPriceEur(), item.getImagePath()) > 0;
		} catch (Exception e) {
			logger.error("Error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try {
			Object holderId = item.getCurrentHolderUserId() > 0 ? item.getCurrentHolderUserId() : null;
			Object eventId = item.getAssignedEventId() > 0 ? item.getAssignedEventId() : null;
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getDefectiveQuantity(),
					item.getDefectReason(), item.getWeightKg(), item.getPriceEur(), item.getImagePath(),
					item.getStatus(), holderId, eventId, item.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, itemId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public List<StorageItem> getLowStockItems(int limit) {
		String sql = "SELECT * FROM storage_items WHERE (quantity - defective_quantity) < (max_quantity * 0.25) AND max_quantity > 0 ORDER BY (quantity - defective_quantity) / max_quantity ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error while fetching low stock items.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;

@Repository
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		try {
			Object eventIdObj = eventId > 0 ? eventId : null;
			int[] types = { Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.VARCHAR, Types.INTEGER };
			return jdbcTemplate.update(sql, new Object[] { itemId, userId, quantityChange, notes, eventIdObj },
					types) > 0;
		} catch (Exception e) {
			logger.error("Error logging storage transaction for item {}", itemId, e);
			return false;
		}
	}

	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT sl.*, u.username FROM storage_log sl JOIN users u ON sl.user_id = u.id WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageLogEntry entry = new StorageLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setQuantityChange(rs.getInt("quantity_change"));
				entry.setNotes(rs.getString("notes"));
				entry.setEventId(rs.getInt("event_id"));
				entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\TodoDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Repository
public class TodoDAO {
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public TodoDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<TodoCategory> getAllCategoriesWithTasks() {
		Map<Integer, TodoCategory> categoryMap = new LinkedHashMap<>();
		String sql = "SELECT c.id as cat_id, c.name as cat_name, c.display_order as cat_order, "
				+ "t.id as task_id, t.category_id as task_cat_id, t.content as task_content, "
				+ "t.is_completed as task_completed, t.display_order as task_order "
				+ "FROM todo_categories c LEFT JOIN todo_tasks t ON c.id = t.category_id "
				+ "ORDER BY c.display_order, t.display_order";

		jdbcTemplate.query(sql, rs -> {
			int categoryId = rs.getInt("cat_id");
			TodoCategory category = categoryMap.computeIfAbsent(categoryId, id -> {
				try {
					TodoCategory newCat = new TodoCategory();
					newCat.setId(id);
					newCat.setName(rs.getString("cat_name"));
					newCat.setDisplayOrder(rs.getInt("cat_order"));
					return newCat;
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			});

			if (rs.getObject("task_id") != null) {
				TodoTask task = new TodoTask();
				task.setId(rs.getInt("task_id"));
				task.setCategoryId(rs.getInt("task_cat_id"));
				task.setContent(rs.getString("task_content"));
				task.setCompleted(rs.getBoolean("task_completed"));
				task.setDisplayOrder(rs.getInt("task_order"));
				category.getTasks().add(task);
			}
		});
		return new ArrayList<>(categoryMap.values());
	}

	public TodoCategory createCategory(String name) {
		String sql = "INSERT INTO todo_categories (name, display_order) "
				+ "SELECT ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_categories";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoCategory newCategory = new TodoCategory();
		newCategory.setId(newId);
		newCategory.setName(name);
		return newCategory;
	}

	public TodoTask createTask(int categoryId, String content) {
		String sql = "INSERT INTO todo_tasks (category_id, content, display_order) "
				+ "SELECT ?, ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_tasks WHERE category_id = ?";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, categoryId);
			ps.setString(2, content);
			ps.setInt(3, categoryId);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoTask newTask = new TodoTask();
		newTask.setId(newId);
		newTask.setCategoryId(categoryId);
		newTask.setContent(content);
		return newTask;
	}

	public boolean updateTaskContent(int taskId, String content) {
		String sql = "UPDATE todo_tasks SET content = ? WHERE id = ?";
		return jdbcTemplate.update(sql, content, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, boolean isCompleted) {
		String sql = "UPDATE todo_tasks SET is_completed = ? WHERE id = ?";
		return jdbcTemplate.update(sql, isCompleted, taskId) > 0;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM todo_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean deleteCategory(int categoryId) {
		jdbcTemplate.update("DELETE FROM todo_tasks WHERE category_id = ?", categoryId);
		String sql = "DELETE FROM todo_categories WHERE id = ?";
		return jdbcTemplate.update(sql, categoryId) > 0;
	}

	public void updateCategoryOrder(List<Integer> categoryIds) {
		String sql = "UPDATE todo_categories SET display_order = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, categoryIds, 100, (ps, categoryId) -> {
			ps.setInt(1, categoryIds.indexOf(categoryId));
			ps.setInt(2, categoryId);
		});
	}

	public void updateTaskOrders(List<Integer> taskIds, int categoryId) {
		String sql = "UPDATE todo_tasks SET display_order = ?, category_id = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, taskIds, 100, (ps, taskId) -> {
			ps.setInt(1, taskIds.indexOf(taskId));
			ps.setInt(2, categoryId);
			ps.setInt(3, taskId);
		});
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.*;

@Repository
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<User> userRowMapper = (resultSet, rowNum) -> {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		user.setPasswordHash(resultSet.getString("password_hash"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "profile_picture_path")) {
			user.setProfilePicturePath(resultSet.getString("profile_picture_path"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	};

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, this.userRowMapper, username);
			String storedHash = user.getPasswordHash();

			if (storedHash != null && passwordEncoder.matches(password, storedHash)) {
				user.setPermissions(getPermissionsForUser(user.getId()));
				return user;
			}
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, username);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(user.getId()));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by username: {}", username, e);
			return null;
		}
	}

	public Set<String> getPermissionsForUser(int userId) {
		String sql = "SELECT p.permission_key FROM permissions p JOIN user_permissions up ON p.id = up.permission_id WHERE up.user_id = ?";
		try {
			return new HashSet<>(jdbcTemplate.queryForList(sql, String.class, userId));
		} catch (Exception e) {
			logger.error("Could not fetch permissions for user ID: {}", userId, e);
			return new HashSet<>();
		}
	}

	public boolean updateUserPermissions(int userId, String[] permissionIds) {
		try {
			jdbcTemplate.update("DELETE FROM user_permissions WHERE user_id = ?", userId);
			if (permissionIds != null && permissionIds.length > 0) {
				String insertSql = "INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)";
				jdbcTemplate.batchUpdate(insertSql, List.of(permissionIds), 100, (ps, permId) -> {
					ps.setInt(1, userId);
					ps.setInt(2, Integer.parseInt(permId));
				});
			}
			return true;
		} catch (Exception e) {
			logger.error("Error updating user permissions for user {}", userId, e);
			return false;
		}
	}

	public int createUser(User user, String password) {
		String hashedPassword = passwordEncoder.encode(password);
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, user.getUsername());
				ps.setString(2, hashedPassword);
				ps.setInt(3, user.getRoleId());
				ps.setInt(4, user.getClassYear());
				ps.setString(5, user.getClassName());
				ps.setString(6, user.getEmail());
				ps.setString(7, "light");
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating user {}", user.getUsername(), e);
			return 0;
		}
	}

	public boolean updateUser(User user) {
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ?, profile_picture_path = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, user.getUsername(), user.getRoleId(), user.getClassYear(),
					user.getClassName(), user.getEmail(), user.getProfilePicturePath(), user.getId()) > 0;
		} catch (Exception e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, theme, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating theme for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, chatColor, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating chat color for user ID {}", userId, e);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, hashedPassword, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}

	public List<User> getAllUsers() {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		try {
			return jdbcTemplate.query(sql, userRowMapper);
		} catch (Exception e) {
			logger.error("SQL error fetching all users", e);
			return List.of();
		}
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, userId);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(userId));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by ID with permissions: {}", userId, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.UserQualification;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.List;

@Repository
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserQualificationsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private UserQualification mapResultSetToUserQualification(ResultSet rs, int rowNum) throws SQLException {
		UserQualification uq = new UserQualification();
		if (DaoUtils.hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	public List<UserQualification> getQualificationsForUser(int userId) {
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id WHERE uq.user_id = ?";
		try {
			return jdbcTemplate.query(sql, this::mapResultSetToUserQualification, userId);
		} catch (Exception e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
			return List.of();
		}
	}

	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try {
				jdbcTemplate.update(deleteSql, userId, courseId);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try {
				jdbcTemplate.update(upsertSql, userId, courseId, status, completionDate, remarks);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\WikiDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class WikiDAO {
	private static final Logger logger = LogManager.getLogger(WikiDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public WikiDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<WikiEntry> wikiEntryRowMapper = (rs, rowNum) -> {
		WikiEntry entry = new WikiEntry();
		entry.setId(rs.getInt("id"));
		entry.setFilePath(rs.getString("file_path"));
		entry.setContent(rs.getString("content"));
		return entry;
	};

	public Optional<WikiEntry> getWikiEntryById(int id) {
		String sql = "SELECT * FROM wiki_documentation WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by ID {}", id, e);
			return Optional.empty();
		}
	}

	public Optional<WikiEntry> findByFilePath(String filePath) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, filePath));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by file_path {}", filePath, e);
			return Optional.empty();
		}
	}

	public List<WikiEntry> getAllWikiEntries() {
		String sql = "SELECT * FROM wiki_documentation ORDER BY file_path";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all wiki entries", e);
			return List.of();
		}
	}

	public boolean updateWikiContent(int id, String content) {
		String sql = "UPDATE wiki_documentation SET content = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, content, id) > 0;
		} catch (Exception e) {
			logger.error("Error updating wiki content for ID {}", id, e);
			return false;
		}
	}

	public Optional<WikiEntry> createWikiEntry(WikiEntry entry) {
		String sql = "INSERT INTO wiki_documentation (file_path, content) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, entry.getFilePath());
				ps.setString(2, entry.getContent());
				return ps;
			}, keyHolder);
			entry.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
			return Optional.of(entry);
		} catch (Exception e) {
			logger.error("Error creating wiki entry for path {}", entry.getFilePath(), e);
			return Optional.empty();
		}
	}

	public boolean deleteWikiEntry(int id) {
		String sql = "DELETE FROM wiki_documentation WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting wiki entry with ID {}", id, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ApiResponse.java
========================================================================

package de.technikteam.model;

/**
 * A standard wrapper for all API responses. This object is returned by all
 * Actions and processed by the FrontControllerServlet. It contains a success
 * flag, a message, and a generic data payload.
 */
public class ApiResponse {

	private final boolean success;
	private final String message;
	private final Object data;

	public ApiResponse(boolean success, String message, Object data) {
		this.success = success;
		this.message = message;
		this.data = data;
	}

	public boolean isSuccess() {
		return success;
	}

	public String getMessage() {
		return message;
	}

	public Object getData() {
		return data;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; 
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DashboardDataDTO.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.Map;

/**
 * A Data Transfer Object to encapsulate all data required for the dynamic admin
 * dashboard.
 */
public class DashboardDataDTO {
	private List<Event> upcomingEvents;
	private List<StorageItem> lowStockItems;
	private List<AdminLog> recentLogs;
	private List<Map<String, Object>> eventTrendData;

	public List<Event> getUpcomingEvents() {
		return upcomingEvents;
	}

	public void setUpcomingEvents(List<Event> upcomingEvents) {
		this.upcomingEvents = upcomingEvents;
	}

	public List<StorageItem> getLowStockItems() {
		return lowStockItems;
	}

	public void setLowStockItems(List<StorageItem> lowStockItems) {
		this.lowStockItems = lowStockItems;
	}

	public List<AdminLog> getRecentLogs() {
		return recentLogs;
	}

	public void setRecentLogs(List<AdminLog> recentLogs) {
		this.recentLogs = recentLogs;
	}

	public List<Map<String, Object>> getEventTrendData() {
		return eventTrendData;
	}

	public void setEventTrendData(List<Map<String, Object>> eventTrendData) {
		this.eventTrendData = eventTrendData;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;

	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean edited;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor; 

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details;
	private String status;
	private String eventName;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers;
	private List<StorageItem> requiredItems;
	private List<InventoryKit> requiredKits;

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackSubmission.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single feedback submission from a user. Corresponds to the
 * `feedback_submissions` table.
 */
public class FeedbackSubmission {
	private int id;
	private int userId;
	private String username; 
	private String subject;
	private String displayTitle; 
	private String content;
	private LocalDateTime submittedAt;
	private String status;
	private int displayOrder;

	public String getFormattedSubmittedAt() {
		return DateFormatter.formatDateTime(this.submittedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public String getDisplayTitle() {
		return displayTitle;
	}

	public void setDisplayTitle(String displayTitle) {
		this.displayTitle = displayTitle;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;
	private String content;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\PasskeyCredential.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single Passkey/WebAuthn credential from the user_passkeys table.
 */
public class PasskeyCredential {
	private int id;
	private int userId;
	private String name;
	private String userHandle;
	private String credentialId;
	private String publicKey;
	private long signatureCount;
	private LocalDateTime createdAt;

	public PasskeyCredential(int id, int userId, String name, String userHandle, String credentialId, String publicKey,
			long signatureCount, LocalDateTime createdAt) {
		this.id = id;
		this.userId = userId;
		this.name = name;
		this.userHandle = userHandle;
		this.credentialId = credentialId;
		this.publicKey = publicKey;
		this.signatureCount = signatureCount;
		this.createdAt = createdAt;
	}

	public PasskeyCredential() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getUserHandle() {
		return userHandle;
	}

	public void setUserHandle(String userHandle) {
		this.userHandle = userHandle;
	}

	public String getCredentialId() {
		return credentialId;
	}

	public void setCredentialId(String credentialId) {
		this.credentialId = credentialId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public void setPublicKey(String publicKey) {
		this.publicKey = publicKey;
	}

	public long getSignatureCount() {
		return signatureCount;
	}

	public void setSignatureCount(long signatureCount) {
		this.signatureCount = signatureCount;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ProfileChangeRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single request from a user to change their profile data.
 * Corresponds to the `profile_change_requests` table.
 */
public class ProfileChangeRequest {
	private int id;
	private int userId;
	private String username; 
	private String requestedChanges; 
	private String status;
	private LocalDateTime requestedAt;
	private Integer reviewedByAdminId;
	private String reviewedByAdminName; 
	private LocalDateTime reviewedAt;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRequestedChanges() {
		return requestedChanges;
	}

	public void setRequestedChanges(String requestedChanges) {
		this.requestedChanges = requestedChanges;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getRequestedAt() {
		return requestedAt;
	}

	public void setRequestedAt(LocalDateTime requestedAt) {
		this.requestedAt = requestedAt;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public String getReviewedByAdminName() {
		return reviewedByAdminName;
	}

	public void setReviewedByAdminName(String reviewedByAdminName) {
		this.reviewedByAdminName = reviewedByAdminName;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "Vergriffen";
		}
		if (maxQuantity == 0) {
			return "Auf Lager"; 
		}
		if (available >= maxQuantity) {
			return "Vollständig";
		}
		if ((double) available / maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "status-danger";
		}
		if (maxQuantity > 0 && (double) available / maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoCategory.java
========================================================================

package de.technikteam.model;

import java.util.ArrayList;
import java.util.List;

public class TodoCategory {
	private int id;
	private String name;
	private int displayOrder;
	private List<TodoTask> tasks = new ArrayList<>();

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public List<TodoTask> getTasks() {
		return tasks;
	}

	public void setTasks(List<TodoTask> tasks) {
		this.tasks = tasks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoTask.java
========================================================================

package de.technikteam.model;

public class TodoTask {
	private int id;
	private int categoryId;
	private String content;
	private boolean isCompleted;
	private int displayOrder;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCompleted(boolean completed) {
		isCompleted = completed;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import de.technikteam.config.Permissions;

import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;
	private String profilePicturePath;

	@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
	private String passwordHash;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	public boolean hasAdminAccess() {
		if (permissions == null) {
			return false;
		}
		return permissions.contains(Permissions.ACCESS_ADMIN_PANEL) || permissions.stream().anyMatch(
				p -> !p.equals(Permissions.FILE_READ) && !p.equals(Permissions.FILE_UPDATE) && (p.contains("_READ")
						|| p.contains("_MANAGE") || p.contains("_CREATE") || p.contains("_DELETE")));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getProfilePicturePath() {
		return profilePicturePath;
	}

	public void setProfilePicturePath(String profilePicturePath) {
		this.profilePicturePath = profilePicturePath;
	}

	public String getPasswordHash() {
		return passwordHash;
	}

	public void setPasswordHash(String passwordHash) {
		this.passwordHash = passwordHash;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\WikiEntry.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single documentation entry from the `wiki_documentation` table.
 */
public class WikiEntry {
	private int id;
	private String filePath;
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilePath() {
		return filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\JwtAuthFilter.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.AuthService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

	private final AuthService authService;

	@Autowired
	public JwtAuthFilter(AuthService authService) {
		this.authService = authService;
	}

	@Override
	protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull FilterChain filterChain) throws ServletException, IOException {

		if (request.getCookies() == null) {
			filterChain.doFilter(request, response);
			return;
		}

		final String token = Arrays.stream(request.getCookies())
				.filter(cookie -> AuthService.AUTH_COOKIE_NAME.equals(cookie.getName())).map(Cookie::getValue)
				.findFirst().orElse(null);

		if (token == null) {
			filterChain.doFilter(request, response);
			return;
		}

		UserDetails userDetails = authService.validateTokenAndGetUser(token);

		if (userDetails != null && SecurityContextHolder.getContext().getAuthentication() == null) {
			UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null,
					userDetails.getAuthorities());
			authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
			SecurityContextHolder.getContext().setAuthentication(authToken);
		}

		filterChain.doFilter(request, response);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\RateLimitingInterceptor.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.RateLimitingService;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.concurrent.TimeUnit;

@Component
public class RateLimitingInterceptor implements HandlerInterceptor {

	private final RateLimitingService rateLimitingService;

	@Autowired
	public RateLimitingInterceptor(RateLimitingService rateLimitingService) {
		this.rateLimitingService = rateLimitingService;
	}

	@Override
	public boolean preHandle(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull Object handler) throws Exception {
		String ipAddress = getClientIp(request);
		Bucket bucket = rateLimitingService.resolveBucket(ipAddress);
		ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

		if (probe.isConsumed()) {
			response.addHeader("X-Rate-Limit-Remaining", String.valueOf(probe.getRemainingTokens()));
			return true;
		} else {
			long waitForRefill = TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill());
			response.addHeader("X-Rate-Limit-Retry-After-Seconds", String.valueOf(waitForRefill));
			response.sendError(HttpStatus.TOO_MANY_REQUESTS.value(),
					"You have exhausted your API request quota. Please try again later.");
			return false;
		}
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityConfig.java
========================================================================

package de.technikteam.security;

import de.technikteam.dao.UserDAO;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig {

	private final JwtAuthFilter jwtAuthFilter;
	private final UserDAO userDAO;

	public SecurityConfig(JwtAuthFilter jwtAuthFilter, UserDAO userDAO) {
		this.jwtAuthFilter = jwtAuthFilter;
		this.userDAO = userDAO;
	}

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler();
		requestHandler.setCsrfRequestAttributeName(null);

		http.csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
				.csrfTokenRequestHandler(requestHandler))
				.authorizeHttpRequests(auth -> auth.requestMatchers("/api/v1/auth/**", "/api/v1/public/calendar.ics",
						"/api/v1/public/files/avatars/**", "/swagger-ui.html", "/swagger-ui/**", "/v3/api-docs/**")
						.permitAll().anyRequest().authenticated())
				.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
				.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin())
						.httpStrictTransportSecurity(hsts -> hsts.includeSubDomains(true).maxAgeInSeconds(31536000))
						.contentSecurityPolicy(csp -> csp.policyDirectives(
								"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com; object-src 'none'; base-uri 'self';")))
				.httpBasic(AbstractHttpConfigurer::disable).formLogin(AbstractHttpConfigurer::disable);

		return http.build();
	}

	@Bean
	public UserDetailsService userDetailsService() {
		return username -> {
			de.technikteam.model.User user = userDAO.getUserByUsername(username);
			if (user == null) {
				throw new UsernameNotFoundException("User not found: " + username);
			}
			return new SecurityUser(user);
		};
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityUser.java
========================================================================

package de.technikteam.security;

import de.technikteam.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serializable;
import java.util.Collection;
import java.util.Collections;
import java.util.stream.Collectors;

public class SecurityUser implements UserDetails, Serializable {

	private static final long serialVersionUID = 1L;
	private final User user;

	public SecurityUser(User user) {
		this.user = user;
	}

	public User getUser() {
		return user;
	}

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		if (user.getPermissions() == null) {
			return Collections.emptyList();
		}
		return user.getPermissions().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());
	}

	@Override
	public String getPassword() {
		return user.getPasswordHash();
	}

	@Override
	public String getUsername() {
		return user.getUsername();
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);

	private final AchievementDAO achievementDAO;
	private final EventDAO eventDAO;

	@Autowired
	public AchievementService(AchievementDAO achievementDAO, EventDAO eventDAO) {
		this.achievementDAO = achievementDAO;
		this.eventDAO = eventDAO;
	}

	@Transactional
	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// Placeholder for future implementation
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminDashboardService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.ReportDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.DashboardDataDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminDashboardService {
	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final AdminLogDAO adminLogDAO;
	private final ReportDAO reportDAO;

	private static final int WIDGET_LIMIT = 5;
	private static final int TREND_MONTHS = 12;

	@Autowired
	public AdminDashboardService(EventDAO eventDAO, StorageDAO storageDAO, AdminLogDAO adminLogDAO,
			ReportDAO reportDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.adminLogDAO = adminLogDAO;
		this.reportDAO = reportDAO;
	}

	public DashboardDataDTO getDashboardData() {
		DashboardDataDTO dto = new DashboardDataDTO();
		dto.setUpcomingEvents(eventDAO.getUpcomingEvents(WIDGET_LIMIT));
		dto.setLowStockItems(storageDAO.getLowStockItems(WIDGET_LIMIT));
		dto.setRecentLogs(adminLogDAO.getRecentLogs(WIDGET_LIMIT));
		dto.setEventTrendData(reportDAO.getEventCountByMonth(TREND_MONTHS));
		return dto;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private final AdminLogDAO logDAO;

	@Autowired
	public AdminLogService(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	private String sanitize(String input) {
		if (input == null) {
			return "";
		}
		// Replace newlines and carriage returns to prevent log injection
		return input.replace('\n', '_').replace('\r', '_');
	}

	public void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);
			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);
			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AuthService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;

@Service
public class AuthService {
	private static final Logger logger = LogManager.getLogger(AuthService.class);
	private static final String JWT_ISSUER = "TechnikTeamApp";
	public static final String AUTH_COOKIE_NAME = "TT_AUTH_TOKEN";
	private static final int COOKIE_MAX_AGE_SECONDS = 8 * 60 * 60; // 8 hours

	private final SecretKey secretKey;
	private final UserDAO userDAO;

	@Autowired
	public AuthService(UserDAO userDAO, ConfigurationService configService) {
		this.userDAO = userDAO;
		String secret = configService.getProperty("jwt.secret");
		if (secret == null || secret.isBlank() || secret.length() < 32) {
			logger.fatal(
					"JWT secret is not configured or is too short (must be at least 32 characters). Application cannot start securely.");
			throw new RuntimeException("JWT secret is not configured or is insecure.");
		}
		this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
	}

	public String generateToken(User user) {
		Instant now = Instant.now();
		Instant expiry = now.plus(COOKIE_MAX_AGE_SECONDS, ChronoUnit.SECONDS);

		return Jwts.builder().issuer(JWT_ISSUER).subject(String.valueOf(user.getId())).issuedAt(Date.from(now))
				.expiration(Date.from(expiry)).signWith(secretKey).compact();
	}

	public void addJwtCookie(User user, HttpServletResponse response) {
		String token = generateToken(user);
		Cookie cookie = new Cookie(AUTH_COOKIE_NAME, token);
		cookie.setHttpOnly(true);
		cookie.setSecure(true); // Should be true in production
		cookie.setPath("/");
		cookie.setMaxAge(COOKIE_MAX_AGE_SECONDS);
		// cookie.setSameSite("Strict"); // Enable for maximum security
		response.addCookie(cookie);
	}

	public void clearJwtCookie(HttpServletResponse response) {
		Cookie cookie = new Cookie(AUTH_COOKIE_NAME, null);
		cookie.setHttpOnly(true);
		cookie.setSecure(true);
		cookie.setPath("/");
		cookie.setMaxAge(0); // Expire immediately
		response.addCookie(cookie);
	}

	public UserDetails validateTokenAndGetUser(String token) {
		try {
			Claims claims = Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload();

			int userId = Integer.parseInt(claims.getSubject());
			User user = userDAO.getUserById(userId);

			if (user == null) {
				logger.warn("JWT validation successful, but user with ID {} no longer exists.", userId);
				return null;
			}
			return new SecurityUser(user);
		} catch (Exception e) {
			logger.warn("JWT verification failed: {}", e.getMessage());
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ChallengeRepository.java
========================================================================

package de.technikteam.service;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import com.yubico.webauthn.AssertionRequest;
import com.yubico.webauthn.data.PublicKeyCredentialCreationOptions;
import org.springframework.stereotype.Component;

import java.util.Optional;
import java.util.concurrent.TimeUnit;

@Component
public class ChallengeRepository {

	private final Cache<String, PublicKeyCredentialCreationOptions> registrationCache = Caffeine.newBuilder()
			.maximumSize(100).expireAfterWrite(5, TimeUnit.MINUTES).build();

	private final Cache<String, AssertionRequest> assertionCache = Caffeine.newBuilder().maximumSize(100)
			.expireAfterWrite(5, TimeUnit.MINUTES).build();

	private final Cache<String, String> deviceNameCache = Caffeine.newBuilder().maximumSize(100)
			.expireAfterWrite(5, TimeUnit.MINUTES).build();

	public void addRegistrationOptions(String username, PublicKeyCredentialCreationOptions options) {
		registrationCache.put(username, options);
	}

	public Optional<PublicKeyCredentialCreationOptions> getRegistrationOptions(String username) {
		return Optional.ofNullable(registrationCache.getIfPresent(username));
	}

	public void addAssertionRequest(String username, AssertionRequest request) {
		assertionCache.put(username, request);
	}

	public Optional<AssertionRequest> getAssertionRequest(String username) {
		return Optional.ofNullable(assertionCache.getIfPresent(username));
	}

	public void addDeviceName(String username, String deviceName) {
		deviceNameCache.put(username, deviceName);
	}

	public Optional<String> getDeviceName(String username) {
		return Optional.ofNullable(deviceNameCache.getIfPresent(username));
	}

	public void removeDeviceName(String username) {
		deviceNameCache.invalidate(username);
	}

	public void removeChallenge(String username) {
		registrationCache.invalidate(username);
		assertionCache.invalidate(username);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ConfigurationService.java
========================================================================

package de.technikteam.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConfigurationService {
	private static final Logger logger = LogManager.getLogger(ConfigurationService.class);

	@Value("${server.servlet.context-path:#{''}}")
	private String contextPath;

	@Value("${spring.datasource.url}")
	private String dbUrl;

	@Value("${spring.datasource.username}")
	private String dbUser;

	@Value("${spring.datasource.password}")
	private String dbPassword;

	@Value("${jwt.secret}")
	private String jwtSecret;

	@Value("${upload.directory}")
	private String uploadDirectory;

	public String getProperty(String key) {
		switch (key) {
		case "context.path":
			return contextPath;
		case "db.url":
			return dbUrl;
		case "db.user":
			return dbUser;
		case "db.password":
			return dbPassword;
		case "jwt.secret":
			return jwtSecret;
		case "upload.directory":
			return uploadDirectory;
		default:
			logger.warn("Attempted to access unknown property key: {}", key);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Event;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
public class EventService {
	private static final Logger logger = LogManager.getLogger(EventService.class);

	private final EventDAO eventDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public EventService(EventDAO eventDAO, AttachmentDAO attachmentDAO, EventCustomFieldDAO customFieldDAO,
			ConfigurationService configService, AdminLogService adminLogService,
			NotificationService notificationService, @Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.eventDAO = eventDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.configService = configService;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public int createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, String[] requiredCourseIds,
			String[] requiredPersons, String[] itemIds, String[] quantities, List<EventCustomField> customFields,
			MultipartFile file, String requiredRole) throws SQLException, IOException {

		// Sanitize HTML content before saving
		if (event.getDescription() != null) {
			String sanitizedDescription = richTextPolicy.sanitize(event.getDescription());
			event.setDescription(sanitizedDescription);
		}

		int eventId;
		if (isUpdate) {
			eventDAO.updateEvent(event);
			eventId = event.getId();
			adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
		} else {
			eventId = eventDAO.createEvent(event);
			event.setId(eventId);
			adminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
		}

		eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);
		eventDAO.saveReservations(eventId, itemIds, quantities);
		if (customFields != null) {
			customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
		}

		if (file != null && !file.isEmpty()) {
			handleAttachmentUpload(file, eventId, requiredRole, adminUser);
		}

		logger.info("Transaction for event ID {} committed successfully.", eventId);
		return eventId;
	}

	public void signOffUserFromRunningEvent(int userId, String username, int eventId, String reason) {
		eventDAO.signOffFromEvent(userId, eventId);
		Event event = eventDAO.getEventById(eventId);
		if (event != null && event.getLeaderUserId() > 0) {
			String notificationMessage = String.format("%s hat sich vom laufenden Event '%s' abgemeldet. Grund: %s",
					username, event.getName(), reason);

			Map<String, Object> payload = Map.of("type", "alert", "payload",
					Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + eventId));

			notificationService.sendNotificationToUser(event.getLeaderUserId(), payload);
			logger.info("Sent sign-off notification to event leader (ID: {}) for event '{}'", event.getLeaderUserId(),
					event.getName());
		}
	}

	private void handleAttachmentUpload(MultipartFile file, int eventId, String requiredRole, User adminUser)
			throws IOException {
		String uploadDir = configService.getProperty("upload.directory");
		String originalFileName = Paths.get(file.getOriginalFilename()).getFileName().toString();
		String uniqueFileName = UUID.randomUUID() + "-" + originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");

		Path targetPath = Paths.get(uploadDir, "events", uniqueFileName);
		Files.createDirectories(targetPath.getParent());
		Files.copy(file.getInputStream(), targetPath);

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(originalFileName);
		attachment.setFilepath("events/" + uniqueFileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			adminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + originalFileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Failed to save attachment to database.");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\FileService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
public class FileService {

	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;
	private final Path fileStorageLocation;

	private static final long MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10 MB

	@Autowired
	public FileService(FileDAO fileDAO, ConfigurationService configService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser) throws IOException {

		// Security Validations
		if (multipartFile.getSize() > MAX_FILE_SIZE_BYTES) {
			throw new IOException("File size exceeds the limit of 10MB.");
		}
		if (!FileSignatureValidator.isFileTypeAllowed(multipartFile)) {
			throw new IOException("Invalid or spoofed file type detected.");
		}

		String originalFileName = FilenameUtils.getName(multipartFile.getOriginalFilename());
		String sanitizedFileName = originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");
		String uniqueFileName = UUID.randomUUID() + "-" + sanitizedFileName;

		Path targetPath = this.fileStorageLocation.resolve(Paths.get("docs", uniqueFileName));
		Files.createDirectories(targetPath.getParent());
		Files.copy(multipartFile.getInputStream(), targetPath);

		de.technikteam.model.File file = new de.technikteam.model.File();
		file.setFilename(originalFileName);
		file.setFilepath("docs/" + uniqueFileName);
		file.setCategoryId(categoryId != null ? categoryId : 0);
		file.setRequiredRole(requiredRole);

		int newFileId = fileDAO.createFile(file);
		if (newFileId > 0) {
			adminLogService.log(adminUser.getUsername(), "UPLOAD_FILE",
					"Datei '" + originalFileName + "' hochgeladen.");
			return fileDAO.getFileById(newFileId);
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Failed to save file metadata to database.");
		}
	}

	public boolean deleteFile(int fileId, User adminUser) throws IOException {
		de.technikteam.model.File file = fileDAO.getFileById(fileId);
		if (file == null) {
			return false;
		}

		boolean success = fileDAO.deleteFile(fileId);
		if (success) {
			Path filePath = this.fileStorageLocation.resolve(file.getFilepath()).normalize();
			Files.deleteIfExists(filePath);
			adminLogService.log(adminUser.getUsername(), "DELETE_FILE",
					"Datei '" + file.getFilename() + "' (ID: " + fileId + ") gelöscht.");
		}
		return success;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\LoginAttemptService.java
========================================================================

package de.technikteam.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.LocalDateTime;

@Service
public class LoginAttemptService {

	private static final Logger logger = LogManager.getLogger(LoginAttemptService.class);
	private static final int MAX_ATTEMPTS = 5;
	private static final int LOCKOUT_MINUTES = 30;

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public LoginAttemptService(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean isLockedOut(String username) {
		String sql = "SELECT last_attempt, attempts FROM login_attempts WHERE username = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				LocalDateTime lastAttempt = rs.getTimestamp("last_attempt").toLocalDateTime();
				int attempts = rs.getInt("attempts");
				if (attempts >= MAX_ATTEMPTS
						&& lastAttempt.isAfter(LocalDateTime.now().minusMinutes(LOCKOUT_MINUTES))) {
					return true;
				}
				// If lockout period expired, clear attempts and allow login
				clearLoginAttempts(username);
				return false;
			}, username);
		} catch (Exception e) {
			return false; // No record means not locked out
		}
	}

	public void recordFailedLogin(String username) {
		String sql = "INSERT INTO login_attempts (username, attempts, last_attempt) VALUES (?, 1, ?) "
				+ "ON DUPLICATE KEY UPDATE attempts = attempts + 1, last_attempt = ?";
		Timestamp now = Timestamp.valueOf(LocalDateTime.now());
		jdbcTemplate.update(sql, username, now, now);

		String checkSql = "SELECT attempts FROM login_attempts WHERE username = ?";
		Integer currentAttempts = jdbcTemplate.queryForObject(checkSql, Integer.class, username);
		if (currentAttempts != null && currentAttempts >= MAX_ATTEMPTS) {
			logger.warn("Locking out user {} due to {} failed login attempts.", username, currentAttempts);
		}
	}

	public void clearLoginAttempts(String username) {
		String sql = "DELETE FROM login_attempts WHERE username = ?";
		jdbcTemplate.update(sql, username);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

@Service
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);

	private final Map<Integer, List<SseEmitter>> emittersByUser = new ConcurrentHashMap<>();

	public NotificationService() {
		new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	public SseEmitter register(User user) {
		if (user == null) {
			logger.warn("Attempt to register for notifications from a non-authenticated session.");
			return null;
		}

		// Timeout set to a very long value. The connection will be kept alive by
		// heartbeats.
		SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		int userId = user.getId();

		emitter.onCompletion(() -> {
			logger.info("SSE Emitter completed for user {}", userId);
			removeEmitter(userId, emitter);
		});
		emitter.onTimeout(() -> {
			logger.warn("SSE Emitter timed out for user {}", userId);
			emitter.complete();
		});
		emitter.onError(e -> {
			logger.error("SSE Emitter error for user {}: {}", userId, e.getMessage());
			emitter.complete();
		});

		emittersByUser.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);

		logger.info("New client registered for SSE notifications for user ID {}. Total clients for user: {}", userId,
				emittersByUser.get(userId).size());

		// Send a confirmation event
		try {
			emitter.send(SseEmitter.event().name("connected").data("Connection established"));
		} catch (IOException e) {
			logger.error("Error sending connection confirmation to user {}", userId, e);
			emitter.complete();
		}

		return emitter;
	}

	public void broadcastUIUpdate(String type, Object payload) {
		logger.info("Broadcasting UI update of type '{}' to all clients.", type);
		Map<String, Object> message = Map.of("updateType", type, "data", payload);
		SseEmitter.SseEventBuilder event = SseEmitter.event().name("ui_update").data(message);

		emittersByUser.values().forEach(emitterList -> emitterList.forEach(emitter -> {
			try {
				emitter.send(event);
			} catch (IOException e) {
				logger.warn("Failed to send broadcast to a client (likely disconnected), removing it. Error: {}",
						e.getMessage());
				emitter.complete();
			}
		}));
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null && !userEmitters.isEmpty()) {
			SseEmitter.SseEventBuilder event = SseEmitter.event().name("notification").data(payload);
			logger.info("Sending targeted notification to user ID {}: {}", userId, payload);

			userEmitters.forEach(emitter -> {
				try {
					emitter.send(event);
				} catch (IOException e) {
					logger.warn(
							"Failed to send targeted notification to user {} (client likely disconnected), removing it. Error: {}",
							userId, e.getMessage());
					emitter.complete();
				}
			});
		} else {
			logger.debug("No active SSE clients found for user ID {} to send notification.", userId);
		}
	}

	private void removeEmitter(int userId, SseEmitter emitter) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null) {
			userEmitters.remove(emitter);
			if (userEmitters.isEmpty()) {
				emittersByUser.remove(userId);
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\PasskeyService.java
========================================================================

package de.technikteam.service;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.yubico.webauthn.*;
import com.yubico.webauthn.data.*;
import com.yubico.webauthn.exception.RegistrationFailedException;
import com.yubico.webauthn.exception.VerificationFailedException;
import de.technikteam.dao.PasskeyDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.PasskeyCredential;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.Optional;

@Service
public class PasskeyService {
	private static final Logger logger = LogManager.getLogger(PasskeyService.class);
	private final PasskeyDAO passkeyDAO;
	private final UserDAO userDAO;
	private final RelyingParty relyingParty;
	private final ChallengeRepository challengeRepository;

	@Autowired
	public PasskeyService(PasskeyDAO passkeyDAO, UserDAO userDAO, ChallengeRepository challengeRepository) {
		this.passkeyDAO = passkeyDAO;
		this.userDAO = userDAO;
		this.challengeRepository = challengeRepository;

		RelyingPartyIdentity rpIdentity = RelyingPartyIdentity.builder().id("localhost") // Must match your domain in
																							// production
				.name("TechnikTeam").build();

		this.relyingParty = RelyingParty.builder().identity(rpIdentity).credentialRepository(this.passkeyDAO)
				.allowOriginPort(true) // For localhost development
				.build();
	}

	public String startRegistration(User user) throws JsonProcessingException {
		StartRegistrationOptions options = StartRegistrationOptions.builder().user(UserIdentity.builder()
				.name(user.getUsername()).displayName(user.getUsername()).id(UserHandle.of(user.getUsername())).build())
				.build();

		PublicKeyCredentialCreationOptions credentialCreationOptions = relyingParty.startRegistration(options);
		challengeRepository.addRegistrationOptions(user.getUsername(), credentialCreationOptions);

		return credentialCreationOptions.toJson();
	}

	public boolean finishRegistration(int userId, String username, String deviceName, String credentialJson) {
		try {
			PublicKeyCredentialCreationOptions registrationOptions = challengeRepository
					.getRegistrationOptions(username)
					.orElseThrow(() -> new RegistrationFailedException("No registration ceremony found for user."));

			PublicKeyCredential<AuthenticatorAttestationResponse, ClientRegistrationExtensionOutputs> pkc = PublicKeyCredential
					.parseRegistrationResponseJson(credentialJson);

			RegistrationResult result = relyingParty.finishRegistration(
					FinishRegistrationOptions.builder().request(pkc).response(registrationOptions).build());

			PasskeyCredential credential = new PasskeyCredential();
			credential.setUserId(userId);
			credential.setName(deviceName);
			credential.setUserHandle(registrationOptions.getUser().getId().getBase64Url());
			credential.setCredentialId(result.getKeyId().getId().getBase64Url());
			credential.setPublicKey(result.getPublicKeyCose().getBase64Url());
			credential.setSignatureCount(result.getSignatureCount());

			return passkeyDAO.saveCredential(credential);

		} catch (RegistrationFailedException | IOException e) {
			logger.error("Passkey registration failed for user {}: {}", username, e.getMessage(), e);
			return false;
		} finally {
			challengeRepository.removeChallenge(username);
		}
	}

	public String startAuthentication(String username) throws JsonProcessingException {
		AssertionRequest assertionRequest = relyingParty
				.startAssertion(StartAssertionOptions.builder().username(Optional.of(username)).build());

		challengeRepository.addAssertionRequest(username, assertionRequest);

		return assertionRequest.toJson();
	}

	public User finishAuthentication(String credentialJson) {
		String username = null;
		try {
			PublicKeyCredential<AuthenticatorAssertionResponse, ClientAuthenticationExtensionOutputs> pkc = PublicKeyCredential
					.parseAssertionResponseJson(credentialJson);

			Optional<ByteArray> userHandle = pkc.getResponse().getUserHandle();
			if (userHandle.isEmpty()) {
				throw new VerificationFailedException(new Exception("User handle is missing from assertion."));
			}
			username = passkeyDAO.getUsernameForUserHandle(userHandle.get())
					.orElseThrow(() -> new VerificationFailedException(new Exception("Unknown user handle.")));

			AssertionRequest assertionRequest = challengeRepository.getAssertionRequest(username).orElseThrow(
					() -> new VerificationFailedException(new Exception("No assertion request found for user.")));

			AssertionResult result = relyingParty
					.finishAssertion(FinishAssertionOptions.builder().request(pkc).response(assertionRequest).build());

			if (result.isSuccess()) {
				passkeyDAO.updateSignatureCount(result.getCredential().getCredentialId(), result.getSignatureCount());
				return userDAO.getUserByUsername(result.getUsername());
			} else {
				return null;
			}
		} catch (VerificationFailedException | IOException e) {
			logger.error("Passkey authentication failed for user {}: {}", username, e.getMessage(), e);
			return null;
		} finally {
			if (username != null) {
				challengeRepository.removeChallenge(username);
			}
		}
	}

}
========================================================================
FILE: src\main\java\de\technikteam\service\ProfileRequestService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;

@Service
public class ProfileRequestService {

	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ConfigurationService configService;
	private final Gson gson;

	@Autowired
	public ProfileRequestService(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService,
			NotificationService notificationService, ConfigurationService configService, Gson gson) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.configService = configService;
		this.gson = gson;
	}

	@Transactional
	public void createChangeRequest(User currentUser, ProfileChangeRequestDTO requestDTO, MultipartFile profilePicture)
			throws IOException {
		Map<String, String> changes = new HashMap<>();
		if (requestDTO.email() != null && !Objects.equals(currentUser.getEmail(), requestDTO.email())) {
			changes.put("email", requestDTO.email());
		}
		if (requestDTO.classYear() != null && currentUser.getClassYear() != requestDTO.classYear()) {
			changes.put("classYear", String.valueOf(requestDTO.classYear()));
		}
		if (requestDTO.className() != null && !Objects.equals(currentUser.getClassName(), requestDTO.className())) {
			changes.put("className", requestDTO.className());
		}

		if (profilePicture != null && !profilePicture.isEmpty()) {
			if (!FileSignatureValidator.isFileTypeAllowed(profilePicture)) {
				throw new IOException("Invalid profile picture file type. Only JPG and PNG are allowed.");
			}
			String tempPath = saveTemporaryProfilePicture(profilePicture);
			changes.put("profilePicturePath", tempPath);
		}

		if (changes.isEmpty()) {
			return; // No changes to request
		}

		ProfileChangeRequest pcr = new ProfileChangeRequest();
		pcr.setUserId(currentUser.getId());
		pcr.setRequestedChanges(gson.toJson(changes));

		if (!requestDAO.createRequest(pcr)) {
			throw new IOException("Could not save your request to the database.");
		}
	}

	@Transactional
	public boolean approveRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Request not found or has already been processed.");
		}

		User userToUpdate = userDAO.getUserById(pcr.getUserId());
		if (userToUpdate == null) {
			requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
			throw new IllegalStateException("The associated user no longer exists. Request has been denied.");
		}

		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = gson.fromJson(pcr.getRequestedChanges(), type);

		for (Map.Entry<String, String> entry : changes.entrySet()) {
			String field = entry.getKey();
			String value = entry.getValue();
			switch (field) {
			case "email":
				userToUpdate.setEmail(value);
				break;
			case "classYear":
				userToUpdate.setClassYear(Integer.parseInt(value));
				break;
			case "className":
				userToUpdate.setClassName(value);
				break;
			case "profilePicturePath":
				String permanentPath = makeProfilePicturePermanent(value, userToUpdate.getProfilePicturePath());
				userToUpdate.setProfilePicturePath(permanentPath);
				break;
			}
		}

		if (userDAO.updateUser(userToUpdate)
				&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED_API", "Profile change for '"
					+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") approved via API.");

			String notificationMessage = "Your profile change has been approved.";
			Map<String, Object> payload = Map.of("type", "alert", "payload", Map.of("message", notificationMessage));
			notificationService.sendNotificationToUser(userToUpdate.getId(), payload);

			return true;
		}
		return false;
	}

	@Transactional
	public boolean denyRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Request not found or has already been processed.");
		}

		// If the request included a temporary file, delete it
		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = gson.fromJson(pcr.getRequestedChanges(), type);
		if (changes.containsKey("profilePicturePath")) {
			deleteTemporaryProfilePicture(changes.get("profilePicturePath"));
		}

		if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED_API", "Profile change for user ID "
					+ pcr.getUserId() + " (Request ID: " + requestId + ") denied via API.");
			return true;
		}
		return false;
	}

	private String saveTemporaryProfilePicture(MultipartFile file) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempDir = uploadDir.resolve("temp_avatars");
		Files.createDirectories(tempDir);

		String extension = FilenameUtils.getExtension(file.getOriginalFilename());
		String newFilename = UUID.randomUUID().toString() + "." + extension;
		Path targetPath = tempDir.resolve(newFilename);
		Files.copy(file.getInputStream(), targetPath);
		return newFilename;
	}

	private String makeProfilePicturePermanent(String tempFilename, String oldPermanentFilename) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempDir = uploadDir.resolve("temp_avatars");
		Path finalDir = uploadDir.resolve("avatars");
		Files.createDirectories(finalDir);

		Path sourcePath = tempDir.resolve(tempFilename);
		Path destinationPath = finalDir.resolve(tempFilename);

		if (Files.exists(sourcePath)) {
			Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);

			// Delete the old profile picture if it exists
			if (oldPermanentFilename != null && !oldPermanentFilename.isBlank()) {
				Path oldPath = finalDir.resolve(oldPermanentFilename);
				Files.deleteIfExists(oldPath);
			}
			return tempFilename;
		}
		throw new IOException("Temporary profile picture not found: " + tempFilename);
	}

	private void deleteTemporaryProfilePicture(String tempFilename) throws IOException {
		Path uploadDir = Paths.get(configService.getProperty("upload.directory"));
		Path tempFile = uploadDir.resolve("temp_avatars").resolve(tempFilename);
		Files.deleteIfExists(tempFile);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\RateLimitingService.java
========================================================================

package de.technikteam.service;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RateLimitingService {

	private final Map<String, Bucket> cache = new ConcurrentHashMap<>();

	public Bucket resolveBucket(String apiKey) {
		return cache.computeIfAbsent(apiKey, this::newBucket);
	}

	private Bucket newBucket(String apiKey) {
		// Example: 10 requests per minute
		Bandwidth limit = Bandwidth.simple(10, Duration.ofMinutes(1));
		return Bucket.builder().addLimit(limit).build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\StorageService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class StorageService {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public StorageService(StorageDAO storageDAO, StorageLogDAO storageLogDAO, EventDAO eventDAO,
			AdminLogService adminLogService) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public boolean processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null)
			throw new IllegalArgumentException("Item with ID " + itemId + " not found.");

		if ("checkout".equals(type)) {
			if (item.getAvailableQuantity() < quantity)
				throw new IllegalStateException("Not enough items available to check out.");
			item.setQuantity(item.getQuantity() - quantity);
			item.setStatus("CHECKED_OUT");
			item.setCurrentHolderUserId(user.getId());
			item.setAssignedEventId(eventId != null ? eventId : 0);
		} else if ("checkin".equals(type)) {
			if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
				throw new IllegalStateException("Not enough space to check in this many items.");
			}
			item.setQuantity(item.getQuantity() + quantity);
			if (item.getQuantity() >= item.getMaxQuantity()) {
				item.setStatus("IN_STORAGE");
				item.setCurrentHolderUserId(0);
				item.setAssignedEventId(0);
			}
		} else {
			throw new IllegalArgumentException("Invalid transaction type: " + type);
		}

		storageDAO.updateItem(item);

		String finalNotes = notes;
		if ("checkout".equals(type) && eventId != null) {
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				String autoNote = "Für Event: " + event.getName();
				finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes : autoNote;
			}
		}
		int quantityChange = "checkin".equals(type) ? quantity : -quantity;
		storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes, eventId != null ? eventId : 0);

		String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
		String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, item.getName(), itemId, action,
				finalNotes);
		adminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

		return true;
	}

	@Transactional
	public boolean updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Item with ID " + itemId + " not found.");
		}

		String logDetails;

		if ("UNREPAIRABLE".equals(status)) {
			if (item.getQuantity() < quantity || item.getDefectiveQuantity() < quantity) {
				throw new IllegalStateException("Cannot mark more items as unrepairable than exist or are defective.");
			}
			item.setQuantity(item.getQuantity() - quantity);
			item.setDefectiveQuantity(item.getDefectiveQuantity() - quantity);
			item.setDefectReason(reason);
			logDetails = String.format("Permanently removed %d x '%s' (ID: %d) from stock (unrepairable). Reason: %s",
					quantity, item.getName(), itemId, reason);
			adminLogService.log(adminUser.getUsername(), "ITEM_UNREPAIRABLE", logDetails);
		} else {
			int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
			if (item.getQuantity() < newDefectiveTotal) {
				throw new IllegalStateException("Total defective quantity cannot exceed total quantity.");
			}
			item.setDefectiveQuantity(newDefectiveTotal);
			item.setDefectReason(reason);
			logDetails = String.format("Defect status for '%s' (ID: %d) updated: %d defective. Reason: %s",
					item.getName(), itemId, newDefectiveTotal, reason);
			adminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS", logDetails);
		}

		storageDAO.updateItem(item);
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

@Service
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getCpuLoad() * 100.0);

		long totalMemoryBytes = Runtime.getRuntime().totalMemory();
		long freeMemoryBytes = Runtime.getRuntime().freeMemory();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\TodoService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.TodoDAO;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class TodoService {
	private static final Logger logger = LogManager.getLogger(TodoService.class);
	private final TodoDAO todoDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public TodoService(TodoDAO todoDAO, AdminLogService adminLogService) {
		this.todoDAO = todoDAO;
		this.adminLogService = adminLogService;
	}

	public List<TodoCategory> getAllTodos() {
		return todoDAO.getAllCategoriesWithTasks();
	}

	@Transactional
	public TodoCategory createCategory(String name, User admin) {
		try {
			TodoCategory newCategory = todoDAO.createCategory(name);
			if (newCategory != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_CATEGORY",
						"To-Do Kategorie '" + name + "' erstellt.");
			}
			return newCategory;
		} catch (Exception e) {
			logger.error("Service error creating To-Do category '{}'", name, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public TodoTask createTask(int categoryId, String content, User admin) {
		try {
			TodoTask newTask = todoDAO.createTask(categoryId, content);
			if (newTask != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_TASK",
						"To-Do Aufgabe '" + content + "' in Kategorie ID " + categoryId + " erstellt.");
			}
			return newTask;
		} catch (Exception e) {
			logger.error("Service error creating To-Do task in category {}", categoryId, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public boolean updateTask(int taskId, String content, Boolean isCompleted, User admin) {
		boolean success = false;
		if (content != null) {
			success = todoDAO.updateTaskContent(taskId, content);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_TASK", "Aufgabe ID " + taskId + " aktualisiert.");
		}
		if (isCompleted != null) {
			success = todoDAO.updateTaskStatus(taskId, isCompleted);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_STATUS",
						"Status für Aufgabe ID " + taskId + " auf '" + isCompleted + "' gesetzt.");
		}
		return success;
	}

	@Transactional
	public boolean deleteTask(int taskId, User admin) {
		if (todoDAO.deleteTask(taskId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_TASK", "Aufgabe ID " + taskId + " gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean deleteCategory(int categoryId, User admin) {
		if (todoDAO.deleteCategory(categoryId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_CATEGORY",
					"Kategorie ID " + categoryId + " und alle zugehörigen Aufgaben gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean reorder(Map<String, List<Integer>> reorderData, User admin) {
		List<Integer> categoryOrder = reorderData.get("categoryOrder");
		if (categoryOrder != null) {
			todoDAO.updateCategoryOrder(categoryOrder);
		}

		for (Map.Entry<String, List<Integer>> entry : reorderData.entrySet()) {
			if (entry.getKey().startsWith("category-")) {
				int categoryId = Integer.parseInt(entry.getKey().substring("category-".length()));
				todoDAO.updateTaskOrders(entry.getValue(), categoryId);
			}
		}
		adminLogService.log(admin.getUsername(), "TODO_REORDER", "To-Do-Listen neu sortiert.");
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\UserService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
	private static final Logger logger = LogManager.getLogger(UserService.class);

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public UserService(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public int createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername) {
		int newUserId = userDAO.createUser(user, password);
		if (newUserId > 0) {
			userDAO.updateUserPermissions(newUserId, permissionIds);
			logger.info("Transaction for creating user '{}' committed successfully.", user.getUsername());

			String logDetails = String.format(
					"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %s) erstellt und Berechtigungen zugewiesen.",
					user.getUsername(), newUserId, user.getRoleId(), user.getClassName());
			adminLogService.log(adminUsername, "CREATE_USER", logDetails);

			return newUserId;
		} else {
			throw new RuntimeException("User creation returned an invalid ID.");
		}
	}

	@Transactional
	public boolean updateUserWithPermissions(User user, String[] permissionIds) {
		boolean profileUpdated = userDAO.updateUser(user);
		boolean permissionsUpdated = userDAO.updateUserPermissions(user.getId(), permissionIds);
		logger.info("Transaction for updating user '{}' committed successfully.", user.getUsername());
		return profileUpdated || permissionsUpdated;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\WikiService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.WikiDAO;
import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Service
public class WikiService {
	private static final Logger logger = LogManager.getLogger(WikiService.class);
	private final WikiDAO wikiDAO;

	@Autowired
	public WikiService(WikiDAO wikiDAO) {
		this.wikiDAO = wikiDAO;
	}

	/**
	 * Fetches all wiki entries and organizes them into a hierarchical tree
	 * structure. The structure is a map of maps, where the final value is a
	 * WikiEntry object.
	 *
	 * @return A Map representing the root of the file tree.
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getWikiTreeAsData() {
		List<WikiEntry> allEntries = wikiDAO.getAllWikiEntries();
		Map<String, Object> rootNode = new LinkedHashMap<>();

		for (WikiEntry entry : allEntries) {
			String[] pathParts = entry.getFilePath().split("/");
			Map<String, Object> currentNode = rootNode;

			for (int i = 0; i < pathParts.length - 1; i++) {
				String part = pathParts[i];
				// This cast is safe within this algorithm as we are intentionally building a
				// nested map structure.
				currentNode = (Map<String, Object>) currentNode.computeIfAbsent(part,
						k -> new LinkedHashMap<String, Object>());
			}

			String fileName = pathParts[pathParts.length - 1];
			if (!fileName.isEmpty()) {
				currentNode.put(fileName, entry);
			}
		}
		logger.debug("Successfully built wiki tree with {} root elements.", rootNode.size());
		return rootNode;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\FileSignatureValidator.java
========================================================================

package de.technikteam.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FileSignatureValidator {
	private static final Logger logger = LogManager.getLogger(FileSignatureValidator.class);

	private static final Map<String, List<byte[]>> MAGIC_NUMBERS = new HashMap<>();

	static {
		// JPEG
		MAGIC_NUMBERS.put("image/jpeg", List.of(new byte[] { (byte) 0xFF, (byte) 0xD8, (byte) 0xFF }));
		// PNG
		MAGIC_NUMBERS.put("image/png", List.of(new byte[] { (byte) 0x89, (byte) 0x50, (byte) 0x4E, (byte) 0x47 }));
		// GIF
		MAGIC_NUMBERS.put("image/gif", List.of(new byte[] { (byte) 0x47, (byte) 0x49, (byte) 0x46, (byte) 0x38 }));
		// PDF
		MAGIC_NUMBERS.put("application/pdf",
				List.of(new byte[] { (byte) 0x25, (byte) 0x50, (byte) 0x44, (byte) 0x46 }));
		// DOCX, XLSX, PPTX (PKZIP archive)
		List<byte[]> pkzip = List.of(new byte[] { (byte) 0x50, (byte) 0x4B, (byte) 0x03, (byte) 0x04 });
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.wordprocessingml.document", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.presentationml.presentation", pkzip);
	}

	private static final int MAX_HEADER_SIZE = 8;

	public static boolean isFileTypeAllowed(MultipartFile file) {
		if (file == null || file.isEmpty()) {
			return false;
		}
		String declaredMimeType = file.getContentType();
		List<byte[]> expectedSignatures = MAGIC_NUMBERS.get(declaredMimeType);

		if (expectedSignatures == null) {
			logger.warn("File upload blocked for undeclared MIME type: {}", declaredMimeType);
			return false; // Type not in our allowed map
		}

		try (InputStream is = file.getInputStream()) {
			byte[] header = new byte[MAX_HEADER_SIZE];
			int bytesRead = is.read(header);
			if (bytesRead < 1)
				return false;

			byte[] actualHeader = Arrays.copyOf(header, bytesRead);

			for (byte[] signature : expectedSignatures) {
				if (actualHeader.length >= signature.length) {
					byte[] headerToCompare = Arrays.copyOf(actualHeader, signature.length);
					if (Arrays.equals(headerToCompare, signature)) {
						return true; // Match found
					}
				}
			}
		} catch (IOException e) {
			logger.error("Could not read file header for validation", e);
			return false;
		}

		logger.warn("File signature mismatch. Declared MIME type: {}, but magic bytes do not match. Upload blocked.",
				declaredMimeType);
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

/**
 * DEPRECATED: This class is no longer used for security-sensitive sanitization.
 * The OWASP Java HTML Sanitizer is now used instead to provide robust
 * protection against Cross-Site Scripting (XSS) attacks. This class is retained
 * for historical purposes or non-security-related transformations if needed.
 */
public final class MarkdownUtil {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private MarkdownUtil() {
	}

	/**
	 * A simple, non-security-focused method to perform basic transformations.
	 *
	 * @param markdown The raw string.
	 * @return The transformed string.
	 */
	public static String transform(String markdown) {
		if (markdown == null || markdown.isEmpty()) {
			return markdown;
		}
		// Example transformation: none, as this is deprecated for security.
		return markdown;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Mein Feedback", "/my-feedback", "fa-comment-dots", null));
		ALL_ITEMS.add(new NavigationItem("Feedback geben", "/feedback", "fa-lightbulb", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(new NavigationItem("Anträge", "/admin/requests", "fa-inbox", Permissions.USER_UPDATE));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/admin/dateien", "fa-file-upload", Permissions.FILE_MANAGE));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgangs-Vorlagen", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Kit-Verwaltung", "/admin/kits", "fa-box-open", Permissions.KIT_READ));
		ALL_ITEMS
				.add(new NavigationItem("Feedback", "/admin/feedback", "fa-inbox", Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Abzeichen", "/admin/achievements", "fa-award", Permissions.ACHIEVEMENT_VIEW));
		ALL_ITEMS.add(new NavigationItem("Defekte Artikel", "/admin/defekte", "fa-wrench", Permissions.STORAGE_READ));
		ALL_ITEMS
				.add(new NavigationItem("Quali-Matrix", "/admin/matrix", "fa-th-list", Permissions.QUALIFICATION_READ));
		ALL_ITEMS.add(new NavigationItem("Berichte", "/admin/berichte", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(new NavigationItem("Aktions-Log", "/admin/log", "fa-clipboard-list", Permissions.LOG_READ));
		ALL_ITEMS.add(new NavigationItem("System", "/admin/system", "fa-server", Permissions.SYSTEM_READ));
		ALL_ITEMS.add(new NavigationItem("Wiki", "/admin/wiki", "fa-book-reader", Permissions.ACCESS_ADMIN_PANEL));
		ALL_ITEMS.add(new NavigationItem("API Docs", "/swagger-ui.html", "fa-code", Permissions.ACCESS_ADMIN_PANEL));
	}

	private NavigationRegistry() {
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null || user.getPermissions() == null) {
			return new ArrayList<>();
		}

		final Set<String> userPermissions = user.getPermissions();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items are always visible
			if (requiredPerm == null) {
				return true;
			}

			// Super-admins see all admin items
			if (userPermissions.contains(Permissions.ACCESS_ADMIN_PANEL)) {
				return true;
			}

			// Special case: The "Admin Dashboard" link is visible if the user has *any*
			// admin-level access.
			if (Permissions.ADMIN_DASHBOARD_ACCESS.equals(requiredPerm)) {
				return user.hasAdminAccess();
			}

			// Special case: The "Abzeichen" link is visible if user can perform any
			// achievement action.
			if (Permissions.ACHIEVEMENT_VIEW.equals(requiredPerm)) {
				return userPermissions.contains(Permissions.ACHIEVEMENT_CREATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_UPDATE)
						|| userPermissions.contains(Permissions.ACHIEVEMENT_DELETE);
			}

			// Standard permission check for all other items
			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms as a thread-safe
 * Spring Component. It maps event IDs to a set of active sessions, allowing for
 * targeted broadcasting of messages.
 */
@Component
public class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByEvent = new ConcurrentHashMap<>();

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, WebSocketSession session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\EventChatSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class EventChatSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(EventChatSocketHandler.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private final EventChatDAO chatDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ChatSessionManager sessionManager;
	private final Gson gson;
	private final PolicyFactory inlineFormattingPolicy;

	@Autowired
	public EventChatSocketHandler(EventChatDAO chatDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService, ChatSessionManager sessionManager,
			@Qualifier("inlineFormattingPolicy") PolicyFactory inlineFormattingPolicy) {
		this.chatDAO = chatDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.sessionManager = sessionManager;
		this.inlineFormattingPolicy = inlineFormattingPolicy;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String eventId = getEventId(session);

		if (user == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Authentication required."));
			return;
		}

		if (eventId == null || !eventDAO.isUserAssociatedWithEvent(Integer.parseInt(eventId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Permission denied for this event chat."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("eventId", eventId);
		sessionManager.addSession(eventId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) {
		User user = (User) session.getAttributes().get("user");
		String eventId = (String) session.getAttributes().get("eventId");
		if (user == null || eventId == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message.getPayload(), Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = inlineFormattingPolicy.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = inlineFormattingPolicy.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload",
					Map.of("messageId", messageId, "newText", sanitizedText));
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload",
					Map.of("messageId", messageId, "originalUsername", payload.get("originalUsername"),
							"deletedByUsername", user.getUsername()));
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + event.getId()));
				notificationService.sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
		String eventId = (String) session.getAttributes().get("eventId");
		if (eventId != null) {
			sessionManager.removeSession(eventId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication) {
			Authentication auth = (Authentication) session.getPrincipal();
			if (auth.getPrincipal() instanceof SecurityUser) {
				return ((SecurityUser) auth.getPrincipal()).getUser();
			}
		}
		return null;
	}

	private String getEventId(WebSocketSession session) {
		// URI pattern is /ws/chat/{eventId}
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\WebSocketConfig.java
========================================================================

package de.technikteam.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	private final EventChatSocketHandler eventChatSocketHandler;

	@Autowired
	public WebSocketConfig(EventChatSocketHandler eventChatSocketHandler) {
		this.eventChatSocketHandler = eventChatSocketHandler;
	}

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(eventChatSocketHandler, "/ws/chat/{eventId}").setAllowedOrigins("*"); 
	}
}
========================================================================
FILE: src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
	<Appenders>
		<Console name="Console" target="SYSTEM_OUT">
			<!-- For development, use a human-readable pattern -->
			<!-- <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} 
				- %msg%n"/> -->

			<!-- For production/structured logging, use JSON Template Layout -->
			<JsonTemplateLayout
				eventTemplateUri="classpath:Log4j2JsonTemplate.json" />
		</Console>
	</Appenders>
	<Loggers>
		<Root level="info">
			<AppenderRef ref="Console" />
		</Root>
		<!-- Set a more verbose level for our application's packages during development -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
		</Logger>
	</Loggers>
</Configuration>