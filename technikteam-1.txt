
========================================================================
FILE: src\main\java\de\technikteam\api\v1\UserResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.UserCreateRequest;
import de.technikteam.api.v1.dto.UserUpdateRequest;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.service.UserService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.security.SecureRandom;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
public class UserResource {

	private final UserService userService;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public UserResource(UserService userService, UserDAO userDAO, AdminLogService adminLogService,
			LoginAttemptService loginAttemptService) {
		this.userService = userService;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.loginAttemptService = loginAttemptService;
	}

	private String getSystemUsername() {
		return "SYSTEM";
	}

	@GetMapping
	@Operation(summary = "Get all users", description = "Retrieves a list of all users in the system.")
	public ResponseEntity<ApiResponse> getAllUsers() {
		List<User> users = userDAO.getAllUsers();
		return ResponseEntity.ok(new ApiResponse(true, "Users retrieved successfully", users));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get user by ID", description = "Retrieves a single user by their ID, including their permissions.")
	public ResponseEntity<ApiResponse> getUserById(
			@Parameter(description = "ID of the user to retrieve") @PathVariable int id) {
		User user = userDAO.getUserById(id);
		if (user != null) {
			return ResponseEntity.ok(new ApiResponse(true, "User retrieved successfully", user));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found", null));
		}
	}

	@PostMapping
	@Operation(summary = "Create a new user", description = "Creates a new user with a specified role and individual permissions.")
	public ResponseEntity<ApiResponse> createUser(@Valid @RequestBody UserCreateRequest createRequest) {
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(createRequest.password());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "Password does not meet policy: " + validationResult.getMessage(), null));
		}

		User newUser = new User();
		newUser.setUsername(createRequest.username());
		newUser.setRoleId(createRequest.roleId());
		newUser.setEmail(createRequest.email());
		newUser.setClassYear(createRequest.classYear() != null ? createRequest.classYear() : 0);
		newUser.setClassName(createRequest.className());

		String[] permissionIds = createRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		int newUserId = userService.createUserWithPermissions(newUser, createRequest.password(), permissionIds,
				getSystemUsername());
		if (newUserId > 0) {
			User createdUser = userDAO.getUserById(newUserId);
			return new ResponseEntity<>(new ApiResponse(true, "User created successfully", createdUser),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "User could not be created (username or email may already exist).", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a user", description = "Updates an existing user's profile details, role, and individual permissions.")
	public ResponseEntity<ApiResponse> updateUser(
			@Parameter(description = "ID of the user to update") @PathVariable int id,
			@Valid @RequestBody UserUpdateRequest updateRequest) {

		User userToUpdate = userDAO.getUserById(id);
		if (userToUpdate == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found.", null));
		}

		userToUpdate.setUsername(updateRequest.username());
		userToUpdate.setRoleId(updateRequest.roleId());
		userToUpdate.setEmail(updateRequest.email());
		userToUpdate.setClassYear(updateRequest.classYear() != null ? updateRequest.classYear() : 0);
		userToUpdate.setClassName(updateRequest.className());
		userToUpdate.setAdminNotes(updateRequest.adminNotes());

		String[] permissionIds = updateRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		if (userService.updateUserWithPermissions(userToUpdate, permissionIds)) {
			adminLogService.log(getSystemUsername(), "UPDATE_USER_API",
					"User '" + userToUpdate.getUsername() + "' (ID: " + id + ") updated via API.");
			User refreshedUser = userDAO.getUserById(id);
			return ResponseEntity.ok(new ApiResponse(true, "User updated successfully", refreshedUser));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to update user.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a user", description = "Permanently deletes a user from the system.")
	public ResponseEntity<ApiResponse> deleteUser(
			@Parameter(description = "ID of the user to delete") @PathVariable int id) {

		User userToDelete = userDAO.getUserById(id);
		if (userToDelete == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to delete not found.", null));
		}

		if (userToDelete.getId() == 1) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "The default admin account cannot be deleted.", null));
		}

		if (userDAO.deleteUser(id)) {
			adminLogService.log(getSystemUsername(), "DELETE_USER_API",
					"User '" + userToDelete.getUsername() + "' (ID: " + id + ") deleted via API.");
			return ResponseEntity.ok(new ApiResponse(true, "User deleted successfully", Map.of("deletedUserId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete user.", null));
		}
	}

	@PostMapping("/{id}/reset-password")
	@Operation(summary = "Reset user's password", description = "Resets a user's password to a new, randomly generated password.")
	public ResponseEntity<ApiResponse> resetPassword(
			@Parameter(description = "ID of the user whose password will be reset") @PathVariable int id) {

		User userToReset = userDAO.getUserById(id);
		if (userToReset == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to reset not found.", null));
		}

		String newPassword = generateRandomPassword(12);
		if (userDAO.changePassword(id, newPassword)) {
			adminLogService.log(getSystemUsername(), "RESET_PASSWORD_API",
					"Password for user '" + userToReset.getUsername() + "' (ID: " + id + ") reset via API.");
			return ResponseEntity
					.ok(new ApiResponse(true, "Password for " + userToReset.getUsername() + " has been reset.",
							Map.of("username", userToReset.getUsername(), "newPassword", newPassword)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Password could not be reset.", null));
		}
	}

	@PostMapping("/{id}/unlock")
	@Operation(summary = "Unlock a user account", description = "Unlocks a user account that was locked due to too many failed login attempts.")
	public ResponseEntity<ApiResponse> unlockUser(
			@Parameter(description = "ID of the user to unlock") @PathVariable int id) {

		User userToUnlock = userDAO.getUserById(id);
		if (userToUnlock == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to unlock not found.", null));
		}

		loginAttemptService.clearLoginAttempts(userToUnlock.getUsername());
		adminLogService.log(getSystemUsername(), "UNLOCK_USER_API",
				"User account '" + userToUnlock.getUsername() + "' (ID: " + id + ") unlocked via API.");
		return ResponseEntity.ok(new ApiResponse(true,
				"User account '" + userToUnlock.getUsername() + "' has been unlocked.", Map.of("unlockedUserId", id)));
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\WikiResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.WikiUpdateRequest;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.WikiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/wiki")
@Tag(name = "Admin Wiki", description = "Endpoints for managing the technical documentation wiki.")
public class WikiResource {

	private final WikiService wikiService;
	private final WikiDAO wikiDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public WikiResource(WikiService wikiService, WikiDAO wikiDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.wikiService = wikiService;
		this.wikiDAO = wikiDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get wiki navigation tree", description = "Retrieves the entire wiki page structure as a hierarchical tree.")
	public ResponseEntity<ApiResponse> getWikiTree() {
		Map<String, Object> treeData = wikiService.getWikiTreeAsData();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Struktur erfolgreich abgerufen.", treeData));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single wiki page", description = "Retrieves the content of a single wiki page by its ID.")
	public ResponseEntity<ApiResponse> getWikiEntryById(
			@Parameter(description = "ID of the wiki page to retrieve") @PathVariable int id) {
		Optional<WikiEntry> entryOptional = wikiDAO.getWikiEntryById(id);
		return entryOptional.map(entry -> ResponseEntity.ok(new ApiResponse(true, "Inhalt geladen.", entry)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new wiki page", description = "Creates a new documentation page in the wiki.")
	public ResponseEntity<ApiResponse> createWikiEntry(@Valid @RequestBody WikiEntry newEntry) {
		if (newEntry.getFilePath() == null || newEntry.getFilePath().isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Dateipfad darf nicht leer sein.", null));
		}
		if (wikiDAO.findByFilePath(newEntry.getFilePath()).isPresent()) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Ein Eintrag mit diesem Dateipfad existiert bereits.", null));
		}

		newEntry.setContent(richTextPolicy.sanitize(newEntry.getContent()));
		Optional<WikiEntry> createdEntryOptional = wikiDAO.createWikiEntry(newEntry);
		if (createdEntryOptional.isPresent()) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_WIKI_PAGE",
					"Created wiki page: " + createdEntryOptional.get().getFilePath());
			return new ResponseEntity<>(
					new ApiResponse(true, "Seite erfolgreich erstellt.", createdEntryOptional.get()),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Seite konnte nicht in der Datenbank erstellt werden.", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a wiki page", description = "Updates the content of an existing wiki page.")
	public ResponseEntity<ApiResponse> updateWikiEntry(
			@Parameter(description = "ID of the wiki page to update") @PathVariable int id,
			@Valid @RequestBody WikiUpdateRequest updateRequest) {

		String sanitizedContent = richTextPolicy.sanitize(updateRequest.content());
		if (wikiDAO.updateWikiContent(id, sanitizedContent)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_WIKI_PAGE", "Updated wiki page ID: " + id);
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false,
					"Seite konnte nicht aktualisiert werden. Sie existiert möglicherweise nicht.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a wiki page", description = "Permanently deletes a wiki page.")
	public ResponseEntity<ApiResponse> deleteWikiEntry(
			@Parameter(description = "ID of the wiki page to delete") @PathVariable int id) {

		Optional<WikiEntry> entryToDelete = wikiDAO.getWikiEntryById(id);
		if (entryToDelete.isEmpty()) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null));
		}

		if (wikiDAO.deleteWikiEntry(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_WIKI_PAGE",
					"Deleted wiki page: " + entryToDelete.get().getFilePath());
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich gelöscht.", Map.of("deletedId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Löschen der Seite.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\AuthResource.java
========================================================================

package de.technikteam.api.v1.auth;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AuthService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.dao.UserDAO;
import de.technikteam.util.NavigationRegistry;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/auth")
@Tag(name = "Authentication", description = "Endpoints for user authentication.")
public class AuthResource {
	private static final Logger logger = LogManager.getLogger(AuthResource.class);

	private final UserDAO userDAO;
	private final AuthService authService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public AuthResource(UserDAO userDAO, AuthService authService, LoginAttemptService loginAttemptService) {
		this.userDAO = userDAO;
		this.authService = authService;
		this.loginAttemptService = loginAttemptService;
	}

	@PostMapping("/login")
	@Operation(summary = "User Login", description = "Authenticates a user with username and password. On success, it sets an HttpOnly cookie with the JWT and returns user session data.", requestBody = @RequestBody(description = "User credentials for login.", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = LoginRequest.class))))
	public ResponseEntity<ApiResponse> login(
			@org.springframework.web.bind.annotation.RequestBody LoginRequest loginRequest, HttpServletRequest request,
			HttpServletResponse response) {
		String username = loginRequest.username();
		String password = loginRequest.password();
		String ipAddress = getClientIp(request);

		if (loginAttemptService.isLockedOut(username, ipAddress)) {
			logger.warn("Blocked login attempt for locked-out user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Konto ist vorübergehend gesperrt.", null),
					HttpStatus.FORBIDDEN);
		}

		User user = userDAO.validateUser(username, password);
		if (user != null) {
			loginAttemptService.clearLoginAttempts(username);
			authService.addJwtCookie(user, response);
			logger.info("JWT cookie set successfully for user '{}'", username);
			// Return user data but not the token itself
			return ResponseEntity.ok(new ApiResponse(true, "Anmeldung erfolgreich", user));
		} else {
			loginAttemptService.recordFailedLogin(username, ipAddress);
			logger.warn("Failed API login attempt for user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Falscher Benutzername oder Passwort.", null),
					HttpStatus.UNAUTHORIZED);
		}
	}

	@GetMapping("/me")
	@Operation(summary = "Get current user session", description = "Retrieves the user object and navigation items for the currently authenticated user.", security = @SecurityRequirement(name = "bearerAuth"))
	public ResponseEntity<ApiResponse> getCurrentUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User authenticatedUser = securityUser.getUser();
		List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(authenticatedUser);
		Map<String, Object> responseData = Map.of("user", authenticatedUser, "navigation", navigationItems);
		return ResponseEntity.ok(new ApiResponse(true, "Current user session retrieved.", responseData));
	}

	@PostMapping("/logout")
	@Operation(summary = "User Logout", description = "Logs out the user by clearing the JWT authentication cookie.")
	public ResponseEntity<ApiResponse> logout(HttpServletResponse response) {
		authService.clearJwtCookie(response);
		return ResponseEntity.ok(new ApiResponse(true, "Abmeldung erfolgreich", null));
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\LoginRequest.java
========================================================================

package de.technikteam.api.v1.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/**
 * A Data Transfer Object (DTO) representing the credentials for a login
 * request. Using a dedicated DTO provides type safety and allows for
 * declarative validation.
 */
public record LoginRequest(
		@NotBlank(message = "Username cannot be blank") @Schema(description = "The user's unique username.", example = "admin", required = true) String username,

		@NotBlank(message = "Password cannot be blank") @Schema(description = "The user's password.", example = "admin123", required = true) String password) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\CategoryRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record CategoryRequest(
		@NotBlank(message = "Kategoriename darf nicht leer sein") @Size(min = 2, max = 100, message = "Kategoriename muss zwischen 2 und 100 Zeichen lang sein") @Schema(description = "The name for the new file category.", required = true) String name) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventDebriefingDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;
import java.util.List;

public record EventDebriefingDTO(@NotNull @Schema(description = "Summary of what went well.") String whatWentWell,
		@NotNull @Schema(description = "Summary of what could be improved.") String whatToImprove,
		@Schema(description = "Notes about specific equipment performance.") String equipmentNotes,
		@Schema(description = "List of user IDs for crew members who performed exceptionally.") List<Integer> standoutCrewMemberIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;

public record EventUpdateRequest(@NotBlank @Schema(description = "Name of the event") String name,
		@NotNull @Schema(description = "Start date and time of the event") LocalDateTime eventDateTime,
		@Schema(description = "End date and time of the event") LocalDateTime endDateTime,
		@Schema(description = "Detailed description of the event") String description,
		@Schema(description = "Location of the event") String location,
		@Schema(description = "Current status of the event (e.g., GEPLANT, LAUFEND)") String status,
		@Schema(description = "ID of the user leading the event") Integer leaderUserId,
		@Schema(description = "Required role for viewing attachments") String requiredRole,
		@Schema(description = "Reminder time in minutes before the event starts") Integer reminderMinutes,
		@Schema(description = "Array of course IDs for skill requirements") List<String> requiredCourseIds,
		@Schema(description = "Array of required person counts for skills") List<String> requiredPersons,
		@Schema(description = "Array of item IDs for reservations") List<String> itemIds,
		@Schema(description = "Array of quantities for reserved items") List<String> quantities) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\GeneralFeedbackRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record GeneralFeedbackRequest(
		@NotBlank(message = "Betreff darf nicht leer sein") @Size(max = 255, message = "Betreff darf nicht länger als 255 Zeichen sein") @Schema(description = "The subject line of the feedback.", required = true) String subject,

		@NotBlank(message = "Inhalt darf nicht leer sein") @Schema(description = "The detailed content of the feedback.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\MeetingRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

public record MeetingRequest(
		@NotNull(message = "Kurs-ID darf nicht null sein") @Schema(description = "The ID of the parent course for this meeting.", required = true) Integer courseId,

		@NotBlank(message = "Meeting-Name darf nicht leer sein") @Schema(description = "The name of the meeting.", required = true, example = "Teil 1: Grundlagen") String name,

		@NotNull(message = "Datum und Uhrzeit des Meetings dürfen nicht null sein") @FutureOrPresent(message = "Das Datum des Meetings muss in der Gegenwart oder Zukunft liegen") @Schema(description = "The start date and time of the meeting.", required = true) LocalDateTime meetingDateTime,

		@Schema(description = "The optional end date and time of the meeting.") LocalDateTime endDateTime,

		@Schema(description = "The ID of the user leading the meeting.") Integer leaderUserId,

		@Schema(description = "A description of the meeting's content.") String description,

		@Schema(description = "The location of the meeting.") String location) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\NotificationRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record NotificationRequest(
		@NotBlank(message = "Titel darf nicht leer sein") @Size(max = 100, message = "Titel darf 100 Zeichen nicht überschreiten") @Schema(description = "The title of the notification.", required = true) String title,

		@NotBlank(message = "Beschreibung darf nicht leer sein") @Schema(description = "The main content of the notification.", required = true) String description,

		@NotBlank(message = "Stufe darf nicht leer sein") @Schema(description = "The severity level of the notification.", required = true, allowableValues = {
				"Informational", "Important", "Warning" }) String level,

		@NotBlank(message = "Zieltyp darf nicht leer sein") @Schema(description = "The target audience type.", required = true, allowableValues = {
				"ALL", "EVENT", "MEETING" }) String targetType,

		@Schema(description = "The ID of the event or meeting if targetType is EVENT or MEETING.") Integer targetId){
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\PasswordChangeRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

public record PasswordChangeRequest(
		@NotBlank(message = "Aktuelles Passwort darf nicht leer sein") @Schema(description = "The user's current password.", required = true) String currentPassword,

		@NotBlank(message = "Neues Passwort darf nicht leer sein") @Schema(description = "The desired new password. Must meet the password policy.", required = true) String newPassword,

		@NotBlank(message = "Bestätigungspasswort darf nicht leer sein") @Schema(description = "Confirmation of the new password.", required = true) String confirmPassword) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\ProfileChangeRequestDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;

public record ProfileChangeRequestDTO(
		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's new email address.") String email,

		@Schema(description = "The user's new class year.") Integer classYear,

		@Schema(description = "The user's new class name.") String className,

		@Schema(description = "The user's new profile icon class (e.g., 'fa-user-ninja').") String profileIconClass) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserCreateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserCreateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotBlank(message = "Passwort darf nicht leer sein") @Schema(description = "The user's initial password. Must meet the password policy.", required = true) String password,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserUpdateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@Schema(description = "Admin-only notes about the user.") String adminNotes,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\WikiUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record WikiUpdateRequest(
		@NotNull(message = "Inhalt darf nicht null sein") @Schema(description = "The full Markdown content of the wiki page.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarEntriesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/calendar")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarEntriesResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarEntriesResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/entries")
	@Operation(summary = "Get calendar entries", description = "Retrieves a combined list of upcoming events and meetings for display in a calendar.")
	public ResponseEntity<ApiResponse> getCalendarEntries() {
		List<Map<String, Object>> entries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", event.getId());
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("end", event.getEndDateTime());
			entry.put("type", "Event");
			entry.put("url", "/veranstaltungen/details/" + event.getId());
			entries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", meeting.getId());
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("end", meeting.getEndDateTime());
			entry.put("type", "Lehrgang");
			entry.put("url", "/lehrgaenge/details/" + meeting.getId());
			entries.add(entry);
		}

		return ResponseEntity.ok(new ApiResponse(true, "Kalendereinträge erfolgreich abgerufen.", entries));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.*;
import net.fortuna.ical4j.util.RandomUidGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayOutputStream;
import java.net.URI;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

@RestController
@RequestMapping("/api/v1/public")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/calendar.ics")
	@Operation(summary = "Get iCalendar Feed", description = "Provides an iCalendar (.ics) feed of all upcoming events and meetings.", responses = {
			@ApiResponse(responseCode = "200", description = "iCalendar feed generated successfully", content = @Content(mediaType = "text/calendar")),
			@ApiResponse(responseCode = "500", description = "Internal server error while generating the feed") })
	public ResponseEntity<byte[]> getICalendarFeed(HttpServletRequest request) {
		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-//TechnikTeam Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
					+ request.getContextPath();
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());
				if (event.getEventDateTime() != null) {
					vEvent.getProperties().add(new DtStart(
							new DateTime(Date.from(event.getEventDateTime().atZone(systemZone).toInstant()))));
				}
				if (event.getEndDateTime() != null) {
					vEvent.getProperties().add(
							new DtEnd(new DateTime(Date.from(event.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				vEvent.getProperties().add(new Url(new URI(baseUrl + "/veranstaltungen/details/" + event.getId())));
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());
				if (meeting.getMeetingDateTime() != null) {
					vMeeting.getProperties().add(new DtStart(
							new DateTime(Date.from(meeting.getMeetingDateTime().atZone(systemZone).toInstant()))));
				}
				if (meeting.getEndDateTime() != null) {
					vMeeting.getProperties().add(new DtEnd(
							new DateTime(Date.from(meeting.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				vMeeting.getProperties().add(new Url(new URI(baseUrl + "/lehrgaenge/details/" + meeting.getId())));
				calendar.getComponents().add(vMeeting);
			}

			ByteArrayOutputStream boas = new ByteArrayOutputStream();
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, boas);

			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.parseMediaType("text/calendar"));
			headers.setContentDispositionFormData("attachment", "technikteam-calendar.ics");

			return new ResponseEntity<>(boas.toByteArray(), headers, HttpStatus.OK);

		} catch (Exception e) {
			return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChangelogResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChangelogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/public/changelog")
@Tag(name = "Public Changelog", description = "Endpoints for user-facing changelog features.")
public class PublicChangelogResource {

	private final ChangelogDAO changelogDAO;

	@Autowired
	public PublicChangelogResource(ChangelogDAO changelogDAO) {
		this.changelogDAO = changelogDAO;
	}

	@GetMapping
	@Operation(summary = "Get all published changelogs")
	public ResponseEntity<ApiResponse> getAllPublishedChangelogs() {
		List<Changelog> changelogs = changelogDAO.findAllPublished();
		return ResponseEntity.ok(new ApiResponse(true, "Published changelogs retrieved.", changelogs));
	}

	@GetMapping("/latest-unseen")
	@Operation(summary = "Get the latest unseen changelog for the current user")
	public ResponseEntity<ApiResponse> getLatestUnseenChangelog(@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.ok(new ApiResponse(true, "User not authenticated.", null));
		}
		Optional<Changelog> changelog = changelogDAO.findLatestUnseen(securityUser.getUser().getId());
		return ResponseEntity.ok(new ApiResponse(true, "Latest unseen changelog retrieved.", changelog.orElse(null)));
	}

	@PostMapping("/{id}/mark-seen")
	@Operation(summary = "Mark a changelog as seen by the current user")
	public ResponseEntity<ApiResponse> markAsSeen(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (securityUser == null) {
			return ResponseEntity.status(401).body(new ApiResponse(false, "User not authenticated.", null));
		}
		if (changelogDAO.markAsSeen(id, securityUser.getUser().getId())) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog marked as seen.", null));
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Could not mark as seen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicChatResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.ChatDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/chat")
@Tag(name = "Public Chat", description = "Endpoints for user direct messaging.")
@SecurityRequirement(name = "bearerAuth")
public class PublicChatResource {

	private final ChatDAO chatDAO;
	private final FileService fileService;

	@Autowired
	public PublicChatResource(ChatDAO chatDAO, FileService fileService) {
		this.chatDAO = chatDAO;
		this.fileService = fileService;
	}

	@GetMapping("/conversations")
	@Operation(summary = "Get user's conversations")
	public ResponseEntity<ApiResponse> getConversations(@AuthenticationPrincipal SecurityUser securityUser) {
		return ResponseEntity.ok(new ApiResponse(true, "Gespräche abgerufen.",
				chatDAO.getConversationsForUser(securityUser.getUser().getId())));
	}

	@GetMapping("/conversations/{id}")
	@Operation(summary = "Get a single conversation's details")
	public ResponseEntity<ApiResponse> getConversationById(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			return new ResponseEntity<>(new ApiResponse(false, "Nicht autorisiert.", null), HttpStatus.FORBIDDEN);
		}
		ChatConversation conversation = chatDAO.getConversationById(id);
		return ResponseEntity.ok(new ApiResponse(true, "Gespräch abgerufen.", conversation));
	}

	@GetMapping("/conversations/{id}/messages")
	@Operation(summary = "Get messages for a conversation")
	public ResponseEntity<ApiResponse> getMessages(@PathVariable int id, @RequestParam(defaultValue = "50") int limit,
			@RequestParam(defaultValue = "0") int offset, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!chatDAO.isUserInConversation(id, securityUser.getUser().getId())) {
			return new ResponseEntity<>(new ApiResponse(false, "Nicht autorisiert.", null), HttpStatus.FORBIDDEN);
		}
		return ResponseEntity.ok(
				new ApiResponse(true, "Nachrichten abgerufen.", chatDAO.getMessagesForConversation(id, limit, offset)));
	}

	@PostMapping("/conversations")
	@Operation(summary = "Find or create a conversation with a user")
	public ResponseEntity<ApiResponse> findOrCreateConversation(@RequestBody Map<String, Integer> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		Integer otherUserId = payload.get("userId");
		if (otherUserId == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Benutzer-ID fehlt.", null));
		}
		int conversationId = chatDAO.findOrCreateConversation(securityUser.getUser().getId(), otherUserId);
		return ResponseEntity.ok(
				new ApiResponse(true, "Gespräch gefunden oder erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/group")
	@Operation(summary = "Create a new group conversation")
	public ResponseEntity<ApiResponse> createGroupConversation(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String name = (String) payload.get("name");
		@SuppressWarnings("unchecked")
		List<Integer> participantIds = (List<Integer>) payload.get("participantIds");

		if (name == null || name.isBlank() || participantIds == null || participantIds.isEmpty()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Gruppenname und Teilnehmer sind erforderlich.", null));
		}

		int conversationId = chatDAO.createGroupConversation(name, securityUser.getUser().getId(), participantIds);
		return ResponseEntity.status(HttpStatus.CREATED)
				.body(new ApiResponse(true, "Gruppe erfolgreich erstellt.", Map.of("conversationId", conversationId)));
	}

	@PostMapping("/conversations/{id}/participants")
	@Operation(summary = "Add participants to a group")
	public ResponseEntity<ApiResponse> addParticipants(@PathVariable int id,
			@RequestBody Map<String, List<Integer>> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		ChatConversation conversation = chatDAO.getConversationById(id);
		if (conversation == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Gespräch nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		if (!conversation.isGroupChat() || conversation.getCreatorId() != securityUser.getUser().getId()) {
			return new ResponseEntity<>(
					new ApiResponse(false, "Nur der Ersteller der Gruppe kann Mitglieder hinzufügen.", null),
					HttpStatus.FORBIDDEN);
		}
		List<Integer> userIds = payload.get("userIds");
		if (userIds == null || userIds.isEmpty()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Keine Benutzer-IDs angegeben.", null));
		}

		chatDAO.addParticipantsToGroup(id, userIds);
		return ResponseEntity.ok(new ApiResponse(true, "Teilnehmer erfolgreich hinzugefügt.", null));
	}

	@PostMapping("/upload")
	@Operation(summary = "Upload a file for chat")
	public ResponseEntity<ApiResponse> uploadChatFile(@RequestParam("file") MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"chat");
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDashboardResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/dashboard")
@Tag(name = "Public Dashboard", description = "Endpoints for the user-facing dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class PublicDashboardResource {

	private final EventDAO eventDAO;
	private final EventTaskDAO eventTaskDAO;

	@Autowired
	public PublicDashboardResource(EventDAO eventDAO, EventTaskDAO eventTaskDAO) {
		this.eventDAO = eventDAO;
		this.eventTaskDAO = eventTaskDAO;
	}

	@GetMapping
	@Operation(summary = "Get dashboard data", description = "Retrieves all necessary data for the user's main dashboard view.")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getAllActiveAndUpcomingEvents(); // Simplified for now

		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("assignedEvents", assignedEvents);
		dashboardData.put("openTasks", openTasks);
		dashboardData.put("upcomingEvents", upcomingEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
@SecurityRequirement(name = "bearerAuth")
public class PublicEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;
	private final EventCustomFieldDAO customFieldDAO;
	private final FileService fileService;

	@Autowired
	public PublicEventResource(EventDAO eventDAO, EventService eventService, EventCustomFieldDAO customFieldDAO,
			FileService fileService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
		this.customFieldDAO = customFieldDAO;
		this.fileService = fileService;
	}

	@GetMapping
	@Operation(summary = "Get upcoming events for user", description = "Retrieves a list of upcoming events, indicating the user's current attendance and qualification status for each.")
	public ResponseEntity<ApiResponse> getUpcomingEventsForUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Event> events = eventDAO.getUpcomingEventsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get event details", description = "Retrieves detailed information for a single event.")
	public ResponseEntity<ApiResponse> getEventDetails(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		Event event = eventDAO.getEventById(id);
		if (event == null) {
			return ResponseEntity.status(404).body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungsdetails erfolgreich abgerufen.", event));
	}

	@PostMapping("/{id}/signup")
	@Operation(summary = "Sign up for an event", description = "Allows the current user to sign up for an event and submit custom field responses.")
	public ResponseEntity<ApiResponse> signUpForEvent(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> customFieldResponses) {
		User user = securityUser.getUser();
		eventDAO.signUpForEvent(user.getId(), id);
		if (customFieldResponses != null) {
			customFieldResponses.forEach((key, value) -> {
				if (key.startsWith("customfield_")) {
					int fieldId = Integer.parseInt(key.substring("customfield_".length()));
					EventCustomFieldResponse response = new EventCustomFieldResponse();
					response.setFieldId(fieldId);
					response.setUserId(user.getId());
					response.setResponseValue(value);
					customFieldDAO.saveResponse(response);
				}
			});
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich für die Veranstaltung angemeldet.", null));
	}

	@PostMapping("/{id}/signoff")
	@Operation(summary = "Sign off from an event", description = "Allows the current user to sign off from an event.")
	public ResponseEntity<ApiResponse> signOffFromEvent(
			@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> payload) {
		User user = securityUser.getUser();
		String reason = payload.get("reason");
		Event event = eventDAO.getEventById(id);
		if ("LAUFEND".equals(event.getStatus())) {
			eventService.signOffUserFromRunningEvent(user.getId(), user.getUsername(), id, reason);
		} else {
			eventDAO.signOffFromEvent(user.getId(), id);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich von der Veranstaltung abgemeldet.", null));
	}

	@GetMapping("/{id}/custom-fields")
	@Operation(summary = "Get custom fields for an event", description = "Retrieves the list of custom fields required for signing up for a specific event.")
	public ResponseEntity<ApiResponse> getEventCustomFields(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(id);
		return ResponseEntity.ok(new ApiResponse(true, "Zusatzfelder erfolgreich abgerufen.", fields));
	}

	@PostMapping("/{eventId}/chat/upload")
	@Operation(summary = "Upload a file to an event chat")
	public ResponseEntity<ApiResponse> uploadEventChatFile(@PathVariable int eventId,
			@RequestParam("file") MultipartFile file, @AuthenticationPrincipal SecurityUser securityUser) {
		if (!eventDAO.isUserAssociatedWithEvent(eventId, securityUser.getUser().getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN)
					.body(new ApiResponse(false, "Nicht berechtigt, Dateien in diesem Chat hochzuladen.", null));
		}
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, null, "NUTZER", securityUser.getUser(),
					"eventchat/" + eventId);
			return ResponseEntity.ok(new ApiResponse(true, "Datei hochgeladen.", savedFile));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei-Upload fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFeedbackResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.api.v1.dto.GeneralFeedbackRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/feedback")
@Tag(name = "Public Feedback", description = "Endpoints for users to submit and view feedback.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;
	private final EventFeedbackDAO eventFeedbackDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicFeedbackResource(FeedbackSubmissionDAO submissionDAO, EventFeedbackDAO eventFeedbackDAO,
			EventDAO eventDAO) {
		this.submissionDAO = submissionDAO;
		this.eventFeedbackDAO = eventFeedbackDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/user")
	@Operation(summary = "Get user's feedback submissions", description = "Retrieves a list of all general feedback submissions made by the current user.")
	public ResponseEntity<ApiResponse> getMyFeedbackSubmissions(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<FeedbackSubmission> submissions = submissionDAO.getSubmissionsByUserId(user.getId());
		return ResponseEntity.ok(new ApiResponse(true, "Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PostMapping("/general")
	@Operation(summary = "Submit general feedback", description = "Allows a user to submit a new general feedback entry.")
	public ResponseEntity<ApiResponse> submitGeneralFeedback(@Valid @RequestBody GeneralFeedbackRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		FeedbackSubmission submission = new FeedbackSubmission();
		submission.setUserId(user.getId());
		submission.setSubject(request.subject());
		submission.setContent(request.content());

		if (submissionDAO.createSubmission(submission)) {
			return new ResponseEntity<>(new ApiResponse(true, "Feedback erfolgreich übermittelt.", submission),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Feedback konnte nicht gespeichert werden.", null));
		}
	}

	@GetMapping("/forms")
	@Operation(summary = "Get feedback form for an event", description = "Retrieves the feedback form for a specific event and checks if the user has already submitted a response.")
	public ResponseEntity<ApiResponse> getEventFeedbackForm(
			@Parameter(description = "ID of the event") @RequestParam int eventId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		FeedbackForm form = eventFeedbackDAO.getFeedbackFormForEvent(eventId);
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Kein Feedback-Formular für diese Veranstaltung.", null));
		}
		boolean alreadySubmitted = eventFeedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId());

		Map<String, Object> responseData = Map.of("event", event, "form", form, "alreadySubmitted", alreadySubmitted);
		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/event")
	@Operation(summary = "Submit event feedback", description = "Submits a user's rating and comments for an event feedback form.")
	public ResponseEntity<ApiResponse> submitEventFeedback(@RequestBody FeedbackResponse response,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		response.setUserId(user.getId());

		// --- REMEDIATION START ---
		FeedbackForm form = eventFeedbackDAO.getFormById(response.getFormId());
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Feedback-Formular nicht gefunden.", null));
		}
		// Check if user was actually assigned to the event for which they are giving
		// feedback
		if (!eventDAO.isUserAssociatedWithEvent(form.getEventId(), user.getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false,
					"Sie können nur Feedback für Veranstaltungen abgeben, an denen Sie teilgenommen haben.", null));
		}
		// --- REMEDIATION END ---

		if (eventFeedbackDAO.saveFeedbackResponse(response)) {
			return ResponseEntity.ok(new ApiResponse(true, "Event-Feedback erfolgreich übermittelt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Event-Feedback konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFilesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.File;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFilesResource {

	private final FileDAO fileDAO;

	@Autowired
	public PublicFilesResource(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@GetMapping
	@Operation(summary = "Get all accessible files grouped by category", description = "Retrieves files visible to the current user, grouped by their category.")
	public ResponseEntity<ApiResponse> getFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, List<File>> files = fileDAO.getAllFilesGroupedByCategory(user);
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", files));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFileStreamResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.*;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
public class PublicFileStreamResource {
	private static final Logger logger = LogManager.getLogger(PublicFileStreamResource.class);

	private final FileDAO fileDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final Path fileStorageLocation;

	@Autowired
	public PublicFileStreamResource(FileDAO fileDAO, AttachmentDAO attachmentDAO, EventDAO eventDAO,
			MeetingDAO meetingDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.attachmentDAO = attachmentDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	@GetMapping("/download/{id}")
	@Operation(summary = "Download a file", description = "Downloads a file (general or attachment) by its database ID after checking permissions.")
	@ApiResponse(responseCode = "200", description = "File content", content = @Content(mediaType = "application/octet-stream"))
	public ResponseEntity<Resource> downloadFile(
			@Parameter(description = "ID of the file or attachment record") @PathVariable int id) {
		String filePathFromDb = null;
		String filenameForDownload = null;

		Attachment attachment = attachmentDAO.getAttachmentById(id);
		if (attachment != null) {
			filePathFromDb = attachment.getFilepath();
			filenameForDownload = attachment.getFilename();
		} else {
			de.technikteam.model.File dbFile = fileDAO.getFileById(id);
			if (dbFile != null) {
				filePathFromDb = dbFile.getFilepath();
				filenameForDownload = dbFile.getFilename();
			}
		}

		if (filePathFromDb == null)
			return ResponseEntity.notFound().build();

		return serveFile(filePathFromDb, filenameForDownload, false);
	}

	@GetMapping("/images/{filename:.+}")
	@Operation(summary = "Get an inventory image", description = "Retrieves an inventory image for display. The filename usually corresponds to a storage item's image path.")
	@ApiResponse(responseCode = "200", description = "Image content", content = @Content(mediaType = "image/*"))
	public ResponseEntity<Resource> getImage(
			@Parameter(description = "The filename of the image") @PathVariable String filename) {
		return serveFile("images/" + filename, filename, true);
	}

	private ResponseEntity<Resource> serveFile(String relativePath, String originalFilename, boolean inline) {
		try {
			Path filePath = this.fileStorageLocation.resolve(relativePath).normalize();
			if (!filePath.startsWith(this.fileStorageLocation)) {
				logger.warn("Path Traversal Attack attempt detected for path '{}'", filePath);
				return ResponseEntity.status(403).build();
			}

			Resource resource = new UrlResource(filePath.toUri());
			if (resource.exists() || resource.isReadable()) {
				String contentType = "application/octet-stream"; // fallback
				try {
					contentType = Files.probeContentType(filePath);
				} catch (IOException e) {
					logger.warn("Could not determine content type for file {}", filePath);
				}

				String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+",
						"%20");
				String disposition = inline ? "inline" : "attachment";

				return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))
						.header(HttpHeaders.CONTENT_DISPOSITION, disposition + "; filename*=UTF-8''" + encodedFilename)
						.body(resource);
			} else {
				logger.error("File not found or not readable at path: {}", filePath);
				return ResponseEntity.notFound().build();
			}
		} catch (MalformedURLException ex) {
			logger.error("Malformed URL for file path: {}", relativePath, ex);
			return ResponseEntity.notFound().build();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicMeetingResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/meetings")
@Tag(name = "Public Meetings", description = "Endpoints for user interactions with training meetings.")
@SecurityRequirement(name = "bearerAuth")
public class PublicMeetingResource {

	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO attendanceDAO;

	@Autowired
	public PublicMeetingResource(MeetingDAO meetingDAO, MeetingAttendanceDAO attendanceDAO) {
		this.meetingDAO = meetingDAO;
		this.attendanceDAO = attendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get upcoming meetings for user", description = "Retrieves a list of upcoming meetings, indicating the user's current attendance status for each.")
	public ResponseEntity<ApiResponse> getUpcomingMeetings(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@PostMapping("/{id}/{action}")
	@Operation(summary = "Sign up or off from a meeting", description = "Allows the current user to sign up for or sign off from a specific meeting.")
	public ResponseEntity<ApiResponse> handleMeetingAction(
			@Parameter(description = "ID of the meeting") @PathVariable int id,
			@Parameter(description = "Action to perform. Must be 'signup' or 'signoff'.") @PathVariable String action,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		boolean success;
		if ("signup".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, true, "");
		} else if ("signoff".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, false, "");
		} else {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Unbekannte Aktion.", null));
		}

		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich ausgeführt.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Aktion konnte nicht verarbeitet werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicProfileResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.PasswordChangeRequest;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.*;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/profile")
@Tag(name = "Public Profile", description = "Endpoints for managing the current user's profile.")
@SecurityRequirement(name = "bearerAuth")
public class PublicProfileResource {

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final AchievementDAO achievementDAO;
	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService profileRequestService;

	@Autowired
	public PublicProfileResource(UserDAO userDAO, EventDAO eventDAO, UserQualificationsDAO qualificationsDAO,
			AchievementDAO achievementDAO, ProfileChangeRequestDAO requestDAO,
			ProfileRequestService profileRequestService) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.achievementDAO = achievementDAO;
		this.requestDAO = requestDAO;
		this.profileRequestService = profileRequestService;
	}

	@GetMapping
	@Operation(summary = "Get current user's profile data", description = "Retrieves a comprehensive set of data for the authenticated user's profile page.")
	public ResponseEntity<ApiResponse> getMyProfile(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user);
		profileData.put("eventHistory", eventDAO.getEventHistoryForUser(user.getId()));
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(user.getId()));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(user.getId()));
		profileData.put("passkeys", Collections.emptyList()); // Passkeys removed
		profileData.put("hasPendingRequest", requestDAO.hasPendingRequest(user.getId()));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@PostMapping("/request-change")
	@Operation(summary = "Request a profile data change", description = "Submits a request for an administrator to approve changes to the user's profile data.")
	public ResponseEntity<ApiResponse> requestProfileChange(@Valid @RequestBody ProfileChangeRequestDTO requestDTO,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			profileRequestService.createChangeRequest(securityUser.getUser(), requestDTO);
			return ResponseEntity.ok(new ApiResponse(true, "Änderungsantrag erfolgreich eingereicht.", null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Ihr Antrag konnte nicht gespeichert werden: " + e.getMessage(), null));
		}
	}

	@PutMapping("/theme")
	@Operation(summary = "Update user theme", description = "Updates the user's preferred theme (light/dark).")
	public ResponseEntity<ApiResponse> updateUserTheme(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String theme = payload.get("theme");
		if (theme != null && (theme.equals("light") || theme.equals("dark"))) {
			if (userDAO.updateUserTheme(user.getId(), theme)) {
				User updatedUser = userDAO.getUserById(user.getId());
				return ResponseEntity.ok(new ApiResponse(true, "Theme aktualisiert.", updatedUser));
			}
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Ungültiges Theme angegeben.", null));
	}

	@PutMapping("/chat-color")
	@Operation(summary = "Update chat color", description = "Updates the user's preferred color for chat messages.")
	public ResponseEntity<ApiResponse> updateChatColor(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String chatColor = payload.get("chatColor");
		if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
			return ResponseEntity.ok(new ApiResponse(true, "Chatfarbe aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Chatfarbe konnte nicht gespeichert werden.", null));
		}
	}

	@PutMapping("/password")
	@Operation(summary = "Change password", description = "Allows the authenticated user to change their own password after verifying their current one.")
	public ResponseEntity<ApiResponse> updatePassword(@Valid @RequestBody PasswordChangeRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		if (userDAO.validateUser(user.getUsername(), request.currentPassword()) == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Das aktuelle Passwort ist nicht korrekt.", null));
		}
		if (!request.newPassword().equals(request.confirmPassword())) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Die neuen Passwörter stimmen nicht überein.", null));
		}
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(request.newPassword());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, validationResult.getMessage(), null));
		}
		if (userDAO.changePassword(user.getId(), request.newPassword())) {
			return ResponseEntity.ok(new ApiResponse(true, "Ihr Passwort wurde erfolgreich geändert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Passwort konnte nicht geändert werden.", null));
		}
	}

	@PutMapping("/dashboard-layout")
	@Operation(summary = "Update dashboard layout", description = "Saves the user's custom dashboard widget layout.")
	public ResponseEntity<ApiResponse> updateDashboardLayout(@RequestBody Object layout,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String layoutJson = new Gson().toJson(layout);
		if (userDAO.updateDashboardLayout(user.getId(), layoutJson)) {
			User updatedUser = userDAO.getUserById(user.getId());
			return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Layout gespeichert.", updatedUser));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Layout konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicSearchResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.SearchService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/public/search")
@Tag(name = "Public Search", description = "Endpoints for site-wide content search.")
@SecurityRequirement(name = "bearerAuth")
public class PublicSearchResource {

	private final SearchService searchService;

	@Autowired
	public PublicSearchResource(SearchService searchService) {
		this.searchService = searchService;
	}

	@GetMapping
	@Operation(summary = "Perform a site-wide search", description = "Searches across events, inventory, and documentation for a given query.")
	public ResponseEntity<ApiResponse> search(@Parameter(description = "The search term.") @RequestParam String query,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (query == null || query.trim().length() < 3) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Der Suchbegriff muss mindestens 3 Zeichen lang sein.", null));
		}

		User user = securityUser.getUser();
		return ResponseEntity.ok(new ApiResponse(true, "Suchergebnisse erfolgreich abgerufen.",
				searchService.performSearch(query, user)));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageDetailsResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.StorageLogEntry;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageDetailsResource {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;

	@Autowired
	public PublicStorageDetailsResource(StorageDAO storageDAO, StorageLogDAO storageLogDAO,
			MaintenanceLogDAO maintenanceLogDAO) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
	}

	@GetMapping("/{itemId}")
	@Operation(summary = "Get a single storage item by ID", description = "Retrieves detailed information for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemById(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			return new ResponseEntity<>(new ApiResponse(false, "Artikel nicht gefunden.", null), HttpStatus.NOT_FOUND);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Artikeldetails erfolgreich abgerufen.", item));
	}

	@GetMapping("/{itemId}/history")
	@Operation(summary = "Get history for a storage item", description = "Retrieves the transaction and maintenance history for a single inventory item.")
	public ResponseEntity<ApiResponse> getStorageItemHistory(
			@Parameter(description = "ID of the storage item") @PathVariable int itemId) {
		List<StorageLogEntry> transactions = storageLogDAO.getHistoryForItem(itemId);
		List<MaintenanceLogEntry> maintenance = maintenanceLogDAO.getHistoryForItem(itemId);

		Map<String, Object> historyData = new HashMap<>();
		historyData.put("transactions", transactions);
		historyData.put("maintenance", maintenance);

		return ResponseEntity.ok(new ApiResponse(true, "Verlauf erfolgreich abgerufen.", historyData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageResource {

	private final StorageService storageService;
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicStorageResource(StorageService storageService, StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageService = storageService;
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping
	@Operation(summary = "Get all storage data for display", description = "Retrieves all storage items grouped by location and a list of active events for the transaction modal.")
	public ResponseEntity<ApiResponse> getStoragePageData() {
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("storageData", storageData);
		responseData.put("activeEvents", activeEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Lagerdaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/transactions")
	@Operation(summary = "Perform a storage transaction", description = "Checks out or checks in a specified quantity of a storage item.")
	public ResponseEntity<ApiResponse> performTransaction(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		try {
			int itemId = ((Number) payload.get("itemId")).intValue();
			int quantity = ((Number) payload.get("quantity")).intValue();
			String type = (String) payload.get("type");
			String notes = (String) payload.get("notes");
			Integer eventId = payload.get("eventId") != null && !payload.get("eventId").toString().isEmpty()
					? ((Number) payload.get("eventId")).intValue()
					: null;

			if (storageService.processTransaction(itemId, quantity, type, user, eventId, notes)) {
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				return ResponseEntity
						.ok(new ApiResponse(true, "Erfolgreich " + quantity + " Stück " + action + ".", null));
			} else {
				return ResponseEntity.badRequest().body(new ApiResponse(false, "Transaktion fehlgeschlagen.", null));
			}
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{itemId}/report-damage")
	@Operation(summary = "Report damage for an item", description = "Allows a user to submit a damage report for a specific inventory item.")
	public ResponseEntity<ApiResponse> reportDamage(@PathVariable int itemId, @RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String description = payload.get("description");
		if (description == null || description.isBlank()) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Eine Beschreibung ist erforderlich.", null));
		}

		try {
			storageService.createDamageReport(itemId, securityUser.getUser().getId(), description);
			return ResponseEntity.ok(
					new ApiResponse(true, "Schadensmeldung erfolgreich übermittelt. Ein Admin wird sie prüfen.", null));
		} catch (IllegalArgumentException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Meldung konnte nicht gespeichert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}

		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\GlobalExceptionHandler.java
========================================================================

package de.technikteam.config;

import de.technikteam.model.ApiResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

	private static final Logger logger = LogManager.getLogger(GlobalExceptionHandler.class);

	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
		String errors = ex.getBindingResult().getFieldErrors().stream()
				.map(error -> error.getField() + ": " + error.getDefaultMessage()).collect(Collectors.joining(", "));
		ApiResponse apiResponse = new ApiResponse(false, "Validierung fehlgeschlagen: " + errors, null);
		return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
	}

	@ExceptionHandler(AccessDeniedException.class)
	public ResponseEntity<ApiResponse> handleAccessDeniedException(AccessDeniedException ex) {
		ApiResponse apiResponse = new ApiResponse(false,
				"Zugriff verweigert: Sie haben nicht die erforderlichen Berechtigungen für diese Aktion.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
	}

	@ExceptionHandler(Exception.class)
	public ResponseEntity<ApiResponse> handleAllExceptions(Exception ex) {
		logger.error("An unexpected internal server error occurred", ex);
		ApiResponse apiResponse = new ApiResponse(false,
				"Ein unerwarteter interner Serverfehler ist aufgetreten. Bitte kontaktieren Sie den Support.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.INTERNAL_SERVER_ERROR);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\InitialAdminCreator.java
========================================================================

package de.technikteam.config;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.List;

@Component
public class InitialAdminCreator implements CommandLineRunner {

	private static final Logger logger = LogManager.getLogger(InitialAdminCreator.class);

	private final UserDAO userDAO;
	private final UserService userService;
	private final PermissionDAO permissionDAO;

	@Autowired
	public InitialAdminCreator(UserDAO userDAO, UserService userService, PermissionDAO permissionDAO) {
		this.userDAO = userDAO;
		this.userService = userService;
		this.permissionDAO = permissionDAO;
	}

	@Override
	public void run(String... args) throws Exception {
		if (userDAO.getUserByUsername("admin") == null) {
			logger.warn("############################################################");
			logger.warn("##              FIRST TIME SETUP DETECTED                 ##");
			logger.warn("##     Creating default 'admin' user with a random pass   ##");
			logger.warn("############################################################");

			User adminUser = new User();
			adminUser.setUsername("admin");
			adminUser.setRoleId(1); // Assuming 1 is the ADMIN role ID

			String randomPassword = generateRandomPassword(16);

			// Grant both master admin and notification permissions by default
			List<String> permissionIds = new ArrayList<>();
			Integer adminPermissionId = permissionDAO.getPermissionIdByKey(Permissions.ACCESS_ADMIN_PANEL);
			if (adminPermissionId != null) {
				permissionIds.add(String.valueOf(adminPermissionId));
			} else {
				logger.error(
						"FATAL: Could not find the essential ACCESS_ADMIN_PANEL permission. Admin user will lack full rights.");
			}

			Integer notificationPermissionId = permissionDAO.getPermissionIdByKey(Permissions.NOTIFICATION_SEND);
			if (notificationPermissionId != null) {
				permissionIds.add(String.valueOf(notificationPermissionId));
			} else {
				logger.error(
						"FATAL: Could not find the NOTIFICATION_SEND permission. Admin user will not be able to send notifications.");
			}

			userService.createUserWithPermissions(adminUser, randomPassword, permissionIds.toArray(new String[0]),
					"SYSTEM");

			logger.warn("############################################################");
			logger.warn("##                ADMIN USER CREATED                      ##");
			logger.warn("##                                                        ##");
			logger.warn("##    Username: admin                                     ##");
			logger.warn("##    Password: " + randomPassword + "                     ##");
			logger.warn("##                                                        ##");
			logger.warn("##   !!! PLEASE COPY THIS PASSWORD AND STORE IT SAFELY.   ##");
			logger.warn("##             IT WILL NOT BE SHOWN AGAIN.                ##");
			logger.warn("############################################################");
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON) and
 * deserialization (JSON to Java), preventing reflection issues with the Java
 * Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

	private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

	@Override
	public void write(JsonWriter out, LocalDateTime value) throws IOException {
		if (value == null) {
			out.nullValue();
		} else {
			out.value(value.format(FORMATTER));
		}
	}

	@Override
	public LocalDateTime read(JsonReader in) throws IOException {
		if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
			in.nextNull();
			return null;
		}
		String value = in.nextString();
		return LocalDateTime.parse(value, FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\OpenApiConfig.java
========================================================================

package de.technikteam.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

	@Bean
	public OpenAPI customOpenAPI() {
		final String securitySchemeName = "bearerAuth";
		return new OpenAPI()
				.info(new Info().title("TechnikTeam API").version("v1.0.0").description(
						"This is the complete REST API for the TechnikTeam Event & Crew Management System."))
				.addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
				.components(new Components().addSecuritySchemes(securitySchemeName, new SecurityScheme()
						.name(securitySchemeName).type(SecurityScheme.Type.HTTP).scheme("bearer").bearerFormat("JWT")));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\Permissions.java
========================================================================

package de.technikteam.config;

/**
 * A central repository for all permission key constants used throughout the
 * application. This prevents the use of "magic strings" for permission checks,
 * reducing typos and making the code more maintainable and readable.
 */
public final class Permissions {

	private Permissions() {
	}

	// --- GLOBAL ---
	public static final String ACCESS_ADMIN_PANEL = "ACCESS_ADMIN_PANEL";

	// --- USER MANAGEMENT ---
	public static final String USER_CREATE = "USER_CREATE";
	public static final String USER_READ = "USER_READ";
	public static final String USER_UPDATE = "USER_UPDATE";
	public static final String USER_DELETE = "USER_DELETE";
	public static final String USER_PASSWORD_RESET = "USER_PASSWORD_RESET";

	// --- EVENT MANAGEMENT ---
	public static final String EVENT_CREATE = "EVENT_CREATE";
	public static final String EVENT_READ = "EVENT_READ";
	public static final String EVENT_UPDATE = "EVENT_UPDATE";
	public static final String EVENT_DELETE = "EVENT_DELETE";
	public static final String EVENT_MANAGE_ASSIGNMENTS = "EVENT_MANAGE_ASSIGNMENTS";
	public static final String EVENT_MANAGE_TASKS = "EVENT_MANAGE_TASKS";
	public static final String EVENT_DEBRIEFING_VIEW = "EVENT_DEBRIEFING_VIEW";
	public static final String EVENT_DEBRIEFING_MANAGE = "EVENT_DEBRIEFING_MANAGE";

	// --- COURSE & MEETING MANAGEMENT ---
	public static final String COURSE_CREATE = "COURSE_CREATE";
	public static final String COURSE_READ = "COURSE_READ";
	public static final String COURSE_UPDATE = "COURSE_UPDATE";
	public static final String COURSE_DELETE = "COURSE_DELETE";

	// --- STORAGE & INVENTORY ---
	public static final String STORAGE_CREATE = "STORAGE_CREATE";
	public static final String STORAGE_READ = "STORAGE_READ";
	public static final String STORAGE_UPDATE = "STORAGE_UPDATE";
	public static final String STORAGE_DELETE = "STORAGE_DELETE";
	public static final String DAMAGE_REPORT_MANAGE = "DAMAGE_REPORT_MANAGE";

	// --- KIT MANAGEMENT ---
	public static final String KIT_CREATE = "KIT_CREATE";
	public static final String KIT_READ = "KIT_READ";
	public static final String KIT_UPDATE = "KIT_UPDATE";
	public static final String KIT_DELETE = "KIT_DELETE";

	// --- QUALIFICATIONS ---
	public static final String QUALIFICATION_READ = "QUALIFICATION_READ";
	public static final String QUALIFICATION_UPDATE = "QUALIFICATION_UPDATE";

	// --- FILE MANAGEMENT ---
	public static final String FILE_CREATE = "FILE_CREATE";
	public static final String FILE_READ = "FILE_READ";
	public static final String FILE_UPDATE = "FILE_UPDATE";
	public static final String FILE_DELETE = "FILE_DELETE";
	public static final String FILE_MANAGE = "FILE_MANAGE";

	// --- SYSTEM & REPORTING ---
	public static final String LOG_READ = "LOG_READ";
	public static final String REPORT_READ = "REPORT_READ";
	public static final String SYSTEM_READ = "SYSTEM_READ";

	// --- ACHIEVEMENTS ---
	public static final String ACHIEVEMENT_CREATE = "ACHIEVEMENT_CREATE";
	public static final String ACHIEVEMENT_UPDATE = "ACHIEVEMENT_UPDATE";
	public static final String ACHIEVEMENT_DELETE = "ACHIEVEMENT_DELETE";
	public static final String ACHIEVEMENT_VIEW = "ACHIEVEMENT_VIEW";

	// --- NOTIFICATIONS ---
	public static final String NOTIFICATION_SEND = "NOTIFICATION_SEND";

	// --- NAVIGATION-SPECIFIC ---
	public static final String ADMIN_DASHBOARD_ACCESS = "ADMIN_DASHBOARD_ACCESS";
}
========================================================================
FILE: src\main\java\de\technikteam\config\SanitizerConfig.java
========================================================================

package de.technikteam.config;

import org.owasp.html.HtmlPolicyBuilder;
import org.owasp.html.PolicyFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SanitizerConfig {

	/**
	 * A policy factory that allows common text formatting and block-level elements.
	 * Suitable for rich text content like event descriptions. Allows: <b>, <i>,
	 * <u>, <s>, <sub>, <sup>,
	 * <p>
	 * , <blockquote>,
	 * <ul>
	 * ,
	 * <ol>
	 * ,
	 * <li>, <br>
	 * ,
	 * <h1>-
	 * <h6>
	 */
	@Bean("richTextPolicy")
	public PolicyFactory richTextPolicy() {
		return new HtmlPolicyBuilder().allowCommonBlockElements() // p, div, h1-h6, etc.
				.allowCommonInlineFormattingElements() // b, i, u, etc.
				.allowElements("br", "ul", "ol", "li", "blockquote", "s", "sub", "sup").toFactory();
	}

	/**
	 * A stricter policy that only allows inline formatting, no block elements.
	 * Suitable for single-line content or chat messages where block elements are
	 * undesirable. Allows: <b>, <i>, <u>, <s>, <sub>, <sup>
	 */
	@Bean("inlineFormattingPolicy")
	public PolicyFactory inlineFormattingPolicy() {
		return new HtmlPolicyBuilder().allowCommonInlineFormattingElements().allowElements("s", "sub", "sup")
				.toFactory();
	}

	/**
	 * A policy that strips all HTML, leaving only plain text. Useful for fields
	 * that should not contain any formatting.
	 */
	@Bean("plainTextPolicy")
	public PolicyFactory plainTextPolicy() {
		return new HtmlPolicyBuilder().toFactory(); // No elements allowed
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\WebMvcConfig.java
========================================================================

package de.technikteam.config;

import de.technikteam.security.RateLimitingInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
	private final RateLimitingInterceptor rateLimitingInterceptor;

	@Autowired
	public WebMvcConfig(RateLimitingInterceptor rateLimitingInterceptor) {
		this.rateLimitingInterceptor = rateLimitingInterceptor;
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		// Rate limiting is disabled as per the request to remove all verification.
		// registry.addInterceptor(rateLimitingInterceptor).addPathPatterns("/api/v1/auth/login")
		// .addPathPatterns("/api/v1/users/**").addPathPatterns("/api/v1/events/**")
		// .addPathPatterns("/api/v1/storage/**").addPathPatterns("/api/v1/kits/**")
		// .addPathPatterns("/api/v1/courses/**").addPathPatterns("/api/v1/meetings/**")
		// .addPathPatterns("/api/v1/feedback/**").addPathPatterns("/api/v1/public/feedback/**")
		// .addPathPatterns("/api/v1/public/profile/**");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Achievement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AchievementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Achievement> achievementRowMapper = (rs, rowNum) -> {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	};

	public List<Achievement> getAllAchievements() {
		String sql = "SELECT * FROM achievements ORDER BY name";
		try {
			return jdbcTemplate.query(sql, achievementRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all achievements", e);
			return List.of();
		}
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, achievementRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching achievement by ID {}", id, e);
			return null;
		}
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, achievement.getAchievementKey(), achievement.getName(),
					achievement.getDescription(), achievement.getIconClass()) > 0;
		} catch (Exception e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, achievement.getName(), achievement.getDescription(),
					achievement.getIconClass(), achievement.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try {
			// First, delete dependencies in user_achievements
			jdbcTemplate.update("DELETE FROM user_achievements WHERE achievement_id = ?", id);
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		String sql = "SELECT a.*, ua.earned_at FROM achievements a JOIN user_achievements ua ON a.id = ua.achievement_id WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Achievement ach = achievementRowMapper.mapRow(rs, rowNum);
				ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
				return ach;
			}, userId);
		} catch (Exception e) {
			logger.error("Error fetching achievements for user {}", userId, e);
			return List.of();
		}
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			return false; // Already has it, not an error
		}
		String sql = "INSERT INTO user_achievements (user_id, achievement_id) SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try {
			return jdbcTemplate.update(sql, userId, achievementKey) > 0;
		} catch (Exception e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
			return false;
		}
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT COUNT(*) FROM user_achievements ua JOIN achievements a ON ua.achievement_id = a.id WHERE ua.user_id = ? AND a.achievement_key = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId, achievementKey);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AdminLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		try {
			jdbcTemplate.update(sql, log.getAdminUsername(), log.getActionType(), log.getDetails());
		} catch (Exception e) {
			logger.error("Failed to create admin log for user '{}'.", log.getAdminUsername(), e);
		}
	}

	public List<AdminLog> getAllLogs() {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			});
		} catch (Exception e) {
			logger.error("Failed to fetch admin logs from the database.", e);
			return List.of();
		}
	}

	public List<AdminLog> getRecentLogs(int limit) {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			}, limit);
		} catch (Exception e) {
			logger.error("Failed to fetch recent admin logs from the database.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AttachmentDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Attachment> attachmentRowMapper = (rs, rowNum) -> {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	};

	public boolean addAttachment(Attachment attachment) {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, attachment.getParentType(), attachment.getParentId(),
					attachment.getFilename(), attachment.getFilepath(), attachment.getRequiredRole()) > 0;
		} catch (Exception e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try {
			return jdbcTemplate.query(sql, attachmentRowMapper, parentType, parentId);
		} catch (Exception e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
			return List.of();
		}
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, attachmentRowMapper, attachmentId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
			return null;
		}
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, attachmentId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChangelogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.model.Changelog;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.lang.reflect.Type;
import java.sql.Date;
import java.util.Collections;
import java.util.List;
import java.util.Optional;

@Repository
public class ChangelogDAO {

	private final JdbcTemplate jdbcTemplate;
	private final Gson gson = new Gson();
	private final Type listType = new TypeToken<List<Integer>>() {
	}.getType();

	@Autowired
	public ChangelogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Changelog> rowMapper = (rs, rowNum) -> {
		Changelog cl = new Changelog();
		cl.setId(rs.getInt("id"));
		cl.setVersion(rs.getString("version"));
		cl.setReleaseDate(rs.getDate("release_date").toLocalDate());
		cl.setTitle(rs.getString("title"));
		cl.setNotes(rs.getString("notes"));
		cl.setPublished(rs.getBoolean("is_published"));
		String seenByJson = rs.getString("seen_by_users");
		cl.setSeenByUserIds(gson.fromJson(seenByJson, listType));
		return cl;
	};

	public List<Changelog> findAll() {
		String sql = "SELECT * FROM changelogs ORDER BY release_date DESC, version DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public List<Changelog> findAllPublished() {
		String sql = "SELECT * FROM changelogs WHERE is_published = TRUE ORDER BY release_date DESC, version DESC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public Optional<Changelog> findLatestUnseen(int userId) {
		// FIX: Correctly use JSON_CONTAINS by passing the value to check as a string.
		String sql = "SELECT * FROM changelogs WHERE is_published = TRUE AND NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$') ORDER BY release_date DESC, version DESC LIMIT 1";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, rowMapper, String.valueOf(userId)));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public boolean markAsSeen(int changelogId, int userId) {
		// FIX: Correctly use JSON_CONTAINS by passing the value to check as a string.
		String sql = "UPDATE changelogs SET seen_by_users = JSON_ARRAY_APPEND(seen_by_users, '$', ?) WHERE id = ? AND NOT JSON_CONTAINS(seen_by_users, CAST(? AS CHAR), '$')";
		return jdbcTemplate.update(sql, userId, changelogId, String.valueOf(userId)) > 0;
	}

	public boolean create(Changelog changelog) {
		String sql = "INSERT INTO changelogs (version, release_date, title, notes, is_published) VALUES (?, ?, ?, ?, ?)";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes(), changelog.isPublished()) > 0;
	}

	public boolean update(Changelog changelog) {
		String sql = "UPDATE changelogs SET version = ?, release_date = ?, title = ?, notes = ?, is_published = ? WHERE id = ?";
		return jdbcTemplate.update(sql, changelog.getVersion(), Date.valueOf(changelog.getReleaseDate()),
				changelog.getTitle(), changelog.getNotes(), changelog.isPublished(), changelog.getId()) > 0;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM changelogs WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChatMessage;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class ChatDAO {

	private final JdbcTemplate jdbcTemplate;
	private final NamedParameterJdbcTemplate namedParameterJdbcTemplate;

	@Autowired
	public ChatDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate);
	}

	private final RowMapper<ChatMessage> chatMessageRowMapper = (rs, rowNum) -> {
		ChatMessage m = new ChatMessage();
		m.setId(rs.getLong("id"));
		m.setConversationId(rs.getInt("conversation_id"));
		m.setSenderId(rs.getInt("sender_id"));
		m.setSenderUsername(rs.getString("sender_username"));
		m.setMessageText(rs.getString("message_text"));
		m.setStatus(rs.getString("status"));
		m.setChatColor(rs.getString("chat_color"));
		m.setEdited(rs.getBoolean("edited"));
		if (rs.getTimestamp("edited_at") != null) {
			m.setEditedAt(rs.getTimestamp("edited_at").toLocalDateTime());
		}
		m.setDeleted(rs.getBoolean("is_deleted"));
		if (rs.getTimestamp("deleted_at") != null) {
			m.setDeletedAt(rs.getTimestamp("deleted_at").toLocalDateTime());
		}
		m.setDeletedByUserId(rs.getObject("deleted_by_user_id", Integer.class));
		m.setDeletedByUsername(rs.getString("deleted_by_username"));
		m.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
		return m;
	};

	/**
	 * Soft-delete a message. This method executes in its own transaction so that
	 * the deletion is committed immediately and not rolled back by outer
	 * transactions.
	 *
	 * For non-admin deletions, the method first verifies that the deleter is the
	 * original sender.
	 *
	 * @param messageId      id of the message to delete
	 * @param deletersUserId id of the user requesting the delete
	 * @param isAdmin        whether the deleter has admin privileges for this
	 *                       conversation
	 * @return true if a row was updated (message marked deleted), false otherwise
	 */
	@Transactional(propagation = Propagation.REQUIRES_NEW)
	public boolean deleteMessage(long messageId, int deletersUserId, boolean isAdmin) {
		if (!isAdmin) {
			Integer senderId = null;
			try {
				senderId = jdbcTemplate.queryForObject("SELECT sender_id FROM chat_messages WHERE id = ?",
						Integer.class, messageId);
			} catch (Exception e) {
				return false;
			}
			if (senderId == null || senderId != deletersUserId) {
				return false;
			}
		}

		String sql = "UPDATE chat_messages SET is_deleted = TRUE, message_text = '', deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ?";

		int updated = jdbcTemplate.update(sql, deletersUserId, messageId);
		return updated > 0;
	}

	public List<ChatMessage> getMessagesForConversation(int conversationId, int limit, int offset) {
		String sql = """
				    SELECT cm.*, u.username as sender_username, u.chat_color, u_del.username as deleted_by_username
				    FROM chat_messages cm
				    JOIN users u ON cm.sender_id = u.id
				    LEFT JOIN users u_del ON cm.deleted_by_user_id = u_del.id
				    WHERE cm.conversation_id = ?
				    ORDER BY cm.sent_at DESC
				    LIMIT ? OFFSET ?
				""";
		return jdbcTemplate.query(sql, chatMessageRowMapper, conversationId, limit, offset);
	}

	public ChatMessage getMessageById(long messageId) {
		try {
			String sql = """
					    SELECT cm.*, u.username as sender_username, u.chat_color, u_del.username as deleted_by_username
					    FROM chat_messages cm
					    JOIN users u ON cm.sender_id = u.id
					    LEFT JOIN users u_del ON cm.deleted_by_user_id = u_del.id
					    WHERE cm.id = ?
					""";
			return jdbcTemplate.queryForObject(sql, chatMessageRowMapper, messageId);
		} catch (Exception e) {
			return null;
		}
	}

	public ChatConversation getConversationById(int conversationId) {
		String sql = "SELECT * FROM chat_conversations WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				ChatConversation conv = new ChatConversation();
				conv.setId(rs.getInt("id"));
				conv.setName(rs.getString("name"));
				conv.setGroupChat(rs.getBoolean("is_group_chat"));
				conv.setCreatorId(rs.getInt("creator_id"));
				conv.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				conv.setParticipants(getParticipantsForConversation(conversationId));
				return conv;
			}, conversationId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		}
	}

	public List<ChatConversation> getConversationsForUser(int userId) {
		String sql = """
				    SELECT
				        c.id, c.name, c.is_group_chat,
				        other_p.user_id as other_participant_id,
				        other_u.username as other_participant_username,
				        (SELECT cm.message_text FROM chat_messages cm WHERE cm.conversation_id = c.id AND cm.is_deleted = FALSE ORDER BY cm.sent_at DESC LIMIT 1) as last_message,
				        (SELECT cm.sent_at FROM chat_messages cm WHERE cm.conversation_id = c.id ORDER BY cm.sent_at DESC LIMIT 1) as last_message_timestamp
				    FROM chat_conversations c
				    JOIN chat_participants p ON c.id = p.conversation_id
				    LEFT JOIN chat_participants other_p ON c.id = other_p.conversation_id AND other_p.user_id != ? AND c.is_group_chat = false
				    LEFT JOIN users other_u ON other_p.user_id = other_u.id
				    WHERE p.user_id = ?
				    ORDER BY last_message_timestamp DESC;
				""";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			ChatConversation conv = new ChatConversation();
			conv.setId(rs.getInt("id"));
			conv.setName(rs.getString("name"));
			conv.setGroupChat(rs.getBoolean("is_group_chat"));
			conv.setOtherParticipantId(rs.getInt("other_participant_id"));
			conv.setOtherParticipantUsername(rs.getString("other_participant_username"));
			conv.setLastMessage(rs.getString("last_message"));
			if (rs.getTimestamp("last_message_timestamp") != null) {
				conv.setLastMessageTimestamp(rs.getTimestamp("last_message_timestamp").toLocalDateTime());
			}
			return conv;
		}, userId, userId);
	}

	public List<User> getParticipantsForConversation(int conversationId) {
		String sql = "SELECT u.id, u.username FROM users u JOIN chat_participants cp ON u.id = cp.user_id WHERE cp.conversation_id = ?";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			User user = new User();
			user.setId(rs.getInt("id"));
			user.setUsername(rs.getString("username"));
			return user;
		}, conversationId);
	}

	@Transactional
	public boolean updateMessagesStatusToRead(List<Long> messageIds, int conversationId, int readerId) {
		if (messageIds == null || messageIds.isEmpty()) {
			return false;
		}
		// FIX: Use NamedParameterJdbcTemplate to avoid SQL injection
		MapSqlParameterSource parameters = new MapSqlParameterSource();
		parameters.addValue("ids", messageIds);
		parameters.addValue("conversationId", conversationId);
		parameters.addValue("readerId", readerId);

		String sql = "UPDATE chat_messages SET status = 'READ' WHERE id IN (:ids) AND conversation_id = :conversationId AND sender_id != :readerId AND status != 'READ'";

		return namedParameterJdbcTemplate.update(sql, parameters) > 0;
	}

	public boolean updateMessage(long messageId, int userId, String newText) {
		String sql = "UPDATE chat_messages SET message_text = ?, edited = TRUE, edited_at = NOW() WHERE id = ? AND sender_id = ? AND is_deleted = FALSE AND sent_at >= NOW() - INTERVAL 24 HOUR";
		return jdbcTemplate.update(sql, newText, messageId, userId) > 0;
	}

	@Transactional
	public ChatMessage createMessage(ChatMessage message) {
		String sql = "INSERT INTO chat_messages (conversation_id, sender_id, message_text, status) VALUES (?, ?, ?, 'SENT')";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, message.getConversationId());
			ps.setInt(2, message.getSenderId());
			ps.setString(3, message.getMessageText());
			return ps;
		}, keyHolder);
		message.setId(Objects.requireNonNull(keyHolder.getKey()).longValue());
		message.setStatus("SENT");
		return message;
	}

	@Transactional
	public int findOrCreateConversation(int userId1, int userId2) {
		String findSql = """
				    SELECT cp1.conversation_id FROM chat_participants cp1
				    JOIN chat_participants cp2 ON cp1.conversation_id = cp2.conversation_id
				    JOIN chat_conversations c ON cp1.conversation_id = c.id
				    WHERE cp1.user_id = ? AND cp2.user_id = ? AND c.is_group_chat = false;
				""";
		try {
			return jdbcTemplate.queryForObject(findSql, Integer.class, userId1, userId2);
		} catch (EmptyResultDataAccessException e) {
			String createConvSql = "INSERT INTO chat_conversations (is_group_chat, creator_id) VALUES (false, ?)";
			GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(createConvSql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, userId1);
				return ps;
			}, keyHolder);
			int newConversationId = Objects.requireNonNull(keyHolder.getKey()).intValue();

			String addParticipantsSql = "INSERT INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
			jdbcTemplate.update(addParticipantsSql, newConversationId, userId1);
			jdbcTemplate.update(addParticipantsSql, newConversationId, userId2);

			return newConversationId;
		}
	}

	@Transactional
	public int createGroupConversation(String name, int creatorId, List<Integer> participantIds) {
		String createConvSql = "INSERT INTO chat_conversations (is_group_chat, name, creator_id) VALUES (true, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(createConvSql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			ps.setInt(2, creatorId);
			return ps;
		}, keyHolder);
		int newConversationId = Objects.requireNonNull(keyHolder.getKey()).intValue();

		String addParticipantsSql = "INSERT INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
		// Add the creator as well
		if (!participantIds.contains(creatorId)) {
			participantIds.add(creatorId);
		}
		for (Integer participantId : participantIds) {
			jdbcTemplate.update(addParticipantsSql, newConversationId, participantId);
		}

		return newConversationId;
	}

	public boolean isUserInConversation(int conversationId, int userId) {
		String sql = "SELECT COUNT(*) FROM chat_participants WHERE conversation_id = ? AND user_id = ?";
		Integer count = jdbcTemplate.queryForObject(sql, Integer.class, conversationId, userId);
		return count != null && count > 0;
	}

	@Transactional
	public void addParticipantsToGroup(int conversationId, List<Integer> userIds) {
		String sql = "INSERT IGNORE INTO chat_participants (conversation_id, user_id) VALUES (?, ?)";
		jdbcTemplate.batchUpdate(sql, userIds, 100, (ps, userId) -> {
			ps.setInt(1, conversationId);
			ps.setInt(2, userId);
		});
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChecklistDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChecklistItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ChecklistDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ChecklistDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ChecklistItem> checklistItemRowMapper = (rs, rowNum) -> {
		ChecklistItem item = new ChecklistItem();
		item.setId(rs.getInt("id"));
		item.setEventId(rs.getInt("event_id"));
		item.setItemId(rs.getInt("item_id"));
		item.setItemName(rs.getString("item_name"));
		item.setQuantity(rs.getInt("quantity"));
		item.setStatus(rs.getString("status"));
		item.setLastUpdatedByUserId(rs.getObject("last_updated_by_user_id", Integer.class));
		item.setLastUpdatedByUsername(rs.getString("last_updated_by_username"));
		item.setLastUpdatedAt(rs.getTimestamp("last_updated_at").toLocalDateTime());
		return item;
	};

	public List<ChecklistItem> getChecklistForEvent(int eventId) {
		String sql = "SELECT ci.*, si.name as item_name, u.username as last_updated_by_username "
				+ "FROM event_inventory_checklist ci " + "JOIN storage_items si ON ci.item_id = si.id "
				+ "LEFT JOIN users u ON ci.last_updated_by_user_id = u.id " + "WHERE ci.event_id = ? ORDER BY si.name";
		return jdbcTemplate.query(sql, checklistItemRowMapper, eventId);
	}

	public int generateChecklistFromReservations(int eventId) {
		String sql = "INSERT INTO event_inventory_checklist (event_id, item_id, quantity, status) "
				+ "SELECT event_id, item_id, reserved_quantity, 'PENDING' FROM event_storage_reservations "
				+ "WHERE event_id = ? " + "ON DUPLICATE KEY UPDATE quantity = VALUES(quantity)";
		return jdbcTemplate.update(sql, eventId);
	}

	public boolean updateChecklistItemStatus(int checklistItemId, String status, int userId) {
		String sql = "UPDATE event_inventory_checklist SET status = ?, last_updated_by_user_id = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, userId, checklistItemId) > 0;
	}

	public ChecklistItem getChecklistItemById(int checklistItemId) {
		String sql = "SELECT ci.*, si.name as item_name, u.username as last_updated_by_username "
				+ "FROM event_inventory_checklist ci " + "JOIN storage_items si ON ci.item_id = si.id "
				+ "LEFT JOIN users u ON ci.last_updated_by_user_id = u.id " + "WHERE ci.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, checklistItemRowMapper, checklistItemId);
		} catch (Exception e) {
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ChecklistTemplateDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ChecklistTemplate;
import de.technikteam.model.ChecklistTemplateItem;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class ChecklistTemplateDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ChecklistTemplateDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public ChecklistTemplate save(ChecklistTemplate template) {
		if (template.getId() > 0) {
			updateTemplate(template);
		} else {
			int newId = createTemplate(template);
			template.setId(newId);
		}

		// Sync items
		jdbcTemplate.update("DELETE FROM preflight_checklist_items WHERE template_id = ?", template.getId());
		if (template.getItems() != null && !template.getItems().isEmpty()) {
			String itemSql = "INSERT INTO preflight_checklist_items (template_id, item_text, display_order) VALUES (?, ?, ?)";
			jdbcTemplate.batchUpdate(itemSql, template.getItems(), 100, (ps, item) -> {
				ps.setInt(1, template.getId());
				ps.setString(2, item.getItemText());
				ps.setInt(3, template.getItems().indexOf(item));
			});
		}
		return template;
	}

	private int createTemplate(ChecklistTemplate template) {
		String sql = "INSERT INTO preflight_checklist_templates (name, description) VALUES (?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, template.getName());
			ps.setString(2, template.getDescription());
			return ps;
		}, keyHolder);
		return Objects.requireNonNull(keyHolder.getKey()).intValue();
	}

	private void updateTemplate(ChecklistTemplate template) {
		String sql = "UPDATE preflight_checklist_templates SET name = ?, description = ? WHERE id = ?";
		jdbcTemplate.update(sql, template.getName(), template.getDescription(), template.getId());
	}

	public List<ChecklistTemplate> findAll() {
		String sql = "SELECT t.id as template_id, t.name, t.description, i.id as item_id, i.item_text, i.display_order "
				+ "FROM preflight_checklist_templates t "
				+ "LEFT JOIN preflight_checklist_items i ON t.id = i.template_id " + "ORDER BY t.name, i.display_order";

		Map<Integer, ChecklistTemplate> templateMap = new LinkedHashMap<>();
		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int templateId = rs.getInt("template_id");
			ChecklistTemplate template = templateMap.computeIfAbsent(templateId, id -> {
				try {
					ChecklistTemplate newTemplate = new ChecklistTemplate();
					newTemplate.setId(id);
					newTemplate.setName(rs.getString("name"));
					newTemplate.setDescription(rs.getString("description"));
					newTemplate.setItems(new ArrayList<>());
					return newTemplate;
				} catch (SQLException e) {
					throw new RuntimeException("Failed to map template", e);
				}
			});

			if (rs.getObject("item_id") != null) {
				ChecklistTemplateItem item = new ChecklistTemplateItem();
				item.setId(rs.getInt("item_id"));
				item.setTemplateId(templateId);
				item.setItemText(rs.getString("item_text"));
				item.setDisplayOrder(rs.getInt("display_order"));
				template.getItems().add(item);
			}
		});
		return new ArrayList<>(templateMap.values());
	}

	public boolean delete(int id) {
		return jdbcTemplate.update("DELETE FROM preflight_checklist_templates WHERE id = ?", id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Course;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public CourseDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Course> courseRowMapper = (rs, rowNum) -> {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	};

	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription()) > 0;
		} catch (Exception e) {
			logger.error("Error creating course: {}", course.getName(), e);
			return false;
		}
	}

	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, courseRowMapper, courseId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching course by ID: {}", courseId, e);
			return null;
		}
	}

	public List<Course> getAllCourses() {
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		try {
			return jdbcTemplate.query(sql, courseRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all courses.", e);
			return List.of();
		}
	}

	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription(),
					course.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating course: {}", course.getName(), e);
			return false;
		}
	}

	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		try {
			// Manually delete related data due to foreign key constraints
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE required_course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM user_qualifications WHERE course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM meetings WHERE course_id = ?", courseId);

			return jdbcTemplate.update(sql, courseId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\DamageReportDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.DamageReport;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class DamageReportDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public DamageReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<DamageReport> reportRowMapper = (rs, rowNum) -> {
		DamageReport report = new DamageReport();
		report.setId(rs.getInt("id"));
		report.setItemId(rs.getInt("item_id"));
		report.setReporterUserId(rs.getInt("reporter_user_id"));
		report.setReportDescription(rs.getString("report_description"));
		report.setReportedAt(rs.getTimestamp("reported_at").toLocalDateTime());
		report.setStatus(rs.getString("status"));
		report.setReviewedByAdminId(rs.getObject("reviewed_by_admin_id", Integer.class));
		if (rs.getTimestamp("reviewed_at") != null) {
			report.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		report.setAdminNotes(rs.getString("admin_notes"));
		// Joined fields
		report.setItemName(rs.getString("item_name"));
		report.setReporterUsername(rs.getString("reporter_username"));
		return report;
	};

	public DamageReport createReport(int itemId, int reporterUserId, String description) {
		String sql = "INSERT INTO damage_reports (item_id, reporter_user_id, report_description) VALUES (?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, itemId);
			ps.setInt(2, reporterUserId);
			ps.setString(3, description);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		return getReportById(newId).orElse(null);
	}

	public List<DamageReport> getPendingReports() {
		String sql = "SELECT dr.*, si.name as item_name, u.username as reporter_username FROM damage_reports dr "
				+ "JOIN storage_items si ON dr.item_id = si.id " + "JOIN users u ON dr.reporter_user_id = u.id "
				+ "WHERE dr.status = 'PENDING' ORDER BY dr.reported_at ASC";
		return jdbcTemplate.query(sql, reportRowMapper);
	}

	public Optional<DamageReport> getReportById(int id) {
		String sql = "SELECT dr.*, si.name as item_name, u.username as reporter_username FROM damage_reports dr "
				+ "JOIN storage_items si ON dr.item_id = si.id " + "JOIN users u ON dr.reporter_user_id = u.id "
				+ "WHERE dr.id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, reportRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public boolean updateStatus(int reportId, String status, int adminId, String adminNotes) {
		String sql = "UPDATE damage_reports SET status = ?, reviewed_by_admin_id = ?, reviewed_at = ?, admin_notes = ? WHERE id = ?";
		return jdbcTemplate.update(sql, ps -> {
			ps.setString(1, status);
			ps.setInt(2, adminId);
			ps.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now()));
			if (adminNotes != null) {
				ps.setString(4, adminNotes);
			} else {
				ps.setNull(4, Types.VARCHAR);
			}
			ps.setInt(5, reportId);
		}) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventChatDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventChatMessage> chatMessageRowMapper = (rs, rowNum) -> {
		EventChatMessage message = new EventChatMessage();
		message.setId(rs.getInt("id"));
		message.setEventId(rs.getInt("event_id"));
		message.setUserId(rs.getInt("user_id"));
		message.setUsername(rs.getString("username"));
		message.setMessageText(rs.getString("message_text"));
		message.setEdited(rs.getBoolean("edited"));
		if (rs.getTimestamp("edited_at") != null) {
			message.setEditedAt(rs.getTimestamp("edited_at").toLocalDateTime());
		}
		message.setDeleted(rs.getBoolean("is_deleted"));
		message.setDeletedByUserId(rs.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(rs.getString("deleted_by_username"));
		message.setChatColor(rs.getString("chat_color"));
		if (rs.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(rs.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
		return message;
	};

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, message.getEventId());
				ps.setInt(2, message.getUserId());
				ps.setString(3, message.getUsername());
				ps.setString(4, message.getMessageText());
				return ps;
			}, keyHolder);

			int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
			return getMessageById(newId);
		} catch (Exception e) {
			logger.error("Error posting chat message for event {}", message.getEventId(), e);
			return null;
		}
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try {
			return jdbcTemplate.query(sql, chatMessageRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching chat messages for event {}", eventId, e);
			return List.of();
		}
	}

	public EventChatMessage getMessageById(int messageId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, chatMessageRowMapper, messageId);
		} catch (Exception e) {
			logger.error("Error fetching message by ID {}", messageId, e);
			return null;
		}
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE, edited_at = NOW() WHERE id = ? AND user_id = ? AND is_deleted = FALSE AND sent_at >= NOW() - INTERVAL 24 HOUR";
		try {
			return jdbcTemplate.update(sql, newText, messageId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating message ID {}", messageId, e);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql = isAdmin
				? "UPDATE event_chat_messages SET is_deleted = TRUE, message_text = '', deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ?"
				: "UPDATE event_chat_messages SET is_deleted = TRUE, message_text = '', deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ? AND user_id = ?";
		try {
			if (isAdmin) {
				return jdbcTemplate.update(sql, deletersUserId, messageId) > 0;
			} else {
				return jdbcTemplate.update(sql, deletersUserId, messageId, deletersUserId) > 0;
			}
		} catch (Exception e) {
			logger.error("Error soft-deleting message ID {}:", messageId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventCustomFieldDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields) {
		try {
			jdbcTemplate.update("DELETE FROM event_custom_fields WHERE event_id = ?", eventId);

			if (fields != null && !fields.isEmpty()) {
				String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
				jdbcTemplate.batchUpdate(insertSql, fields, 100, (ps, field) -> {
					ps.setInt(1, eventId);
					ps.setString(2, field.getFieldName());
					ps.setString(3, field.getFieldType());
					ps.setBoolean(4, field.isRequired());
					ps.setString(5, field.getFieldOptions());
				});
			}
		} catch (Exception e) {
			logger.error("Error in transaction for saving custom fields for event {}", eventId, e);
			// Transactional annotation will handle rollback
			throw new RuntimeException(e);
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				EventCustomField field = new EventCustomField();
				field.setId(rs.getInt("id"));
				field.setEventId(rs.getInt("event_id"));
				field.setFieldName(rs.getString("field_name"));
				field.setFieldType(rs.getString("field_type"));
				field.setRequired(rs.getBoolean("is_required"));
				field.setFieldOptions(rs.getString("field_options"));
				return field;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
			return List.of();
		}
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try {
			jdbcTemplate.update(sql, response.getFieldId(), response.getUserId(), response.getResponseValue());
		} catch (Exception e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Event;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Event> eventRowMapper = (rs, rowNum) -> {
		Event event = new Event();
		event.setId(rs.getInt("id"));
		event.setName(rs.getString("name"));
		event.setDescription(rs.getString("description"));
		event.setLocation(rs.getString("location"));
		event.setStatus(rs.getString("status"));
		event.setEventDateTime(rs.getTimestamp("event_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			event.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(rs, "leader_user_id")) {
			event.setLeaderUserId(rs.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(rs, "leader_username")) {
			event.setLeaderUsername(rs.getString("leader_username"));
		}
		return event;
	};

	private final RowMapper<User> simpleUserRowMapper = (rs, rowNum) -> new User(rs.getInt("id"),
			rs.getString("username"), rs.getString("role"));

	public List<Event> getUpcomingEventsForUser(User user) {
		String sql = "SELECT e.*, u_leader.username AS leader_username, " + "COALESCE("
				+ "    (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), "
				+ "    (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), "
				+ "    'OFFEN'" + ") AS user_attendance_status, " + "(" + "    SELECT COUNT(*) = 0 "
				+ "    FROM event_skill_requirements esr " + "    WHERE esr.event_id = e.id " + "    AND NOT EXISTS ("
				+ "        SELECT 1 FROM user_qualifications uq "
				+ "        WHERE uq.user_id = ? AND uq.course_id = esr.required_course_id AND uq.status = 'BESTANDEN'"
				+ "    )" + ") AS is_user_qualified " + "FROM events e "
				+ "LEFT JOIN users u_leader ON e.leader_user_id = u_leader.id "
				+ "WHERE e.status IN ('GEPLANT', 'LAUFEND') AND e.event_datetime >= NOW() - INTERVAL 1 DAY "
				+ "ORDER BY e.event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_attendance_status"));
				event.setUserQualified(rs.getBoolean("is_user_qualified"));
				return event;
			}, user.getId(), user.getId(), user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming events for user {}: {}", user.getUsername(), e.getMessage());
			return List.of();
		}
	}

	public List<Event> getEventHistoryForUser(int userId) {
		String sql = "SELECT e.*, COALESCE( (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), 'OFFEN' ) AS user_status FROM events e WHERE EXISTS ( SELECT 1 FROM event_attendance WHERE event_id = e.id AND user_id = ? UNION SELECT 1 FROM event_assignments WHERE event_id = e.id AND user_id = ? ) ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_status"));
				return event;
			}, userId, userId, userId, userId);
		} catch (Exception e) {
			logger.error("Error fetching event history for user {}", userId, e);
			return List.of();
		}
	}

	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id WHERE e.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, eventRowMapper, eventId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching event by ID: {}", eventId, e);
			return null;
		}
	}

	public List<Event> getAllEvents() {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all events.", e);
			return List.of();
		}
	}

	public List<Event> getActiveEvents() {
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active events.", e);
			return List.of();
		}
	}

	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, 'GEPLANT', ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, event.getName());
				ps.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
				if (event.getEndDateTime() != null)
					ps.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
				else
					ps.setNull(3, Types.TIMESTAMP);
				ps.setString(4, event.getDescription());
				ps.setString(5, event.getLocation());
				if (event.getLeaderUserId() > 0)
					ps.setInt(6, event.getLeaderUserId());
				else
					ps.setNull(6, Types.INTEGER);
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating event {}", event.getName(), e);
			return 0;
		}
	}

	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, event.getName(), Timestamp.valueOf(event.getEventDateTime()),
					event.getEndDateTime() != null ? Timestamp.valueOf(event.getEndDateTime()) : null,
					event.getDescription(), event.getLocation(), event.getStatus(),
					event.getLeaderUserId() > 0 ? event.getLeaderUserId() : null, event.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating event {}", event.getName(), e);
			return false;
		}
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, eventId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting event with ID: {}", eventId, e);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-up for user {} and event {}", userId, eventId, e);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-off for user {} and event {}", userId, eventId, e);
		}
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		try {
			jdbcTemplate.update("DELETE FROM event_assignments WHERE event_id = ?", eventId);
			if (userIds != null && userIds.length > 0) {
				String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
				jdbcTemplate.batchUpdate(insertSql, List.of(userIds), 100, (ps, userId) -> {
					ps.setInt(1, eventId);
					ps.setInt(2, Integer.parseInt(userId));
				});
			}
		} catch (Exception e) {
			logger.error("Error during user assignment for event ID: {}.", eventId, e);
		}
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				SkillRequirement req = new SkillRequirement();
				req.setRequiredCourseId(rs.getInt("required_course_id"));
				req.setCourseName(rs.getString("course_name"));
				req.setRequiredPersons(rs.getInt("required_persons"));
				return req;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching skill requirements for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		try {
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE event_id = ?", eventId);
			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				String sql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(requiredCourseIds), 100, (ps, courseId) -> {
					// This is a bit clumsy but necessary to align arrays
					int index = List.of(requiredCourseIds).indexOf(courseId);
					if (!courseId.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(courseId));
						ps.setInt(3, Integer.parseInt(requiredPersons[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving skill requirements for event ID: {}.", eventId, e);
		}
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		try {
			jdbcTemplate.update("DELETE FROM event_storage_reservations WHERE event_id = ?", eventId);
			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				String sql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(itemIds), 100, (ps, itemId) -> {
					int index = List.of(itemIds).indexOf(itemId);
					if (!itemId.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(itemId));
						ps.setInt(3, Integer.parseInt(quantities[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving reservations for event ID: {}.", eventId, e);
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageItem item = new StorageItem();
				item.setId(rs.getInt("id"));
				item.setName(rs.getString("name"));
				item.setQuantity(rs.getInt("reserved_quantity"));
				return item;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching reserved items for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		String sql = "SELECT * FROM events WHERE status NOT IN ('ABGESCHLOSSEN', 'ABGESAGT') AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active/upcoming events for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithEvent(int eventId, int userId) {
		String sql = "SELECT COUNT(*) FROM (SELECT 1 FROM event_attendance WHERE event_id = ? AND user_id = ? AND signup_status = 'ANGEMELDET' UNION ALL SELECT 1 FROM event_assignments WHERE event_id = ? AND user_id = ?) AS combined";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, eventId, userId, eventId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for event {} and user {}", eventId, userId, e);
			return false;
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u JOIN event_assignments ea ON u.id = ea.user_id LEFT JOIN roles r ON u.role_id = r.id WHERE ea.event_id = ?";
		try {
			return jdbcTemplate.query(sql, simpleUserRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching assigned users for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching completed event history for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.event_datetime >= NOW() ORDER BY e.event_datetime ASC";
		if (limit > 0) {
			sql += " LIMIT ?";
		}
		try {
			if (limit > 0) {
				return jdbcTemplate.query(sql, eventRowMapper, userId, limit);
			} else {
				return jdbcTemplate.query(sql, eventRowMapper, userId);
			}
		} catch (Exception e) {
			logger.error("Error fetching assigned events for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getUpcomingEvents(int limit) {
		String sql = "SELECT * FROM events WHERE event_datetime > NOW() ORDER BY event_datetime ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error fetching upcoming events with limit {}", limit, e);
			return List.of();
		}
	}

	public List<Event> search(String query) {
		String sql = "SELECT * FROM events WHERE name LIKE ? OR description LIKE ? OR location LIKE ? ORDER BY event_datetime DESC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching events for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventDebriefingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventDebriefing;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public class EventDebriefingDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventDebriefingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventDebriefing> debriefingRowMapper = (rs, rowNum) -> {
		EventDebriefing d = new EventDebriefing();
		d.setId(rs.getInt("id"));
		d.setEventId(rs.getInt("event_id"));
		d.setAuthorUserId(rs.getInt("author_user_id"));
		d.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		d.setWhatWentWell(rs.getString("what_went_well"));
		d.setWhatToImprove(rs.getString("what_to_improve"));
		d.setEquipmentNotes(rs.getString("equipment_notes"));
		d.setStandoutCrewMembers(rs.getString("standout_crew_members"));
		// Joined fields
		d.setEventName(rs.getString("event_name"));
		d.setAuthorUsername(rs.getString("author_username"));
		return d;
	};

	public Optional<EventDebriefing> findByEventId(int eventId) {
		String sql = "SELECT ed.*, e.name as event_name, u.username as author_username " + "FROM event_debriefings ed "
				+ "JOIN events e ON ed.event_id = e.id " + "JOIN users u ON ed.author_user_id = u.id "
				+ "WHERE ed.event_id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, debriefingRowMapper, eventId));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public List<EventDebriefing> findAll() {
		String sql = "SELECT ed.*, e.name as event_name, u.username as author_username " + "FROM event_debriefings ed "
				+ "JOIN events e ON ed.event_id = e.id " + "JOIN users u ON ed.author_user_id = u.id "
				+ "ORDER BY ed.submitted_at DESC";
		return jdbcTemplate.query(sql, debriefingRowMapper);
	}

	public EventDebriefing save(EventDebriefing debriefing) {
		String sql = "INSERT INTO event_debriefings (event_id, author_user_id, what_went_well, what_to_improve, equipment_notes, standout_crew_members) "
				+ "VALUES (?, ?, ?, ?, ?, ?) " + "ON DUPLICATE KEY UPDATE "
				+ "author_user_id = VALUES(author_user_id), " + "submitted_at = CURRENT_TIMESTAMP, "
				+ "what_went_well = VALUES(what_went_well), " + "what_to_improve = VALUES(what_to_improve), "
				+ "equipment_notes = VALUES(equipment_notes), "
				+ "standout_crew_members = VALUES(standout_crew_members)";

		jdbcTemplate.update(sql, debriefing.getEventId(), debriefing.getAuthorUserId(), debriefing.getWhatWentWell(),
				debriefing.getWhatToImprove(), debriefing.getEquipmentNotes(), debriefing.getStandoutCrewMembers());
		return findByEventId(debriefing.getEventId()).orElse(null);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventFeedbackDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventFeedbackDAO {
	private static final Logger logger = LogManager.getLogger(EventFeedbackDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventFeedbackDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, form.getEventId());
				ps.setString(2, form.getTitle());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
			return 0;
		}
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try {
			return jdbcTemplate.update(sql, response.getFormId(), response.getUserId(), response.getRating(),
					response.getComments()) > 0;
		} catch (Exception e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
			return false;
		}
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, eventId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
			return null;
		}
	}

	public FeedbackForm getFormById(int formId) {
		String sql = "SELECT * FROM feedback_forms WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, formId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for form ID {}", formId, e);
			return null;
		}
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FeedbackResponse response = new FeedbackResponse();
				response.setId(rs.getInt("id"));
				response.setFormId(rs.getInt("form_id"));
				response.setUserId(rs.getInt("user_id"));
				response.setUsername(rs.getString("username"));
				response.setRating(rs.getInt("rating"));
				response.setComments(rs.getString("comments"));
				response.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
				return response;
			}, formId);
		} catch (Exception e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
			return List.of();
		}
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT COUNT(*) FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, formId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user feedback submission status.", e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventRoleDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventRole;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class EventRoleDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventRoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventRole> rowMapper = (rs, rowNum) -> {
		EventRole role = new EventRole();
		role.setId(rs.getInt("id"));
		role.setName(rs.getString("name"));
		role.setDescription(rs.getString("description"));
		role.setIconClass(rs.getString("icon_class"));
		role.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return role;
	};

	public List<EventRole> findAll() {
		String sql = "SELECT * FROM event_roles ORDER BY name ASC";
		return jdbcTemplate.query(sql, rowMapper);
	}

	public boolean create(EventRole role) {
		String sql = "INSERT INTO event_roles (name, description, icon_class) VALUES (?, ?, ?)";
		return jdbcTemplate.update(sql, role.getName(), role.getDescription(), role.getIconClass()) > 0;
	}

	public boolean update(EventRole role) {
		String sql = "UPDATE event_roles SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		return jdbcTemplate.update(sql, role.getName(), role.getDescription(), role.getIconClass(), role.getId()) > 0;
	}

	public boolean delete(int id) {
		// ON DELETE SET NULL will handle un-assigning from event_assignments
		String sql = "DELETE FROM event_roles WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventTaskDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds,
			int[] dependencyIds) {
		boolean isUpdate = task.getId() > 0;
		if (isUpdate) {
			updateTask(task);
		} else {
			int newId = createTask(task);
			task.setId(newId);
		}

		if (task.getId() == 0) {
			throw new RuntimeException("Failed to create or find task ID.");
		}

		clearAssociations(task.getId());
		saveUserAssignments(task.getId(), userIds);
		saveItemRequirements(task.getId(), itemIds, itemQuantities);
		saveKitRequirements(task.getId(), kitIds);
		saveDependencies(task.getId(), dependencyIds);

		logger.info("Successfully saved task ID {}", task.getId());
		return task.getId();
	}

	private int createTask(EventTask task) {
		String taskSql = "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, task.getEventId());
			ps.setString(2, task.getDescription());
			ps.setString(3, task.getDetails());
			ps.setInt(4, task.getDisplayOrder());
			ps.setInt(5, task.getRequiredPersons());
			return ps;
		}, keyHolder);
		return Objects.requireNonNull(keyHolder.getKey()).intValue();
	}

	private void updateTask(EventTask task) {
		String taskSql = "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?";
		jdbcTemplate.update(taskSql, task.getDescription(), task.getDetails(), task.getStatus(), task.getDisplayOrder(),
				task.getRequiredPersons(), task.getId());
	}

	private void clearAssociations(int taskId) {
		jdbcTemplate.update("DELETE FROM event_task_assignments WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_storage_items WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_kits WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_dependencies WHERE task_id = ?", taskId);
	}

	private void saveUserAssignments(int taskId, int[] userIds) {
		if (userIds == null || userIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		List<Integer> userIdList = Arrays.stream(userIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, userIdList, 100, (ps, userId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, userId);
		});
	}

	private void saveItemRequirements(int taskId, String[] itemIds, String[] itemQuantities) {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;
		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		List<String> itemIdList = List.of(itemIds);
		jdbcTemplate.batchUpdate(sql, itemIdList, 100, (ps, itemIdStr) -> {
			if (itemIdStr != null && !itemIdStr.isEmpty()) {
				int index = itemIdList.indexOf(itemIdStr);
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(itemIdStr));
				ps.setInt(3, Integer.parseInt(itemQuantities[index]));
			}
		});
	}

	private void saveKitRequirements(int taskId, String[] kitIds) {
		if (kitIds == null || kitIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		List<String> kitIdList = List.of(kitIds);
		jdbcTemplate.batchUpdate(sql, kitIdList, 100, (ps, kitIdStr) -> {
			if (kitIdStr != null && !kitIdStr.isEmpty()) {
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(kitIdStr));
			}
		});
	}

	private void saveDependencies(int taskId, int[] dependencyIds) {
		if (dependencyIds == null || dependencyIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_dependencies (task_id, depends_on_task_id) VALUES (?, ?)";
		List<Integer> dependencyIdList = Arrays.stream(dependencyIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, dependencyIdList, 100, (ps, dependencyId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, dependencyId);
		});
	}

	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, u.id as user_id, u.username, si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, ik.id as kit_id, ik.name as kit_name FROM event_tasks t LEFT JOIN event_task_assignments ta ON t.id = ta.task_id LEFT JOIN users u ON ta.user_id = u.id LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id LEFT JOIN storage_items si ON tsi.item_id = si.id LEFT JOIN event_task_kits tk ON t.id = tk.task_id LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id WHERE t.event_id = ? ORDER BY t.display_order ASC, t.id ASC, u.username, si.name, ik.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int currentTaskId = rs.getInt("id");
			EventTask task = tasksById.computeIfAbsent(currentTaskId, id -> mapResultSetToTask(rs));

			int currentUserId = rs.getInt("user_id");
			if (currentUserId > 0 && task.getAssignedUsers().stream().noneMatch(u -> u.getId() == currentUserId)) {
				User user = new User();
				user.setId(currentUserId);
				user.setUsername(rs.getString("username"));
				task.getAssignedUsers().add(user);
			}
			int currentItemId = rs.getInt("item_id");
			if (currentItemId > 0 && task.getRequiredItems().stream().noneMatch(i -> i.getId() == currentItemId)) {
				StorageItem item = new StorageItem();
				item.setId(currentItemId);
				item.setName(rs.getString("item_name"));
				item.setQuantity(rs.getInt("item_quantity"));
				task.getRequiredItems().add(item);
			}
			int currentKitId = rs.getInt("kit_id");
			if (currentKitId > 0 && task.getRequiredKits().stream().noneMatch(k -> k.getId() == currentKitId)) {
				InventoryKit kit = new InventoryKit();
				kit.setId(currentKitId);
				kit.setName(rs.getString("kit_name"));
				task.getRequiredKits().add(kit);
			}
		}, eventId);

		// Now fetch and assemble dependencies
		if (!tasksById.isEmpty()) {
			String depSql = "SELECT * FROM event_task_dependencies WHERE task_id IN ("
					+ tasksById.keySet().stream().map(String::valueOf).collect(Collectors.joining(",")) + ")";
			jdbcTemplate.query(depSql, rs -> {
				int taskId = rs.getInt("task_id");
				int dependsOnId = rs.getInt("depends_on_task_id");
				EventTask task = tasksById.get(taskId);
				EventTask parentTask = tasksById.get(dependsOnId);
				if (task != null && parentTask != null) {
					task.getDependsOn().add(parentTask);
					parentTask.getDependencyFor().add(task);
				}
			});
		}

		return new ArrayList<>(tasksById.values());
	}

	private EventTask mapResultSetToTask(ResultSet rs) {
		try {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setDetails(rs.getString("details"));
			task.setStatus(rs.getString("status"));
			task.setDisplayOrder(rs.getInt("display_order"));
			task.setRequiredPersons(rs.getInt("required_persons"));
			task.setAssignedUsers(new ArrayList<>());
			task.setRequiredItems(new ArrayList<>());
			task.setRequiredKits(new ArrayList<>());
			task.setDependsOn(new ArrayList<>());
			task.setDependencyFor(new ArrayList<>());
			return task;
		} catch (SQLException e) {
			throw new RuntimeException("Failed to map ResultSet to EventTask", e);
		}
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, taskId) > 0;
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		String sql = "SELECT t.*, e.name as event_name FROM event_tasks t JOIN event_task_assignments ta ON t.id = ta.task_id JOIN events e ON t.event_id = e.id WHERE ta.user_id = ? AND t.status = 'OFFEN' ORDER BY e.event_datetime ASC";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setStatus(rs.getString("status"));
			task.setEventName(rs.getString("event_name"));
			return task;
		}, userId);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\FeedbackSubmissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackSubmission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class FeedbackSubmissionDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackSubmissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FeedbackSubmissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<FeedbackSubmission> submissionRowMapper = (rs, rowNum) -> {
		FeedbackSubmission sub = new FeedbackSubmission();
		sub.setId(rs.getInt("id"));
		sub.setUserId(rs.getInt("user_id"));
		sub.setUsername(rs.getString("username"));
		sub.setSubject(rs.getString("subject"));
		sub.setDisplayTitle(rs.getString("display_title"));
		sub.setContent(rs.getString("content"));
		sub.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		sub.setStatus(rs.getString("status"));
		sub.setDisplayOrder(rs.getInt("display_order"));
		return sub;
	};

	public boolean createSubmission(FeedbackSubmission submission) {
		String sql = "INSERT INTO feedback_submissions (user_id, subject, content) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, submission.getUserId(), submission.getSubject(),
					submission.getContent()) > 0;
		} catch (Exception e) {
			logger.error("Error creating feedback submission for user {}", submission.getUserId(), e);
			return false;
		}
	}

	public List<FeedbackSubmission> getAllSubmissions() {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id ORDER BY FIELD(fs.status, 'NEW', 'VIEWED', 'PLANNED', 'REJECTED', 'COMPLETED'), fs.display_order ASC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all feedback submissions", e);
			return List.of();
		}
	}

	public FeedbackSubmission getSubmissionById(int submissionId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, submissionRowMapper, submissionId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback submission by ID {}", submissionId, e);
			return null;
		}
	}

	public List<FeedbackSubmission> getSubmissionsByUserId(int userId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.user_id = ? ORDER BY fs.submitted_at DESC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching feedback submissions for user {}", userId, e);
			return List.of();
		}
	}

	public boolean updateStatusAndTitle(int submissionId, String newStatus, String displayTitle) {
		String sql = "UPDATE feedback_submissions SET status = ?, display_title = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, newStatus, displayTitle, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status and title for submission {}", submissionId, e);
			return false;
		}
	}

	public boolean deleteSubmission(int submissionId) {
		String sql = "DELETE FROM feedback_submissions WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting submission {}", submissionId, e);
			return false;
		}
	}

}
========================================================================
FILE: src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FileDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<File> fileRowMapper = (rs, rowNum) -> {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));
		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}
		if (DaoUtils.hasColumn(rs, "category_name")) {
			file.setCategoryName(
					rs.getString("category_name") == null ? "Ohne Kategorie" : rs.getString("category_name"));
		} else {
			file.setCategoryName("Ohne Kategorie");
		}
		return file;
	};

	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		List<File> files = getAllFiles(user);
		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	public List<File> getAllFiles(User user) {
		StringBuilder sql = new StringBuilder(
				"SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id ");
		// If user is null or not admin, only show public files.
		// In the "no verification" model, user will be null for admin endpoints.
		// We assume an admin context and show all files.
		if (user != null && !user.hasAdminAccess()) {
			sql.append("WHERE f.required_role = 'NUTZER' ");
		}
		sql.append("ORDER BY fc.name, f.filename");

		try {
			return jdbcTemplate.query(sql.toString(), fileRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching files.", e);
			return List.of();
		}
	}

	public int createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, file.getFilename());
				ps.setString(2, file.getFilepath());
				if (file.getCategoryId() > 0) {
					ps.setInt(3, file.getCategoryId());
				} else {
					ps.setNull(3, Types.INTEGER);
				}
				ps.setString(4, file.getRequiredRole());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating file record for '{}'", file.getFilename(), e);
			return 0;
		}
	}

	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	public boolean reassignFileToCategory(int fileId, int categoryId) {
		String sql = "UPDATE files SET category_id = ? WHERE id = ?";
		try {
			Object newCategoryId = categoryId > 0 ? categoryId : null;
			return jdbcTemplate.update(sql, newCategoryId, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error reassigning file {} to category {}", fileId, categoryId, e);
			return false;
		}
	}

	public List<FileCategory> getAllCategories() {
		String sql = "SELECT * FROM file_categories ORDER BY name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				return cat;
			});
		} catch (Exception e) {
			logger.error("Error fetching file categories.", e);
			return List.of();
		}
	}

	public File getFileById(int fileId) {
		String sql = "SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id WHERE f.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, fileRowMapper, fileId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error while fetching file with ID: {}", fileId, e);
			return null;
		}
	}

	public boolean deleteFile(int fileId) {
		String sql = "DELETE FROM files WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	public boolean createCategory(String categoryName) {
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try {
			return jdbcTemplate.update(sql, categoryName) > 0;
		} catch (Exception e) {
			logger.error("Error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	public boolean deleteCategory(int categoryId) {
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try {
			// First, un-assign files from this category
			jdbcTemplate.update("UPDATE files SET category_id = NULL WHERE category_id = ?", categoryId);
			return jdbcTemplate.update(sql, categoryId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, String.class, categoryId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

@Repository
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public InventoryKitDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<InventoryKit> kitRowMapper = (rs, rowNum) -> {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>());
		return kit;
	};

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, kit.getName());
				ps.setString(2, kit.getDescription());
				ps.setString(3, kit.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
			return 0;
		}
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, kit.getName(), kit.getDescription(), kit.getLocation(), kit.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, kitRowMapper, kitId);
		} catch (EmptyResultDataAccessException e) {
			return null; // Expected case when not found
		} catch (Exception e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
			return null;
		}
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try {
			// First, delete dependencies in the linking table
			jdbcTemplate.update("DELETE FROM inventory_kit_items WHERE kit_id = ?", kitId);
			// Then, delete the kit itself
			return jdbcTemplate.update(sql, kitId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, ki.item_id, ki.quantity, si.name as item_name FROM inventory_kits k LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id LEFT JOIN storage_items si ON ki.item_id = si.id ORDER BY k.name, si.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int kitId = rs.getInt("id");
			InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
				try {
					return kitRowMapper.mapRow(rs, 0);
				} catch (SQLException e) {
					// This is a safe way to handle checked exceptions within a lambda
					throw new RuntimeException("Failed to map ResultSet to InventoryKit", e);
				}
			});
			if (rs.getInt("item_id") > 0) {
				InventoryKitItem item = new InventoryKitItem();
				item.setKitId(kitId);
				item.setItemId(rs.getInt("item_id"));
				item.setQuantity(rs.getInt("quantity"));
				item.setItemName(rs.getString("item_name"));
				kit.getItems().add(item);
			}
		});
		return new ArrayList<>(kitMap.values());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MaintenanceLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, log.getItemId(), log.getUserId(), log.getAction(), log.getNotes(),
					log.getCost()) > 0;
		} catch (Exception e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml JOIN users u ON ml.user_id = u.id WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MaintenanceLogEntry entry = new MaintenanceLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
				entry.setAction(rs.getString("action"));
				entry.setNotes(rs.getString("notes"));
				entry.setCost(rs.getDouble("cost"));
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingAttendanceDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";
		try {
			jdbcTemplate.update(sql, userId, meetingId, attended, remarks);
			return true;
		} catch (Exception e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	public List<MeetingAttendance> getAllAttendance() {
		String sql = "SELECT * FROM meeting_attendance";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				MeetingAttendance attendance = new MeetingAttendance();
				attendance.setUserId(rs.getInt("user_id"));
				attendance.setMeetingId(rs.getInt("meeting_id"));
				attendance.setAttended(rs.getBoolean("attended"));
				attendance.setRemarks(rs.getString("remarks"));
				return attendance;
			});
		} catch (Exception e) {
			logger.error("SQL error fetching all attendance records.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public MeetingDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Meeting> meetingRowMapper = (rs, rowNum) -> {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null)
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));
		return meeting;
	};

	private final RowMapper<User> userRowMapper = (rs, rowNum) -> {
		User user = new User();
		user.setId(rs.getInt("id"));
		user.setUsername(rs.getString("username"));
		return user;
	};

	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, meeting.getCourseId());
				ps.setString(2, meeting.getName());
				ps.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
				if (meeting.getEndDateTime() != null)
					ps.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
				else
					ps.setNull(4, Types.TIMESTAMP);
				if (meeting.getLeaderUserId() > 0)
					ps.setInt(5, meeting.getLeaderUserId());
				else
					ps.setNull(5, Types.INTEGER);
				ps.setString(6, meeting.getDescription());
				ps.setString(7, meeting.getLocation());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating meeting: {}", meeting.getName(), e);
			return 0;
		}
	}

	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, meetingRowMapper, meetingId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching meeting by ID: {}", meetingId, e);
			return null;
		}
	}

	public List<Meeting> getMeetingsForCourse(int courseId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, courseId);
		} catch (Exception e) {
			logger.error("Error fetching meetings for course ID: {}", courseId, e);
			return List.of();
		}
	}

	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, meeting.getName(), Timestamp.valueOf(meeting.getMeetingDateTime()),
					meeting.getEndDateTime() != null ? Timestamp.valueOf(meeting.getEndDateTime()) : null,
					meeting.getLeaderUserId() > 0 ? meeting.getLeaderUserId() : null, meeting.getDescription(),
					meeting.getLocation(), meeting.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		try {
			jdbcTemplate.update("DELETE FROM meeting_attendance WHERE meeting_id = ?", meetingId);
			return jdbcTemplate.update(sql, meetingId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Meeting meeting = meetingRowMapper.mapRow(rs, rowNum);
				if (rs.getObject("attended") != null) {
					meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
				} else {
					meeting.setUserAttendanceStatus("OFFEN");
				}
				return meeting;
			}, user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for user {}", user.getId(), e);
			return List.of();
		}
	}

	public List<Meeting> getAllUpcomingMeetings() {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching upcoming meetings for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
		String sql = "SELECT COUNT(*) FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, meetingId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
			return false;
		}
	}

	public List<Meeting> search(String query) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.name LIKE ? OR m.description LIKE ? OR c.name LIKE ? ORDER BY m.meeting_datetime DESC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, meetingRowMapper, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching meetings for query '{}'", query, e);
			return List.of();
		}
	}

	public List<User> getParticipantUsersForMeeting(int meetingId) {
		String sql = "SELECT u.id, u.username FROM users u JOIN meeting_attendance ma ON u.id = ma.user_id WHERE ma.meeting_id = ? AND ma.attended = 1";
		try {
			return jdbcTemplate.query(sql, userRowMapper, meetingId);
		} catch (Exception e) {
			logger.error("Error fetching participant users for meeting {}", meetingId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Repository
public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public PermissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Permission> getAllPermissions() {
		String sql = "SELECT * FROM permissions ORDER BY description";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				return p;
			});
		} catch (Exception e) {
			logger.error("Error fetching all permissions", e);
			return List.of();
		}
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try {
			List<Integer> ids = jdbcTemplate.queryForList(sql, Integer.class, userId);
			return new HashSet<>(ids);
		} catch (Exception e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
			return Set.of();
		}
	}

	public Integer getPermissionIdByKey(String key) {
		String sql = "SELECT id FROM permissions WHERE permission_key = ?";
		try {
			return jdbcTemplate.queryForObject(sql, Integer.class, key);
		} catch (EmptyResultDataAccessException e) {
			logger.warn("Could not find permission with key: {}", key);
			return null;
		} catch (Exception e) {
			logger.error("Error fetching permission ID for key {}", key, e);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ProfileChangeRequestDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ProfileChangeRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class ProfileChangeRequestDAO {
	private static final Logger logger = LogManager.getLogger(ProfileChangeRequestDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ProfileChangeRequestDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<ProfileChangeRequest> requestRowMapper = (rs, rowNum) -> {
		ProfileChangeRequest request = new ProfileChangeRequest();
		request.setId(rs.getInt("id"));
		request.setUserId(rs.getInt("user_id"));
		request.setRequestedChanges(rs.getString("requested_changes"));
		request.setStatus(rs.getString("status"));
		request.setRequestedAt(rs.getTimestamp("requested_at").toLocalDateTime());
		request.setUsername(rs.getString("username"));
		if (rs.getObject("reviewed_by_admin_id") != null) {
			request.setReviewedByAdminId(rs.getInt("reviewed_by_admin_id"));
		}
		if (rs.getTimestamp("reviewed_at") != null) {
			request.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		if (rs.getMetaData().getColumnCount() > 8) { // Simple check if admin_username is present
			request.setReviewedByAdminName(rs.getString("admin_username"));
		}
		return request;
	};

	public boolean createRequest(ProfileChangeRequest request) {
		String sql = "INSERT INTO profile_change_requests (user_id, requested_changes, status) VALUES (?, ?, 'PENDING')";
		try {
			return jdbcTemplate.update(sql, request.getUserId(), request.getRequestedChanges()) > 0;
		} catch (Exception e) {
			logger.error("Error creating profile change request for user {}", request.getUserId(), e);
			return false;
		}
	}

	public ProfileChangeRequest getRequestById(int id) {
		String sql = "SELECT pcr.*, u.username as username, a.username as admin_username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id LEFT JOIN users a ON pcr.reviewed_by_admin_id = a.id WHERE pcr.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, requestRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching request by ID {}", id, e);
			return null;
		}
	}

	public List<ProfileChangeRequest> getPendingRequests() {
		String sql = "SELECT pcr.*, u.username as username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id WHERE pcr.status = 'PENDING' ORDER BY pcr.requested_at ASC";
		try {
			return jdbcTemplate.query(sql, requestRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching pending requests", e);
			return List.of();
		}
	}

	public boolean hasPendingRequest(int userId) {
		String sql = "SELECT COUNT(*) FROM profile_change_requests WHERE user_id = ? AND status = 'PENDING'";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for pending request for user {}", userId, e);
			return false;
		}
	}

	public boolean updateRequestStatus(int requestId, String status, int adminId) {
		String sql = "UPDATE profile_change_requests SET status = ?, reviewed_by_admin_id = ?, reviewed_at = NOW() WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, status, adminId, requestId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status for request {}", requestId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.ColumnMapRowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

@Repository
public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ReportDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<Map<String, Object>> getEventParticipationSummary() {
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating event participation summary.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserActivityStats() {
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating user activity stats.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper());
		} catch (Exception e) {
			logger.error("Error generating inventory usage frequency report.", e);
			return List.of();
		}
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		try {
			Double totalValue = jdbcTemplate.queryForObject(sql, Double.class);
			return totalValue != null ? totalValue : 0.0;
		} catch (Exception e) {
			logger.error("Error calculating total inventory value.", e);
			return 0.0;
		}
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		String sql = "SELECT DATE_FORMAT(event_datetime, '%Y-%m') AS month, COUNT(*) AS count " + "FROM events "
				+ "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), months);
		} catch (Exception e) {
			logger.error("Error generating event count by month report.", e);
			return List.of();
		}
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try {
			return jdbcTemplate.query(sql, new ColumnMapRowMapper(), limit);
		} catch (Exception e) {
			logger.error("Error generating user participation stats.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.concurrent.TimeUnit;

@Repository
public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);
	private final JdbcTemplate jdbcTemplate;
	private final LoadingCache<String, List<Role>> roleCache;
	private static final String ALL_ROLES_KEY = "ALL_ROLES";

	@Autowired
	public RoleDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
		this.roleCache = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.HOURS).maximumSize(1)
				.build(key -> fetchAllRolesFromDb());
	}

	public List<Role> getAllRoles() {
		logger.debug("Fetching all roles from cache.");
		return roleCache.get(ALL_ROLES_KEY);
	}

	private List<Role> fetchAllRolesFromDb() {
		logger.info("Cache miss for roles. Fetching all roles from database.");
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				return role;
			});
		} catch (Exception e) {
			logger.error("Error fetching all roles from DB", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\ScheduledNotificationDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ScheduledNotification;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;

@Repository
public class ScheduledNotificationDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public ScheduledNotificationDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createOrUpdateReminder(String type, int entityId, List<Integer> userIds, LocalDateTime sendAt,
			String title, String description, String url) {
		// First, delete any existing reminders for this entity to prevent duplicates
		deleteReminders(type, entityId);

		// If a valid send time and user list are provided, create new reminders
		if (sendAt != null && userIds != null && !userIds.isEmpty()) {
			String sql = "INSERT INTO scheduled_notifications (target_user_id, notification_type, related_entity_id, send_at, title, description, url) VALUES (?, ?, ?, ?, ?, ?, ?)";
			jdbcTemplate.batchUpdate(sql, userIds, 100, (ps, userId) -> {
				ps.setInt(1, userId);
				ps.setString(2, type);
				ps.setInt(3, entityId);
				ps.setTimestamp(4, Timestamp.valueOf(sendAt));
				ps.setString(5, title);
				ps.setString(6, description);
				ps.setString(7, url);
			});
		}
	}

	public void deleteReminders(String type, int entityId) {
		String sql = "DELETE FROM scheduled_notifications WHERE notification_type = ? AND related_entity_id = ?";
		jdbcTemplate.update(sql, type, entityId);
	}

	public List<ScheduledNotification> findPendingNotifications() {
		String sql = "SELECT * FROM scheduled_notifications WHERE status = 'PENDING' AND send_at <= NOW()";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			ScheduledNotification n = new ScheduledNotification();
			n.setId(rs.getInt("id"));
			n.setTargetUserId(rs.getInt("target_user_id"));
			n.setTitle(rs.getString("title"));
			n.setDescription(rs.getString("description"));
			n.setUrl(rs.getString("url"));
			return n;
		});
	}

	public void markAsSent(List<Integer> ids) {
		if (ids.isEmpty())
			return;
		String sql = "UPDATE scheduled_notifications SET status = 'SENT' WHERE id IN ("
				+ ids.stream().map(String::valueOf).collect(java.util.stream.Collectors.joining(",")) + ")";
		jdbcTemplate.update(sql);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

@Repository
public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StatisticsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int getUserCount() {
		return getCount("SELECT COUNT(*) FROM users");
	}

	public int getActiveEventCount() {
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	private int getCount(String sql) {
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
			return count != null ? count : 0;
		} catch (Exception e) {
			logger.error("SQL error executing count query: {}", sql, e);
			return 0;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Repository
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<StorageItem> storageItemRowMapper = (rs, rowNum) -> {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	};

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream()
				.collect(Collectors.groupingBy(
						item -> item.getLocation() != null && !item.getLocation().isBlank() ? item.getLocation().trim()
								: "Unbekannt"));
	}

	public List<StorageItem> getAllItems() {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id ORDER BY si.location, si.name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all storage items.", e);
			return List.of();
		}
	}

	public List<StorageItem> getDefectiveItems() {
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching defective items.", e);
			return List.of();
		}
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id WHERE si.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, storageItemRowMapper, itemId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching storage item by ID: {}", itemId, e);
			return null;
		}
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try {
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getWeightKg(),
					item.getPriceEur(), item.getImagePath()) > 0;
		} catch (Exception e) {
			logger.error("Error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try {
			Object holderId = item.getCurrentHolderUserId() > 0 ? item.getCurrentHolderUserId() : null;
			Object eventId = item.getAssignedEventId() > 0 ? item.getAssignedEventId() : null;
			return jdbcTemplate.update(sql, item.getName(), item.getLocation(), item.getCabinet(),
					item.getCompartment(), item.getQuantity(), item.getMaxQuantity(), item.getDefectiveQuantity(),
					item.getDefectReason(), item.getWeightKg(), item.getPriceEur(), item.getImagePath(),
					item.getStatus(), holderId, eventId, item.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, itemId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public List<StorageItem> getLowStockItems(int limit) {
		String sql = "SELECT * FROM storage_items WHERE (quantity - defective_quantity) < (max_quantity * 0.25) AND max_quantity > 0 ORDER BY (quantity - defective_quantity) / max_quantity ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error while fetching low stock items.", e);
			return List.of();
		}
	}

	public List<StorageItem> search(String query) {
		String sql = "SELECT * FROM storage_items WHERE name LIKE ? OR location LIKE ? OR cabinet LIKE ? OR compartment LIKE ? ORDER BY name ASC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, storageItemRowMapper, searchTerm, searchTerm, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching storage items for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Types;
import java.util.List;

@Repository
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public StorageLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		try {
			Object eventIdObj = eventId > 0 ? eventId : null;
			int[] types = { Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.VARCHAR, Types.INTEGER };
			return jdbcTemplate.update(sql, new Object[] { itemId, userId, quantityChange, notes, eventIdObj },
					types) > 0;
		} catch (Exception e) {
			logger.error("Error logging storage transaction for item {}", itemId, e);
			return false;
		}
	}

	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		String sql = "SELECT sl.*, u.username FROM storage_log sl JOIN users u ON sl.user_id = u.id WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageLogEntry entry = new StorageLogEntry();
				entry.setId(rs.getInt("id"));
				entry.setItemId(rs.getInt("item_id"));
				entry.setUserId(rs.getInt("user_id"));
				entry.setUsername(rs.getString("username"));
				entry.setQuantityChange(rs.getInt("quantity_change"));
				entry.setNotes(rs.getString("notes"));
				entry.setEventId(rs.getInt("event_id"));
				entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
				return entry;
			}, itemId);
		} catch (Exception e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\TodoDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Repository
public class TodoDAO {
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public TodoDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public List<TodoCategory> getAllCategoriesWithTasks() {
		Map<Integer, TodoCategory> categoryMap = new LinkedHashMap<>();
		String sql = "SELECT c.id as cat_id, c.name as cat_name, c.display_order as cat_order, "
				+ "t.id as task_id, t.category_id as task_cat_id, t.content as task_content, "
				+ "t.is_completed as task_completed, t.display_order as task_order "
				+ "FROM todo_categories c LEFT JOIN todo_tasks t ON c.id = t.category_id "
				+ "ORDER BY c.display_order, t.display_order";

		jdbcTemplate.query(sql, rs -> {
			int categoryId = rs.getInt("cat_id");
			TodoCategory category = categoryMap.computeIfAbsent(categoryId, id -> {
				try {
					TodoCategory newCat = new TodoCategory();
					newCat.setId(id);
					newCat.setName(rs.getString("cat_name"));
					newCat.setDisplayOrder(rs.getInt("cat_order"));
					return newCat;
				} catch (SQLException e) {
					throw new RuntimeException(e);
				}
			});

			if (rs.getObject("task_id") != null) {
				TodoTask task = new TodoTask();
				task.setId(rs.getInt("task_id"));
				task.setCategoryId(rs.getInt("task_cat_id"));
				task.setContent(rs.getString("task_content"));
				task.setCompleted(rs.getBoolean("task_completed"));
				task.setDisplayOrder(rs.getInt("task_order"));
				category.getTasks().add(task);
			}
		});
		return new ArrayList<>(categoryMap.values());
	}

	public TodoCategory createCategory(String name) {
		String sql = "INSERT INTO todo_categories (name, display_order) "
				+ "SELECT ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_categories";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, name);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoCategory newCategory = new TodoCategory();
		newCategory.setId(newId);
		newCategory.setName(name);
		return newCategory;
	}

	public TodoTask createTask(int categoryId, String content) {
		String sql = "INSERT INTO todo_tasks (category_id, content, display_order) "
				+ "SELECT ?, ?, COALESCE(MAX(display_order), -1) + 1 FROM todo_tasks WHERE category_id = ?";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, categoryId);
			ps.setString(2, content);
			ps.setInt(3, categoryId);
			return ps;
		}, keyHolder);

		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		TodoTask newTask = new TodoTask();
		newTask.setId(newId);
		newTask.setCategoryId(categoryId);
		newTask.setContent(content);
		return newTask;
	}

	public boolean updateTaskContent(int taskId, String content) {
		String sql = "UPDATE todo_tasks SET content = ? WHERE id = ?";
		return jdbcTemplate.update(sql, content, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, boolean isCompleted) {
		String sql = "UPDATE todo_tasks SET is_completed = ? WHERE id = ?";
		return jdbcTemplate.update(sql, isCompleted, taskId) > 0;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM todo_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean deleteCategory(int categoryId) {
		jdbcTemplate.update("DELETE FROM todo_tasks WHERE category_id = ?", categoryId);
		String sql = "DELETE FROM todo_categories WHERE id = ?";
		return jdbcTemplate.update(sql, categoryId) > 0;
	}

	public void updateCategoryOrder(List<Integer> categoryIds) {
		String sql = "UPDATE todo_categories SET display_order = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, categoryIds, 100, (ps, categoryId) -> {
			ps.setInt(1, categoryIds.indexOf(categoryId));
			ps.setInt(2, categoryId);
		});
	}

	public void updateTaskOrders(List<Integer> taskIds, int categoryId) {
		String sql = "UPDATE todo_tasks SET display_order = ?, category_id = ? WHERE id = ?";
		jdbcTemplate.batchUpdate(sql, taskIds, 100, (ps, taskId) -> {
			ps.setInt(1, taskIds.indexOf(taskId));
			ps.setInt(2, categoryId);
			ps.setInt(3, taskId);
		});
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<User> userRowMapper = (resultSet, rowNum) -> {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		user.setPasswordHash(resultSet.getString("password_hash"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "profile_icon_class")) {
			user.setProfileIconClass(resultSet.getString("profile_icon_class"));
		}
		if (DaoUtils.hasColumn(resultSet, "admin_notes")) {
			user.setAdminNotes(resultSet.getString("admin_notes"));
		}
		if (DaoUtils.hasColumn(resultSet, "dashboard_layout")) {
			user.setDashboardLayout(resultSet.getString("dashboard_layout"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	};

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, this.userRowMapper, username);
			String storedHash = user.getPasswordHash();

			if (storedHash != null && passwordEncoder.matches(password, storedHash)) {
				user.setPermissions(getPermissionsForUser(user.getId()));
				return user;
			}
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, username);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(user.getId()));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by username: {}", username, e);
			return null;
		}
	}

	public Set<String> getPermissionsForUser(int userId) {
		String sql = "SELECT p.permission_key FROM permissions p "
				+ "JOIN user_permissions up ON p.id = up.permission_id " + "WHERE up.user_id = ?";
		try {
			List<String> permissionKeys = jdbcTemplate.queryForList(sql, String.class, userId);
			return new HashSet<>(permissionKeys);
		} catch (Exception e) {
			logger.error("Error fetching permissions for user {}", userId, e);
			return Set.of();
		}
	}

	@Transactional
	public boolean updateUserPermissions(int userId, String[] permissionIds) {
		jdbcTemplate.update("DELETE FROM user_permissions WHERE user_id = ?", userId);
		if (permissionIds != null && permissionIds.length > 0) {
			List<Object[]> batchArgs = Arrays.stream(permissionIds)
					.map(idStr -> new Object[] { userId, Integer.parseInt(idStr) }).collect(Collectors.toList());
			jdbcTemplate.batchUpdate("INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)", batchArgs);
		}
		return true;
	}

	public int createUser(User user, String password) {
		String hashedPassword = passwordEncoder.encode(password);
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, user.getUsername());
				ps.setString(2, hashedPassword);
				ps.setInt(3, user.getRoleId());
				ps.setInt(4, user.getClassYear());
				ps.setString(5, user.getClassName());
				ps.setString(6, user.getEmail());
				ps.setString(7, "light");
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating user {}", user.getUsername(), e);
			return 0;
		}
	}

	public boolean updateUser(User user) {
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ?, profile_icon_class = ?, admin_notes = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, user.getUsername(), user.getRoleId(), user.getClassYear(),
					user.getClassName(), user.getEmail(), user.getProfileIconClass(), user.getAdminNotes(),
					user.getId()) > 0;
		} catch (Exception e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, theme, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating theme for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, chatColor, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating chat color for user ID {}", userId, e);
			return false;
		}
	}

	public boolean updateDashboardLayout(int userId, String layoutJson) {
		String sql = "UPDATE users SET dashboard_layout = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, layoutJson, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating dashboard layout for user ID {}", userId, e);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, hashedPassword, userId) > 0;
		} catch (Exception e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}

	public List<User> getAllUsers() {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		try {
			return jdbcTemplate.query(sql, userRowMapper);
		} catch (Exception e) {
			logger.error("SQL error fetching all users", e);
			return List.of();
		}
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		try {
			User user = jdbcTemplate.queryForObject(sql, userRowMapper, userId);
			if (user != null) {
				user.setPermissions(getPermissionsForUser(userId));
			}
			return user;
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("SQL error fetching user by ID with permissions: {}", userId, e);
			return null;
		}
	}

	public List<Integer> findUserIdsByPermission(String permissionKey) {
		String sql = "SELECT up.user_id FROM user_permissions up JOIN permissions p ON up.permission_id = p.id WHERE p.permission_key = ?";
		try {
			return jdbcTemplate.queryForList(sql, Integer.class, permissionKey);
		} catch (Exception e) {
			logger.error("Error fetching user IDs by permission key '{}'", permissionKey, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.UserQualification;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.List;

@Repository
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public UserQualificationsDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private UserQualification mapResultSetToUserQualification(ResultSet rs, int rowNum) throws SQLException {
		UserQualification uq = new UserQualification();
		if (DaoUtils.hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	public List<UserQualification> getQualificationsForUser(int userId) {
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id WHERE uq.user_id = ?";
		try {
			return jdbcTemplate.query(sql, this::mapResultSetToUserQualification, userId);
		} catch (Exception e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
			return List.of();
		}
	}

	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try {
				jdbcTemplate.update(deleteSql, userId, courseId);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try {
				jdbcTemplate.update(upsertSql, userId, courseId, status, completionDate, remarks);
				return true;
			} catch (Exception e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\VenueDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Venue;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class VenueDAO {

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public VenueDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Venue> venueRowMapper = (rs, rowNum) -> {
		Venue venue = new Venue();
		venue.setId(rs.getInt("id"));
		venue.setName(rs.getString("name"));
		venue.setAddress(rs.getString("address"));
		venue.setNotes(rs.getString("notes"));
		venue.setMapImagePath(rs.getString("map_image_path"));
		venue.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		return venue;
	};

	public List<Venue> findAll() {
		String sql = "SELECT * FROM venues ORDER BY name ASC";
		return jdbcTemplate.query(sql, venueRowMapper);
	}

	public Optional<Venue> findById(int id) {
		String sql = "SELECT * FROM venues WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, venueRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		}
	}

	public Venue create(Venue venue) {
		String sql = "INSERT INTO venues (name, address, notes, map_image_path) VALUES (?, ?, ?, ?)";
		GeneratedKeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
			ps.setString(1, venue.getName());
			ps.setString(2, venue.getAddress());
			ps.setString(3, venue.getNotes());
			ps.setString(4, venue.getMapImagePath());
			return ps;
		}, keyHolder);
		int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
		venue.setId(newId);
		return venue;
	}

	public boolean update(Venue venue) {
		String sql = "UPDATE venues SET name = ?, address = ?, notes = ?, map_image_path = ? WHERE id = ?";
		return jdbcTemplate.update(sql, venue.getName(), venue.getAddress(), venue.getNotes(), venue.getMapImagePath(),
				venue.getId()) > 0;
	}

	public boolean delete(int id) {
		String sql = "DELETE FROM venues WHERE id = ?";
		return jdbcTemplate.update(sql, id) > 0;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\WikiDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

@Repository
public class WikiDAO {
	private static final Logger logger = LogManager.getLogger(WikiDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public WikiDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<WikiEntry> wikiEntryRowMapper = (rs, rowNum) -> {
		WikiEntry entry = new WikiEntry();
		entry.setId(rs.getInt("id"));
		entry.setFilePath(rs.getString("file_path"));
		entry.setContent(rs.getString("content"));
		return entry;
	};

	public Optional<WikiEntry> getWikiEntryById(int id) {
		String sql = "SELECT * FROM wiki_documentation WHERE id = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, id));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by ID {}", id, e);
			return Optional.empty();
		}
	}

	public Optional<WikiEntry> findByFilePath(String filePath) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path = ?";
		try {
			return Optional.ofNullable(jdbcTemplate.queryForObject(sql, wikiEntryRowMapper, filePath));
		} catch (EmptyResultDataAccessException e) {
			return Optional.empty();
		} catch (Exception e) {
			logger.error("Error fetching wiki entry by file_path {}", filePath, e);
			return Optional.empty();
		}
	}

	public List<WikiEntry> getAllWikiEntries() {
		String sql = "SELECT * FROM wiki_documentation ORDER BY file_path";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all wiki entries", e);
			return List.of();
		}
	}

	public boolean updateWikiContent(int id, String content) {
		String sql = "UPDATE wiki_documentation SET content = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, content, id) > 0;
		} catch (Exception e) {
			logger.error("Error updating wiki content for ID {}", id, e);
			return false;
		}
	}

	public Optional<WikiEntry> createWikiEntry(WikiEntry entry) {
		String sql = "INSERT INTO wiki_documentation (file_path, content) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, entry.getFilePath());
				ps.setString(2, entry.getContent());
				return ps;
			}, keyHolder);
			entry.setId(Objects.requireNonNull(keyHolder.getKey()).intValue());
			return Optional.of(entry);
		} catch (Exception e) {
			logger.error("Error creating wiki entry for path {}", entry.getFilePath(), e);
			return Optional.empty();
		}
	}

	public boolean deleteWikiEntry(int id) {
		String sql = "DELETE FROM wiki_documentation WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting wiki entry with ID {}", id, e);
			return false;
		}
	}

	public List<WikiEntry> search(String query) {
		String sql = "SELECT * FROM wiki_documentation WHERE file_path LIKE ? OR content LIKE ? ORDER BY file_path ASC LIMIT 20";
		String searchTerm = "%" + query + "%";
		try {
			return jdbcTemplate.query(sql, wikiEntryRowMapper, searchTerm, searchTerm);
		} catch (Exception e) {
			logger.error("Error searching wiki entries for query '{}'", query, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ApiResponse.java
========================================================================

package de.technikteam.model;

/**
 * A standard wrapper for all API responses. This object is returned by all
 * Actions and processed by the FrontControllerServlet. It contains a success
 * flag, a message, and a generic data payload.
 */
public class ApiResponse {

	private final boolean success;
	private final String message;
	private final Object data;

	public ApiResponse(boolean success, String message, Object data) {
		this.success = success;
		this.message = message;
		this.data = data;
	}

	public boolean isSuccess() {
		return success;
	}

	public String getMessage() {
		return message;
	}

	public Object getData() {
		return data;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; 
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Changelog.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;
import java.util.List;

public class Changelog {
	private int id;
	private String version;
	private LocalDate releaseDate;
	private String title;
	private String notes;
	private boolean isPublished;
	private List<Integer> seenByUserIds; // Mapped from JSON

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getVersion() {
		return version;
	}

	public void setVersion(String version) {
		this.version = version;
	}

	public LocalDate getReleaseDate() {
		return releaseDate;
	}

	public void setReleaseDate(LocalDate releaseDate) {
		this.releaseDate = releaseDate;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public boolean isPublished() {
		return isPublished;
	}

	public void setPublished(boolean published) {
		isPublished = published;
	}

	public List<Integer> getSeenByUserIds() {
		return seenByUserIds;
	}

	public void setSeenByUserIds(List<Integer> seenByUserIds) {
		this.seenByUserIds = seenByUserIds;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChatConversation.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class ChatConversation {
	private int id;
	private boolean isGroupChat;
	private String name;
	private Integer creatorId;
	private LocalDateTime createdAt;

	// Transient fields for UI
	private int otherParticipantId;
	private String otherParticipantUsername;
	private String lastMessage;
	private LocalDateTime lastMessageTimestamp;
	private List<User> participants;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public boolean isGroupChat() {
		return isGroupChat;
	}

	public void setGroupChat(boolean groupChat) {
		isGroupChat = groupChat;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getCreatorId() {
		return creatorId;
	}

	public void setCreatorId(Integer creatorId) {
		this.creatorId = creatorId;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getOtherParticipantId() {
		return otherParticipantId;
	}

	public void setOtherParticipantId(int otherParticipantId) {
		this.otherParticipantId = otherParticipantId;
	}

	public String getOtherParticipantUsername() {
		return otherParticipantUsername;
	}

	public void setOtherParticipantUsername(String otherParticipantUsername) {
		this.otherParticipantUsername = otherParticipantUsername;
	}

	public String getLastMessage() {
		return lastMessage;
	}

	public void setLastMessage(String lastMessage) {
		this.lastMessage = lastMessage;
	}

	public LocalDateTime getLastMessageTimestamp() {
		return lastMessageTimestamp;
	}

	public void setLastMessageTimestamp(LocalDateTime lastMessageTimestamp) {
		this.lastMessageTimestamp = lastMessageTimestamp;
	}

	public List<User> getParticipants() {
		return participants;
	}

	public void setParticipants(List<User> participants) {
		this.participants = participants;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ChatMessage {
	private long id;
	private int conversationId;
	private int senderId;
	private String senderUsername;
	private String messageText;
	private String status; // SENT, DELIVERED, READ
	private LocalDateTime sentAt;
	private String chatColor;
	private boolean edited;
	private LocalDateTime editedAt;
	private boolean isDeleted;
	private LocalDateTime deletedAt;
	private Integer deletedByUserId;
	private String deletedByUsername; // Transient

	public long getId() {
		return id;
	}

	public void setId(long id) {
		this.id = id;
	}

	public int getConversationId() {
		return conversationId;
	}

	public void setConversationId(int conversationId) {
		this.conversationId = conversationId;
	}

	public int getSenderId() {
		return senderId;
	}

	public void setSenderId(int senderId) {
		this.senderId = senderId;
	}

	public String getSenderUsername() {
		return senderUsername;
	}

	public void setSenderUsername(String senderUsername) {
		this.senderUsername = senderUsername;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public LocalDateTime getEditedAt() {
		return editedAt;
	}

	public void setEditedAt(LocalDateTime editedAt) {
		this.editedAt = editedAt;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean deleted) {
		isDeleted = deleted;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public Integer getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(Integer deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistItem.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ChecklistItem {
	private int id;
	private int eventId;
	private int itemId;
	private String itemName;
	private int quantity;
	private String status;
	private Integer lastUpdatedByUserId;
	private String lastUpdatedByUsername;
	private LocalDateTime lastUpdatedAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Integer getLastUpdatedByUserId() {
		return lastUpdatedByUserId;
	}

	public void setLastUpdatedByUserId(Integer lastUpdatedByUserId) {
		this.lastUpdatedByUserId = lastUpdatedByUserId;
	}

	public String getLastUpdatedByUsername() {
		return lastUpdatedByUsername;
	}

	public void setLastUpdatedByUsername(String lastUpdatedByUsername) {
		this.lastUpdatedByUsername = lastUpdatedByUsername;
	}

	public LocalDateTime getLastUpdatedAt() {
		return lastUpdatedAt;
	}

	public void setLastUpdatedAt(LocalDateTime lastUpdatedAt) {
		this.lastUpdatedAt = lastUpdatedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistTemplate.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class ChecklistTemplate {
	private int id;
	private String name;
	private String description;
	private LocalDateTime createdAt;
	private List<ChecklistTemplateItem> items;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public List<ChecklistTemplateItem> getItems() {
		return items;
	}

	public void setItems(List<ChecklistTemplateItem> items) {
		this.items = items;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ChecklistTemplateItem.java
========================================================================

package de.technikteam.model;

public class ChecklistTemplateItem {
	private int id;
	private int templateId;
	private String itemText;
	private int displayOrder;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getTemplateId() {
		return templateId;
	}

	public void setTemplateId(int templateId) {
		this.templateId = templateId;
	}

	public String getItemText() {
		return itemText;
	}

	public void setItemText(String itemText) {
		this.itemText = itemText;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DamageReport.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class DamageReport {
	private int id;
	private int itemId;
	private int reporterUserId;
	private String reportDescription;
	private LocalDateTime reportedAt;
	private String status;
	private Integer reviewedByAdminId;
	private LocalDateTime reviewedAt;
	private String adminNotes;

	// Transient fields for easy display
	private String itemName;
	private String reporterUsername;
	private String reviewedByAdminUsername;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getReporterUserId() {
		return reporterUserId;
	}

	public void setReporterUserId(int reporterUserId) {
		this.reporterUserId = reporterUserId;
	}

	public String getReportDescription() {
		return reportDescription;
	}

	public void setReportDescription(String reportDescription) {
		this.reportDescription = reportDescription;
	}

	public LocalDateTime getReportedAt() {
		return reportedAt;
	}

	public void setReportedAt(LocalDateTime reportedAt) {
		this.reportedAt = reportedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}

	public String getAdminNotes() {
		return adminNotes;
	}

	public void setAdminNotes(String adminNotes) {
		this.adminNotes = adminNotes;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}

	public String getReporterUsername() {
		return reporterUsername;
	}

	public void setReporterUsername(String reporterUsername) {
		this.reporterUsername = reporterUsername;
	}

	public String getReviewedByAdminUsername() {
		return reviewedByAdminUsername;
	}

	public void setReviewedByAdminUsername(String reviewedByAdminUsername) {
		this.reviewedByAdminUsername = reviewedByAdminUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\DashboardDataDTO.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.Map;

/**
 * A Data Transfer Object to encapsulate all data required for the dynamic admin
 * dashboard.
 */
public class DashboardDataDTO {
	private List<Event> upcomingEvents;
	private List<StorageItem> lowStockItems;
	private List<AdminLog> recentLogs;
	private List<Map<String, Object>> eventTrendData;

	public List<Event> getUpcomingEvents() {
		return upcomingEvents;
	}

	public void setUpcomingEvents(List<Event> upcomingEvents) {
		this.upcomingEvents = upcomingEvents;
	}

	public List<StorageItem> getLowStockItems() {
		return lowStockItems;
	}

	public void setLowStockItems(List<StorageItem> lowStockItems) {
		this.lowStockItems = lowStockItems;
	}

	public List<AdminLog> getRecentLogs() {
		return recentLogs;
	}

	public void setRecentLogs(List<AdminLog> recentLogs) {
		this.recentLogs = recentLogs;
	}

	public List<Map<String, Object>> getEventTrendData() {
		return eventTrendData;
	}

	public void setEventTrendData(List<Map<String, Object>> eventTrendData) {
		this.eventTrendData = eventTrendData;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;
	private List<ChecklistItem> checklistItems;

	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public List<ChecklistItem> getChecklistItems() {
		return checklistItems;
	}

	public void setChecklistItems(List<ChecklistItem> checklistItems) {
		this.checklistItems = checklistItems;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean isAnnouncement;
	private boolean edited;
	private LocalDateTime editedAt;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor;

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isAnnouncement() {
		return isAnnouncement;
	}

	public void setAnnouncement(boolean announcement) {
		isAnnouncement = announcement;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public LocalDateTime getEditedAt() {
		return editedAt;
	}

	public void setEditedAt(LocalDateTime editedAt) {
		this.editedAt = editedAt;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventDebriefing.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.List;

public class EventDebriefing {
	private int id;
	private int eventId;
	private int authorUserId;
	private LocalDateTime submittedAt;
	private String whatWentWell;
	private String whatToImprove;
	private String equipmentNotes;
	private String standoutCrewMembers; // Stored as JSON string of user IDs

	// Transient fields for display
	private String eventName;
	private String authorUsername;
	private List<User> standoutCrewDetails; // Populated in service/resource layer

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getAuthorUserId() {
		return authorUserId;
	}

	public void setAuthorUserId(int authorUserId) {
		this.authorUserId = authorUserId;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getWhatWentWell() {
		return whatWentWell;
	}

	public void setWhatWentWell(String whatWentWell) {
		this.whatWentWell = whatWentWell;
	}

	public String getWhatToImprove() {
		return whatToImprove;
	}

	public void setWhatToImprove(String whatToImprove) {
		this.whatToImprove = whatToImprove;
	}

	public String getEquipmentNotes() {
		return equipmentNotes;
	}

	public void setEquipmentNotes(String equipmentNotes) {
		this.equipmentNotes = equipmentNotes;
	}

	public String getStandoutCrewMembers() {
		return standoutCrewMembers;
	}

	public void setStandoutCrewMembers(String standoutCrewMembers) {
		this.standoutCrewMembers = standoutCrewMembers;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public String getAuthorUsername() {
		return authorUsername;
	}

	public void setAuthorUsername(String authorUsername) {
		this.authorUsername = authorUsername;
	}

	public List<User> getStandoutCrewDetails() {
		return standoutCrewDetails;
	}

	public void setStandoutCrewDetails(List<User> standoutCrewDetails) {
		this.standoutCrewDetails = standoutCrewDetails;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventRole.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class EventRole {
	private int id;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details;
	private String status;
	private String eventName;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers;
	private List<StorageItem> requiredItems;
	private List<InventoryKit> requiredKits;
	private List<EventTask> dependsOn; // Tasks that must be completed before this one
	private List<EventTask> dependencyFor; // Tasks that depend on this one

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}

	public List<EventTask> getDependsOn() {
		return dependsOn;
	}

	public void setDependsOn(List<EventTask> dependsOn) {
		this.dependsOn = dependsOn;
	}

	public List<EventTask> getDependencyFor() {
		return dependencyFor;
	}

	public void setDependencyFor(List<EventTask> dependencyFor) {
		this.dependencyFor = dependencyFor;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FeedbackSubmission.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single feedback submission from a user. Corresponds to the
 * `feedback_submissions` table.
 */
public class FeedbackSubmission {
	private int id;
	private int userId;
	private String username; 
	private String subject;
	private String displayTitle; 
	private String content;
	private LocalDateTime submittedAt;
	private String status;
	private int displayOrder;

	public String getFormattedSubmittedAt() {
		return DateFormatter.formatDateTime(this.submittedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public String getDisplayTitle() {
		return displayTitle;
	}

	public void setDisplayTitle(String displayTitle) {
		this.displayTitle = displayTitle;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;
	private String content;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\PasskeyCredential.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a WebAuthn/Passkey credential stored in the `user_passkeys` table.
 */
public class PasskeyCredential {
	private int id;
	private int userId;
	private String name;
	private String userHandle;
	private String credentialId;
	private String publicKey;
	private long signatureCount;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getUserHandle() {
		return userHandle;
	}

	public void setUserHandle(String userHandle) {
		this.userHandle = userHandle;
	}

	public String getCredentialId() {
		return credentialId;
	}

	public void setCredentialId(String credentialId) {
		this.credentialId = credentialId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public void setPublicKey(String publicKey) {
		this.publicKey = publicKey;
	}

	public long getSignatureCount() {
		return signatureCount;
	}

	public void setSignatureCount(long signatureCount) {
		this.signatureCount = signatureCount;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\ProfileChangeRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single request from a user to change their profile data.
 * Corresponds to the `profile_change_requests` table.
 */
public class ProfileChangeRequest {
	private int id;
	private int userId;
	private String username; 
	private String requestedChanges; 
	private String status;
	private LocalDateTime requestedAt;
	private Integer reviewedByAdminId;
	private String reviewedByAdminName; 
	private LocalDateTime reviewedAt;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRequestedChanges() {
		return requestedChanges;
	}

	public void setRequestedChanges(String requestedChanges) {
		this.requestedChanges = requestedChanges;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getRequestedAt() {
		return requestedAt;
	}

	public void setRequestedAt(LocalDateTime requestedAt) {
		this.requestedAt = requestedAt;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public String getReviewedByAdminName() {
		return reviewedByAdminName;
	}

	public void setReviewedByAdminName(String reviewedByAdminName) {
		this.reviewedByAdminName = reviewedByAdminName;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: src\main\java\de\technikteam\model\ScheduledNotification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class ScheduledNotification {
	private int id;
	private int targetUserId;
	private String notificationType;
	private int relatedEntityId;
	private LocalDateTime sendAt;
	private String title;
	private String description;
	private String url;
	private String status;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getTargetUserId() {
		return targetUserId;
	}

	public void setTargetUserId(int targetUserId) {
		this.targetUserId = targetUserId;
	}

	public String getNotificationType() {
		return notificationType;
	}

	public void setNotificationType(String notificationType) {
		this.notificationType = notificationType;
	}

	public int getRelatedEntityId() {
		return relatedEntityId;
	}

	public void setRelatedEntityId(int relatedEntityId) {
		this.relatedEntityId = relatedEntityId;
	}

	public LocalDateTime getSendAt() {
		return sendAt;
	}

	public void setSendAt(LocalDateTime sendAt) {
		this.sendAt = sendAt;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SearchResultDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) to represent a single, generic search result.
 * This is used to combine results from different database tables (events,
 * storage, etc.) into a unified list for the API response.
 */
public class SearchResultDTO {
	private String type; // e.g., "Veranstaltung", "Lagerartikel", "Dokumentation"
	private String title;
	private String url;
	private String snippet;

	public SearchResultDTO(String type, String title, String url, String snippet) {
		this.type = type;
		this.title = title;
		this.url = url;
		this.snippet = snippet;
	}

	// Getters and Setters
	public String getType() {
		return type;
	}

	public void setType(String type) {
		this.type = type;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
	}

	public String getUrl() {
		return url;
	}

	public void setUrl(String url) {
		this.url = url;
	}

	public String getSnippet() {
		return snippet;
	}

	public void setSnippet(String snippet) {
		this.snippet = snippet;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "Vergriffen";
		}
		if (maxQuantity == 0) {
			return "Auf Lager"; 
		}
		if (available >= maxQuantity) {
			return "Vollständig";
		}
		if ((double) available / maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		int available = getAvailableQuantity();
		if (available <= 0 && maxQuantity > 0) {
			return "status-danger";
		}
		if (maxQuantity > 0 && (double) available / maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoCategory.java
========================================================================

package de.technikteam.model;

import java.util.ArrayList;
import java.util.List;

public class TodoCategory {
	private int id;
	private String name;
	private int displayOrder;
	private List<TodoTask> tasks = new ArrayList<>();

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public List<TodoTask> getTasks() {
		return tasks;
	}

	public void setTasks(List<TodoTask> tasks) {
		this.tasks = tasks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\TodoTask.java
========================================================================

package de.technikteam.model;

public class TodoTask {
	private int id;
	private int categoryId;
	private String content;
	private boolean isCompleted;
	private int displayOrder;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public boolean isCompleted() {
		return isCompleted;
	}

	public void setCompleted(boolean completed) {
		isCompleted = completed;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;
	private String profileIconClass;
	private String adminNotes;
	private String dashboardLayout; // JSON string
	private String assignedEventRole; // Transient field for event details

	@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)
	private String passwordHash;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	public boolean hasAdminAccess() {
		// With granular permissions removed, admin access is determined solely by role.
		return "ADMIN".equals(this.roleName);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getProfileIconClass() {
		return profileIconClass;
	}

	public void setProfileIconClass(String profileIconClass) {
		this.profileIconClass = profileIconClass;
	}

	public String getAdminNotes() {
		return adminNotes;
	}

	public void setAdminNotes(String adminNotes) {
		this.adminNotes = adminNotes;
	}

	public String getDashboardLayout() {
		return dashboardLayout;
	}

	public void setDashboardLayout(String dashboardLayout) {
		this.dashboardLayout = dashboardLayout;
	}

	public String getAssignedEventRole() {
		return assignedEventRole;
	}

	public void setAssignedEventRole(String assignedEventRole) {
		this.assignedEventRole = assignedEventRole;
	}

	public String getPasswordHash() {
		return passwordHash;
	}

	public void setPasswordHash(String passwordHash) {
		this.passwordHash = passwordHash;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\Venue.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

public class Venue {
	private int id;
	private String name;
	private String address;
	private String notes;
	private String mapImagePath;
	private LocalDateTime createdAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public String getMapImagePath() {
		return mapImagePath;
	}

	public void setMapImagePath(String mapImagePath) {
		this.mapImagePath = mapImagePath;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\model\WikiEntry.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single documentation entry from the `wiki_documentation` table.
 */
public class WikiEntry {
	private int id;
	private String filePath;
	private String content;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilePath() {
		return filePath;
	}

	public void setFilePath(String filePath) {
		this.filePath = filePath;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\JwtAuthFilter.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.AuthService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;

@Component
public class JwtAuthFilter extends OncePerRequestFilter {

	private final AuthService authService;

	@Autowired
	public JwtAuthFilter(AuthService authService) {
		this.authService = authService;
	}

	@Override
	protected void doFilterInternal(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull FilterChain filterChain) throws ServletException, IOException {

		if (request.getCookies() == null) {
			filterChain.doFilter(request, response);
			return;
		}

		final String token = Arrays.stream(request.getCookies())
				.filter(cookie -> AuthService.AUTH_COOKIE_NAME.equals(cookie.getName())).map(Cookie::getValue)
				.findFirst().orElse(null);

		if (token == null) {
			filterChain.doFilter(request, response);
			return;
		}

		UserDetails userDetails = authService.validateTokenAndGetUser(token);

		if (userDetails != null && SecurityContextHolder.getContext().getAuthentication() == null) {
			UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(userDetails, null,
					userDetails.getAuthorities());
			authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
			SecurityContextHolder.getContext().setAuthentication(authToken);
		}

		filterChain.doFilter(request, response);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\RateLimitingInterceptor.java
========================================================================

package de.technikteam.security;

import de.technikteam.service.RateLimitingService;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import java.util.concurrent.TimeUnit;

@Component
public class RateLimitingInterceptor implements HandlerInterceptor {

	private final RateLimitingService rateLimitingService;

	@Autowired
	public RateLimitingInterceptor(RateLimitingService rateLimitingService) {
		this.rateLimitingService = rateLimitingService;
	}

	@Override
	public boolean preHandle(@NonNull HttpServletRequest request, @NonNull HttpServletResponse response,
			@NonNull Object handler) throws Exception {
		String ipAddress = getClientIp(request);
		Bucket bucket = rateLimitingService.resolveBucket(ipAddress);
		ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);

		if (probe.isConsumed()) {
			response.addHeader("X-Rate-Limit-Remaining", String.valueOf(probe.getRemainingTokens()));
			return true;
		} else {
			long waitForRefill = TimeUnit.NANOSECONDS.toSeconds(probe.getNanosToWaitForRefill());
			response.addHeader("X-Rate-Limit-Retry-After-Seconds", String.valueOf(waitForRefill));
			response.sendError(HttpStatus.TOO_MANY_REQUESTS.value(),
					"Sie haben Ihr API-Anfragekontingent ausgeschöpft. Bitte versuchen Sie es später erneut.");
			return false;
		}
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityConfig.java
========================================================================

package de.technikteam.security;

import de.technikteam.dao.UserDAO;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true, securedEnabled = true)
public class SecurityConfig {

	private final JwtAuthFilter jwtAuthFilter;
	private final UserDAO userDAO;

	public SecurityConfig(JwtAuthFilter jwtAuthFilter, UserDAO userDAO) {
		this.jwtAuthFilter = jwtAuthFilter;
		this.userDAO = userDAO;
	}

	@Bean
	public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
		CsrfTokenRequestAttributeHandler requestHandler = new CsrfTokenRequestAttributeHandler();
		requestHandler.setCsrfRequestAttributeName(null);

		http.csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
				.csrfTokenRequestHandler(requestHandler).ignoringRequestMatchers(
						// --- Authentication ---
						"/api/v1/auth/login", "/api/v1/auth/logout",

						// --- Public Actions ---
						"/api/v1/public/profile/**", "/api/v1/public/storage/**", "/api/v1/public/events/**",
						"/api/v1/public/meetings/**", "/api/v1/public/feedback/**", "/api/v1/public/chat/**",

						// --- Admin Actions ---
						"/api/v1/users/**", "/api/v1/requests/**", "/api/v1/events/**", "/api/v1/meetings/**",
						"/api/v1/courses/**", "/api/v1/storage/**", "/api/v1/kits/**", "/api/v1/matrix/**",
						"/api/v1/achievements/**", "/api/v1/feedback/**", "/api/v1/admin/**" // Broad rule for all other
																								// admin endpoints
				)).authorizeHttpRequests(auth -> auth.requestMatchers(
						// Public Authentication endpoints
						"/api/v1/auth/**", "/api/v1/admin/notifications/sse", // Explicitly permit
																				// SSE endpoint
						// Publicly accessible assets and docs
						"/api/v1/public/calendar.ics", "/api/v1/public/files/avatars/**", "/swagger-ui.html",
						"/swagger-ui/**", "/v3/api-docs/**").permitAll().requestMatchers("/api/v1/admin/**")
						.authenticated() // Secure all admin endpoints
						.anyRequest().authenticated())
				.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				.addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
				.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin())
						.httpStrictTransportSecurity(hsts -> hsts.includeSubDomains(true).maxAgeInSeconds(31536000))
						.contentSecurityPolicy(csp -> csp.policyDirectives(
								"default-src 'self'; script-src 'self'; style-src 'self' https://cdnjs.cloudflare.com; font-src 'self' https://cdnjs.cloudflare.com; object-src 'none'; base-uri 'self';")))
				.httpBasic(AbstractHttpConfigurer::disable).formLogin(AbstractHttpConfigurer::disable);

		return http.build();
	}

	@Bean
	public UserDetailsService userDetailsService() {
		return username -> {
			de.technikteam.model.User user = userDAO.getUserByUsername(username);
			if (user == null) {
				throw new UsernameNotFoundException("User not found: " + username);
			}
			return new SecurityUser(user);
		};
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\security\SecurityUser.java
========================================================================

package de.technikteam.security;

import de.technikteam.model.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.io.Serializable;
import java.util.Collection;
import java.util.stream.Collectors;

public class SecurityUser implements UserDetails, Serializable {

	private static final long serialVersionUID = 1L;
	private final User user;

	public SecurityUser(User user) {
		this.user = user;
	}

	public User getUser() {
		return user;
	}

	@Override
	public Collection<? extends GrantedAuthority> getAuthorities() {
		// Convert the user's permission strings into Spring Security GrantedAuthority
		// objects.
		return user.getPermissions().stream().map(SimpleGrantedAuthority::new).collect(Collectors.toSet());
	}

	@Override
	public String getPassword() {
		return user.getPasswordHash();
	}

	@Override
	public String getUsername() {
		return user.getUsername();
	}

	@Override
	public boolean isAccountNonExpired() {
		return true;
	}

	@Override
	public boolean isAccountNonLocked() {
		return true;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return true;
	}

	@Override
	public boolean isEnabled() {
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);

	private final AchievementDAO achievementDAO;
	private final EventDAO eventDAO;

	@Autowired
	public AchievementService(AchievementDAO achievementDAO, EventDAO eventDAO) {
		this.achievementDAO = achievementDAO;
		this.eventDAO = eventDAO;
	}

	@Transactional
	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// Placeholder for future implementation
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminDashboardService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.ReportDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.DashboardDataDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminDashboardService {
	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final AdminLogDAO adminLogDAO;
	private final ReportDAO reportDAO;

	private static final int WIDGET_LIMIT = 5;
	private static final int TREND_MONTHS = 12;

	@Autowired
	public AdminDashboardService(EventDAO eventDAO, StorageDAO storageDAO, AdminLogDAO adminLogDAO,
			ReportDAO reportDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.adminLogDAO = adminLogDAO;
		this.reportDAO = reportDAO;
	}

	public DashboardDataDTO getDashboardData() {
		DashboardDataDTO dto = new DashboardDataDTO();
		dto.setUpcomingEvents(eventDAO.getUpcomingEvents(WIDGET_LIMIT));
		dto.setLowStockItems(storageDAO.getLowStockItems(WIDGET_LIMIT));
		dto.setRecentLogs(adminLogDAO.getRecentLogs(WIDGET_LIMIT));
		dto.setEventTrendData(reportDAO.getEventCountByMonth(TREND_MONTHS));
		return dto;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private final AdminLogDAO logDAO;

	@Autowired
	public AdminLogService(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	private String sanitize(String input) {
		if (input == null) {
			return "";
		}
		// Replace newlines and carriage returns to prevent log injection
		return input.replace('\n', '_').replace('\r', '_');
	}

	public void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);
			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);
			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error(
					"KRITISCH: Fehler beim Schreiben in das Admin-Audit-Log! Daten: [Benutzer: {}, Aktion: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\AuthService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Date;

@Service
public class AuthService {
	private static final Logger logger = LogManager.getLogger(AuthService.class);
	private static final String JWT_ISSUER = "TechnikTeamApp";
	public static final String AUTH_COOKIE_NAME = "TT_AUTH_TOKEN";
	private static final int COOKIE_MAX_AGE_SECONDS = 8 * 60 * 60; // 8 hours

	private final SecretKey secretKey;
	private final UserDAO userDAO;

	@Autowired
	public AuthService(UserDAO userDAO, ConfigurationService configService) {
		this.userDAO = userDAO;
		// TODO: SECURITY-AUDIT-FIX (CWE-547)
		// Loading secrets from properties files committed to version control is
		// insecure.
		// REMEDIATION: Refactor to read the JWT secret from an environment variable
		// (e.g., System.getenv("JWT_SECRET")) or a dedicated secrets management
		// service.
		String secret = configService.getProperty("jwt.secret");
		if (secret == null || secret.isBlank() || secret.length() < 32) {
			logger.fatal(
					"JWT-Secret ist nicht konfiguriert oder zu kurz (muss mindestens 32 Zeichen lang sein). Die Anwendung kann nicht sicher gestartet werden.");
			throw new RuntimeException("JWT-Secret ist nicht konfiguriert oder unsicher.");
		}
		this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));
	}

	public String generateToken(User user) {
		Instant now = Instant.now();
		Instant expiry = now.plus(COOKIE_MAX_AGE_SECONDS, ChronoUnit.SECONDS);

		return Jwts.builder().issuer(JWT_ISSUER).subject(String.valueOf(user.getId())).issuedAt(Date.from(now))
				.expiration(Date.from(expiry)).signWith(secretKey).compact();
	}

	public void addJwtCookie(User user, HttpServletResponse response) {
		String token = generateToken(user);
		String header = String.format("%s=%s; Path=/; Max-Age=%d; HttpOnly; Secure; SameSite=Strict", AUTH_COOKIE_NAME,
				token, COOKIE_MAX_AGE_SECONDS);
		response.addHeader(HttpHeaders.SET_COOKIE, header);
	}

	public void clearJwtCookie(HttpServletResponse response) {
		// Construct a Set-Cookie header that expires the cookie immediately.
		// It's crucial to include the same attributes (Path, HttpOnly, Secure,
		// SameSite) as
		// the original cookie to ensure the browser overwrites it correctly.
		String header = String.format("%s=; Path=/; Max-Age=0; HttpOnly; Secure; SameSite=Strict", AUTH_COOKIE_NAME);
		response.addHeader(HttpHeaders.SET_COOKIE, header);
	}

	public UserDetails validateTokenAndGetUser(String token) {
		try {
			Claims claims = Jwts.parser().verifyWith(secretKey).build().parseSignedClaims(token).getPayload();

			int userId = Integer.parseInt(claims.getSubject());
			User user = userDAO.getUserById(userId);

			if (user == null) {
				logger.warn("JWT-Validierung erfolgreich, aber Benutzer mit ID {} existiert nicht mehr.", userId);
				return null;
			}
			return new SecurityUser(user);
		} catch (Exception e) {
			logger.warn("JWT-Verifizierung fehlgeschlagen: {}", e.getMessage());
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ConfigurationService.java
========================================================================

package de.technikteam.service;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

@Service
public class ConfigurationService {
	private static final Logger logger = LogManager.getLogger(ConfigurationService.class);

	@Value("${server.servlet.context-path:#{''}}")
	private String contextPath;

	@Value("${spring.datasource.url}")
	private String dbUrl;

	@Value("${spring.datasource.username}")
	private String dbUser;

	@Value("${spring.datasource.password}")
	private String dbPassword;

	@Value("${jwt.secret}")
	private String jwtSecret;

	@Value("${upload.directory}")
	private String uploadDirectory;

	public String getProperty(String key) {
		switch (key) {
		case "context.path":
			return contextPath;
		case "db.url":
			return dbUrl;
		case "db.user":
			return dbUser;
		case "db.password":
			return dbPassword;
		case "jwt.secret":
			return jwtSecret;
		case "upload.directory":
			return uploadDirectory;
		default:
			logger.warn("Attempted to access unknown property key: {}", key);
			return null;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventDebriefingService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.EventDebriefingDTO;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventDebriefingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventDebriefing;
import de.technikteam.model.User;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
public class EventDebriefingService {

	private final EventDebriefingDAO debriefingDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final PolicyFactory richTextPolicy;
	private final Gson gson = new Gson();

	@Autowired
	public EventDebriefingService(EventDebriefingDAO debriefingDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.debriefingDAO = debriefingDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public EventDebriefing saveDebriefing(int eventId, EventDebriefingDTO dto, User author) {
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			throw new IllegalArgumentException("Event not found.");
		}
		if (!"ABGESCHLOSSEN".equals(event.getStatus())) {
			throw new IllegalStateException("Debriefings can only be submitted for completed events.");
		}

		EventDebriefing debriefing = debriefingDAO.findByEventId(eventId).orElse(new EventDebriefing());
		debriefing.setEventId(eventId);
		debriefing.setAuthorUserId(author.getId());
		debriefing.setWhatWentWell(richTextPolicy.sanitize(dto.whatWentWell()));
		debriefing.setWhatToImprove(richTextPolicy.sanitize(dto.whatToImprove()));
		debriefing.setEquipmentNotes(richTextPolicy.sanitize(dto.equipmentNotes()));
		debriefing.setStandoutCrewMembers(gson.toJson(dto.standoutCrewMemberIds()));

		EventDebriefing savedDebriefing = debriefingDAO.save(debriefing);
		adminLogService.log(author.getUsername(), "SUBMIT_DEBRIEFING",
				"Debriefing for event '" + event.getName() + "' submitted/updated.");

		// Placeholder for achievement logic based on being a "standout crew member"
		// for (Integer userId : dto.standoutCrewMemberIds()) { ... }

		// Notify admins with permission that a new debriefing is available
		List<Integer> adminIds = userDAO.findUserIdsByPermission(Permissions.EVENT_DEBRIEFING_VIEW);
		String title = "Neues Event-Debriefing";
		String description = String.format("Ein Debriefing für das Event '%s' wurde von %s eingereicht.",
				event.getName(), author.getUsername());
		for (Integer adminId : adminIds) {
			if (adminId != author.getId()) { // Don't notify the author
				Map<String, Object> payload = Map.of("title", title, "description", description, "level",
						"Informational", "url", "/admin/debriefings");
				notificationService.sendNotificationToUser(adminId, payload);
			}
		}
		return enrichDebriefing(savedDebriefing);
	}

	public EventDebriefing enrichDebriefing(EventDebriefing debriefing) {
		if (debriefing == null)
			return null;
		if (debriefing.getStandoutCrewMembers() != null && !debriefing.getStandoutCrewMembers().isBlank()) {
			List<Integer> userIds = gson.fromJson(debriefing.getStandoutCrewMembers(), List.class);
			List<User> userDetails = userIds.stream().map(id -> userDAO.getUserById(id.intValue()))
					.filter(java.util.Objects::nonNull).collect(Collectors.toList());
			debriefing.setStandoutCrewDetails(userDetails);
		}
		return debriefing;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import de.technikteam.dao.*;
import de.technikteam.model.*;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
public class EventService {
	private static final Logger logger = LogManager.getLogger(EventService.class);

	private final EventDAO eventDAO;
	private final EventTaskDAO taskDAO;
	private final MeetingDAO meetingDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final ChecklistDAO checklistDAO;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ScheduledNotificationDAO scheduledNotificationDAO;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public EventService(EventDAO eventDAO, EventTaskDAO taskDAO, MeetingDAO meetingDAO, AttachmentDAO attachmentDAO,
			EventCustomFieldDAO customFieldDAO, ChecklistDAO checklistDAO, ConfigurationService configService,
			AdminLogService adminLogService, NotificationService notificationService,
			ScheduledNotificationDAO scheduledNotificationDAO,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.eventDAO = eventDAO;
		this.taskDAO = taskDAO;
		this.meetingDAO = meetingDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.checklistDAO = checklistDAO;
		this.configService = configService;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.scheduledNotificationDAO = scheduledNotificationDAO;
		this.richTextPolicy = richTextPolicy;
	}

	@Transactional
	public int createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, String[] requiredCourseIds,
			String[] requiredPersons, String[] itemIds, String[] quantities, List<EventCustomField> customFields,
			MultipartFile file, String requiredRole, int reminderMinutes) throws SQLException, IOException {

		// Sanitize HTML content before saving
		if (event.getDescription() != null) {
			String sanitizedDescription = richTextPolicy.sanitize(event.getDescription());
			event.setDescription(sanitizedDescription);
		}

		int eventId;
		if (isUpdate) {
			eventDAO.updateEvent(event);
			eventId = event.getId();
			adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
		} else {
			eventId = eventDAO.createEvent(event);
			event.setId(eventId);
			adminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
					"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
		}

		eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);
		eventDAO.saveReservations(eventId, itemIds, quantities);
		checklistDAO.generateChecklistFromReservations(eventId); // Generate/update checklist
		if (customFields != null) {
			customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
		}

		if (file != null && !file.isEmpty()) {
			handleAttachmentUpload(file, eventId, requiredRole, adminUser);
		}

		// Handle scheduled reminder
		List<Integer> participantIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
				.collect(Collectors.toList());
		LocalDateTime sendAt = reminderMinutes > 0 ? event.getEventDateTime().minusMinutes(reminderMinutes) : null;
		if (sendAt != null && sendAt.isAfter(LocalDateTime.now())) {
			scheduledNotificationDAO.createOrUpdateReminder("EVENT_REMINDER", eventId, participantIds, sendAt,
					"Erinnerung: " + event.getName(), "Diese Veranstaltung beginnt bald.",
					"/veranstaltungen/details/" + eventId);
		} else {
			// Delete existing reminder if it's no longer needed
			scheduledNotificationDAO.deleteReminders("EVENT_REMINDER", eventId);
		}

		logger.info("Transaction for event ID {} committed successfully.", eventId);
		return eventId;
	}

	public void assignUsersToEventAndNotify(int eventId, String[] userIds, User adminUser) {
		eventDAO.assignUsersToEvent(eventId, userIds);
		Event event = eventDAO.getEventById(eventId);
		String logDetails = String.format("Benutzer %s zu Event '%s' zugewiesen.", Arrays.toString(userIds),
				event.getName());
		adminLogService.log(adminUser.getUsername(), "ASSIGN_USERS_EVENT", logDetails);

		for (String userIdStr : userIds) {
			int userId = Integer.parseInt(userIdStr);
			String notificationMessage = String.format("Du wurdest zum Event '%s' zugewiesen.", event.getName());
			Map<String, Object> payload = Map.of("type", "assignment", "title", "Neue Zuweisung", "description",
					notificationMessage, "level", "Important", "url", "/veranstaltungen/details/" + eventId);
			notificationService.sendNotificationToUser(userId, payload);
		}
	}

	public void signOffUserFromRunningEvent(int userId, String username, int eventId, String reason) {
		eventDAO.signOffFromEvent(userId, eventId);
		Event event = eventDAO.getEventById(eventId);
		if (event != null && event.getLeaderUserId() > 0) {
			String notificationMessage = String.format("%s hat sich vom laufenden Event '%s' abgemeldet. Grund: %s",
					username, event.getName(), reason);

			Map<String, Object> payload = Map.of("type", "alert", "payload",
					Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + eventId));

			notificationService.sendNotificationToUser(event.getLeaderUserId(), payload);
			logger.info("Sent sign-off notification to event leader (ID: {}) for event '{}'", event.getLeaderUserId(),
					event.getName());
		}
	}

	@Transactional
	public Event cloneEvent(int originalEventId, User adminUser) {
		Event originalEvent = eventDAO.getEventById(originalEventId);
		if (originalEvent == null) {
			throw new IllegalArgumentException("Original event not found.");
		}

		// Create a copy with a new name and future date
		Event clonedEvent = new Event();
		clonedEvent.setName(originalEvent.getName() + " (Kopie)");
		clonedEvent.setDescription(originalEvent.getDescription());
		clonedEvent.setLocation(originalEvent.getLocation());
		clonedEvent.setLeaderUserId(originalEvent.getLeaderUserId());
		clonedEvent.setEventDateTime(LocalDateTime.now().plus(7, ChronoUnit.DAYS).withHour(18).withMinute(0));

		int newEventId = eventDAO.createEvent(clonedEvent);
		clonedEvent.setId(newEventId);

		// Copy skill requirements
		List<SkillRequirement> skills = eventDAO.getSkillRequirementsForEvent(originalEventId);
		String[] courseIds = skills.stream().map(s -> String.valueOf(s.getRequiredCourseId())).toArray(String[]::new);
		String[] persons = skills.stream().map(s -> String.valueOf(s.getRequiredPersons())).toArray(String[]::new);
		eventDAO.saveSkillRequirements(newEventId, courseIds, persons);

		// Copy item reservations
		List<StorageItem> items = eventDAO.getReservedItemsForEvent(originalEventId);
		String[] itemIds = items.stream().map(i -> String.valueOf(i.getId())).toArray(String[]::new);
		String[] quantities = items.stream().map(i -> String.valueOf(i.getQuantity())).toArray(String[]::new);
		eventDAO.saveReservations(newEventId, itemIds, quantities);
		checklistDAO.generateChecklistFromReservations(newEventId);

		// Copy tasks (without assignments)
		List<EventTask> tasks = taskDAO.getTasksForEvent(originalEventId);
		for (EventTask task : tasks) {
			task.setEventId(newEventId);
			task.setStatus("OFFEN");
			taskDAO.saveTask(task, new int[0], new String[0], new String[0], new String[0], new int[0]);
		}

		adminLogService.log(adminUser.getUsername(), "CLONE_EVENT", "Event '" + originalEvent.getName() + "' (ID: "
				+ originalEventId + ") zu '" + clonedEvent.getName() + "' (ID: " + newEventId + ") geklont.");

		return clonedEvent;
	}

	@Transactional
	public Meeting cloneMeeting(int originalMeetingId, User adminUser) {
		Meeting originalMeeting = meetingDAO.getMeetingById(originalMeetingId);
		if (originalMeeting == null) {
			throw new IllegalArgumentException("Original meeting not found.");
		}

		Meeting clonedMeeting = new Meeting();
		clonedMeeting.setCourseId(originalMeeting.getCourseId());
		clonedMeeting.setName(originalMeeting.getName() + " (Kopie)");
		clonedMeeting.setDescription(originalMeeting.getDescription());
		clonedMeeting.setLocation(originalMeeting.getLocation());
		clonedMeeting.setLeaderUserId(originalMeeting.getLeaderUserId());
		clonedMeeting.setMeetingDateTime(LocalDateTime.now().plus(7, ChronoUnit.DAYS).withHour(19).withMinute(0));

		int newMeetingId = meetingDAO.createMeeting(clonedMeeting);
		clonedMeeting.setId(newMeetingId);

		adminLogService.log(adminUser.getUsername(), "CLONE_MEETING",
				"Meeting '" + originalMeeting.getName() + "' (ID: " + originalMeetingId + ") zu '"
						+ clonedMeeting.getName() + "' (ID: " + newMeetingId + ") geklont.");

		return clonedMeeting;
	}

	private void handleAttachmentUpload(MultipartFile file, int eventId, String requiredRole, User adminUser)
			throws IOException {
		String uploadDir = configService.getProperty("upload.directory");
		String originalFileName = Paths.get(file.getOriginalFilename()).getFileName().toString();
		String uniqueFileName = UUID.randomUUID() + "-" + originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");

		Path targetPath = Paths.get(uploadDir, "events", uniqueFileName);
		Files.createDirectories(targetPath.getParent());
		Files.copy(file.getInputStream(), targetPath);

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(originalFileName);
		attachment.setFilepath("events/" + uniqueFileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			adminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + originalFileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Fehler beim Speichern des Anhangs in der Datenbank.");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\EventTaskService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class EventTaskService {

	private final EventTaskDAO taskDAO;
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final NotificationService notificationService;

	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	@Autowired
	public EventTaskService(EventTaskDAO taskDAO, UserDAO userDAO, EventDAO eventDAO,
			NotificationService notificationService) {
		this.taskDAO = taskDAO;
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.notificationService = notificationService;
	}

	@Transactional
	public int saveTaskAndHandleMentions(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities,
			String[] kitIds, int[] dependencyIds, User currentUser) {
		String originalDetails = "";
		if (task.getId() > 0) {
			// This is not perfectly efficient, but good enough for this purpose.
			// A better solution would be to get the task from a service layer cache.
			EventTask existingTask = taskDAO.getTasksForEvent(task.getEventId()).stream()
					.filter(t -> t.getId() == task.getId()).findFirst().orElse(null);
			if (existingTask != null) {
				originalDetails = existingTask.getDetails();
			}
		}

		int taskId = taskDAO.saveTask(task, userIds, itemIds, itemQuantities, kitIds, dependencyIds);

		// Handle mentions only if the details have changed
		if (task.getDetails() != null && !task.getDetails().equals(originalDetails)) {
			handleMentions(currentUser, task);
		}

		return taskId;
	}

	private void handleMentions(User currentUser, EventTask task) {
		Event event = eventDAO.getEventById(task.getEventId());
		if (event == null || task.getDetails() == null)
			return;

		Set<String> mentionedUsernames = new HashSet<>();
		Matcher matcher = MENTION_PATTERN.matcher(task.getDetails());
		while (matcher.find()) {
			mentionedUsernames.add(matcher.group(1));
		}

		for (String username : mentionedUsernames) {
			User mentionedUser = userDAO.getUserByUsername(username);
			if (mentionedUser != null && mentionedUser.getId() != currentUser.getId()) {
				String title = String.format("Erwähnung in Aufgabe für '%s'", event.getName());
				String description = String.format("%s hat Sie in der Aufgabe '%s' erwähnt.", currentUser.getUsername(),
						task.getDescription());

				Map<String, Object> payload = Map.of("title", title, "description", description, "level",
						"Informational", "url", "/veranstaltungen/details/" + event.getId());
				notificationService.sendNotificationToUser(mentionedUser.getId(), payload);
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\FileService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.util.FileSignatureValidator;
import org.apache.commons.io.FilenameUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.UUID;

@Service
public class FileService {

	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;
	private final Path fileStorageLocation;

	private static final long MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10 MB

	@Autowired
	public FileService(FileDAO fileDAO, ConfigurationService configService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser) throws IOException {
		return storeFile(multipartFile, categoryId, requiredRole, adminUser, "docs");
	}

	public de.technikteam.model.File storeFile(MultipartFile multipartFile, Integer categoryId, String requiredRole,
			User adminUser, String subDirectory) throws IOException {

		// Security Validations
		if (multipartFile.getSize() > MAX_FILE_SIZE_BYTES) {
			throw new IOException("Dateigröße überschreitet das Limit von 10MB.");
		}
		if (!FileSignatureValidator.isFileTypeAllowed(multipartFile)) {
			throw new IOException("Ungültiger oder gefälschter Dateityp erkannt.");
		}

		String originalFileName = FilenameUtils.getName(multipartFile.getOriginalFilename());
		String sanitizedFileName = originalFileName.replaceAll("[^a-zA-Z0-9.\\-_]", "_");
		String uniqueFileName = UUID.randomUUID() + "-" + sanitizedFileName;

		Path targetDirectory = this.fileStorageLocation.resolve(subDirectory);
		Path targetPath = targetDirectory.resolve(uniqueFileName);
		Files.createDirectories(targetDirectory);
		Files.copy(multipartFile.getInputStream(), targetPath);

		de.technikteam.model.File file = new de.technikteam.model.File();
		file.setFilename(originalFileName);
		file.setFilepath(subDirectory + "/" + uniqueFileName);
		file.setCategoryId(categoryId != null ? categoryId : 0);
		file.setRequiredRole(requiredRole);

		int newFileId = fileDAO.createFile(file);
		if (newFileId > 0) {
			adminLogService.log(adminUser.getUsername(), "UPLOAD_FILE",
					"Datei '" + originalFileName + "' hochgeladen.");
			return fileDAO.getFileById(newFileId);
		} else {
			Files.deleteIfExists(targetPath);
			throw new RuntimeException("Fehler beim Speichern der Datei-Metadaten in der Datenbank.");
		}
	}

	public boolean deleteFile(int fileId, User adminUser) throws IOException {
		de.technikteam.model.File file = fileDAO.getFileById(fileId);
		if (file == null) {
			return false;
		}

		boolean success = fileDAO.deleteFile(fileId);
		if (success) {
			Path filePath = this.fileStorageLocation.resolve(file.getFilepath()).normalize();
			Files.deleteIfExists(filePath);
			adminLogService.log(adminUser.getUsername(), "DELETE_FILE",
					"Datei '" + file.getFilename() + "' (ID: " + fileId + ") gelöscht.");
		}
		return success;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\LoginAttemptService.java
========================================================================

package de.technikteam.service;

// TODO: SECURITY-AUDIT-FIX (CWE-307)
// The current lockout mechanism is based solely on username, which makes it vulnerable
// to targeted Denial of Service attacks where an attacker can lock out any known user.
// REMEDIATION: This service should be refactored to be primarily IP-based.
// 1. A database migration is required to change the login_attempts table to track failures by IP address.
// 2. The logic in isLockedOut() and recordFailedLogin() must be updated to use the client's IP address
//    as the key for tracking and enforcing lockouts.

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.sql.Timestamp;
import java.time.LocalDateTime;

@Service
public class LoginAttemptService {
	private static final Logger logger = LogManager.getLogger(LoginAttemptService.class);
	private static final int MAX_ATTEMPTS = 5;
	private static final int LOCKOUT_MINUTES = 30;

	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public LoginAttemptService(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public boolean isLockedOut(String username, String ipAddress) {
		String sql = "SELECT last_attempt, attempts FROM login_attempts WHERE username = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				LocalDateTime lastAttempt = rs.getTimestamp("last_attempt").toLocalDateTime();
				int attempts = rs.getInt("attempts");
				if (attempts >= MAX_ATTEMPTS
						&& lastAttempt.isAfter(LocalDateTime.now().minusMinutes(LOCKOUT_MINUTES))) {
					return true;
				}
				// If lockout period expired, clear attempts and allow login
				clearLoginAttempts(username);
				return false;
			}, username);
		} catch (Exception e) {
			return false; // No record means not locked out
		}
	}

	public void recordFailedLogin(String username, String ipAddress) {
		String sql = "INSERT INTO login_attempts (username, attempts, last_attempt) VALUES (?, 1, ?) "
				+ "ON DUPLICATE KEY UPDATE attempts = attempts + 1, last_attempt = ?";
		Timestamp now = Timestamp.valueOf(LocalDateTime.now());
		jdbcTemplate.update(sql, username, now, now);

		String checkSql = "SELECT attempts FROM login_attempts WHERE username = ?";
		try {
			Integer currentAttempts = jdbcTemplate.queryForObject(checkSql, Integer.class, username);
			if (currentAttempts != null && currentAttempts >= MAX_ATTEMPTS) {
				logger.warn("Locking out user '{}' (from IP {}) due to {} failed login attempts.", username, ipAddress,
						currentAttempts);
			}
		} catch (Exception e) {
			logger.error("Could not check login attempts for user '{}' after failed login.", username, e);
		}
	}

	public void clearLoginAttempts(String username) {
		String sql = "DELETE FROM login_attempts WHERE username = ?";
		jdbcTemplate.update(sql, username);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationScheduler.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.ScheduledNotificationDAO;
import de.technikteam.model.ScheduledNotification;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
@EnableScheduling
public class NotificationScheduler {

	private static final Logger logger = LogManager.getLogger(NotificationScheduler.class);

	private final ScheduledNotificationDAO notificationDAO;
	private final NotificationService notificationService;

	@Autowired
	public NotificationScheduler(ScheduledNotificationDAO notificationDAO, NotificationService notificationService) {
		this.notificationDAO = notificationDAO;
		this.notificationService = notificationService;
	}

	@Scheduled(fixedRate = 60000) // Run every 60 seconds
	public void sendPendingNotifications() {
		logger.debug("Running scheduled notification task...");
		List<ScheduledNotification> pending = notificationDAO.findPendingNotifications();

		if (pending.isEmpty()) {
			logger.debug("No pending notifications to send.");
			return;
		}

		logger.info("Found {} pending notifications to send.", pending.size());
		for (ScheduledNotification notification : pending) {
			Map<String, Object> payload = Map.of("title", notification.getTitle(), "description",
					notification.getDescription(), "level", "Important", // Reminders are always important
					"url", notification.getUrl());
			notificationService.sendNotificationToUser(notification.getTargetUserId(), payload);
		}

		List<Integer> sentIds = pending.stream().map(ScheduledNotification::getId).collect(Collectors.toList());
		notificationDAO.markAsSent(sentIds);
		logger.info("Successfully sent and marked {} notifications.", sentIds.size());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.api.v1.dto.NotificationRequest;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

@Service
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);

	private final Map<Integer, List<SseEmitter>> emittersByUser = new ConcurrentHashMap<>();
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;

	public NotificationService(UserDAO userDAO, EventDAO eventDAO, MeetingDAO meetingDAO,
			AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	public SseEmitter register(User user) {
		if (user == null) {
			logger.warn("Versuch, Benachrichtigungen für eine nicht authentifizierte Sitzung zu registrieren.");
			return null;
		}

		// Timeout set to a very long value. The connection will be kept alive by
		// heartbeats.
		SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		int userId = user.getId();

		emitter.onCompletion(() -> {
			logger.info("SSE Emitter für Benutzer {} beendet.", userId);
			removeEmitter(userId, emitter);
		});
		emitter.onTimeout(() -> {
			logger.warn("SSE Emitter für Benutzer {} hat Zeitüberschreitung.", userId);
			emitter.complete();
		});
		emitter.onError(e -> {
			logger.error("SSE Emitter Fehler für Benutzer {}: {}", userId, e.getMessage());
			emitter.complete();
		});

		emittersByUser.computeIfAbsent(userId, k -> new CopyOnWriteArrayList<>()).add(emitter);

		logger.info(
				"Neuer Client für SSE-Benachrichtigungen für Benutzer-ID {} registriert. Gesamtzahl der Clients für Benutzer: {}",
				userId, emittersByUser.get(userId).size());

		// Send a confirmation event
		try {
			emitter.send(SseEmitter.event().name("connected").data("Verbindung hergestellt"));
		} catch (IOException e) {
			logger.error("Fehler beim Senden der Verbindungsbestätigung an Benutzer {}", userId, e);
			emitter.complete();
		}

		return emitter;
	}

	public void broadcastUIUpdate(String type, Object payload) {
		logger.info("Sende UI-Update vom Typ '{}' an alle Clients.", type);
		Map<String, Object> message = Map.of("updateType", type, "data", payload);
		SseEmitter.SseEventBuilder event = SseEmitter.event().name("ui_update").data(message);

		emittersByUser.values().forEach(emitterList -> emitterList.forEach(emitter -> {
			try {
				emitter.send(event);
			} catch (IOException e) {
				logger.warn("Fehler beim Senden an einen Client (wahrscheinlich getrennt), wird entfernt. Fehler: {}",
						e.getMessage());
				emitter.complete();
			}
		}));
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null && !userEmitters.isEmpty()) {
			SseEmitter.SseEventBuilder event = SseEmitter.event().name("notification").data(payload);
			logger.info("Sende gezielte Benachrichtigung an Benutzer-ID {}: {}", userId, payload);

			userEmitters.forEach(emitter -> {
				try {
					emitter.send(event);
				} catch (IOException e) {
					logger.warn(
							"Fehler beim Senden der gezielten Benachrichtigung an Benutzer {} (Client wahrscheinlich getrennt), wird entfernt. Fehler: {}",
							userId, e.getMessage());
					emitter.complete();
				}
			});
		} else {
			logger.debug("Keine aktiven SSE-Clients für Benutzer-ID {} gefunden, um Benachrichtigung zu senden.",
					userId);
		}
	}

	public int sendBroadcastNotification(NotificationRequest request, User adminUser) {
		List<User> targetUsers;
		String targetDescription;

		switch (request.targetType()) {
		case "ALL":
			targetUsers = userDAO.getAllUsers();
			targetDescription = "alle Benutzer";
			break;
		case "EVENT":
			if (request.targetId() == null)
				throw new IllegalArgumentException("Event-ID ist erforderlich.");
			targetUsers = eventDAO.getAssignedUsersForEvent(request.targetId());
			targetDescription = "Teilnehmer des Events ID " + request.targetId();
			break;
		case "MEETING":
			if (request.targetId() == null)
				throw new IllegalArgumentException("Meeting-ID ist erforderlich.");
			targetUsers = meetingDAO.getParticipantUsersForMeeting(request.targetId());
			targetDescription = "Teilnehmer des Meetings ID " + request.targetId();
			break;
		default:
			throw new IllegalArgumentException("Ungültiger Zieltyp: " + request.targetType());
		}

		if (targetUsers.isEmpty()) {
			logger.warn("Keine Empfänger für die Benachrichtigung gefunden (Ziel: {}).", targetDescription);
			return 0;
		}

		Map<String, Object> payload = Map.of("title", request.title(), "description", request.description(), "level",
				request.level());

		for (User targetUser : targetUsers) {
			sendNotificationToUser(targetUser.getId(), payload);
		}

		String logDetails = String.format("Benachrichtigung gesendet an '%s'. Titel: %s, Stufe: %s", targetDescription,
				request.title(), request.level());
		adminLogService.log(adminUser.getUsername(), "SEND_NOTIFICATION", logDetails);

		return targetUsers.size();
	}

	private void removeEmitter(int userId, SseEmitter emitter) {
		List<SseEmitter> userEmitters = emittersByUser.get(userId);
		if (userEmitters != null) {
			userEmitters.remove(emitter);
			if (userEmitters.isEmpty()) {
				emittersByUser.remove(userId);
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\ProfileRequestService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Service
public class ProfileRequestService {
	private static final Logger logger = LogManager.getLogger(ProfileRequestService.class);

	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;

	@Autowired
	public ProfileRequestService(ProfileChangeRequestDAO requestDAO, UserDAO userDAO, AdminLogService adminLogService,
			NotificationService notificationService) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
	}

	@Transactional
	public void createChangeRequest(User currentUser, ProfileChangeRequestDTO requestDTO) throws IOException {
		Map<String, String> changes = new HashMap<>();
		if (requestDTO.email() != null && !Objects.equals(currentUser.getEmail(), requestDTO.email())) {
			changes.put("email", requestDTO.email());
		}
		if (requestDTO.classYear() != null && currentUser.getClassYear() != requestDTO.classYear()) {
			changes.put("classYear", String.valueOf(requestDTO.classYear()));
		}
		if (requestDTO.className() != null && !Objects.equals(currentUser.getClassName(), requestDTO.className())) {
			changes.put("className", requestDTO.className());
		}
		if (requestDTO.profileIconClass() != null
				&& !Objects.equals(currentUser.getProfileIconClass(), requestDTO.profileIconClass())) {
			changes.put("profileIconClass", requestDTO.profileIconClass());
		}

		if (changes.isEmpty()) {
			return; // No changes to request
		}

		ProfileChangeRequest pcr = new ProfileChangeRequest();
		pcr.setUserId(currentUser.getId());
		pcr.setRequestedChanges(new Gson().toJson(changes));

		if (!requestDAO.createRequest(pcr)) {
			throw new IOException("Ihr Antrag konnte nicht in der Datenbank gespeichert werden.");
		}
	}

	@Transactional
	public boolean approveRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		User userToUpdate = userDAO.getUserById(pcr.getUserId());
		if (userToUpdate == null) {
			requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId());
			throw new IllegalStateException(
					"Der zugehörige Benutzer existiert nicht mehr. Der Antrag wurde abgelehnt.");
		}

		Type type = new TypeToken<Map<String, String>>() {
		}.getType();
		Map<String, String> changes = new Gson().fromJson(pcr.getRequestedChanges(), type);

		for (Map.Entry<String, String> entry : changes.entrySet()) {
			String field = entry.getKey();
			String value = entry.getValue();
			switch (field) {
			case "email":
				// Prevent unique constraint violation for empty strings
				userToUpdate.setEmail("".equals(value) ? null : value);
				break;
			case "classYear":
				userToUpdate.setClassYear(Integer.parseInt(value));
				break;
			case "className":
				userToUpdate.setClassName(value);
				break;
			case "profileIconClass":
				userToUpdate.setProfileIconClass(value);
				break;
			}
		}
		try {
			if (userDAO.updateUser(userToUpdate)
					&& requestDAO.updateRequestStatus(requestId, "APPROVED", adminUser.getId())) {
				adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_APPROVED_API", "Profile change for '"
						+ userToUpdate.getUsername() + "' (Request ID: " + requestId + ") approved via API.");

				String notificationMessage = "Your profile change has been approved.";
				Map<String, Object> payload = Map.of("type", "alert", "payload",
						Map.of("message", notificationMessage));
				notificationService.sendNotificationToUser(userToUpdate.getId(), payload);

				return true;
			}
		} catch (DuplicateKeyException e) {
			logger.warn("Failed to approve request {}: {}", requestId, e.getMessage());
			throw new IllegalStateException(
					"Die Genehmigung ist fehlgeschlagen, da die angeforderte E-Mail-Adresse bereits von einem anderen Konto verwendet wird.");
		}
		return false;
	}

	@Transactional
	public boolean denyRequest(int requestId, User adminUser) throws IOException {
		ProfileChangeRequest pcr = requestDAO.getRequestById(requestId);
		if (pcr == null || !"PENDING".equals(pcr.getStatus())) {
			throw new IllegalStateException("Antrag nicht gefunden oder bereits bearbeitet.");
		}

		if (requestDAO.updateRequestStatus(requestId, "DENIED", adminUser.getId())) {
			adminLogService.log(adminUser.getUsername(), "PROFILE_CHANGE_DENIED_API", "Profile change for user ID "
					+ pcr.getUserId() + " (Request ID: " + requestId + ") denied via API.");
			return true;
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\RateLimitingService.java
========================================================================

package de.technikteam.service;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class RateLimitingService {

	private final Map<String, Bucket> cache = new ConcurrentHashMap<>();

	public Bucket resolveBucket(String apiKey) {
		return cache.computeIfAbsent(apiKey, this::newBucket);
	}

	private Bucket newBucket(String apiKey) {
		// Example: 10 requests per minute
		Bandwidth limit = Bandwidth.simple(10, Duration.ofMinutes(1));
		return Bucket.builder().addLimit(limit).build();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SearchService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import de.technikteam.model.SearchResultDTO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Service
public class SearchService {

	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final MeetingDAO meetingDAO;
	private final WikiDAO wikiDAO;

	@Autowired
	public SearchService(EventDAO eventDAO, StorageDAO storageDAO, MeetingDAO meetingDAO, WikiDAO wikiDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.meetingDAO = meetingDAO;
		this.wikiDAO = wikiDAO;
	}

	public List<SearchResultDTO> performSearch(String query, User user) {
		// Since security is frontend-only, we don't need to filter results based on the
		// user object here.
		// In a secure app, we would pass the user to each DAO method.

		List<SearchResultDTO> eventResults = eventDAO.search(query).stream().map(this::mapEventToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> itemResults = storageDAO.search(query).stream().map(this::mapStorageItemToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> meetingResults = meetingDAO.search(query).stream().map(this::mapMeetingToSearchResult)
				.collect(Collectors.toList());

		List<SearchResultDTO> wikiResults = new ArrayList<>();
		// Only search wiki if user is an admin
		if (user != null && user.hasAdminAccess()) {
			wikiResults = wikiDAO.search(query).stream().map(this::mapWikiEntryToSearchResult)
					.collect(Collectors.toList());
		}

		return Stream.of(eventResults, itemResults, meetingResults, wikiResults).flatMap(List::stream)
				.collect(Collectors.toList());
	}

	private SearchResultDTO mapEventToSearchResult(Event event) {
		String url = "/veranstaltungen/details/" + event.getId();
		return new SearchResultDTO("Veranstaltung", event.getName(), url, event.getLocation());
	}

	private SearchResultDTO mapStorageItemToSearchResult(StorageItem item) {
		String url = "/lager/details/" + item.getId();
		return new SearchResultDTO("Lagerartikel", item.getName(), url, item.getLocation());
	}

	private SearchResultDTO mapMeetingToSearchResult(Meeting meeting) {
		String url = "/lehrgaenge/details/" + meeting.getId();
		String title = meeting.getParentCourseName() + ": " + meeting.getName();
		return new SearchResultDTO("Lehrgang", title, url, meeting.getLocation());
	}

	private SearchResultDTO mapWikiEntryToSearchResult(WikiEntry entry) {
		// Note: The Wiki is admin-only, so this URL will only work for admins.
		String url = "/admin/wiki"; // The wiki is a single page app, we can't link to a sub-page directly
		return new SearchResultDTO("Dokumentation", entry.getFilePath(), url, "Wiki-Eintrag");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\StorageService.java
========================================================================

package de.technikteam.service;

import de.technikteam.config.Permissions;
import de.technikteam.dao.*;
import de.technikteam.model.DamageReport;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class StorageService {

	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final DamageReportDAO damageReportDAO;
	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;

	@Autowired
	public StorageService(StorageDAO storageDAO, StorageLogDAO storageLogDAO, DamageReportDAO damageReportDAO,
			UserDAO userDAO, EventDAO eventDAO, AdminLogService adminLogService,
			NotificationService notificationService) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.damageReportDAO = damageReportDAO;
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
	}

	@Transactional
	public boolean processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null)
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");

		if ("checkout".equals(type)) {
			if (item.getAvailableQuantity() < quantity)
				throw new IllegalStateException("Nicht genügend Artikel zum Entnehmen verfügbar.");
			item.setQuantity(item.getQuantity() - quantity);
			item.setStatus("CHECKED_OUT");
			item.setCurrentHolderUserId(user.getId());
			item.setAssignedEventId(eventId != null ? eventId : 0);
		} else if ("checkin".equals(type)) {
			if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
				throw new IllegalStateException("Nicht genügend Platz, um diese Menge einzuräumen.");
			}
			item.setQuantity(item.getQuantity() + quantity);
			if (item.getQuantity() >= item.getMaxQuantity()) {
				item.setStatus("IN_STORAGE");
				item.setCurrentHolderUserId(0);
				item.setAssignedEventId(0);
			}
		} else {
			throw new IllegalArgumentException("Ungültiger Transaktionstyp: " + type);
		}

		storageDAO.updateItem(item);

		String finalNotes = notes;
		if ("checkout".equals(type) && eventId != null) {
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				String autoNote = "Für Event: " + event.getName();
				finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes : autoNote;
			}
		}
		int quantityChange = "checkin".equals(type) ? quantity : -quantity;
		storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes, eventId != null ? eventId : 0);

		String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
		String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, item.getName(), itemId, action,
				finalNotes);
		adminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

		return true;
	}

	@Transactional
	public boolean updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Artikel mit ID " + itemId + " nicht gefunden.");
		}

		String logDetails;

		if ("UNREPAIRABLE".equals(status)) {
			if (item.getQuantity() < quantity || item.getDefectiveQuantity() < quantity) {
				throw new IllegalStateException(
						"Es können nicht mehr Artikel als irreparabel markiert werden, als vorhanden oder defekt sind.");
			}
			item.setQuantity(item.getQuantity() - quantity);
			item.setDefectiveQuantity(item.getDefectiveQuantity() - quantity);
			item.setDefectReason(reason);
			logDetails = String.format("Permanently removed %d x '%s' (ID: %d) from stock (unrepairable). Reason: %s",
					quantity, item.getName(), itemId, reason);
			adminLogService.log(adminUser.getUsername(), "ITEM_UNREPAIRABLE", logDetails);
		} else {
			int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
			if (item.getQuantity() < newDefectiveTotal) {
				throw new IllegalStateException(
						"Die Gesamtzahl der defekten Artikel kann die Gesamtmenge nicht überschreiten.");
			}
			item.setDefectiveQuantity(newDefectiveTotal);
			item.setDefectReason(reason);
			logDetails = String.format("Defect status for '%s' (ID: %d) updated: %d defective. Reason: %s",
					item.getName(), itemId, newDefectiveTotal, reason);
			adminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS", logDetails);
		}

		storageDAO.updateItem(item);
		return true;
	}

	@Transactional
	public DamageReport createDamageReport(int itemId, int reporterId, String description) {
		StorageItem item = storageDAO.getItemById(itemId);
		if (item == null) {
			throw new IllegalArgumentException("Der zu meldende Artikel existiert nicht.");
		}
		DamageReport report = damageReportDAO.createReport(itemId, reporterId, description);

		// Notify admins
		List<Integer> adminIds = userDAO.findUserIdsByPermission(Permissions.DAMAGE_REPORT_MANAGE);
		User reporter = userDAO.getUserById(reporterId);
		String title = "Neue Schadensmeldung";
		String notificationDescription = String.format("%s hat einen Schaden für '%s' gemeldet.",
				reporter.getUsername(), item.getName());

		for (Integer adminId : adminIds) {
			Map<String, Object> payload = Map.of("title", title, "description", notificationDescription, "level",
					"Important", "url", "/admin/damage-reports");
			notificationService.sendNotificationToUser(adminId, payload);
		}

		return report;
	}

	@Transactional
	public void confirmDamageReport(int reportId, int quantity, User adminUser) {
		DamageReport report = damageReportDAO.getReportById(reportId)
				.orElseThrow(() -> new IllegalArgumentException("Bericht nicht gefunden."));

		if (!"PENDING".equals(report.getStatus())) {
			throw new IllegalStateException("Dieser Bericht wurde bereits bearbeitet.");
		}

		// Update the storage item
		StorageItem item = storageDAO.getItemById(report.getItemId());
		int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
		if (item.getQuantity() < newDefectiveTotal) {
			throw new IllegalStateException(
					"Die Gesamtzahl der defekten Artikel kann die Gesamtmenge nicht überschreiten.");
		}
		item.setDefectiveQuantity(newDefectiveTotal);
		if (item.getDefectReason() == null || item.getDefectReason().isBlank()) {
			item.setDefectReason(report.getReportDescription());
		} else {
			item.setDefectReason(item.getDefectReason() + " | Gemeldet: " + report.getReportDescription());
		}
		storageDAO.updateItem(item);

		// Update the report status
		damageReportDAO.updateStatus(reportId, "CONFIRMED", adminUser.getId(), "Bestätigt und als defekt verbucht.");

		// Log the admin action
		adminLogService.log(adminUser.getUsername(), "DAMAGE_REPORT_CONFIRMED",
				String.format("Schadensmeldung #%d für '%s' bestätigt.", reportId, item.getName()));
	}

	@Transactional
	public void rejectDamageReport(int reportId, String adminNotes, User adminUser) {
		DamageReport report = damageReportDAO.getReportById(reportId)
				.orElseThrow(() -> new IllegalArgumentException("Bericht nicht gefunden."));

		if (!"PENDING".equals(report.getStatus())) {
			throw new IllegalStateException("Dieser Bericht wurde bereits bearbeitet.");
		}

		damageReportDAO.updateStatus(reportId, "REJECTED", adminUser.getId(), adminNotes);

		adminLogService.log(adminUser.getUsername(), "DAMAGE_REPORT_REJECTED", String.format(
				"Schadensmeldung #%d für '%s' abgelehnt. Grund: %s", reportId, report.getItemName(), adminNotes));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

@Service
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getCpuLoad() * 100.0);

		long totalMemoryBytes = Runtime.getRuntime().totalMemory();
		long freeMemoryBytes = Runtime.getRuntime().freeMemory();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\TodoService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.TodoDAO;
import de.technikteam.model.TodoCategory;
import de.technikteam.model.TodoTask;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Map;

@Service
public class TodoService {
	private static final Logger logger = LogManager.getLogger(TodoService.class);
	private final TodoDAO todoDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public TodoService(TodoDAO todoDAO, AdminLogService adminLogService) {
		this.todoDAO = todoDAO;
		this.adminLogService = adminLogService;
	}

	public List<TodoCategory> getAllTodos() {
		return todoDAO.getAllCategoriesWithTasks();
	}

	@Transactional
	public TodoCategory createCategory(String name, User admin) {
		try {
			TodoCategory newCategory = todoDAO.createCategory(name);
			if (newCategory != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_CATEGORY",
						"To-Do Kategorie '" + name + "' erstellt.");
			}
			return newCategory;
		} catch (Exception e) {
			logger.error("Service error creating To-Do category '{}'", name, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public TodoTask createTask(int categoryId, String content, User admin) {
		try {
			TodoTask newTask = todoDAO.createTask(categoryId, content);
			if (newTask != null) {
				adminLogService.log(admin.getUsername(), "TODO_CREATE_TASK",
						"To-Do Aufgabe '" + content + "' in Kategorie ID " + categoryId + " erstellt.");
			}
			return newTask;
		} catch (Exception e) {
			logger.error("Service error creating To-Do task in category {}", categoryId, e);
			throw new RuntimeException(e);
		}
	}

	@Transactional
	public boolean updateTask(int taskId, String content, Boolean isCompleted, User admin) {
		boolean success = false;
		if (content != null) {
			success = todoDAO.updateTaskContent(taskId, content);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_TASK", "Aufgabe ID " + taskId + " aktualisiert.");
		}
		if (isCompleted != null) {
			success = todoDAO.updateTaskStatus(taskId, isCompleted);
			if (success)
				adminLogService.log(admin.getUsername(), "TODO_UPDATE_STATUS",
						"Status für Aufgabe ID " + taskId + " auf '" + isCompleted + "' gesetzt.");
		}
		return success;
	}

	@Transactional
	public boolean deleteTask(int taskId, User admin) {
		if (todoDAO.deleteTask(taskId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_TASK", "Aufgabe ID " + taskId + " gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean deleteCategory(int categoryId, User admin) {
		if (todoDAO.deleteCategory(categoryId)) {
			adminLogService.log(admin.getUsername(), "TODO_DELETE_CATEGORY",
					"Kategorie ID " + categoryId + " und alle zugehörigen Aufgaben gelöscht.");
			return true;
		}
		return false;
	}

	@Transactional
	public boolean reorder(Map<String, List<Integer>> reorderData, User admin) {
		List<Integer> categoryOrder = reorderData.get("categoryOrder");
		if (categoryOrder != null) {
			todoDAO.updateCategoryOrder(categoryOrder);
		}

		for (Map.Entry<String, List<Integer>> entry : reorderData.entrySet()) {
			if (entry.getKey().startsWith("category-")) {
				int categoryId = Integer.parseInt(entry.getKey().substring("category-".length()));
				todoDAO.updateTaskOrders(entry.getValue(), categoryId);
			}
		}
		adminLogService.log(admin.getUsername(), "TODO_REORDER", "To-Do-Listen neu sortiert.");
		return true;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\UserService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {
	private static final Logger logger = LogManager.getLogger(UserService.class);

	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public UserService(UserDAO userDAO, AdminLogService adminLogService) {
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	@Transactional
	public int createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername) {
		int newUserId = userDAO.createUser(user, password);
		if (newUserId > 0) {
			userDAO.updateUserPermissions(newUserId, permissionIds);
			logger.info("Transaction for creating user '{}' committed successfully.", user.getUsername());

			String logDetails = String.format(
					"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %s) erstellt und Berechtigungen zugewiesen.",
					user.getUsername(), newUserId, user.getRoleId(), user.getClassName());
			adminLogService.log(adminUsername, "CREATE_USER", logDetails);

			return newUserId;
		} else {
			throw new RuntimeException("Benutzererstellung lieferte eine ungültige ID zurück.");
		}
	}

	@Transactional
	public boolean updateUserWithPermissions(User user, String[] permissionIds) {
		boolean profileUpdated = userDAO.updateUser(user);
		boolean permissionsUpdated = userDAO.updateUserPermissions(user.getId(), permissionIds);
		logger.info("Transaction for updating user '{}' committed successfully.", user.getUsername());
		return profileUpdated || permissionsUpdated;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\service\WikiService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.WikiDAO;
import de.technikteam.model.WikiEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Service
public class WikiService {
	private static final Logger logger = LogManager.getLogger(WikiService.class);
	private final WikiDAO wikiDAO;

	@Autowired
	public WikiService(WikiDAO wikiDAO) {
		this.wikiDAO = wikiDAO;
	}

	/**
	 * Fetches all wiki entries and organizes them into a hierarchical tree
	 * structure. The structure is a map of maps, where the final value is a
	 * WikiEntry object.
	 *
	 * @return A Map representing the root of the file tree.
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Object> getWikiTreeAsData() {
		List<WikiEntry> allEntries = wikiDAO.getAllWikiEntries();
		Map<String, Object> rootNode = new LinkedHashMap<>();

		for (WikiEntry entry : allEntries) {
			String[] pathParts = entry.getFilePath().split("/");
			Map<String, Object> currentNode = rootNode;

			for (int i = 0; i < pathParts.length - 1; i++) {
				String part = pathParts[i];
				// This cast is safe within this algorithm as we are intentionally building a
				// nested map structure.
				currentNode = (Map<String, Object>) currentNode.computeIfAbsent(part,
						k -> new LinkedHashMap<String, Object>());
			}

			String fileName = pathParts[pathParts.length - 1];
			if (!fileName.isEmpty()) {
				currentNode.put(fileName, entry);
			}
		}
		logger.debug("Successfully built wiki tree with {} root elements.", rootNode.size());
		return rootNode;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class providing common helper methods for Data Access Objects
 * (DAOs).
 */
public final class DaoUtils {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private DaoUtils() {
	}

	/**
	 * Checks if a ResultSet contains a column with the given name. This check is
	 * case-insensitive. It is useful for handling optional columns from complex
	 * JOINs without causing a SQLException.
	 *
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column to look for.
	 * @return true if the column exists in the ResultSet metadata, false otherwise.
	 * @throws SQLException If a database access error occurs while retrieving
	 *                      metadata.
	 */
	public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columnCount = rsmd.getColumnCount();
		for (int i = 1; i <= columnCount; i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\FileSignatureValidator.java
========================================================================

package de.technikteam.util;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class FileSignatureValidator {
	private static final Logger logger = LogManager.getLogger(FileSignatureValidator.class);

	private static final Map<String, List<byte[]>> MAGIC_NUMBERS = new HashMap<>();

	static {
		// JPEG
		MAGIC_NUMBERS.put("image/jpeg", List.of(new byte[] { (byte) 0xFF, (byte) 0xD8, (byte) 0xFF }));
		// PNG
		MAGIC_NUMBERS.put("image/png", List.of(new byte[] { (byte) 0x89, (byte) 0x50, (byte) 0x4E, (byte) 0x47 }));
		// GIF
		MAGIC_NUMBERS.put("image/gif", List.of(new byte[] { (byte) 0x47, (byte) 0x49, (byte) 0x46, (byte) 0x38 }));
		// PDF
		MAGIC_NUMBERS.put("application/pdf",
				List.of(new byte[] { (byte) 0x25, (byte) 0x50, (byte) 0x44, (byte) 0x46 }));
		// DOCX, XLSX, PPTX (PKZIP archive)
		List<byte[]> pkzip = List.of(new byte[] { (byte) 0x50, (byte) 0x4B, (byte) 0x03, (byte) 0x04 });
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.wordprocessingml.document", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", pkzip);
		MAGIC_NUMBERS.put("application/vnd.openxmlformats-officedocument.presentationml.presentation", pkzip);
	}

	private static final int MAX_HEADER_SIZE = 8;

	public static boolean isFileTypeAllowed(MultipartFile file) {
		if (file == null || file.isEmpty()) {
			return false;
		}
		String declaredMimeType = file.getContentType();
		List<byte[]> expectedSignatures = MAGIC_NUMBERS.get(declaredMimeType);

		if (expectedSignatures == null) {
			logger.warn("File upload blocked for undeclared MIME type: {}", declaredMimeType);
			return false; // Type not in our allowed map
		}

		try (InputStream is = file.getInputStream()) {
			byte[] header = new byte[MAX_HEADER_SIZE];
			int bytesRead = is.read(header);
			if (bytesRead < 1)
				return false;

			byte[] actualHeader = Arrays.copyOf(header, bytesRead);

			for (byte[] signature : expectedSignatures) {
				if (actualHeader.length >= signature.length) {
					byte[] headerToCompare = Arrays.copyOf(actualHeader, signature.length);
					if (Arrays.equals(headerToCompare, signature)) {
						return true; // Match found
					}
				}
			}
		} catch (IOException e) {
			logger.error("Could not read file header for validation", e);
			return false;
		}

		logger.warn("File signature mismatch. Declared MIME type: {}, but magic bytes do not match. Upload blocked.",
				declaredMimeType);
		return false;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\MarkdownUtil.java
========================================================================

package de.technikteam.util;

/**
 * DEPRECATED: This class is no longer used for security-sensitive sanitization.
 * The OWASP Java HTML Sanitizer is now used instead to provide robust
 * protection against Cross-Site Scripting (XSS) attacks. This class is retained
 * for historical purposes or non-security-related transformations if needed.
 */
public final class MarkdownUtil {

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private MarkdownUtil() {
	}

	/**
	 * A simple, non-security-focused method to perform basic transformations.
	 *
	 * @param markdown The raw string.
	 * @return The transformed string.
	 */
	public static String transform(String markdown) {
		if (markdown == null || markdown.isEmpty()) {
			return markdown;
		}
		// Example transformation: none, as this is deprecated for security.
		return markdown;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\NavigationRegistry.java
========================================================================

package de.technikteam.util;

import de.technikteam.config.Permissions;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A central registry for all navigation items in the application. This class
 * provides a single source of truth for the sidebar links and their required
 * permissions, ensuring consistency and simplifying access control logic.
 */
public final class NavigationRegistry {

	private static final List<NavigationItem> ALL_ITEMS = new ArrayList<>();
	static {
		// User Section
		ALL_ITEMS.add(new NavigationItem("Dashboard", "/home", "fa-home", null));
		ALL_ITEMS.add(new NavigationItem("Chat", "/chat", "fa-comments", null));
		ALL_ITEMS.add(new NavigationItem("Lehrgänge", "/lehrgaenge", "fa-graduation-cap", null));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungen", "/veranstaltungen", "fa-calendar-check", null));
		ALL_ITEMS.add(new NavigationItem("Lager", "/lager", "fa-boxes", null));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/dateien", "fa-folder-open", null));
		ALL_ITEMS.add(new NavigationItem("Kalender", "/kalender", "fa-calendar-alt", null));
		ALL_ITEMS.add(new NavigationItem("Feedback", "/feedback", "fa-lightbulb", null));
		ALL_ITEMS.add(new NavigationItem("Changelogs", "/changelogs", "fa-history", null));

		// Admin Section
		ALL_ITEMS.add(new NavigationItem("Admin Dashboard", "/admin/dashboard", "fa-tachometer-alt",
				Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benutzer", "/admin/mitglieder", "fa-users-cog", Permissions.USER_READ));
		ALL_ITEMS.add(new NavigationItem("Anträge", "/admin/requests", "fa-inbox", Permissions.USER_UPDATE));
		ALL_ITEMS.add(
				new NavigationItem("Events", "/admin/veranstaltungen", "fa-calendar-plus", Permissions.EVENT_READ));
		ALL_ITEMS.add(new NavigationItem("Debriefings", "/admin/debriefings", "fa-clipboard-check",
				Permissions.EVENT_DEBRIEFING_VIEW));
		ALL_ITEMS.add(new NavigationItem("Lager", "/admin/lager", "fa-warehouse", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Veranstaltungsorte", "/admin/venues", "fa-map-marked-alt",
				Permissions.EVENT_CREATE));
		ALL_ITEMS.add(new NavigationItem("Dateien", "/admin/dateien", "fa-file-upload", Permissions.FILE_MANAGE));
		ALL_ITEMS
				.add(new NavigationItem("Lehrgangs-Vorlagen", "/admin/lehrgaenge", "fa-book", Permissions.COURSE_READ));
		ALL_ITEMS.add(new NavigationItem("Kit-Verwaltung", "/admin/kits", "fa-box-open", Permissions.KIT_READ));
		ALL_ITEMS
				.add(new NavigationItem("Feedback", "/admin/feedback", "fa-inbox", Permissions.ADMIN_DASHBOARD_ACCESS));
		ALL_ITEMS.add(new NavigationItem("Benachrichtigungen", "/admin/benachrichtigungen", "fa-bullhorn",
				Permissions.NOTIFICATION_SEND));
		ALL_ITEMS.add(new NavigationItem("Abzeichen", "/admin/achievements", "fa-award", Permissions.ACHIEVEMENT_VIEW));
		ALL_ITEMS.add(new NavigationItem("Defekte Artikel", "/admin/defekte", "fa-wrench", Permissions.STORAGE_READ));
		ALL_ITEMS.add(new NavigationItem("Schadensmeldungen", "/admin/damage-reports", "fa-tools",
				Permissions.DAMAGE_REPORT_MANAGE));
		ALL_ITEMS.add(new NavigationItem("Checklist-Vorlagen", "/admin/checklist-templates", "fa-tasks",
				Permissions.EVENT_MANAGE_TASKS));
		ALL_ITEMS
				.add(new NavigationItem("Quali-Matrix", "/admin/matrix", "fa-th-list", Permissions.QUALIFICATION_READ));
		ALL_ITEMS.add(new NavigationItem("Berichte", "/admin/berichte", "fa-chart-pie", Permissions.REPORT_READ));
		ALL_ITEMS.add(
				new NavigationItem("Changelogs", "/admin/changelogs", "fa-history", Permissions.ACCESS_ADMIN_PANEL));
		ALL_ITEMS.add(new NavigationItem("Aktions-Log", "/admin/log", "fa-clipboard-list", Permissions.LOG_READ));
		ALL_ITEMS.add(new NavigationItem("System", "/admin/system", "fa-server", Permissions.SYSTEM_READ));
		ALL_ITEMS.add(new NavigationItem("Wiki", "/admin/wiki", "fa-book-reader", Permissions.ACCESS_ADMIN_PANEL));
		ALL_ITEMS.add(new NavigationItem("API Docs", "/swagger-ui.html", "fa-code", Permissions.ACCESS_ADMIN_PANEL));
	}

	private NavigationRegistry() {
	}

	/**
	 * Builds a filtered list of navigation items based on the user's permissions.
	 *
	 * @param user The current user.
	 * @return A list of NavigationItem objects the user is allowed to see.
	 */
	public static List<NavigationItem> getNavigationItemsForUser(User user) {
		if (user == null) {
			return new ArrayList<>();
		}

		final boolean isAdmin = user.hasAdminAccess();
		final Set<String> userPermissions = user.getPermissions() != null ? user.getPermissions() : Set.of();

		return ALL_ITEMS.stream().filter(item -> {
			final String requiredPerm = item.getRequiredPermission();

			// Public items (no permission required) are always visible to any authenticated
			// user.
			if (requiredPerm == null) {
				return true;
			}

			// For admin links, check if the user is an admin or has the specific permission
			if (isAdmin) {
				return true;
			}

			return userPermissions.contains(requiredPerm);
		}).collect(Collectors.toList());
	}
}
========================================================================
FILE: src\main\java\de\technikteam\util\PasswordPolicyValidator.java
========================================================================

package de.technikteam.util;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

/**
 * A utility class to enforce a consistent, server-side password policy.
 */
public final class PasswordPolicyValidator {

	private static final int MIN_LENGTH = 10;
	private static final Pattern HAS_UPPERCASE = Pattern.compile("[A-Z]");
	private static final Pattern HAS_LOWERCASE = Pattern.compile("[a-z]");
	private static final Pattern HAS_DIGIT = Pattern.compile("[0-9]");
	private static final Pattern HAS_SPECIAL_CHAR = Pattern.compile("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]");

	/**
	 * Private constructor to prevent instantiation of this utility class.
	 */
	private PasswordPolicyValidator() {
	}

	/**
	 * A simple record to hold the result of a password validation check.
	 */
	public static class ValidationResult {
		private final boolean isValid;
		private final String message;

		public ValidationResult(boolean isValid, String message) {
			this.isValid = isValid;
			this.message = message;
		}

		public boolean isValid() {
			return isValid;
		}

		public String getMessage() {
			return message;
		}
	}

	/**
	 * Validates a password against the application's defined security policy.
	 *
	 * @param password The password to validate.
	 * @return A {@link ValidationResult} object containing the result and a
	 *         descriptive message.
	 */
	public static ValidationResult validate(String password) {
		if (password == null || password.trim().isEmpty()) {
			return new ValidationResult(false, "Das Passwort darf nicht leer sein.");
		}

		List<String> errors = new ArrayList<>();

		if (password.length() < MIN_LENGTH) {
			errors.add("mindestens " + MIN_LENGTH + " Zeichen lang sein");
		}
		if (!HAS_UPPERCASE.matcher(password).find()) {
			errors.add("mindestens einen Großbuchstaben enthalten");
		}
		if (!HAS_LOWERCASE.matcher(password).find()) {
			errors.add("mindestens einen Kleinbuchstaben enthalten");
		}
		if (!HAS_DIGIT.matcher(password).find()) {
			errors.add("mindestens eine Ziffer enthalten");
		}
		if (!HAS_SPECIAL_CHAR.matcher(password).find()) {
			errors.add("mindestens ein Sonderzeichen enthalten");
		}

		if (errors.isEmpty()) {
			return new ValidationResult(true, "Passwort ist gültig.");
		} else {
			return new ValidationResult(false, "Das Passwort muss " + String.join(", ", errors) + ".");
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

/**
 * Manages WebSocket sessions for event-specific chat rooms as a thread-safe
 * Spring Component. It maps event IDs to a set of active sessions, allowing for
 * targeted broadcasting of messages.
 */
@Component
public class ChatSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByEvent = new ConcurrentHashMap<>();

	/**
	 * Adds a new WebSocket session to a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to add.
	 */
	public void addSession(String eventId, WebSocketSession session) {
		sessionsByEvent.computeIfAbsent(eventId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for event chat [{}].", session.getId(), eventId);
	}

	/**
	 * Removes a WebSocket session from an event chat room. If the room becomes
	 * empty, it is removed from the map to conserve memory.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param session The WebSocket session to remove.
	 */
	public void removeSession(String eventId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from event chat [{}].", session.getId(), eventId);
			if (sessions.isEmpty()) {
				sessionsByEvent.remove(eventId);
				logger.info("Event chat room [{}] is now empty and has been removed.", eventId);
			}
		}
	}

	/**
	 * Broadcasts a message to all open sessions in a specific event chat room.
	 *
	 * @param eventId The ID of the event chat room.
	 * @param message The message to broadcast.
	 */
	public void broadcast(String eventId, String message) {
		Set<WebSocketSession> sessions = sessionsByEvent.get(eventId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in event chat [{}].", sessions.size(), eventId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatWebSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.ChatDAO;
import de.technikteam.model.ChatConversation;
import de.technikteam.model.ChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class ChatWebSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(ChatWebSocketHandler.class);
	private final ChatDAO chatDAO;
	private final ChatWebSocketSessionManager sessionManager;
	private final NotificationService notificationService;
	private final Gson gson;

	@Autowired
	public ChatWebSocketHandler(ChatDAO chatDAO, ChatWebSocketSessionManager sessionManager,
			NotificationService notificationService) {
		this.chatDAO = chatDAO;
		this.sessionManager = sessionManager;
		this.notificationService = notificationService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String conversationId = getConversationId(session);

		if (user == null || conversationId == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Missing user or conversation ID."));
			return;
		}

		if (!chatDAO.isUserInConversation(Integer.parseInt(conversationId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Unauthorized for this conversation."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("conversationId", conversationId);
		sessionManager.addSession(conversationId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		User user = (User) session.getAttributes().get("user");
		String conversationIdStr = (String) session.getAttributes().get("conversationId");
		if (user == null || conversationIdStr == null)
			return;
		int conversationId = Integer.parseInt(conversationIdStr);

		try {
			Map<String, Object> payload = gson.fromJson(message.getPayload(), new TypeToken<Map<String, Object>>() {
			}.getType());
			String type = (String) payload.get("type");
			// The actual data might be nested inside a 'payload' object or be at the top
			// level
			Map<String, Object> data = (Map<String, Object>) payload.get("payload");
			if (data == null) {
				data = payload; // Fallback for messages like `new_message` which might not have a nested
								// payload
			}

			switch (type) {
			case "new_message":
				handleNewMessage(user, conversationId, (String) data.get("messageText"));
				break;
			case "mark_as_read":
				if (data.get("messageIds") instanceof List) {
					handleMarkAsRead(user, conversationId, (List<Double>) data.get("messageIds"));
				}
				break;
			case "update_message":
				handleUpdateMessage(user, conversationId, data);
				break;
			case "delete_message":
				handleDeleteMessage(user, conversationId, data);
				break;
			}
		} catch (JsonSyntaxException | ClassCastException | NullPointerException e) {
			logger.warn("Bad payload from {}: {}", user.getUsername(), e.getMessage());
		}
	}

	private void handleNewMessage(User user, int conversationId, String text) {
		if (text != null && !text.isBlank()) {
			ChatMessage chatMessage = new ChatMessage();
			chatMessage.setConversationId(conversationId);
			chatMessage.setSenderId(user.getId());
			chatMessage.setMessageText(text);

			ChatMessage savedMessage = chatDAO.createMessage(chatMessage);
			ChatMessage fullMessage = chatDAO.getMessageById(savedMessage.getId());

			sessionManager.broadcast(String.valueOf(conversationId),
					gson.toJson(Map.of("type", "new_message", "payload", fullMessage)));
			notifyParticipants(fullMessage, user);
		}
	}

	private void handleMarkAsRead(User user, int conversationId, List<Double> messageIdsDouble) {
		if (messageIdsDouble == null || messageIdsDouble.isEmpty())
			return;
		List<Long> messageIds = messageIdsDouble.stream().map(Double::longValue).collect(Collectors.toList());

		boolean updated = chatDAO.updateMessagesStatusToRead(messageIds, conversationId, user.getId());
		if (updated) {
			Map<String, Object> updatePayload = Map.of("type", "messages_status_updated", "payload",
					Map.of("messageIds", messageIds, "newStatus", "READ"));
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(updatePayload));
		}
	}

	private void handleUpdateMessage(User user, int conversationId, Map<String, Object> data) {
		if (data == null || !(data.get("messageId") instanceof Number))
			return;
		long messageId = ((Number) data.get("messageId")).longValue();
		String newText = (String) data.get("newText");

		if (chatDAO.updateMessage(messageId, user.getId(), newText)) {
			ChatMessage updatedMessage = chatDAO.getMessageById(messageId);
			if (updatedMessage == null)
				return;

			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload", updatedMessage);
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, int conversationId, Map<String, Object> data) {
		if (data == null || !(data.get("messageId") instanceof Number))
			return;
		long messageId = ((Number) data.get("messageId")).longValue();
		ChatConversation conversation = chatDAO.getConversationById(conversationId);
		boolean isAdmin = conversation != null && conversation.isGroupChat() && conversation.getCreatorId() != null
				&& conversation.getCreatorId() == user.getId();

		if (chatDAO.deleteMessage(messageId, user.getId(), isAdmin)) {
			ChatMessage deletedMessage = chatDAO.getMessageById(messageId);
			if (deletedMessage == null)
				return;

			Map<String, Object> broadcastPayload = Map.of("type", "message_deleted", "payload", deletedMessage);
			sessionManager.broadcast(String.valueOf(conversationId), gson.toJson(broadcastPayload));
		}
	}

	private void notifyParticipants(ChatMessage message, User sender) {
		ChatConversation conversation = chatDAO.getConversationById(message.getConversationId());
		if (conversation == null)
			return;

		List<User> participants = conversation.getParticipants();
		for (User participant : participants) {
			if (participant.getId() != sender.getId()) { // Don't notify the sender
				String messageSnippet = message.getMessageText();
				if (messageSnippet.length() > 50) {
					messageSnippet = messageSnippet.substring(0, 47) + "...";
				}

				String title = conversation.isGroupChat() ? "Neue Nachricht in \"" + conversation.getName() + "\""
						: "Neue Nachricht von " + sender.getUsername();

				Map<String, Object> payload = Map.of("type", "new_message", "title", title, "description",
						messageSnippet, "level", "Informational", "url", "/chat/" + message.getConversationId());
				notificationService.sendNotificationToUser(participant.getId(), payload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		String conversationId = (String) session.getAttributes().get("conversationId");
		if (conversationId != null) {
			sessionManager.removeSession(conversationId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication auth) {
			if (auth.getPrincipal() instanceof SecurityUser securityUser) {
				return securityUser.getUser();
			}
		}
		return null;
	}

	private String getConversationId(WebSocketSession session) {
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\ChatWebSocketSessionManager.java
========================================================================

package de.technikteam.websocket;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArraySet;

@Component
public class ChatWebSocketSessionManager {
	private static final Logger logger = LogManager.getLogger(ChatWebSocketSessionManager.class);

	private final Map<String, Set<WebSocketSession>> sessionsByConversation = new ConcurrentHashMap<>();

	public void addSession(String conversationId, WebSocketSession session) {
		sessionsByConversation.computeIfAbsent(conversationId, k -> new CopyOnWriteArraySet<>()).add(session);
		logger.info("Session {} registered for direct message chat [{}].", session.getId(), conversationId);
	}

	public void removeSession(String conversationId, WebSocketSession session) {
		Set<WebSocketSession> sessions = sessionsByConversation.get(conversationId);
		if (sessions != null) {
			sessions.remove(session);
			logger.info("Session {} removed from direct message chat [{}].", session.getId(), conversationId);
			if (sessions.isEmpty()) {
				sessionsByConversation.remove(conversationId);
				logger.info("Direct message chat room [{}] is now empty and has been removed.", conversationId);
			}
		}
	}

	public void broadcast(String conversationId, String message) {
		Set<WebSocketSession> sessions = sessionsByConversation.get(conversationId);
		if (sessions != null) {
			logger.debug("Broadcasting to {} sessions in direct message chat [{}].", sessions.size(), conversationId);
			TextMessage textMessage = new TextMessage(message);
			for (WebSocketSession session : sessions) {
				if (session.isOpen()) {
					try {
						session.sendMessage(textMessage);
					} catch (IOException e) {
						logger.error("Error broadcasting to session {}:", session.getId(), e);
					}
				}
			}
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\EventChatSocketHandler.java
========================================================================

package de.technikteam.websocket;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonSyntaxException;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
public class EventChatSocketHandler extends TextWebSocketHandler {

	private static final Logger logger = LogManager.getLogger(EventChatSocketHandler.class);
	private static final Pattern MENTION_PATTERN = Pattern.compile("@(\\w+)");

	private final EventChatDAO chatDAO;
	private final EventDAO eventDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final NotificationService notificationService;
	private final ChatSessionManager sessionManager;
	private final Gson gson;
	private final PolicyFactory inlineFormattingPolicy;

	@Autowired
	public EventChatSocketHandler(EventChatDAO chatDAO, EventDAO eventDAO, UserDAO userDAO,
			AdminLogService adminLogService, NotificationService notificationService, ChatSessionManager sessionManager,
			@Qualifier("inlineFormattingPolicy") PolicyFactory inlineFormattingPolicy) {
		this.chatDAO = chatDAO;
		this.eventDAO = eventDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.notificationService = notificationService;
		this.sessionManager = sessionManager;
		this.inlineFormattingPolicy = inlineFormattingPolicy;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		User user = getUserFromSession(session);
		String eventId = getEventId(session);

		if (user == null) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Authentifizierung erforderlich."));
			return;
		}

		if (eventId == null || !eventDAO.isUserAssociatedWithEvent(Integer.parseInt(eventId), user.getId())) {
			session.close(CloseStatus.POLICY_VIOLATION.withReason("Keine Berechtigung für diesen Event-Chat."));
			return;
		}

		session.getAttributes().put("user", user);
		session.getAttributes().put("eventId", eventId);
		sessionManager.addSession(eventId, session);
	}

	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) {
		User user = (User) session.getAttributes().get("user");
		String eventId = (String) session.getAttributes().get("eventId");
		if (user == null || eventId == null)
			return;

		try {
			@SuppressWarnings("unchecked")
			Map<String, Object> messageMap = gson.fromJson(message.getPayload(), Map.class);
			String type = (String) messageMap.get("type");
			@SuppressWarnings("unchecked")
			Map<String, Object> payload = (Map<String, Object>) messageMap.get("payload");

			switch (type) {
			case "new_message":
				handleNewMessage(user, eventId, payload);
				break;
			case "update_message":
				handleUpdateMessage(user, eventId, payload);
				break;
			case "delete_message":
				handleDeleteMessage(user, eventId, payload);
				break;
			}
		} catch (JsonSyntaxException e) {
			logger.error("Error processing message from user '{}'. Invalid JSON format.", user.getUsername(), e);
		}
	}

	private void handleNewMessage(User user, String eventId, Map<String, Object> payload) {
		String messageText = (String) payload.get("messageText");
		String sanitizedMessage = inlineFormattingPolicy.sanitize(messageText);
		EventChatMessage newMessage = new EventChatMessage();
		newMessage.setEventId(Integer.parseInt(eventId));
		newMessage.setUserId(user.getId());
		newMessage.setUsername(user.getUsername());
		newMessage.setMessageText(sanitizedMessage);
		EventChatMessage savedMessage = chatDAO.postMessage(newMessage);
		if (savedMessage == null)
			return;
		Map<String, Object> broadcastPayload = Map.of("type", "new_message", "payload", savedMessage);
		sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		handleMentions(user, savedMessage);
	}

	private void handleUpdateMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		String newText = (String) payload.get("newText");
		String sanitizedText = inlineFormattingPolicy.sanitize(newText);
		if (chatDAO.updateMessage(messageId, user.getId(), sanitizedText)) {
			EventChatMessage updatedMessage = chatDAO.getMessageById(messageId);
			if (updatedMessage == null)
				return;
			Map<String, Object> broadcastPayload = Map.of("type", "message_updated", "payload", updatedMessage);
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleDeleteMessage(User user, String eventId, Map<String, Object> payload) {
		int messageId = ((Double) payload.get("messageId")).intValue();
		Event event = eventDAO.getEventById(Integer.parseInt(eventId));
		boolean isEventLeader = event != null && event.getLeaderUserId() == user.getId();
		boolean canDeleteAsAdmin = user.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL) || isEventLeader;
		if (chatDAO.deleteMessage(messageId, user.getId(), canDeleteAsAdmin)) {
			int originalUserId = ((Double) payload.get("originalUserId")).intValue();
			if (canDeleteAsAdmin && user.getId() != originalUserId && event != null) {
				String logDetails = String.format(
						"Admin '%s' deleted chat message (ID: %d) in event chat for event '%s' (ID: %s).",
						user.getUsername(), messageId, event.getName(), eventId);
				adminLogService.log(user.getUsername(), "DELETE_CHAT_MESSAGE", logDetails);
			}
			EventChatMessage deletedMessage = chatDAO.getMessageById(messageId);
			if (deletedMessage == null)
				return;
			Map<String, Object> broadcastPayload = Map.of("type", "message_soft_deleted", "payload", deletedMessage);
			sessionManager.broadcast(eventId, gson.toJson(broadcastPayload));
		}
	}

	private void handleMentions(User sender, EventChatMessage message) {
		Event event = eventDAO.getEventById(message.getEventId());
		if (event == null)
			return;
		Matcher matcher = MENTION_PATTERN.matcher(message.getMessageText());
		while (matcher.find()) {
			String mentionedUsername = matcher.group(1);
			User mentionedUser = userDAO.getUserByUsername(mentionedUsername);
			if (mentionedUser != null && mentionedUser.getId() != sender.getId()) {
				String notificationMessage = String.format("%s hat Sie im Chat für '%s' erwähnt.", sender.getUsername(),
						event.getName());
				Map<String, Object> notificationPayload = Map.of("type", "mention", "payload",
						Map.of("message", notificationMessage, "url", "/veranstaltungen/details/" + event.getId()));
				notificationService.sendNotificationToUser(mentionedUser.getId(), notificationPayload);
			}
		}
	}

	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
		String eventId = (String) session.getAttributes().get("eventId");
		if (eventId != null) {
			sessionManager.removeSession(eventId, session);
		}
	}

	private User getUserFromSession(WebSocketSession session) {
		if (session.getPrincipal() instanceof Authentication) {
			Authentication auth = (Authentication) session.getPrincipal();
			if (auth.getPrincipal() instanceof SecurityUser) {
				return ((SecurityUser) auth.getPrincipal()).getUser();
			}
		}
		return null;
	}

	private String getEventId(WebSocketSession session) {
		// URI pattern is /ws/chat/{eventId}
		String path = session.getUri().getPath();
		String[] parts = path.split("/");
		if (parts.length > 0) {
			return parts[parts.length - 1];
		}
		return null;
	}
}
========================================================================
FILE: src\main\java\de\technikteam\websocket\WebSocketConfig.java
========================================================================

package de.technikteam.websocket;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.config.annotation.EnableWebSocket;
import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {

	private final EventChatSocketHandler eventChatSocketHandler;
	private final ChatWebSocketHandler chatWebSocketHandler;

	@Autowired
	public WebSocketConfig(EventChatSocketHandler eventChatSocketHandler, ChatWebSocketHandler chatWebSocketHandler) {
		this.eventChatSocketHandler = eventChatSocketHandler;
		this.chatWebSocketHandler = chatWebSocketHandler;
	}

	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(eventChatSocketHandler, "/ws/chat/{eventId}").setAllowedOrigins("*");
		registry.addHandler(chatWebSocketHandler, "/ws/dm/{conversationId}").setAllowedOrigins("*");
	}
}