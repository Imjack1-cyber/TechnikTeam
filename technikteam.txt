
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\AppConfig.java
========================================================================

package de.technikteam.config;

/**
 * A simple configuration class that holds a single, application-wide constant: 
 * the absolute file path for the directory where all user-uploaded files are stored.
 * This centralized approach makes it easy to change the upload location without
 * modifying multiple files.
 */
public class AppConfig {
	public static final String UPLOAD_DIRECTORY = "C:\\dev\\eclipse\\workspace\\TechnikTeam\\resources\\uploads";
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	// A formatter for a full date and time, e.g., "10.06.2025, 17:45"
	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy HH:mm",
			Locale.GERMANY);

	// A formatter for just the date, e.g., "10.06.2025"
	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	// A formatter for just the time, e.g., "17:45"
	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * e.g., "10.06.2025, 17:45 - 19:00 Uhr"
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}
		String formattedStart = formatDateTime(start);
		if (end == null) {
			return formattedStart + " Uhr";
		}
		// If start and end are on the same day, format as "dd.MM.yyyy HH:mm - HH:mm"
		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + " " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}
		// If on different days, format fully
		return formattedStart + " - " + formatDateTime(end) + " Uhr";
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * A custom serializer for the Gson library. It converts java.time.LocalDate
 * objects into the standard YYYY-MM-DD string format, which is ideal for JSON
 * data exchange and compatibility with HTML date input fields.
 */
public class LocalDateAdapter implements JsonSerializer<LocalDate> {

	@Override
	public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context) {
		// We convert the LocalDate to its standard ISO_LOCAL_DATE string format
		// ("YYYY-MM-DD").
		// This also gracefully handles the case where the date object might be null.
		return date == null ? null : new JsonPrimitive(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A Data Access Object (DAO) responsible for all database interactions with the
 * `admin_logs` table. It provides methods to create new log entries, which are
 * used for auditing administrative actions, and to retrieve all existing logs
 * for display in the admin panel.
 */
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);

	/**
	 * Creates a new log entry in the database. This is the primary method for
	 * recording an administrative action.
	 * 
	 * @param log The AdminLog object to persist.
	 */
	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		logger.debug("Attempting to create admin log: [User: {}, Action: {}]", log.getAdminUsername(),
				log.getActionType());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, log.getAdminUsername());
			pstmt.setString(2, log.getActionType());
			pstmt.setString(3, log.getDetails());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created admin log for user '{}'.", log.getAdminUsername());
			}
		} catch (SQLException e) {
			logger.error("Failed to create admin log for user '{}'. Details: {}", log.getAdminUsername(),
					log.getDetails(), e);
		}
	}

	/**
	 * Fetches all log entries from the database, ordered with the newest first.
	 * 
	 * @return A list of AdminLog objects.
	 */
	public List<AdminLog> getAllLogs() {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		logger.debug("Executing query to fetch all admin logs.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				logs.add(logEntry);
			}
			logger.info("Fetched {} admin log entries from the database.", logs.size());
		} catch (SQLException e) {
			logger.error("Failed to fetch admin logs from the database.", e);
		}
		return logs;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Course;

/**
 * Data Access Object for managing `Course` templates in the `courses` table.
 * This DAO handles CRUD operations for the parent course definitions (e.g.,
 * "Grundlehrgang Tontechnik"), which serve as blueprints for individual,
 * schedulable `Meeting` instances.
 */
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);

	/**
	 * Creates a new parent course template in the database.
	 * 
	 * @param course The Course object to create (containing name, abbreviation, and
	 *               description).
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		logger.debug("Attempting to create parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error creating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Fetches a single parent course by its ID.
	 * 
	 * @param courseId The ID of the course.
	 * @return A Course object, or null if not found.
	 */
	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		logger.debug("Attempting to fetch course by ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found course with ID: {}", courseId);
					return mapResultSetToCourse(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching course by ID: {}", courseId, e);
		}
		logger.warn("No course found with ID: {}", courseId);
		return null;
	}

	/**
	 * Fetches all parent courses from the database, sorted alphabetically by name.
	 * 
	 * @return A list of all Course objects.
	 */
	public List<Course> getAllCourses() {
		List<Course> courses = new ArrayList<>();
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		logger.debug("Attempting to fetch all parent courses.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				courses.add(mapResultSetToCourse(rs));
			}
			logger.info("Fetched {} total parent courses.", courses.size());
		} catch (SQLException e) {
			logger.error("SQL error while fetching all courses.", e);
		}
		return courses;
	}

	/**
	 * Helper method to map a ResultSet row to a Course object.
	 * 
	 * @param rs The ResultSet to map from.
	 * @return A populated Course object.
	 * @throws SQLException If a database access error occurs.
	 */
	private Course mapResultSetToCourse(ResultSet rs) throws SQLException {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	}

	/**
	 * Updates an existing parent course's name, abbreviation, and description.
	 * 
	 * @param course The Course object with the updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		logger.debug("Attempting to update parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			pstmt.setInt(4, course.getId());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully updated parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error updating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Deletes a parent course from the database. NOTE: This relies on `ON DELETE
	 * CASCADE` in the database schema to also delete all associated meetings and
	 * qualifications.
	 * 
	 * @param courseId The ID of the course to delete.
	 * @return true if the deletion was successful, false otherwise.
	 */
	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		logger.debug("Attempting to delete parent course with ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.warn("Successfully deleted parent course with ID: {}", courseId);
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\DatabaseManager.java
========================================================================

package de.technikteam.dao;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This class manages the application's connection to the MySQL database. It
 * uses the HikariCP connection pool for efficient and high-performance database
 * communication. A single, static `HikariDataSource` is initialized when the
 * class is first loaded. All Data Access Objects (DAOs) use the static
 * `getConnection()` method to borrow a connection from the pool.
 */
public class DatabaseManager {

	private static final Logger logger = LogManager.getLogger(DatabaseManager.class);
	private static HikariDataSource dataSource;

	// This static block runs only ONCE when the class is first loaded.
	static {
		try {
			logger.info("Initializing database connection pool...");

			HikariConfig config = new HikariConfig();
			// Ensure the JDBC URL uses UTF-8 and a modern timezone for compatibility.
			config.setJdbcUrl(
					"jdbc:mysql://localhost:3306/technik_team_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=UTC");
			config.setUsername("technik_user"); // <-- SET YOUR DB USERNAME
			config.setPassword("ein_sicheres_passwort"); // <-- SET YOUR DB PASSWORD

			// --- Pool Configuration (Good Defaults) ---
			config.setMaximumPoolSize(10); // Max number of active connections
			config.setMinimumIdle(5); // Min number of idle connections to keep ready
			config.setConnectionTimeout(30000); // 30 seconds to wait for a connection before timing out
			config.setIdleTimeout(600000); // 10 minutes for an idle connection to be retired
			config.setMaxLifetime(1800000); // 30 minutes max lifetime for any single connection

			// Create the datasource pool from the configuration
			dataSource = new HikariDataSource(config);

			logger.info("================================================================");
			logger.info("DATABASE CONNECTION POOL INITIALIZED SUCCESSFULLY.");
			logger.info("================================================================");

		} catch (Exception e) {
			logger.fatal(
					"Failed to initialize database connection pool! The application cannot function without a database.",
					e);
			// This is a fatal error, so we throw an exception to stop the application from
			// starting incorrectly.
			throw new RuntimeException("Could not initialize database pool", e);
		}
	}

	/**
	 * Gets a connection from the connection pool. This method is fast because it
	 * borrows an existing, ready-to-use connection; it does not create a new one.
	 * 
	 * @return A database connection.
	 * @throws SQLException if a connection cannot be obtained from the pool.
	 */
	public static Connection getConnection() throws SQLException {
		if (dataSource == null) {
			logger.error("Datasource is null. The database manager was not initialized correctly.");
			throw new SQLException("Database connection pool is not available.");
		}
		return dataSource.getConnection();
	}

	/**
	 * Closes the entire connection pool. This should be called only when the
	 * application is shutting down to release all database resources.
	 */
	public static void closeDataSource() {
		if (dataSource != null && !dataSource.isClosed()) {
			logger.info("Closing database connection pool...");
			dataSource.close();
			logger.info("Database connection pool closed successfully.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling chat messages specific to a single event. It
 * manages records in the `event_chat_messages` table, allowing users to post
 * messages and retrieve the chat history for a particular event.
 */
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);

	/**
	 * Posts a new message to an event's chat log in the database.
	 * 
	 * @param message The EventChatMessage object to persist.
	 * @return true if the message was successfully inserted, false otherwise.
	 */
	public boolean postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		logger.debug("Posting chat message for event {}: '{}'", message.getEventId(), message.getMessageText());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, message.getEventId());
			pstmt.setInt(2, message.getUserId());
			pstmt.setString(3, message.getUsername());
			pstmt.setString(4, message.getMessageText());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error posting chat message for event {}", message.getEventId(), e);
			return false;
		}
	}

	/**
	 * Fetches all messages for a specific event, ordered by the time they were
	 * sent.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of EventChatMessage objects, or an empty list if none are
	 *         found.
	 */
	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		List<EventChatMessage> messages = new ArrayList<>();
		String sql = "SELECT * FROM event_chat_messages WHERE event_id = ? ORDER BY sent_at ASC";
		logger.debug("Fetching chat messages for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventChatMessage msg = new EventChatMessage();
					msg.setId(rs.getInt("id"));
					msg.setEventId(rs.getInt("event_id"));
					msg.setUserId(rs.getInt("user_id"));
					msg.setUsername(rs.getString("username"));
					msg.setMessageText(rs.getString("message_text"));
					msg.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
					messages.add(msg);
				}
				logger.info("Found {} chat messages for event ID: {}", messages.size(), eventId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching chat messages for event {}", eventId, e);
		}
		return messages;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Event;
import de.technikteam.model.EventAttendance;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.User;

/**
 * A comprehensive DAO for all database operations related to the `events`
 * table. It handles creating, reading, updating, and deleting events.
 * Additionally, it manages user sign-ups/sign-offs, event skill requirements,
 * and the final assignment of users to an event. It contains methods to supply
 * data for both regular user views (like upcoming events) and administrative
 * back-end pages.
 */
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);

	// --- Private Helper Methods ---

	/**
	 * Maps a row from a ResultSet to an Event object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Event object.
	 * @throws SQLException If a database error occurs.
	 */
	private Event mapResultSetToEvent(ResultSet rs) throws SQLException {
		Event event = new Event();
		event.setId(rs.getInt("id"));
		event.setName(rs.getString("name"));
		event.setEventDateTime(rs.getTimestamp("event_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			event.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		event.setDescription(rs.getString("description"));
		event.setStatus(rs.getString("status"));
		return event;
	}

	public void setAttendanceCommitment(int eventId, int userId, String commitment) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Setting attendance commitment for user {} event {} to '{}'", userId, eventId, commitment);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, commitment);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, userId);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("SQL error setting attendance commitment for user {} event {}", userId, eventId, e);
		}
	}

	/**
	 * Maps a row from a ResultSet to a simplified User object (ID, username, role).
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated User object.
	 * @throws SQLException If a database error occurs.
	 */
	private User mapResultSetToSimpleUser(ResultSet rs) throws SQLException {
		return new User(rs.getInt("id"), rs.getString("username"), rs.getString("role"));
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		for (int i = 1; i <= rsmd.getColumnCount(); i++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(i))) {
				return true;
			}
		}
		return false;
	}

	// --- Methods for Public and User-Specific Views ---

	/**
	 * Fetches the event participation history for a specific user.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of all past and present events the user has interacted with.
	 */
	public List<Event> getEventHistoryForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.*, ea.signup_status FROM events e "
				+ "JOIN event_attendance ea ON e.id = ea.event_id WHERE ea.user_id = ? ORDER BY e.event_datetime DESC";
		logger.debug("Fetching event history for user ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			ResultSet rs = pstmt.executeQuery();
			while (rs.next()) {
				Event event = mapResultSetToEvent(rs);
				event.setUserAttendanceStatus(rs.getString("signup_status"));
				history.add(event);
			}
			logger.info("Found {} events in history for user ID: {}", history.size(), userId);
		} catch (SQLException e) {
			logger.error("SQL error fetching event history for user {}", userId, e);
		}
		return history;
	}

	// --- Methods for Admin Views & CRUD ---

	/**
	 * Fetches a single event by its ID.
	 * 
	 * @param eventId The ID of the event.
	 * @return An Event object, or null if not found.
	 */
	public Event getEventById(int eventId) {
		String sql = "SELECT * FROM events WHERE id = ?";
		logger.debug("Fetching event by ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found event '{}' with ID: {}", rs.getString("name"), eventId);
					return mapResultSetToEvent(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching event by ID: {}", eventId, e);
		}
		logger.warn("No event found with ID: {}", eventId);
		return null;
	}

	/**
	 * Fetches all events from the database, newest first.
	 * 
	 * @return A list of all Event objects.
	 */
	public List<Event> getAllEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events ORDER BY event_datetime DESC";
		logger.debug("Fetching all events.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				events.add(mapResultSetToEvent(rs));
			}
			logger.info("Fetched a total of {} events.", events.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all events.", e);
		}
		return events;
	}

	/**
	 * Creates a new event in the database.
	 * 
	 * @param event The Event object to persist.
	 * @return The ID of the newly created event, or 0 on failure.
	 */
	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, status) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Attempting to create new event: {}", event.getName());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setString(1, event.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			pstmt.setString(4, event.getDescription());
			pstmt.setString(5, "GEPLANT");
			if (pstmt.executeUpdate() > 0) {
				try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						logger.info("Successfully created event '{}' with ID {}", event.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating event '{}'.", event.getName(), e);
		}
		return 0;
	}

	/**
	 * Updates an existing event in the database.
	 * 
	 * @param event The Event object with updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, status = ? WHERE id = ?";
		logger.debug("Attempting to update event with ID: {}", event.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, event.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			pstmt.setString(4, event.getDescription());
			pstmt.setString(5, event.getStatus());
			pstmt.setInt(6, event.getId());
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated event with ID: {}", event.getId());
			return success;
		} catch (SQLException e) {
			logger.error("SQL error updating event with ID: {}", event.getId(), e);
		}
		return false;
	}

	/**
	 * Deletes an event from the database.
	 * 
	 * @param eventId The ID of the event to delete.
	 * @return true if deletion was successful, false otherwise.
	 */
	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		logger.debug("Attempting to delete event with ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.warn("Successfully deleted event with ID: {}", eventId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting event with ID: {}", eventId, e);
		}
		return false;
	}

	/**
	 * Updates only the status of a specific event.
	 * 
	 * @param eventId   The ID of the event to update.
	 * @param newStatus The new status string (e.g., 'LAUFEND', 'ABGESCHLOSSEN').
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateEventStatus(int eventId, String newStatus) {
		String sql = "UPDATE events SET status = ? WHERE id = ?";
		logger.debug("Attempting to update status for event {} to '{}'", eventId, newStatus);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newStatus);
			pstmt.setInt(2, eventId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Updating status for event {} to '{}' was successful.", eventId, newStatus);
			else
				logger.warn("Updating status for event {} to '{}' failed (0 rows affected).", eventId, newStatus);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error updating status for event ID: {}", eventId, e);
			return false;
		}
	}

	// --- Methods for User Actions & Admin Management ---

	/**
	 * Signs a user up for an event, or updates their status if they previously
	 * signed off.
	 * 
	 * @param userId  The ID of the user.
	 * @param eventId The ID of the event.
	 */
	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		logger.debug("Signing up user {} for event {}", userId, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setInt(2, eventId);
			pstmt.executeUpdate();
			logger.info("User {} successfully signed up for event {}", userId, eventId);
		} catch (SQLException e) {
			logger.error("SQL error during event sign-up for user {} and event {}", userId, eventId, e);
		}
	}

	/**
	 * Signs a user off from an event.
	 * 
	 * @param userId  The ID of the user.
	 * @param eventId The ID of the event.
	 */
	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		logger.debug("Signing off user {} from event {}", userId, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setInt(2, eventId);
			pstmt.executeUpdate();
			logger.info("User {} successfully signed off from event {}", userId, eventId);
		} catch (SQLException e) {
			logger.error("SQL error during event sign-off for user {} and event {}", userId, eventId, e);
		}
	}

	/**
	 * Fetches a list of all users who have signed up for a specific event.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of User objects.
	 */
	public List<User> getSignedUpUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, u.role FROM users u JOIN event_attendance ea ON u.id = ea.user_id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching signed up users for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next())
					users.add(mapResultSetToSimpleUser(rs));
			}
			logger.info("Found {} signed-up users for event ID: {}", users.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching signed-up users for event ID: {}", eventId, e);
		}
		return users;
	}

	/**
	 * Fetches detailed attendance information for an event, including signup and
	 * commitment status.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of EventAttendance objects.
	 */
	public List<EventAttendance> getAttendanceDetailsForEvent(int eventId) {
		List<EventAttendance> attendances = new ArrayList<>();
		String sql = "SELECT u.id, u.username, ea.signup_status, ea.commitment_status FROM event_attendance ea JOIN users u ON ea.user_id = u.id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching attendance details for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventAttendance attendance = new EventAttendance();
					attendance.setUserId(rs.getInt("id"));
					attendance.setUsername(rs.getString("username"));
					attendance.setSignupStatus(rs.getString("signup_status"));
					attendance.setCommitmentStatus(rs.getString("commitment_status"));
					attendances.add(attendance);
				}
			}
			logger.info("Found {} attendance detail records for event ID: {}", attendances.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching attendance details for event ID: {}", eventId, e);
		}
		return attendances;
	}

	/**
	 * Updates the commitment status (e.g., 'BESTÄTIGT') for a user's attendance at
	 * an event.
	 * 
	 * @param eventId The ID of the event.
	 * @param userId  The ID of the user.
	 * @param status  The new commitment status.
	 * @return true if the update was successful.
	 */
	public boolean updateCommitmentStatus(int eventId, int userId, String status) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Updating commitment status for event {}, user {} to '{}'", eventId, userId, status);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error while updating commitment status for event {}, user {}", eventId, userId, e);
		}
		return false;
	}

	/**
	 * Fetches all skill requirements (required courses and number of people) for an
	 * event.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of SkillRequirement objects.
	 */
	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		List<SkillRequirement> requirements = new ArrayList<>();
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		logger.debug("Fetching skill requirements for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					SkillRequirement req = new SkillRequirement();
					req.setRequiredCourseId(rs.getInt("required_course_id"));
					req.setCourseName(rs.getString("course_name"));
					req.setRequiredPersons(rs.getInt("required_persons"));
					requirements.add(req);
				}
			}
			logger.info("Found {} skill requirements for event ID: {}", requirements.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching skill requirements for event ID: {}", eventId, e);
		}
		return requirements;
	}

	/**
	 * Saves the skill requirements for an event in a single transaction. It first
	 * deletes all existing requirements for the event, then inserts the new ones.
	 * 
	 * @param eventId           The ID of the event.
	 * @param requiredCourseIds An array of course IDs.
	 * @param requiredPersons   An array of the number of people required for each
	 *                          course.
	 */
	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		String deleteSql = "DELETE FROM event_skill_requirements WHERE event_id = ?";
		String insertSql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons, skill_name) VALUES (?, ?, ?, ?)";
		logger.debug("Saving skill requirements for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection()) {
			conn.setAutoCommit(false); // Start transaction
			try (PreparedStatement deletePstmt = conn.prepareStatement(deleteSql)) {
				deletePstmt.setInt(1, eventId);
				deletePstmt.executeUpdate();
			}
			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				try (PreparedStatement insertPstmt = conn.prepareStatement(insertSql)) {
					for (int i = 0; i < requiredCourseIds.length; i++) {
						if (requiredCourseIds[i] == null || requiredCourseIds[i].isEmpty()
								|| "0".equals(requiredPersons[i]))
							continue;
						insertPstmt.setInt(1, eventId);
						insertPstmt.setInt(2, Integer.parseInt(requiredCourseIds[i]));
						insertPstmt.setInt(3, Integer.parseInt(requiredPersons[i]));
						insertPstmt.setString(4, "Default");
						insertPstmt.addBatch();
					}
					insertPstmt.executeBatch();
				}
			}
			conn.commit(); // Commit transaction
			logger.info("Successfully saved skill requirements for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException e) {
			logger.error("Transaction error during saving skill requirements for event ID: {}.", eventId, e);
			// In a real app, you would handle transaction rollback here.
		}
	}

	/**
	 * Fetches a list of users who have been definitively assigned to an event's
	 * final team.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of assigned User objects.
	 */
	public List<User> getAssignedUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, u.role FROM users u "
				+ "JOIN event_assignments ea ON u.id = ea.user_id WHERE ea.event_id = ?";
		logger.debug("Fetching assigned users for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					users.add(mapResultSetToSimpleUser(rs));
				}
			}
			logger.info("Found {} assigned users for event ID: {}", users.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching assigned users for event ID: {}", eventId, e);
		}
		return users;
	}

	/**
	 * Saves the final assignment of users to an event. This is a transactional
	 * operation: it first clears all existing assignments for the event and then
	 * inserts the new ones.
	 * 
	 * @param eventId The ID of the event.
	 * @param userIds An array of user IDs to be assigned.
	 */
	public void assignUsersToEvent(int eventId, String[] userIds) {
		String deleteSql = "DELETE FROM event_assignments WHERE event_id = ?";
		String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning users to event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection()) {
			conn.setAutoCommit(false); // Start transaction

			// 1. Delete all previous assignments for this event
			try (PreparedStatement deletePstmt = conn.prepareStatement(deleteSql)) {
				deletePstmt.setInt(1, eventId);
				deletePstmt.executeUpdate();
			}

			// 2. Insert the new assignments if any users were selected
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertPstmt = conn.prepareStatement(insertSql)) {
					for (String userId : userIds) {
						insertPstmt.setInt(1, eventId);
						insertPstmt.setInt(2, Integer.parseInt(userId));
						insertPstmt.addBatch();
					}
					insertPstmt.executeBatch();
				}
			}

			conn.commit(); // Commit transaction
			logger.info("Successfully assigned {} users to event ID {}", (userIds != null ? userIds.length : 0),
					eventId);

		} catch (SQLException | NumberFormatException e) {
			logger.error("SQL transaction error during user assignment for event ID: {}", eventId, e);
			// In a real app, you would handle transaction rollback here.
		}
	}

	/**
	 * Fetches all upcoming events for a user, with a calculated status that
	 * prioritizes assignments over simple sign-ups. Status can be: ZUGEWIESEN,
	 * ANGEMELDET, ABGEMELDET, or OFFEN.
	 *
	 * @param user  The currently logged-in user.
	 * @param limit The maximum number of events to return (0 for no limit).
	 * @return A list of upcoming Event objects with the correctly calculated user
	 *         status.
	 */
	public List<Event> getUpcomingEventsForUser(User user, int limit) {
		List<Event> events = new ArrayList<>();

		// This intelligent SQL query calculates the most relevant status for the user.
		// It prioritizes "ZUGEWIESEN" (assigned) over "ANGEMELDET" (signed up).
		String sql = "SELECT e.*, " + "CASE " + "    WHEN eas.user_id IS NOT NULL THEN 'ZUGEWIESEN' " + // 1. Check for
																										// assignment
																										// first
				"    WHEN ea.signup_status IS NOT NULL THEN ea.signup_status " + // 2. Fall back to signup status
				"    ELSE 'OFFEN' " + // 3. Default to open
				"END AS calculated_user_status " + "FROM events e "
				+ "LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.user_id = ? "
				+ "LEFT JOIN event_assignments eas ON e.id = eas.event_id AND eas.user_id = ? "
				+ "WHERE e.event_datetime >= NOW() " + "AND (" + // Qualification check remains the same
				"  NOT EXISTS (SELECT 1 FROM event_skill_requirements esr WHERE esr.event_id = e.id) OR "
				+ "  EXISTS (SELECT 1 FROM event_skill_requirements esr JOIN user_qualifications uq ON esr.required_course_id = uq.course_id WHERE esr.event_id = e.id AND uq.user_id = ?)"
				+ ") " + "ORDER BY e.event_datetime ASC" + (limit > 0 ? " LIMIT ?" : "");

		logger.debug("Fetching upcoming events for user ID: {} with limit: {}", user.getId(), limit);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			// Set the user ID for all three placeholders in the query
			pstmt.setInt(1, user.getId());
			pstmt.setInt(2, user.getId());
			pstmt.setInt(3, user.getId());
			if (limit > 0) {
				pstmt.setInt(4, limit);
			}

			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Event event = mapResultSetToEvent(rs); // Use your existing helper

					// Get the final calculated status from our new CASE statement
					String finalStatus = rs.getString("calculated_user_status");
					event.setUserAttendanceStatus(finalStatus);

					events.add(event);
				}
				logger.info("Found {} qualified upcoming events for user ID {}", events.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualified upcoming events for user {}", user.getId(), e);
		}
		return events;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for managing event-specific tasks in the `event_tasks`
 * table. It handles creating, assigning, updating status, and deleting tasks
 * associated with a "running" event.
 */
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);

	/**
	 * Creates a new task for an event.
	 * 
	 * @param task The EventTask object to create.
	 * @return The ID of the newly created task, or 0 on failure.
	 */
	public int createTask(EventTask task) {
		String sql = "INSERT INTO event_tasks (event_id, description, status) VALUES (?, ?, 'OFFEN')";
		logger.debug("Creating new task '{}' for event ID {}", task.getDescription(), task.getEventId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setInt(1, task.getEventId());
			pstmt.setString(2, task.getDescription());
			if (pstmt.executeUpdate() > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int taskId = rs.getInt(1);
						logger.info("Created task '{}' with ID {} for event {}", task.getDescription(), taskId,
								task.getEventId());
						return taskId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating task for event {}", task.getEventId(), e);
		}
		return 0;
	}

	/**
	 * Assigns a task to one or more users. This is a transactional operation that
	 * first clears all existing assignments for the task and then adds the new
	 * ones.
	 * 
	 * @param taskId  The ID of the task.
	 * @param userIds The array of user IDs to assign to the task.
	 */
	public void assignTaskToUsers(int taskId, int[] userIds) {
		// Transactional: clear old assignments, add new ones.
		String deleteSql = "DELETE FROM event_task_assignments WHERE task_id = ?";
		String insertSql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning task ID {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		try (Connection conn = DatabaseManager.getConnection()) {
			conn.setAutoCommit(false); // Start transaction
			// 1. Delete old assignments
			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, taskId);
				deleteStmt.executeUpdate();
			}
			// 2. Insert new assignments
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (int userId : userIds) {
						insertStmt.setInt(1, taskId);
						insertStmt.setInt(2, userId);
						insertStmt.addBatch();
					}
					insertStmt.executeBatch();
				}
			}
			conn.commit(); // Commit transaction
			logger.info("Successfully assigned task {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		} catch (SQLException e) {
			logger.error("Error during transaction for assigning task {}", taskId, e);
			// Consider rollback logic here if connection is not auto-closed with
			// try-with-resources
		}
	}

	/**
	 * Updates the status of a task (e.g., from "OFFEN" to "ERLEDIGT").
	 * 
	 * @param taskId The ID of the task.
	 * @param status The new status string.
	 * @return true if the update was successful.
	 */
	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		logger.debug("Updating status for task ID {} to '{}'", taskId, status);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Deletes a task and its assignments (due to database foreign key constraints).
	 * 
	 * @param taskId The ID of the task to delete.
	 * @return true if successful.
	 */
	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		logger.warn("Attempting to delete task with ID: {}", taskId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Fetches all tasks for a given event, including a comma-separated list of
	 * usernames of assigned users for easy display.
	 * 
	 * @param eventId The event's ID.
	 * @return A list of EventTask objects.
	 */
	public List<EventTask> getTasksForEvent(int eventId) {
		List<EventTask> tasks = new ArrayList<>();
		// This query uses GROUP_CONCAT to aggregate assigned usernames into a single
		// string
		String sql = "SELECT t.id, t.event_id, t.description, t.status, "
				+ "GROUP_CONCAT(u.username SEPARATOR ', ') as assigned_usernames " + "FROM event_tasks t "
				+ "LEFT JOIN event_task_assignments ta ON t.id = ta.task_id "
				+ "LEFT JOIN users u ON ta.user_id = u.id " + "WHERE t.event_id = ? "
				+ "GROUP BY t.id, t.event_id, t.description, t.status " + "ORDER BY t.id";
		logger.debug("Fetching all tasks for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setAssignedUsernames(rs.getString("assigned_usernames"));
					tasks.add(task);
				}
				logger.info("Found {} tasks for event ID: {}", tasks.size(), eventId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching tasks for event {}", eventId, e);
		}
		return tasks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * This DAO manages metadata of uploaded files stored in the `files` and
 * `file_categories` tables. It handles creating, reading, and deleting file
 * records and categories. It includes role-based filtering to control file
 * visibility and logic to group files by category for display in the UI. It
 * also provides methods to manage a simple key-value content store in the
 * `shared_documents` table.
 */
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);

	/**
	 * Helper method to map a row from a ResultSet to a File object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated File object.
	 * @throws SQLException If a database error occurs.
	 */
	private File mapResultSetToFile(ResultSet rs) throws SQLException {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));

		if (hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}

		String categoryName = rs.getString("category_name");
		file.setCategoryName(categoryName == null ? "Ohne Kategorie" : categoryName);

		return file;
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Fetches all file records, applying role-based filtering, and groups them by
	 * category name.
	 * 
	 * @param user The current user, used to determine their role.
	 * @return A Map where keys are category names and values are lists of files.
	 */
	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		logger.debug("Fetching all files grouped by category for user role: {}", user.getRole());
		List<File> files = new ArrayList<>();

		String sql = "SELECT f.*, fc.name as category_name FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id ";

		if (!"ADMIN".equalsIgnoreCase(user.getRole())) {
			sql += "WHERE f.required_role = 'NUTZER' ";
			logger.debug("Applying 'NUTZER' role filter for file query.");
		}

		sql += "ORDER BY fc.name, f.filename";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				files.add(mapResultSetToFile(rs));
			}
			logger.info("Fetched {} files visible to user role '{}'.", files.size(), user.getRole());
		} catch (SQLException e) {
			logger.error("SQL error while fetching files.", e);
		}

		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	/**
	 * Creates a new file metadata record in the database.
	 * 
	 * @param file The File object to persist.
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Creating file record for '{}' with role '{}'", file.getFilename(), file.getRequiredRole());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			if (file.getCategoryId() > 0) {
				pstmt.setInt(3, file.getCategoryId());
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setString(4, file.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file record for '{}'", file.getFilename(), e);
			return false;
		}
	}

	/**
	 * Fetches all file categories from the database, sorted by name.
	 * 
	 * @return A list of FileCategory objects.
	 */
	public List<FileCategory> getAllCategories() {
		List<FileCategory> categories = new ArrayList<>();
		String sql = "SELECT * FROM file_categories ORDER BY name";
		logger.debug("Fetching all file categories.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				categories.add(cat);
			}
			logger.info("Fetched {} file categories.", categories.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching file categories.", e);
		}
		return categories;
	}

	/**
	 * Retrieves a single file's metadata by its ID.
	 *
	 * @param fileId The ID of the file to retrieve.
	 * @return A File object populated with data, or null if not found.
	 */
	public File getFileById(int fileId) {
		logger.debug("Fetching file by ID: {}", fileId);
		String sql = "SELECT f.*, fc.name as category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id " + "WHERE f.id = ?";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found file with ID: {}", fileId);
					return mapResultSetToFile(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching file with ID: {}", fileId, e);
		}

		logger.warn("No file found with ID: {}", fileId);
		return null;
	}

	/**
	 * Deletes a file record from the 'files' table in the database. Note: This
	 * method ONLY deletes the database record. The physical file must be deleted
	 * separately by the calling servlet.
	 *
	 * @param fileId The ID of the file record to delete.
	 * @return true if the database record was successfully deleted, false
	 *         otherwise.
	 */
	public boolean deleteFile(int fileId) {
		logger.warn("Attempting to delete file record from database with ID: {}", fileId);
		String sql = "DELETE FROM files WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				logger.info("Successfully deleted file record with ID: {}", fileId);
				return true;
			} else {
				logger.warn("Could not delete file record with ID: {}. It might not exist.", fileId);
				return false;
			}
		} catch (SQLException e) {
			logger.error("SQL error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	/**
	 * Creates a new file category.
	 * 
	 * @param categoryName The name of the new category.
	 * @return true if successful.
	 */
	public boolean createCategory(String categoryName) {
		logger.info("Creating new file category: {}", categoryName);
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, categoryName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	/**
	 * Updates the name of an existing file category.
	 * 
	 * @param categoryId The ID of the category to update.
	 * @param newName    The new name for the category.
	 * @return true if successful.
	 */
	public boolean updateCategory(int categoryId, String newName) {
		String sql = "UPDATE file_categories SET name = ? WHERE id = ?";
		logger.debug("Updating category ID {} to new name '{}'", categoryId, newName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newName);
			pstmt.setInt(2, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Deletes a file category. Due to "ON DELETE SET NULL" constraint in the DB,
	 * files in this category will have their category_id set to NULL.
	 * 
	 * @param categoryId The ID of the category to delete.
	 * @return true if successful.
	 */
	public boolean deleteCategory(int categoryId) {
		logger.warn("Attempting to delete category ID: {}", categoryId);
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Retrieves the name of a category by its ID.
	 * 
	 * @param categoryId The ID of the category.
	 * @return The category name, or null if not found.
	 */
	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		logger.debug("Fetching category name for ID: {}", categoryId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("name");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
		}
		return null;
	}

	/**
	 * Retrieves the content of a shared document (e.g., for the collaborative
	 * editor).
	 * 
	 * @param documentName The unique name/key of the document.
	 * @return The document's content as a string, or an empty string if not found.
	 */
	public String getDocumentContent(String documentName) {
		String sql = "SELECT content FROM shared_documents WHERE document_name = ?";
		logger.trace("Fetching document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("content");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching document content for name: {}", documentName, e);
		}
		return "";
	}

	/**
	 * Updates the content of a shared document.
	 * 
	 * @param documentName The unique name/key of the document to update.
	 * @param content      The new content to save.
	 * @return true if the update was successful.
	 */
	public boolean updateDocumentContent(String documentName, String content) {
		String sql = "UPDATE shared_documents SET content = ? WHERE document_name = ?";
		logger.trace("Updating document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, content);
			pstmt.setString(2, documentName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating document content for name: {}", documentName, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing file attachments for meetings, interacting with the
 * `meeting_attachments` table. It handles adding, retrieving (with role-based
 * filtering), and deleting file attachments associated with a specific meeting.
 */
public class MeetingAttachmentDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttachmentDAO.class);

	/**
	 * Attaches a file to a meeting by creating a record in the database.
	 * 
	 * @param attachment The MeetingAttachment object to persist.
	 * @return true if the record was successfully created.
	 */
	public boolean addAttachment(MeetingAttachment attachment) {
		String sql = "INSERT INTO meeting_attachments (meeting_id, filename, filepath, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to meeting ID {}", attachment.getFilename(), attachment.getMeetingId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachment.getMeetingId());
			pstmt.setString(2, attachment.getFilename());
			pstmt.setString(3, attachment.getFilepath());
			pstmt.setString(4, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to meeting {}", attachment.getMeetingId(), e);
			return false;
		}
	}

	/**
	 * Gets all attachments for a specific meeting, optionally filtering by user
	 * role. Admins see all files, while regular users only see files marked as
	 * 'NUTZER'.
	 * 
	 * @param meetingId The ID of the meeting.
	 * @param userRole  The role of the current user ("ADMIN" or "NUTZER").
	 * @return A list of MeetingAttachment objects.
	 */
	public List<MeetingAttachment> getAttachmentsForMeeting(int meetingId, String userRole) {
		List<MeetingAttachment> attachments = new ArrayList<>();

		String sql = "SELECT * FROM meeting_attachments WHERE meeting_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
			logger.debug("Fetching attachments for meeting {} with NUTZER role filter.", meetingId);
		} else {
			logger.debug("Fetching attachments for meeting {} with ADMIN role (no filter).", meetingId);
		}

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setMeetingId(rs.getInt("meeting_id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
					att.setRequiredRole(rs.getString("required_role"));
					attachments.add(att);
				}
				logger.info("Found {} attachments for meeting ID {}.", attachments.size(), meetingId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for meeting {}", meetingId, e);
		}
		return attachments;
	}

	/**
	 * Gets a single attachment by its ID, without any role check. This is typically
	 * used internally by admin functions like deletion.
	 * 
	 * @param attachmentId The ID of the attachment.
	 * @return A MeetingAttachment object or null if not found.
	 */
	public MeetingAttachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM meeting_attachments WHERE id = ?";
		logger.debug("Fetching attachment by ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					return att;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		logger.warn("No attachment found for ID: {}", attachmentId);
		return null;
	}

	/**
	 * Deletes an attachment record from the database. The physical file must be
	 * deleted separately.
	 * 
	 * @param attachmentId The ID of the attachment to delete.
	 * @return true if successful.
	 */
	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM meeting_attachments WHERE id = ?";
		logger.warn("Attempting to delete attachment with ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling user attendance at specific course meetings.
 * It interacts with the `meeting_attendance` table to record whether a user
 * attended a meeting, along with any relevant remarks.
 */
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class.getName());

	/**
	 * Sets or updates a user's attendance status for a specific meeting. Uses an
	 * efficient "INSERT ... ON DUPLICATE KEY UPDATE" (upsert) operation. This
	 * single method handles both signing up (attended=true) and signing off
	 * (attended=false).
	 *
	 * @param userId    The user's ID.
	 * @param meetingId The meeting's ID.
	 * @param attended  true if the user attended, false otherwise.
	 * @param remarks   Any notes about the attendance (e.g., "excused absence").
	 * @return true if the operation was successful.
	 */
	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";

		logger.debug("Setting attendance for user {} at meeting {} to attended={}", userId, meetingId, attended);

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			pstmt.setInt(2, meetingId);
			pstmt.setBoolean(3, attended);
			pstmt.setString(4, remarks);

			pstmt.executeUpdate();
			logger.info("Successfully set attendance for user {} at meeting {} to attended={}", userId, meetingId,
					attended);
			return true;

		} catch (SQLException e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all attendance records from the database. This is highly efficient
	 * for building the data map used by the qualification matrix view.
	 * 
	 * @return A list of all MeetingAttendance objects in the database.
	 */
	public List<MeetingAttendance> getAllAttendance() {
		List<MeetingAttendance> allAttendance = new ArrayList<>();
		String sql = "SELECT * FROM meeting_attendance";
		logger.debug("Fetching all meeting attendance records for matrix.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				allAttendance.add(mapResultSetToAttendance(rs));
			}
			logger.info("Fetched {} total attendance records.", allAttendance.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all attendance records.", e);
		}
		return allAttendance;
	}

	/**
	 * Helper method to map a ResultSet row to a MeetingAttendance object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated MeetingAttendance object.
	 * @throws SQLException If a database error occurs.
	 */
	private MeetingAttendance mapResultSetToAttendance(ResultSet rs) throws SQLException {
		MeetingAttendance attendance = new MeetingAttendance();
		attendance.setUserId(rs.getInt("user_id"));
		attendance.setMeetingId(rs.getInt("meeting_id"));
		attendance.setAttended(rs.getBoolean("attended"));
		attendance.setRemarks(rs.getString("remarks"));
		return attendance;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;

/**
 * Data Access Object for all Meeting-related database operations. It handles
 * CRUD for individual, schedulable course meetings stored in the `meetings`
 * table. It's distinct from CourseDAO, which manages the parent course
 * templates.
 */
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);

	/**
	 * Creates a new meeting in the database, linked to a parent course.
	 * 
	 * @param meeting The Meeting object to create.
	 * @return The ID of the newly created meeting, or 0 on failure.
	 */
	public int createMeeting(Meeting meeting) { // FIX: Changed return type from boolean to int
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader, description) VALUES (?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create meeting '{}' for course ID {}", meeting.getName(), meeting.getCourseId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) { // FIX: Added
																											// RETURN_GENERATED_KEYS

			pstmt.setInt(1, meeting.getCourseId());
			pstmt.setString(2, meeting.getName());
			pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(4, Types.TIMESTAMP);
			}
			pstmt.setString(5, meeting.getLeader());
			pstmt.setString(6, meeting.getDescription());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				// FIX: Retrieve and return the new ID
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int newId = rs.getInt(1);
						logger.info("Successfully created meeting '{}' with new ID {}", meeting.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating meeting: {}", meeting.getName(), e);
		}
		return 0; // Return 0 on failure
	}

	/**
	 * Fetches a single meeting by its ID, joining with the courses table to get the
	 * parent course name.
	 * 
	 * @param meetingId The ID of the meeting to retrieve.
	 * @return A Meeting object, or null if not found.
	 */
	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id WHERE m.id = ?";
		logger.debug("Fetching meeting by ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found meeting with ID: {}", meetingId);
					return mapResultSetToMeeting(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meeting by ID: {}", meetingId, e);
		}
		logger.warn("No meeting found with ID: {}", meetingId);
		return null;
	}

	/**
	 * Fetches all scheduled meetings that belong to a specific parent course.
	 * Crucial for building the qualification matrix view.
	 * 
	 * @param courseId The ID of the parent course.
	 * @return A list of Meeting objects, sorted by date.
	 */
	public List<Meeting> getMeetingsForCourse(int courseId) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name FROM meetings m JOIN courses c ON m.course_id = c.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		logger.debug("Fetching all meetings for course ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					meetings.add(mapResultSetToMeeting(rs));
				}
				logger.info("Found {} meetings for course ID: {}", meetings.size(), courseId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meetings for course ID: {}", courseId, e);
		}
		return meetings;
	}

	/**
	 * Fetches all meetings from the database, typically for an admin list view.
	 * Includes the parent course name.
	 * 
	 * @return A list of all Meeting objects.
	 */
	public List<Meeting> getAllMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id ORDER BY m.meeting_datetime DESC";
		logger.debug("Fetching all meetings from the database.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
			logger.info("Fetched a total of {} meetings.", meetings.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all meetings.", e);
		}
		return meetings;
	}

	/**
	 * Helper method to map a row from a ResultSet to a Meeting object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Meeting object.
	 * @throws SQLException If a database error occurs.
	 */
	private Meeting mapResultSetToMeeting(ResultSet rs) throws SQLException {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		meeting.setLeader(rs.getString("leader"));
		meeting.setDescription(rs.getString("description"));

		// If the parent course name was joined, add it.
		// A more robust check for the column's existence
		ResultSetMetaData rsmd = rs.getMetaData();
		for (int i = 1; i <= rsmd.getColumnCount(); i++) {
			if ("parent_course_name".equalsIgnoreCase(rsmd.getColumnName(i))) {
				meeting.setParentCourseName(rs.getString("parent_course_name"));
				break;
			}
		}

		return meeting;
	}

	/**
	 * Updates an existing meeting in the database.
	 * 
	 * @param meeting The Meeting object with updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader = ?, description = ? WHERE id = ?";
		logger.debug("Attempting to update meeting ID: {}", meeting.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, meeting.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			pstmt.setString(4, meeting.getLeader());
			pstmt.setString(5, meeting.getDescription());
			pstmt.setInt(6, meeting.getId());

			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated meeting with ID: {}", meeting.getId());
			return success;

		} catch (SQLException e) {
			logger.error("SQL error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a meeting from the database.
	 * 
	 * @param meetingId The ID of the meeting to delete.
	 * @return true if deletion was successful.
	 */
	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		logger.warn("Attempting to delete meeting with ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully deleted meeting with ID: {}", meetingId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all upcoming meetings, enriched with the attendance status for a
	 * specific user (ANGEMELDET, ABGEMELDET, OFFEN).
	 * 
	 * @param user The currently logged-in user.
	 * @return A list of upcoming Meeting objects with user-specific status.
	 */
	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, ma.attended " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? "
				+ "WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";

		logger.debug("Fetching upcoming meetings for user ID: {}", user.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, user.getId());
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Meeting meeting = mapResultSetToMeeting(rs);

					// Set the user-specific status based on the 'attended' flag from the join
					if (rs.getObject("attended") != null) {
						meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
					} else {
						meeting.setUserAttendanceStatus("OFFEN");
					}
					meetings.add(meeting);
				}
				logger.info("Found {} upcoming meetings for user ID: {}", meetings.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for user {}", user.getId(), e);
		}
		return meetings;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * A simple Data Access Object used to retrieve basic aggregate numbers from the
 * database, such as the total count of users and the number of active, upcoming
 * events. This is primarily used for the administrative dashboard.
 */

public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);

	/**
	 * Gets the total count of all users in the `users` table.
	 * 
	 * @return The total number of users.
	 */
	public int getUserCount() {
		logger.debug("Getting user count.");
		return getCount("SELECT COUNT(*) FROM users");
	}

	/**
	 * Gets the count of all events that are not yet in the past.
	 * 
	 * @return The number of active/upcoming events.
	 */
	public int getActiveEventCount() {
		logger.debug("Getting active event count.");
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	/**
	 * A generic helper method to execute a `SELECT COUNT(*)` query.
	 * 
	 * @param sql The SQL query to execute.
	 * @return The count, or 0 if an error occurs.
	 */
	private int getCount(String sql) {
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			if (rs.next()) {
				int count = rs.getInt(1);
				logger.info("Count query '{}' returned {}.", sql, count);
				return count;
			}
		} catch (SQLException e) {
			logger.error("SQL error executing count query: {}", sql, e);
		}
		return 0;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Data Access Object for managing inventory in the `storage_items` table. It
 * handles full CRUD operations for storage items and provides methods for
 * quantity adjustments and grouping items by location for display.
 */
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class.getName());

	/**
	 * Fetches all storage items and groups them by their 'location' field.
	 * 
	 * @return A Map where keys are location names and values are lists of items in
	 *         that location.
	 */
	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		logger.debug("Fetching all storage items, grouped by location.");
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items ORDER BY location, cabinet, shelf, name";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
			logger.info("Successfully fetched {} storage items from database.", items.size());
		} catch (SQLException e) {
			logger.error("SQL error while fetching storage items.", e);
		}

		// Group the flat list of items into a map using Java Streams
		return items.stream().collect(Collectors.groupingBy(StorageItem::getLocation));
	}

	/**
	 * Helper method to map a row from a ResultSet to a StorageItem object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated StorageItem object.
	 * @throws SQLException If a database error occurs.
	 */
	private StorageItem mapResultSetToStorageItem(ResultSet rs) throws SQLException {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setShelf(rs.getString("shelf"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setImagePath(rs.getString("image_path"));
		return item;
	}

	/**
	 * Fetches a single storage item by its unique ID.
	 * 
	 * @param itemId The ID of the item to fetch.
	 * @return A StorageItem object, or null if not found.
	 */
	public StorageItem getItemById(int itemId) {
		String sql = "SELECT * FROM storage_items WHERE id = ?";
		logger.debug("Fetching storage item by ID: {}", itemId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			ResultSet rs = pstmt.executeQuery();
			if (rs.next()) {
				logger.info("Found storage item '{}' with ID: {}", rs.getString("name"), itemId);
				return mapResultSetToStorageItem(rs);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage item by ID: {}", itemId, e);
		}
		logger.warn("No storage item found with ID: {}", itemId);
		return null;
	}

	/**
	 * Creates a new storage item in the database.
	 * 
	 * @param item The StorageItem object to persist.
	 * @return true if the creation was successful.
	 */
	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, shelf, compartment, quantity, max_quantity, image_path) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Creating new storage item: {}", item.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getShelf());
			pstmt.setString(5, item.getCompartment());
			pstmt.setInt(6, item.getQuantity());
			pstmt.setInt(7, item.getMaxQuantity());
			pstmt.setString(8, item.getImagePath());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	/**
	 * Updates all fields of an existing storage item.
	 * 
	 * @param item The StorageItem object with the new data.
	 * @return true if the update was successful.
	 */
	public boolean updateItem(StorageItem item) {
		logger.debug("DAO: Preparing to update item ID: {}. Values -> Name: '{}', Quantity: {}, MaxQuantity: {}",
				item.getId(), item.getName(), item.getQuantity(), item.getMaxQuantity());
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, shelf=?, compartment=?, quantity=?, max_quantity=?, image_path=? WHERE id=?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getShelf());
			pstmt.setString(5, item.getCompartment());
			pstmt.setInt(6, item.getQuantity());
			pstmt.setInt(7, item.getMaxQuantity());
			pstmt.setString(8, item.getImagePath());
			pstmt.setInt(9, item.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	/**
	 * Atomically updates the quantity of an item by a given amount (can be
	 * negative). Ensures that the quantity never drops below zero.
	 * 
	 * @param itemId         The ID of the item to update.
	 * @param quantityChange The amount to add (positive) or remove (negative).
	 * @return true if the update was successful.
	 * @throws SQLException if a database error occurs.
	 */
	public boolean updateItemQuantity(int itemId, int quantityChange) throws SQLException {
		String sql = "UPDATE storage_items SET quantity = quantity + ? WHERE id = ? AND quantity + ? >= 0";
		logger.debug("Attempting to change quantity for item ID {} by {}", itemId, quantityChange);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantityChange);
			pstmt.setInt(2, itemId);
			pstmt.setInt(3, quantityChange);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				logger.info("Successfully changed quantity for item {} by {}", itemId, quantityChange);
				return true;
			} else {
				logger.warn("Failed to update quantity for item {}. Not enough stock or item not found.", itemId);
				return false;
			}
		}
	}

	/**
	 * Deletes a storage item from the database.
	 * 
	 * @param itemId The ID of the item to delete.
	 * @return true if deletion was successful.
	 */
	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		logger.warn("Attempting to delete storage item with ID: {}", itemId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;

/**
 * Data Access Object for logging storage item transactions (check-ins and
 * check-outs) into the `storage_log` table. This provides a history of
 * inventory movements.
 */
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);

	/**
	 * Logs a single transaction (check-in or check-out) to the database.
	 * 
	 * @param itemId         The ID of the item involved in the transaction.
	 * @param userId         The ID of the user performing the transaction.
	 * @param quantityChange The number of items moved (positive for check-in,
	 *                       negative for check-out).
	 * @param notes          Optional notes for the transaction (e.g., purpose,
	 *                       event).
	 * @return true if the log entry was created successfully.
	 */
	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes) VALUES (?, ?, ?, ?)";
		logger.debug("Logging storage transaction for item {}, user {}, change {}", itemId, userId, quantityChange);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, quantityChange);
			pstmt.setString(4, notes);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Failed to log storage transaction for item {}", itemId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.User;

/**
 * A core DAO responsible for all user account management, interacting with the
 * `users` table. Its functions include validating user credentials for login,
 * fetching single or all user records, creating, updating, and deleting users,
 * and handling password changes.
 */
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);

	/**
	 * Helper method to check if a ResultSet contains a certain column,
	 * case-insensitive.
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists.
	 * @throws SQLException if a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Robustly maps a ResultSet row to a User object, checking for optional columns
	 * before attempting to read them.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated User object.
	 * @throws SQLException if a database error occurs.
	 */
	private User mapResultSetToUser(ResultSet rs) throws SQLException {
		User user = new User(rs.getInt("id"), rs.getString("username"), rs.getString("role"));
		if (hasColumn(rs, "created_at") && rs.getTimestamp("created_at") != null) {
			user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		}
		if (hasColumn(rs, "class_year")) {
			user.setClassYear(rs.getInt("class_year"));
		}
		if (hasColumn(rs, "class_name")) {
			user.setClassName(rs.getString("class_name"));
		}
		return user;
	}

	/**
	 * Validates user credentials against the database. IMPORTANT: This
	 * implementation uses plaintext passwords for validation, which is insecure and
	 * should be replaced with a password hashing mechanism (e.g., BCrypt) in a
	 * production environment.
	 * 
	 * @param username The user's username.
	 * @param password The user's plaintext password.
	 * @return A User object if validation is successful, null otherwise.
	 */
	public User validateUser(String username, String password) {
		String sql = "SELECT * FROM users WHERE username = ? AND password_hash = ?";
		logger.debug("Validating user credentials for username: {}", username);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, username);
			pstmt.setString(2, password);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("User validation successful for username: {}", username);
					return mapResultSetToUser(rs);
				} else {
					logger.warn("User validation failed for username: {}", username);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	/**
	 * Fetches all users from the database, sorted by username.
	 * 
	 * @return A list of all User objects.
	 */
	public List<User> getAllUsers() {
		List<User> users = new ArrayList<>();
		String sql = "SELECT * FROM users ORDER BY username";
		logger.debug("Fetching all users.");
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			while (rs.next()) {
				users.add(mapResultSetToUser(rs));
			}
			logger.info("Fetched {} total users.", users.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all users", e);
		}
		return users;
	}

	/**
	 * Fetches a single user by their unique ID.
	 * 
	 * @param userId The ID of the user to fetch.
	 * @return A User object, or null if not found.
	 */
	public User getUserById(int userId) {
		String sql = "SELECT * FROM users WHERE id = ?";
		logger.debug("Fetching user by ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found user '{}' with ID: {}", rs.getString("username"), userId);
					return mapResultSetToUser(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching user by ID: {}", userId, e);
		}
		logger.warn("No user found with ID: {}", userId);
		return null;
	}

	/**
	 * Creates a new user in the database.
	 * 
	 * @param user     The User object containing the data to be inserted.
	 * @param password The plain text password (should be hashed in production).
	 * @return The ID of the newly created user, or 0 if creation failed.
	 */
	public int createUser(User user, String password) {
		String sql = "INSERT INTO users (username, password_hash, role, class_year, class_name) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Attempting to create user: {}", user.getUsername());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

			pstmt.setString(1, user.getUsername());
			pstmt.setString(2, password); // In a real app, this should be a hash.
			pstmt.setString(3, user.getRole());
			pstmt.setInt(4, user.getClassYear());
			pstmt.setString(5, user.getClassName());

			int affectedRows = pstmt.executeUpdate();

			if (affectedRows > 0) {
				try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newUserId = generatedKeys.getInt(1);
						logger.info("Successfully created user '{}' with ID: {}", user.getUsername(), newUserId);
						return newUserId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating user '{}'. Username might already exist.", user.getUsername(), e);
		}
		return 0;
	}

	/**
	 * Updates an existing user's profile information in the database.
	 * 
	 * @param user The User object containing the updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateUser(User user) {
		logger.debug("Updating user with ID: {}", user.getId());
		String sql = "UPDATE users SET username = ?, role = ?, class_year = ?, class_name = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, user.getUsername());
			pstmt.setString(2, user.getRole());
			pstmt.setInt(3, user.getClassYear());
			pstmt.setString(4, user.getClassName());
			pstmt.setInt(5, user.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a user from the database.
	 * 
	 * @param userId The ID of the user to delete.
	 * @return true if the deletion was successful.
	 */
	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		logger.warn("Attempting to delete user with ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	/**
	 * Changes a user's password.
	 * 
	 * @param userId      The ID of the user whose password is to be changed.
	 * @param newPassword The new plaintext password.
	 * @return true if the password was changed successfully.
	 */
	public boolean changePassword(int userId, String newPassword) {
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		logger.debug("Changing password for user ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newPassword); // Should be a hash in production.
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.UserQualification;

/**
 * This DAO manages the `user_qualifications` table, which links users to the
 * courses they have completed. It's used to track which skills a user
 * possesses. Its key functions are fetching qualifications for a single user or
 * all users, and updating a user's qualification status for a specific course.
 */
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);

	/**
	 * Fetches all qualifications for a single user. This is typically used for a
	 * user's profile or details page.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of UserQualification objects.
	 */
	public List<UserQualification> getQualificationsForUser(int userId) {
		logger.debug("Fetching qualifications for user ID: {}", userId);
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id " + "WHERE uq.user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					qualifications.add(mapResultSetToUserQualification(rs));
				}
				logger.info("Found {} qualifications for user ID: {}", qualifications.size(), userId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
		}
		return qualifications;
	}

	/**
	 * Fetches all qualification records for all users. This is used to build the
	 * data for an overview or matrix page.
	 * 
	 * @return A list of all UserQualification objects in the database.
	 */
	public List<UserQualification> getAllQualifications() {
		logger.debug("Fetching all user qualifications.");
		List<UserQualification> qualifications = new ArrayList<>();
		// This query needs the user_id to build a lookup map later.
		String sql = "SELECT uq.user_id, uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				qualifications.add(mapResultSetToUserQualification(rs));
			}
			logger.info("Fetched a total of {} qualification entries.", qualifications.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all qualifications.", e);
		}
		return qualifications;
	}

	/**
	 * Updates or creates a qualification status for a user and a course. If the
	 * status is set to "NICHT BESUCHT", the corresponding record is deleted.
	 * Otherwise, it performs an "upsert" (INSERT ... ON DUPLICATE KEY UPDATE) to
	 * create or modify the record. This is a key method for admin management of
	 * user skills.
	 * 
	 * @param userId         The ID of the user.
	 * @param courseId       The ID of the course.
	 * @param status         The new status ('BESUCHT', 'ABSOLVIERT', or 'NICHT
	 *                       BESUCHT').
	 * @param completionDate The date of completion (can be null).
	 * @param remarks        Additional remarks (can be null).
	 * @return true if the operation was successful, false otherwise.
	 */
	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		logger.debug("DAO: Updating qualification for user {}, course {}. New status: {}, Date: {}, Remarks: '{}'",
				userId, courseId, status, completionDate, remarks);

		if ("NICHT BESUCHT".equals(status)) {
			// If status is "Not Attended", we delete the record from the database.
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(deleteSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				int affectedRows = pstmt.executeUpdate();
				logger.info("Deleted qualification entry for user {} and course {}. Rows affected: {}", userId,
						courseId, affectedRows);
				return true; // The desired state is achieved, so return true.
			} catch (SQLException e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			// Otherwise, we insert a new record or update an existing one.
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) "
					+ "ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(upsertSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.setString(3, status);

				if (completionDate != null) {
					pstmt.setDate(4, Date.valueOf(completionDate));
				} else {
					pstmt.setNull(4, Types.DATE);
				}

				pstmt.setString(5, remarks);

				int affectedRows = pstmt.executeUpdate();
				logger.info("Upserted qualification for user {} and course {}. Rows affected: {}", userId, courseId,
						affectedRows);
				// Can return 0 (no change), 1 (insert), or 2 (update), so >= 0 is a good check
				// for success.
				return affectedRows >= 0;
			} catch (SQLException e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}

	// --- Helper Methods ---

	/**
	 * Maps a row from a ResultSet to a UserQualification object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated UserQualification object.
	 * @throws SQLException If a database error occurs.
	 */
	private UserQualification mapResultSetToUserQualification(ResultSet rs) throws SQLException {
		UserQualification uq = new UserQualification();
		// user_id is only present in the getAllQualifications query
		if (hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AdminFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.model.User;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * A security filter that protects all URLs under the `/admin/*` path. It
 * intercepts requests to these protected endpoints and checks if the user
 * object in the current session has the "ADMIN" role. If the user is not an
 * admin or is not logged in at all, it denies access and redirects them to an
 * appropriate page (login or home).
 */
@WebFilter(urlPatterns = "/admin/*", asyncSupported = true)
public class AdminFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AdminFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AdminFilter initialized and protecting /admin/* paths.");
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String path = request.getRequestURI().substring(request.getContextPath().length());

		logger.trace("AdminFilter is processing request for path: '{}'", path);

		// Check if the session exists AND if the user object is in the session.
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Admin access DENIED to path '{}'. No active session found. Redirecting to login.", path);
			response.sendRedirect(request.getContextPath() + "/login");
			return; // Stop processing this request.
		}

		User user = (User) session.getAttribute("user");

		if ("ADMIN".equalsIgnoreCase(user.getRole())) {
			logger.debug("ADMIN access GRANTED for user '{}' to path '{}'. Passing to next filter/servlet.",
					user.getUsername(), path);
			chain.doFilter(request, response);
		} else {
			logger.warn("ADMIN access DENIED for user '{}' (Role: '{}') to path '{}'. Redirecting to user home.",
					user.getUsername(), user.getRole(), path);
			request.getSession().setAttribute("accessErrorMessage",
					"Sie haben keine Berechtigung, auf diese Seite zuzugreifen.");
			response.sendRedirect(request.getContextPath() + "/home");
		}
	}

	@Override
	public void destroy() {
		logger.info("AdminFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AuthenticationFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * A security filter that intercepts all incoming requests (`/*`) to enforce
 * authentication. It checks if a user is logged in by looking for a "user"
 * object in the session. It allows access to a predefined set of public pages
 * (like login, error pages) and resources (CSS, JS) for everyone. For all other
 * protected paths, it redirects unauthenticated users to the login page.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class AuthenticationFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AuthenticationFilter.class.getName());

	// A set of paths that are publicly accessible without logging in.
	private static final Set<String> PUBLIC_PATHS = new HashSet<>(
			Arrays.asList("/login", "/login.jsp", "/logout.jsp", "/error404.jsp", "/error500.jsp"));

	// A set of resource prefixes that are always public (e.g., /css/style.css).
	private static final Set<String> PUBLIC_RESOURCE_PREFIXES = new HashSet<>(Arrays.asList("/css", "/js", "/images"));

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AuthenticationFilter initialized. Public paths: {}, Public prefixes: {}", PUBLIC_PATHS,
				PUBLIC_RESOURCE_PREFIXES);
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String contextPath = request.getContextPath();
		String path = request.getRequestURI().substring(contextPath.length());

		logger.trace("AuthenticationFilter processing request for path: '{}'", path);

		boolean isLoggedIn = (session != null && session.getAttribute("user") != null);

		boolean isPublicResource = PUBLIC_PATHS.contains(path)
				|| PUBLIC_RESOURCE_PREFIXES.stream().anyMatch(path::startsWith);

		// If the user is logged in OR the path is public, let the request through.
		if (isLoggedIn || isPublicResource) {
			logger.trace("Access granted for path '{}'. LoggedIn: {}, IsPublic: {}", path, isLoggedIn,
					isPublicResource);
			chain.doFilter(request, response);
		} else {
			// If not logged in and not a public path, redirect to login.
			logger.warn("Unauthorized access attempt by a guest to protected path: '{}'. Redirecting to login page.",
					path);
			response.sendRedirect(contextPath + "/login");
		}
	}

	@Override
	public void destroy() {
		logger.info("AuthenticationFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\CharacterEncodingFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;

/**
 * A crucial utility filter that intercepts all incoming requests (`/*`) to set
 * the character encoding to UTF-8. This ensures that any data submitted in
 * requests (e.g., form fields with special characters like German umlauts) and
 * any content sent in responses is correctly interpreted and rendered by the
 * browser. It should be the first filter in the chain.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class CharacterEncodingFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(CharacterEncodingFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("CharacterEncodingFilter initialized and set to enforce UTF-8.");
	}

	/**
	 * Sets the character encoding for both the request and response to UTF-8.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		logger.trace("Applying UTF-8 character encoding to request and response.");

		// Set the character encoding for the request to correctly interpret incoming
		// data
		request.setCharacterEncoding("UTF-8");

		// Set the character encoding for the response to ensure the browser renders it
		// correctly
		response.setCharacterEncoding("UTF-8");

		// Pass the request along the filter chain
		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
		logger.info("CharacterEncodingFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\AppContextListener.java
========================================================================

package de.technikteam.listener;

import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * This is an application lifecycle listener that performs crucial cleanup tasks
 * when the web application is shut down or undeployed from the server. Its
 * primary purpose is to manually deregister the JDBC driver that was loaded by
 * this application's classloader. This prevents potential memory leaks in
 * application servers like Tomcat.
 */
@WebListener
public class AppContextListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(AppContextListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Initialized <<<<<<<<<<");
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Being Destroyed. Cleaning up resources... <<<<<<<<<<");

		// This is the officially supported way to prevent memory leaks caused by JDBC
		// drivers
		// when a web application is shut down. We iterate through all loaded drivers
		// and deregister any that were loaded by this application's classloader.
		Enumeration<java.sql.Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			java.sql.Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getClass().getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
					logger.info("Deregistering JDBC driver: {}", driver);
				} catch (SQLException e) {
					logger.error("Error deregistering JDBC driver: {}", driver, e);
				}
			} else {
				logger.trace("Not deregistering JDBC driver {} as it does not belong to this webapp's classloader.",
						driver);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\ApplicationInitializerListener.java
========================================================================

package de.technikteam.listener;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.dao.DatabaseManager;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * An application lifecycle listener that runs when the application starts. It
 * performs two critical initialization tasks: 1. Manually loads the MySQL JDBC
 * driver to ensure it's available for the application. This is a robust
 * practice that prevents connectivity issues if the server's automatic service
 * discovery fails. 2. Explicitly triggers the initialization of the
 * `DatabaseManager` and its connection pool, and ensures the pool is closed on
 * application shutdown.
 */
@WebListener
public class ApplicationInitializerListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(ApplicationInitializerListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being initialized...");

		try {
			// Manually load the MySQL JDBC driver.
			logger.info("Attempting to manually load MySQL JDBC driver...");
			Class.forName("com.mysql.cj.jdbc.Driver");
			logger.info("MySQL JDBC driver loaded successfully.");

			// Eagerly initialize the database connection pool on startup
			logger.info("Triggering database connection pool initialization...");
			Class.forName("de.technikteam.dao.DatabaseManager");

		} catch (ClassNotFoundException e) {
			logger.fatal("FATAL: MySQL JDBC driver or DatabaseManager not found in classpath. Application will fail.",
					e);
		}
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being destroyed.");
		// Properly shut down the database connection pool.
		DatabaseManager.closeDataSource();
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	// --- Formatted Helper ---

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String status;
	private String userAttendanceStatus; // Specific to the logged-in user (e.g., ANGEMELDET, ZUGEWIESEN)

	// These fields are populated on-demand for detailed views and are not direct
	// table columns.
	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;

	public Event() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	// --- Formatted Helpers ---

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; // To display the user's name in lists
	private String signupStatus; // e.g., ANGEMELDET, ABGEMELDET
	private String commitmentStatus; // e.g., BESTÄTIGT, OFFEN

	public EventAttendance() {
	}

	// --- Getters and Setters ---

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Represents a single chat message from the `event_chat_messages` table,
 * associated with a specific "running" event. It holds the message content,
 * sender information, and timestamp.
 */
public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private LocalDateTime sentAt;

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");

	/**
	 * A convenience method to get the sent-at timestamp as a formatted time string
	 * (e.g., "15:30"), suitable for display in the chat UI.
	 * 
	 * @return A formatted time string.
	 */
	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status
 * ("OFFEN" or "ERLEDIGT"), and a transient field for displaying assigned users.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String status; // e.g., "OFFEN" or "ERLEDIGT"
	private String assignedUsernames; // Comma-separated list for display, not a direct table column

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getAssignedUsernames() {
		return assignedUsernames;
	}

	public void setAssignedUsernames(String assignedUsernames) {
		this.assignedUsernames = assignedUsernames;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName; // For display purposes, joined from file_categories
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private String leader;
	private String description;

	// Transient fields populated by DAO joins for UI display
	private String parentCourseName;
	private String userAttendanceStatus; // User-specific status (ANGEMELDET, ABGEMELDET, OFFEN)

	// --- Formatted Helpers ---

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	// --- Getters and Setters ---

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getLeader() {
		return leader;
	}

	public void setLeader(String leader) {
		this.leader = leader;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the `meeting_attachments` table. It links a
 * file (with its path and name) to a specific meeting and includes a
 * `requiredRole` to control its visibility to different types of users.
 */
public class MeetingAttachment {
	private int id;
	private int meetingId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	// --- Getters and Setters ---

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;

	// Transient field for UI display, populated by a DAO join
	private String courseName;

	// --- Getters and Setters ---

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table. It holds
 * all data related to an inventory item, including its name, location,
 * quantity, and an optional image path. It also contains helper methods to
 * 
 * determine its availability status for UI display.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String shelf;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private String imagePath;

	public StorageItem() {
	}

	/**
	 * Determines a human-readable availability status based on the current quantity
	 * relative to the maximum quantity.
	 * 
	 * @return A string representing the status (e.g., "Vollständig", "Niedriger
	 *         Bestand").
	 */
	public String getAvailabilityStatus() {
		if (this.maxQuantity <= 0) {
			return "Unbegrenzt";
		}
		if (this.quantity <= 0) {
			return "Vergriffen";
		}
		if (this.quantity >= this.maxQuantity) {
			return "Vollständig";
		}
		double percentage = (double) this.quantity / this.maxQuantity;
		if (percentage <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	/**
	 * Gets a corresponding CSS class based on the availability status, allowing for
	 * easy color-coding in the user interface.
	 * 
	 * @return A CSS class name (e.g., "status-ok", "status-danger").
	 */
	public String getAvailabilityStatusCssClass() {
		if (this.maxQuantity <= 0) {
			return "status-info"; // Unlimited
		}
		if (this.quantity <= 0) {
			return "status-danger"; // Out of Stock
		}
		if (this.quantity >= this.maxQuantity) {
			return "status-ok"; // Full
		}
		double percentage = (double) this.quantity / this.maxQuantity;
		if (percentage <= 0.25) {
			return "status-warn"; // Low Stock
		}
		return "status-ok"; // In Stock
	}

	// --- Getters and Setters ---

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getShelf() {
		return shelf;
	}

	public void setShelf(String shelf) {
		this.shelf = shelf;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * The core model for an application user, representing a record from the
 * `users` table. It contains the user's ID, username, role ("ADMIN" or
 * "NUTZER"), and other profile information like class year and creation date.
 */
public class User {
	private int id;
	private String username;
	private String role;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;

	public User() {
	}

	public User(int id, String username, String role) {
		this(id, username, role, null, 0, null);
	}

	public User(int id, String username, String role, LocalDateTime createdAt, int classYear, String className) {
		this.id = id;
		this.username = username;
		this.role = role;
		this.createdAt = createdAt;
		this.classYear = classYear;
		this.className = className;
	}

	// --- Getters and Setters ---

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRole() {
		return role;
	}

	public void setRole(String role) {
		this.role = role;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * A convenience method to get the creation timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; // For display, joined from 'courses' table
	private String status; // e.g., "BESUCHT", "ABSOLVIERT"
	private LocalDate completionDate;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * A simple service layer that acts as a middleman for logging administrative
 * actions. It provides a static `log` method that other parts of the
 * application can call to create an audit log entry. This decouples the
 * application logic from the direct use of the AdminLogDAO.
 */
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private static final AdminLogDAO logDAO = new AdminLogDAO();

	/**
	 * Creates and persists an administrative audit log entry. This is the central
	 * point for all audit logging.
	 * 
	 * @param adminUsername The username of the admin performing the action.
	 * @param actionType    A high-level category for the action (e.g.,
	 *                      "UPDATE_USER", "DELETE_EVENT").
	 * @param details       A detailed, human-readable description of the action and
	 *                      its context.
	 */
	public static void log(String adminUsername, String actionType, String details) {
		try {
			AdminLog log = new AdminLog();
			log.setAdminUsername(adminUsername);
			log.setActionType(actionType);
			log.setDetails(details);

			// Log the same info to the file/console for debugging purposes before DB write
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", adminUsername, actionType, details);

			logDAO.createLog(log);
		} catch (Exception e) {
			// Log the failure to write to the audit log itself
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					adminUsername, actionType, details, e);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.AsyncContext;
import jakarta.servlet.http.HttpServletRequest;

/**
 * A singleton service designed to handle real-time notifications using
 * Server-Sent Events (SSE). It manages a thread-safe list of connected clients
 * (via their `AsyncContext`) and provides a central method to broadcast a
 * notification message to all of them simultaneously.
 */
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);
	private static final NotificationService INSTANCE = new NotificationService();

	// Use a thread-safe list because clients can register/deregister from different
	// threads.
	private final List<AsyncContext> contexts = new CopyOnWriteArrayList<>();

	private NotificationService() {
	}

	public static NotificationService getInstance() {
		return INSTANCE;
	}

	/**
	 * Registers a new client (from an incoming HttpServletRequest) to receive
	 * notifications. It starts an asynchronous context and adds it to the list of
	 * subscribers.
	 * 
	 * @param request The request from the client wishing to subscribe.
	 */
	public void register(HttpServletRequest request) {
		AsyncContext asyncContext = request.startAsync();
		asyncContext.setTimeout(0); // No timeout for SSE connections
		contexts.add(asyncContext);
		logger.info("New client registered for SSE notifications. Total clients: {}", contexts.size());
	}

	/**
	 * Sends a notification message to all currently registered clients. If a client
	 * has disconnected, it will be removed from the list.
	 * 
	 * @param message The message to send.
	 */
	public void sendNotification(String message) {
		logger.info("Sending notification to {} clients: {}", contexts.size(), message);
		for (AsyncContext context : contexts) {
			try {
				PrintWriter writer = context.getResponse().getWriter();
				// Format the message according to the SSE specification: "data: message\n\n"
				writer.write("data: " + message + "\n\n");
				writer.flush();
			} catch (IOException e) {
				logger.warn("Failed to send notification to a client (likely disconnected), removing it.", e);
				contexts.remove(context);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAttendanceServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;

/**
 * Mapped to `/admin/attendance`, this servlet handles all actions related to
 * updating meeting attendance records, primarily called from the modal window
 * on the administrative qualifications matrix (`admin_matrix.jsp`).
 */
@WebServlet("/admin/attendance")
public class AdminAttendanceServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAttendanceServlet.class);
	private MeetingAttendanceDAO attendanceDAO;
	private UserDAO userDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
		userDAO = new UserDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo"); // e.g., "matrix"

		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			int meetingId = Integer.parseInt(request.getParameter("meetingId"));

			// A checkbox sends "true" if checked, and null if not. This is a standard way
			// to check it.
			boolean attended = "true".equals(request.getParameter("attended"));

			String remarks = request.getParameter("remarks");
			logger.debug("Processing attendance update for user ID {}, meeting ID {}. Attended: {}, Remarks: '{}'",
					userId, meetingId, attended, remarks);

			if (attendanceDAO.setAttendance(userId, meetingId, attended, remarks)) {
				// Fetch details for rich logging
				User targetUser = userDAO.getUserById(userId);
				Meeting meeting = meetingDAO.getMeetingById(meetingId);

				String status = attended ? "TEILGENOMMEN" : "NICHT TEILGENOMMEN";
				String logDetails = String.format(
						"Teilnahme für Nutzer '%s' (ID: %d) bei Meeting '%s' (ID: %d) auf '%s' gesetzt. Bemerkungen: '%s'.",
						(targetUser != null ? targetUser.getUsername() : "N/A"), userId,
						(meeting != null ? meeting.getName() : "N/A"), meetingId, status, remarks);

				AdminLogService.log(adminUser.getUsername(), "UPDATE_ATTENDANCE", logDetails);

				request.getSession().setAttribute("successMessage", "Teilnahmestatus erfolgreich aktualisiert.");
				logger.info("Attendance update successful for user ID {} / meeting ID {}.", userId, meetingId);
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Teilnahmestatus konnte nicht aktualisiert werden.");
				logger.error("Attendance update failed for user ID {} / meeting ID {}.", userId, meetingId);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid ID received in AdminAttendanceServlet.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID empfangen.");
		}

		// Redirect back to the matrix or a default page
		String redirectUrl = request.getContextPath()
				+ ("/matrix".equals(returnTo) ? "/admin/matrix" : "/admin/dashboard");
		logger.debug("Redirecting to {}", redirectUrl);
		response.sendRedirect(redirectUrl);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminCourseServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.CourseDAO;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;
import java.util.List;
import java.util.Objects;

/**
 * Mapped to `/admin/courses`, this servlet manages the parent course templates.
 * It handles listing all course templates, showing forms to create or edit
 * them, and processing the creation, update, and deletion of these templates.
 * It works in tandem with `AdminMeetingServlet` which manages the individual
 * sessions for each course.
 */
@WebServlet("/admin/courses")
public class AdminCourseServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminCourseServlet.class);
	private CourseDAO courseDAO;

	@Override
	public void init() {
		courseDAO = new CourseDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminCourseServlet received GET request with action: {}", action);
		switch (action) {
		case "edit":
		case "new":
			showForm(req, resp);
			break;
		default:
			listCourses(req, resp);
			break;
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getParameter("action");
		logger.debug("AdminCourseServlet received POST request with action: {}", action);
		if ("delete".equals(action)) {
			handleDelete(req, resp);
		} else {
			handleCreateOrUpdate(req, resp);
		}
	}

	private void listCourses(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		logger.info("Listing all course templates.");
		List<Course> courseList = courseDAO.getAllCourses();
		req.setAttribute("courseList", courseList);
		req.getRequestDispatcher("/admin/admin_course_list.jsp").forward(req, resp);
	}

	private void showForm(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if ("edit".equals(req.getParameter("action"))) {
			int courseId = Integer.parseInt(req.getParameter("id"));
			logger.info("Showing edit form for course ID: {}", courseId);
			Course course = courseDAO.getCourseById(courseId);
			req.setAttribute("course", course);
		} else {
			logger.info("Showing form for new course template.");
		}
		req.getRequestDispatcher("/admin/admin_course_form.jsp").forward(req, resp);
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");

		Course course = new Course();
		course.setName(request.getParameter("name"));
		course.setAbbreviation(request.getParameter("abbreviation"));
		course.setDescription(request.getParameter("description"));

		boolean success;
		if (idParam != null && !idParam.isEmpty()) { // UPDATE
			course.setId(Integer.parseInt(idParam));
			logger.info("Attempting to update course: {}", course.getName());
			Course originalCourse = courseDAO.getCourseById(course.getId());
			success = courseDAO.updateCourse(course);
			if (success) {
				StringBuilder changes = new StringBuilder();
				if (!Objects.equals(originalCourse.getName(), course.getName())) {
					changes.append(String.format("Name: '%s' -> '%s'. ", originalCourse.getName(), course.getName()));
				}
				if (!Objects.equals(originalCourse.getAbbreviation(), course.getAbbreviation())) {
					changes.append(String.format("Abk.: '%s' -> '%s'. ", originalCourse.getAbbreviation(),
							course.getAbbreviation()));
				}
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (ID: %d) aktualisiert. %s",
						originalCourse.getName(), course.getId(), changes.toString());
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren der Vorlage.");
			}
		} else { // CREATE
			logger.info("Attempting to create new course: {}", course.getName());
			success = courseDAO.createCourse(course);
			if (success) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (Abk.: %s) erstellt.", course.getName(),
						course.getAbbreviation());
				AdminLogService.log(adminUser.getUsername(), "CREATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Neue Lehrgangs-Vorlage erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Erstellen der Vorlage.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/courses");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete course with ID: {}", courseId);

			// Fetch course details before deleting for detailed logging
			Course courseToDelete = courseDAO.getCourseById(courseId);
			String courseName = (courseToDelete != null) ? courseToDelete.getName() : "N/A";

			if (courseDAO.deleteCourse(courseId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_COURSE",
						"Lehrgangs-Vorlage '" + courseName + "' (ID: " + courseId
								+ ") und alle zugehörigen Meetings, Anhänge und Qualifikationen gelöscht.");
				req.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Vorlage konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid course ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Löschvorgang.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/courses");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDashboardServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.StatisticsDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/dashboard`, this servlet serves as the entry point for the
 * main administrative dashboard. It uses the `StatisticsDAO` to fetch key
 * metrics like the total user count and the number of active events. It then
 * forwards this data to `admin_dashboard.jsp` for display.
 */
@WebServlet("/admin/dashboard")
public class AdminDashboardServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminDashboardServlet.class);
	private StatisticsDAO statisticsDAO;

	@Override
	public void init() {
		statisticsDAO = new StatisticsDAO();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Admin dashboard requested. Fetching statistics.");

		int userCount = statisticsDAO.getUserCount();
		int activeEventCount = statisticsDAO.getActiveEventCount();

		request.setAttribute("userCount", userCount);
		request.setAttribute("activeEventCount", activeEventCount);

		logger.debug("Forwarding to admin_dashboard.jsp with userCount={} and activeEventCount={}", userCount,
				activeEventCount);
		request.getRequestDispatcher("/admin/admin_dashboard.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminEventServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.Arrays;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/events`, this is a complex servlet that manages all aspects
 * of events from an administrative perspective. It handles full CRUD operations
 * (create, read, update, delete) for events, manages skill requirements,
 * updates event statuses, and provides the interface for assigning users to an
 * event's final team. It routes to various JSPs like `admin_events_list.jsp`,
 * `admin_event_form.jsp`, and `admin_event_assign.jsp`.
 */
@WebServlet("/admin/events")
public class AdminEventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminEventServlet.class);

	private EventDAO eventDAO;
	private CourseDAO courseDAO; // Needed for skill requirements dropdown in the form

	@Override
	public void init() {
		eventDAO = new EventDAO();
		courseDAO = new CourseDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminEventServlet received GET request with action: {}", action);
		try {
			switch (action) {
			case "edit":
			case "new":
				showEventForm(req, resp);
				break;
			case "assign":
				showAssignForm(req, resp);
				break;
			default:
				listEvents(req, resp);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminEventServlet doGet", e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/events");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getParameter("action");
		logger.debug("AdminEventServlet received POST request with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "assignUsers":
			handleAssignUsers(req, resp);
			break;
		case "updateStatus":
			handleStatusUpdate(req, resp);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/events");
			break;
		}
	}

	private void listEvents(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		logger.info("Listing all events for admin view.");
		List<Event> eventList = eventDAO.getAllEvents();
		req.setAttribute("eventList", eventList);
		req.getRequestDispatcher("/admin/admin_events_list.jsp").forward(req, resp);
	}

	private void showEventForm(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		if ("edit".equals(req.getParameter("action"))) {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.info("Showing edit form for event ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);
			event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
			req.setAttribute("event", event);
		} else {
			logger.info("Showing form for new event.");
		}
		List<Course> allCourses = courseDAO.getAllCourses();
		req.setAttribute("allCourses", allCourses);
		req.getRequestDispatcher("/admin/admin_event_form.jsp").forward(req, resp);
	}

	private void showAssignForm(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.info("Showing user assignment form for event ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);
			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);

			Set<Integer> assignedUserIds = assignedUsers.stream().map(User::getId).collect(Collectors.toSet());

			req.setAttribute("event", event);
			req.setAttribute("signedUpUsers", signedUpUsers);
			req.setAttribute("assignedUserIds", assignedUserIds);

			req.getRequestDispatcher("/admin/admin_event_assign.jsp").forward(req, resp);
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID for assignment form.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
			resp.sendRedirect(req.getContextPath() + "/admin/events");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		boolean isUpdate = idParam != null && !idParam.isEmpty();

		try {
			Event event = new Event();
			event.setName(request.getParameter("name"));
			event.setDescription(request.getParameter("description"));
			event.setEventDateTime(LocalDateTime.parse(request.getParameter("eventDateTime")));

			String endDateTimeParam = request.getParameter("endDateTime");
			if (endDateTimeParam != null && !endDateTimeParam.isEmpty()) {
				event.setEndDateTime(LocalDateTime.parse(endDateTimeParam));
			}

			boolean success = false;
			String actionType;

			if (isUpdate) {
				actionType = "UPDATE_EVENT";
				int eventId = Integer.parseInt(idParam);
				event.setId(eventId);
				event.setStatus(request.getParameter("status"));
				logger.info("Attempting to update event ID: {}", eventId);
				success = eventDAO.updateEvent(event);
				if (success) {
					AdminLogService.log(adminUser.getUsername(), actionType,
							"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
				}
			} else { // CREATE
				actionType = "CREATE_EVENT";
				event.setStatus("GEPLANT");
				logger.info("Attempting to create new event: {}", event.getName());
				int newEventId = eventDAO.createEvent(event);
				if (newEventId > 0) {
					success = true;
					event.setId(newEventId);
					AdminLogService.log(adminUser.getUsername(), actionType,
							"Event '" + event.getName() + "' (ID: " + newEventId + ") erstellt.");
				}
			}

			if (success) {
				String[] requiredCourseIds = request.getParameterValues("requiredCourseId");
				String[] requiredPersons = request.getParameterValues("requiredPersons");
				eventDAO.saveSkillRequirements(event.getId(), requiredCourseIds, requiredPersons);
				request.getSession().setAttribute("successMessage", "Event erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Event konnte nicht gespeichert werden.");
			}

		} catch (DateTimeParseException e) {
			logger.error("Invalid date format submitted for event.", e);
			request.getSession().setAttribute("errorMessage",
					"Ungültiges Datumsformat. Bitte 'TT.MM.JJJJ hh:mm' verwenden.");
		} catch (Exception e) {
			logger.error("Error during event creation/update.", e);
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}

		response.sendRedirect(request.getContextPath() + "/admin/events");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete event with ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);

			if (event != null && eventDAO.deleteEvent(eventId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT",
						"Event '" + event.getName() + "' (ID: " + eventId + ") endgültig gelöscht.");
				req.getSession().setAttribute("successMessage", "Event wurde gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Event konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

	private void handleAssignUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("eventId"));
			String[] userIds = req.getParameterValues("userIds");
			logger.info("Assigning {} users to event ID {}", (userIds != null ? userIds.length : 0), eventId);
			Event event = eventDAO.getEventById(eventId);

			eventDAO.assignUsersToEvent(eventId, userIds);

			String assignedUserCount = (userIds != null) ? String.valueOf(userIds.length) : "0";
			String logDetails = String.format("Team für Event '%s' (ID: %d) finalisiert. %s Benutzer zugewiesen.",
					event.getName(), eventId, assignedUserCount);
			AdminLogService.log(adminUser.getUsername(), "ASSIGN_TEAM", logDetails);

			req.getSession().setAttribute("successMessage", "Team für das Event wurde erfolgreich zugewiesen.");
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for user assignment.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

	private void handleStatusUpdate(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			String newStatus = req.getParameter("newStatus");
			logger.info("Updating status for event ID {} to '{}'", eventId, newStatus);
			Event event = eventDAO.getEventById(eventId);

			if (event != null && eventDAO.updateEventStatus(eventId, newStatus)) {
				String logDetails = String.format("Status für Event '%s' (ID: %d) von '%s' auf '%s' geändert.",
						event.getName(), eventId, event.getStatus(), newStatus);
				AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT_STATUS", logDetails);
				req.getSession().setAttribute("successMessage", "Event-Status erfolgreich aktualisiert.");
			} else {
				req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Event-Status.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for status update.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileCategoryServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet is uniquely mapped to multiple URL patterns
 * (`/admin/categories/*`) to handle specific CRUD actions for file categories.
 * It processes POST requests to create, update, or delete a category based on
 * the servlet path, logs the action, and then redirects back to the main admin
 * file management page.
 */
@WebServlet({ "/admin/categories/create", "/admin/categories/update", "/admin/categories/delete" })
public class AdminFileCategoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileCategoryServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getServletPath();
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.debug("AdminFileCategoryServlet processing POST for action path: {}", action);

		try {
			if (action.endsWith("/create")) {
				String categoryName = req.getParameter("categoryName");
				if (fileDAO.createCategory(categoryName)) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' erstellt.");
					req.getSession().setAttribute("successMessage",
							"Kategorie '" + categoryName + "' erfolgreich erstellt.");
				}
			} else if (action.endsWith("/update")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String newName = req.getParameter("categoryName");
				String oldName = fileDAO.getCategoryNameById(categoryId); // Get old name for logging
				if (fileDAO.updateCategory(categoryId, newName)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_FILE_CATEGORY", "Dateikategorie '" + oldName
							+ "' (ID: " + categoryId + ") umbenannt in '" + newName + "'.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich umbenannt.");
				}
			} else if (action.endsWith("/delete")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String categoryName = fileDAO.getCategoryNameById(categoryId); // Get name for logging
				if (fileDAO.deleteCategory(categoryId)) {
					AdminLogService.log(adminUser.getUsername(), "DELETE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' (ID: " + categoryId + ") gelöscht.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich gelöscht.");
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in AdminFileCategoryServlet for action {}", action, e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Kategorie-Aktion.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/files");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.File; // Our own model: de.technikteam.model.File
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

/**
 * Mapped to `/admin/files`, this servlet manages file uploads and deletions for
 * administrators. A GET request displays the management page
 * (`admin_files.jsp`) with a list of all files grouped by category. A POST
 * request handles either uploading a new file or deleting an existing one. It
 * correctly handles `multipart/form-data` to read form fields and the uploaded
 * file.
 */
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
@WebServlet("/admin/files")
public class AdminFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("Admin file page requested by user '{}'.", user.getUsername());

		Map<String, List<File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(user);
		List<FileCategory> allCategories = fileDAO.getAllCategories();

		request.setAttribute("groupedFiles", groupedFiles);
		request.setAttribute("allCategories", allCategories);

		logger.debug("Forwarding to admin_files.jsp with {} file groups and {} categories.", groupedFiles.size(),
				allCategories.size());
		request.getRequestDispatcher("/admin/admin_files.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();

		// FIX: Differentiate between multipart (upload) and standard (delete) forms
		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			handleUpload(request, response);
		} else {
			String action = request.getParameter("action");
			if ("delete".equals(action)) {
				handleDelete(request, response);
			} else {
				logger.warn("Received non-multipart POST with unknown or missing action: '{}'", action);
				request.getSession().setAttribute("errorMessage", "Unbekannte Aktion empfangen.");
				response.sendRedirect(request.getContextPath() + "/admin/files");
			}
		}
	}

	private void handleUpload(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			String uploadFilePath = AppConfig.UPLOAD_DIRECTORY;
			java.io.File uploadDir = new java.io.File(uploadFilePath);
			if (!uploadDir.exists())
				uploadDir.mkdirs();

			Part filePart = request.getPart("file");
			String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();

			String requiredRole = getPartValue(request.getPart("requiredRole"));
			String categoryIdStr = getPartValue(request.getPart("categoryId"));

			int categoryId = 0;
			try {
				if (categoryIdStr != null && !categoryIdStr.isEmpty()) {
					categoryId = Integer.parseInt(categoryIdStr);
				}
			} catch (NumberFormatException e) {
				logger.warn("No valid category ID provided during upload.");
			}

			if (fileName == null || fileName.isEmpty()) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Datei zum Hochladen aus.");
			} else if (categoryId == 0) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Kategorie aus.");
			} else {
				java.io.File targetFile = new java.io.File(uploadDir, fileName);
				filePart.write(targetFile.getAbsolutePath());
				logger.info("File '{}' uploaded by '{}' to: {}", fileName, adminUser.getUsername(),
						targetFile.getAbsolutePath());

				File newDbFile = new File();
				newDbFile.setFilename(fileName);
				newDbFile.setFilepath(fileName); // Filepath is just the filename for top-level uploads
				newDbFile.setCategoryId(categoryId);
				newDbFile.setRequiredRole(requiredRole);

				if (fileDAO.createFile(newDbFile)) {
					String categoryName = fileDAO.getCategoryNameById(categoryId);
					String logDetails = String.format("Datei '%s' in Kategorie '%s' hochgeladen. Sichtbar für: %s.",
							fileName, categoryName, requiredRole);
					AdminLogService.log(adminUser.getUsername(), "FILE_UPLOAD", logDetails);
					request.getSession().setAttribute("successMessage",
							"Datei '" + fileName + "' erfolgreich hochgeladen.");
				} else {
					request.getSession().setAttribute("errorMessage",
							"DB-Fehler: Datei konnte nicht gespeichert werden (ggf. existiert der Name bereits).");
					targetFile.delete();
				}
			}
		} catch (Exception e) {
			logger.error("File upload failed.", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Upload: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/files");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int fileId = Integer.parseInt(request.getParameter("fileId"));
			logger.warn("Attempting to delete file with ID: {} by user '{}'", fileId, adminUser.getUsername());
			File dbFile = fileDAO.getFileById(fileId);

			if (dbFile != null) {
				java.io.File physicalFile = new java.io.File(AppConfig.UPLOAD_DIRECTORY, dbFile.getFilepath());
				boolean physicalDeleted = true;

				if (physicalFile.exists()) {
					physicalDeleted = physicalFile.delete();
				} else {
					logger.warn("Physical file not found at [{}], but proceeding with DB record deletion.",
							physicalFile.getAbsolutePath());
				}

				if (physicalDeleted) {
					if (fileDAO.deleteFile(fileId)) {
						String categoryName = fileDAO.getCategoryNameById(dbFile.getCategoryId());
						String logDetails = String.format("Datei '%s' (ID: %d) aus Kategorie '%s' gelöscht.",
								dbFile.getFilename(), fileId, categoryName != null ? categoryName : "N/A");
						AdminLogService.log(adminUser.getUsername(), "FILE_DELETE", logDetails);
						request.getSession().setAttribute("successMessage",
								"Datei '" + dbFile.getFilename() + "' wurde erfolgreich gelöscht.");
					} else {
						request.getSession().setAttribute("errorMessage",
								"FEHLER: Die Datei konnte aus der Datenbank nicht gelöscht werden.");
					}
				} else {
					request.getSession().setAttribute("errorMessage",
							"FEHLER: Die physische Datei konnte nicht gelöscht werden. Bitte Berechtigungen prüfen.");
				}
			} else {
				request.getSession().setAttribute("errorMessage", "Datei in der Datenbank nicht gefunden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Datei-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/files");
	}

	private String getPartValue(Part part) throws IOException {
		if (part == null) {
			return null;
		}
		try (InputStream inputStream = part.getInputStream();
				Scanner scanner = new Scanner(inputStream, StandardCharsets.UTF_8.name())) {
			return scanner.useDelimiter("\\A").hasNext() ? scanner.next() : "";
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminLogServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/log`, this servlet retrieves all entries from the
 * administrative action log using the `AdminLogDAO`. It then passes the
 * complete list of logs to `admin_log.jsp` for display and filtering on the
 * client side.
 */
@WebServlet("/admin/log")
public class AdminLogServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminLogServlet.class);
	private AdminLogDAO adminLogDAO;

	@Override
	public void init() {
		adminLogDAO = new AdminLogDAO();
		logger.info("AdminLogServlet has been initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		logger.info("Admin log page requested by user '{}'.", adminUser.getUsername());
		try {
			List<AdminLog> logs = adminLogDAO.getAllLogs();
			request.setAttribute("logs", logs);
			logger.info("Fetched {} log entries. Forwarding to JSP.", logs.size());
			request.getRequestDispatcher("/admin/admin_log.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("A critical error occurred in AdminLogServlet doGet()", e);
			// Redirect to a generic error page to avoid exposing stack traces to the user
			response.sendRedirect(request.getContextPath() + "/error500.jsp");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttachment;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.List;
import java.util.Scanner;

@WebServlet("/admin/meetings")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);
	private MeetingDAO meetingDAO;
	private CourseDAO courseDAO;
	private MeetingAttachmentDAO attachmentDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		courseDAO = new CourseDAO();
		attachmentDAO = new MeetingAttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminMeetingServlet received GET with action: {}", action);
		try {
			int courseId = Integer.parseInt(req.getParameter("courseId"));
			Course parentCourse = courseDAO.getCourseById(courseId);
			req.setAttribute("parentCourse", parentCourse);

			switch (action) {
			case "new":
			case "edit":
				showForm(req, resp);
				break;
			default: // "list"
				listMeetings(req, resp);
				break;
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid courseId parameter in GET request.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: Ungültige Kurs-ID.");
			resp.sendRedirect(req.getContextPath() + "/admin/courses");
		} catch (Exception e) {
			logger.error("General error in doGet of AdminMeetingServlet.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/courses");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String contentType = req.getContentType();

		// FIX: Differentiate between multipart and standard form requests
		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			String action = getPartValue(req.getPart("action"));
			if ("create".equals(action) || "update".equals(action)) {
				handleCreateOrUpdate(req, resp);
			} else {
				logger.warn("Unknown multipart action received in doPost: {}", action);
				resp.sendRedirect(req.getContextPath() + "/admin/courses");
			}
		} else {
			String action = req.getParameter("action");
			logger.debug("AdminMeetingServlet received non-multipart POST with action: {}", action);
			if ("delete".equals(action)) {
				handleDelete(req, resp);
			} else if ("deleteAttachment".equals(action)) {
				handleDeleteAttachment(req, resp);
			} else {
				logger.warn("Unknown non-multipart action received in doPost: {}", action);
				resp.sendRedirect(req.getContextPath() + "/admin/courses");
			}
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = getPartValue(req.getPart("action"));
		boolean isUpdate = "update".equals(action);

		int courseId = 0;
		int meetingId = 0;
		String redirectUrl = req.getContextPath() + "/admin/courses"; // Fallback redirect

		try {
			// Read all form fields using the helper for multipart data
			courseId = Integer.parseInt(getPartValue(req.getPart("courseId")));
			redirectUrl = req.getContextPath() + "/admin/meetings?courseId=" + courseId; // Better redirect

			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(getPartValue(req.getPart("name")));
			meeting.setLeader(getPartValue(req.getPart("leader")));
			meeting.setDescription(getPartValue(req.getPart("description")));

			String startDateTimeStr = getPartValue(req.getPart("meetingDateTime"));
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}

			String endDateTimeStr = getPartValue(req.getPart("endDateTime"));
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(getPartValue(req.getPart("meetingId")));
				meeting.setId(meetingId);
				logger.info("Attempting to update meeting ID: {}", meetingId);

				if (meetingDAO.updateMeeting(meeting)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				} else {
					req.getSession().setAttribute("infoMessage", "Keine Änderungen am Meeting vorgenommen.");
				}
				// Redirect back to the edit page to show changes and allow more uploads
				redirectUrl = req.getContextPath() + "/admin/meetings?action=edit&courseId=" + courseId + "&meetingId="
						+ meetingId;
			} else { // CREATE
				logger.info("Attempting to create new meeting for course ID: {}", courseId);
				int newMeetingId = meetingDAO.createMeeting(meeting);
				if (newMeetingId > 0) {
					meetingId = newMeetingId;
					AdminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + newMeetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
					// Redirect to the new meeting's edit page so attachments can be added
					redirectUrl = req.getContextPath() + "/admin/meetings?action=edit&courseId=" + courseId
							+ "&meetingId=" + newMeetingId;
				} else {
					req.getSession().setAttribute("errorMessage", "Meeting konnte nicht erstellt werden.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = getPartValue(req.getPart("requiredRole"));
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}

		} catch (DateTimeParseException e) {
			logger.error("Invalid date format in meeting form.", e);
			req.getSession().setAttribute("errorMessage",
					"Ungültiges Datumsformat. Bitte ein gültiges Format verwenden.");
		} catch (NumberFormatException e) {
			logger.error("Invalid number format for an ID in meeting form.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID empfangen.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}

		resp.sendRedirect(redirectUrl);
	}

	private String getPartValue(Part part) throws IOException {
		if (part == null) {
			return null;
		}
		try (InputStream inputStream = part.getInputStream();
				Scanner scanner = new Scanner(inputStream, StandardCharsets.UTF_8.name())) {
			return scanner.useDelimiter("\\A").hasNext() ? scanner.next() : "";
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.info("Listing all meetings for course ID: {}", courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		req.setAttribute("meetings", meetings);
		req.getRequestDispatcher("/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void showForm(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User user = (User) req.getSession().getAttribute("user");
		if ("edit".equals(req.getParameter("action"))) {
			int meetingId = Integer.parseInt(req.getParameter("meetingId"));
			logger.info("Showing edit form for meeting ID: {}", meetingId);
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			req.setAttribute("meeting", meeting);
			req.setAttribute("attachments", attachmentDAO.getAttachmentsForMeeting(meetingId, user.getRole()));
		} else {
			logger.info("Showing new meeting form for course ID: {}", req.getParameter("courseId"));
		}
		req.getRequestDispatcher("/admin/admin_meeting_form.jsp").forward(req, resp);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "meetings";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		MeetingAttachment attachment = new MeetingAttachment();
		attachment.setMeetingId(meetingId);
		attachment.setFilename(fileName);
		attachment.setFilepath("meetings" + File.separator + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			logger.info("Attachment '{}' uploaded for meeting ID {} by '{}'", fileName, meetingId,
					adminUser.getUsername());
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			AdminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
			req.getSession().setAttribute("successMessage", "Anhang '" + fileName + "' erfolgreich hochgeladen.");
		}
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		logger.warn("Attempting to delete attachment ID {} from meeting ID {}", attachmentId, meetingId);

		MeetingAttachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());
			if (physicalFile.exists()) {
				physicalFile.delete();
			}
			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING_ATTACHMENT",
						"Anhang '" + attachment.getFilename() + "' von Meeting ID " + meetingId + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(
				req.getContextPath() + "/admin/meetings?action=edit&courseId=" + courseId + "&meetingId=" + meetingId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.warn("Attempting to delete meeting ID {} from course ID {}", meetingId, courseId);

		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/storage`, this servlet provides full administrative control
 * over the inventory (`storage_items` table). It handles listing all items,
 * displaying forms for creating or editing items, and processing the create,
 * update, and delete actions, including handling associated image file uploads
 * and deletions. It correctly handles `multipart/form-data` requests.
 */
@WebServlet("/admin/storage")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class.getName());
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		logger.debug("AdminStorageServlet received GET with action: {}", action);
		try {
			switch (action) {
			case "edit":
			case "new":
				showForm(request, response);
				break;
			default:
				listItems(request, response);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in doGet of AdminStorageServlet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/storage");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();

		// FIX: Differentiate between multipart and standard forms
		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			String action = getPartValue(request.getPart("action"));
			if ("create".equals(action)) {
				handleCreateOrUpdate(request, response, true);
			} else if ("update".equals(action)) {
				handleCreateOrUpdate(request, response, false);
			} else {
				logger.warn("Unknown multipart action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/storage");
			}
		} else {
			String action = request.getParameter("action");
			if ("delete".equals(action)) {
				handleDelete(request, response);
			} else {
				logger.warn("Unknown non-multipart action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/storage");
			}
		}
	}

	private void listItems(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Listing all storage items for admin view.");
		Map<String, List<StorageItem>> groupedItems = storageDAO.getAllItemsGroupedByLocation();
		List<StorageItem> flatList = groupedItems.values().stream().flatMap(List::stream).collect(Collectors.toList());
		request.setAttribute("storageList", flatList);
		request.getRequestDispatcher("/admin/admin_storage_list.jsp").forward(request, response);
	}

	private void showForm(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		if ("edit".equals(request.getParameter("action"))) {
			int itemId = Integer.parseInt(request.getParameter("id"));
			logger.info("Showing edit form for storage item ID: {}", itemId);
			StorageItem item = storageDAO.getItemById(itemId);
			request.setAttribute("storageItem", item);
		} else {
			logger.info("Showing new storage item form.");
		}
		request.getRequestDispatcher("/admin/admin_storage_form.jsp").forward(request, response);
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response, boolean isCreate)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			StorageItem item = new StorageItem();
			item.setName(getPartValue(request.getPart("name")));
			item.setLocation(getPartValue(request.getPart("location")));
			item.setCabinet(getPartValue(request.getPart("cabinet")));
			item.setShelf(getPartValue(request.getPart("shelf")));
			item.setCompartment(getPartValue(request.getPart("compartment")));
			item.setQuantity(Integer.parseInt(getPartValue(request.getPart("quantity"))));
			item.setMaxQuantity(Integer.parseInt(getPartValue(request.getPart("maxQuantity"))));

			logger.debug("SERVLET: Read from form -> Name: '{}', Quantity: {}, MaxQuantity: {}", item.getName(),
					item.getQuantity(), item.getMaxQuantity());

			Part filePart = request.getPart("imageFile");
			String imagePath = null;
			if (!isCreate) {
				int itemId = Integer.parseInt(getPartValue(request.getPart("id")));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success;
			if (isCreate) {
				success = storageDAO.createItem(item);
				if (success) {
					String logDetails = String.format(
							"Lagerartikel '%s' erstellt. Ort: %s, Schrank: %s, Anzahl: %d/%d.", item.getName(),
							item.getLocation(), item.getCabinet(), item.getQuantity(), item.getMaxQuantity());
					AdminLogService.log(adminUser.getUsername(), "CREATE_STORAGE_ITEM", logDetails);
					request.getSession().setAttribute("successMessage",
							"Artikel '" + item.getName() + "' erfolgreich erstellt.");
				}
			} else { // UPDATE
				StorageItem originalItem = storageDAO.getItemById(item.getId());
				success = storageDAO.updateItem(item);
				if (success) {
					String logDetails = String.format(
							"Lagerartikel '%s' (ID: %d) aktualisiert. Anzahl: %d -> %d, Ort: '%s' -> '%s'.",
							originalItem.getName(), item.getId(), originalItem.getQuantity(), item.getQuantity(),
							originalItem.getLocation(), item.getLocation());
					AdminLogService.log(adminUser.getUsername(), "UPDATE_STORAGE_ITEM", logDetails);
					request.getSession().setAttribute("successMessage",
							"Artikel '" + item.getName() + "' erfolgreich aktualisiert.");
				}
			}

			if (!success) {
				request.getSession().setAttribute("errorMessage",
						"Operation am Artikel fehlgeschlagen. Möglicherweise gab es keine Änderungen.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid number format for quantity or ID.", e);
			request.getSession().setAttribute("errorMessage", "Ungültiges Zahlenformat für Anzahl oder ID.");
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/storage");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);

			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageFile = new File(AppConfig.UPLOAD_DIRECTORY + File.separator + "images", item.getImagePath());
				if (imageFile.exists()) {
					if (imageFile.delete()) {
						logger.info("Deleted physical image file: {}", imageFile.getAbsolutePath());
					} else {
						logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
					}
				}
			}

			if (storageDAO.deleteItem(itemId)) {
				String itemName = (item != null) ? item.getName() : "N/A";
				String itemLocation = (item != null) ? item.getLocation() : "N/A";
				String logDetails = String.format("Lagerartikel '%s' (ID: %d) von Ort '%s' gelöscht.", itemName, itemId,
						itemLocation);
				AdminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", logDetails);
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Artikel konnte nicht aus der Datenbank gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/storage");
	}

	private String getPartValue(Part part) throws IOException {
		if (part == null) {
			return null;
		}
		try (InputStream inputStream = part.getInputStream();
				Scanner scanner = new Scanner(inputStream, StandardCharsets.UTF_8.name())) {
			return scanner.useDelimiter("\\A").hasNext() ? scanner.next() : "";
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminTaskServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Arrays;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/tasks`, this servlet manages administrative actions for
 * event tasks. It handles POST requests for creating and assigning tasks, and
 * DELETE requests for removing them. All actions are logged to the admin audit
 * trail. It's designed to be called via forms or AJAX from the event details
 * page.
 */
@WebServlet("/admin/tasks")
public class AdminTaskServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminTaskServlet.class);
	private EventTaskDAO taskDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		logger.debug("AdminTaskServlet received POST with action: {}", action);

		switch (action) {
		case "create":
			handleCreateTask(request, response);
			break;
		case "assign":
			handleAssignTask(request, response);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unknown action");
			break;
		}
	}

	private void handleCreateTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		String description = request.getParameter("description");
		logger.info("Creating new task '{}' for event ID {}", description, eventId);

		EventTask newTask = new EventTask();
		newTask.setEventId(eventId);
		newTask.setDescription(description);

		int newTaskId = taskDAO.createTask(newTask);
		if (newTaskId > 0) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_TASK",
					"Aufgabe '" + description + "' (ID: " + newTaskId + ") für Event-ID " + eventId + " erstellt.");
		}
		response.sendRedirect(request.getContextPath() + "/eventDetails?id=" + eventId);
	}

	private void handleAssignTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		String[] userIdsStr = request.getParameterValues("userIds");
		int[] userIds = userIdsStr == null ? new int[0]
				: Arrays.stream(userIdsStr).mapToInt(Integer::parseInt).toArray();

		logger.info("Assigning task ID {} to {} users for event ID {}", taskId, userIds.length, eventId);
		taskDAO.assignTaskToUsers(taskId, userIds);

		String assignedUserIdsString = userIds.length > 0
				? Arrays.stream(userIds).mapToObj(String::valueOf).collect(Collectors.joining(", "))
				: "niemandem";
		AdminLogService.log(adminUser.getUsername(), "ASSIGN_TASK", "Aufgabe (ID: " + taskId + ") für Event-ID "
				+ eventId + " an Nutzer-IDs [" + assignedUserIdsString + "] zugewiesen.");

		response.sendRedirect(request.getContextPath() + "/eventDetails?id=" + eventId);
	}

	@Override
	protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int taskId = Integer.parseInt(req.getParameter("taskId"));
			logger.warn("Attempting to delete task ID {} by user '{}'", taskId, adminUser.getUsername());
			if (taskDAO.deleteTask(taskId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_TASK", "Aufgabe mit ID " + taskId + " gelöscht.");
				resp.setStatus(HttpServletResponse.SC_OK);
			} else {
				resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid task ID format for deletion.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid task ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Mapped to `/admin/users`, this servlet is the central controller for user
 * management by administrators. It handles listing all users, showing a
 * detailed view for a single user (including their event history), and
 * processing POST requests for creating, updating, and deleting user accounts.
 * All actions are logged for auditing.
 */
@WebServlet("/admin/users")
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private UserDAO userDAO;
	private EventDAO eventDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
		eventDAO = new EventDAO();
		logger.info("AdminUserServlet initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		logger.debug("AdminUserServlet received GET with action: {}", action);
		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/users");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		logger.debug("AdminUserServlet received POST with action: {}", action);
		if (action == null) {
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		try {
			switch (action) {
			case "create":
				handleCreateUser(request, response);
				break;
			case "update":
				handleUpdateUser(request, response);
				break;
			case "delete":
				handleDeleteUser(request, response);
				break;
			default:
				logger.warn("Unknown POST action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/users");
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doPost", e);
			request.getSession().setAttribute("errorMessage",
					"Ein schwerwiegender Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/users");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Listing all users for admin view.");
		List<User> userList = userDAO.getAllUsers();
		request.setAttribute("userList", userList);
		request.getRequestDispatcher("/admin/admin_users.jsp").forward(request, response);
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		logger.info("Showing details for user ID: {}", userId);
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);

		request.setAttribute("userToEdit", user);
		request.setAttribute("eventHistory", eventHistory);
		logger.debug("Forwarding to user details page for user '{}'", user.getUsername());
		request.getRequestDispatcher("/admin/admin_user_details.jsp").forward(request, response);
	}

	private void handleCreateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		String username = request.getParameter("username");
		String pass = request.getParameter("password");
		String role = request.getParameter("role");

		if (username == null || username.trim().isEmpty() || pass == null || pass.trim().isEmpty()) {
			request.getSession().setAttribute("errorMessage", "Benutzername und Passwort dürfen nicht leer sein.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		logger.info("Attempting to create new user '{}' with role '{}'", username, role);
		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRole(role);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0); // Default value
		}
		newUser.setClassName(request.getParameter("className"));

		int newUserId = userDAO.createUser(newUser, pass);
		if (newUserId > 0) {
			User adminUser = (User) request.getSession().getAttribute("user");
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s, Klasse: %d %s) erstellt.",
					newUser.getUsername(), newUserId, newUser.getRole(), newUser.getClassYear(),
					newUser.getClassName());
			AdminLogService.log(adminUser.getUsername(), "CREATE_USER", logDetails);
			request.getSession().setAttribute("successMessage",
					"Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.");
		} else {
			request.getSession().setAttribute("errorMessage",
					"Benutzer konnte nicht erstellt werden (ggf. existiert der Name bereits).");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}

	private void handleUpdateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userId = Integer.parseInt(request.getParameter("userId"));
		User adminUser = (User) request.getSession().getAttribute("user");
		User originalUser = userDAO.getUserById(userId);

		if (originalUser == null) {
			logger.error("Attempted to update non-existent user with ID: {}", userId);
			request.getSession().setAttribute("errorMessage", "Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		logger.info("Attempting to update user '{}' (ID: {})", originalUser.getUsername(), userId);

		User updatedUser = new User();
		updatedUser.setId(userId);
		updatedUser.setUsername(request.getParameter("username").trim());
		updatedUser.setRole(request.getParameter("role"));
		updatedUser.setClassName(request.getParameter("className"));
		try {
			updatedUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		List<String> changes = new ArrayList<>();
		if (!Objects.equals(originalUser.getUsername(), updatedUser.getUsername()))
			changes.add("Benutzername von '" + originalUser.getUsername() + "' zu '" + updatedUser.getUsername() + "'");
		if (!Objects.equals(originalUser.getRole(), updatedUser.getRole()))
			changes.add("Rolle von '" + originalUser.getRole() + "' zu '" + updatedUser.getRole() + "'");
		if (originalUser.getClassYear() != updatedUser.getClassYear())
			changes.add("Jahrgang von '" + originalUser.getClassYear() + "' zu '" + updatedUser.getClassYear() + "'");
		if (!Objects.equals(originalUser.getClassName(), updatedUser.getClassName()))
			changes.add("Klasse von '" + originalUser.getClassName() + "' zu '" + updatedUser.getClassName() + "'");

		if (!changes.isEmpty()) {
			if (userDAO.updateUser(updatedUser)) {
				String logDetails = String.format("Benutzer '%s' (ID: %d) aktualisiert. Änderungen: %s.",
						originalUser.getUsername(), userId, String.join(", ", changes));
				AdminLogService.log(adminUser.getUsername(), "UPDATE_USER", logDetails);
				request.getSession().setAttribute("successMessage", "Benutzerdaten erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Benutzerdaten konnten nicht in der DB aktualisiert werden.");
			}
		} else {
			request.getSession().setAttribute("infoMessage", "Keine Änderungen an den Benutzerdaten vorgenommen.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users?action=details&id=" + userId);
	}

	private void handleDeleteUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) request.getSession().getAttribute("user");

		if (loggedInAdmin.getId() == userIdToDelete) {
			logger.warn("Admin '{}' (ID: {}) attempted to delete themselves. Operation denied.",
					loggedInAdmin.getUsername(), loggedInAdmin.getId());
			request.getSession().setAttribute("errorMessage", "Sie können sich nicht selbst löschen.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}

		User userToDelete = userDAO.getUserById(userIdToDelete);
		logger.warn("Admin '{}' is attempting to delete user '{}' (ID: {})", loggedInAdmin.getUsername(),
				userToDelete != null ? userToDelete.getUsername() : "N/A", userIdToDelete);

		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.",
					(userToDelete != null ? userToDelete.getUsername() : "N/A"), userIdToDelete,
					(userToDelete != null ? userToDelete.getRole() : "N/A"));
			AdminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);
			request.getSession().setAttribute("successMessage", "Benutzer erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Benutzer konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/matrix`, this servlet constructs the data for the
 * comprehensive qualification and attendance matrix. It fetches all users, all
 * course templates, all meetings for each course, and all attendance records.
 * It then organizes this data and forwards it to `admin_matrix.jsp` for
 * rendering a grid view that shows which users have attended which course
 * meetings.
 */
@WebServlet("/admin/matrix")
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private UserDAO userDAO;
	private CourseDAO courseDAO;
	private MeetingDAO meetingDAO;
	private MeetingAttendanceDAO meetingAttendanceDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
		courseDAO = new CourseDAO();
		meetingDAO = new MeetingDAO();
		meetingAttendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		// 1. Fetch all users who will be rows in the matrix
		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		// 2. Fetch all parent courses which define the top-level columns
		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		// 3. For each course, fetch its scheduled meetings to create sub-columns
		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		// 4. Fetch all attendance records and put them in a map for quick lookup.
		// The key is a "userId-meetingId" string.
		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		// 5. Set all data as request attributes for the JSP
		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		request.getRequestDispatcher("/admin/admin_matrix.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CollaborativeEditorServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/editor-page`, this is a very simple servlet whose only purpose is
 * to forward the user to the `collaborative_editor.jsp` page. All the dynamic
 * functionality for the editor is handled client-side by JavaScript and the
 * `DocumentApiServlet`.
 */
@WebServlet("/editor-page")
public class CollaborativeEditorServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/collaborative_editor.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DocumentApiServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.stream.Collectors;

import de.technikteam.dao.FileDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/api/document`, this servlet provides a simple REST-like API for
 * the collaborative text editor. A GET request fetches the latest document
 * content, while a POST request (with the new content in its raw body) updates
 * the document in the database. It interacts with `FileDAO` to persist the
 * content.
 */
@WebServlet("/api/document")
public class DocumentApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DocumentApiServlet.class);
	private FileDAO fileDAO;
	private static final String DOCUMENT_NAME = "realtime_notes";

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	/**
	 * Handles GET requests to fetch the latest content of the shared document.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.trace("GET request for document content '{}'", DOCUMENT_NAME);
		String content = fileDAO.getDocumentContent(DOCUMENT_NAME);

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(content);
	}

	/**
	 * Handles POST requests to update the document content. It reads the raw text
	 * from the request body.
	 */
	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String content = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		logger.trace("POST request to update document content for '{}'. Content length: {}", DOCUMENT_NAME,
				content.length());

		boolean success = fileDAO.updateDocumentContent(DOCUMENT_NAME, content);

		if (success) {
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update document content for '{}'", DOCUMENT_NAME);
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DownloadServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/download`, this servlet handles file download requests for both
 * general files and meeting attachments. It takes a `file` parameter which
 * corresponds to a path relative to the application's upload directory. It
 * performs basic security checks, constructs the full file path, and streams
 * the file from the server's filesystem to the user's browser, setting the
 * correct headers to trigger a download dialog.
 */
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DownloadServlet.class);

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String relativePath = request.getParameter("file");
		if (relativePath == null || relativePath.isEmpty()) {
			logger.warn("Download request rejected: missing 'file' parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Fehlender 'file' Parameter.");
			return;
		}

		User user = (User) request.getSession().getAttribute("user");

		// Basic security measure to prevent path traversal attacks (e.g., ../../)
		if (relativePath.contains("..")) {
			logger.warn("Potential path traversal attack from user '{}' for file '{}'. Access denied.",
					(user != null ? user.getUsername() : "GUEST"), relativePath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Zugriff verweigert.");
			return;
		}

		File file = new File(AppConfig.UPLOAD_DIRECTORY, relativePath);
		if (!file.exists() || !file.isFile()) {
			logger.error("Download failed: File not found at resolved path {}", file.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Datei nicht gefunden.");
			return;
		}

		response.setContentType("application/octet-stream");
		response.setContentLengthLong(file.length());

		String headerKey = "Content-Disposition";
		// URL-encode the filename to handle special characters and spaces correctly.
		String headerValue = String.format("attachment; filename=\"%s\"",
				URLEncoder.encode(file.getName(), StandardCharsets.UTF_8.toString()));
		response.setHeader(headerKey, headerValue);

		logger.info("User '{}' is downloading file: {}. Size: {} bytes.", (user != null ? user.getUsername() : "GUEST"),
				file.getAbsolutePath(), file.length());

		try (FileInputStream inStream = new FileInputStream(file);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;
			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventActionServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/event-action`, this servlet processes POST requests from the main
 * event listing page (`events.jsp`). It allows a logged-in user to either sign
 * up for (`signup`) or sign off from (`signoff`) an event by updating the
 * `event_attendance` table via the `EventDAO`.
 */
@WebServlet("/event-action")
public class EventActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventActionServlet.class);
	private EventDAO eventDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String eventIdParam = request.getParameter("eventId");

		if (user == null || action == null || eventIdParam == null) {
			logger.warn("Invalid request to EventActionServlet. Missing user, action, or eventId parameter.");
			response.sendRedirect(request.getContextPath() + "/events");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.info("User '{}' (ID: {}) is performing action '{}' on event ID {}", user.getUsername(), user.getId(),
					action, eventId);

			if ("signup".equals(action)) {
				eventDAO.signUpForEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Event angemeldet.");
			} else if ("signoff".equals(action)) {
				eventDAO.signOffFromEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Event abgemeldet.");
			} else {
				logger.warn("Unknown action received in EventActionServlet: {}", action);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in EventActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}

		// Redirect back to the event list page to show the updated status
		response.sendRedirect(request.getContextPath() + "/events");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventChatApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/api/event-chat`, this servlet provides a JSON API for the
 * real-time event chat feature. A GET request fetches all messages for a given
 * event ID. A POST request allows a logged-in user to submit a new message for
 * an event. It uses the Gson library for JSON serialization.
 */
@WebServlet("/api/event-chat")
public class EventChatApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventChatApiServlet.class);
	private EventChatDAO chatDAO;
	private Gson gson;

	@Override
	public void init() {
		chatDAO = new EventChatDAO();
		gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			logger.trace("GET request for chat messages for event ID: {}", eventId);
			List<EventChatMessage> messages = chatDAO.getMessagesForEvent(eventId);
			String jsonResponse = gson.toJson(messages);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat API: Invalid or missing eventId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing eventId.");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			String messageText = request.getParameter("messageText");
			User user = (User) request.getSession().getAttribute("user");

			if (user == null || messageText == null || messageText.trim().isEmpty()) {
				logger.warn("Bad POST request to event chat API: Missing user session or message text for event ID {}",
						eventId);
				response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing user or message text.");
				return;
			}

			logger.info("User '{}' posting message to event chat for event ID {}: '{}'", user.getUsername(), eventId,
					messageText);

			EventChatMessage newMessage = new EventChatMessage();
			newMessage.setEventId(eventId);
			newMessage.setUserId(user.getId());
			newMessage.setUsername(user.getUsername());
			newMessage.setMessageText(messageText);

			if (chatDAO.postMessage(newMessage)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				logger.error("Failed to post chat message for user '{}' to event ID {}", user.getUsername(), eventId);
				response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat API: Invalid eventId in POST.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid event ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.util.stream.Collectors;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/eventDetails`, this servlet is responsible for displaying the
 * detailed view of a single event. It fetches all relevant data for the event,
 * including its description, skill requirements, and assigned team. If the
 * event is currently 'LAUFEND' (running), it also fetches associated tasks and
 * chat history. It forwards all this data to `eventDetails.jsp`.
 */
@WebServlet("/eventDetails")
public class EventDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventDetailsServlet.class);
	private EventDAO eventDAO;
	private EventTaskDAO taskDAO;
	private EventChatDAO chatDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		taskDAO = new EventTaskDAO();
		chatDAO = new EventChatDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(request.getParameter("id"));
			logger.info("Event details requested for ID: {} by user '{}'", eventId, user.getUsername());
			Event event = eventDAO.getEventById(eventId);

			if (event == null) {
				logger.warn("Event with ID {} not found. Redirecting to 404.", eventId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event nicht gefunden.");
				return;
			}

			// Fetch base data applicable to all event statuses
			event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
			List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
			event.setAssignedAttendees(assignedUsers);

			// Fetch data specific to running events (tasks, chat)
			if ("LAUFEND".equalsIgnoreCase(event.getStatus())) {
				logger.debug("Event {} is running. Fetching tasks and chat messages.", eventId);
				event.setEventTasks(taskDAO.getTasksForEvent(eventId));
				event.setChatMessages(chatDAO.getMessagesForEvent(eventId));
			}

			// For Admins, provide the list of assigned users for the task assignment
			// dropdown
			if ("ADMIN".equalsIgnoreCase(user.getRole())) {
				request.setAttribute("assignedUsers", assignedUsers);
			}

			// For regular users, determine if they are part of the assigned team to show
			// relevant UI
			Set<Integer> assignedUserIds = assignedUsers.stream().map(User::getId).collect(Collectors.toSet());
			boolean isUserAssigned = assignedUserIds.contains(user.getId());
			request.setAttribute("isUserAssigned", isUserAssigned);

			request.setAttribute("event", event);
			logger.debug("Forwarding to eventDetails.jsp for event '{}'", event.getName());
			request.getRequestDispatcher("/eventDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		} catch (Exception e) {
			logger.error("An unexpected error occurred while fetching event details.", e);
			response.sendRedirect(request.getContextPath() + "/error500.jsp");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/events`, this servlet is responsible for the main event listing
 * page for a logged-in user. It fetches a list of all upcoming events for which
 * the user is qualified, along with their specific attendance status for each
 * event (e.g., ZUGEWIESEN, ANGEMELDET, OFFEN). It then passes this data to
 * `events.jsp`.
 */
@WebServlet("/events")
public class EventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventServlet.class);
	private EventDAO eventDAO;

	public void init() {
		eventDAO = new EventDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming events for user '{}' (ID: {})", user.getUsername(), user.getId());

		// The DAO method intelligently calculates the most relevant status for the
		// user.
		List<Event> events = eventDAO.getUpcomingEventsForUser(user, 0); // 0 means no limit

		request.setAttribute("events", events);
		logger.debug("Found {} upcoming events for user '{}'. Forwarding to events.jsp.", events.size(),
				user.getUsername());
		request.getRequestDispatcher("/events.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FileServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/dateien`, this servlet handles the display of the main files and
 * documents page for users. It fetches all files the user is permitted to see,
 * grouped by category. In a unique step, it programmatically injects a
 * "virtual" file entry that links to the collaborative live editor, placing it
 * in a specific category for a seamless user experience.
 */
@WebServlet("/dateien")
public class FileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("File page requested by user '{}' (Role: {})", user.getUsername(), user.getRole());

		// 1. Fetch files from the database, already filtered by the user's role in the
		// DAO.
		Map<String, List<File>> fileData = fileDAO.getAllFilesGroupedByCategory(user);

		// 2. Create our "virtual" file object for the collaborative editor.
		File collaborativeFile = new File();
		collaborativeFile.setId(-1); // Use a special ID to identify it in the JSP.
		collaborativeFile.setFilename("Gemeinsamer Notizblock (Live-Editor)");
		collaborativeFile.setFilepath(null); // No physical file path.

		// 3. Add the virtual file to a specific category. If the category doesn't
		// exist, create it.
		String virtualCategoryName = "Allgemeine Dokumente";
		List<File> generalFiles = fileData.computeIfAbsent(virtualCategoryName, k -> new ArrayList<>());
		generalFiles.add(0, collaborativeFile); // Add to the beginning of the list.

		// 4. Send the modified map to the JSP.
		request.setAttribute("fileData", fileData);
		logger.debug("Forwarding file data (including virtual editor link) to dateien.jsp.");
		request.getRequestDispatcher("/dateien.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\HomeServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapped to `/home`, this servlet serves the main landing page for a logged-in
 * user. It provides a quick overview by fetching a limited number of upcoming
 * events and meetings that are relevant to the user. The fetched data is then
 * forwarded to `home.jsp` for display.
 */
@WebServlet("/home")
public class HomeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(HomeServlet.class);
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;

	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Home page requested by user '{}'. Fetching dashboard data.", user.getUsername());

		// Fetch up to 3 upcoming events the user is qualified for
		List<Event> upcomingEvents = eventDAO.getUpcomingEventsForUser(user, 3);
		logger.debug("Fetched {} upcoming events for home page.", upcomingEvents.size());

		// Fetch all upcoming meetings and then limit to the first 3
		List<Meeting> upcomingMeetings = meetingDAO.getUpcomingMeetingsForUser(user).stream().limit(3)
				.collect(Collectors.toList());
		logger.debug("Fetched {} upcoming meetings for home page.", upcomingMeetings.size());

		request.setAttribute("upcomingEvents", upcomingEvents);
		request.setAttribute("upcomingMeetings", upcomingMeetings);

		logger.debug("Forwarding to home.jsp.");
		request.getRequestDispatcher("/home.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ImageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/image`, this servlet acts as a secure proxy to serve images. It
 * prevents direct filesystem access by taking a `file` parameter, locating the
 * image within a designated `images` subdirectory in the main upload path, and
 * then streaming it to the browser. It sets the `Content-Disposition: inline`
 * header so the image is displayed directly on the web page rather than
 * downloaded.
 */
@WebServlet("/image")
public class ImageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(ImageServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String filename = request.getParameter("file");
		if (filename == null || filename.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing 'file' parameter.");
			return;
		}

		try {
			filename = URLDecoder.decode(filename, StandardCharsets.UTF_8.toString());
		} catch (IllegalArgumentException e) {
			logger.warn("Could not decode filename: {}", filename, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid filename encoding.");
			return;
		}

		// Prevent path traversal
		if (filename.contains("..")) {
			logger.warn("Potential path traversal attack detected for image filename: {}", filename);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		// Construct the full path to the image file inside the 'images' subdirectory
		File imageFile = new File(AppConfig.UPLOAD_DIRECTORY + File.separator + "images", filename);

		if (!imageFile.exists() || !imageFile.isFile()) {
			logger.warn("Image not found at path: {}", imageFile.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Image not found.");
			return;
		}

		// Determine content type (MIME type) from file extension
		String contentType = getServletContext().getMimeType(imageFile.getName());
		if (contentType == null) {
			contentType = "application/octet-stream"; // Fallback if type is unknown
		}

		response.setContentType(contentType);
		response.setContentLengthLong(imageFile.length());

		// The 'inline' header tells the browser to display the file, not to download
		// it.
		response.setHeader("Content-Disposition", "inline; filename=\"" + imageFile.getName() + "\"");

		logger.debug("Serving image: {} with content type {}", imageFile.getAbsolutePath(), contentType);

		// Stream the file content to the response
		try (FileInputStream inStream = new FileInputStream(imageFile);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;

			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LoginServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/login`, this servlet is central to the application's
 * authentication. It handles GET requests to simply display the `login.jsp`
 * page. It handles POST requests by taking a username and password, validating
 * them against the database via `UserDAO`, and creating a user session upon
 * successful authentication. If authentication fails, it forwards back to the
 * login page with an error message.
 */
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LoginServlet.class);
	private UserDAO userDAO;

	public void init() {
		userDAO = new UserDAO();
		logger.info("LoginServlet initialized.");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		logger.info("Login attempt for username: {}", username);

		// NOTE: This uses plaintext password validation for simplicity.
		// In a production environment, use a strong hashing library like BCrypt.
		User user = userDAO.validateUser(username, password);

		if (user != null) {
			// Create a new session for the user
			HttpSession session = request.getSession();
			session.setAttribute("user", user); // Store the entire user object
			session.setAttribute("username", user.getUsername());
			session.setAttribute("role", user.getRole());

			logger.info("Login successful for user: {}. Role: {}. Redirecting to home.", user.getUsername(),
					user.getRole());
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			logger.warn("Login failed for username: {}. Invalid credentials.", username);
			request.setAttribute("errorMessage", "Benutzername oder Passwort ungültig.");
			request.getRequestDispatcher("login.jsp").forward(request, response);
		}
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received for /login. Forwarding to login.jsp.");
		request.getRequestDispatcher("login.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LogoutServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/logout`, this servlet handles the user logout process. It
 * invalidates the current session, effectively logging the user out and
 * clearing all session attributes. It then redirects the user to a `logout.jsp`
 * confirmation page, passing the username as a parameter for a personalized
 * message.
 */
@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LogoutServlet.class);

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		String username = "Gast";

		if (session != null) {
			if (session.getAttribute("username") != null) {
				username = (String) session.getAttribute("username");
			}
			logger.info("Logging out user: {}. Invalidating session.", username);
			session.invalidate();
		} else {
			logger.warn("Logoutservlet called but no active session found.");
		}

		// Redirect to the logout page with the username as a URL parameter
		response.sendRedirect("logout.jsp?username=" + URLEncoder.encode(username, StandardCharsets.UTF_8.toString()));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/meeting-action`, this servlet processes POST requests from the
 * main course/meeting listing page (`lehrgaenge.jsp`). It allows a logged-in
 * user to either sign up for (`signup`) or sign off from (`signoff`) a specific
 * meeting by updating the `meeting_attendance` table via the
 * `MeetingAttendanceDAO`.
 */
@WebServlet("/meeting-action")
public class MeetingActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingActionServlet.class);
	private MeetingAttendanceDAO attendanceDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String meetingIdParam = request.getParameter("meetingId");

		if (user == null || action == null || meetingIdParam == null) {
			logger.warn("Invalid request to MeetingActionServlet. Missing user, action, or meetingId.");
			response.sendRedirect(request.getContextPath() + "/lehrgaenge");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			logger.info("User '{}' (ID: {}) performing action '{}' on meeting ID {}", user.getUsername(), user.getId(),
					action, meetingId);

			if ("signup".equals(action)) {
				// The DAO method handles both new signups and re-signups.
				attendanceDAO.setAttendance(user.getId(), meetingId, true, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Meeting angemeldet.");
			} else if ("signoff".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, false, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Meeting abgemeldet.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format in MeetingActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Meeting-ID.");
		}

		// Redirect back to the meeting list page to show the updated status.
		response.sendRedirect(request.getContextPath() + "/lehrgaenge");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingAttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/meetingDetails`, this servlet handles GET requests to display the
 * detailed view of a single course meeting. It fetches the core meeting data as
 * well as any associated file attachments, applying role-based filtering for
 * the attachments. The collected data is then forwarded to
 * `meetingDetails.jsp`.
 */
@WebServlet("/meetingDetails")
public class MeetingDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingDetailsServlet.class);
	private MeetingDAO meetingDAO;
	private MeetingAttachmentDAO attachmentDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		attachmentDAO = new MeetingAttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		String meetingIdParam = request.getParameter("id");
		if (meetingIdParam == null || meetingIdParam.isEmpty()) {
			logger.warn("Bad request to MeetingDetailsServlet: missing ID parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Meeting-ID fehlt.");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			User user = (User) request.getSession().getAttribute("user");
			logger.info("Meeting details for ID {} requested by user '{}'", meetingId, user.getUsername());

			Meeting meeting = meetingDAO.getMeetingById(meetingId);

			if (meeting == null) {
				logger.warn("Meeting with ID {} not found.", meetingId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden.");
				return;
			}

			// Fetch attachments for the meeting, respecting the user's role
			request.setAttribute("attachments", attachmentDAO.getAttachmentsForMeeting(meetingId, user.getRole()));
			request.setAttribute("meeting", meeting);

			logger.debug("Forwarding to meetingDetails.jsp for meeting '{}'", meeting.getName());
			request.getRequestDispatcher("/meetingDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format: {}", meetingIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/lehrgaenge`, this servlet is responsible for the main
 * course/meeting listing page for a logged-in user. It fetches a list of all
 * upcoming meetings and enriches each one with the user's specific attendance
 * status (e.g., ANGEMELDET, ABGEMELDET, OFFEN). This data is then passed to
 * `lehrgaenge.jsp` for rendering.
 */
@WebServlet("/lehrgaenge")
public class MeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingServlet.class);
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming meetings for user '{}' (ID: {})", user.getUsername(), user.getId());

		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);

		request.setAttribute("meetings", meetings);
		logger.debug("Found {} upcoming meetings. Forwarding to lehrgaenge.jsp.", meetings.size());
		request.getRequestDispatcher("/lehrgaenge.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\NotificationServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/notifications`, this servlet is the entry point for clients
 * wanting to receive real-time updates via Server-Sent Events (SSE). On a GET
 * request, it establishes a persistent connection by setting the appropriate
 * headers and registering the client's asynchronous context with the singleton
 * `NotificationService`. It requires an active user session to connect.
 */
@WebServlet(urlPatterns = "/notifications", asyncSupported = true)
public class NotificationServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(NotificationServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Unauthorized attempt to connect to SSE stream. No session.");
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		logger.info("Client '{}' connecting to SSE stream.", session.getAttribute("username"));

		// Set headers for Server-Sent Events
		response.setContentType("text/event-stream");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Cache-Control", "no-cache");
		response.setHeader("Connection", "keep-alive");

		// Register the client with the notification service
		NotificationService.getInstance().register(request);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PasswordServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/passwort`, this servlet allows a logged-in user to change their
 * own password. It handles GET requests by displaying the change form
 * (`passwort.jsp`) and POST requests by processing the password change. This
 * includes validating the user's current password and ensuring the new password
 * confirmation matches before updating the database via `UserDAO`.
 */
@WebServlet("/passwort")
public class PasswordServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PasswordServlet.class);
	private UserDAO userDAO;

	public void init() {
		userDAO = new UserDAO();
		logger.info("PasswordServlet initialized.");
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received, showing password change form.");
		request.getRequestDispatcher("passwort.jsp").forward(request, response);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		logger.info("Password change attempt for user: {}", user.getUsername());

		String currentPassword = request.getParameter("currentPassword");
		String newPassword = request.getParameter("newPassword");
		String confirmPassword = request.getParameter("confirmPassword");

		// Validate that the user knows their current password
		User authenticatedUser = userDAO.validateUser(user.getUsername(), currentPassword);
		if (authenticatedUser == null) {
			logger.warn("Password change failed for {}: incorrect current password.", user.getUsername());
			request.setAttribute("errorMessage", "Das aktuelle Passwort ist nicht korrekt.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		if (!newPassword.equals(confirmPassword)) {
			logger.warn("Password change failed for {}: new passwords do not match.", user.getUsername());
			request.setAttribute("errorMessage", "Die neuen Passwörter stimmen nicht überein.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		if (newPassword.trim().isEmpty()) {
			logger.warn("Password change failed for {}: new password is empty.", user.getUsername());
			request.setAttribute("errorMessage", "Das neue Passwort darf nicht leer sein.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		boolean success = userDAO.changePassword(user.getId(), newPassword);
		if (success) {
			logger.info("Password successfully changed for user: {}", user.getUsername());
			request.setAttribute("successMessage", "Ihr Passwort wurde erfolgreich geändert.");
		} else {
			logger.error("Password change failed for {} due to a DAO error.", user.getUsername());
			request.setAttribute("errorMessage", "Ein interner Fehler ist aufgetreten. Bitte versuchen Sie es erneut.");
		}
		request.getRequestDispatcher("passwort.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/storage-item`, this servlet displays a public-facing detail page
 * for a single inventory item. It is typically accessed by scanning a QR code
 * that contains the URL with the item's ID. It fetches the item's data using
 * `StorageDAO` and forwards it to `storage_item_details.jsp` for rendering.
 */
@WebServlet("/storage-item")
public class StorageItemDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageItemDetailsServlet.class);
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			logger.info("Storage item details requested for ID: {}", itemId);

			StorageItem item = storageDAO.getItemById(itemId);

			if (item == null) {
				logger.warn("Storage item with ID {} not found.", itemId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}

			request.setAttribute("item", item);
			logger.debug("Forwarding to storage_item_details.jsp for item '{}'", item.getName());
			request.getRequestDispatcher("/storage_item_details.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid storage item ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet, mapped to `/lager`, is responsible for displaying the main
 * inventory/storage page for users. On a GET request, it fetches all storage
 * items from the database, grouped by their physical location, and forwards
 * this structured data to `lager.jsp` for rendering.
 */
@WebServlet("/lager")
public class StorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageServlet.class);
	private StorageDAO storageDAO;

	public void init() {
		storageDAO = new StorageDAO();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Main storage page requested. Fetching all items.");

		// Fetch all items, grouped by their location (e.g., "Erdgeschoss",
		// "Lagercontainer").
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();

		request.setAttribute("storageData", storageData);
		logger.debug("Forwarding {} location groups to lager.jsp.", storageData.size());
		request.getRequestDispatcher("lager.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageTransactionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.sql.SQLException;

/**
 * Mapped to `/storage-transaction`, this servlet handles the business logic for
 * checking items in and out of the inventory. It processes POST requests from
 * the modal on the main storage page. It atomically updates the item quantity
 * in the `storage_items` table and creates a record of the transaction in both
 * the `storage_log` table and the main administrative audit log.
 */
@WebServlet("/storage-transaction")
public class StorageTransactionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageTransactionServlet.class);
	private StorageDAO storageDAO;
	private StorageLogDAO storageLogDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		storageLogDAO = new StorageLogDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String redirectUrl = request.getParameter("redirectUrl");
		if (redirectUrl == null || redirectUrl.isEmpty()) {
			redirectUrl = request.getContextPath() + "/lager";
		}

		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			int quantity = Integer.parseInt(request.getParameter("quantity"));
			String type = request.getParameter("type"); // "checkout" or "checkin"
			String notes = request.getParameter("notes");

			int quantityChange = "checkin".equals(type) ? quantity : -quantity;
			logger.info("Processing storage transaction by user '{}': item ID {}, quantity change {}",
					user.getUsername(), itemId, quantityChange);

			// Atomically update the quantity. This can fail if there's not enough stock.
			boolean success = storageDAO.updateItemQuantity(itemId, quantityChange);

			if (success) {
				// Log the transaction in the specific storage log and the general admin log.
				storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, notes);

				StorageItem item = storageDAO.getItemById(itemId);
				String itemName = (item != null) ? item.getName() : "N/A";
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, itemName, itemId,
						action, notes);
				AdminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

				request.getSession().setAttribute("successMessage",
						"Erfolgreich " + quantity + " Stück " + action + ".");
			} else {
				logger.warn("Storage transaction failed for item ID {}. Not enough stock.", itemId);
				request.getSession().setAttribute("errorMessage",
						"Transaktion fehlgeschlagen. Nicht genügend Artikel auf Lager?");
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid number format in storage transaction request.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültiges Zahlenformat.");
		} catch (SQLException e) {
			logger.error("SQL error during storage transaction.", e);
			request.getSession().setAttribute("errorMessage", "Datenbankfehler bei der Transaktion: " + e.getMessage());
		}

		response.sendRedirect(redirectUrl);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\TaskActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/task-action`, this servlet handles task status updates initiated
 * by non-admin users, typically via AJAX from the event details page. It
 * processes a POST request to change a task's status (e.g., from "OFFEN" to
 * "ERLEDIGT") when a user checks a checkbox corresponding to their assigned
 * task.
 */
@WebServlet("/task-action")
public class TaskActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(TaskActionServlet.class);
	private EventTaskDAO taskDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		try {
			int taskId = Integer.parseInt(request.getParameter("taskId"));
			String status = request.getParameter("status");
			logger.info("User '{}' is updating task ID {} to status '{}'", user.getUsername(), taskId, status);

			if (taskDAO.updateTaskStatus(taskId, status)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				logger.error("Failed to update task status for task ID {}", taskId);
				response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Task status could not be updated.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid task ID format in task-action request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid task ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<!-- Log4j2 Configuration File This file controls all logging behavior for 
	the application. It defines where log messages are sent (appenders) and at 
	what detail level (loggers). It's configured to log to both the server console 
	(for live debugging in Eclipse) and a rolling file on the server's filesystem 
	for persistent records. -->
<Configuration status="WARN">
	<Properties>
		<!-- Use the 'catalina.base' system property provided by Tomcat to create 
			the logs folder in a guaranteed writable location relative to the server 
			instance (e.g., .../wst.server.core/tmp0/logs). This avoids permission issues 
			with writing to the source directory. -->
		<Property name="log-path">${sys:catalina.base}/logs</Property>
	</Properties>

	<Appenders>
		<!-- Console Appender: Sends log output to SYSTEM_OUT, which is typically 
			visible in the Eclipse Console view. -->
		<Console name="Console" target="SYSTEM_OUT">
			<!-- Pattern includes: timestamp, thread name, log level, logger name 
				(abbreviated), the log message, and a newline. -->
			<PatternLayout
				pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
		</Console>

		<!-- Rolling File Appender: Writes logs to a file. It "rolls over" (creates 
			a new file) based on time (daily) or size (10 MB), keeping a maximum of 10 
			old log files compressed in .gz format. -->
		<RollingFile name="RollingFile"
			fileName="${log-path}/technik-team-app.log"
			filePattern="${log-path}/technik-team-app-%d{MM-dd-yyyy}-%i.log.gz">
			<PatternLayout>
				<Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} -
					%msg%n</Pattern>
			</PatternLayout>
			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="10 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>
	</Appenders>

	<Loggers>
		<!-- Application-specific Logger: Logs all messages from the 'de.technikteam' 
			package and its sub-packages at the DEBUG level or higher (DEBUG, INFO, WARN, 
			ERROR, FATAL). 'additivity="false"' prevents these messages from being passed 
			up to the root logger, avoiding duplicate output. -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
			<AppenderRef ref="RollingFile" />
		</Logger>

		<!-- Root Logger: This is the catch-all logger for all other libraries 
			used in the project (e.g., Tomcat, HikariCP, etc.). Setting it to WARN reduces 
			log noise by only showing important warnings and errors from third-party 
			code. -->
		<Root level="warn">
			<AppenderRef ref="Console" />
			<AppenderRef ref="RollingFile" />
		</Root>
	</Loggers>
</Configuration>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_course_form.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_course_form.jsp
  
  This JSP provides the form for creating a new or editing an existing parent
  course template.
  
  - It is served by: AdminCourseServlet (doGet with action=new or action=edit).
  - It submits to: AdminCourseServlet (doPost).
  - Expected attributes:
    - 'course' (de.technikteam.model.Course): The course object to edit (optional, for edit mode).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title"
		value="${empty course ? 'Neue Lehrgangs-Vorlage anlegen' : 'Lehrgangs-Vorlage bearbeiten'}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>${empty course ? 'Neue Lehrgangs-Vorlage anlegen' : 'Lehrgangs-Vorlage bearbeiten'}</h1>
<p>Hier definieren Sie die übergeordnete Vorlage für einen Lehrgang.
	Einzelne Termine (Meetings) werden separat hinzugefügt.</p>

<div class="form-center-wrapper">
	<div class="card">
		<form action="${pageContext.request.contextPath}/admin/courses"
			method="post">

			<%-- The action determines whether the servlet should create or update. --%>
			<input type="hidden" name="action"
				value="${empty course ? 'create' : 'update'}">
			<c:if test="${not empty course}">
				<input type="hidden" name="id" value="${course.id}">
			</c:if>

			<div class="form-group">
				<label for="name">Name der Vorlage (z.B. Grundlehrgang
					Tontechnik)</label> <input type="text" id="name" name="name"
					value="${course.name}" required>
			</div>

			<div class="form-group">
				<label for="abbreviation">Abkürzung (für Matrix, max. 10
					Zeichen, z.B. GL-Ton)</label> <input type="text" id="abbreviation"
					name="abbreviation" value="${course.abbreviation}" maxlength="10"
					required>
			</div>

			<div class="form-group">
				<label for="description">Allgemeine Beschreibung des
					Lehrgangs</label>
				<textarea id="description" name="description" rows="4">${course.description}</textarea>
			</div>

			<div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
				<button type="submit" class="btn">Vorlage Speichern</button>
				<a href="${pageContext.request.contextPath}/admin/courses"
					class="btn" style="background-color: var(--text-muted-color);">Abbrechen</a>
			</div>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_course_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_course_list.jsp
  
  This JSP displays a list of all parent course templates for administrators.
  It provides actions to manage the meetings for each template, edit the
  template itself, or delete it. It features a responsive layout, showing
  cards on mobile and a table on desktop with client-side filtering and sorting.
  
  - It is served by: AdminCourseServlet (doGet).
  - Expected attributes:
    - 'courseList' (List<de.technikteam.model.Course>): A list of all course templates.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Lehrgangs-Vorlagen" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Lehrgangs-Vorlagen verwalten</h1>
<p>Dies sind die übergeordneten Lehrgänge. Einzelne Termine
	(Meetings) werden für jede Vorlage separat verwaltet.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<a href="${pageContext.request.contextPath}/admin/courses?action=new"
		class="btn">Neue Lehrgangs-Vorlage anlegen</a>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>


<c:if test="${empty courseList}">
	<div class="card">
		<p>Es wurden noch keine Lehrgangs-Vorlagen erstellt.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT: A list of cards, one for each course template -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="course" items="${courseList}">
		<div class="list-item-card"
			data-searchable-content="${course.name} ${course.abbreviation}">
			<h3 class="card-title">${course.name}</h3>
			<div class="card-row">
				<span>Abkürzung:</span> <span>${course.abbreviation}</span>
			</div>
			<div class="card-actions">
				<a
					href="${pageContext.request.contextPath}/admin/meetings?courseId=${course.id}"
					class="btn btn-small btn-success">Meetings verwalten</a> <a
					href="${pageContext.request.contextPath}/admin/courses?action=edit&id=${course.id}"
					class="btn btn-small">Vorlage bearbeiten</a>
				<form action="${pageContext.request.contextPath}/admin/courses"
					method="post" style="display: inline;">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="id" value="${course.id}">
					<button type="submit" class="btn btn-small btn-danger"
						onclick="return confirm('Vorlage \'${course.name}\' wirklich löschen? Alle zugehörigen Meetings und Qualifikationen werden auch gelöscht!')">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT: A bordered table -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name der Vorlage</th>
				<th class="sortable" data-sort-type="string">Abkürzung (für
					Matrix)</th>
				<th style="width: 450px;">Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="course" items="${courseList}">
				<tr>
					<td>${course.name}</td>
					<td>${course.abbreviation}</td>
					<td style="display: flex; gap: 0.5rem; flex-wrap: wrap;"><a
						href="${pageContext.request.contextPath}/admin/meetings?courseId=${course.id}"
						class="btn btn-small btn-success">Meetings verwalten</a> <a
						href="${pageContext.request.contextPath}/admin/courses?action=edit&id=${course.id}"
						class="btn btn-small">Vorlage bearbeiten</a>
						<form action="${pageContext.request.contextPath}/admin/courses"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${course.id}">
							<button type="submit" class="btn btn-small btn-danger"
								onclick="return confirm('Vorlage \'${course.name}\' wirklich löschen? Alle zugehörigen Meetings und Qualifikationen werden auch gelöscht!')">Löschen</button>
						</form></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_dashboard.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_dashboard.jsp
  
  This is the main landing page for the administrative area. It greets the
  admin user and displays quick access links to major management sections,
  as well as some basic application statistics.
  
  - It is served by: AdminDashboardServlet.
  - Expected attributes:
    - 'userCount' (int): The total number of registered users.
    - 'activeEventCount' (int): The number of upcoming events.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Admin Dashboard" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Willkommen im Admin-Bereich, ${sessionScope.user.username}!</h1>
<p>Hier können Sie die Anwendung verwalten. Wählen Sie eine Option
	aus der Navigation oder den Schnellzugriffen.</p>

<div class="dashboard-grid">
	<div class="card">
		<h2 class="card-title">Schnellzugriff</h2>
		<ul style="list-style: none; padding: 0;">
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/users">Benutzer
					verwalten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/events">Events
					erstellen &amp; bearbeiten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/courses">Lehrgänge
					&amp; Meetings verwalten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/files">Dateien
					hochladen</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/storage">Lager
					verwalten</a></li>
		</ul>
	</div>

	<div class="card">
		<h2 class="card-title">Statistiken</h2>
		<p style="font-size: 1.1rem; margin-bottom: 0.5rem;">
			Anzahl registrierter Benutzer: <strong>${userCount}</strong>
		</p>
		<p style="font-size: 1.1rem;">
			Anzahl aktiver Events: <strong>${activeEventCount}</strong>
		</p>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_events_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_events_list.jsp
  
  This JSP displays a list of all events for administrators. It provides a comprehensive
  set of actions for each event, such as editing, assigning users, changing the
  event status (e.g., from "Geplant" to "Laufend"), and deleting. It uses a 
  responsive layout with cards for mobile and a table for desktop with client-side sorting/filtering.
  
  - It is served by: AdminEventServlet (doGet).
  - Expected attributes:
    - 'eventList' (List<de.technikteam.model.Event>): A list of all events.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Eventverwaltung" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Eventverwaltung</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<a href="${pageContext.request.contextPath}/admin/events?action=new"
		class="btn">Neues Event anlegen</a>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<c:if test="${empty eventList}">
	<div class="card">
		<p>Es wurden noch keine Events erstellt.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT: CARD LIST -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="event" items="${eventList}">
		<div class="list-item-card"
			data-searchable-content="${event.name} ${event.status}">
			<h3 class="card-title">${event.name}</h3>
			<div class="card-row">
				<span>Zeitraum:</span> <span>${event.formattedEventDateTimeRange}</span>
			</div>
			<div class="card-row">
				<span>Status:</span> <span>${event.status}</span>
			</div>
			<div class="card-actions">
				<a
					href="${pageContext.request.contextPath}/admin/events?action=edit&id=${event.id}"
					class="btn btn-small">Bearbeiten</a>

				<c:if test="${event.status != 'ABGESCHLOSSEN'}">
					<a
						href="${pageContext.request.contextPath}/admin/events?action=assign&id=${event.id}"
						class="btn btn-small btn-success">Zuweisen</a>
					<c:if
						test="${event.status == 'GEPLANT' || event.status == 'KOMPLETT'}">
						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="updateStatus">
							<input type="hidden" name="id" value="${event.id}"> <input
								type="hidden" name="newStatus" value="LAUFEND">
							<button type="submit" class="btn btn-small"
								style="background-color: orange;">Starten</button>
						</form>
					</c:if>
					<c:if test="${event.status == 'LAUFEND'}">
						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="updateStatus">
							<input type="hidden" name="id" value="${event.id}"> <input
								type="hidden" name="newStatus" value="ABGESCHLOSSEN">
							<button type="submit" class="btn btn-small"
								style="background-color: var(--text-muted-color);">Abschließen</button>
						</form>
					</c:if>
				</c:if>

				<form action="${pageContext.request.contextPath}/admin/events"
					method="post" style="display: inline;">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="id" value="${event.id}">
					<button type="submit" class="btn btn-small btn-danger"
						onclick="return confirm('Soll das Event \'${event.name}\' wirklich endgültig gelöscht werden?')">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT: TABLE -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name</th>
				<th class="sortable" data-sort-type="string">Zeitraum</th>
				<th class="sortable" data-sort-type="string">Status</th>
				<th style="width: 450px;">Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="event" items="${eventList}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a></td>
					<td>${event.formattedEventDateTimeRange}</td>
					<td>${event.status}</td>
					<td style="display: flex; gap: 5px; flex-wrap: wrap;"><a
						href="${pageContext.request.contextPath}/admin/events?action=edit&id=${event.id}"
						class="btn btn-small">Bearbeiten</a> <c:if
							test="${event.status != 'ABGESCHLOSSEN'}">
							<a
								href="${pageContext.request.contextPath}/admin/events?action=assign&id=${event.id}"
								class="btn btn-small btn-success">Zuweisen</a>
							<c:if
								test="${event.status == 'GEPLANT' || event.status == 'KOMPLETT'}">
								<form action="${pageContext.request.contextPath}/admin/events"
									method="post" style="display: inline;">
									<input type="hidden" name="action" value="updateStatus">
									<input type="hidden" name="id" value="${event.id}"> <input
										type="hidden" name="newStatus" value="LAUFEND">
									<button type="submit" class="btn btn-small"
										style="background-color: orange;">Starten</button>
								</form>
							</c:if>
							<c:if test="${event.status == 'LAUFEND'}">
								<form action="${pageContext.request.contextPath}/admin/events"
									method="post" style="display: inline;">
									<input type="hidden" name="action" value="updateStatus">
									<input type="hidden" name="id" value="${event.id}"> <input
										type="hidden" name="newStatus" value="ABGESCHLOSSEN">
									<button type="submit" class="btn btn-small"
										style="background-color: var(--text-muted-color);">Abschließen</button>
								</form>
							</c:if>
						</c:if>

						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${event.id}">
							<button type="submit" class="btn btn-small btn-danger"
								onclick="return confirm('Soll das Event \'${event.name}\' wirklich endgültig gelöscht werden?')">Löschen</button>
						</form></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_event_assign.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_event_assign.jsp
  
  This JSP provides the interface for an administrator to assign the final team
  for an event. It displays a list of all users who have signed up for the event,
  with checkboxes to select them for the final assignment. Previously assigned
  users are pre-checked.
  
  - It is served by: AdminEventServlet (doGet with action=assign).
  - It submits to: AdminEventServlet (doPost with action=assignUsers).
  - Expected attributes:
    - 'event' (de.technikteam.model.Event): The event being managed.
    - 'signedUpUsers' (List<de.technikteam.model.User>): Users who signed up.
    - 'assignedUserIds' (Set<Integer>): The IDs of users already assigned.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Teilnehmer zuweisen" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Teilnehmer für "${event.name}" zuweisen</h1>
<p>Wählen Sie die Benutzer aus, die dem finalen Team für dieses
	Event angehören sollen. Nach dem Speichern wird der Event-Status
	automatisch auf "KOMPLETT" gesetzt.</p>

<div class="form-center-wrapper">
	<div class="card">
		<form action="${pageContext.request.contextPath}/admin/events"
			method="post">
			<input type="hidden" name="action" value="assignUsers"> <input
				type="hidden" name="eventId" value="${event.id}">

			<h2 class="card-title">Angemeldete Benutzer</h2>

			<c:choose>
				<c:when test="${not empty signedUpUsers}">
					<div class="user-checkbox-list">
						<c:forEach var="user" items="${signedUpUsers}">
							<label class="checkbox-label"> <input type="checkbox"
								name="userIds" value="${user.id}"
								style="width: auto; height: 1.2rem;"
								<c:if test="${assignedUserIds.contains(user.id)}">checked</c:if>>
								${user.username}
							</label>
						</c:forEach>
					</div>
				</c:when>
				<c:otherwise>
					<p>Es haben sich noch keine Benutzer für dieses Event
						angemeldet.</p>
				</c:otherwise>
			</c:choose>

			<div style="margin-top: 2rem; display: flex; gap: 1rem;">
				<button type="submit" class="btn">Team finalisieren &
					Speichern</button>
				<a href="${pageContext.request.contextPath}/admin/events"
					class="btn" style="background-color: var(--text-muted-color);">Abbrechen</a>
			</div>
		</form>
	</div>
</div>

<style>
.user-checkbox-list {
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
}

.checkbox-label {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	font-size: 1.1rem;
	cursor: pointer;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_event_form.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_event_form.jsp
  
  This JSP provides the form for an administrator to create a new or edit an
  existing event. It includes fields for the event's name, date/time, description,
  status, and a dynamic section for specifying skill requirements (i.e., how
  many people with a certain qualification are needed).
  
  - It is served by: AdminEventServlet (doGet with action=new or action=edit).
  - It submits to: AdminEventServlet (doPost with action=create or action=update).
  - Expected attributes:
    - 'event' (de.technikteam.model.Event): The event to edit (optional, for edit mode).
    - 'allCourses' (List<de.technikteam.model.Course>): List of all available courses for the skill requirements dropdown.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title"
		value="${empty event ? 'Neues Event erstellen' : 'Event bearbeiten'}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>
	<c:out
		value="${empty event ? 'Neues Event erstellen' : 'Event bearbeiten'}" />
</h1>

<div class="form-center-wrapper">
	<div class="card">
		<form action="${pageContext.request.contextPath}/admin/events"
			method="post">
			<input type="hidden" name="action"
				value="${empty event ? 'create' : 'update'}">
			<c:if test="${not empty event}">
				<input type="hidden" name="id" value="${event.id}">
			</c:if>

			<div class="form-group">
				<label for="name">Name des Events</label> <input type="text"
					id="name" name="name" value="${event.name}" required>
			</div>
			<div
				style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
				<div class="form-group">
					<label for="eventDateTime">Beginn</label> <input
						type="datetime-local" id="eventDateTime" name="eventDateTime"
						value="${event.eventDateTime}" required>
				</div>
				<div class="form-group">
					<label for="endDateTime">Ende (optional)</label> <input
						type="datetime-local" id="endDateTime" name="endDateTime"
						value="${event.endDateTime}">
				</div>
			</div>
			<div class="form-group">
				<label for="description">Beschreibung</label>
				<textarea id="description" name="description" rows="4">${event.description}</textarea>
			</div>
			<c:if test="${not empty event}">
				<div class="form-group">
					<label for="status">Status</label> <select id="status"
						name="status">
						<option value="GEPLANT"
							${event.status == 'GEPLANT' ? 'selected' : ''}>Geplant</option>
						<option value="KOMPLETT"
							${event.status == 'KOMPLETT' ? 'selected' : ''}>Komplett
							(Team steht)</option>
						<option value="LAUFEND"
							${event.status == 'LAUFEND' ? 'selected' : ''}>Laufend</option>
						<option value="ABGESCHLOSSEN"
							${event.status == 'ABGESCHLOSSEN' ? 'selected' : ''}>Abgeschlossen</option>
					</select>
				</div>
			</c:if>

			<!-- Container for skill requirements -->
			<div class="card"
				style="margin-top: 1.5rem; padding: 1rem; background-color: var(--bg-color);">
				<h3 class="card-title" style="border: none; padding: 0;">Benötigte
					Qualifikationen</h3>
				<div id="requirements-container">
					<c:forEach var="req" items="${event.skillRequirements}">
						<div class="requirement-row">
							<select name="requiredCourseId">
								<c:forEach var="course" items="${allCourses}">
									<option value="${course.id}"
										${req.requiredCourseId == course.id ? 'selected' : ''}>${course.name}</option>
								</c:forEach>
							</select> <input type="number" name="requiredPersons"
								value="${req.requiredPersons}" placeholder="Anzahl" min="1"
								style="max-width: 100px;">
							<button type="button" class="btn-small btn-danger"
								onclick="this.parentElement.remove()">X</button>
						</div>
					</c:forEach>
				</div>
				<button type="button" id="add-requirement-btn" class="btn btn-small"
					style="margin-top: 1rem;">Anforderung hinzufügen</button>
			</div>

			<div style="display: flex; gap: 1rem; margin-top: 2rem;">
				<button type="submit" class="btn">Event Speichern</button>
				<a href="${pageContext.request.contextPath}/admin/events"
					class="btn" style="background-color: var(--text-muted-color);">Abbrechen</a>
			</div>
		</form>
	</div>
</div>

<script>
document.getElementById('add-requirement-btn').addEventListener('click', () => {
    const container = document.getElementById('requirements-container');
    const newRow = document.createElement('div');
    newRow.className = 'requirement-row';
    newRow.innerHTML = `
        <select name="requiredCourseId" class="form-group" style="padding: 0.5rem; margin-bottom: 0;">
            <option value="">-- Lehrgang auswählen --</option>
            <c:forEach var="course" items="${allCourses}">
                <option value="${course.id}">${course.name}</option>
            </c:forEach>
        </select>
        <input type="number" name="requiredPersons" value="1" placeholder="Anzahl" min="1" class="form-group" style="padding: 0.5rem; margin-bottom: 0; max-width: 100px;">
        <button type="button" class="btn-small btn-danger" onclick="this.parentElement.remove()">X</button>
    `;
    container.appendChild(newRow);
});
</script>

<style>
.requirement-row {
	display: flex;
	gap: 10px;
	margin-bottom: 10px;
	align-items: center;
}

.requirement-row select {
	flex-grow: 1;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_files.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_files.jsp
  
  This JSP serves as the main administrative interface for managing both files and
  file categories. It features a new, interactive two-column layout. The left
  column lists categories, and clicking one updates the right column to show
  the associated files and management actions.
  
  - It is served by: AdminFileServlet (doGet).
  - It submits to: AdminFileServlet (for file actions) and AdminFileCategoryServlet (for category actions).
  - Expected attributes:
    - 'groupedFiles' (Map<String, List<de.technikteam.model.File>>): Files grouped by category name.
    - 'allCategories' (List<de.technikteam.model.FileCategory>): List of all categories for dropdowns and management.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Datei- & Kategorienverwaltung" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>
	<i class="fas fa-folder-open"></i> Datei- & Kategorienverwaltung
</h1>
<p>Verwalten Sie hier alle hochgeladenen Dateien und deren
	Kategorien.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i> ${sessionScope.successMessage}
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		${sessionScope.errorMessage}
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="file-manager-layout">
	<!-- Left Column: Category List -->
	<div class="card file-manager-categories">
		<h2>Kategorien</h2>
		<ul class="category-list">
			<c:forEach var="cat" items="${allCategories}">
				<li data-category-id="${cat.id}"><i class="fas fa-folder"></i>
					${cat.name}</li>
			</c:forEach>
		</ul>
		<hr>
		<h4 style="margin-top: 1rem;">Kategorie-Aktionen</h4>
		<form
			action="${pageContext.request.contextPath}/admin/categories/create"
			method="post">
			<div class="form-group">
				<label for="newCategoryName">Neue Kategorie erstellen</label> <input
					type="text" name="categoryName" id="newCategoryName" required>
			</div>
			<button type="submit" class="btn">
				<i class="fas fa-plus"></i> Erstellen
			</button>
		</form>
	</div>

	<!-- Right Column: File List, Upload, and Category Management -->
	<div class="file-manager-content">
		<div id="section-placeholder" class="card"
			style="text-align: center; padding: 3rem; border-style: dashed;">
			<i class="fas fa-arrow-left fa-2x"
				style="color: var(--text-muted-color); margin-bottom: 1rem;"></i>
			<p style="font-size: 1.2rem; color: var(--text-muted-color);">Bitte
				wählen Sie links eine Kategorie aus, um Dateien anzuzeigen und zu
				verwalten.</p>
		</div>
		<!-- This container will be populated by JS -->
		<div id="dynamic-content-area"></div>
	</div>
</div>


<!-- JAVASCRIPT TEMPLATES FOR DYNAMIC CONTENT -->
<template id="category-section-template">
	<div class="file-category-section">
		<div class="card">
			<h2>
				<i class="fas fa-file-alt"></i> Dateien in "<span
					class="category-name"></span>"
			</h2>
			<ul class="file-list">
				<!-- File items will be inserted here by JS -->
			</ul>
		</div>
		<div class="card">
			<h2>
				<i class="fas fa-upload"></i> Datei zu "<span class="category-name"></span>"
				hochladen
			</h2>
			<form action="${pageContext.request.contextPath}/admin/files"
				method="post" enctype="multipart/form-data">
				<input type="hidden" name="categoryId" class="category-id-input">
				<div class="form-group">
					<label>Datei auswählen</label> <input type="file" name="file"
						class="file-input" data-max-size="20971520" required> <small
						class="file-size-warning" style="color: red; display: none;">Datei
						ist zu groß! (Max. 20 MB)</small>
				</div>
				<div class="form-group">
					<label>Sichtbar für</label> <select name="requiredRole">
						<option value="NUTZER" selected>Alle Nutzer</option>
						<option value="ADMIN">Nur Admins</option>
					</select>
				</div>
				<button type="submit" class="btn">
					<i class="fas fa-cloud-upload-alt"></i> Hochladen
				</button>
			</form>
		</div>
		<div class="card">
			<h2>
				<i class="fas fa-edit"></i> Kategorie "<span class="category-name"></span>"
				verwalten
			</h2>
			<div class="category-actions-grid">
				<form
					action="${pageContext.request.contextPath}/admin/categories/update"
					method="post" class="category-action-form">
					<input type="hidden" name="categoryId" class="category-id-input">
					<div class="form-group">
						<label>Umbenennen</label> <input type="text" name="categoryName"
							class="category-name-input" required>
					</div>
					<button type="submit" class="btn btn-small">
						<i class="fas fa-save"></i> Umbenennen
					</button>
				</form>
				<form
					action="${pageContext.request.contextPath}/admin/categories/delete"
					method="post" class="category-action-form">
					<input type="hidden" name="categoryId" class="category-id-input">
					<div class="form-group">
						<label>Löschen</label>
						<p>
							<small>Zugehörige Dateien verlieren ihre
								Kategoriezuordnung.</small>
						</p>
					</div>
					<button type="submit" class="btn btn-small btn-danger"
						onclick="return confirm('Kategorie wirklich löschen?')">
						<i class="fas fa-trash-alt"></i> Endgültig Löschen
					</button>
				</form>
			</div>
		</div>
	</div>
</template>

<template id="file-item-template">
	<li>
		<div class="file-info">
			<a href="#" class="file-download-link" title="Datei herunterladen"></a>
			<small class="file-meta"></small>
		</div>
		<form action="${pageContext.request.contextPath}/admin/files"
			method="post">
			<input type="hidden" name="action" value="delete"> <input
				type="hidden" name="fileId" class="file-id-input">
			<button type="submit" class="btn btn-small btn-danger-outline"
				title="Löschen" onclick="return confirm('Datei wirklich löschen?')">
				<i class="fas fa-trash-alt"></i>
			</button>
		</form>
	</li>
</template>


<script>
document.addEventListener('DOMContentLoaded', () => {
    // Data from JSP to JS
    const groupedFiles = {
        <c:forEach var="entry" items="${groupedFiles}" varStatus="status">
            "${entry.key}": [
                <c:forEach var="file" items="${entry.value}" varStatus="fileStatus">
                    { id: ${file.id}, filename: "${file.filename}", filepath: "${file.filepath}", requiredRole: "${file.requiredRole}" }
                    ${!fileStatus.last ? ',' : ''}
                </c:forEach>
            ]
            ${!status.last ? ',' : ''}
        </c:forEach>
    };

    const allCategories = [
        <c:forEach var="cat" items="${allCategories}" varStatus="status">
            { id: ${cat.id}, name: "${cat.name}" }
            ${!status.last ? ',' : ''}
        </c:forEach>
    ];

    const categoryListItems = document.querySelectorAll('.category-list li');
    const dynamicContentArea = document.getElementById('dynamic-content-area');
    const placeholder = document.getElementById('section-placeholder');
    const sectionTemplate = document.getElementById('category-section-template');
    const fileItemTemplate = document.getElementById('file-item-template');
    const contextPath = "${pageContext.request.contextPath}";

    const switchCategoryView = (categoryId) => {
        dynamicContentArea.innerHTML = '';
        placeholder.style.display = 'none';
        categoryListItems.forEach(item => item.classList.remove('active'));

        if (!categoryId) {
            placeholder.style.display = 'block';
            return;
        }

        const category = allCategories.find(c => c.id == categoryId);
        if (!category) return;

        // Activate the selected category list item
        const activeLi = document.querySelector(`.category-list li[data-category-id='${categoryId}']`);
        if(activeLi) activeLi.classList.add('active');

        // Clone and populate the main section template
        const sectionClone = sectionTemplate.content.cloneNode(true);
        sectionClone.querySelectorAll('.category-name').forEach(el => el.textContent = category.name);
        sectionClone.querySelectorAll('.category-id-input').forEach(el => el.value = category.id);
        sectionClone.querySelector('.category-name-input').value = category.name;

        // Populate the file list
        const fileList = sectionClone.querySelector('.file-list');
        const filesForCategory = groupedFiles[category.name] || [];

        if (filesForCategory.length > 0) {
            filesForCategory.forEach(file => {
                const fileItemClone = fileItemTemplate.content.cloneNode(true);
                const downloadLink = fileItemClone.querySelector('.file-download-link');
                downloadLink.href = `${contextPath}/download?file=${file.filepath}`;
                downloadLink.textContent = file.filename;
                fileItemClone.querySelector('.file-meta').textContent = `(Sichtbar für: ${file.requiredRole})`;
                fileItemClone.querySelector('.file-id-input').value = file.id;
                fileItemClone.querySelector('form').onclick = (e) => {
                    if (!confirm(`Datei '${file.filename}' wirklich löschen?`)) {
                        e.preventDefault();
                    }
                };
                fileList.appendChild(fileItemClone);
            });
        } else {
            fileList.innerHTML = '<li style="justify-content: center; color: var(--text-muted-color);">Keine Dateien in dieser Kategorie.</li>';
        }

        dynamicContentArea.appendChild(sectionClone);
        
        // Re-attach file size validation to the newly added input
        attachFileSizeValidator(dynamicContentArea.querySelector('.file-input'));
    };
    
    const attachFileSizeValidator = (input) => {
        if (!input) return;
        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const maxSize = parseInt(e.target.dataset.maxSize, 10);
            const warningElement = e.target.nextElementSibling;
            if (file && file.size > maxSize) {
                warningElement.style.display = 'block';
                e.target.value = '';
            } else {
                warningElement.style.display = 'none';
            }
        });
    };

    categoryListItems.forEach(item => {
        item.addEventListener('click', () => {
            switchCategoryView(item.dataset.categoryId);
        });
    });
    
    // Initial view
    switchCategoryView(null);
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_log.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_log.jsp
  
  This JSP displays the administrative audit log. It receives a list of all
  log entries and renders them in a responsive table/card layout. It includes
  a client-side JavaScript search filter that allows the admin to quickly find
  specific log entries by searching across all their fields.
  
  - It is served by: AdminLogServlet.
  - Expected attributes:
    - 'logs' (List<de.technikteam.model.AdminLog>): A list of all log entries, newest first.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Admin Log" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Admin Aktions-Protokoll</h1>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter"
			placeholder="Nach Details, Name oder Aktion filtern..."
			style="width: 100%;" aria-label="Protokoll filtern">
	</div>
</div>


<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="log" items="${logs}">
		<div class="list-item-card"
			data-searchable-content="${log.details} ${log.adminUsername} ${log.actionType}">
			<p>
				<strong>${log.details}</strong>
			</p>
			<div class="card-row">
				<span>Wer:</span> <span>${log.adminUsername}</span>
			</div>
			<div class="card-row">
				<span>Aktionstyp:</span> <span>${log.actionType}</span>
			</div>
			<div class="card-row">
				<span>Wann:</span> <span>${log.formattedActionTimestamp} Uhr</span>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table searchable-table">
		<thead>
			<tr>
				<th>Wann</th>
				<th>Wer</th>
				<th>Aktionstyp</th>
				<th>Details</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="log" items="${logs}">
				<tr>
					<td>${log.formattedActionTimestamp}Uhr</td>
					<td>${log.adminUsername}</td>
					<td>${log.actionType}</td>
					<td>${log.details}</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_matrix.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_matrix.jsp
  
  This JSP displays the main qualification and attendance matrix. It's a complex
  view that cross-references users with all scheduled meetings for every course.
  Each cell indicates if a user attended a specific meeting. The cells are
  interactive; clicking one opens a modal window to edit that specific attendance
  record. The modal's form is submitted to the AdminAttendanceServlet.
  
  - It is served by: MatrixServlet.
  - Expected attributes:
    - 'allUsers' (List<de.technikteam.model.User>): All users for the rows.
    - 'allCourses' (List<de.technikteam.model.Course>): All courses for the main columns.
    - 'meetingsByCourse' (Map<Integer, List<Meeting>>): Meetings for each course for the sub-columns.
    - 'attendanceMap' (Map<String, MeetingAttendance>): A map for quick lookup of attendance records.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Qualifikations-Matrix" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>
	<i class="fas fa-th-list"></i> Qualifikations-Matrix (Modular)
</h1>
<p>Klicken Sie auf eine Zelle, um die Teilnahme an einem Meeting zu
	bearbeiten.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i> ${sessionScope.successMessage}
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		${sessionScope.errorMessage}
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<!-- This wrapper ensures mobile-only display -->
<div class="mobile-card-list">
	<div class="card" style="overflow-x: auto;">
		<table class="mobile-matrix-table">
			<thead>
				<tr>
					<th>Nutzer</th>
					<c:forEach var="course" items="${allCourses}">
						<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
							<th>${course.abbreviation}<br />${meeting.name}</th>
						</c:forEach>
					</c:forEach>
				</tr>
			</thead>
			<tbody>
				<c:forEach var="user" items="${allUsers}">
					<tr>
						<td>${user.username}</td>
						<c:forEach var="course" items="${allCourses}">
							<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
								<c:set var="attendanceKey" value="${user.id}-${meeting.id}" />
								<c:set var="attendance" value="${attendanceMap[attendanceKey]}" />
								<td class="qual-cell" data-user-id="${user.id}"
									data-user-name="${user.username}"
									data-meeting-id="${meeting.id}"
									data-meeting-name="${course.name} - ${meeting.name}"
									data-attended="${not empty attendance && attendance.attended}"
									data-remarks="${not empty attendance ? attendance.remarks : ''}">
									<c:if test="${not empty attendance && attendance.attended}">
										<span class="text-success" style="font-weight: bold;">✔</span>
									</c:if> <c:if test="${empty attendance || !attendance.attended}">-</c:if>
								</td>
							</c:forEach>
						</c:forEach>
					</tr>
				</c:forEach>
			</tbody>
		</table>
	</div>
</div>

<!-- This wrapper ensures desktop-only display -->
<div class="desktop-table-wrapper">
	<table class="desktop-table matrix-table">
		<thead>
			<tr>
				<th rowspan="2"
					style="vertical-align: middle; position: sticky; left: 0; z-index: 10;">Nutzer
					/ Lehrgang ↓</th>
				<c:forEach var="course" items="${allCourses}">
					<th colspan="${meetingsByCourse[course.id].size()}"
						style="text-align: center;"><a
						href="${pageContext.request.contextPath}/admin/courses?action=edit&id=${course.id}"
						title="Vorlage '${course.name}' bearbeiten">${course.abbreviation}</a>
					</th>
				</c:forEach>
			</tr>
			<tr>
				<c:forEach var="course" items="${allCourses}">
					<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
						<th style="text-align: center;"><a
							href="${pageContext.request.contextPath}/admin/meetings?action=edit&courseId=${course.id}&meetingId=${meeting.id}"
							title="Meeting '${meeting.name}' bearbeiten">${meeting.name}</a>
						</th>
					</c:forEach>
				</c:forEach>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="user" items="${allUsers}">
				<tr>
					<td
						style="font-weight: 500; position: sticky; left: 0; background-color: var(--surface-color); z-index: 5;">
						<a
						href="${pageContext.request.contextPath}/admin/users?action=details&id=${user.id}">${user.username}</a>
					</td>
					<c:forEach var="course" items="${allCourses}">
						<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
							<c:set var="attendanceKey" value="${user.id}-${meeting.id}" />
							<c:set var="attendance" value="${attendanceMap[attendanceKey]}" />
							<td class="qual-cell" data-user-id="${user.id}"
								data-user-name="${user.username}"
								data-meeting-id="${meeting.id}"
								data-meeting-name="${course.name} - ${meeting.name}"
								data-attended="${not empty attendance && attendance.attended}"
								data-remarks="${not empty attendance ? attendance.remarks : ''}"
								style="text-align: center; font-weight: bold; cursor: pointer;"
								title="Klicken zum Bearbeiten"><c:if
									test="${not empty attendance && attendance.attended}">
									<span class="text-success">✔</span>
								</c:if> <c:if test="${empty attendance || !attendance.attended}">-</c:if>
							</td>
						</c:forEach>
					</c:forEach>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<!-- MODAL HTML STRUCTURE -->
<div class="modal-overlay" id="attendance-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3>Teilnahme bearbeiten</h3>
		<p id="modal-title" style="font-weight: bold; margin-bottom: 1rem;"></p>
		<form action="${pageContext.request.contextPath}/admin/attendance"
			method="post">
			<input type="hidden" name="returnTo" value="matrix"> <input
				type="hidden" name="userId" id="modal-user-id"> <input
				type="hidden" name="meetingId" id="modal-meeting-id">
			<div class="form-group"
				style="display: flex; align-items: center; gap: 1rem;">
				<label for="modal-attended" style="margin-bottom: 0;">Teilgenommen:</label>
				<input type="checkbox" id="modal-attended" name="attended"
					value="true" style="width: auto; height: 1.5rem;">
			</div>
			<div class="form-group">
				<label for="modal-remarks">Bemerkungen:</label>
				<textarea name="remarks" id="modal-remarks" rows="3"></textarea>
			</div>
			<button type="submit" class="btn">
				<i class="fas fa-save"></i> Speichern
			</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    const modalOverlay = document.getElementById('attendance-modal');
    if (!modalOverlay) return;
    
    const modalTitle = document.getElementById('modal-title');
    const modalUserId = document.getElementById('modal-user-id');
    const modalMeetingId = document.getElementById('modal-meeting-id');
    const modalAttended = document.getElementById('modal-attended');
    const modalRemarks = document.getElementById('modal-remarks');
    const closeBtn = modalOverlay.querySelector('.modal-close-btn');

    const openModal = (cell) => {
        const userData = cell.dataset;
        modalTitle.textContent = `Nutzer: ${userData.userName} | Meeting: ${userData.meetingName}`;
        modalUserId.value = userData.userId;
        modalMeetingId.value = userData.meetingId;
        modalRemarks.value = userData.remarks;
        modalAttended.checked = (userData.attended === 'true');
        modalOverlay.classList.add('active');
    };

    const closeModal = () => modalOverlay.classList.remove('active');

    document.querySelectorAll('.qual-cell').forEach(cell => {
        cell.addEventListener('click', () => openModal(cell));
    });

    if (closeBtn) closeBtn.addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', (event) => { if (event.target === modalOverlay) closeModal(); });
    document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && modalOverlay.classList.contains('active')) closeModal(); });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_meeting_form.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<c:set var="isEditMode" value="${not empty meeting}" />

<%--
  admin_meeting_form.jsp
  
  This JSP provides a multipart form for an administrator to create or edit
  a specific meeting. It includes fields for meeting details and allows for
  uploading and deleting file attachments in edit mode.
  
  - It is served by: AdminMeetingServlet (doGet).
  - It submits to: AdminMeetingServlet (doPost).
  - Expected attributes:
    - 'parentCourse' (Course): The parent course of this meeting.
    - 'meeting' (Meeting): The meeting object to edit (optional).
    - 'attachments' (List<MeetingAttachment>): Existing attachments for the meeting (optional).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title"
		value="${isEditMode ? 'Meeting bearbeiten' : 'Neues Meeting planen'}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>${isEditMode ? 'Meeting bearbeiten' : 'Neues Meeting für "'.concat(parentCourse.name).concat('" planen')}</h1>
<a
	href="${pageContext.request.contextPath}/admin/meetings?courseId=${parentCourse.id}"
	style="display: inline-block; margin-bottom: 1rem;"> « Zurück zur
	Meeting-Liste </a>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="card" style="max-width: 700px; margin: 1rem auto;">
	<form action="${pageContext.request.contextPath}/admin/meetings"
		method="post" enctype="multipart/form-data">

		<input type="hidden" name="action"
			value="${isEditMode ? 'update' : 'create'}"> <input
			type="hidden" name="courseId" value="${parentCourse.id}">
		<c:if test="${isEditMode}">
			<input type="hidden" name="meetingId" value="${meeting.id}">
		</c:if>

		<div class="form-group">
			<label for="name">Name des Meetings (z.B. Teil 1, Modul A:
				Ton)</label> <input type="text" id="name" name="name"
				value="${meeting.name}" required>
		</div>

		<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
			<div class="form-group">
				<label for="meetingDateTime">Beginn</label> <input
					type="datetime-local" id="meetingDateTime" name="meetingDateTime"
					value="${meeting.meetingDateTime}" required>
			</div>
			<div class="form-group">
				<label for="endDateTime">Ende (optional)</label> <input
					type="datetime-local" id="endDateTime" name="endDateTime"
					value="${meeting.endDateTime}">
			</div>
		</div>

		<div class="form-group">
			<label for="leader">Leitende Person</label> <input type="text"
				id="leader" name="leader" value="${meeting.leader}">
		</div>

		<div class="form-group">
			<label for="description">Beschreibung (spezifisch für dieses
				Meeting)</label>
			<textarea id="description" name="description" rows="4">${meeting.description}</textarea>
		</div>

		<%-- File Upload Section --%>
		<div class="card" style="background-color: var(--bg-color);">
			<h3 class="card-title" style="border: none; padding: 0;">Anhänge
				verwalten</h3>

			<c:if test="${isEditMode}">
				<c:if test="${not empty attachments}">
					<ul style="list-style: none; padding-left: 0; margin-bottom: 1rem;">
						<c:forEach var="att" items="${attachments}">
							<li
								style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border-color);">
								<span><a
									href="${pageContext.request.contextPath}/download?file=${att.filepath}">${att.filename}</a></span>
								<%-- This form is NOT multipart, so it submits to the else block in doPost --%>
								<form action="${pageContext.request.contextPath}/admin/meetings"
									method="post"
									onsubmit="return confirm('Anhang \'${att.filename}\' wirklich löschen?')">
									<input type="hidden" name="action" value="deleteAttachment">
									<input type="hidden" name="attachmentId" value="${att.id}">
									<input type="hidden" name="meetingId" value="${meeting.id}">
									<input type="hidden" name="courseId" value="${parentCourse.id}">
									<button type="submit" class="btn btn-small btn-danger">X</button>
								</form>
							</li>
						</c:forEach>
					</ul>
				</c:if>
			</c:if>

			<h4 style="margin-top: 1rem;">Neuen Anhang hochladen</h4>
			<div class="form-group">
				<label for="attachment">Datei</label> <input type="file"
					name="attachment" id="attachment" class="file-input"
					data-max-size="20971520"> <small class="file-size-warning"
					style="color: red; display: none;">Datei ist zu groß! (Max.
					20 MB)</small>
			</div>
			<div class="form-group">
				<label for="requiredRole">Sichtbar für</label> <select
					name="requiredRole" id="requiredRole">
					<option value="NUTZER" selected>Alle Nutzer</option>
					<option value="ADMIN">Nur Admins</option>
				</select>
			</div>
		</div>

		<div style="display: flex; gap: 1rem; margin-top: 1.5rem;">
			<button type="submit" class="btn">${isEditMode ? 'Änderungen speichern' : 'Meeting planen'}</button>
			<a
				href="${pageContext.request.contextPath}/admin/meetings?courseId=${parentCourse.id}"
				class="btn" style="background-color: var(--text-muted-color);">Abbrechen</a>
		</div>
	</form>
</div>

<script>
// File size validation script
document.querySelectorAll('.file-input').forEach(input => {
    input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        const maxSize = parseInt(e.target.dataset.maxSize, 10);
        const warningElement = e.target.nextElementSibling;

        if (file && file.size > maxSize) {
            warningElement.style.display = 'block';
            e.target.value = ''; // Clear the invalid file selection
        } else {
            warningElement.style.display = 'none';
        }
    });
});
</script>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_meeting_list.jsp
========================================================================


<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_meeting_list.jsp
  
  This JSP displays a list of all scheduled meetings for a specific parent
  course template. It allows an administrator to see all planned sessions at
  a glance and provides actions to edit or delete each meeting.
  
  - It is served by: AdminMeetingServlet (doGet with action=list).
  - Expected attributes:
    - 'parentCourse' (de.technikteam.model.Course): The course whose meetings are being listed.
    - 'meetings' (List<de.technikteam.model.Meeting>): The list of meetings for this course.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Meetings für ${parentCourse.name}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Meetings für "${parentCourse.name}"</h1>
<a href="${pageContext.request.contextPath}/admin/courses"
	style="margin-bottom: 1rem; display: inline-block;"> &laquo; Zurück
	zu allen Vorlagen </a>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<a
		href="${pageContext.request.contextPath}/admin/meetings?action=new&courseId=${parentCourse.id}"
		class="btn">Neues Meeting planen</a>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>


<c:if test="${empty meetings}">
	<div class="card">
		<p>Für diesen Lehrgang wurden noch keine Meetings geplant.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="meeting" items="${meetings}">
		<div class="list-item-card"
			data-searchable-content="${meeting.name} ${meeting.leader}">
			<h3 class="card-title">${meeting.name}</h3>
			<div class="card-row">
				<span>Datum:</span> <span>${meeting.formattedMeetingDateTimeRange}</span>
			</div>
			<div class="card-row">
				<span>Leitung:</span> <span>${empty meeting.leader ? 'N/A' : meeting.leader}</span>
			</div>
			<div class="card-actions">
				<a
					href="${pageContext.request.contextPath}/admin/meetings?action=edit&courseId=${parentCourse.id}&meetingId=${meeting.id}"
					class="btn btn-small">Bearbeiten</a>
				<form action="${pageContext.request.contextPath}/admin/meetings"
					method="post" style="display: inline;">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="courseId" value="${parentCourse.id}">
					<input type="hidden" name="meetingId" value="${meeting.id}">
					<button type="submit" class="btn btn-small btn-danger"
						onclick="return confirm('Meeting \'${meeting.name}\' wirklich löschen?')">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Meeting-Name</th>
				<th class="sortable" data-sort-type="string">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Leitung</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="meeting" items="${meetings}">
				<tr>
					<td>${meeting.name}</td>
					<td>${meeting.formattedMeetingDateTimeRange}</td>
					<td>${empty meeting.leader ? 'N/A' : meeting.leader}</td>
					<td style="display: flex; gap: 0.5rem;"><a
						href="${pageContext.request.contextPath}/admin/meetings?action=edit&courseId=${parentCourse.id}&meetingId=${meeting.id}"
						class="btn btn-small">Bearbeiten</a>
						<form action="${pageContext.request.contextPath}/admin/meetings"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="courseId" value="${parentCourse.id}">
							<input type="hidden" name="meetingId" value="${meeting.id}">
							<button type="submit" class="btn btn-small btn-danger"
								onclick="return confirm('Meeting \'${meeting.name}\' wirklich löschen?')">Löschen</button>
						</form></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_storage_form.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_storage_form.jsp
  
  This JSP provides the form for an administrator to create a new or edit an
  existing inventory item. It includes fields for all item properties, such
  as name, location details, quantities, and an optional image upload.
  
  - It is served by: AdminStorageServlet (doGet with action=new or action=edit).
  - It submits to: AdminStorageServlet (doPost).
  - Expected attributes:
    - 'storageItem' (de.technikteam.model.StorageItem): The item to edit (optional, for edit mode).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title"
		value="${empty storageItem ? 'Neuen Lagerartikel anlegen' : 'Lagerartikel bearbeiten'}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>
	<i class="fas fa-plus-circle"></i>
	<c:out
		value="${empty storageItem ? 'Neuen Lagerartikel anlegen' : 'Lagerartikel bearbeiten'}" />
</h1>

<div class="form-center-wrapper">
	<div class="card">
		<c:if test="${not empty sessionScope.errorMessage}">
			<p class="error-message">${sessionScope.errorMessage}</p>
			<c:remove var="errorMessage" scope="session" />
		</c:if>

		<form action="${pageContext.request.contextPath}/admin/storage"
			method="post" enctype="multipart/form-data">

			<input type="hidden" name="action"
				value="${empty storageItem ? 'create' : 'update'}">
			<c:if test="${not empty storageItem}">
				<input type="hidden" name="id" value="${storageItem.id}">
			</c:if>

			<div class="form-group">
				<label for="name">Artikelname</label> <input type="text" id="name"
					name="name" value="${storageItem.name}" required>
			</div>

			<div class="form-group">
				<label for="location">Ort (z.B. Erdgeschoss, Obergeschoss,
					Lagercontainer)</label> <input type="text" id="location" name="location"
					value="${storageItem.location}" required>
			</div>

			<div class="form-group">
				<label for="cabinet">Schrank</label> <input type="text" id="cabinet"
					name="cabinet" value="${storageItem.cabinet}">
			</div>

			<div class="form-group">
				<label for="shelf">Regal</label> <input type="text" id="shelf"
					name="shelf" value="${storageItem.shelf}">
			</div>

			<div class="form-group">
				<label for="compartment">Fach / Kiste</label> <input type="text"
					id="compartment" name="compartment"
					value="${storageItem.compartment}">
			</div>

			<div class="form-group">
				<label for="quantity">Aktuelle Anzahl</label> <input type="number"
					id="quantity" name="quantity"
					value="${empty storageItem ? 0 : storageItem.quantity}" required
					min="0">
			</div>

			<div class="form-group">
				<label for="maxQuantity">Maximale Anzahl (0 für unbegrenzt)</label>
				<input type="number" id="maxQuantity" name="maxQuantity"
					value="${empty storageItem ? 0 : storageItem.maxQuantity}" required
					min="0">
			</div>

			<div class="form-group">
				<label for="imagePath">Aktuelles Bild</label>
				<c:if test="${not empty storageItem.imagePath}">
					<img
						src="${pageContext.request.contextPath}/image?file=${storageItem.imagePath}"
						alt="Aktuelles Bild"
						style="max-width: 200px; height: auto; border-radius: 8px; margin-top: 0.5rem;">
				</c:if>
				<c:if test="${empty storageItem.imagePath}">
					<p style="color: var(--text-muted-color);">Kein Bild vorhanden.</p>
				</c:if>
			</div>

			<div class="form-group">
				<label for="imageFile">Neues Bild hochladen (optional,
					überschreibt das alte Bild)</label> <input type="file" id="imageFile"
					name="imageFile"
					accept="image/jpeg, image/png, image/gif, image/webp">
			</div>

			<div style="display: flex; gap: 1rem;">
				<button type="submit" class="btn">
					<i class="fas fa-save"></i> Speichern
				</button>
				<a href="${pageContext.request.contextPath}/admin/storage"
					class="btn" style="background-color: var(--text-muted-color);">Abbrechen</a>
			</div>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_storage_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_storage_list.jsp
  
  This JSP displays a list of all inventory items for administrators.
  It provides actions to edit an item, delete an item, or generate a QR code
  that links to the item's public detail page. It uses a responsive layout,
  showing cards on mobile and a table on desktop with client-side filtering and sorting.
  
  - It is served by: AdminStorageServlet (doGet).
  - Expected attributes:
    - 'storageList' (List<de.technikteam.model.StorageItem>): A flat list of all inventory items.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Lagerverwaltung" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Lagerverwaltung</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<a href="${pageContext.request.contextPath}/admin/storage?action=new"
		class="btn">Neuen Artikel anlegen</a>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<c:if test="${empty storageList}">
	<div class="card">
		<p>Es sind noch keine Lagerartikel erfasst worden.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="item" items="${storageList}">
		<div class="list-item-card"
			data-searchable-content="${item.name} ${item.location} ${item.cabinet}">
			<h3 class="card-title">${item.name}</h3>
			<div class="card-row">
				<span>Ort:</span> <span>${item.location}</span>
			</div>
			<div class="card-row">
				<span>Anzahl:</span> <span>${item.quantity}</span>
			</div>
			<div class="card-actions">
				<a
					href="${pageContext.request.contextPath}/admin/storage?action=edit&id=${item.id}"
					class="btn btn-small">Bearbeiten</a> <a
					href="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${pageContext.request.scheme}://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/storage-item?id=${item.id}"
					target="_blank" class="btn btn-small btn-success">QR-Code</a>
				<form action="${pageContext.request.contextPath}/admin/storage"
					method="post" style="display: inline;">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="id" value="${item.id}">
					<button type="submit" class="btn btn-small btn-danger"
						onclick="return confirm('Artikel \'${item.name}\' wirklich löschen?')">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name</th>
				<th class="sortable" data-sort-type="string">Ort</th>
				<th class="sortable" data-sort-type="string">Schrank</th>
				<th class="sortable" data-sort-type="number">Anzahl</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="item" items="${storageList}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/storage-item?id=${item.id}">${item.name}</a></td>
					<td>${item.location}</td>
					<td>${item.cabinet}</td>
					<td>${item.quantity}</td>
					<td style="display: flex; gap: 0.5rem; flex-wrap: wrap;"><a
						href="${pageContext.request.contextPath}/admin/storage?action=edit&id=${item.id}"
						class="btn btn-small">Bearbeiten</a> <a
						href="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${pageContext.request.scheme}://${pageContext.request.serverName}:${pageContext.request.serverPort}${pageContext.request.contextPath}/storage-item?id=${item.id}"
						target="_blank" class="btn btn-small btn-success">QR-Code</a>
						<form action="${pageContext.request.contextPath}/admin/storage"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${item.id}">
							<button type="submit" class="btn btn-small btn-danger"
								onclick="return confirm('Artikel \'${item.name}\' wirklich löschen?')">Löschen</button>
						</form></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_users.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  admin_users.jsp
  
  This is the main user management page for administrators. It displays a list
  of all users in the system with options to view their details or delete them.
  It also includes a form at the bottom to create a new user account.
  Features client-side filtering and sorting for the user table.
  
  - It is served by: AdminUserServlet (doGet).
  - It submits to: AdminUserServlet (doPost).
  - Expected attributes:
    - 'userList' (List<de.technikteam.model.User>): A list of all users.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Benutzerverwaltung" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>Benutzerverwaltung</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<a href="#new-user-form" class="btn">Neuen Benutzer anlegen</a>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>


<c:if test="${empty userList}">
	<div class="card">
		<p>Es sind keine Benutzer registriert.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="user" items="${userList}">
		<div class="list-item-card"
			data-searchable-content="${user.id} ${user.username} ${user.role}">
			<h3 class="card-title">${user.username}</h3>
			<div class="card-row">
				<span>ID:</span> <span>${user.id}</span>
			</div>
			<div class="card-row">
				<span>Rolle:</span> <span>${user.role}</span>
			</div>
			<div class="card-actions">
				<a
					href="${pageContext.request.contextPath}/admin/users?action=details&id=${user.id}"
					class="btn btn-small">Details</a>
				<c:if test="${sessionScope.user.id != user.id}">
					<form action="${pageContext.request.contextPath}/admin/users"
						method="post" style="display: inline;">
						<input type="hidden" name="action" value="delete"> <input
							type="hidden" name="userId" value="${user.id}">
						<button type="submit" class="btn btn-small btn-danger"
							onclick="return confirm('Benutzer ${user.username} wirklich löschen?')">Löschen</button>
					</form>
				</c:if>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="number">ID</th>
				<th class="sortable" data-sort-type="string">Benutzername</th>
				<th class="sortable" data-sort-type="string">Rolle</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="user" items="${userList}">
				<tr>
					<td>${user.id}</td>
					<td><a
						href="${pageContext.request.contextPath}/admin/users?action=details&id=${user.id}">${user.username}</a></td>
					<td>${user.role}</td>
					<td style="display: flex; gap: 0.5rem;"><a
						href="${pageContext.request.contextPath}/admin/users?action=details&id=${user.id}"
						class="btn btn-small">Details</a> <c:if
							test="${sessionScope.user.id != user.id}">
							<form action="${pageContext.request.contextPath}/admin/users"
								method="post" style="display: inline;">
								<input type="hidden" name="action" value="delete"> <input
									type="hidden" name="userId" value="${user.id}">
								<button type="submit" class="btn btn-small btn-danger"
									onclick="return confirm('Benutzer ${user.username} wirklich löschen?')">Löschen</button>
							</form>
						</c:if></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<div class="card" id="new-user-form" style="margin-top: 2rem;">
	<h2>Neuen Benutzer anlegen</h2>
	<form action="${pageContext.request.contextPath}/admin/users"
		method="post">
		<input type="hidden" name="action" value="create">
		<div class="form-group">
			<label for="new-username">Benutzername</label> <input type="text"
				id="new-username" name="username" required>
		</div>
		<div class="form-group">
			<label for="new-password">Passwort</label> <input type="password"
				id="new-password" name="password" required>
		</div>
		<div class="form-group">
			<label for="new-role">Rolle</label> <select name="role" id="new-role">
				<option value="NUTZER" selected>Nutzer</option>
				<option value="ADMIN">Admin</option>
			</select>
		</div>
		<div class="form-group">
			<label for="new-classYear">Jahrgang</label> <input type="number"
				id="new-classYear" name="classYear" placeholder="z.B. 2025">
		</div>
		<div class="form-group">
			<label for="new-className">Klasse</label> <input type="text"
				id="new-className" name="className" placeholder="z.B. 10b">
		</div>
		<button type="submit" class="btn">Benutzer erstellen</button>
	</form>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_user_details.jsp
========================================================================


<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>

<%--
  admin_user_details.jsp
  
  This JSP displays a detailed view of a single user for an administrator.
  It shows a form to edit the user's master data (username, role, class info)
  and a table listing the user's event participation history.
  
  - It is served by: AdminUserServlet (doGet with action=details).
  - It submits to: AdminUserServlet (doPost with action=update).
  - Expected attributes:
    - 'userToEdit' (de.technikteam.model.User): The user whose details are being viewed/edited.
    - 'eventHistory' (List<de.technikteam.model.Event>): The user's event history.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Benutzerdetails bearbeiten" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />

<h1>
	Benutzerdetails bearbeiten:
	<c:out value="${userToEdit.username}" />
</h1>
<a href="${pageContext.request.contextPath}/admin/users"
	style="display: inline-block; margin-bottom: 1rem;"> &laquo; Zurück
	zur Benutzerliste </a>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.infoMessage}">
	<p class="info-message">${sessionScope.infoMessage}</p>
	<c:remove var="infoMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="dashboard-grid">
	<%-- Master Data --%>
	<div class="card">
		<form action="${pageContext.request.contextPath}/admin/users"
			method="post">
			<input type="hidden" name="action" value="update"> <input
				type="hidden" name="userId" value="${userToEdit.id}">

			<h2 class="card-title">Stammdaten</h2>
			<div class="form-group">
				<label for="username">Benutzername</label> <input type="text"
					id="username" name="username" value="${userToEdit.username}"
					required>
			</div>
			<div class="form-group">
				<label for="role">Rolle</label> <select name="role" id="role">
					<option value="NUTZER"
						${userToEdit.role == 'NUTZER' ? 'selected' : ''}>Nutzer</option>
					<option value="ADMIN"
						${userToEdit.role == 'ADMIN' ? 'selected' : ''}>Admin</option>
				</select>
			</div>
			<div class="form-group">
				<label for="classYear">Jahrgang</label> <input type="number"
					id="classYear" name="classYear" value="${userToEdit.classYear}"
					placeholder="z.B. 2025">
			</div>
			<div class="form-group">
				<label for="className">Klasse</label> <input type="text"
					id="className" name="className" value="${userToEdit.className}"
					placeholder="z.B. 10b">
			</div>
			<div class="form-group">
				<label>Registriert seit</label> <input type="text"
					value="${userToEdit.formattedCreatedAt} Uhr" readonly
					class="readonly-field">
			</div>
			<button type="submit" class="btn">Änderungen speichern</button>
		</form>
	</div>

	<%-- Event History --%>
	<div class="card">
		<h2 class="card-title">Event-Teilnahmehistorie</h2>
		<div class="desktop-table-wrapper"
			style="box-shadow: none; border: none;">
			<table class="desktop-table">
				<thead>
					<tr>
						<th>Event</th>
						<th>Datum</th>
						<th>Status</th>
					</tr>
				</thead>
				<tbody>
					<c:if test="${empty eventHistory}">
						<tr>
							<td colspan="3">Keine Event-Historie vorhanden.</td>
						</tr>
					</c:if>
					<c:forEach var="event" items="${eventHistory}">
						<tr>
							<td><a
								href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a></td>
							<td>${event.formattedEventDateTime}Uhr</td>
							<td>${event.userAttendanceStatus}</td>
						</tr>
					</c:forEach>
				</tbody>
			</table>
		</div>
	</div>
</div>

<style>
.readonly-field {
	background-color: var(--bg-color);
	border: 1px solid var(--border-color);
	cursor: not-allowed;
	color: var(--text-muted-color);
}

.dashboard-grid {
	grid-template-columns: 1fr; /* Stack on mobile */
}

@media ( min-width : 992px) {
	.dashboard-grid {
		grid-template-columns: 1fr 1fr; /* Side-by-side on desktop */
	}
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\css\style.css
========================================================================

/* =================================================================== */
/*                MODERN TECHNIKTEAM DESIGN V12 (FINAL BLUE)           */
/* =================================================================== */

/* --- 1. THEME & COLOR PALETTE --- */
:root {
	/* Light Theme */
	--primary-color: #0d6efd;
	--primary-color-hover: #0a58ca;
	--primary-color-light: rgba(13, 110, 253, 0.1);
	--bg-color: #f0f2f5;
	--surface-color: #ffffff;
	--text-color: #212529;
	--text-muted-color: #6c757d;
	--border-color: #e9ecef;
	--success-color: #198754;
	--warning-color: #ffc107;
	--danger-color: #dc3545;
	--danger-hover-color: #bb2d3b;
	--shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05);
}

[data-theme="dark"] {
	/* Dark Theme */
	--primary-color: #3b82f6;
	--primary-color-hover: #60a5fa;
	--primary-color-light: rgba(59, 130, 246, 0.15);
	--bg-color: #000000;
	--surface-color: #1a1a1a;
	--text-color: #f8f9fa;
	--text-muted-color: #adb5bd;
	--border-color: #343a40;
	--success-color: #20c997;
	--warning-color: #fcc419;
	--danger-color: #ef4444;
	--danger-hover-color: #dc2626;
}

/* --- 2. BASE & LAYOUT --- */
*, *::before, *::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

body {
	font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
		Roboto, sans-serif;
	background-color: var(--bg-color);
	color: var(--text-color);
	line-height: 1.6;
	display: flex;
	flex-direction: column;
	min-height: 100vh;
	transition: background-color 0.2s, color 0.2s;
}

body.nav-open {
	overflow: hidden;
}

main {
	padding: 1rem;
	width: 100%;
	flex: 1;
}

h1 {
	font-size: 2rem;
	font-weight: 700;
	margin-bottom: 0.5rem;
	color: var(--primary-color);
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

main>p {
	margin-bottom: 1.5rem;
	color: var(--text-muted-color);
	font-size: 1.1rem;
}

h2 {
	font-size: 1.5rem;
	font-weight: 600;
	margin-bottom: 1rem;
	color: var(--text-color);
	border-bottom: 1px solid var(--border-color);
	padding-bottom: 0.5rem;
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

a {
	color: var(--primary-color);
	text-decoration: none;
	transition: color 0.2s;
}

a:hover {
	text-decoration: none;
	color: var(--primary-color-hover);
}

.app-footer {
	text-align: center;
	padding: 2rem;
	color: var(--text-muted-color);
	margin-top: auto;
}

/* --- 3. HEADER & NAVIGATION --- */
.app-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0 1.5rem;
	height: 64px;
	background-color: var(--surface-color);
	border-bottom: 1px solid var(--border-color);
	position: sticky;
	top: 0;
	z-index: 1000;
	box-shadow: var(--shadow-sm);
}

.logo {
	font-size: 1.5rem;
	font-weight: 700;
	color: var(--text-color);
	flex-shrink: 0;
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.logo i {
	color: var(--primary-color);
}

.mobile-nav-toggle {
	display: block;
	background: none;
	border: none;
	cursor: pointer;
	z-index: 1001;
}

.mobile-nav-toggle .line {
	width: 28px;
	height: 3px;
	background-color: var(--text-color);
	margin: 6px 0;
	border-radius: 3px;
	transition: all 0.3s;
}

.nav-open .mobile-nav-toggle .line-1 {
	transform: rotate(45deg) translate(7px, 7px);
}

.nav-open .mobile-nav-toggle .line-2 {
	opacity: 0;
}

.nav-open .mobile-nav-toggle .line-3 {
	transform: rotate(-45deg) translate(7px, -7px);
}

.main-nav {
	position: fixed;
	top: 64px;
	right: -320px;
	width: 300px;
	height: calc(100vh - 64px);
	background-color: var(--surface-color);
	z-index: 999;
	transition: right 0.3s ease-in-out;
	display: flex;
	flex-direction: column;
	border-left: 1px solid var(--border-color);
}

.nav-open .main-nav {
	right: 0;
}

.main-nav ul {
	list-style: none;
}

.main-nav a {
	display: flex;
	align-items: center;
	gap: 1rem;
	padding: 1rem 2rem;
	font-size: 1.1rem;
	color: var(--text-muted-color);
	font-weight: 500;
	border-left: 4px solid transparent;
	transition: all 0.2s ease-in-out;
}

.main-nav a:hover, .main-nav a.active-nav-link {
	background-color: var(--primary-color-light);
	text-decoration: none;
	color: var(--primary-color);
	border-left-color: var(--primary-color);
}

.main-nav a i {
	width: 20px;
	text-align: center;
}

.user-actions {
	margin-top: auto;
	padding: 1rem 2rem;
	border-top: 1px solid var(--border-color);
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

/* --- 4. THEME SWITCHER --- */
.theme-switch-wrapper {
	display: flex;
	align-items: center;
}

.theme-switch {
	display: inline-block;
	height: 24px;
	position: relative;
	width: 50px;
}

.theme-switch input {
	display: none;
}

.slider {
	background-color: #ccc;
	bottom: 0;
	cursor: pointer;
	left: 0;
	position: absolute;
	right: 0;
	top: 0;
	transition: .4s;
}

.slider:before {
	background-color: white;
	bottom: 4px;
	content: "";
	height: 16px;
	left: 4px;
	position: absolute;
	transition: .4s;
	width: 16px;
}

input:checked+.slider {
	background-color: var(--primary-color);
}

input:checked+.slider:before {
	transform: translateX(26px);
}

.slider.round {
	border-radius: 34px;
}

.slider.round:before {
	border-radius: 50%;
}

/* --- 5. COMPONENTS --- */
.card {
	background-color: var(--surface-color);
	border-radius: 8px;
	padding: 1.5rem;
	margin-bottom: 1.5rem;
	box-shadow: var(--shadow-sm);
	border: 1px solid var(--border-color);
	border-top: 4px solid var(--primary-color);
}

.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;
	padding: 0.6rem 1.2rem;
	background-color: var(--primary-color);
	color: #fff;
	border: 1px solid var(--primary-color);
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s;
	text-align: center;
}

.btn:hover {
	transform: translateY(-2px);
	box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
	text-decoration: none;
	color: #fff;
	background-color: var(--primary-color-hover);
	border-color: var(--primary-color-hover);
}

.btn-small {
	padding: 0.4rem 0.8rem;
	font-size: 0.9rem;
}

.btn-danger {
	background-color: var(--danger-color);
	border-color: var(--danger-color);
}

.btn-danger:hover {
	background-color: var(--danger-hover-color);
	border-color: var(--danger-hover-color);
}

.btn-secondary {
	background-color: var(--surface-color);
	border-color: var(--border-color);
	color: var(--text-color);
}

.btn-secondary:hover {
	background-color: var(--primary-color);
	border-color: var(--primary-color);
	color: #fff;
}

.btn-danger-outline {
	background-color: var(--surface-color);
	border-color: var(--danger-color);
	color: var(--danger-color);
}

.btn-danger-outline:hover {
	background-color: var(--danger-color);
	color: #fff;
}

.success-message, .error-message, .info-message {
	padding: 1rem;
	margin-bottom: 1.5rem;
	border-radius: 8px;
	color: #fff;
	border: 1px solid transparent;
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.success-message {
	background-color: var(--success-color);
}

.error-message {
	background-color: var(--danger-color);
}

.info-message {
	background-color: var(--primary-color);
}

.form-group {
	margin-bottom: 1.5rem;
}

.form-group label {
	display: block;
	margin-bottom: 0.5rem;
	font-weight: 500;
}

.form-group input, .form-group select, .form-group textarea {
	width: 100%;
	padding: 0.75rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
	background-color: var(--surface-color);
	color: var(--text-color);
	font-size: 1rem;
	transition: all 0.2s;
}

.form-group input:focus, .form-group select:focus, .form-group textarea:focus
	{
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 3px var(--primary-color-light);
}

/* --- 6. MODALS & LIGHTBOX --- */
.lightbox-overlay, .modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.7);
	display: flex;
	justify-content: center;
	align-items: center;
	z-index: 2000;
	opacity: 0;
	visibility: hidden;
	transition: opacity 0.3s, visibility 0.3s;
}

.lightbox-overlay.active, .modal-overlay.active {
	opacity: 1;
	visibility: visible;
}

.lightbox-overlay img {
	max-width: 90%;
	max-height: 90%;
	box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
	border-radius: 4px;
}

.modal-content {
	background-color: var(--surface-color);
	padding: 2rem;
	border-radius: 12px;
	width: 90%;
	max-width: 500px;
	position: relative;
	box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
	transform: scale(0.95);
	transition: transform 0.3s;
}

.modal-overlay.active .modal-content {
	transform: scale(1);
}

.modal-close-btn {
	position: absolute;
	top: 10px;
	right: 15px;
	font-size: 2rem;
	font-weight: bold;
	color: var(--text-muted-color);
	cursor: pointer;
	border: none;
	background: none;
	line-height: 1;
}

/* --- 7. FILE MANAGER & TABLE CONTROLS --- */
.file-manager-layout {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1.5rem;
	align-items: flex-start;
}

ul.category-list {
	list-style: none;
	padding: 0;
	margin: 0 0 1rem 0;
}

ul.category-list li {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0.75rem 1rem;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s ease-in-out;
	border: 1px solid var(--border-color);
	margin-bottom: 0.5rem;
}

ul.category-list li:hover {
	background-color: var(--primary-color-light);
	border-color: var(--primary-color);
	color: var(--primary-color);
}

ul.category-list li.active {
	background-color: var(--primary-color);
	color: #fff;
	border-color: var(--primary-color);
}

ul.file-list {
	list-style: none;
	padding: 0;
}

ul.file-list li {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	gap: 1rem;
}

ul.file-list li:last-child {
	border-bottom: none;
}

.file-info a {
	font-weight: 500;
}

.file-meta {
	color: var(--text-muted-color);
	display: block;
	font-size: 0.9em;
}

/* --- 8. DESKTOP MEDIA QUERIES --- */
@media ( min-width : 992px) {
	main {
		max-width: 1600px;
		margin: 0 auto;
		padding: 2rem;
	}
	.mobile-nav-toggle, .mobile-card-list, .mobile-matrix-wrapper {
		display: none;
	}
	.desktop-table-wrapper, .desktop-table {
		display: block;
	}
	.main-nav {
		position: static;
		width: auto;
		height: 100%;
		padding: 0;
		flex-direction: row;
		align-items: stretch;
		flex-grow: 1;
		transition: none;
		margin-left: 2rem;
		border-left: none;
	}
	.main-nav ul {
		display: flex;
		flex-direction: row;
		align-items: stretch;
		gap: 0.5rem;
	}
	.main-nav a {
		padding: 0 1rem;
		border-left: none;
		border-bottom: 4px solid transparent;
	}
	.main-nav a:hover, .main-nav a.active-nav-link {
		color: var(--primary-color);
		border-bottom-color: var(--primary-color);
		background: none;
	}
	.user-actions {
		flex-direction: row;
		align-items: center;
		gap: 1rem;
		margin: 0 0 0 auto;
		padding: 0;
		border: none;
	}
	.user-actions .btn {
		padding: 0.5rem 1rem;
	}
	.user-actions .btn i {
		font-size: 1rem;
	}
	.desktop-table-wrapper {
		border: 1px solid var(--border-color);
		border-radius: 8px;
		overflow: hidden;
		box-shadow: var(--shadow-sm);
	}
	.desktop-table {
		display: table;
		width: 100%;
		border-collapse: collapse;
		background-color: var(--surface-color);
	}
	.desktop-table th {
		padding: 1rem 1.5rem;
		text-align: left;
		background-color: var(--bg-color);
		color: var(--text-color);
		font-weight: 600;
		border-bottom: 2px solid var(--border-color);
	}
	.desktop-table th.sortable {
		cursor: pointer;
		position: relative;
	}
	.desktop-table th.sortable::after {
		content: ' \2195';
		opacity: 0.4;
		position: absolute;
		right: 1rem;
	}
	.desktop-table th.sortable.sorted-asc::after {
		content: ' \2191';
		opacity: 1;
	}
	.desktop-table th.sortable.sorted-desc::after {
		content: ' \2193';
		opacity: 1;
	}
	.desktop-table td {
		padding: 1rem 1.5rem;
		border-bottom: 1px solid var(--border-color);
	}
	.desktop-table tbody tr:last-child td {
		border-bottom: none;
	}
	.desktop-table tbody tr:hover {
		background-color: var(--primary-color-light);
	}
	.file-manager-layout {
		grid-template-columns: 320px 1fr;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\main.js
========================================================================

/**
 * Main JavaScript file for the TechnikTeam application.
 * This file is included on every page and handles global user interface logic.
 *
 * It contains functionality for:
 * 1. Mobile Navigation: Toggling the slide-in menu (hamburger menu).
 * 2. Active Navigation Link Highlighting: Marks the current page in the nav bar.
 * 3. Theme Switching: Handling light/dark mode persistence via localStorage.
 * 4. User Interaction Confirmations: Adding a confirmation dialog to the logout link.
 * 5. Server-Sent Events (SSE): Establishing a connection to receive real-time
 *    push notifications from the server and displaying them as browser notifications.
 */
document.addEventListener('DOMContentLoaded', () => {

	// --- 1. Mobile Navigation Toggle Logic ---
	const navToggle = document.querySelector('.mobile-nav-toggle');
	const mainContent = document.querySelector('main');
	const mainNav = document.querySelector('.main-nav');

	const toggleNavigation = (e) => {
		e.stopPropagation();
		document.body.classList.toggle('nav-open');
	};

	const closeNavigation = () => {
		if (document.body.classList.contains('nav-open')) {
			document.body.classList.remove('nav-open');
		}
	};

	if (navToggle) {
		navToggle.addEventListener('click', toggleNavigation);
	}
	if (mainContent) {
		mainContent.addEventListener('click', closeNavigation);
	}
	if (mainNav) {
		// Prevent clicks inside the nav from closing it
		mainNav.addEventListener('click', (e) => e.stopPropagation());
	}


	// --- 2. Active Navigation Link Highlighting ---
	const currentPath = window.location.pathname;
	const contextPath = document.body.dataset.contextPath || '';
	const navLinks = document.querySelectorAll('.main-nav a');

	navLinks.forEach(link => {
		const linkPath = link.getAttribute('href').substring(contextPath.length);
		if (linkPath && currentPath.startsWith(linkPath) && linkPath !== `${contextPath}/`) {
			link.classList.add('active-nav-link');
		}
	});
	// Special case for home page
	const homeLink = document.querySelector('.main-nav a[href$="/home"]');
	if (homeLink && (currentPath === `${contextPath}/` || currentPath === `${contextPath}/home`)) {
		homeLink.classList.add('active-nav-link');
	}
	// Special case for admin dashboard
	const adminDashboardLink = document.querySelector('.main-nav a[href$="/admin/dashboard"]');
	if (adminDashboardLink && (currentPath === `${contextPath}/admin/` || currentPath === `${contextPath}/admin/dashboard`)) {
		adminDashboardLink.classList.add('active-nav-link');
	}


	// --- 3. Theme Switcher Logic ---
	const themeCheckbox = document.getElementById('theme-checkbox');
	const applyTheme = (theme) => {
		document.documentElement.setAttribute('data-theme', theme);
		if (themeCheckbox) {
			themeCheckbox.checked = (theme === 'dark');
		}
	};
	const savedTheme = localStorage.getItem('theme');
	const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
	applyTheme(savedTheme || (prefersDark ? 'dark' : 'light'));
	if (themeCheckbox) {
		themeCheckbox.addEventListener('change', () => {
			const newTheme = themeCheckbox.checked ? 'dark' : 'light';
			localStorage.setItem('theme', newTheme);
			applyTheme(newTheme);
		});
	}


	// --- 4. Logout Confirmation Logic ---
	const logoutLink = document.getElementById('logout-link');
	if (logoutLink) {
		logoutLink.addEventListener('click', (event) => {
			if (!confirm('Bist du sicher, dass du dich ausloggen möchtest?')) {
				event.preventDefault();
			}
		});
	}


	// --- 5. Server-Sent Events (SSE) Notification Logic ---
	if (document.body.dataset.isLoggedIn === 'true' && window.EventSource) {
		const eventSource = new EventSource(`${contextPath}/notifications`);

		eventSource.onopen = () => console.log("SSE connection established.");

		eventSource.onmessage = (event) => {
			console.log("SSE message received:", event.data);
			showBrowserNotification(event.data);
		};

		eventSource.onerror = (err) => {
			console.error("SSE connection error.", err);
			eventSource.close();
		};
	}

	function showBrowserNotification(message) {
		if (!("Notification" in window)) {
			console.warn("This browser does not support desktop notifications.");
			return;
		}
		if (Notification.permission === "granted") {
			new Notification("Technik Team Update", { body: message, icon: `${contextPath}/images/logo.png` });
		} else if (Notification.permission !== "denied") {
			Notification.requestPermission().then((permission) => {
				if (permission === "granted") {
					new Notification("Technik Team Update", { body: message, icon: `${contextPath}/images/logo.png` });
				}
			});
		}
	}
});

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\WEB-INF\web.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
	version="6.0">

	<!-- web.xml: The core deployment descriptor for the web application. This 
		file configures essential, application-wide settings that cannot be handled 
		by Java annotations. It defines: - Session Timeout: How long a user's session 
		remains active during inactivity. - Welcome File: The default page a user 
		sees when they visit the root URL. - JSP Configuration: Ensures Expression 
		Language (EL) is enabled on all JSPs. - Custom Error Pages: Maps HTTP error 
		codes like 404 (Not Found) and 500 (Internal Server Error) to user-friendly, 
		custom JSP pages. Note: All Servlet, Filter, and Listener mappings are now 
		managed via annotations in their respective Java classes for a more modern 
		and decentralized configuration approach. -->

	<display-name>TechnikTeam Web Application</display-name>

	<session-config>
		<session-timeout>30</session-timeout> <!-- in minutes -->
	</session-config>

	<welcome-file-list>
		<welcome-file>login.jsp</welcome-file>
	</welcome-file-list>

	<!-- Ensures that Expression Language (${...}) is always enabled on JSPs. -->
	<jsp-config>
		<jsp-property-group>
			<url-pattern>*.jsp</url-pattern>
			<url-pattern>*.jspf</url-pattern>
			<el-ignored>false</el-ignored>
		</jsp-property-group>
	</jsp-config>

	<!-- Custom Error Pages -->
	<error-page>
		<error-code>404</error-code>
		<location>/error404.jsp</location>
	</error-page>
	<error-page>
		<error-code>500</error-code>
		<location>/error500.jsp</location>
	</error-page>
	<error-page>
		<exception-type>java.lang.Throwable</exception-type>
		<location>/error500.jsp</location>
	</error-page>

</web-app>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\collaborative_editor.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  collaborative_editor.jsp
  
  This page provides a real-time collaborative text editor. The core
  functionality is handled by client-side JavaScript which communicates
  with the DocumentApiServlet. It periodically fetches the latest content
  and saves changes back to the server after the user stops typing.
  
  - It is served by: CollaborativeEditorServlet.
  - Expected attributes: None.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Gemeinsamer Editor" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Gemeinsamer Notizblock</h1>
<p>Änderungen werden automatisch für alle Benutzer gespeichert und
	angezeigt.</p>

<div class="card">
	<textarea id="editor" class="form-group"
		style="width: 100%; height: 60vh; font-family: monospace; font-size: 16px; margin: 0; background-color: var(--surface-color);"
		placeholder="Lade Inhalt..."></textarea>
	<div id="status-indicator"
		style="text-align: right; font-style: italic; color: var(--text-muted-color); padding-top: 5px; min-height: 1.2em;"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const editor = document.getElementById('editor');
    const statusIndicator = document.getElementById('status-indicator');
    const apiUrl = "${pageContext.request.contextPath}/api/document";
    let debounceTimer;

    // --- Function to SAVE content to the server ---
    // Uses a "debouncer" to avoid spamming the server with requests on every keystroke.
    const saveContent = () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            const content = editor.value;
            statusIndicator.textContent = 'Speichere...';
            fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain; charset=utf-8' },
                body: content
            }).then(response => {
                if (response.ok) {
                    statusIndicator.textContent = 'Gespeichert';
                } else {
                    statusIndicator.textContent = 'Fehler beim Speichern!';
                    statusIndicator.style.color = 'var(--danger-color)';
                }
            }).catch(err => {
                 statusIndicator.textContent = 'Netzwerkfehler!';
                 statusIndicator.style.color = 'var(--danger-color)';
            });
        }, 500); // Wait 500ms after last keystroke
    };

    // --- Function to FETCH content from the server ---
    const fetchContent = () => {
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) throw new Error("Server response not OK");
                return response.text();
            })
            .then(newContent => {
                // IMPORTANT: Only update the editor if the content has actually changed
                // and the user is not currently typing in it. This prevents the cursor from jumping.
                if (document.activeElement !== editor && editor.value !== newContent) {
                    const cursorPos = editor.selectionStart; // Save cursor position
                    editor.value = newContent;
                    editor.selectionStart = editor.selectionEnd = cursorPos; // Restore cursor position
                }
            }).catch(err => {
                console.error("Error fetching document content:", err);
                statusIndicator.textContent = 'Fehler beim Laden!';
                statusIndicator.style.color = 'var(--danger-color)';
            });
    };
    
    // Attach the event listener to save content when the user types
    editor.addEventListener('input', saveContent);

    // Start polling: Fetch the content every 3 seconds
    setInterval(fetchContent, 3000);

    // Initial load of the document
    fetchContent();
});
</script>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\dateien.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  dateien.jsp
  
  This is the main user-facing page for accessing files and documents.
  It displays a list of all files the user is authorized to see, grouped
  by their category. It also includes a special, "virtual" link to the
  collaborative editor page.
  
  - It is served by: FileServlet.
  - Expected attributes:
    - 'fileData' (Map<String, List<de.technikteam.model.File>>): Files grouped by category.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Dateien" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Dateien & Dokumente</h1>

<c:if test="${empty fileData}">
	<div class="card">
		<p>Es sind keine Dateien oder Dokumente verfügbar.</p>
	</div>
</c:if>

<c:forEach var="categoryEntry" items="${fileData}">
	<div class="card">
		<h2>${categoryEntry.key}</h2>
		<ul style="list-style: none; padding-left: 0;">
			<c:forEach var="file" items="${categoryEntry.value}" varStatus="loop">
				<li
					style="padding: 0.75rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
					<c:choose>
						<%-- The virtual file with ID -1 links to the editor page --%>
						<c:when test="${file.id == -1}">
							<a href="${pageContext.request.contextPath}/editor-page"
								style="font-weight: 600;">${file.filename}</a>
						</c:when>
						<%-- All other files link to the download servlet --%>
						<c:otherwise>
							<a
								href="${pageContext.request.contextPath}/download?file=${file.filepath}">${file.filename}</a>
						</c:otherwise>
					</c:choose>
				</li>
			</c:forEach>
		</ul>
	</div>
</c:forEach>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\error404.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>
<jsp:useBean id="now" class="java.util.Date" />

<%--
  error404.jsp
  
  This is a custom, user-friendly "Page Not Found" page. It is displayed
  whenever a user navigates to a URL that does not map to any servlet or
  resource in the application. The mapping is configured in web.xml.
  It does not use the standard navigation for a cleaner error display.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="404 - Seite nicht gefunden" />
</c:import>

<header class="app-header">
	<a href="${pageContext.request.contextPath}/home" class="logo">Technik
		Team</a>
</header>

<main>
	<div class="error-container">
		<div class="error-icon">⚠️</div>
		<h1>Seite nicht gefunden</h1>
		<h2>Fehlercode 404</h2>

		<p>
			Die von dir aufgerufene Seite <strong><c:out
					value="${pageContext.errorData.requestURI}" /></strong> existiert leider
			nicht.
		</p>
		<p>Möglicherweise hast du dich vertippt oder der Link ist
			veraltet.</p>

		<a href="${pageContext.request.contextPath}/home" class="btn">Zurück
			zur Startseite</a>

		<div class="error-details">
			Fehlerzeitpunkt:
			<fmt:formatDate value="${now}" type="both" dateStyle="long"
				timeStyle="medium" />
		</div>
	</div>
</main>

<style>
/* Specific styles for the error page content */
.error-container {
	text-align: center;
	padding: 2rem;
	margin: 2rem auto;
	max-width: 650px;
	background-color: var(--surface-color);
	border-radius: 12px;
	border: 1px solid var(--border-color);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.error-icon {
	font-size: 4rem;
	color: var(--primary-color);
	margin-bottom: 1rem;
}

.error-container h1 {
	font-size: 2.2rem;
	color: var(--text-color);
	margin-bottom: 0.25rem;
}

.error-container h2 {
	font-size: 1.2rem;
	color: var(--text-muted-color);
	font-weight: 500;
	margin-bottom: 2rem;
}

.error-container p {
	margin-bottom: 1rem;
	font-size: 1.1rem;
	line-height: 1.6;
}

.error-container .btn {
	margin-top: 1rem;
}

.error-details {
	margin-top: 2rem;
	font-size: 0.85rem;
	color: var(--text-muted-color);
	border-top: 1px solid var(--border-color);
	padding-top: 1rem;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\error500.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isErrorPage="true" isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>
<jsp:useBean id="now" class="java.util.Date" />

<%--
  error500.jsp
  
  This is a custom "Internal Server Error" page. It is displayed whenever an
  uncaught exception occurs during the processing of a request. The mapping
  is configured in web.xml. For developers, it includes a hidden HTML comment
  with basic debugging information (the full stack trace is available in the
  server logs).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="500 - Interner Serverfehler" />
</c:import>

<header class="app-header">
	<a href="${pageContext.request.contextPath}/home" class="logo">Technik
		Team</a>
</header>

<main>
	<div class="error-container">
		<div class="error-icon" style="color: var(--danger-color);">⚙️</div>
		<h1>Interner Serverfehler</h1>
		<h2>Fehlercode 500</h2>

		<p>Es ist ein unerwarteter technischer Fehler aufgetreten.</p>
		<p>Unser Team wurde bereits benachrichtigt. Bitte versuche es
			später erneut oder wende dich an einen Administrator, wenn der Fehler
			weiterhin bestehen bleibt.</p>

		<a href="${pageContext.request.contextPath}/home" class="btn">Zurück
			zur Startseite</a>

		<div class="error-details">
			Fehlerzeitpunkt:
			<fmt:formatDate value="${now}" type="both" dateStyle="long"
				timeStyle="medium" />
		</div>

		<%-- 
          DEBUGGING INFO: This block is hidden from regular users via an HTML comment.
          It allows developers to see error details by viewing the page source in the browser.
          The full stack trace is always available in the server logs (e.g., catalina.out).
        --%>
		<!--
            Exception Details for Developers:
            Request URI:    ${pageContext.errorData.requestURI}
            Servlet Name:   ${pageContext.errorData.servletName}
            Exception Type: ${pageContext.exception}
            Exception Msg:  ${pageContext.exception.message}
            Stack Trace:
            <c:forEach var="trace" items="${pageContext.exception.stackTrace}">
                ${trace}
            </c:forEach>
        -->
	</div>
</main>

<style>
/* Reuse the same styles from the 404 page for consistency */
.error-container {
	text-align: center;
	padding: 2rem;
	margin: 2rem auto;
	max-width: 650px;
	background-color: var(--surface-color);
	border-radius: 12px;
	border: 1px solid var(--border-color);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.error-icon {
	font-size: 4rem;
	color: var(--danger-color);
	margin-bottom: 1rem;
}

.error-container h1 {
	font-size: 2.2rem;
	color: var(--text-color);
	margin-bottom: 0.25rem;
}

.error-container h2 {
	font-size: 1.2rem;
	color: var(--text-muted-color);
	font-weight: 500;
	margin-bottom: 2rem;
}

.error-container p {
	margin-bottom: 1rem;
	font-size: 1.1rem;
	line-height: 1.6;
}

.error-container .btn {
	margin-top: 1rem;
}

.error-details {
	margin-top: 2rem;
	font-size: 0.85rem;
	color: var(--text-muted-color);
	border-top: 1px solid var(--border-color);
	padding-top: 1rem;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\eventDetails.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<%--
  eventDetails.jsp
  
  This JSP displays the detailed view of a single event. It shows general info
  (description, requirements, assigned team) for all users. For events with a
  status of 'LAUFEND', it reveals an interactive section with a task list and
  a real-time chat, available only to assigned team members and admins.
  
  - It is served by: EventDetailsServlet.
  - Expected attributes:
    - 'event' (de.technikteam.model.Event): The event object, populated with all necessary details.
    - 'assignedUsers' (List<User>): For admins, the list of users assigned to the event.
    - 'isUserAssigned' (boolean): For regular users, indicates if they are on the team.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Event Details" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<div class="details-container" data-event-id="${event.id}">

	<div
		style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
		<h1>
			<c:out value="${event.name}" />
		</h1>
		<c:if test="${not empty event.status}">
			<span class="status-badge"
				style="padding: 0.3rem 0.8rem; border-radius: 20px; font-size: 1rem; font-weight: 500; color: white;
                background-color: ${event.status == 'KOMPLETT' ? 'var(--success-color)' : event.status == 'LAUFEND' ? 'orange' : event.status == 'ABGESCHLOSSEN' ? 'var(--text-muted-color)' : 'var(--info-color)'};">
				${event.status} </span>
		</c:if>
	</div>

	<p class="details-subtitle">
		<strong>Zeitraum:</strong> ${event.formattedEventDateTimeRange}
	</p>

	<%-- Interactive section for running events, visible only to assigned users and admins --%>
	<c:if
		test="${event.status == 'LAUFEND' and (isUserAssigned or sessionScope.user.role == 'ADMIN')}">
		<div class="dashboard-grid responsive-grid">
			<div class="card">
				<h2 class="card-title">Aufgaben</h2>
				<%-- Admin view for tasks: manage all tasks --%>
				<c:if test="${sessionScope.user.role == 'ADMIN'}">
					<div id="admin-task-manager">
						<ul id="task-list-admin" class="details-list">
							<c:if test="${empty event.eventTasks}">
								<p>Noch keine Aufgaben erstellt.</p>
							</c:if>
							<c:forEach var="task" items="${event.eventTasks}">
								<li id="task-item-${task.id}">
									<div style="flex-grow: 1;">
										<strong>${task.description}</strong><br> <small>Zugewiesen:
											${not empty task.assignedUsernames ? task.assignedUsernames : 'Niemand'}</small>
									</div>
									<div style="display: flex; gap: 0.5rem; flex-shrink: 0;">
										<span
											class="status-badge ${task.status == 'ERLEDIGT' ? 'status-ok' : 'status-warn'}">${task.status}</span>
										<button class="btn btn-small assign-task-btn"
											data-task-id="${task.id}">Zuweisen</button>
										<button class="btn btn-small btn-danger delete-task-btn"
											data-task-id="${task.id}">×</button>
									</div>
								</li>
							</c:forEach>
						</ul>
						<form action="${pageContext.request.contextPath}/admin/tasks"
							method="post"
							style="margin-top: 1rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
							<input type="hidden" name="action" value="create"> <input
								type="hidden" name="eventId" value="${event.id}">
							<div class="form-group">
								<label for="task-description">Neue Aufgabe</label> <input
									type="text" name="description" id="task-description" required
									placeholder="z.B. Mischpult aufbauen">
							</div>
							<button type="submit" class="btn btn-small">Aufgabe
								erstellen</button>
						</form>
					</div>
				</c:if>
				<%-- User view for tasks: see and complete only their own tasks --%>
				<c:if test="${sessionScope.user.role != 'ADMIN'}">
					<ul id="task-list-user" class="details-list">
						<c:forEach var="task" items="${event.eventTasks}">
							<c:if
								test="${fn:contains(task.assignedUsernames, sessionScope.user.username) and task.status == 'OFFEN'}">
								<li id="task-item-user-${task.id}"><label
									style="display: flex; align-items: center; gap: 0.5rem; width: 100%; cursor: pointer;">
										<input type="checkbox" class="task-checkbox"
										data-task-id="${task.id}"
										style="width: auto; height: 1.2rem; flex-shrink: 0;">
										<span>${task.description}</span>
								</label></li>
							</c:if>
						</c:forEach>
					</ul>
				</c:if>
			</div>
			<div class="card">
				<h2 class="card-title">Event-Chat</h2>
				<div id="chat-box"
					style="height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 0.5rem; margin-bottom: 1rem; background: var(--bg-color);"></div>
				<form id="chat-form" style="display: flex; gap: 0.5rem;">
					<input type="text" id="chat-message-input" class="form-group"
						style="flex-grow: 1; margin: 0;"
						placeholder="Nachricht eingeben...">
					<button type="submit" class="btn">Senden</button>
				</form>
			</div>
		</div>
	</c:if>

	<div class="card">
		<h2 class="card-title">Beschreibung</h2>
		<p>${not empty event.description ? event.description : 'Keine Beschreibung für dieses Event vorhanden.'}</p>
	</div>
	<div class="card">
		<h2 class="card-title">Benötigter Personalbedarf</h2>
		<ul class="details-list">
			<c:if test="${empty event.skillRequirements}">
				<p>Keine speziellen Qualifikationen benötigt.</p>
			</c:if>
			<c:forEach var="req" items="${event.skillRequirements}">
				<li><strong>${req.courseName}:</strong> ${req.requiredPersons}
					Person(en) benötigt</li>
			</c:forEach>
		</ul>
	</div>
	<div class="card">
		<h2 class="card-title">Zugewiesenes Team</h2>
		<ul class="details-list">
			<c:if test="${empty event.assignedAttendees}">
				<p>Noch kein Team zugewiesen.</p>
			</c:if>
			<c:forEach var="attendee" items="${event.assignedAttendees}">
				<li><a
					href="${pageContext.request.contextPath}/admin/users?action=details&id=${attendee.id}">${attendee.username}</a></li>
			</c:forEach>
		</ul>
	</div>
	<div style="margin-top: 2rem;">
		<a href="${pageContext.request.contextPath}/events" class="btn">Zurück
			zur Event-Übersicht</a>
	</div>
</div>

<div class="modal-overlay" id="assign-task-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3>Aufgabe zuweisen</h3>
		<form action="${pageContext.request.contextPath}/admin/tasks"
			method="post">
			<input type="hidden" name="action" value="assign"> <input
				type="hidden" name="eventId" value="${event.id}"> <input
				type="hidden" name="taskId" id="modal-task-id">
			<div class="form-group">
				<label>Verfügbare Teammitglieder</label>
				<div id="modal-user-checkboxes"
					style="display: flex; flex-direction: column; gap: 0.5rem;">
					<c:forEach var="user" items="${assignedUsers}">
						<label><input type="checkbox" name="userIds"
							value="${user.id}"> ${user.username}</label>
					</c:forEach>
				</div>
			</div>
			<button type="submit" class="btn">Zuweisung speichern</button>
		</form>
	</div>
</div>

<style>
.details-subtitle {
	font-size: 1.1rem;
	color: var(--text-muted-color);
	margin-bottom: 1.5rem;
}

.details-list {
	list-style-type: none;
	padding-left: 0;
	margin: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex-wrap: wrap;
	gap: 1rem;
}

.details-list li:last-child {
	border-bottom: none;
}

.responsive-grid {
	grid-template-columns: 1fr;
}

@media ( min-width : 992px) {
	.responsive-grid {
		grid-template-columns: 1fr 1fr;
	}
}
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const mainContainer = document.querySelector('.details-container');
    if (!mainContainer) return;
    
    const contextPath = "${pageContext.request.contextPath}";
    const eventId = mainContainer.dataset.eventId;
    const currentUserId = "${sessionScope.user.id}";
    const isAdmin = "${sessionScope.user.role}" === "ADMIN";

    if (!eventId) {
        console.error("Event ID is missing. Real-time features disabled.");
        return;
    }
    
    // --- Admin-specific JS for task management ---
    if (isAdmin) {
        const assignModal = document.getElementById('assign-task-modal');
        if (assignModal) {
            const modalTaskIdInput = document.getElementById('modal-task-id');
            const modalCloseBtn = assignModal.querySelector('.modal-close-btn');
            
            document.querySelectorAll('.assign-task-btn').forEach(btn => btn.addEventListener('click', () => {
                modalTaskIdInput.value = btn.dataset.taskId;
                assignModal.classList.add('active');
            }));
            
            if(modalCloseBtn) modalCloseBtn.addEventListener('click', () => assignModal.classList.remove('active'));
            assignModal.addEventListener('click', e => { if (e.target === assignModal) assignModal.classList.remove('active'); });
        }
        
        document.querySelectorAll('.delete-task-btn').forEach(btn => btn.addEventListener('click', (e) => {
            if (confirm('Aufgabe wirklich löschen?')) {
                fetch(`${contextPath}/admin/tasks?taskId=${e.target.dataset.taskId}`, { method: 'DELETE' })
                    .then(res => res.ok ? e.target.closest('li').remove() : alert('Löschen fehlgeschlagen!'));
            }
        }));
    }

    // --- User-specific JS for completing tasks ---
    document.querySelectorAll('.task-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
            const params = new URLSearchParams({ taskId: e.target.dataset.taskId, status: e.target.checked ? 'ERLEDIGT' : 'OFFEN' });
            fetch(`${contextPath}/task-action`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: params })
                .then(res => {
                    if (res.ok) {
                        if (e.target.checked) e.target.closest('li').style.display = 'none';
                    } else { e.target.checked = !e.target.checked; alert('Status konnte nicht aktualisiert werden.'); }
                }).catch(() => { e.target.checked = !e.target.checked; alert('Netzwerkfehler.'); });
        });
    });

    // --- JS for Event Chat (if present) ---
    const chatBox = document.getElementById('chat-box');
    if (chatBox) {
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-message-input');
        
        const fetchMessages = () => {
            fetch(`${contextPath}/api/event-chat?eventId=${eventId}`)
                .then(res => res.ok ? res.json() : Promise.reject(`HTTP error! status: ${res.status}`))
                .then(messages => {
                    chatBox.innerHTML = messages.length > 0 ? messages.map(msg =>
                        `<p style="margin-bottom:0.25rem; ${msg.userId == currentUserId ? 'text-align:right;' : ''}">
                            <strong ${msg.userId == currentUserId ? 'style="color:var(--primary-color);"' : ''}>${msg.username}:</strong> ${msg.messageText}
                         </p>`
                    ).join('') : '<p style="color:var(--text-muted-color);">Noch keine Nachrichten.</p>';
                    chatBox.scrollTop = chatBox.scrollHeight;
                }).catch(error => console.error("Error fetching chat messages:", error));
        };
        
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) {
                const formData = new URLSearchParams({ eventId: eventId, messageText: message });
                fetch(`${contextPath}/api/event-chat`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formData })
                    .then(res => { if (res.ok) { chatInput.value = ''; fetchMessages(); } else { alert('Nachricht konnte nicht gesendet werden.'); } })
                    .catch(() => alert('Netzwerkfehler beim Senden.'));
            }
        });
        
        setInterval(fetchMessages, 3000);
        fetchMessages();
    }
});
</script>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\events.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  events.jsp
  
  This is the main event listing page for a regular user. It displays a list
  of all upcoming events for which the user is qualified. For each event, it
  shows the user's specific status (e.g., "Zugewiesen", "Angemeldet", "Offen")
  and provides appropriate actions (like "Anmelden" or "Abmelden"). It now
  includes client-side sorting and filtering.
  
  - It is served by: EventServlet.
  - It submits to: EventActionServlet.
  - Expected attributes:
    - 'events' (List<de.technikteam.model.Event>): A list of events relevant to the user.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Veranstaltungen" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Anstehende Veranstaltungen</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter" placeholder="Events filtern..."
			style="width: 100%;" aria-label="Events filtern">
	</div>
</div>


<c:if test="${empty events}">
	<div class="card">
		<p>Für dich stehen derzeit keine Veranstaltungen an, für die du
			qualifiziert bist.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="event" items="${events}">
		<div class="list-item-card"
			data-searchable-content="${event.name} ${event.userAttendanceStatus}">
			<h3 class="card-title">
				<a
					href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a>
			</h3>
			<div class="card-row">
				<span>Datum:</span> <span>${event.formattedEventDateTimeRange}</span>
			</div>
			<div class="card-row">
				<span>Dein Status:</span> <span> <c:choose>
						<c:when test="${event.userAttendanceStatus == 'ZUGEWIESEN'}">
							<strong class="text-success">Zugewiesen</strong>
						</c:when>
						<c:when test="${event.userAttendanceStatus == 'ANGEMELDET'}">
							<span class="text-success">Angemeldet</span>
						</c:when>
						<c:when test="${event.userAttendanceStatus == 'ABGEMELDET'}">
							<span class="text-danger">Abgemeldet</span>
						</c:when>
						<c:otherwise>Offen</c:otherwise>
					</c:choose>
				</span>
			</div>
			<c:if test="${event.userAttendanceStatus != 'ZUGEWIESEN'}">
				<div class="card-actions">
					<form action="${pageContext.request.contextPath}/event-action"
						method="post" style="display: flex; gap: 0.5rem;">
						<input type="hidden" name="eventId" value="${event.id}">
						<c:if
							test="${event.userAttendanceStatus == 'OFFEN' or event.userAttendanceStatus == 'ABGEMELDET'}">
							<button type="submit" name="action" value="signup"
								class="btn btn-small btn-success">Anmelden</button>
						</c:if>
						<c:if test="${event.userAttendanceStatus == 'ANGEMELDET'}">
							<button type="submit" name="action" value="signoff"
								class="btn btn-small btn-danger">Abmelden</button>
						</c:if>
					</form>
				</div>
			</c:if>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Veranstaltung</th>
				<th class="sortable" data-sort-type="string">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Dein Status</th>
				<th>Aktion</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="event" items="${events}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a></td>
					<td>${event.formattedEventDateTimeRange}</td>
					<td><c:choose>
							<c:when test="${event.userAttendanceStatus == 'ZUGEWIESEN'}">
								<strong class="text-success">Zugewiesen</strong>
							</c:when>
							<c:when test="${event.userAttendanceStatus == 'ANGEMELDET'}">
								<span class="text-success">Angemeldet</span>
							</c:when>
							<c:when test="${event.userAttendanceStatus == 'ABGEMELDET'}">
								<span class="text-danger">Abgemeldet</span>
							</c:when>
							<c:otherwise>Offen</c:otherwise>
						</c:choose></td>
					<td><c:if test="${event.userAttendanceStatus != 'ZUGEWIESEN'}">
							<form action="${pageContext.request.contextPath}/event-action"
								method="post" style="display: flex; gap: 0.5rem;">
								<input type="hidden" name="eventId" value="${event.id}">
								<c:if
									test="${event.userAttendanceStatus == 'OFFEN' or event.userAttendanceStatus == 'ABGEMELDET'}">
									<button type="submit" name="action" value="signup"
										class="btn btn-small btn-success">Anmelden</button>
								</c:if>
								<c:if test="${event.userAttendanceStatus == 'ANGEMELDET'}">
									<button type="submit" name="action" value="signoff"
										class="btn btn-small btn-danger">Abmelden</button>
								</c:if>
							</form>
						</c:if></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\home.jsp
========================================================================


<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  home.jsp
  
  This is the main landing page (dashboard) for a logged-in user. It provides
  a welcome message and a quick overview of their upcoming commitments,
  displaying the next few events and meetings they are eligible for or
  signed up for.
  
  - It is served by: HomeServlet.
  - Expected attributes:
    - 'upcomingEvents' (List<de.technikteam.model.Event>): A list of the next 3 events.
    - 'upcomingMeetings' (List<de.technikteam.model.Meeting>): A list of the next 3 meetings.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Home" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Willkommen zurück, ${sessionScope.user.username}!</h1>

<div class="dashboard-grid">
	<div class="card">
		<h2 class="card-title">Deine nächsten 3 Veranstaltungen</h2>
		<c:choose>
			<c:when test="${not empty upcomingEvents}">
				<ul style="list-style: none; padding-left: 0;">
					<c:forEach var="event" items="${upcomingEvents}" varStatus="loop">
						<li
							style="padding: 0.5rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
							<a
							href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a>
							<br> <small>${event.formattedEventDateTimeRange}</small>
						</li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Keine anstehenden Veranstaltungen.</p>
			</c:otherwise>
		</c:choose>
	</div>
	<div class="card">
		<h2 class="card-title">Deine nächsten 3 Lehrgänge/Meetings</h2>
		<c:choose>
			<c:when test="${not empty upcomingMeetings}">
				<ul style="list-style: none; padding-left: 0;">
					<c:forEach var="meeting" items="${upcomingMeetings}"
						varStatus="loop">
						<li
							style="padding: 0.5rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
							<a
							href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}">${meeting.name}</a>
							<br> <small>${meeting.formattedMeetingDateTimeRange}</small>
						</li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Keine anstehenden Lehrgänge.</p>
			</c:otherwise>
		</c:choose>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\lager.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  lager.jsp
  
  This is the main inventory page for all users. It displays a list of all
  storage items, grouped by their physical location. It provides actions for
  users to check items in or out via a modal dialog. It also features a
  lightbox for viewing item images and client-side filtering and sorting.
  
  - It is served by: StorageServlet.
  - It submits to: StorageTransactionServlet (from the modal).
  - Expected attributes:
    - 'storageData' (Map<String, List<de.technikteam.model.StorageItem>>): Items grouped by location.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Lager" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Lagerübersicht</h1>
<p>Hier finden Sie eine Übersicht aller erfassten Artikel im Lager.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i> ${sessionScope.successMessage}
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		${sessionScope.errorMessage}
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter"
			placeholder="Alle Artikel filtern..." style="width: 100%;"
			aria-label="Lager filtern">
	</div>
</div>

<c:if test="${empty storageData}">
	<div class="card">
		<p>Derzeit sind keine Artikel im Lager erfasst.</p>
	</div>
</c:if>

<c:forEach var="locationEntry" items="${storageData}">
	<h2>
		<i class="fas fa-map-marker-alt"></i> ${locationEntry.key}
	</h2>

	<!-- MOBILE LAYOUT -->
	<div class="mobile-card-list searchable-list">
		<c:forEach var="item" items="${locationEntry.value}">
			<div class="list-item-card"
				data-searchable-content="${item.name} ${item.cabinet} ${item.shelf}">
				<h3 class="card-title">${item.name}</h3>
				<div class="card-row">
					<span>Anzahl:</span> <span>${item.quantity} <span
						class="status-badge ${item.availabilityStatusCssClass}">${item.availabilityStatus}</span></span>
				</div>
				<div class="card-row">
					<span>Ort:</span> <span>${item.cabinet} / ${item.shelf}</span>
				</div>
				<div class="card-actions">
					<button class="btn btn-small btn-success transaction-btn"
						data-item-id="${item.id}" data-item-name="${item.name}"
						data-type="checkin">
						<i class="fas fa-plus"></i> Einräumen
					</button>
					<button class="btn btn-small btn-danger transaction-btn"
						data-item-id="${item.id}" data-item-name="${item.name}"
						data-type="checkout">
						<i class="fas fa-minus"></i> Entnehmen
					</button>
					<c:if test="${not empty item.imagePath}">
						<a href="#" class="btn btn-small btn-secondary lightbox-trigger"
							data-src="${pageContext.request.contextPath}/image?file=${item.imagePath}"><i
							class="fas fa-image"></i> Bild</a>
					</c:if>
				</div>
			</div>
		</c:forEach>
	</div>

	<!-- DESKTOP LAYOUT -->
	<div class="desktop-table-wrapper">
		<table class="desktop-table sortable-table searchable-table">
			<thead>
				<tr>
					<th class="sortable" data-sort-type="string">Gerät</th>
					<th class="sortable" data-sort-type="string">Schrank</th>
					<th class="sortable" data-sort-type="string">Regal</th>
					<th class="sortable" data-sort-type="number">Anzahl</th>
					<th class="sortable" data-sort-type="string">Status</th>
					<th>Bild</th>
					<th>Aktion</th>
				</tr>
			</thead>
			<tbody>
				<c:forEach var="item" items="${locationEntry.value}">
					<tr>
						<td>${item.name}</td>
						<td>${item.cabinet}</td>
						<td>${item.shelf}</td>
						<td>${item.quantity}</td>
						<td><span
							class="status-badge ${item.availabilityStatusCssClass}">${item.availabilityStatus}</span></td>
						<td><c:if test="${not empty item.imagePath}">
								<a href="#" class="lightbox-trigger"
									data-src="${pageContext.request.contextPath}/image?file=${item.imagePath}">
									<img
									src="${pageContext.request.contextPath}/image?file=${item.imagePath}"
									alt="${item.name}" width="60"
									style="border-radius: 4px; vertical-align: middle; cursor: pointer; aspect-ratio: 4/3; object-fit: cover;">
								</a>
							</c:if></td>
						<td style="display: flex; gap: 0.5rem;">
							<button class="btn btn-small btn-success transaction-btn"
								data-item-id="${item.id}" data-item-name="${item.name}"
								data-type="checkin">
								<i class="fas fa-plus"></i> Einräumen
							</button>
							<button class="btn btn-small btn-danger transaction-btn"
								data-item-id="${item.id}" data-item-name="${item.name}"
								data-type="checkout">
								<i class="fas fa-minus"></i> Entnehmen
							</button>
						</td>
					</tr>
				</c:forEach>
			</tbody>
		</table>
	</div>
</c:forEach>

<!-- Lightbox structure, placed once at the end of the page -->
<div class="lightbox-overlay" id="lightbox">
	<img src="" alt="Vergrößerte Ansicht">
</div>

<!-- Transaction Modal -->
<div class="modal-overlay" id="transaction-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3 id="transaction-modal-title">Artikel bewegen</h3>
		<form action="${pageContext.request.contextPath}/storage-transaction"
			method="post">
			<input type="hidden" name="itemId" id="transaction-item-id">
			<input type="hidden" name="type" id="transaction-type"> <input
				type="hidden" name="redirectUrl"
				value="${pageContext.request.contextPath}${requestScope['jakarta.servlet.forward.request_uri']}">
			<div class="form-group">
				<label for="transaction-quantity">Anzahl</label> <input
					type="number" name="quantity" id="transaction-quantity" required
					min="1" value="1">
			</div>
			<div class="form-group">
				<label for="transaction-notes">Notiz (optional)</label>
				<textarea name="notes" id="transaction-notes" rows="2"
					placeholder="z.B. für Event X, Reparatur, etc."></textarea>
			</div>
			<button type="submit" class="btn">Bestätigen</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    // Lightbox Logic
    const lightbox = document.getElementById('lightbox');
    if (lightbox) {
        const lightboxImage = lightbox.querySelector('img');
        document.querySelectorAll('.lightbox-trigger').forEach(trigger => {
            trigger.addEventListener('click', (e) => {
                e.preventDefault();
                lightboxImage.setAttribute('src', trigger.dataset.src);
                lightbox.classList.add('active');
            });
        });
        lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
    }

    // Transaction Modal Logic
    const transactionModal = document.getElementById('transaction-modal');
    if(transactionModal) {
        const modalTitle = document.getElementById('transaction-modal-title');
        const modalItemId = document.getElementById('transaction-item-id');
        const modalType = document.getElementById('transaction-type');
        const closeModalBtn = transactionModal.querySelector('.modal-close-btn');

        const openModal = (btn) => {
            const type = btn.dataset.type;
            const actionText = type === 'checkin' ? 'Einräumen' : 'Entnehmen';
            modalTitle.textContent = `${btn.dataset.itemName} ${actionText}`;
            modalItemId.value = btn.dataset.itemId;
            modalType.value = type;
            transactionModal.classList.add('active');
        };

        const closeModal = () => transactionModal.classList.remove('active');

        document.querySelectorAll('.transaction-btn').forEach(btn => {
            btn.addEventListener('click', () => openModal(btn));
        });

        closeModalBtn.addEventListener('click', closeModal);
        transactionModal.addEventListener('click', e => {
            if (e.target === transactionModal) closeModal();
        });
    }
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\lehrgaenge.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  lehrgaenge.jsp
  
  This is the main page for users to view and interact with upcoming course
  meetings. It displays a list of all scheduled meetings, showing the user's
  current attendance status for each. It provides buttons for the user to
  sign up for or sign off from each meeting. Now includes client-side
  filtering and sorting.
  
  - It is served by: MeetingServlet.
  - It submits to: MeetingActionServlet.
  - Expected attributes:
    - 'meetings' (List<de.technikteam.model.Meeting>): A list of all upcoming meetings.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Lehrgänge" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Anstehende Lehrgänge & Meetings</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter"
			placeholder="Lehrgänge filtern..." style="width: 100%;"
			aria-label="Lehrgänge filtern">
	</div>
</div>

<c:if test="${empty meetings}">
	<div class="card">
		<p>Derzeit stehen keine Lehrgänge oder Meetings an.</p>
	</div>
</c:if>

<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="meeting" items="${meetings}">
		<div class="list-item-card"
			data-searchable-content="${meeting.name} ${meeting.parentCourseName} ${meeting.userAttendanceStatus}">
			<h3 class="card-title">
				<a
					href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}">${meeting.name}</a>
			</h3>
			<div class="card-row">
				<span>Gehört zu:</span> <span>${meeting.parentCourseName}</span>
			</div>
			<div class="card-row">
				<span>Dein Status:</span> <span> <c:choose>
						<c:when test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
							<span class="text-success">Angemeldet</span>
						</c:when>
						<c:when test="${meeting.userAttendanceStatus == 'ABGEMELDET'}">
							<span class="text-danger">Abgemeldet</span>
						</c:when>
						<c:otherwise>Offen</c:otherwise>
					</c:choose>
				</span>
			</div>
			<div class="card-actions">
				<form action="${pageContext.request.contextPath}/meeting-action"
					method="post" style="display: flex; gap: 0.5rem;">
					<input type="hidden" name="meetingId" value="${meeting.id}">
					<c:if test="${meeting.userAttendanceStatus != 'ANGEMELDET'}">
						<button type="submit" name="action" value="signup"
							class="btn btn-small btn-success">Anmelden</button>
					</c:if>
					<c:if test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
						<button type="submit" name="action" value="signoff"
							class="btn btn-small btn-danger">Abmelden</button>
					</c:if>
				</form>
			</div>
		</div>
	</c:forEach>
</div>

<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Meeting</th>
				<th class="sortable" data-sort-type="string">Gehört zu Kurs</th>
				<th class="sortable" data-sort-type="string">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Dein Status</th>
				<th>Aktion</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="meeting" items="${meetings}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}">${meeting.name}</a></td>
					<td>${meeting.parentCourseName}</td>
					<td>${meeting.formattedMeetingDateTimeRange}</td>
					<td><c:choose>
							<c:when test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
								<span class="text-success">Angemeldet</span>
							</c:when>
							<c:when test="${meeting.userAttendanceStatus == 'ABGEMELDET'}">
								<span class="text-danger">Abgemeldet</span>
							</c:when>
							<c:otherwise>Offen</c:otherwise>
						</c:choose></td>
					<td>
						<form action="${pageContext.request.contextPath}/meeting-action"
							method="post" style="display: flex; gap: 0.5rem;">
							<input type="hidden" name="meetingId" value="${meeting.id}">
							<c:if test="${meeting.userAttendanceStatus != 'ANGEMELDET'}">
								<button type="submit" name="action" value="signup"
									class="btn btn-small btn-success">Anmelden</button>
							</c:if>
							<c:if test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
								<button type="submit" name="action" value="signoff"
									class="btn btn-small btn-danger">Abmelden</button>
							</c:if>
						</form>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\login.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

<%--
  login.jsp
  
  This is the main login page for the application. It provides a simple form
  for users to enter their username and password. The form is submitted to
  the LoginServlet for authentication.
  
  - It is served by: LoginServlet (doGet).
  - It can also be the welcome-file defined in web.xml.
  - Expected attributes:
    - 'errorMessage' (String): An error message to display if login fails (optional).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
    <c:param name="title" value="Anmeldung" />
</c:import>

<div class="login-wrapper">
    <div class="login-box">
        <h1>Willkommen zurück</h1>

        <c:if test="${not empty errorMessage}">
            <p class="error-message">${errorMessage}</p>
        </c:if>

        <form action="${pageContext.request.contextPath}/login" method="post">
            <div class="form-group">
                <label for="username">Benutzername</label>
                <input type="text" id="username" name="username" required autocomplete="username" autofocus>
            </div>
            <div class="form-group">
                <label for="password">Passwort</label>
                <input type="password" id="password" name="password" required autocomplete="current-password">
            </div>
            <button type="submit" class="btn" style="width: 100%;">Anmelden</button>
        </form>
    </div>
</div>

<%-- The footer is omitted on the login page for a cleaner, focused look. --%>
</body>
</html>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\logout.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  logout.jsp
  
  This is a confirmation page shown to the user immediately after they have
  logged out. It displays a personalized message and uses JavaScript to
  automatically redirect the user to the login page after a short delay.
  
  - It is served by: LogoutServlet (via redirect).
  - Expected parameters:
    - 'username' (String): The name of the user who just logged out.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Logout" />
</c:import>

<div style="text-align: center; margin-top: 5rem; padding: 2rem;">
	<h1>
		<c:out value="${not empty param.username ? param.username : 'Du'}" />
		, du wurdest erfolgreich ausgeloggt!
	</h1>
	<p>Du wirst in 5 Sekunden automatisch zur Login-Seite
		weitergeleitet.</p>
	<p>
		<a href="${pageContext.request.contextPath}/login">Jetzt zur
			Login-Seite</a>
	</p>
</div>

<script>
	setTimeout(function() {
		// Use the contextPath to build the URL safely, making it robust
		// even if the application is deployed under a different name.
		window.location.href = "${pageContext.request.contextPath}/login";
	}, 5000); // 5000 milliseconds = 5 seconds
</script>

</body>
</html>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\meetingDetails.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  meetingDetails.jsp
  
  This is the public-facing detail page for a single course meeting.
  It displays the meeting's name, parent course, date/time, leader,
  description, and a list of any file attachments visible to the current user.
  
  - It is served by: MeetingDetailsServlet.
  - Expected attributes:
    - 'meeting' (de.technikteam.model.Meeting): The meeting being displayed.
    - 'attachments' (List<MeetingAttachment>): A list of attachments for the meeting.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Meeting-Details" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<div class="details-container" style="max-width: 800px; margin: 0 auto;">
	<h1>${meeting.name}</h1>
	<p
		style="color: var(--text-muted-color); margin-top: -1rem; margin-bottom: 2rem;">
		Teil des Lehrgangs: <strong>${meeting.parentCourseName}</strong>
	</p>

	<div class="card">
		<h2>Details</h2>
		<ul class="details-list">
			<li><strong>Termin:</strong>
				${meeting.formattedMeetingDateTimeRange}</li>
			<li><strong>Leitung:</strong> <c:choose>
					<c:when test="${not empty meeting.leader}">${meeting.leader}</c:when>
					<c:otherwise>N/A</c:otherwise>
				</c:choose></li>
		</ul>
	</div>

	<div class="card">
		<h2>Beschreibung</h2>
		<p>
			<c:choose>
				<c:when test="${not empty meeting.description}">${meeting.description}</c:when>
				<c:otherwise>Keine Beschreibung vorhanden.</c:otherwise>
			</c:choose>
		</p>
	</div>

	<div class="card">
		<h2>Anhänge</h2>
		<c:choose>
			<c:when test="${not empty attachments}">
				<ul class="details-list">
					<c:forEach var="att" items="${attachments}">
						<li><a
							href="${pageContext.request.contextPath}/download?file=${att.filepath}">${att.filename}</a>
							<c:if test="${sessionScope.user.role == 'ADMIN'}">
								<small
									style="color: var(--text-muted-color); margin-left: 1rem;">(Sichtbar
									für: ${att.requiredRole})</small>
							</c:if></li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Für dieses Meeting gibt es keine Anhänge.</p>
			</c:otherwise>
		</c:choose>
	</div>

	<a href="${pageContext.request.contextPath}/lehrgaenge" class="btn"
		style="margin-top: 1rem;"> &laquo; Zurück zur Übersicht </a>
</div>

<style>
.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.details-list li:last-child {
	border-bottom: none;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\passwort.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  passwort.jsp
  
  This page provides a form for a logged-in user to change their own password.
  It requires them to enter their current password for verification and to
  confirm their new password.
  
  - It is served by: PasswordServlet (doGet).
  - It submits to: PasswordServlet (doPost).
  - Expected attributes:
    - 'successMessage' (String): Message on successful change (optional).
    - 'errorMessage' (String): Message on validation failure (optional).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Passwort ändern" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<div class="form-center-wrapper">
	<div class="card">
		<h1>Passwort ändern</h1>

		<c:if test="${not empty successMessage}">
			<p class="success-message">${successMessage}</p>
		</c:if>
		<c:if test="${not empty errorMessage}">
			<p class="error-message">${errorMessage}</p>
		</c:if>

		<form action="${pageContext.request.contextPath}/passwort"
			method="post">
			<div class="form-group">
				<label for="currentPassword">Aktuelles Passwort</label> <input
					type="password" id="currentPassword" name="currentPassword"
					required autocomplete="current-password">
			</div>
			<div class="form-group">
				<label for="newPassword">Neues Passwort</label> <input
					type="password" id="newPassword" name="newPassword" required
					autocomplete="new-password">
			</div>
			<div class="form-group">
				<label for="confirmPassword">Neues Passwort bestätigen</label> <input
					type="password" id="confirmPassword" name="confirmPassword"
					required autocomplete="new-password">
			</div>
			<button type="submit" class="btn">Passwort speichern</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\storage_item_details.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  storage_item_details.jsp
  
  This is the public-facing detail page for a single inventory item. It is
  designed to be easily accessible, often via a QR code scan. It displays the
  item's name, an image if available, and its location details.
  
  - It is served by: StorageItemDetailsServlet.
  - Expected attributes:
    - 'item' (de.technikteam.model.StorageItem): The inventory item to display.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Artikeldetails" />
</c:import>
<c:import url="/WEB-INF/jspf/navigation.jspf" />

<h1>Artikeldetails</h1>
<p>Dies ist die Detailansicht für einen Artikel aus dem Lager, oft
	aufgerufen über einen QR-Code.</p>

<div class="card" style="max-width: 600px; margin: 1rem auto;">
	<h2 class="card-title">${item.name}</h2>

	<c:if test="${not empty item.imagePath}">
		<img
			src="${pageContext.request.contextPath}/image?file=${item.imagePath}"
			alt="Bild von ${item.name}"
			style="width: 100%; max-width: 400px; height: auto; border-radius: 8px; margin: 0 auto 1.5rem; display: block;">
	</c:if>

	<ul class="details-list">
		<li><strong>Aktuelle Anzahl:</strong> ${item.quantity}</li>
		<li><strong>Ort:</strong> ${item.location}</li>
		<li><strong>Schrank:</strong> ${not empty item.cabinet ? item.cabinet : 'N/A'}</li>
		<li><strong>Regal:</strong> ${not empty item.shelf ? item.shelf : 'N/A'}</li>
		<li><strong>Fach/Kiste:</strong> ${not empty item.compartment ? item.compartment : 'N/A'}</li>
	</ul>

	<div style="margin-top: 2rem;">
		<a href="${pageContext.request.contextPath}/lager" class="btn">Zurück
			zur Lagerübersicht</a>
	</div>
</div>

<style>
.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
}

.details-list li:last-child {
	border-bottom: none;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />
