
========================================================================
FILE: pom.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">

<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.1</version>
		<relativePath /> 
</parent>

<groupId>de.technikteam</groupId>
<artifactId>TechnikTeam</artifactId>
<version>2.0.0-SNAPSHOT</version>
<packaging>jar</packaging>

<name>TechnikTeam</name>

<properties>
    <java.version>21</java.version>
    <springdoc-openapi.version>2.5.0</springdoc-openapi.version>
    <jjwt.version>0.12.5</jjwt.version>
    <ical4j.version>3.2.4</ical4j.version>
    <diffutils.version>1.3.0</diffutils.version>
    <!-- REMOVED <webauthn.version>2.2.0</webauthn.version> -->
    <commons-io.version>2.16.1</commons-io.version>
    <owasp-java-html-sanitizer.version>20230925.1</owasp-java-html-sanitizer.version>
    <bucket4j.version>8.9.0</bucket4j.version>
</properties>

<dependencies>

    <!-- Spring Boot Starters -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-log4j2</artifactId>
    </dependency>

    <!-- Database & Migrations -->
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-mysql</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mariadb.jdbc</groupId>
        <artifactId>mariadb-java-client</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Security & Authentication -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>${jjwt.version}</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>${jjwt.version}</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>${jjwt.version}</version>
        <scope>runtime</scope>
    </dependency>
    <!-- REMOVED YUBICO DEPENDENCY BLOCK -->
    <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>32.1.2-jre</version>
    </dependency>
    <dependency>
        <groupId>com.googlecode.java-diff-utils</groupId>
        <artifactId>diffutils</artifactId>
        <version>${diffutils.version}</version>
    </dependency>
    <dependency>
        <groupId>com.google.code.gson</groupId>
        <artifactId>gson</artifactId>
    </dependency>
	    <dependency>
	    <groupId>com.googlecode.owasp-java-html-sanitizer</groupId>
	    <artifactId>owasp-java-html-sanitizer</artifactId>
	    <version>20240325.1</version> 
	</dependency>
    <dependency>
        <groupId>com.bucket4j</groupId>
        <artifactId>bucket4j-core</artifactId>
        <version>${bucket4j.version}</version>
    </dependency>

    <!-- API Documentation -->
    <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        <version>${springdoc-openapi.version}</version>
    </dependency>

    <!-- Utilities -->
    <dependency>
	    <groupId>org.mnode.ical4j</groupId>
	    <artifactId>ical4j</artifactId>
	    <version>${ical4j.version}</version>
	</dependency>
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>${commons-io.version}</version>
    </dependency>
    <dependency>
	    <groupId>org.apache.logging.log4j</groupId>
	    <artifactId>log4j-layout-template-json</artifactId>
	</dependency>

    <!-- Testing -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        
        <plugin>
		    <groupId>org.flywaydb</groupId>
		    <artifactId>flyway-maven-plugin</artifactId>
		    <configuration>
		        <configFile>flyway.conf</configFile>
		    </configuration>
		</plugin>
        
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <source>${java.version}</source>
                <target>${java.version}</target>
            </configuration>
        </plugin>
</plugins>
</build>
</project>
========================================================================
FILE: README.md
========================================================================

# TechnikTeam - School Event & Crew Management System v2.0

![Spring Boot](https://img.shields.io/badge/Spring_Boot-3.3+-6DB33F?style=for-the-badge&logo=spring&logoColor=white)
![React](https://img.shields.io/badge/React-18+-61DAFB?style=for-the-badge&logo=react&logoColor=black)
![Vite](https://img.shields.io/badge/Vite-5+-646CFF?style=for-the-badge&logo=vite&logoColor=white)
![Java](https://img.shields.io/badge/Java-21+-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![MySQL](https://img.shields.io/badge/MySQL-8.0-4479A1?style=for-the-badge&logo=mysql&logoColor=white)

A comprehensive web application designed to manage a school's event technology crew ("Technik-Team"). The platform provides tools for event planning, user management, inventory tracking, and skill development, all within a granular, permission-based access control system. This version is a complete rewrite using a modern Spring Boot REST API and a React single-page application frontend.

## Key Features

### 👑 Admin-Specific Features
*   **Central Dashboard**: At-a-glance view of key metrics like upcoming events, low-stock items, and event trends.
*   **User Management**: Full CRUD functionality for user accounts with a flexible permission-based system.
*   **Event Management**: Create events with skill requirements, reserve inventory, upload files, and manage the event lifecycle.
*   **Training & Qualification**: Define course templates, schedule meetings, and track user qualifications with an interactive matrix.
*   **Inventory Management**: Full CRUD for all inventory items, including location details, quantity, images, and maintenance logs.
*   **Kit Management**: Create reusable "kits" or "cases" of equipment with printable packing lists via QR codes.
*   **File & Document Hub**: Manage file categories and upload documents with role-based access control.
*   **Feedback Kanban Board**: Manage user feedback and suggestions through a visual board.
*   **Audit Trail**: A detailed log of all administrative actions for accountability.
*   **System Monitoring**: View live server statistics, including CPU, memory, and disk usage.

### 👥 User-Facing Features
*   **Personalized Homepage**: A dashboard showing upcoming events, assigned tasks, and training meetings.
*   **Event System**: View and sign up for upcoming events, and access real-time tools like chat and task lists for "running" events.
*   **Training Hub**: View and sign up for upcoming course meetings to gain new qualifications.
*   **Inventory Browser**: Browse the entire equipment inventory and view item details.
*   **Profile Management**: Update personal details, change passwords, and manage passwordless login with Passkeys/WebAuthn.
*   **Calendar**: View all upcoming events and meetings in a list or calendar view, with an option to subscribe via an iCal feed.

## Technology Stack

*   **Backend**: Spring Boot 3.3, Java 21
    *   **Security**: Spring Security 6 with JWT Authentication via HttpOnly Cookies
    *   **Database**: Spring Data JDBC, MariaDB/MySQL
    *   **Migrations**: Flyway
    *   **Real-time**: Spring WebSocket
*   **Frontend**: React 18, Vite 5
    *   **Routing**: React Router
    *   **State Management**: Zustand
    *   **Styling**: Plain CSS with custom properties for theming
*   **API Documentation**: Springdoc OpenAPI (Swagger UI)
*   **Build Tool**: Apache Maven

## Setup and Installation

Follow these steps to get a local instance of the application running for development.

### 1. Prerequisites
*   Java Development Kit (JDK) 21 or higher
*   Apache Maven 3.8+
*   Node.js 20+ (with npm)
*   MySQL Server 8.0+ or MariaDB 10.6+

### 2. Database Setup
1.  Create a new database in your database server:
    ```sql
    CREATE DATABASE technik_team_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```
2.  Create a dedicated database user with privileges on this database.

### 3. Backend Configuration & Setup
1.  Navigate to the project's root directory.
2.  Open `src/main/resources/application.properties`.
3.  Update the `spring.datasource.*` properties to match your database connection details.
4.  Set a strong, unique secret for `jwt.secret`. This is critical for security. It **must** be at least 32 characters long.
5.  Set the `upload.directory` to an absolute path on your local machine. This directory must exist and be writable by the application.
6.  The application uses Flyway for database migrations. The necessary tables will be created automatically when the application starts for the first time.

**First-time Setup Note:** The application includes a component (`InitialAdminCreator.java`) that checks if an 'admin' user exists on first startup. If not, it creates a default `admin` user with full permissions and a strong, random password. This password is printed to the console **only once** on the very first startup. Please copy this password immediately and store it securely. Note that a Flyway migration (`V22`) is included to remove any legacy, insecurely created admin users from previous development versions.

### 4. Backend Launch
1.  From the project's root directory, run the Spring Boot application using Maven:
    ```shell
    mvn spring-boot:run
    ```
2.  The backend server will start on `http://localhost:8080`.

### 5. Frontend Setup & Launch
1.  In a separate terminal, navigate to the `frontend` directory:
    ```shell
    cd frontend
    ```
2.  Install the required Node.js dependencies:
    ```shell
    npm install
    ```
3.  Start the Vite development server:
    ```shell
    npm run dev
    ```
4.  The frontend will be available at `http://localhost:3000`. The Vite server is configured to proxy all API (`/api`) and WebSocket (`/ws`) requests to the Spring Boot backend running on port 8080.

## Usage

Once both servers are running, open `http://localhost:3000` in your browser.

*   **API Documentation**: Full, interactive API documentation is available via Swagger UI at `http://localhost:8080/TechnikTeam/swagger-ui.html` once the backend is running.
========================================================================
FILE: frontend\eslint.config.js
========================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

========================================================================
FILE: frontend\index.html
========================================================================

<!doctype html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TechnikTeam</title>
<!-- Link to Font Awesome (from original project) -->
<link rel="stylesheet"
	href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<!-- Link to our application's stylesheets -->
<link rel="stylesheet" href="/style1.css">
<link rel="stylesheet" href="/style2.css">
<link rel="stylesheet" href="/style3.css">
<link rel="stylesheet" href="/style4.css">
<script>
	// This script runs immediately to prevent a "flash" of the wrong theme.
	const savedTheme = localStorage.getItem('theme') || 'light';
	document.documentElement.setAttribute('data-theme', savedTheme);
</script>
</head>
<body>
	<div id="root"></div>
	<script type="module" src="/src/main.jsx"></script>
</body>
</html>
========================================================================
FILE: frontend\README.md
========================================================================

# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

========================================================================
FILE: frontend\vite.config.js
========================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { fileURLToPath, URL } from 'url'

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [react()],
	server: {
		port: 3000,
		proxy: {
			// Proxy all API requests starting with /api to the Spring Boot backend
			'/api': {
				target: 'http://localhost:8080/TechnikTeam',
				changeOrigin: true,
				secure: false,
			},
			// Proxy all WebSocket connections to the Spring Boot backend
			'/ws': {
				target: 'ws://localhost:8080/TechnikTeam',
				ws: true, // Enable WebSocket proxying
			},
		},
	},
	resolve: {
		alias: {
			'@': fileURLToPath(new URL('./src', import.meta.url))
		}
	}
})
========================================================================
FILE: frontend\public\style1.css
========================================================================

/* FILE: style1.css - Core, Base, and Layout Styles */

/* --- 1. THEME & COLOR PALETTE --- */
:root {
	--primary-color: #007bff;
	--primary-color-hover: #0056b3;
	--primary-color-light: rgba(0, 123, 255, 0.1);
	--bg-color: #f8f9fa;
	--surface-color: #ffffff;
	--text-color: #212529;
	--heading-color: #002B5B;
	/* Dark, rich blue for headings */
	--text-muted-color: #6c757d;
	--border-color: #dee2e6;
	--success-color: #28a745;
	--danger-color: #dc3545;
	--warning-color: #ffc107;
	--info-color: #0dcaf0;
	--shadow-sm: 0 1px 2px 0 rgb(0 0 0/ 0.05);
	--shadow-md: 0 4px 6px -1px rgb(0 0 0/ 0.1), 0 2px 4px -2px rgb(0 0 0/ 0.1);
	--shadow-lg: 0 10px 15px -3px rgb(0 0 0/ 0.1), 0 4px 6px -4px rgb(0 0 0/ 0.1);
	--sidebar-width: 260px;
	--header-height: 64px;
	--border-radius: 8px;
	--sidebar-bg: var(--surface-color);
	--sidebar-border: var(--border-color);
	--sidebar-text-color: #343a40;
	--sidebar-text-muted: #6c757d;
	--sidebar-icon-color: #6c757d;
	--sidebar-hover-bg: #e9ecef;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
    /* Terminal Colors */
    --terminal-bg: #010409;
    --terminal-header-bg: #0d1117;
    --terminal-border: #30363d;
    --terminal-text: #c9d1d9;
    --terminal-text-muted: #8b949e;
    --terminal-prompt: #58a6ff;
}

[data-theme="dark"] {
	--primary-color: #58a6ff;
	--primary-color-hover: #80b6ff;
	--primary-color-light: rgba(88, 166, 255, 0.15);
	--bg-color: #0d1117;
	--surface-color: #161b22;
	--text-color: #c9d1d9;
	--heading-color: var(--primary-color);
	--text-muted-color: #8b949e;
	--border-color: #30363d;
	--success-color: #56d364;
	--danger-color: #f87171;
	--warning-color: #f0b72f;
	--info-color: #67d4ed;
	--sidebar-bg: #161b22;
	--sidebar-border: #30363d;
	--sidebar-text-color: #c9d1d9;
	--sidebar-text-muted: #8b949e;
	--sidebar-icon-color: #8b949e;
	--sidebar-hover-bg: #21262d;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
    /* Terminal Colors remain dark, as it's a specific component style */
}

[data-theme="light"] {
    --terminal-bg: #ffffff;
    --terminal-header-bg: #f8f9fa;
    --terminal-border: #dee2e6;
    --terminal-text: #212529;
    --terminal-text-muted: #6c757d;
    --terminal-prompt: #0056b3;
}


/* --- 2. BASE & TYPOGRAPHY --- */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html,
body {
	height: 100%;
}

html {
	scroll-behavior: smooth;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		"Helvetica Neue", Arial, sans-serif;
	background-color: var(--bg-color);
	color: var(--text-color);
	line-height: 1.6;
	transition: background-color 0.3s, color 0.3s;
}

h1,
h2,
h3,
h4 {
	color: var(--heading-color);
	line-height: 1.3;
}

h1 {
	font-size: clamp(1.8rem, 5vw, 2.2rem);
	font-weight: 700;
	margin-bottom: 1rem;
}

h2 {
	font-size: clamp(1.2rem, 4vw, 1.5rem);
	margin-bottom: 1.25rem;
	padding-bottom: 0.75rem;
	border-bottom: 1px solid var(--border-color);
	font-weight: 600;
}

h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	font-weight: 600;
}

a {
	color: var(--primary-color);
	text-decoration: none;
	transition: color 0.2s;
}

a:hover {
	text-decoration: underline;
	color: var(--primary-color-hover);
}

.text-success {
	color: var(--success-color) !important;
}

.text-danger {
	color: var(--danger-color) !important;
}

/* --- 3. LAYOUT & CONTAINERS --- */
.main-content-wrapper {
	transition: margin-left 0.3s ease-in-out;
	height: 100vh;
	display: flex;
	flex-direction: column;
}

.main-content {
	padding: 1.5rem;
	max-width: 1600px;
	margin-left: auto;
	margin-right: auto;
	width: 100%;
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

/* Add centering for error page content */
.main-content.center-content {
    display: flex;
    justify-content: center;
    align-items: center;
}

.card {
	background: var(--surface-color);
	border-radius: var(--border-radius);
	padding: 1.5rem;
	margin-bottom: 1.5rem;
	box-shadow: var(--shadow-sm);
	border: 1px solid var(--border-color);
	transition: all .3s;
}

.card:hover {
	box-shadow: var(--shadow-md);
}

.card-title {
	border: none;
	padding: 0;
	margin-bottom: 1rem;
}

.dashboard-grid,
.responsive-dashboard-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1.5rem;
}

@media (max-width : 767.98px) {
	.responsive-dashboard-grid {
		grid-template-columns: 1fr;
	}
}
========================================================================
FILE: frontend\public\style2.css
========================================================================

/* FILE: style2.css - Navigation Styles */

/* --- 4. NAVIGATION --- */
.sidebar {
	position: fixed;
	top: 0;
	left: calc(-1 * var(--sidebar-width));
	width: var(--sidebar-width);
	height: 100%;
	background: var(--sidebar-bg);
	border-right: 1px solid var(--sidebar-border);
	z-index: 1010;
	transition: left 0.3s ease-in-out, background-color 0.3s, border-color
		0.3s;
	display: flex;
	flex-direction: column;
}

body.nav-open .sidebar {
	left: 0;
	box-shadow: var(--shadow-md);
}

.sidebar-header {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0 1.5rem;
	height: var(--header-height);
	flex-shrink: 0;
}

.sidebar-header .logo {
	font-size: 1.25rem;
	font-weight: 700;
	color: var(--heading-color);
	text-decoration: none;
}

.sidebar-header .logo i {
	color: var(--primary-color);
}

.sidebar-nav {
	list-style: none;
	flex-grow: 1;
	overflow-y: auto;
	padding: 0.5rem 0;
}

.sidebar-nav a {
	display: flex;
	align-items: center;
	gap: 1rem;
	padding: 0.9rem 1.5rem;
	color: var(--sidebar-text-muted);
	font-weight: 500;
	transition: all 0.2s;
	border-left: 4px solid transparent;
	white-space: nowrap;
	text-decoration: none;
}

.sidebar-nav a i.fa-fw {
	width: 20px;
	text-align: center;
	color: var(--sidebar-icon-color);
	transition: color 0.2s;
}

.sidebar-nav a:hover {
	color: var(--text-color);
	background-color: var(--sidebar-hover-bg);
}

.sidebar-nav a:hover i.fa-fw {
	color: var(--primary-color);
}

.sidebar-nav a.active-nav-link {
	color: var(--sidebar-active-text);
	font-weight: 600;
	border-left-color: var(--sidebar-active-border);
	background-color: var(--sidebar-active-bg);
}

.sidebar-nav a.active-nav-link i.fa-fw {
	color: var(--sidebar-active-icon);
}

.sidebar-nav .nav-section-title {
	padding: 1.5rem 1.5rem 0.5rem;
	font-size: 0.8rem;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
}

.user-actions {
	padding: 1rem 1.5rem;
	border-top: 1px solid var(--sidebar-border);
	flex-shrink: 0;
}

.user-info {
	font-weight: 500;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: var(--text-muted-color);
}

.user-info strong {
	color: var(--text-color);
}

.mobile-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	height: var(--header-height);
	background-color: var(--surface-color);
	padding: 0 1rem;
	position: sticky;
	top: 0;
	z-index: 1000;
	border-bottom: 1px solid var(--border-color);
	flex-shrink: 0;
}

.mobile-header-right {
	display: flex;
	align-items: center;
	gap: 1rem;
}

.mobile-nav-toggle {
	background: none;
	border: none;
	cursor: pointer;
	padding: 0.5rem;
	z-index: 1020;
	/* --- STYLE UPDATE --- */
	width: 44px; /* Larger touch target */
	height: 44px; /* Larger touch target */
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

.mobile-nav-toggle .line {
	width: 25px;
	height: 3px;
	/* --- STYLE UPDATE --- */
	background-color: var(--primary-color); /* More visible color */
	margin: 5px 0;
	border-radius: 3px;
	transition: all 0.3s;
}

body.nav-open .mobile-nav-toggle .line-1 {
	transform: rotate(45deg) translate(5px, 6px);
}

body.nav-open .mobile-nav-toggle .line-2 {
	opacity: 0;
}

body.nav-open .mobile-nav-toggle .line-3 {
	transform: rotate(-45deg) translate(5px, -6px);
}

.mobile-logo {
	font-weight: 600;
	font-size: 1.2rem;
	color: var(--heading-color);
	text-decoration: none;
}

.page-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 1005;
}

body.nav-open .page-overlay {
	display: block;
}

@media ( min-width : 992px) {
	.mobile-header, .page-overlay {
		display: none !important;
	}
	.sidebar {
		left: 0;
	}
	.main-content-wrapper {
		margin-left: var(--sidebar-width);
		height: 100vh;
	}
	.sidebar .mobile-only {
		display: none !important;
	}
}

@media ( max-width : 991.98px) {
	.sidebar .desktop-only {
		display: none !important;
	}
	.main-content-wrapper {
		height: 100vh;
	}
}
========================================================================
FILE: frontend\public\style3.css
========================================================================

/* FILE: style3.css - Reusable Component Styles */

/* --- 5. COMPONENTS --- */

/* Buttons */
.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;
	padding: 0.6rem 1.2rem;
	background-color: var(--primary-color);
	color: #fff;
	border: 1px solid transparent;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s;
	text-align: center;
	text-decoration: none;
}

.btn:hover {
	background-color: var(--primary-color-hover);
	color: #fff;
	text-decoration: none;
	transform: translateY(-1px);
}

.btn:disabled {
	background-color: var(--text-muted-color);
	cursor: not-allowed;
	transform: none;
	opacity: 0.65;
}

.btn.btn-danger {
	background-color: var(--danger-color);
}

.btn.btn-danger-outline {
	background-color: transparent;
	border-color: var(--danger-color);
	color: var(--danger-color);
}

.btn.btn-danger-outline:hover {
	background-color: var(--danger-color);
	color: #fff;
}

.btn.btn-success {
	background-color: var(--success-color);
}

.btn.btn-secondary {
	background-color: var(--text-muted-color);
}

.btn-small {
	padding: 0.4rem 0.8rem;
	font-size: 0.875rem;
}

/* Messages & Banners */
.success-message,
.error-message,
.info-message,
.password-reset-alert {
	padding: 1rem;
	margin-bottom: 1.5rem;
	border-radius: var(--border-radius);
	font-weight: 500;
	display: flex;
	align-items: center;
	gap: 0.75rem;
	color: #fff;
}

.success-message {
	background-color: var(--success-color);
}

.error-message {
	background-color: var(--danger-color);
}

.info-message,
.password-reset-alert {
	background-color: var(--info-color);
	color: #000;
}

.password-reset-alert strong {
	cursor: pointer;
	text-decoration: underline;
}

/* Toast Notifications */
.toast {
	position: fixed;
	bottom: 20px;
	right: 20px;
	background-color: var(--surface-color);
	color: var(--text-color);
	padding: 1rem 1.5rem;
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-lg);
	z-index: 9999;
	transform: translateY(150%);
	transition: transform 0.4s ease-in-out, opacity 0.4s;
	border-left: 5px solid var(--primary-color);
	opacity: 0;
	display: flex;
	align-items: center;
}

.toast.clickable:hover {
	box-shadow: var(--shadow-lg), 0 0 0 2px var(--primary-color);
	cursor: pointer;
}

.toast.toast-success {
	border-left-color: var(--success-color);
}

.toast.toast-danger {
	border-left-color: var(--danger-color);
}

.toast.toast-info {
	border-left-color: var(--info-color);
}

.toast.show {
	transform: translateY(0);
	opacity: 1;
}

/* Forms & Inputs */
.form-group {
	margin-bottom: 1.25rem;
}

.form-group label {
	display: block;
	margin-bottom: 0.5rem;
	font-weight: 500;
	color: var(--text-muted-color);
}

.form-group input,
.form-group select,
.form-group textarea {
	width: 100%;
	padding: 0.75rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
	background-color: var(--surface-color);
	color: var(--text-color);
	font-size: 1rem;
	transition: border-color 0.2s, box-shadow 0.2s;
}

fieldset {
	border: none;
	padding: 0;
	margin: 0;
}

[data-theme="dark"] .form-group textarea,
[data-theme="dark"] #editor {
	color: var(--text-color);
	background-color: var(--surface-color);
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 3px var(--primary-color-light);
}

.form-group input[type="file"] {
	background-color: var(--bg-color);
}

.password-input-wrapper {
	position: relative;
	display: flex;
	align-items: center;
}

.password-input-wrapper input {
	padding-right: 40px;
}

.password-toggle-icon {
	position: absolute;
	right: 0;
	top: 0;
	height: 100%;
	width: 40px;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: var(--text-muted-color);
}

.file-size-warning {
	color: var(--danger-color);
	display: none;
	font-size: 0.875rem;
	margin-top: 0.5rem;
}

/* Modals */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.6);
	display: none;
	justify-content: center;
	align-items: center;
	z-index: 2000;
}

.modal-overlay.active {
	display: flex;
}

.modal-content {
	background-color: var(--surface-color);
	padding: 2rem;
	border-radius: var(--border-radius);
	width: 90%;
	max-width: 600px;
	max-height: 90vh;
	overflow-y: auto;
	position: relative;
	box-shadow: var(--shadow-lg);
}

.modal-close-btn {
	position: absolute;
	top: 1rem;
	right: 1rem;
	background: none;
	border: none;
	font-size: 1.5rem;
	cursor: pointer;
	color: var(--text-muted-color);
}

.modal-tabs {
	display: flex;
	border-bottom: 1px solid var(--border-color);
	margin-bottom: 1.5rem;
}

.modal-tab-button {
	padding: 0.75rem 1rem;
	border: none;
	background: none;
	cursor: pointer;
	font-size: 1rem;
	font-weight: 500;
	color: var(--text-muted-color);
	border-bottom: 3px solid transparent;
	transition: all 0.2s;
}

.modal-tab-button.active {
	color: var(--primary-color);
	border-bottom-color: var(--primary-color);
}

.modal-tab-content {
	display: none;
}

.modal-tab-content.active {
	display: block;
}

.dynamic-row {
	display: flex;
	gap: 0.5rem;
	align-items: center;
	margin-bottom: 0.5rem;
	flex-wrap: wrap;
}

.dynamic-row .form-group {
	flex-grow: 1;
	margin-bottom: 0;
}

.dynamic-row .btn-small {
	flex-shrink: 0;
}

/* --- 6. TABLES & RESPONSIVE LISTS --- */
.table-wrapper {
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	overflow-x: auto;
	background-color: var(--surface-color);
}

.data-table {
	width: 100%;
	border-collapse: collapse;
}

.data-table th,
.data-table td {
	padding: 1rem;
	text-align: left;
	border-bottom: 1px solid var(--border-color);
	white-space: nowrap;
	vertical-align: middle;
}

.data-table thead th {
	font-size: 0.8rem;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
	background-color: var(--bg-color);
}

.data-table tbody tr:hover {
	background-color: var(--bg-color);
}

.mobile-card-list {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.list-item-card {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	padding: 1rem;
	box-shadow: var(--shadow-sm);
}

.list-item-card .card-title {
	margin-bottom: 0.5rem;
	font-size: 1.1rem;
	border-bottom: none;
	padding-bottom: 0;
}

.card-row {
	display: flex;
	justify-content: space-between;
	align-items: center;
	font-size: 0.9rem;
	padding: 0.4rem 0;
	border-bottom: 1px solid var(--border-color);
}

.card-row:last-of-type {
	border-bottom: none;
}

.card-actions {
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	gap: 0.5rem;
}

.desktop-table-wrapper {
	display: none;
}

@media (min-width : 992px) {
	.mobile-card-list {
		display: none !important;
	}

	.desktop-table-wrapper {
		display: block !important;
	}
}
========================================================================
FILE: frontend\public\style4.css
========================================================================

/* FILE: style4.css - Page-Specific, Utility, and Complex Component Styles */

/* --- 7. UTILITY & PAGE-SPECIFIC --- */
.login-page-container {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	min-height: 100vh;
	padding: 1rem;
	background: var(--bg-color);
}

.login-box {
	width: 100%;
	max-width: 400px;
	padding: 2.5rem;
	background-color: var(--surface-color);
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-md);
}

.table-controls {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
}

.status-badge {
	padding: 0.25em 0.6em;
	font-size: 0.8rem;
	font-weight: 600;
	border-radius: 20px;
	text-transform: uppercase;
}

.status-ok {
	background-color: var(--success-color);
	color: #fff;
}

.status-warn {
	background-color: var(--warning-color);
	color: #000;
}

.status-danger {
	background-color: var(--danger-color);
	color: #fff;
}

.status-info {
	background-color: var(--text-muted-color);
	color: #fff;
}

.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 0.5rem;
}

@media (max-width : 576px) {
	.details-list li {
		flex-direction: column;
		align-items: flex-start;
	}
}

.details-list li:last-child {
	border-bottom: none;
}

.details-subtitle {
	font-size: 1.1rem;
	color: var(--text-muted-color);
	margin-bottom: 1.5rem;
}

.star-rating {
	display: flex;
	flex-direction: row-reverse;
	justify-content: flex-end;
	font-size: 2em;
}

.star-rating input {
	display: none;
}

.star-rating label {
	color: #ccc;
	cursor: pointer;
	transition: color 0.2s;
}

.star-rating label:before {
	content: '★';
}

.star-rating input:checked~label,
.star-rating:not(:checked)>label:hover,
.star-rating:not(:checked)>label:hover~label {
	color: #ffc107;
}

.qr-action-body {
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: 100vh;
	background-color: var(--bg-color);
}

.qr-action-container {
	text-align: center;
	width: 90%;
	max-width: 400px;
}

.qr-action-item-name {
	font-size: 1.5rem;
	font-weight: bold;
	margin-bottom: 2rem;
}

.qr-action-buttons {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1rem;
}

.qr-action-btn {
	font-size: 1.2rem;
	padding: 1.5rem;
}

.lightbox-overlay {
	display: none;
	position: fixed;
	z-index: 3000;
	padding: 1rem;
	justify-content: center;
	align-items: center;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	overflow: auto;
	background-color: rgba(0, 0, 0, 0.8);
}

.lightbox-content {
	margin: auto;
	display: block;
	width: auto;
	height: auto;
	max-width: 90vw;
	max-height: 90vh;
}

.lightbox-close {
	position: absolute;
	top: 15px;
	right: 35px;
	color: #f1f1f1;
	font-size: 40px;
	font-weight: bold;
	transition: 0.3s;
}

.lightbox-close:hover,
.lightbox-close:focus {
	color: #bbb;
	text-decoration: none;
	cursor: pointer;
}

.data-table .sticky-header {
	position: sticky;
	top: 0;
	z-index: 10;
}

.data-table .sticky-col {
	position: sticky;
	left: 0;
	background-color: var(--surface-color);
	z-index: 5;
}

.data-table .qual-cell[data-attended="true"] {
	color: var(--success-color);
}

.horizontal-scroll-hint {
	display: none;
	text-align: center;
	padding: 0.5rem;
	background-color: var(--warning-color);
	color: #000;
	font-weight: 500;
	border-radius: var(--border-radius);
	margin-bottom: 1rem;
}

@media (max-width : 768px) {
	.horizontal-scroll-hint {
		display: block;
	}
}

/* --- 8. CREATIVE ERROR PAGES --- */
.error-page-wrapper {
    display: flex;
    /* Centering is now optional and handled by the element itself */
    min-height: 100vh;
    width: 100%;
    padding: 0; /* Remove padding for full-screen pages */
    font-family: 'Courier New', Courier, monospace;
    background-color: var(--bg-color);
}

.error-page-wrapper.center {
    justify-content: center;
    align-items: center;
    padding: 2rem;
}

.terminal {
    background-color: var(--terminal-bg);
    border: 1px solid var(--terminal-border);
    border-radius: 8px;
    padding: 1.5rem;
    width: 100%;
    max-width: 800px;
    box-shadow: var(--shadow-lg);
}

.full-screen-terminal {
    width: 100%;
    height: 100vh;
    background-color: var(--terminal-bg);
    color: var(--terminal-text);
    display: flex;
    flex-direction: column;
}

.full-screen-terminal .terminal-header {
    flex-shrink: 0;
}
.full-screen-terminal .terminal-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1.5rem;
}
.full-screen-terminal .terminal-footer {
    flex-shrink: 0;
    padding: 1.5rem;
    border-top: 1px solid var(--terminal-border);
}


.terminal-header {
    display: flex;
    align-items: center;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--terminal-border);
    margin-bottom: 1rem;
    background-color: var(--terminal-header-bg);
    margin: -1.5rem -1.5rem 1rem -1.5rem;
    padding: 1rem 1.5rem;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}

.terminal-header span {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
}
.terminal-header .red { background-color: #ff5f56; }
.terminal-header .yellow { background-color: #ffbd2e; }
.terminal-header .green { background-color: #27c93f; }

.terminal-header .title {
    color: var(--terminal-text-muted);
    margin: 0 auto;
}

.terminal-body {
    min-height: 200px;
    color: var(--terminal-text);
}

.terminal-line {
    display: flex;
    white-space: pre-wrap;
    word-break: break-all;
}

.terminal-prompt {
    color: var(--terminal-prompt);
    margin-right: 0.5rem;
}

.terminal-line .cursor {
    display: inline-block;
    width: 8px;
    height: 1.2em;
    background-color: var(--terminal-text);
    animation: blink 1s step-end infinite;
}

@keyframes blink {
    from, to { background-color: transparent; }
    50% { background-color: var(--terminal-text); }
}

.error-page-wrapper .btn {
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    margin-top: 1.5rem;
}
.full-screen-terminal .btn {
    margin-top: 0;
}


.error-page-wrapper .btn.visible {
    opacity: 1;
}

.terminal-line.info { color: var(--text-muted-color); }
.terminal-line.ok { color: var(--success-color); }
.terminal-line.warn { color: var(--warning-color); }
.terminal-line.fail { color: var(--danger-color); }

/* --- 9. WARNING NOTIFICATION --- */
body.warning-flash {
    animation: flash 1s ease-out infinite;
}

@keyframes flash {
    0%, 100% { background-color: var(--bg-color); }
    50% { background-color: var(--danger-color); }
}

/* --- 10. CHAT INTERFACE --- */
.chat-message-container {
	display: flex;
	align-items: center;
	margin-bottom: 0.75rem;
	position: relative;
	max-width: 90%;
	align-self: flex-start;
}

.chat-message-container.current-user {
	align-self: flex-end;
	flex-direction: row-reverse;
}

.chat-bubble {
	padding: 0.6rem 0.9rem;
	border-radius: 18px;
	word-wrap: break-word;
	border: 1px solid transparent;
}

.chat-bubble.current-user-bubble {
	background-color: var(--primary-color) !important;
	color: #fff !important;
	border-color: var(--primary-color) !important;
}

.chat-username {
	display: block;
	font-size: 0.8rem;
	font-weight: 700;
	margin-bottom: 0.2rem;
}

.chat-text {
	display: block;
	font-size: 1rem;
	line-height: 1.4;
}

.chat-timestamp {
	display: block;
	font-size: 0.75rem;
	margin-top: 0.3rem;
	text-align: right;
}

.chat-edited-marker {
	font-size: 0.7em;
	font-style: italic;
	color: inherit;
}

.chat-options {
	opacity: 0;
	transition: opacity 0.2s;
	display: flex;
	gap: 0.25rem;
	background-color: var(--surface-color);
	padding: 0.25rem;
	border-radius: 20px;
	box-shadow: var(--shadow-md);
	margin: 0 0.5rem;
}

.chat-message-container:hover .chat-options {
	opacity: 1;
}

.chat-option-btn {
	background: none;
	border: none;
	cursor: pointer;
	color: var(--text-muted-color);
	width: 28px;
	height: 28px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
}

.chat-option-btn:hover {
	background-color: var(--bg-color);
	color: var(--text-color);
}

.chat-edit-input {
	width: 100%;
	padding: 0.2rem 0.4rem;
	border: 1px solid var(--primary-color);
	border-radius: 4px;
	background: var(--surface-color);
	color: var(--text-color);
	font-family: inherit;
	font-size: 1rem;
}

.chat-bubble.deleted {
	font-style: italic;
	opacity: 0.7;
}

.chat-deleted-info {
	font-size: 0.9em;
}

#chat-box {
	display: flex;
	flex-direction: column;
}

/* --- 12. MARKDOWN STYLES --- */
.markdown-content {
	overflow-wrap: break-word;
	word-wrap: break-word;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
	margin-top: 1.5rem;
	margin-bottom: 1rem;
	font-weight: 600;
	border: none;
	padding: 0;
}

.markdown-content p {
	margin-bottom: 1rem;
}

.markdown-content ul,
.markdown-content ol {
	padding-left: 2rem;
	margin-bottom: 1rem;
}

.markdown-content blockquote {
	padding: 0.5rem 1rem;
	margin: 0 0 1rem;
	font-size: 1rem;
	border-left: 0.25rem solid var(--border-color);
	background-color: var(--bg-color);
	color: var(--text-muted-color);
}

.markdown-content code {
	padding: .2em .4em;
	margin: 0;
	font-size: 85%;
	background-color: var(--primary-color-light);
	border-radius: 6px;
	font-family: monospace;
}

.markdown-content pre {
	padding: 1rem;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: var(--bg-color);
	border-radius: 6px;
	margin-bottom: 1rem;
}

.markdown-content table {
	width: 100%;
	margin-bottom: 1rem;
	border-collapse: collapse;
	display: block;
	overflow-x: auto;
}

.markdown-content th,
.markdown-content td {
	padding: 0.75rem;
	border: 1px solid var(--border-color);
}

.markdown-content thead {
	background-color: var(--bg-color);
}

.markdown-content img {
	max-width: 100%;
	height: auto;
}

/* --- 14. CUSTOM CALENDAR STYLES --- */
.termin-list {
	list-style: none;
	padding: 0;
}

.termin-item-link {
	text-decoration: none;
	color: inherit;
	display: block;
}

.termin-item {
	display: flex;
	align-items: center;
	padding: 1rem;
	background-color: var(--surface-color);
	border-bottom: 1px solid var(--border-color);
	transition: background-color 0.2s;
}

.termin-item:hover {
	background-color: var(--bg-color);
}

.termin-list li:first-child {
	border-top: 1px solid var(--border-color);
}

.termin-date {
	flex-shrink: 0;
	text-align: center;
	margin-right: 1.5rem;
	width: 60px;
}

.termin-date-day {
	font-size: 1.8rem;
	font-weight: 600;
	display: block;
	line-height: 1;
	color: var(--primary-color);
}

.termin-date-month {
	font-size: 0.9rem;
	text-transform: uppercase;
	font-weight: 500;
	display: block;
	color: var(--text-muted-color);
}

.termin-details {
	flex-grow: 1;
}

.termin-title {
	font-weight: 600;
	display: block;
	margin-bottom: 0.25rem;
}

.termin-type-event {
	background-color: var(--danger-color);
	color: white;
}

.termin-type-lehrgang {
	background-color: var(--primary-color);
	color: white;
}

.termin-arrow {
	color: var(--text-muted-color);
	margin-left: 1rem;
}

.mobile-list-view {
	display: block;
}

.desktop-calendar-view {
	display: none;
}

@media (min-width : 992px) {
	.mobile-list-view {
		display: none;
	}

	.desktop-calendar-view {
		display: block;
	}
}

/* --- 15. WIKI PAGE STYLES --- */
body[data-page="wiki"] .main-content {
	display: flex;
	padding: 0;
	overflow: hidden;
}

.wiki-page-wrapper {
	display: flex;
	flex-grow: 1;
	min-height: 0;
	min-width: 0;
}

.wiki-sidebar {
	flex: 0 0 350px;
	height: 100%;
	display: flex;
	flex-direction: column;
	background-color: var(--surface-color);
	border-right: 1px solid var(--border-color);
	padding: 1.5rem;
}

.wiki-content-pane {
	flex-grow: 1;
	height: 100%;
	display: flex;
	flex-direction: column;
	min-width: 0;
	padding: 1.5rem;
	overflow-y: auto;
}

.wiki-sidebar-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
	flex-shrink: 0;
}

.wiki-sidebar-header h3 {
	margin: 0;
	border: none;
	padding: 0;
}

.wiki-tree-container {
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

.wiki-welcome-pane {
	text-align: center;
	margin: auto;
	color: var(--text-muted-color);
}

.wiki-welcome-pane h1 {
	margin-top: 1rem;
}

.wiki-tree-container ul {
	list-style-type: none;
	padding-left: 1rem;
}

.wiki-tree-container summary {
	cursor: pointer;
	padding: 0.25rem 0;
	list-style: none;
}

.wiki-tree-container summary::-webkit-details-marker {
	display: none;
}

.wiki-tree-container summary:before {
	content: '\f07b';
	font-family: 'Font Awesome 5 Free';
	font-weight: 900;
	margin-right: 0.5rem;
	color: var(--text-muted-color);
	transition: transform 0.2s;
}

.wiki-tree-container details[open]>summary:before {
	content: '\f07c';
}

.wiki-tree-container a {
	display: block;
	padding: 0.25rem 0.5rem;
	border-radius: 4px;
	text-decoration: none;
}

.wiki-tree-container a:hover {
	background-color: var(--sidebar-hover-bg);
}

.wiki-tree-container a.active {
	background-color: var(--primary-color-light);
	font-weight: 600;
	color: var(--primary-color);
}

.wiki-content-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	border-bottom: 1px solid var(--border-color);
	margin-bottom: 1rem;
	flex-wrap: wrap;
	gap: 1rem;
	flex-shrink: 0;
}

.wiki-content-header h2 {
	margin: 0;
	padding: 0;
	border: none;
	font-size: 1.2rem;
	word-break: break-all;
}

@media (max-width : 991.98px) {
	.wiki-sidebar {
		position: fixed;
		top: var(--header-height);
		left: 0;
		height: calc(100% - var(--header-height));
		margin-left: -100%;
		z-index: 1000;
		box-shadow: var(--shadow-lg);
	}

	.wiki-page-wrapper.sidebar-open .wiki-sidebar {
		margin-left: 0;
	}
}

/* --- 16. UTILITY OVERFLOW STYLES --- */
.data-table td,
.data-table th,
code,
pre {
	word-break: break-word;
	white-space: normal;
}

pre,
code {
	white-space: pre-wrap;
}

/* --- 17. INLINE WIKI EDITOR STYLES --- */
.wiki-editor-controls {
	display: flex;
	align-items: center;
	gap: 1rem;
}

#wiki-content-pane .editor-container {
	display: flex;
	flex-direction: column;
	flex-grow: 1;
	min-height: 0;
	border: none;
	padding: 0;
	box-shadow: none;
	background: transparent;
}

#wiki-content-pane #editor {
	flex-grow: 1;
	min-height: 0;
	height: auto;
	overflow-y: auto;
}

#wiki-content-pane #markdown-preview {
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

/* --- 18. FEEDBACK BOARD (KANBAN) --- */
.feedback-board {
	display: flex;
	gap: 1.5rem;
	overflow-x: auto;
	padding-bottom: 1rem;
	min-height: 60vh;
}

.feedback-column {
	flex: 1 0 300px;
	min-width: 300px;
	background-color: var(--bg-color);
	border-radius: var(--border-radius);
	padding: 1rem;
}

.feedback-column h2 {
	font-size: 1.2rem;
	border-bottom: 2px solid var(--border-color);
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
}

.feedback-list {
	min-height: 100px;
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.feedback-card-item {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: 6px;
	padding: 1rem;
	box-shadow: var(--shadow-sm);
	cursor: pointer;
}

.feedback-card-item:active {
	cursor: grabbing;
}

.feedback-card-item .subject {
	font-weight: 600;
	margin-bottom: 0.5rem;
	display: block;
}

.feedback-card-item .content-preview {
	font-size: 0.9rem;
	color: var(--text-muted-color);
	margin-bottom: 0.75rem;
	display: -webkit-box;
	-webkit-line-clamp: 2;
	-webkit-box-orient: vertical;
	overflow: hidden;
	text-overflow: ellipsis;
}

.feedback-card-item .meta {
	font-size: 0.8rem;
	color: var(--text-muted-color);
}

.sortable-ghost {
	opacity: 0.4;
	background: var(--primary-color-light);
}
========================================================================
FILE: frontend\src\App.jsx
========================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import Sidebar from './components/layout/Sidebar';
import Header from './components/layout/Header';
import ToastContainer from './components/ui/ToastContainer';
import { ToastProvider } from './context/ToastContext';
import { useNotifications } from './hooks/useNotifications';
import WarningNotification from './components/ui/WarningNotification';
import ChangelogModal from './components/ui/ChangelogModal';
import apiClient from './services/apiClient';
import { useAuthStore } from './store/authStore';

const AppLayout = () => {
	const [isNavOpen, setIsNavOpen] = useState(false);
	const location = useLocation();
	const { warningNotification, dismissWarning } = useNotifications();
	const [changelog, setChangelog] = useState(null);
	const [isChangelogVisible, setIsChangelogVisible] = useState(false);
	const isAuthenticated = useAuthStore(state => state.isAuthenticated);

	const fetchChangelog = useCallback(async () => {
		if (isAuthenticated) {
			try {
				const result = await apiClient.get('/public/changelog/latest-unseen');
				if (result.success && result.data) {
					setChangelog(result.data);
					setIsChangelogVisible(true);
				}
			} catch (error) {
				console.error("Failed to fetch changelog:", error);
			}
		}
	}, [isAuthenticated]);

	useEffect(() => {
		fetchChangelog();
	}, [fetchChangelog]);


	const handleChangelogClose = async () => {
		if (changelog) {
			try {
				await apiClient.post(`/public/changelog/${changelog.id}/mark-seen`);
			} catch (error) {
				console.error("Failed to mark changelog as seen:", error);
			}
		}
		setIsChangelogVisible(false);
		setChangelog(null); // FIX: Reset state to prevent re-opening
	};

	useEffect(() => {
		// Close mobile navigation when the route changes
		setIsNavOpen(false);
	}, [location]);

	useEffect(() => {
		// Add/remove class from body for overlay effect
		if (isNavOpen) {
			document.body.classList.add('nav-open');
		} else {
			document.body.classList.remove('nav-open');
		}
	}, [isNavOpen]);

	return (
		<>
			<Sidebar />
			<Header onNavToggle={() => setIsNavOpen(!isNavOpen)} />
			{isNavOpen && <div className="page-overlay" onClick={() => setIsNavOpen(false)}></div>}
			<div className="main-content-wrapper">
				<main className="main-content">
					<Outlet />
				</main>
			</div>
			<ToastContainer />
			{warningNotification && <WarningNotification notification={warningNotification} onDismiss={dismissWarning} />}
			{isChangelogVisible && changelog && (
				<ChangelogModal
					changelog={changelog}
					onClose={handleChangelogClose}
				/>
			)}
		</>
	);
};

function App() {
	return (
		<ToastProvider>
			<AppLayout />
		</ToastProvider>
	);
}

export default App;
========================================================================
FILE: frontend\src\main.jsx
========================================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import router from './router';
import { useAuthStore } from './store/authStore';
import apiClient from './services/apiClient'; // Import apiClient here

const initializeApp = async () => {
	// Inject the logout function into the apiClient
	apiClient.setup({ onUnauthorized: useAuthStore.getState().logout });

	// The call to the non-existent fetchCsrfToken function is now removed.

	const { user, fetchUserSession } = useAuthStore.getState();
	if (!user) {
		try {
			await fetchUserSession();
		} catch (error) {
			console.log("Keine gültige Sitzung gefunden. Benutzer muss sich anmelden.");
		}
	}
};

initializeApp().then(() => {
	ReactDOM.createRoot(document.getElementById('root')).render(
		<React.StrictMode>
			<RouterProvider router={router} />
		</React.StrictMode>
	);
});
========================================================================
FILE: frontend\src\components\admin\dashboard\EventTrendChart.jsx
========================================================================

import React from 'react';
import { Line } from 'react-chartjs-2';
import {
	Chart as ChartJS,
	CategoryScale,
	LinearScale,
	PointElement,
	LineElement,
	Title,
	Tooltip,
	Legend,
	Filler,
} from 'chart.js';

ChartJS.register(
	CategoryScale,
	LinearScale,
	PointElement,
	LineElement,
	Title,
	Tooltip,
	Legend,
	Filler
);

const EventTrendChart = ({ trendData }) => {
	if (!trendData || trendData.length === 0) {
		return <p>Nicht genügend Daten für den Event-Trend vorhanden.</p>;
	}

	const data = {
		labels: trendData.map(d => d.month),
		datasets: [
			{
				label: 'Anzahl Events pro Monat',
				data: trendData.map(d => d.count),
				fill: true,
				borderColor: 'rgb(0, 123, 255)',
				backgroundColor: 'rgba(0, 123, 255, 0.1)',
				tension: 0.1,
			},
		],
	};

	const options = {
		responsive: true,
		maintainAspectRatio: false,
		scales: {
			y: {
				beginAtZero: true,
				ticks: {
					stepSize: 1,
					precision: 0,
				},
			},
		},
		plugins: {
			legend: {
				display: false,
			},
		},
	};

	return (
		<div style={{ position: 'relative', height: '300px' }}>
			<Line options={options} data={data} />
		</div>
	);
};

export default EventTrendChart;
========================================================================
FILE: frontend\src\components\admin\dashboard\Widget.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';

const Widget = ({ icon, title, children, linkTo, linkText }) => {
	return (
		<div className="card">
			<h2 className="card-title">
				<i className={`fas ${icon}`}></i> {title}
			</h2>
			{children}
			{linkTo && linkText && (
				<Link to={linkTo} className="btn btn-small" style={{ marginTop: '1rem' }}>
					{linkText}
				</Link>
			)}
		</div>
	);
};

export default Widget;
========================================================================
FILE: frontend\src\components\admin\events\DynamicItemRows.jsx
========================================================================

import React from 'react';

const DynamicItemRows = ({ rows, setRows, storageItems }) => {
	const handleRowChange = (index, field, value) => {
		const newRows = [...rows];
		newRows[index][field] = value;
		setRows(newRows);
	};

	const handleAddRow = () => {
		setRows([...rows, { itemId: '', quantity: 1 }]);
	};

	const handleRemoveRow = (index) => {
		setRows(rows.filter((_, i) => i !== index));
	};

	return (
		<div>
			{rows.map((row, index) => (
				<div className="dynamic-row" key={index}>
					<select
						name="itemIds"
						value={row.itemId}
						onChange={(e) => handleRowChange(index, 'itemId', e.target.value)}
						className="form-group"
					>
						<option value="">-- Artikel auswählen --</option>
						{storageItems.map(item => <option key={item.id} value={item.id}>{item.name}</option>)}
					</select>
					<input
						type="number"
						name="quantities"
						value={row.quantity}
						onChange={(e) => handleRowChange(index, 'quantity', e.target.value)}
						className="form-group"
						style={{ maxWidth: '100px' }}
						min="1"
					/>
					<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveRow(index)} title="Zeile entfernen">×</button>
				</div>
			))}
			<button type="button" className="btn btn-small" onClick={handleAddRow}>
				<i className="fas fa-plus"></i> Artikel hinzufügen
			</button>
		</div>
	);
};

export default DynamicItemRows;
========================================================================
FILE: frontend\src\components\admin\events\DynamicSkillRows.jsx
========================================================================

import React from 'react';

const DynamicSkillRows = ({ rows, setRows, courses }) => {
	const handleRowChange = (index, field, value) => {
		const newRows = [...rows];
		newRows[index][field] = value;
		setRows(newRows);
	};

	const handleAddRow = () => {
		setRows([...rows, { requiredCourseId: '', requiredPersons: 1 }]);
	};

	const handleRemoveRow = (index) => {
		setRows(rows.filter((_, i) => i !== index));
	};

	return (
		<div>
			{rows.map((row, index) => (
				<div className="dynamic-row" key={index}>
					<select
						name="requiredCourseIds"
						value={row.requiredCourseId}
						onChange={(e) => handleRowChange(index, 'requiredCourseId', e.target.value)}
						className="form-group"
					>
						<option value="">-- Qualifikation auswählen --</option>
						{courses.map(course => <option key={course.id} value={course.id}>{course.name}</option>)}
					</select>
					<input
						type="number"
						name="requiredPersons"
						value={row.requiredPersons}
						onChange={(e) => handleRowChange(index, 'requiredPersons', e.target.value)}
						className="form-group"
						style={{ maxWidth: '100px' }}
						min="1"
					/>
					<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveRow(index)} title="Zeile entfernen">×</button>
				</div>
			))}
			<button type="button" className="btn btn-small" onClick={handleAddRow}>
				<i className="fas fa-plus"></i> Anforderung hinzufügen
			</button>
		</div>
	);
};

export default DynamicSkillRows;
========================================================================
FILE: frontend\src\components\admin\events\EventModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';
import DynamicSkillRows from './DynamicSkillRows';
import DynamicItemRows from './DynamicItemRows';
import TaskDependenciesForm from './TaskDependenciesForm';

const EventModal = ({ isOpen, onClose, onSuccess, event, adminFormData }) => {
	const isEditMode = !!event;
	const { users, courses, storageItems } = adminFormData;
	const [activeTab, setActiveTab] = useState('general');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const [formData, setFormData] = useState({
		name: '',
		eventDateTime: '',
		endDateTime: '',
		location: '',
		description: '',
		status: 'GEPLANT',
		leaderUserId: '',
		requiredRole: 'NUTZER',
		reminderMinutes: '0',
	});
	const [skillRows, setSkillRows] = useState([{ requiredCourseId: '', requiredPersons: 1 }]);
	const [itemRows, setItemRows] = useState([{ itemId: '', quantity: 1 }]);
	const [file, setFile] = useState(null);

	useEffect(() => {
		if (isEditMode && event) {
			setFormData({
				name: event.name || '',
				eventDateTime: event.eventDateTime ? event.eventDateTime.substring(0, 16) : '',
				endDateTime: event.endDateTime ? event.endDateTime.substring(0, 16) : '',
				location: event.location || '',
				description: event.description || '',
				status: event.status || 'GEPLANT',
				leaderUserId: event.leaderUserId || '',
				requiredRole: 'NUTZER',
				reminderMinutes: event.reminderMinutes || '0',
			});
			setSkillRows(event.skillRequirements?.length > 0 ? event.skillRequirements : []);
			setItemRows(event.reservedItems?.length > 0 ? event.reservedItems : []);
		}
	}, [event, isEditMode]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const data = new FormData();
		const eventData = {
			...formData,
			reminderMinutes: parseInt(formData.reminderMinutes, 10),
			requiredCourseIds: skillRows.map(r => r.requiredCourseId).filter(Boolean),
			requiredPersons: skillRows.map(r => r.requiredPersons).filter(Boolean),
			itemIds: itemRows.map(r => r.itemId).filter(Boolean),
			quantities: itemRows.map(r => r.quantity).filter(Boolean),
		};

		data.append('eventData', new Blob([JSON.stringify(eventData)], { type: 'application/json' }));
		if (file) {
			data.append('file', file);
		}

		try {
			const result = isEditMode
				? await apiClient.post(`/events/${event.id}`, data)
				: await apiClient.post('/events', data);
			if (result.success) {
				addToast(`Event erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? "Event bearbeiten" : "Neues Event erstellen"}>
			<div className="modal-tabs">
				<button className={`modal-tab-button ${activeTab === 'general' ? 'active' : ''}`} onClick={() => setActiveTab('general')}>Allgemein</button>
				<button className={`modal-tab-button ${activeTab === 'details' ? 'active' : ''}`} onClick={() => setActiveTab('details')}>Details & Bedarf</button>
			</div>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className={`modal-tab-content ${activeTab === 'general' ? 'active' : ''}`}>
					<div className="form-group"><label>Name</label><input name="name" value={formData.name} onChange={handleChange} required /></div>
					<div className="responsive-dashboard-grid">
						<div className="form-group"><label>Beginn</label><input type="datetime-local" name="eventDateTime" value={formData.eventDateTime} onChange={handleChange} required /></div>
						<div className="form-group"><label>Ende</label><input type="datetime-local" name="endDateTime" value={formData.endDateTime} onChange={handleChange} /></div>
					</div>
					<div className="form-group"><label>Ort</label><input name="location" value={formData.location} onChange={handleChange} /></div>
					<div className="form-group"><label>Beschreibung</label><textarea name="description" value={formData.description} onChange={handleChange} rows="4"></textarea></div>
				</div>

				<div className={`modal-tab-content ${activeTab === 'details' ? 'active' : ''}`}>
					<div className="responsive-dashboard-grid">
						<div className="form-group"><label>Status</label><select name="status" value={formData.status} onChange={handleChange}><option value="GEPLANT">Geplant</option><option value="LAUFEND">Laufend</option><option value="ABGESCHLOSSEN">Abgeschlossen</option><option value="ABGESAGT">Abgesagt</option></select></div>
						<div className="form-group"><label>Leitung</label><select name="leaderUserId" value={formData.leaderUserId} onChange={handleChange}><option value="">(Keine)</option>{users?.map(u => <option key={u.id} value={u.id}>{u.username}</option>)}</select></div>
					</div>
					<div className="form-group">
						<label>Erinnerung senden</label>
						<select name="reminderMinutes" value={formData.reminderMinutes} onChange={handleChange}>
							<option value="0">Keine Erinnerung</option>
							<option value="60">1 Stunde vorher</option>
							<option value="120">2 Stunden vorher</option>
							<option value="1440">1 Tag vorher</option>
							<option value="2880">2 Tage vorher</option>
						</select>
					</div>
					<div className="form-group"><label>Anhang (optional)</label><input type="file" name="file" onChange={(e) => setFile(e.target.files[0])} /></div>
					<h4>Personalbedarf</h4>
					<DynamicSkillRows rows={skillRows} setRows={setSkillRows} courses={courses} />
					<h4 style={{ marginTop: '1.5rem' }}>Materialreservierung</h4>
					<DynamicItemRows rows={itemRows} setRows={setItemRows} storageItems={storageItems} />
				</div>

				<button type="submit" className="btn" style={{ marginTop: '1.5rem' }} disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Event speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default EventModal;
========================================================================
FILE: frontend\src\components\admin\events\TaskDependenciesForm.jsx
========================================================================

import React from 'react';

const TaskDependenciesForm = ({ allTasks, selectedDependencies, onDependencyChange }) => {

	const handleToggle = (taskId) => {
		const newSelection = new Set(selectedDependencies);
		if (newSelection.has(taskId)) {
			newSelection.delete(taskId);
		} else {
			newSelection.add(taskId);
		}
		onDependencyChange(newSelection);
	};

	if (!allTasks || allTasks.length === 0) {
		return <p className="text-muted">Keine anderen Aufgaben vorhanden, von denen diese abhängen könnte.</p>;
	}

	return (
		<div className="form-group">
			<label>Abhängig von (Tasks, die vorher erledigt sein müssen):</label>
			<div style={{ maxHeight: '150px', overflowY: 'auto', border: '1px solid var(--border-color)', padding: '0.5rem', borderRadius: 'var(--border-radius)' }}>
				{allTasks.map(task => (
					<label key={task.id} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.25rem' }}>
						<input
							type="checkbox"
							checked={selectedDependencies.has(task.id)}
							onChange={() => handleToggle(task.id)}
						/>
						{task.description}
					</label>
				))}
			</div>
		</div>
	);
};

export default TaskDependenciesForm;
========================================================================
FILE: frontend\src\components\admin\kits\KitItemsForm.jsx
========================================================================

import React, { useState } from 'react';
import apiClient from '../../../services/apiClient';

const KitItemsForm = ({ kit, allStorageItems, onUpdateSuccess }) => {
	const [items, setItems] = useState(kit.items || []);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const handleItemChange = (index, field, value) => {
		const newItems = [...items];
		newItems[index] = { ...newItems[index], [field]: value };
		setItems(newItems);
	};

	const handleAddItem = () => {
		setItems([...items, { itemId: '', quantity: 1 }]);
	};

	const handleRemoveItem = (index) => {
		const newItems = items.filter((_, i) => i !== index);
		setItems(newItems);
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const validItems = items.filter(item => item.itemId && item.quantity > 0)
			.map(item => ({ itemId: parseInt(item.itemId), quantity: parseInt(item.quantity) }));

		try {
			const result = await apiClient.put(`/kits/${kit.id}/items`, validItems);
			if (result.success) {
				onUpdateSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Inhalt konnte nicht gespeichert werden.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<form onSubmit={handleSubmit}>
			<h4>Inhalt bearbeiten</h4>
			{error && <p className="error-message">{error}</p>}
			<div id={`kit-items-container-${kit.id}`} className="kit-items-container">
				{items.length === 0 && <p className="no-items-message">Dieses Kit ist leer. Fügen Sie einen Artikel hinzu.</p>}
				{items.map((item, index) => (
					<div className="dynamic-row" key={index}>
						<select
							name="itemIds"
							className="form-group"
							value={item.itemId}
							onChange={(e) => handleItemChange(index, 'itemId', e.target.value)}
							required
						>
							<option value="">-- Artikel auswählen --</option>
							{allStorageItems.map(i => <option key={i.id} value={i.id}>{i.name}</option>)}
						</select>
						<input
							type="number"
							name="quantities"
							value={item.quantity}
							onChange={(e) => handleItemChange(index, 'quantity', e.target.value)}
							min="1"
							className="form-group"
							style={{ maxWidth: '100px' }}
							required
						/>
						<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveItem(index)} title="Zeile entfernen">×</button>
					</div>
				))}
			</div>
			<div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
				<button type="button" className="btn btn-small" onClick={handleAddItem}>
					<i className="fas fa-plus"></i> Zeile hinzufügen
				</button>
				<button type="submit" className="btn btn-success" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : <><i className="fas fa-save"></i> Kit-Inhalt speichern</>}
				</button>
			</div>
		</form>
	);
};

export default KitItemsForm;
========================================================================
FILE: frontend\src\components\admin\kits\KitModal.jsx
========================================================================

import React, { useState } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const KitModal = ({ isOpen, onClose, onSuccess, kit }) => {
	const isEditMode = !!kit;
	const [formData, setFormData] = useState({
		name: kit?.name || '',
		description: kit?.description || '',
		location: kit?.location || ''
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		try {
			const result = isEditMode
				? await apiClient.put(`/kits/${kit.id}`, formData)
				: await apiClient.post('/kits', formData);

			if (result.success) {
				addToast(`Kit erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? "Kit bearbeiten" : "Neues Kit anlegen"}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="name-modal">Name des Kits</label>
					<input type="text" id="name-modal" name="name" value={formData.name} onChange={handleChange} required />
				</div>
				<div className="form-group">
					<label htmlFor="description-modal">Beschreibung</label>
					<textarea id="description-modal" name="description" value={formData.description} onChange={handleChange} rows="3"></textarea>
				</div>
				<div className="form-group">
					<label htmlFor="location-modal">Physischer Standort des Kits</label>
					<input type="text" id="location-modal" name="location" value={formData.location} onChange={handleChange} placeholder="z.B. Lager, Schrank 3, Fach A" />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default KitModal;
========================================================================
FILE: frontend\src\components\admin\matrix\AttendanceModal.jsx
========================================================================

import React, { useState } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const AttendanceModal = ({ isOpen, onClose, onSuccess, cellData }) => {
	const [attended, setAttended] = useState(cellData.attended);
	const [remarks, setRemarks] = useState(cellData.remarks);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			userId: cellData.userId,
			meetingId: cellData.meetingId,
			attended,
			remarks,
		};

		try {
			const result = await apiClient.put('/matrix/attendance', payload);
			if (result.success) {
				addToast('Teilnahme erfolgreich gespeichert.', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal
			isOpen={isOpen}
			onClose={onClose}
			title={`Teilnahme bearbeiten: ${cellData.userName}`}
		>
			<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
				Meeting: {cellData.meetingName}
			</p>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
					<input
						type="checkbox"
						id="modal-attended"
						name="attended"
						checked={attended}
						onChange={(e) => setAttended(e.target.checked)}
						style={{ width: '1.5rem', height: '1.5rem' }}
					/>
					<label htmlFor="modal-attended" style={{ marginBottom: 0 }}>
						Hat teilgenommen
					</label>
				</div>
				<div className="form-group">
					<label htmlFor="modal-remarks">Anmerkungen (z.B. "entschuldigt gefehlt")</label>
					<textarea
						id="modal-remarks"
						name="remarks"
						value={remarks}
						onChange={(e) => setRemarks(e.target.value)}
						rows="3"
					></textarea>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AttendanceModal;
========================================================================
FILE: frontend\src\components\admin\reports\UserActivityChart.jsx
========================================================================

import React from 'react';
import { Bar } from 'react-chartjs-2';
import {
	Chart as ChartJS,
	CategoryScale,
	LinearScale,
	BarElement,
	Title,
	Tooltip,
	Legend,
} from 'chart.js';

ChartJS.register(
	CategoryScale,
	LinearScale,
	BarElement,
	Title,
	Tooltip,
	Legend
);

const UserActivityChart = ({ activityData }) => {
	if (!activityData || activityData.length === 0) {
		return <p>Nicht genügend Daten für Benutzeraktivität vorhanden.</p>;
	}

	const data = {
		labels: activityData.map(d => d.username),
		datasets: [
			{
				label: 'Anzahl Event-Teilnahmen',
				data: activityData.map(d => d.participation_count),
				backgroundColor: 'rgba(0, 123, 255, 0.6)',
				borderColor: 'rgba(0, 123, 255, 1)',
				borderWidth: 1,
			},
		],
	};

	const options = {
		indexAxis: 'y', // Makes it a horizontal bar chart
		responsive: true,
		maintainAspectRatio: false,
		scales: {
			x: {
				beginAtZero: true,
				ticks: {
					stepSize: 1,
					precision: 0,
				},
			},
		},
		plugins: {
			legend: {
				display: false,
			},
			title: {
				display: true,
				text: 'Event-Teilnahmen pro Benutzer',
			},
		},
	};

	return (
		<div style={{ position: 'relative', height: '400px' }}>
			<Bar options={options} data={data} />
		</div>
	);
};

export default UserActivityChart;
========================================================================
FILE: frontend\src\components\admin\storage\StorageItemModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const StorageItemModal = ({ isOpen, onClose, onSuccess, item, initialMode = 'edit' }) => {
	const [mode, setMode] = useState(initialMode);
	const [formData, setFormData] = useState({});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	useEffect(() => {
		setMode(initialMode);
		if (initialMode === 'create') {
			setFormData({ name: '', location: '', quantity: 1, maxQuantity: 1 });
		} else if (item) {
			setFormData({ ...item });
		}
	}, [item, initialMode, isOpen]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleFileChange = (e) => {
		setFormData({ ...formData, imageFile: e.target.files[0] });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const data = new FormData();
		Object.keys(formData).forEach(key => {
			if (key !== 'imageFile') {
				data.append(key, formData[key] === null ? '' : formData[key]);
			}
		});
		if (formData.imageFile) {
			data.append('imageFile', formData.imageFile);
		}

		try {
			const result = (mode === 'create')
				? await apiClient.post('/storage', data)
				: await apiClient.post(`/storage/${item.id}`, data);

			if (result.success) {
				addToast(`Artikel ${mode === 'create' ? 'erstellt' : 'aktualisiert'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleDefectSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			action: formData.status === 'UNREPAIRABLE' ? 'report_unrepairable' : 'report_defect',
			quantity: parseInt(formData.defective_quantity_change, 10),
			reason: formData.defect_reason_change
		};

		try {
			const result = await apiClient.put(`/storage/${item.id}`, payload);
			if (result.success) {
				addToast('Defekt-Status erfolgreich aktualisiert.', 'success');
				onSuccess();
			} else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Melden des Defekts.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleRepairSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			action: 'repair',
			quantity: parseInt(formData.repaired_quantity, 10),
			notes: formData.repair_notes
		};

		try {
			const result = await apiClient.put(`/storage/${item.id}`, payload);
			if (result.success) {
				addToast('Reparatur erfolgreich verbucht.', 'success');
				onSuccess();
			} else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Buchen der Reparatur.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const renderContent = () => {
		switch (mode) {
			case 'defect':
				return (
					<form onSubmit={handleDefectSubmit}>
						<div className="form-group">
							<label>Status</label>
							<select name="status" onChange={handleChange} defaultValue="DEFECT" className="form-group">
								<option value="DEFECT">Defekt melden</option>
								<option value="UNREPAIRABLE">Nicht reparierbar (wird ausgebucht)</option>
							</select>
						</div>
						<div className="form-group">
							<label>Anzahl defekter Artikel</label>
							<input type="number" name="defective_quantity_change" defaultValue="1" min="1" max={item.availableQuantity} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Grund</label>
							<textarea name="defect_reason_change" rows="3" onChange={handleChange}></textarea>
						</div>
						<button type="submit" className="btn" disabled={isSubmitting}>Speichern</button>
					</form>
				);
			case 'repair':
				return (
					<form onSubmit={handleRepairSubmit}>
						<div className="form-group">
							<label>Anzahl reparierter Artikel</label>
							<input type="number" name="repaired_quantity" defaultValue="1" min="1" max={item.defectiveQuantity} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Notiz (z.B. was wurde gemacht?)</label>
							<textarea name="repair_notes" rows="3" onChange={handleChange}></textarea>
						</div>
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>Als repariert buchen</button>
					</form>
				);
			case 'create':
			case 'edit':
			default:
				return (
					<form onSubmit={handleSubmit}>
						<div className="form-group">
							<label>Name</label>
							<input type="text" name="name" value={formData.name || ''} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Ort</label>
							<input type="text" name="location" value={formData.location || ''} onChange={handleChange} />
						</div>
						<div className="responsive-dashboard-grid">
							<div className="form-group">
								<label>Menge im Bestand</label>
								<input type="number" name="quantity" value={formData.quantity || 0} onChange={handleChange} min="0" required />
							</div>
							<div className="form-group">
								<label>Max. Menge</label>
								<input type="number" name="maxQuantity" value={formData.maxQuantity || 0} onChange={handleChange} min="0" required />
							</div>
						</div>
						<div className="form-group">
							<label>Bild (optional)</label>
							<input type="file" name="imageFile" onChange={handleFileChange} accept="image/*" />
						</div>
						<button type="submit" className="btn" disabled={isSubmitting}>Speichern</button>
					</form>
				);
		}
	};

	const getTitle = () => {
		switch (mode) {
			case 'create': return 'Neuen Artikel anlegen';
			case 'edit': return `Artikel bearbeiten: ${item?.name}`;
			case 'defect': return `Defekt-Status für "${item?.name}"`;
			case 'repair': return `Artikel "${item?.name}" repariert`;
			default: return 'Lagerartikel';
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={getTitle()}>
			{error && <p className="error-message">{error}</p>}
			{renderContent()}
		</Modal>
	);
};

export default StorageItemModal;
========================================================================
FILE: frontend\src\components\admin\users\PermissionTab.jsx
========================================================================

import React from 'react';

const PermissionsTab = ({ groupedPermissions, assignedIds, onPermissionChange, isLoading }) => {
	if (isLoading) {
		return <p>Lade Berechtigungen...</p>;
	}

	return (
		<div>
			<h4>Individuelle Berechtigungen</h4>
			<p>Diese Berechtigungen gelten zusätzlich zu denen, die eine Rolle evtl. standardmäßig hat.</p>
			<div style={{ maxHeight: '40vh', overflowY: 'auto', padding: '0.5rem', border: '1px solid var(--border-color)', borderRadius: 'var(--border-radius)' }}>
				{Object.entries(groupedPermissions).map(([groupName, permissionsInGroup]) => (
					<details key={groupName} open>
						<summary style={{ fontWeight: 'bold', cursor: 'pointer', padding: '0.5rem 0' }}>
							{groupName}
						</summary>
						<div style={{ paddingLeft: '1rem' }}>
							{permissionsInGroup.map(p => (
								<label key={p.id} style={{ display: 'flex', alignItems: 'flex-start', marginBottom: '0.5rem' }}>
									<input
										type="checkbox"
										value={p.id}
										checked={assignedIds.has(p.id)}
										onChange={() => onPermissionChange(p.id)}
										style={{ marginTop: '5px', marginRight: '10px' }}
									/>
									<div>
										<strong>{p.permissionKey.replace(groupName + '_', '')}</strong>
										<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>{p.description}</small>
									</div>
								</label>
							))}
						</div>
					</details>
				))}
			</div>
		</div>
	);
};

export default PermissionsTab;
========================================================================
FILE: frontend\src\components\admin\users\UserModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import PermissionsTab from './PermissionTab';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const UserModal = ({ isOpen, onClose, onSuccess, user, roles, groupedPermissions, isLoadingData }) => {
	const [activeTab, setActiveTab] = useState('general');
	const [formData, setFormData] = useState({});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const isEditMode = !!user;

	useEffect(() => {
		const fetchUserData = async () => {
			if (isEditMode && user) {
				try {
					const result = await apiClient.get(`/users/${user.id}`);
					if (result.success) {
						setFormData({
							username: result.data.username || '',
							roleId: result.data.roleId || '',
							classYear: result.data.classYear || '',
							className: result.data.className || '',
							email: result.data.email || '',
							adminNotes: result.data.adminNotes || '',
							permissionIds: new Set(result.data.permissions.map(p => p.id))
						});
					}
				} catch (err) {
					setError('Benutzerdetails konnten nicht geladen werden.');
				}
			} else {
				setFormData({
					username: '',
					password: '',
					roleId: roles.find(r => r.roleName === 'NUTZER')?.id || '',
					classYear: '',
					className: '',
					email: '',
					adminNotes: '',
					permissionIds: new Set()
				});
			}
		};
		fetchUserData();
	}, [user, isEditMode, roles, isOpen]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handlePermissionChange = (permissionId) => {
		setFormData(prev => {
			const newPermissionIds = new Set(prev.permissionIds);
			if (newPermissionIds.has(permissionId)) {
				newPermissionIds.delete(permissionId);
			} else {
				newPermissionIds.add(permissionId);
			}
			return { ...prev, permissionIds: newPermissionIds };
		});
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			...formData,
			permissionIds: Array.from(formData.permissionIds || [])
		};

		if (!isEditMode && (!payload.password || payload.password.length < 10)) {
			setError('Für neue Benutzer ist ein Passwort erforderlich, das mindestens 10 Zeichen lang sein muss.');
			setIsSubmitting(false);
			return;
		}

		try {
			const result = isEditMode
				? await apiClient.put(`/users/${user.id}`, payload)
				: await apiClient.post('/users', payload);

			if (result.success) {
				addToast(`Benutzer erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? `Benutzer bearbeiten: ${user.username}` : 'Neuen Benutzer anlegen'}>
			<div className="modal-tabs">
				<button className={`modal-tab-button ${activeTab === 'general' ? 'active' : ''}`} onClick={() => setActiveTab('general')}>Allgemein</button>
				<button className={`modal-tab-button ${activeTab === 'permissions' ? 'active' : ''}`} onClick={() => setActiveTab('permissions')}>Berechtigungen</button>
				{isEditMode && <button className={`modal-tab-button ${activeTab === 'notes' ? 'active' : ''}`} onClick={() => setActiveTab('notes')}>Admin-Notizen</button>}
			</div>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className={`modal-tab-content ${activeTab === 'general' ? 'active' : ''}`}>
					<div className="form-group">
						<label htmlFor="username-modal">Benutzername</label>
						<input type="text" id="username-modal" name="username" value={formData.username || ''} onChange={handleChange} required />
					</div>
					{!isEditMode && (
						<div className="form-group">
							<label htmlFor="password-modal">Passwort</label>
							<input type="password" id="password-modal" name="password" value={formData.password || ''} onChange={handleChange} minLength="10" />
							<small className="text-muted">Muss 10+ Zeichen, Groß/Kleinbuchstaben, Zahlen & Sonderzeichen enthalten.</small>
						</div>
					)}
					<div className="form-group">
						<label htmlFor="role-modal">Rolle</label>
						<select name="roleId" id="role-modal" value={formData.roleId || ''} onChange={handleChange} required>
							{roles.map(role => <option key={role.id} value={role.id}>{role.roleName}</option>)}
						</select>
					</div>
					<div className="form-group">
						<label htmlFor="email-modal">E-Mail</label>
						<input type="email" id="email-modal" name="email" value={formData.email || ''} onChange={handleChange} />
					</div>
				</div>

				<div className={`modal-tab-content ${activeTab === 'permissions' ? 'active' : ''}`}>
					<PermissionsTab
						groupedPermissions={groupedPermissions}
						assignedIds={formData.permissionIds || new Set()}
						onPermissionChange={handlePermissionChange}
						isLoading={isLoadingData}
					/>
				</div>

				{isEditMode && (
					<div className={`modal-tab-content ${activeTab === 'notes' ? 'active' : ''}`}>
						<h4>Interne Notizen</h4>
						<p>Diese Notizen sind nur für Administratoren sichtbar.</p>
						<textarea
							name="adminNotes"
							rows="8"
							value={formData.adminNotes || ''}
							onChange={handleChange}
							className="form-group"
						></textarea>
					</div>
				)}

				<button type="submit" className="btn" style={{ marginTop: '1.5rem' }} disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Benutzer speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default UserModal;
========================================================================
FILE: frontend\src\components\calendar\CalendarDesktopView.jsx
========================================================================

import React, { useState, useMemo } from 'react';
import { Link } from 'react-router-dom';
import {
	format,
	addMonths,
	subMonths,
	startOfMonth,
	endOfMonth,
	startOfWeek,
	endOfWeek,
	eachDayOfInterval,
	isSameMonth,
	isToday,
	parseISO,
} from 'date-fns';
import { de } from 'date-fns/locale';

const CalendarDesktopView = ({ entries }) => {
	const [currentDate, setCurrentDate] = useState(new Date());

	const firstDayOfMonth = startOfMonth(currentDate);
	const lastDayOfMonth = endOfMonth(currentDate);
	const firstDayOfGrid = startOfWeek(firstDayOfMonth, { weekStartsOn: 1 }); // Monday start
	const lastDayOfGrid = endOfWeek(lastDayOfMonth, { weekStartsOn: 1 });
	const daysInGrid = eachDayOfInterval({ start: firstDayOfGrid, end: lastDayOfGrid });

	const eventsByDate = useMemo(() => {
		const grouped = {};
		entries.forEach(entry => {
			const dateKey = format(parseISO(entry.start), 'yyyy-MM-dd');
			if (!grouped[dateKey]) {
				grouped[dateKey] = [];
			}
			grouped[dateKey].push(entry);
		});
		return grouped;
	}, [entries]);

	const handlePrevMonth = () => setCurrentDate(subMonths(currentDate, 1));
	const handleNextMonth = () => setCurrentDate(addMonths(currentDate, 1));
	const handleToday = () => setCurrentDate(new Date());

	return (
		<div>
			<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
				<h2 style={{ margin: 0, border: 'none' }}>{format(currentDate, 'MMMM yyyy', { locale: de })}</h2>
				<div>
					<button onClick={handlePrevMonth} className="btn btn-secondary">{'<'}</button>
					<button onClick={handleToday} className="btn btn-secondary" style={{ margin: '0 0.5rem' }}>Heute</button>
					<button onClick={handleNextMonth} className="btn btn-secondary">{'>'}</button>
				</div>
			</div>
			<div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '1px', backgroundColor: 'var(--border-color)', border: '1px solid var(--border-color)' }}>
				{['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(day => (
					<div key={day} style={{ textAlign: 'center', padding: '0.5rem', backgroundColor: 'var(--bg-color)', fontWeight: 'bold' }}>{day}</div>
				))}
				{daysInGrid.map(day => {
					const dateKey = format(day, 'yyyy-MM-dd');
					const dayEvents = eventsByDate[dateKey] || [];
					return (
						<div
							key={dateKey}
							style={{
								backgroundColor: 'var(--surface-color)',
								minHeight: '120px',
								padding: '0.5rem',
								opacity: isSameMonth(day, currentDate) ? 1 : 0.5,
								borderTop: isToday(day) ? '2px solid var(--primary-color)' : 'none'
							}}
						>
							<div style={{ fontWeight: isToday(day) ? 'bold' : 'normal' }}>{format(day, 'd')}</div>
							{dayEvents.map(event => (
								<Link
									key={`${event.type}-${event.id}`}
									to={event.url}
									style={{
										display: 'block',
										fontSize: '0.8rem',
										padding: '0.2rem 0.4rem',
										borderRadius: '4px',
										marginBottom: '0.25rem',
										whiteSpace: 'nowrap',
										overflow: 'hidden',
										textOverflow: 'ellipsis',
										backgroundColor: event.type === 'Event' ? 'var(--danger-color)' : 'var(--primary-color)',
										color: '#fff'
									}}
									title={event.title}
								>
									{event.title}
								</Link>
							))}
						</div>
					);
				})}
			</div>
		</div>
	);
};

export default CalendarDesktopView;
========================================================================
FILE: frontend\src\components\calendar\CalendarMobileView.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
import { format, parseISO } from 'date-fns';
import { de } from 'date-fns/locale';

const CalendarMobileView = ({ entries }) => {
	if (!entries || entries.length === 0) {
		return <div className="card"><p>Derzeit sind keine Termine geplant.</p></div>;
	}

	const sortedEntries = [...entries].sort((a, b) => parseISO(a.start) - parseISO(b.start));

	return (
		<ul className="termin-list">
			{sortedEntries.map(entry => (
				<li key={`${entry.type}-${entry.id}`}>
					<Link to={entry.url} className="termin-item-link">
						<div className="termin-item">
							<div className="termin-date">
								<span className="termin-date-day">{format(parseISO(entry.start), 'dd')}</span>
								<span className="termin-date-month">{format(parseISO(entry.start), 'MMM', { locale: de })}</span>
							</div>
							<div className="termin-details">
								<span className="termin-title">{entry.title}</span>
								<span className={`status-badge ${entry.type === 'Event' ? 'termin-type-event' : 'termin-type-lehrgang'}`}>
									{entry.type}
								</span>
							</div>
							<div className="termin-arrow">
								<i className="fas fa-chevron-right"></i>
							</div>
						</div>
					</Link>
				</li>
			))}
		</ul>
	);
};

export default CalendarMobileView;
========================================================================
FILE: frontend\src\components\chat\ConversationList.css
========================================================================

.conversation-list-container {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.conversation-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.conversation-list-header h3 {
    margin: 0;
}

.conversation-actions {
    display: flex;
    gap: 0.5rem;
}

.conversation-list {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 0;
}

.conversation-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    text-decoration: none;
    color: var(--text-color);
    transition: background-color 0.2s;
}

.conversation-item:hover {
    background-color: var(--bg-color);
}

.conversation-item.active {
    background-color: var(--primary-color-light);
    border-right: 3px solid var(--primary-color);
}

.conversation-icon {
    font-size: 1.5rem;
    color: var(--text-muted-color);
}

.conversation-username {
    font-weight: 600;
    display: block;
}

.conversation-snippet {
    font-size: 0.9rem;
    color: var(--text-muted-color);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block;
}

.user-search-list {
    max-height: 50vh;
    overflow-y: auto;
}

.user-search-item {
    padding: 0.75rem 1rem;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.user-search-item:hover {
    background-color: var(--bg-color);
}

.loading-text, .empty-conversations-message {
    padding: 2rem 1rem;
    text-align: center;
    color: var(--text-muted-color);
}
========================================================================
FILE: frontend\src\components\chat\ConversationList.jsx
========================================================================

import React, { useCallback, useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import './ConversationList.css';
import Modal from '../ui/Modal';
import GroupChatModal from './GroupChatModal';
import { useToast } from '../../context/ToastContext';

const UserSearchModal = ({ isOpen, onClose, onSelectUser }) => {
	const { data: users, loading } = useApi(useCallback(() => apiClient.get('/users'), []));

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neues Gespräch starten">
			<div className="user-search-list">
				{loading && <p>Lade Benutzer...</p>}
				{users?.map(user => (
					<div key={user.id} className="user-search-item" onClick={() => onSelectUser(user.id)}>
						{user.username}
					</div>
				))}
			</div>
		</Modal>
	);
};


const ConversationList = ({ selectedConversationId }) => {
	const apiCall = useCallback(() => apiClient.get('/public/chat/conversations'), []);
	const { data: conversations, loading, error, reload } = useApi(apiCall);
	const [isUserSearchModalOpen, setIsUserSearchModalOpen] = useState(false);
	const [isGroupChatModalOpen, setIsGroupChatModalOpen] = useState(false);
	const navigate = useNavigate();
	const { addToast } = useToast();

	const handleSelectUser = async (userId) => {
		setIsUserSearchModalOpen(false);
		try {
			const result = await apiClient.post('/public/chat/conversations', { userId });
			if (result.success && result.data.conversationId) {
				navigate(`/chat/${result.data.conversationId}`);
			} else {
				throw new Error(result.message || 'Gespräch konnte nicht gestartet werden.');
			}
		} catch (err) {
			addToast(err.message, 'error');
		}
	};

	const handleCreateGroup = async (name, participantIds) => {
		setIsGroupChatModalOpen(false);
		try {
			const result = await apiClient.post('/public/chat/conversations/group', { name, participantIds });
			if (result.success && result.data.conversationId) {
				addToast('Gruppe erfolgreich erstellt!', 'success');
				reload();
				navigate(`/chat/${result.data.conversationId}`);
			} else {
				throw new Error(result.message || 'Gruppe konnte nicht erstellt werden.');
			}
		} catch (err) {
			addToast(err.message, 'error');
		}
	};

	return (
		<div className="conversation-list-container">
			<div className="conversation-list-header">
				<h3>Gespräche</h3>
				<div className="conversation-actions">
					<button onClick={() => setIsUserSearchModalOpen(true)} className="btn btn-small" title="Neues Einzelgespräch">
						<i className="fas fa-user-plus"></i>
					</button>
					<button onClick={() => setIsGroupChatModalOpen(true)} className="btn btn-small" title="Neue Gruppe">
						<i className="fas fa-users"></i>
					</button>
				</div>
			</div>
			<div className="conversation-list">
				{loading && <p className="loading-text">Lade Gespräche...</p>}
				{error && <p className="error-message">{error}</p>}
				{!loading && conversations?.length === 0 && (
					<div className="empty-conversations-message">
						<p>Keine Gespräche vorhanden.</p>
						<p>Starte ein neues Gespräch oder eine neue Gruppe!</p>
					</div>
				)}
				{conversations?.map(conv => (
					<Link to={`/chat/${conv.id}`} key={conv.id} className={`conversation-item ${conv.id.toString() === selectedConversationId ? 'active' : ''}`}>
						<div className="conversation-icon">
							<i className={`fas ${conv.groupChat ? 'fa-users' : 'fa-user'}`}></i>
						</div>
						<div className="conversation-details">
							<span className="conversation-username">{conv.groupChat ? conv.name : conv.otherParticipantUsername}</span>
							<span className="conversation-snippet">{conv.lastMessage}</span>
						</div>
					</Link>
				))}
			</div>
			{isUserSearchModalOpen && <UserSearchModal isOpen={isUserSearchModalOpen} onClose={() => setIsUserSearchModalOpen(false)} onSelectUser={handleSelectUser} />}
			{isGroupChatModalOpen && <GroupChatModal isOpen={isGroupChatModalOpen} onClose={() => setIsGroupChatModalOpen(false)} onCreateGroup={handleCreateGroup} />}
		</div>
	);
};

export default ConversationList;
========================================================================
FILE: frontend\src\components\chat\GroupChatModal.css
========================================================================

.user-selection-list {
	max-height: 40vh;
	overflow-y: auto;
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	padding: 0.5rem;
}

.user-selection-item {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0.5rem;
	cursor: pointer;
	border-radius: 4px;
}

.user-selection-item:hover {
	background-color: var(--bg-color);
}

.user-selection-item input {
	width: 1.2rem;
	height: 1.2rem;
}

.participant-list {
	list-style: none;
	padding: 0;
	margin: 0.5rem 0;
	max-height: 20vh;
	overflow-y: auto;
}

.participant-list li {
	padding: 0.25rem 0;
}
========================================================================
FILE: frontend\src\components\chat\GroupChatModal.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../ui/Modal';
import './GroupChatModal.css';

const GroupChatModal = ({ isOpen, onClose, onCreateGroup }) => {
	const { data: users, loading } = useApi(useCallback(() => apiClient.get('/users'), []));
	const [groupName, setGroupName] = useState('');
	const [selectedUsers, setSelectedUsers] = useState(new Set());

	const handleToggleUser = (userId) => {
		setSelectedUsers(prev => {
			const newSet = new Set(prev);
			if (newSet.has(userId)) {
				newSet.delete(userId);
			} else {
				newSet.add(userId);
			}
			return newSet;
		});
	};

	const handleSubmit = () => {
		if (groupName && selectedUsers.size > 0) {
			onCreateGroup(groupName, Array.from(selectedUsers));
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Gruppe erstellen">
			<div className="form-group">
				<label htmlFor="group-name">Gruppenname</label>
				<input
					type="text"
					id="group-name"
					value={groupName}
					onChange={(e) => setGroupName(e.target.value)}
					placeholder="Name der neuen Gruppe"
				/>
			</div>
			<h4>Mitglieder auswählen</h4>
			<div className="user-selection-list">
				{loading && <p>Lade Benutzer...</p>}
				{users?.map(user => (
					<label key={user.id} className="user-selection-item">
						<input
							type="checkbox"
							checked={selectedUsers.has(user.id)}
							onChange={() => handleToggleUser(user.id)}
						/>
						{user.username}
					</label>
				))}
			</div>
			<div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
				<button className="btn" onClick={handleSubmit} disabled={!groupName || selectedUsers.size === 0}>
					Gruppe erstellen
				</button>
			</div>
		</Modal>
	);
};

export default GroupChatModal;
========================================================================
FILE: frontend\src\components\chat\ManageParticipantsModal.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../ui/Modal';
import './GroupChatModal.css'; // Reuse styles

const ManageParticipantsModal = ({ isOpen, onClose, onAddUsers, conversation }) => {
	const { data: allUsers, loading } = useApi(useCallback(() => apiClient.get('/users'), []));
	const [selectedUsers, setSelectedUsers] = useState(new Set());

	const existingParticipantIds = new Set(conversation.participants.map(p => p.id));
	const usersToAdd = allUsers?.filter(u => !existingParticipantIds.has(u.id));

	const handleToggleUser = (userId) => {
		setSelectedUsers(prev => {
			const newSet = new Set(prev);
			if (newSet.has(userId)) {
				newSet.delete(userId);
			} else {
				newSet.add(userId);
			}
			return newSet;
		});
	};

	const handleSubmit = () => {
		if (selectedUsers.size > 0) {
			onAddUsers(Array.from(selectedUsers));
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={`"${conversation.name}" verwalten`}>
			<h4>Aktuelle Mitglieder</h4>
			<ul className="participant-list">
				{conversation.participants.map(p => <li key={p.id}>{p.username}</li>)}
			</ul>
			<hr />
			<h4>Mitglieder hinzufügen</h4>
			<div className="user-selection-list">
				{loading && <p>Lade Benutzer...</p>}
				{usersToAdd?.length === 0 && <p>Alle Benutzer sind bereits in dieser Gruppe.</p>}
				{usersToAdd?.map(user => (
					<label key={user.id} className="user-selection-item">
						<input
							type="checkbox"
							checked={selectedUsers.has(user.id)}
							onChange={() => handleToggleUser(user.id)}
						/>
						{user.username}
					</label>
				))}
			</div>
			<div style={{ marginTop: '1.5rem', display: 'flex', justifyContent: 'flex-end' }}>
				<button className="btn" onClick={handleSubmit} disabled={selectedUsers.size === 0}>
					Ausgewählte hinzufügen
				</button>
			</div>
		</Modal>
	);
};

export default ManageParticipantsModal;
========================================================================
FILE: frontend\src\components\chat\MessageStatus.jsx
========================================================================

import React from 'react';

const MessageStatus = ({ status, isSentByMe }) => {
	if (!isSentByMe) {
		return null;
	}

	const statusIcon = () => {
		switch (status) {
			case 'SENT':
				return <i className="fas fa-check" title="Gesendet"></i>;
			case 'DELIVERED':
				// For simplicity, we'll treat SENT as DELIVERED visually until READ.
				// A true DELIVERED state would require more complex server-side presence tracking.
				return <i className="fas fa-check-double" title="Zugestellt"></i>;
			case 'READ':
				return <i className="fas fa-check-double" style={{ color: 'var(--info-color)' }} title="Gelesen"></i>;
			default:
				return <i className="fas fa-check" title="Gesendet"></i>;
		}
	};

	return (
		<span className="message-status">
			{statusIcon()}
		</span>
	);
};

export default MessageStatus;
========================================================================
FILE: frontend\src\components\chat\MessageView.css
========================================================================

.message-view-container {
	display: flex;
	flex-direction: column;
	height: 100%;
}

.message-view-header {
	display: flex; /* Always display header */
	align-items: center;
	gap: 1rem;
	padding: 0.75rem 1rem;
	border-bottom: 1px solid var(--border-color);
	flex-shrink: 0;
}

.message-view-header .back-button {
	display: none; /* Hide back button on desktop */
	font-size: 1.2rem;
	color: var(--text-color);
}

.message-view-header h3 {
	margin: 0;
	font-size: 1.1rem;
	flex-grow: 1;
}

.manage-members-btn {
	padding: 0.3rem 0.6rem;
}

.message-list {
	flex-grow: 1;
	overflow-y: auto;
	padding: 1rem;
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
}

.message-bubble-container {
	display: flex;
	max-width: 70%;
	position: relative;
    align-items: center;
}

.message-bubble-container.sent {
	align-self: flex-end;
	justify-content: flex-end;
    flex-direction: row-reverse;
}

.message-bubble-container.received {
	align-self: flex-start;
	justify-content: flex-start;
}

.message-bubble {
	padding: 0.6rem 1rem;
	border-radius: 18px;
	word-break: break-word;
	line-height: 1.4;
    position: relative;
    padding-bottom: 1.5rem; /* Make space for timestamp and status */
    min-width: 80px; /* Ensure space for metadata */
}

.message-sender {
	font-weight: 600;
	font-size: 0.8rem;
	margin-bottom: 0.2rem;
	color: var(--primary-color-light);
}

.message-bubble-container.sent .message-sender {
	display: none;
}

.message-bubble-container.received .message-sender {
	color: var(--primary-color);
}

.message-bubble-container.sent .message-bubble {
	background-color: var(--primary-color);
	color: #fff;
	border-bottom-right-radius: 4px;
}

.message-bubble-container.received .message-bubble {
	background-color: var(--bg-color);
	border: 1px solid var(--border-color);
	border-bottom-left-radius: 4px;
}

.message-meta {
    position: absolute;
    bottom: 0.3rem;
    right: 0.8rem;
    font-size: 0.75rem;
    color: var(--text-muted-color);
    display: flex;
    align-items: center;
    gap: 0.3rem;
}

.message-bubble-container.sent .message-meta {
    color: rgba(255, 255, 255, 0.7);
}

.chat-options {
    display: flex;
    opacity: 0; /* Hidden by default */
    transition: opacity 0.2s;
    background-color: var(--surface-color);
    padding: 0.25rem;
    border-radius: 20px;
    box-shadow: var(--shadow-sm);
    border: 1px solid var(--border-color);
    margin: 0 0.5rem;
}

.message-bubble-container:hover .chat-options,
.message-bubble-container.options-visible .chat-options {
    opacity: 1; /* Show on hover or if active */
}

.chat-option-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--text-muted-color);
    width: 28px;
    height: 28px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s, color 0.2s;
}

.chat-option-btn:hover {
    background-color: var(--bg-color);
    color: var(--text-color);
}


.message-input-container {
	padding: 1rem;
	border-top: 1px solid var(--border-color);
	background-color: var(--surface-color);
	flex-shrink: 0;
}

.message-input-form {
	display: flex;
	gap: 0.5rem;
}

.message-input {
	flex-grow: 1;
	border: 1px solid var(--border-color);
	border-radius: 20px;
	padding: 0.6rem 1rem;
	background-color: var(--bg-color);
	color: var(--text-color);
}

.message-input:focus {
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 3px var(--primary-color-light);
}

@media ( max-width : 991.98px) {
	.message-view-header .back-button {
		display: block;
	}
}
========================================================================
FILE: frontend\src\components\chat\MessageView.jsx
========================================================================

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Link, useParams } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import useWebSocket from '../../hooks/useWebSocket';
import apiClient from '../../services/apiClient';
import { useAuthStore } from '../../store/authStore';
import ManageParticipantsModal from './ManageParticipantsModal';
import MessageStatus from './MessageStatus';
import './MessageView.css';
import { useToast } from '../../context/ToastContext';

const MessageView = ({ conversationId }) => {
	const user = useAuthStore(state => state.user);
	const messagesEndRef = useRef(null);
	const fileInputRef = useRef(null);
	const longPressTimer = useRef();
	const [newMessage, setNewMessage] = useState('');
	const [messages, setMessages] = useState([]);
	const [conversation, setConversation] = useState(null);
	const [isManageModalOpen, setIsManageModalOpen] = useState(false);
	const [isUploading, setIsUploading] = useState(false);
	const [editingMessageId, setEditingMessageId] = useState(null);
	const [editingText, setEditingText] = useState('');
	const [activeOptionsMessageId, setActiveOptionsMessageId] = useState(null);
	const { addToast } = useToast();


	const messagesApiCall = useCallback(() => apiClient.get(`/public/chat/conversations/${conversationId}/messages`), [conversationId]);
	const { data: initialMessages, loading: messagesLoading, error: messagesError, reload: reloadMessages } = useApi(messagesApiCall);

	const conversationApiCall = useCallback(() => apiClient.get(`/public/chat/conversations/${conversationId}`), [conversationId]);
	const { data: currentConversation, reload: reloadConversation } = useApi(conversationApiCall);

	useEffect(() => {
		if (currentConversation) {
			setConversation(currentConversation);
		}
	}, [currentConversation]);

	const handleWebSocketMessage = useCallback((message) => {
		if (message.type === 'new_message') {
			setMessages(prev => [message.payload, ...prev]);
		} else if (message.type === 'messages_status_updated') {
			const { messageIds, newStatus } = message.payload;
			setMessages(prev => prev.map(msg =>
				messageIds.includes(msg.id) ? { ...msg, status: newStatus } : msg
			));
		} else if (message.type === 'message_updated' || message.type === 'message_deleted') {
			setMessages(prev => prev.map(msg =>
				msg.id === message.payload.id ? message.payload : msg
			));
		}
	}, []);

	const websocketUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/dm/${conversationId}`;
	const { sendMessage } = useWebSocket(websocketUrl, handleWebSocketMessage);

	useEffect(() => {
		if (initialMessages) {
			setMessages(initialMessages);
		}
	}, [initialMessages]);

	useEffect(() => {
		// When messages load or a new one arrives, check for unread messages to mark as read
		const unreadMessageIds = messages
			.filter(msg => msg.senderId !== user.id && msg.status !== 'READ')
			.map(msg => msg.id);

		if (unreadMessageIds.length > 0) {
			sendMessage({ type: 'mark_as_read', payload: { messageIds: unreadMessageIds } });
		}
	}, [messages, user.id, sendMessage]);

	useEffect(() => {
		messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
	}, [messages]);

	const handleSubmit = (e) => {
		e.preventDefault();
		if (newMessage.trim()) {
			sendMessage({ type: 'new_message', messageText: newMessage });
			setNewMessage('');
		}
	};

	const handleFileUpload = async (event) => {
		const file = event.target.files[0];
		if (!file) return;

		setIsUploading(true);
		const formData = new FormData();
		formData.append('file', file);

		try {
			const result = await apiClient.post('/public/chat/upload', formData);
			if (result.success) {
				const fileUrl = `/api/v1/public/files/download/${result.data.id}`;
				const messageText = `Datei hochgeladen: [${result.data.filename}](${fileUrl})`;
				sendMessage({ type: 'new_message', messageText });
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || 'Datei-Upload fehlgeschlagen.', 'error');
		} finally {
			setIsUploading(false);
		}
	};

	const renderMessageContent = (msg) => {
		const text = msg.messageText;
		const isSentByMe = msg.senderId === user.id;
		const imageRegex = /\[(.*?)\]\((.*?)\.(png|jpg|jpeg|gif)\)/i;
		const match = text.match(imageRegex);

		if (match) {
			const altText = match[1];
			const imageUrl = match[2] + '.' + match[3];
			return <img src={imageUrl} alt={altText} style={{ maxWidth: '100%', borderRadius: '12px' }} />;
		}

		const fileRegex = /\[(.*?)\]\((.*?)\)/;
		const fileMatch = text.match(fileRegex);

		if (fileMatch) {
			const fileName = fileMatch[1];
			const fileUrl = fileMatch[2];
			return <a href={fileUrl} target="_blank" rel="noopener noreferrer" style={{ color: isSentByMe ? '#fff' : '#000' }}><i className="fas fa-file-alt"></i> {fileName}</a>;
		}

		return text;
	};

	const handleEditClick = (msg) => {
		setEditingMessageId(msg.id);
		setEditingText(msg.messageText);
	};

	const handleCancelEdit = () => {
		setEditingMessageId(null);
		setEditingText('');
	};

	const handleEditSubmit = () => {
		if (editingText.trim()) {
			sendMessage({
				type: 'update_message',
				payload: { messageId: editingMessageId, newText: editingText }
			});
			handleCancelEdit();
		}
	};

	const handleDeleteClick = (msg) => {
		if (window.confirm('Nachricht wirklich löschen?')) {
			sendMessage({
				type: 'delete_message',
				payload: { messageId: msg.id }
			});
		}
	};

	const handleTouchStart = (messageId) => {
		longPressTimer.current = setTimeout(() => {
			setActiveOptionsMessageId(messageId);
		}, 500); // 500ms for a long press
	};

	const handleTouchEnd = () => {
		clearTimeout(longPressTimer.current);
	};

	const handleTouchMove = () => {
		clearTimeout(longPressTimer.current);
	};


	const handleAddUsers = async (userIds) => {
		setIsManageModalOpen(false);
		try {
			const result = await apiClient.post(`/public/chat/conversations/${conversationId}/participants`, { userIds });
			if (result.success) {
				addToast('Mitglieder erfolgreich hinzugefügt.', 'success');
				reloadConversation();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message, 'error');
		}
	};

	const getHeaderText = () => {
		if (!conversation) return 'Lade...';
		if (conversation.groupChat) return conversation.name;

		// Find the other participant in a 1-on-1 chat
		const otherParticipant = conversation.participants?.find(p => p.id !== user.id);
		return otherParticipant ? otherParticipant.username : 'Unbekannt';
	};

	return (
		<div className="message-view-container" onClick={() => setActiveOptionsMessageId(null)}>
			<div className="message-view-header">
				<Link to="/chat" className="back-button">
					<i className="fas fa-arrow-left"></i>
				</Link>
				<h3>{getHeaderText()}</h3>
				{conversation?.groupChat && conversation.creatorId === user.id && (
					<button onClick={() => setIsManageModalOpen(true)} className="btn btn-small manage-members-btn" title="Mitglieder verwalten">
						<i className="fas fa-user-plus"></i>
					</button>
				)}
			</div>
			<div className="message-list">
				{messagesLoading && <p>Lade Nachrichten...</p>}
				{messagesError && <p className="error-message">{messagesError}</p>}
				{[...messages].reverse().map(msg => {
					const isSentByMe = msg.senderId === user.id;
					const isMessageEditable = () => {
						if (!msg.sentAt) return false;
						const sentAt = new Date(msg.sentAt);
						const now = new Date();
						return (now - sentAt) < 24 * 60 * 60 * 1000; // 24 hours in milliseconds
					};
					const canEdit = !msg.isDeleted && isSentByMe && isMessageEditable();
					const canDelete = !msg.isDeleted && (isSentByMe || (conversation?.groupChat && conversation.creatorId === user.id));
					const isEditing = editingMessageId === msg.id;
					return (
						<div
							key={msg.id}
							className={`message-bubble-container ${isSentByMe ? 'sent' : 'received'} ${activeOptionsMessageId === msg.id ? 'options-visible' : ''}`}
							onTouchStart={() => handleTouchStart(msg.id)}
							onTouchEnd={handleTouchEnd}
							onTouchMove={handleTouchMove}
							onClick={(e) => { if (activeOptionsMessageId) e.stopPropagation() }}
						>
							<div
								className="message-bubble"
								style={!isSentByMe ? { backgroundColor: msg.chatColor } : {}}
							>
								{!isSentByMe && !msg.isDeleted && <div className="message-sender">{msg.senderUsername}</div>}
								{msg.isDeleted ? (
									<em style={{ opacity: 0.7 }}>
										Diese Nachricht wurde von {msg.deletedByUsername || "einem Nutzer"} gelöscht.
										<div className="message-meta" style={{ justifyContent: 'flex-end', width: '100%' }}>
											{new Date(msg.deletedAt).toLocaleString('de-DE')}
										</div>
									</em>
								) : isEditing ? (
									<div>
										<textarea value={editingText} onChange={(e) => setEditingText(e.target.value)} className="chat-edit-input" autoFocus />
										<div style={{ marginTop: '0.5rem', display: 'flex', gap: '0.5rem' }}>
											<button onClick={handleEditSubmit} className="btn btn-small btn-success">Speichern</button>
											<button onClick={handleCancelEdit} className="btn btn-small btn-secondary">Abbrechen</button>
										</div>
									</div>
								) : (
									<>
										{renderMessageContent(msg)}
										<div className="message-meta">
											<span>{new Date(msg.sentAt).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}</span>
											{msg.edited && <em style={{ opacity: 0.8 }} title={`Bearbeitet am ${new Date(msg.editedAt).toLocaleString('de-DE')}`}>(bearbeitet)</em>}
											<MessageStatus status={msg.status} isSentByMe={isSentByMe} />
										</div>
									</>
								)}
							</div>
							{!msg.isDeleted && !isEditing && (canEdit || canDelete) && (
								<div className="chat-options">
									{canEdit && <button onClick={() => handleEditClick(msg)} className="chat-option-btn" title="Bearbeiten"><i className="fas fa-pencil-alt"></i></button>}
									{canDelete && <button onClick={() => handleDeleteClick(msg)} className="chat-option-btn" title="Löschen"><i className="fas fa-trash"></i></button>}
								</div>
							)}
						</div>
					)
				})}
				<div ref={messagesEndRef} />
			</div>
			<div className="message-input-container">
				<form onSubmit={handleSubmit} className="message-input-form">
					<input
						type="file"
						ref={fileInputRef}
						onChange={handleFileUpload}
						style={{ display: 'none' }}
						accept="image/*,application/pdf"
					/>
					<button type="button" className="btn" onClick={() => fileInputRef.current.click()} disabled={isUploading} title="Datei anhängen">
						{isUploading ? <i className="fas fa-spinner fa-spin"></i> : <i className="fas fa-paperclip"></i>}
					</button>
					<input
						type="text"
						value={newMessage}
						onChange={(e) => setNewMessage(e.target.value)}
						placeholder="Nachricht schreiben..."
						className="message-input"
					/>
					<button type="submit" className="btn">Senden</button>
				</form>
			</div>
			{isManageModalOpen && conversation && (
				<ManageParticipantsModal
					isOpen={isManageModalOpen}
					onClose={() => setIsManageModalOpen(false)}
					onAddUsers={handleAddUsers}
					conversation={conversation}
				/>
			)}
		</div>
	);
};

export default MessageView;
========================================================================
FILE: frontend\src\components\events\ChecklistTab.jsx
========================================================================

import React, { useState, useCallback, useEffect } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import useWebSocket from '../../hooks/useWebSocket'; // Assuming you have a generic WS hook

const ChecklistTab = ({ event, user }) => {
	const { addToast } = useToast();
	const [checklistItems, setChecklistItems] = useState([]);

	const checklistApiCall = useCallback(() => apiClient.get(`/events/${event.id}/checklist`), [event.id]);
	const { data: initialItems, loading, error, reload } = useApi(checklistApiCall);

	useEffect(() => {
		if (initialItems) {
			setChecklistItems(initialItems);
		}
	}, [initialItems]);

	const handleStatusUpdate = (updatedItem) => {
		setChecklistItems(currentItems =>
			currentItems.map(item => item.id === updatedItem.id ? updatedItem : item)
		);
	};

	// Setup WebSocket for real-time updates
	const websocketUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/checklist/${event.id}`;
	useWebSocket(websocketUrl, (message) => {
		if (message.type === 'checklist_update') {
			handleStatusUpdate(message.payload);
		}
	});


	const handleStatusChange = async (itemId, newStatus) => {
		try {
			const result = await apiClient.put(`/events/${event.id}/checklist/${itemId}/status`, { status: newStatus });
			if (!result.success) { // WebSocket will handle the success update
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Aktualisieren: ${err.message}`, 'error');
		}
	};

	const handleGenerateChecklist = async () => {
		try {
			const result = await apiClient.post(`/events/${event.id}/checklist/generate`);
			if (result.success) {
				addToast('Checkliste erfolgreich aus Reservierungen generiert.', 'success');
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler: ${err.message}`, 'error');
		}
	};

	if (loading) return <p>Lade Checkliste...</p>;
	if (error) return <p className="error-message">{error}</p>;

	return (
		<div>
			<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
				<p>Haken Sie Artikel beim Ein- und Ausladen ab, um den Überblick zu behalten.</p>
				<button onClick={handleGenerateChecklist} className="btn btn-secondary">
					<i className="fas fa-sync"></i> Liste aus Reservierungen generieren
				</button>
			</div>

			<div className="table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Artikel</th>
							<th>Menge</th>
							<th>Status</th>
							<th>Zuletzt geändert</th>
						</tr>
					</thead>
					<tbody>
						{checklistItems.length === 0 ? (
							<tr><td colSpan="4">Keine Artikel auf der Checkliste. Generieren Sie eine aus den Materialreservierungen.</td></tr>
						) : (
							checklistItems.map(item => (
								<tr key={item.id}>
									<td>{item.itemName}</td>
									<td>{item.quantity}</td>
									<td>
										<select
											value={item.status}
											onChange={(e) => handleStatusChange(item.id, e.target.value)}
											className="form-group"
											style={{ marginBottom: 0 }}
										>
											<option value="PENDING">Ausstehend</option>
											<option value="PACKED_OUT">Eingepackt (Load-Out)</option>
											<option value="RETURNED_CHECKED">Zurück & OK</option>
											<option value="RETURNED_DEFECT">Zurück & Defekt</option>
										</select>
									</td>
									<td>{item.lastUpdatedByUsername || 'N/A'} am {new Date(item.lastUpdatedAt).toLocaleTimeString('de-DE')}</td>
								</tr>
							))
						)}
					</tbody>
				</table>
			</div>
		</div>
	);
};

export default ChecklistTab;
========================================================================
FILE: frontend\src\components\layout\ErrorLayout.jsx
========================================================================

import React, { useEffect } from 'react';
import { Outlet } from 'react-router-dom';
import { useAuthStore } from '../../store/authStore';

const ErrorLayout = ({ children }) => {
	// Attempt to get the user's theme. Fallback to localStorage or light theme.
	const userTheme = useAuthStore.getState().user?.theme;

	useEffect(() => {
		const savedTheme = userTheme || localStorage.getItem('theme') || 'light';
		document.documentElement.setAttribute('data-theme', savedTheme);
		// Add a class to the body for specific error page styling if needed
		document.body.classList.add('error-page-active');

		// Cleanup function to remove the class when the component unmounts
		return () => {
			document.body.classList.remove('error-page-active');
		};
	}, [userTheme]);

	return (
		// The wrapper no longer centers content by default.
		// It now provides a full-page container for its children.
		<div className="error-page-wrapper">
			{children || <Outlet />}
		</div>
	);
};

export default ErrorLayout;
========================================================================
FILE: frontend\src\components\layout\Header.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
import { useAuthStore } from '../../store/authStore';

const Header = ({ onNavToggle }) => {
	const user = useAuthStore(state => state.user);

	return (
		<header className="mobile-header">
			<button className="mobile-nav-toggle" aria-label="Navigation umschalten" onClick={onNavToggle}>
				<span className="line line-1"></span>
				<span className="line line-2"></span>
				<span className="line line-3"></span>
			</button>
			<Link to="/home" className="mobile-logo">TechnikTeam</Link>
			<div className="mobile-header-right">
				<Link to="/profil">
					<i className={`fas ${user?.profileIconClass || 'fa-user-circle'}`} style={{ fontSize: '1.5rem', color: 'var(--text-color)' }}></i>
				</Link>
			</div>
		</header>
	);
};

export default Header;
========================================================================
FILE: frontend\src\components\layout\MinimalLayout.jsx
========================================================================

import React from 'react';
import { Outlet } from 'react-router-dom';

/**
 * A minimal layout component for pages that should not have the main sidebar and header,
 * such as printable views or QR code landing pages.
 */
const MinimalLayout = () => {
	return (
		<div className="main-content" style={{ maxWidth: '800px', margin: '2rem auto' }}>
			<Outlet />
		</div>
	);
};

export default MinimalLayout;
========================================================================
FILE: frontend\src\components\layout\Sidebar.jsx
========================================================================

import React, { useState } from 'react';
import { NavLink, useNavigate } from 'react-router-dom';
import { useAuthStore } from '../../store/authStore';
import ThemeSwitcher from '../ui/ThemeSwitcher';

const Sidebar = () => {
	const { user, navigationItems, logout } = useAuthStore();
	const [searchTerm, setSearchTerm] = useState('');
	const navigate = useNavigate();

	if (!user || !navigationItems) {
		return null;
	}

	const handleSearchSubmit = (e) => {
		e.preventDefault();
		if (searchTerm.trim()) {
			navigate(`/suche?q=${encodeURIComponent(searchTerm.trim())}`);
			setSearchTerm('');
		}
	};

	const userNavItems = navigationItems.filter(item => item.requiredPermission === null);
	const adminNavItems = navigationItems.filter(item => item.requiredPermission !== null);

	const handleLogout = () => {
		logout();
	};

	const renderNavItem = (item) => {
		if (item.url.startsWith('/swagger-ui.html')) {
			return (
				<a href={item.url} target="_blank" rel="noopener noreferrer">
					<i className={`fas ${item.icon} fa-fw`}></i> {item.label}
				</a>
			);
		}
		return (
			<NavLink to={item.url} className={({ isActive }) => isActive ? 'active-nav-link' : ''}>
				<i className={`fas ${item.icon} fa-fw`}></i> {item.label}
			</NavLink>
		);
	};

	return (
		<aside className="sidebar">
			<header className="sidebar-header">
				<a href="/home" className="logo">
					<i className="fas fa-bolt"></i> TechnikTeam
				</a>
			</header>
			<div style={{ padding: '0 1rem', marginBottom: '0.5rem' }}>
				<form onSubmit={handleSearchSubmit}>
					<div className="form-group" style={{ position: 'relative', marginBottom: 0 }}>
						<input
							type="search"
							placeholder="Suchen..."
							value={searchTerm}
							onChange={(e) => setSearchTerm(e.target.value)}
							style={{ paddingLeft: '2.5rem' }}
						/>
						<i className="fas fa-search" style={{ position: 'absolute', left: '1rem', top: '50%', transform: 'translateY(-50%)', color: 'var(--text-muted-color)' }}></i>
					</div>
				</form>
			</div>
			<nav className="sidebar-nav">
				<ul>
					{userNavItems.length > 0 && <li className="nav-section-title">Benutzerbereich</li>}
					{userNavItems.map(item => (
						<li key={`${item.label}-${item.url}`}>
							{renderNavItem(item)}
						</li>
					))}

					{adminNavItems.length > 0 && <li className="nav-section-title">Admin-Bereich</li>}
					{adminNavItems.map(item => (
						<li key={`${item.label}-${item.url}`}>
							{renderNavItem(item)}
						</li>
					))}
				</ul>
			</nav>
			<div className="user-actions">
				<div className="user-info">
					Angemeldet als: <strong>{user.username}</strong>
				</div>
				<div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
					<NavLink to="/profil" className="btn btn-secondary btn-small" style={{ flexGrow: 1 }}>Profil</NavLink>
					<button onClick={handleLogout} className="btn btn-danger-outline btn-small" style={{ flexGrow: 1 }}>Logout</button>
					<ThemeSwitcher />
				</div>
			</div>
		</aside>
	);
};

export default Sidebar;
========================================================================
FILE: frontend\src\components\profile\ProfileAchievements.jsx
========================================================================

import React from 'react';

const ProfileAchievements = ({ achievements }) => {
	return (
		<div className="card" style={{ gridColumn: '1 / -1' }} id="profile-achievements-container">
			<h2 className="card-title">Meine Abzeichen</h2>
			{achievements.length === 0 ? (
				<p>Du hast noch keine Abzeichen verdient. Nimm an Events teil, um sie freizuschalten!</p>
			) : (
				<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
					{achievements.map(ach => (
						<div className="card" key={ach.id} style={{ flex: '1', minWidth: '250px', textAlign: 'center' }}>
							<i className={`fas ${ach.iconClass}`} style={{ fontSize: '3rem', color: 'var(--primary-color)', marginBottom: '1rem' }}></i>
							<h4 style={{ margin: 0 }}>{ach.name}</h4>
							<p style={{ color: 'var(--text-muted-color)', fontSize: '0.9rem' }}>{ach.description}</p>
							<small>Verdient am: {new Date(ach.earnedAt).toLocaleDateString('de-DE')}</small>
						</div>
					))}
				</div>
			)}
		</div>
	);
};

export default ProfileAchievements;
========================================================================
FILE: frontend\src\components\profile\ProfileDetails.jsx
========================================================================

import React, { useState } from 'react';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../ui/Modal';

const ConfirmationModal = ({ isOpen, onClose, onConfirm, changes, isSubmitting }) => {
	if (!isOpen) return null;

	const changeLabels = {
		email: 'E-Mail',
		classYear: 'Jahrgang',
		className: 'Klasse',
		profileIconClass: 'Profil-Icon'
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Änderungen bestätigen">
			<p>Bitte überprüfen Sie die folgenden Änderungen. Diese müssen von einem Administrator genehmigt werden.</p>
			<ul className="details-list" style={{ marginTop: '1rem', marginBottom: '1.5rem' }}>
				{Object.entries(changes).map(([key, values]) => (
					<li key={key}>
						<strong>{changeLabels[key] || key}</strong>
						<div>
							<span style={{ textDecoration: 'line-through', color: 'var(--danger-color)', marginRight: '0.5rem' }}>{values.oldVal || 'Nicht gesetzt'}</span>
							<span>→</span>
							<strong style={{ color: 'var(--success-color)', marginLeft: '0.5rem' }}>{values.newVal || 'Wird entfernt'}</strong>
						</div>
					</li>
				))}
			</ul>
			<div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
				<button type="button" onClick={onClose} className="btn btn-secondary" disabled={isSubmitting}>Abbrechen</button>
				<button type="button" onClick={onConfirm} className="btn btn-success" disabled={isSubmitting}>
					{isSubmitting ? 'Wird gesendet...' : 'Bestätigen & Senden'}
				</button>
			</div>
		</Modal>
	);
};


const ProfileDetails = ({ user, hasPendingRequest, onUpdate }) => {
	const [isEditing, setIsEditing] = useState(false);
	const [formData, setFormData] = useState({
		email: user.email || '',
		classYear: user.classYear || '',
		className: user.className || '',
		profileIconClass: user.profileIconClass || 'fa-user-circle',
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
	const [detectedChanges, setDetectedChanges] = useState({});

	const handleEditToggle = () => setIsEditing(!isEditing);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleCancel = () => {
		setFormData({
			email: user.email || '',
			classYear: user.classYear || '',
			className: user.className || '',
			profileIconClass: user.profileIconClass || 'fa-user-circle',
		});
		setIsEditing(false);
		setError('');
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setError('');

		const changes = {};
		if (formData.email !== (user.email || '')) {
			changes.email = { oldVal: user.email, newVal: formData.email };
		}
		if (formData.classYear.toString() !== (user.classYear || '').toString()) {
			changes.classYear = { oldVal: user.classYear, newVal: formData.classYear };
		}
		if (formData.className !== (user.className || '')) {
			changes.className = { oldVal: user.className, newVal: formData.className };
		}
		if (formData.profileIconClass !== (user.profileIconClass || '')) {
			changes.profileIconClass = { oldVal: user.profileIconClass, newVal: formData.profileIconClass };
		}

		if (Object.keys(changes).length === 0) {
			addToast('Keine Änderungen vorgenommen.', 'info');
			return;
		}

		setDetectedChanges(changes);
		setIsConfirmModalOpen(true);
	};

	const handleConfirmSubmit = async () => {
		setIsSubmitting(true);
		setError('');

		try {
			// No longer sending form data, just the JSON payload
			const result = await apiClient.post('/public/profile/request-change', formData);
			if (result.success) {
				addToast('Änderungsantrag erfolgreich eingereicht.', 'success');
				setIsEditing(false);
				setIsConfirmModalOpen(false);
				onUpdate();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Fehler beim Einreichen der Anfrage.');
			setIsConfirmModalOpen(false);
		} finally {
			setIsSubmitting(false);
		}
	};


	const handleColorSubmit = async (e) => {
		e.preventDefault();
		const newColor = e.target.elements.chatColor.value;
		try {
			const result = await apiClient.put('/public/profile/chat-color', { chatColor: newColor });
			if (result.success) {
				addToast('Chat-Farbe gespeichert', 'success');
				onUpdate();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || 'Fehler beim Speichern', 'error');
		}
	}

	return (
		<>
			<div className="card" id="profile-details-container">
				<div style={{ display: 'flex', alignItems: 'center', gap: '1rem', marginBottom: '1rem' }}>
					<i className={`fas ${user.profileIconClass || 'fa-user-circle'}`} style={{ fontSize: '80px', color: 'var(--text-muted-color)', width: '80px', textAlign: 'center' }}></i>
					<h2 className="card-title" style={{ border: 'none', padding: 0, margin: 0 }}>Stammdaten</h2>
				</div>

				{hasPendingRequest && (
					<div className="info-message"><i className="fas fa-info-circle"></i> Sie haben eine ausstehende Profiländerung.</div>
				)}
				{error && <div className="error-message">{error}</div>}
				<form onSubmit={handleSubmit}>
					<ul className="details-list">
						<li><strong>Benutzername:</strong> <span>{user.username}</span></li>
						<li><strong>Jahrgang:</strong> <input type="number" name="classYear" value={formData.classYear} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
						<li><strong>Klasse:</strong> <input type="text" name="className" value={formData.className} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
						<li><strong>E-Mail:</strong> <input type="email" name="email" value={formData.email} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
						{isEditing && (
							<li>
								<strong>Profil-Icon:</strong>
								<input type="text" name="profileIconClass" value={formData.profileIconClass} onChange={handleChange} placeholder="z.B. fa-user-ninja" />
							</li>
						)}
					</ul>
					{!hasPendingRequest && (
						<div style={{ marginTop: '1.5rem', display: 'flex', gap: '0.5rem' }}>
							{!isEditing ? (
								<button type="button" onClick={handleEditToggle} className="btn btn-secondary">Profil bearbeiten</button>
							) : (
								<>
									<button type="submit" className="btn btn-success" disabled={isSubmitting}>Änderungen überprüfen</button>
									<button type="button" onClick={handleCancel} className="btn" style={{ backgroundColor: 'var(--text-muted-color)' }}>Abbrechen</button>
								</>
							)}
						</div>
					)}
				</form>
				<hr style={{ margin: '1.5rem 0' }} />
				<ul className="details-list">
					<li style={{ alignItems: 'center', gap: '1rem' }}>
						<strong>Chat-Farbe:</strong>
						<form onSubmit={handleColorSubmit} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
							<input type="color" name="chatColor" defaultValue={user.chatColor || '#E9ECEF'} title="Wähle deine Chat-Farbe" />
							<button type="submit" className="btn btn-small">Speichern</button>
						</form>
					</li>
				</ul>
			</div>
			<ConfirmationModal
				isOpen={isConfirmModalOpen}
				onClose={() => setIsConfirmModalOpen(false)}
				onConfirm={handleConfirmSubmit}
				changes={detectedChanges}
				isSubmitting={isSubmitting}
			/>
		</>
	);
};

export default ProfileDetails;
========================================================================
FILE: frontend\src\components\profile\ProfileEventHistory.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';

const ProfileEventHistory = ({ eventHistory }) => {
	const formatDate = (dateString) => {
		if (!dateString) return '';
		return new Date(dateString).toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
	};

	return (
		<div className="card" style={{ gridColumn: '1 / -1' }} id="profile-history-container">
			<h2 className="card-title">Meine Event-Historie</h2>
			<div className="desktop-table-wrapper">
				<div className="table-wrapper" style={{ maxHeight: '500px', overflowY: 'auto' }}>
					<table className="data-table">
						<thead>
							<tr>
								<th>Event</th>
								<th>Datum</th>
								<th>Dein Status</th>
								<th>Feedback</th>
							</tr>
						</thead>
						<tbody>
							{eventHistory.length === 0 ? (
								<tr><td colSpan="4">Keine Event-Historie vorhanden.</td></tr>
							) : (
								eventHistory.map(event => (
									<tr key={event.id}>
										<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
										<td>{formatDate(event.eventDateTime)} Uhr</td>
										<td>{event.userAttendanceStatus}</td>
										<td>
											{event.status === 'ABGESCHLOSSEN' && event.userAttendanceStatus === 'ZUGEWIESEN' ? (
												<Link to={`/feedback/event/${event.id}`} className="btn btn-small">Feedback geben</Link>
											) : (
												<span className="text-muted">-</span>
											)}
										</td>
									</tr>
								))
							)}
						</tbody>
					</table>
				</div>
			</div>
		</div>
	);
};

export default ProfileEventHistory;
========================================================================
FILE: frontend\src\components\profile\ProfileQualifications.jsx
========================================================================

import React from 'react';

const ProfileQualifications = ({ qualifications }) => {
	return (
		<div className="card" id="profile-qualifications-container">
			<h2 className="card-title">Meine Qualifikationen</h2>
			<div className="table-wrapper" style={{ maxHeight: '400px', overflowY: 'auto' }}>
				<table className="data-table">
					<thead>
						<tr>
							<th>Lehrgang</th>
							<th>Status</th>
						</tr>
					</thead>
					<tbody>
						{qualifications.length === 0 ? (
							<tr><td colSpan="2">Keine Qualifikationen erworben.</td></tr>
						) : (
							qualifications.map(qual => (
								<tr key={qual.courseId}>
									<td>{qual.courseName}</td>
									<td>{qual.status}</td>
								</tr>
							))
						)}
					</tbody>
				</table>
			</div>
		</div>
	);
};

export default ProfileQualifications;
========================================================================
FILE: frontend\src\components\profile\ProfileSecurity.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
// REMOVED unused imports

const ProfileSecurity = ({ onUpdate }) => {
	// REMOVED all passkey-related state and handlers

	return (
		<div className="card" id="profile-security-container">
			<h2 className="card-title">Sicherheit</h2>
			<ul className="details-list">
				<li>
					<Link to="/passwort" className="btn btn-secondary">Passwort ändern</Link>
				</li>
			</ul>
			<h3 style={{ marginTop: '1.5rem', fontSize: '1.1rem' }}>Passkeys (Passwortloser Login)</h3>
			{/* REPLACED passkey logic with placeholder */}
			<p className="text-muted">
				Dieses Feature wird zurzeit überarbeitet und ist in Kürze wieder verfügbar.
			</p>
			<button className="btn btn-success" disabled={true} style={{ marginBottom: '1rem' }}>
				<i className="fas fa-plus-circle"></i> Neues Gerät registrieren
			</button>
		</div>
	);
};

export default ProfileSecurity;
========================================================================
FILE: frontend\src\components\storage\DamageReportModal.jsx
========================================================================

import React, { useState } from 'react';
import Modal from '../ui/Modal';
import apiClient from '../../services/apiClient';

const DamageReportModal = ({ isOpen, onClose, onSuccess, item }) => {
	const [description, setDescription] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		try {
			const result = await apiClient.post(`/public/storage/${item.id}/report-damage`, { description });
			if (result.success) {
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Meldung konnte nicht gesendet werden.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleClose = () => {
		setDescription('');
		setError('');
		setIsSubmitting(false);
		onClose();
	};

	return (
		<Modal isOpen={isOpen} onClose={handleClose} title={`Schaden für "${item?.name}" melden`}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<p>Bitte beschreiben Sie den Defekt so genau wie möglich. Ein Administrator wird die Meldung prüfen.</p>
				<div className="form-group">
					<label htmlFor="damage-description">Beschreibung des Schadens</label>
					<textarea
						id="damage-description"
						name="description"
						value={description}
						onChange={(e) => setDescription(e.target.value)}
						rows="5"
						required
					></textarea>
				</div>
				<div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem' }}>
					<button type="button" className="btn btn-secondary" onClick={handleClose} disabled={isSubmitting}>
						Abbrechen
					</button>
					<button type="submit" className="btn btn-danger" disabled={isSubmitting}>
						{isSubmitting ? 'Wird gesendet...' : 'Schaden melden'}
					</button>
				</div>
			</form>
		</Modal>
	);
};

export default DamageReportModal;
========================================================================
FILE: frontend\src\components\ui\ChangelogModal.jsx
========================================================================

import React from 'react';
import Modal from './Modal';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const ChangelogModal = ({ changelog, onClose }) => {
	return (
		<Modal isOpen={true} onClose={onClose} title={`Was ist neu in Version ${changelog.version}?`}>
			<h3>{changelog.title}</h3>
			<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
				Veröffentlicht am {new Date(changelog.releaseDate).toLocaleDateString('de-DE')}
			</p>
			<div className="markdown-content" style={{ maxHeight: '60vh', overflowY: 'auto' }}>
				<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
					{changelog.notes}
				</ReactMarkdown>
			</div>
			<div style={{ display: 'flex', justifyContent: 'flex-end', marginTop: '1.5rem' }}>
				<button onClick={onClose} className="btn">
					Verstanden!
				</button>
			</div>
		</Modal>
	);
};

export default ChangelogModal;
========================================================================
FILE: frontend\src\components\ui\Lightbox.jsx
========================================================================

import React, { useEffect } from 'react';

const Lightbox = ({ src, onClose }) => {
	useEffect(() => {
		const handleEscape = (event) => {
			if (event.key === 'Escape') {
				onClose();
			}
		};
		document.addEventListener('keydown', handleEscape);
		return () => {
			document.removeEventListener('keydown', handleEscape);
		};
	}, [onClose]);

	if (!src) {
		return null;
	}

	return (
		<div className="lightbox-overlay" style={{ display: 'flex' }} onClick={onClose}>
			<span className="lightbox-close" title="Schließen">×</span>
			<img
				className="lightbox-content"
				src={src}
				alt="Großansicht"
				onClick={(e) => e.stopPropagation()}
			/>
		</div>
	);
};

export default Lightbox;
========================================================================
FILE: frontend\src\components\ui\Modal.jsx
========================================================================

import React, { useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children }) => {
	useEffect(() => {
		const handleEscape = (event) => {
			if (event.key === 'Escape') {
				onClose();
			}
		};

		if (isOpen) {
			document.addEventListener('keydown', handleEscape);
		}

		return () => {
			document.removeEventListener('keydown', handleEscape);
		};
	}, [isOpen, onClose]);

	if (!isOpen) {
		return null;
	}

	return (
		<div className="modal-overlay active" onClick={onClose}>
			<div className="modal-content" onClick={(e) => e.stopPropagation()}>
				<button
					type="button"
					className="modal-close-btn"
					aria-label="Schließen"
					onClick={onClose}
				>
					×
				</button>
				{title && <h3>{title}</h3>}
				{children}
			</div>
		</div>
	);
};

export default Modal;
========================================================================
FILE: frontend\src\components\ui\StatusBadge.jsx
========================================================================

import React from 'react';

const StatusBadge = ({ status }) => {
	const getStatusClass = () => {
		const upperStatus = status?.toUpperCase() || '';
		switch (upperStatus) {
			case 'LAUFEND':
			case 'PENDING':
			case 'VIEWED':
			case 'PLANNED':
				return 'status-warn';
			case 'GEPLANT':
			case 'KOMPLETT':
			case 'ERLEDIGT':
			case 'APPROVED':
			case 'NEW':
				return 'status-ok';
			case 'ABGESCHLOSSEN':
			case 'ABGESAGT':
			case 'REJECTED':
			case 'COMPLETED':
				return 'status-info';
			default:
				return 'status-info';
		}
	};

	return <span className={`status-badge ${getStatusClass()}`}>{status}</span>;
};

export default StatusBadge;
========================================================================
FILE: frontend\src\components\ui\ThemeSwitcher.jsx
========================================================================

import React from 'react';
import { useAuthStore } from '../../store/authStore';

const ThemeSwitcher = () => {
	const { theme, setTheme } = useAuthStore();

	const toggleTheme = () => {
		const newTheme = theme === 'light' ? 'dark' : 'light';
		setTheme(newTheme);
	};

	return (
		<button
			onClick={toggleTheme}
			className="btn btn-secondary btn-small"
			title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
			style={{ padding: '0.4rem 0.6rem' }}
		>
			<i className={`fas ${theme === 'light' ? 'fa-moon' : 'fa-sun'}`}></i>
		</button>
	);
};

export default ThemeSwitcher;
========================================================================
FILE: frontend\src\components\ui\ToastContainer.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
import { useToast } from '../../context/ToastContext';

const Toast = ({ message, type, url, onHide }) => {
	const [visible, setVisible] = React.useState(false);

	React.useEffect(() => {
		setVisible(true);
		const timer = setTimeout(() => {
			setVisible(false);
			// Give time for fade out animation before removing from DOM
			setTimeout(onHide, 400);
		}, 4600);
		return () => clearTimeout(timer);
	}, [onHide]);


	const getTypeClass = () => {
		switch (type) {
			case 'success':
				return 'toast-success';
			case 'error':
				return 'toast-danger';
			default:
				return 'toast-info';
		}
	};

	const toastContent = (
		<div className={`toast ${visible ? 'show' : ''} ${getTypeClass()} ${url ? 'clickable' : ''}`}>
			{message}
			{url && <i className="fas fa-arrow-right" style={{ marginLeft: 'auto', paddingLeft: '1rem' }}></i>}
		</div>
	);

	if (url) {
		return <Link to={url} style={{ textDecoration: 'none' }}>{toastContent}</Link>
	}

	return toastContent;
};


const ToastContainer = () => {
	const { toasts } = useToast();

	const handleHide = (id) => {
		// The timeout in ToastProvider already handles removal.
		// This component just renders what's in the state.
	};

	return (
		<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 9999, display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
			{toasts.map(toast => (
				<Toast key={toast.id} message={toast.message} type={toast.type} url={toast.url} onHide={() => handleHide(toast.id)} />
			))}
		</div>
	);
};

export default ToastContainer;
========================================================================
FILE: frontend\src\components\ui\WarningNotification.jsx
========================================================================

import React, { useEffect, useState } from 'react';

const WarningNotification = ({ notification, onDismiss }) => {
	const [audio] = useState(new Audio('/attention.mp3'));

	useEffect(() => {
		// Configure audio to loop
		audio.loop = true;
		// Play sound and apply flash class
		audio.play().catch(e => console.error("Audio playback failed:", e));
		document.body.classList.add('warning-flash');

		// Cleanup function: stop audio and remove class when component unmounts (or is dismissed)
		return () => {
			audio.pause();
			audio.currentTime = 0;
			document.body.classList.remove('warning-flash');
		};
	}, [audio]);

	if (!notification) return null;

	return (
		<div className="modal-overlay active" style={{ zIndex: 10000 }}>
			<div className="modal-content" style={{ maxWidth: '500px', border: '3px solid var(--danger-color)', textAlign: 'center' }}>
				<i className="fas fa-exclamation-triangle" style={{ fontSize: '4rem', color: 'var(--danger-color)', marginBottom: '1rem' }}></i>
				<h1 style={{ color: 'var(--danger-color)' }}>{notification.title}</h1>
				<p style={{ fontSize: '1.2rem' }}>{notification.description}</p>
				<button onClick={onDismiss} className="btn btn-danger" style={{ marginTop: '1.5rem' }}>
					Verstanden
				</button>
			</div>
		</div>
	);
};

export default WarningNotification;
========================================================================
FILE: frontend\src\context\ToastContext.jsx
========================================================================

import React, { createContext, useState, useCallback, useContext } from 'react';

const ToastContext = createContext(null);

export const useToast = () => {
	const context = useContext(ToastContext);
	if (!context) {
		throw new Error('useToast muss innerhalb eines ToastProviders verwendet werden');
	}
	return context;
};

export const ToastProvider = ({ children }) => {
	const [toasts, setToasts] = useState([]);

	const addToast = useCallback((message, type = 'info', url = null) => {
		const id = Date.now() + Math.random();
		setToasts(prevToasts => [...prevToasts, { id, message, type, url }]);
		setTimeout(() => {
			setToasts(prevToasts => prevToasts.filter(toast => toast.id !== id));
		}, 5000);
	}, []);

	const value = { toasts, addToast };

	return (
		<ToastContext.Provider value={value}>
			{children}
		</ToastContext.Provider>
	);
};
========================================================================
FILE: frontend\src\hooks\useAdminData.js
========================================================================

import { useState, useEffect } from 'react';
import apiClient from '../services/apiClient';
import { useAuthStore } from '../store/authStore';

// Granular hooks for specific data needs
export const useAdminRolesAndPermissions = () => {
	const [data, setData] = useState({ roles: [], groupedPermissions: {}, loading: true, error: null });
	useEffect(() => {
		const fetchData = async () => {
			try {
				const result = await apiClient.get('/users/form-data');
				if (result.success) {
					setData({ roles: result.data.roles, groupedPermissions: result.data.groupedPermissions, loading: false, error: null });
				} else { throw new Error(result.message); }
			} catch (err) {
				setData({ roles: [], groupedPermissions: {}, loading: false, error: err.message });
			}
		};
		fetchData();
	}, []);
	return data;
};

export const useAdminCourses = () => {
	const [data, setData] = useState({ courses: [], loading: true, error: null });
	const canRead = useAuthStore(state => state.user.permissions.includes('COURSE_READ'));
	useEffect(() => {
		if (!canRead) {
			setData({ courses: [], loading: false, error: null });
			return;
		}
		const fetchData = async () => {
			try {
				const result = await apiClient.get('/courses');
				if (result.success) {
					setData({ courses: result.data, loading: false, error: null });
				} else { throw new Error(result.message); }
			} catch (err) {
				setData({ courses: [], loading: false, error: err.message });
			}
		};
		fetchData();
	}, [canRead]);
	return data;
};

// Main hook remains for components that need everything
const useAdminData = () => {
	const [data, setData] = useState({
		roles: [],
		groupedPermissions: {},
		storageItems: [],
		courses: [],
		users: [],
		loading: true,
		error: null,
	});

	const canReadCourses = useAuthStore(state => state.user.permissions.includes('COURSE_READ'));
	const canReadStorage = useAuthStore(state => state.user.permissions.includes('STORAGE_READ'));
	const canReadUsers = useAuthStore(state => state.user.permissions.includes('USER_READ'));


	useEffect(() => {
		const fetchData = async () => {
			try {
				const promises = [
					apiClient.get('/users/form-data'), // roles & permissions
					canReadStorage ? apiClient.get('/storage') : Promise.resolve({ success: true, data: [] }),
					canReadCourses ? apiClient.get('/courses') : Promise.resolve({ success: true, data: [] }),
					canReadUsers ? apiClient.get('/users') : Promise.resolve({ success: true, data: [] }),
				];

				const [usersFormData, storageItemsData, coursesData, usersData] = await Promise.all(promises);

				if (usersFormData.success && storageItemsData.success && coursesData.success && usersData.success) {
					setData({
						roles: usersFormData.data.roles,
						groupedPermissions: usersFormData.data.groupedPermissions,
						storageItems: storageItemsData.data,
						courses: coursesData.data,
						users: usersData.data,
						loading: false,
						error: null,
					});
				} else {
					throw new Error('Eine oder mehrere Admin-Datenquellen konnten nicht geladen werden.');
				}
			} catch (err) {
				setData(prev => ({
					...prev,
					loading: false,
					error: err.message || 'Fehler beim Laden der Admin-Formulardaten.',
				}));
			}
		};

		fetchData();
	}, [canReadCourses, canReadStorage, canReadUsers]);

	return data;
};

export default useAdminData;
========================================================================
FILE: frontend\src\hooks\useApi.js
========================================================================

import { useState, useEffect, useCallback } from 'react';
import apiClient from '../services/apiClient';

/**
 * A custom React hook to manage the state of an API call.
 * @param {Function} apiCall - The function from apiClient to execute.
 * @returns {object} An object containing data, loading state, error state, and a reload function.
 */
const useApi = (apiCall) => {
	const [data, setData] = useState(null);
	// Start in a loading state. This prevents the state transition during the initial render
	// that causes the "component suspended" error with lazy loading and routing.
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState(null);

	const fetchData = useCallback(async () => {
		// Don't fetch if the apiCall function isn't ready or is null
		if (!apiCall) {
			setLoading(false);
			setData(null); // Clear data if the call is removed
			return;
		}

		try {
			// setLoading(true) was here and caused the issue. It's now the initial state.
			setError(null);
			const result = await apiCall();
			if (result.success) {
				setData(result.data);
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein unerwarteter Fehler ist aufgetreten.');
		} finally {
			setLoading(false);
		}
	}, [apiCall]);

	useEffect(() => {
		fetchData();
	}, [fetchData]);

	return { data, loading, error, reload: fetchData };
};

export default useApi;
========================================================================
FILE: frontend\src\hooks\useNotifications.js
========================================================================

import { useState, useEffect, useCallback } from 'react';
import { useToast } from '../context/ToastContext';
import { useAuthStore } from '../store/authStore';

export const useNotifications = () => {
	const { addToast } = useToast();
	const [warningNotification, setWarningNotification] = useState(null);
	const isAuthenticated = useAuthStore(state => state.isAuthenticated);

	const dismissWarning = useCallback(() => {
		setWarningNotification(null);
	}, []);

	useEffect(() => {
		if (!isAuthenticated) {
			return;
		}

		const events = new EventSource('/api/v1/admin/notifications/sse');

		events.onmessage = (event) => {
			console.log("Received SSE message:", event.data);
		};

		events.addEventListener("notification", (event) => {
			const data = JSON.parse(event.data);
			if (data.level === 'Warning') {
				setWarningNotification(data);
			} else {
				addToast(
					`${data.title}: ${data.description}`,
					data.level === 'Important' ? 'error' : 'info',
					data.url || null // Pass the URL to the toast
				);
			}
		});

		events.onerror = (err) => {
			console.error("EventSource failed:", err);
			events.close();
		};

		return () => {
			events.close();
		};
	}, [isAuthenticated, addToast]);

	return { warningNotification, dismissWarning };
};
========================================================================
FILE: frontend\src\hooks\useTypingAnimation.js
========================================================================

import { useState, useEffect, useRef } from 'react';

const useTypingAnimation = (lines) => {
	const [renderedLines, setRenderedLines] = useState([]);
	const [isComplete, setIsComplete] = useState(false);
	const containerRef = useRef(null);
	const timeoutIds = useRef([]);

	useEffect(() => {
		let isCancelled = false;

		const typeLine = (lineIndex) => {
			if (isCancelled || lineIndex >= lines.length) {
				setIsComplete(true);
				return;
			}

			const currentLine = lines[lineIndex];
			setRenderedLines(prev => {
				const newLines = [...prev];
				newLines[lineIndex] = { ...currentLine, text: '' }; // Initialize line
				return newLines;
			});

			let charIndex = 0;
			const typeChar = () => {
				if (isCancelled) return;

				setRenderedLines(prev => {
					const newLines = [...prev];
					newLines[lineIndex] = {
						...currentLine,
						text: currentLine.text.substring(0, charIndex + 1),
					};
					return newLines;
				});

				if (containerRef.current) {
					containerRef.current.scrollTop = containerRef.current.scrollHeight;
				}

				if (charIndex < currentLine.text.length - 1) {
					charIndex++;
					const timeoutId = setTimeout(typeChar, currentLine.speed || 30);
					timeoutIds.current.push(timeoutId);
				} else {
					const timeoutId = setTimeout(() => typeLine(lineIndex + 1), currentLine.delayAfter || 300);
					timeoutIds.current.push(timeoutId);
				}
			};
			typeChar();
		};

		typeLine(0);

		return () => {
			isCancelled = true;
			timeoutIds.current.forEach(clearTimeout);
		};
	}, [lines]);

	return { containerRef, renderedLines, isComplete };
};

export default useTypingAnimation;
========================================================================
FILE: frontend\src\hooks\useWebSocket.js
========================================================================

import { useState, useEffect, useRef } from 'react';

/**
 * A custom hook to manage a WebSocket connection.
 * @param {string} url - The WebSocket URL to connect to.
 * @param {Function} onMessage - Callback function to handle incoming messages.
 * @returns {object} An object containing the WebSocket ready state and a sendMessage function.
 */
const useWebSocket = (url, onMessage) => {
	const [readyState, setReadyState] = useState(WebSocket.CONNECTING);
	const socketRef = useRef(null);

	useEffect(() => {
		if (!url) return;

		const connect = () => {
			// Authentication is now handled by the HttpOnly cookie, so no token is needed in the URL.
			const socket = new WebSocket(url);
			socketRef.current = socket;

			socket.onopen = () => {
				console.log('WebSocket-Verbindung hergestellt.');
				setReadyState(WebSocket.OPEN);
			};

			socket.onmessage = (event) => {
				try {
					const data = JSON.parse(event.data);
					if (onMessage) {
						onMessage(data);
					}
				} catch (error) {
					console.error('Fehler beim Parsen der WebSocket-Nachricht:', error);
				}
			};

			socket.onclose = (event) => {
				if (event.code === 4001 || event.code === 403) {
					console.error('WebSocket-Verbindung aufgrund von Authentifizierungs-/Autorisierungsfehler geschlossen.');
				} else {
					console.warn('WebSocket-Verbindung geschlossen. Versuche erneute Verbindung...');
					setTimeout(connect, 5000);
				}
				setReadyState(WebSocket.CLOSED);
			};

			socket.onerror = (error) => {
				console.error('WebSocket-Fehler:', error);
				setReadyState(WebSocket.CLOSED);
				socket.close();
			};
		};

		connect();

		return () => {
			if (socketRef.current) {
				socketRef.current.onclose = null; // Prevent reconnect attempts on component unmount
				socketRef.current.close();
			}
		};
	}, [url, onMessage]);

	const sendMessage = (messageObject) => {
		if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
			socketRef.current.send(JSON.stringify(messageObject));
		} else {
			console.error('WebSocket ist nicht geöffnet. Nachricht kann nicht gesendet werden.');
		}
	};

	return { readyState, sendMessage };
};

export default useWebSocket;
========================================================================
FILE: frontend\src\pages\CalendarPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import CalendarDesktopView from '../components/calendar/CalendarDesktopView';
import CalendarMobileView from '../components/calendar/CalendarMobileView';

const CalendarPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/calendar/entries'), []);
	const { data: calendarEntries, loading, error } = useApi(apiCall);

	if (loading) {
		return <div>Lade Kalenderdaten...</div>;
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>
				<i className="fas fa-calendar-alt"></i> Terminübersicht
			</h1>
			<p>
				Übersicht aller anstehenden Veranstaltungen und Lehrgänge.
				<a href="/api/v1/public/calendar.ics" className="btn btn-small" style={{ marginLeft: '1rem', backgroundColor: 'var(--success-color)' }}>
					<i className="fas fa-rss"></i> Kalender abonnieren
				</a>
			</p>

			<div className="mobile-list-view">
				<CalendarMobileView entries={calendarEntries || []} />
			</div>

			<div className="desktop-calendar-view card">
				<CalendarDesktopView entries={calendarEntries || []} />
			</div>
		</div>
	);
};

export default CalendarPage;
========================================================================
FILE: frontend\src\pages\ChangelogPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const ChangelogPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/changelog'), []);
	const { data: changelogs, loading, error } = useApi(apiCall);

	return (
		<div>
			<h1><i className="fas fa-history"></i> Changelogs & Neuerungen</h1>
			<p>Hier finden Sie eine Übersicht aller wichtigen Änderungen und neuen Features der Anwendung.</p>
			{loading && <p>Lade Changelogs...</p>}
			{error && <p className="error-message">{error}</p>}
			{changelogs?.map(cl => (
				<div className="card" key={cl.id}>
					<h2 className="card-title" style={{ border: 'none', padding: 0 }}>
						Version {cl.version} - {cl.title}
					</h2>
					<p className="details-subtitle" style={{ marginTop: '-0.5rem' }}>
						Veröffentlicht am {new Date(cl.releaseDate).toLocaleDateString('de-DE')}
					</p>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>{cl.notes}</ReactMarkdown>
					</div>
				</div>
			))}
		</div>
	);
};

export default ChangelogPage;
========================================================================
FILE: frontend\src\pages\ChatPage.css
========================================================================

.chat-page-container {
    display: flex;
    height: calc(100vh - (var(--header-height) + 3rem)); /* Full height minus header and padding */
    gap: 1rem;
    position: relative;
    overflow: hidden;
}

.chat-sidebar {
    flex: 0 0 320px;
    background-color: var(--surface-color);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    transition: transform 0.3s ease-in-out;
}

.chat-main {
    flex-grow: 1;
    background-color: var(--surface-color);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    min-width: 0;
    transition: transform 0.3s ease-in-out;
}

.chat-welcome-view {
    margin: auto;
    text-align: center;
    color: var(--text-muted-color);
}

.chat-welcome-view .fas {
    font-size: 4rem;
    margin-bottom: 1rem;
}

/* Mobile responsive behavior */
@media (max-width: 991.98px) {
    .chat-page-container {
        gap: 0;
    }

    .chat-sidebar,
    .chat-main {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 0;
        border: none;
    }
    
    /* Default state on mobile: show list, hide messages */
    .chat-sidebar {
        transform: translateX(0);
        z-index: 2;
    }
    
    .chat-main {
        transform: translateX(100%);
        z-index: 1;
    }

    /* When a message view is active, slide the list out and the messages in */
    .chat-page-container.message-view-visible .chat-sidebar {
        transform: translateX(-100%);
    }
    
    .chat-page-container.message-view-visible .chat-main {
        transform: translateX(0);
    }
}
========================================================================
FILE: frontend\src\pages\ChatPage.jsx
========================================================================

import React from 'react';
import { useParams } from 'react-router-dom';
import ConversationList from '../components/chat/ConversationList';
import MessageView from '../components/chat/MessageView';
import './ChatPage.css';

const ChatPage = () => {
	const { conversationId } = useParams();

	// On mobile, the presence of a conversationId dictates which pane is visible.
	const containerClass = `chat-page-container ${conversationId ? 'message-view-visible' : 'conversation-list-visible'}`;

	return (
		<div className={containerClass}>
			<aside className="chat-sidebar">
				<ConversationList selectedConversationId={conversationId} />
			</aside>
			<main className="chat-main">
				{conversationId ? (
					<MessageView conversationId={conversationId} key={conversationId} />
				) : (
					<div className="chat-welcome-view">
						<i className="fas fa-comments"></i>
						<h2>Willkommen im Chat</h2>
						<p>Wähle links ein Gespräch aus oder starte ein neues, um zu beginnen.</p>
					</div>
				)}
			</main>
		</div>
	);
};

export default ChatPage;
========================================================================
FILE: frontend\src\pages\DashboardPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useAuthStore } from '../store/authStore';

const DashboardPage = () => {
	const { user } = useAuthStore();
	const apiCall = useCallback(() => apiClient.get('/public/dashboard'), []);
	const { data: dashboardData, loading, error } = useApi(apiCall);

	if (loading) {
		return (
			<div>
				<h1>Willkommen zurück, {user?.username}!</h1>
				<div className="dashboard-grid">
					<div className="card"><h2 className="card-title">Meine nächsten Einsätze</h2><p>Lade Daten...</p></div>
					<div className="card"><h2 className="card-title">Meine offenen Aufgaben</h2><p>Lade Daten...</p></div>
					<div className="card"><h2 className="card-title">Weitere anstehende Veranstaltungen</h2><p>Lade Daten...</p></div>
				</div>
			</div>
		);
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>Willkommen zurück, {user?.username}!</h1>
			<div className="dashboard-grid">
				<div className="card" id="assigned-events-widget">
					<h2 className="card-title">Meine nächsten Einsätze</h2>
					<div id="assigned-events-content">
						{dashboardData?.assignedEvents?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.assignedEvents.map(event => (
									<li key={event.id}>
										<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
										<small>{new Date(event.eventDateTime).toLocaleString('de-DE')}</small>
									</li>
								))}
							</ul>
						) : (
							<p>Du bist derzeit für keine kommenden Events fest eingeteilt.</p>
						)}
					</div>
					<Link to="/veranstaltungen" className="btn btn-small" style={{ marginTop: '1rem' }}>Alle Veranstaltungen anzeigen</Link>
				</div>

				<div className="card" id="open-tasks-widget">
					<h2 className="card-title">Meine offenen Aufgaben</h2>
					<div id="open-tasks-content">
						{dashboardData?.openTasks?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.openTasks.map(task => (
									<li key={task.id}>
										<Link to={`/veranstaltungen/details/${task.eventId}`}>
											{task.description}
											<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>
												Für Event: {task.eventName}
											</small>
										</Link>
									</li>
								))}
							</ul>
						) : (
							<p>Super! Du hast aktuell keine offenen Aufgaben.</p>
						)}
					</div>
				</div>

				<div className="card" id="upcoming-events-widget">
					<h2 className="card-title">Weitere anstehende Veranstaltungen</h2>
					<div id="upcoming-events-content">
						{dashboardData?.upcomingEvents?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.upcomingEvents.map(event => (
									<li key={event.id}>
										<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
										<small>{new Date(event.eventDateTime).toLocaleString('de-DE')}</small>
									</li>
								))}
							</ul>
						) : (
							<p>Keine weiteren anstehenden Veranstaltungen.</p>
						)}
					</div>
				</div>
			</div>
		</div>
	);
};

export default DashboardPage;
========================================================================
FILE: frontend\src\pages\EventDetailsPage.jsx
========================================================================

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import useWebSocket from '../hooks/useWebSocket';
import { useAuthStore } from '../../store/authStore';
import StatusBadge from '../components/ui/StatusBadge';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';
import { useToast } from '../../context/ToastContext';
import ChecklistTab from '../components/events/ChecklistTab';

const EventDetailsPage = () => {
	const { eventId } = useParams();
	const { user, isAdmin } = useAuthStore(state => ({ user: state.user, isAdmin: state.isAdmin }));
	const apiCall = useCallback(() => apiClient.get(`/public/events/${eventId}`), [eventId]);
	const { data: event, loading, error } = useApi(apiCall);
	const { addToast } = useToast();

	const [chatMessages, setChatMessages] = useState([]);
	const [chatInput, setChatInput] = useState('');
	const fileInputRef = useRef(null);
	const [isUploading, setIsUploading] = useState(false);
	const [editingMessageId, setEditingMessageId] = useState(null);
	const [editingText, setEditingText] = useState('');
	const longPressTimer = useRef();
	const [activeOptionsMessageId, setActiveOptionsMessageId] = useState(null);
	const [activeTab, setActiveTab] = useState('tasks');


	const websocketProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
	const websocketUrl = event && (event.status === 'LAUFEND' || event.status === 'GEPLANT')
		? `${websocketProtocol}//${window.location.host}/ws/chat/${eventId}`
		: null;

	const handleChatMessage = (message) => {
		if (message.type === 'new_message') {
			setChatMessages(prevMessages => [...prevMessages, message.payload]);
		} else if (message.type === 'message_soft_deleted' || message.type === 'message_updated') {
			setChatMessages(prev => prev.map(msg =>
				msg.id === message.payload.id ? message.payload : msg
			));
		}
	};

	const { readyState, sendMessage } = useWebSocket(websocketUrl, handleChatMessage);

	useEffect(() => {
		if (event?.chatMessages) {
			setChatMessages(event.chatMessages);
		}
	}, [event]);

	const handleChatSubmit = (e) => {
		e.preventDefault();
		if (chatInput.trim()) {
			sendMessage({ type: "new_message", payload: { messageText: chatInput } });
			setChatInput('');
		}
	};

	const handleFileUpload = async (e) => {
		const file = e.target.files[0];
		if (!file) return;

		setIsUploading(true);
		const formData = new FormData();
		formData.append('file', file);

		try {
			const result = await apiClient.post(`/public/events/${eventId}/chat/upload`, formData);
			if (result.success) {
				const fileUrl = `/api/v1/public/files/download/${result.data.id}`;
				const messageText = `Datei geteilt: [${result.data.filename}](${fileUrl})`;
				sendMessage({ type: "new_message", payload: { messageText } });
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || 'Datei-Upload fehlgeschlagen.', 'error');
		} finally {
			setIsUploading(false);
			if (fileInputRef.current) fileInputRef.current.value = "";
		}
	};

	const handleEditClick = (msg) => {
		setEditingMessageId(msg.id);
		setEditingText(msg.messageText);
	};

	const handleCancelEdit = () => {
		setEditingMessageId(null);
		setEditingText('');
	};

	const handleEditSubmit = () => {
		if (editingText.trim()) {
			sendMessage({
				type: 'update_message',
				payload: { messageId: editingMessageId, newText: editingText }
			});
			handleCancelEdit();
		}
	};

	const handleDeleteClick = (msg) => {
		if (window.confirm('Nachricht wirklich löschen?')) {
			sendMessage({
				type: 'delete_message',
				payload: { messageId: msg.id, originalUserId: msg.userId, originalUsername: msg.username }
			});
		}
	};

	const handleTouchStart = (messageId) => {
		longPressTimer.current = setTimeout(() => {
			setActiveOptionsMessageId(messageId);
		}, 500);
	};

	const handleTouchEnd = () => {
		clearTimeout(longPressTimer.current);
	};

	const handleTouchMove = () => {
		clearTimeout(longPressTimer.current);
	};

	const renderMessageText = (msg) => {
		const text = msg.messageText;
		const isSentByMe = msg.userId === user.id;

		const imageRegex = /\[(.*?)\]\((.*?)\.(png|jpg|jpeg|gif)\)/i;
		const imageMatch = text.match(imageRegex);
		if (imageMatch) {
			return <img src={imageMatch[2] + '.' + imageMatch[3]} alt={imageMatch[1]} style={{ maxWidth: '100%', borderRadius: '12px' }} />;
		}

		const fileRegex = /\[(.*?)\]\((.*?)\)/;
		const fileMatch = text.match(fileRegex);
		if (fileMatch) {
			return <a href={fileMatch[2]} target="_blank" rel="noopener noreferrer" style={{ color: isSentByMe ? '#fff' : '#000' }}><i className="fas fa-file-alt"></i> {fileMatch[1]}</a>;
		}

		return <ReactMarkdown rehypePlugins={[rehypeSanitize]}>{text}</ReactMarkdown>;
	};

	if (loading) return <div>Lade Event-Details...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!event) return <div className="error-message">Event nicht gefunden.</div>;

	const canManageDebriefing = isAdmin || user.id === event.leaderUserId;

	const isTaskBlocked = (task) => {
		if (!task.dependsOn || task.dependsOn.length === 0) return false;
		return task.dependsOn.some(parent => parent.status !== 'ERLEDIGT');
	};

	const groupedAttendees = event.assignedAttendees?.reduce((acc, member) => {
		const role = member.assignedEventRole || 'Unzugewiesen';
		if (!acc[role]) {
			acc[role] = [];
		}
		acc[role].push(member);
		return acc;
	}, {});

	return (
		<div onClick={() => setActiveOptionsMessageId(null)}>
			<div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexWrap: 'wrap', gap: '1rem' }}>
				<div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
					<h1>{event.name}</h1>
					<StatusBadge status={event.status} />
				</div>
				{event.status === 'ABGESCHLOSSEN' && canManageDebriefing && (
					<Link to={`/admin/veranstaltungen/${event.id}/debriefing`} className="btn btn-secondary">
						<i className="fas fa-clipboard-check"></i> Debriefing ansehen/bearbeiten
					</Link>
				)}
			</div>
			<p className="details-subtitle">
				<strong>Zeitraum:</strong> {new Date(event.eventDateTime).toLocaleString('de-DE')}
				{event.endDateTime && ` - ${new Date(event.endDateTime).toLocaleString('de-DE')}`}
			</p>

			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">Beschreibung</h2>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
							{event.description || 'Keine Beschreibung.'}
						</ReactMarkdown>
					</div>
				</div>

				<div className="card">
					<h2 className="card-title">Details</h2>
					<ul className="details-list">
						<li><strong>Ort:</strong> <span>{event.location || 'N/A'}</span></li>
						<li><strong>Leitung:</strong> <span>{event.leaderUsername || 'N/A'}</span></li>
					</ul>
				</div>

				<div className="card">
					<h2 className="card-title">Benötigter Personalbedarf</h2>
					<ul className="details-list">
						{event.skillRequirements?.length > 0 ? (
							event.skillRequirements.map(req => <li key={req.requiredCourseId}><strong>{req.courseName}:</strong> <span>{req.requiredPersons} Person(en)</span></li>)
						) : (
							<li>Keine speziellen Qualifikationen benötigt.</li>
						)}
					</ul>
				</div>

				<div className="card">
					<h2 className="card-title">Zugewiesenes Team</h2>
					{groupedAttendees && Object.keys(groupedAttendees).length > 0 ? (
						Object.entries(groupedAttendees).map(([role, members]) => (
							<div key={role} style={{ marginBottom: '1rem' }}>
								<h4 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '0.25rem' }}>{role}</h4>
								<ul className="details-list">
									{members.map(member => <li key={member.id} style={{ border: 'none', padding: '0.25rem 0' }}>{member.username}</li>)}
								</ul>
							</div>
						))
					) : (
						<p>Noch kein Team zugewiesen.</p>
					)}
				</div>

				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<div className="modal-tabs">
						<button className={`modal-tab-button ${activeTab === 'tasks' ? 'active' : ''}`} onClick={() => setActiveTab('tasks')}>Aufgaben</button>
						<button className={`modal-tab-button ${activeTab === 'checklist' ? 'active' : ''}`} onClick={() => setActiveTab('checklist')}>Inventar-Checkliste</button>
						<button className={`modal-tab-button ${activeTab === 'chat' ? 'active' : ''}`} onClick={() => setActiveTab('chat')}>Event-Chat</button>
					</div>

					<div className={`modal-tab-content ${activeTab === 'tasks' ? 'active' : ''}`}>
						{event.eventTasks?.length > 0 ? (
							event.eventTasks.map(task => {
								const blocked = isTaskBlocked(task);
								return (
									<div key={task.id} className="card" style={{ marginBottom: '1rem', opacity: blocked ? 0.6 : 1, pointerEvents: blocked ? 'none' : 'auto' }}>
										<div style={{ display: 'flex', justifyContent: 'space-between' }}>
											<h4 style={{ margin: 0 }}>{task.description}</h4>
											<StatusBadge status={task.status} />
										</div>
										{blocked && (
											<small className="text-danger" style={{ display: 'block', fontWeight: 'bold' }}>
												Blockiert durch: {task.dependsOn.map(t => t.description).join(', ')}
											</small>
										)}
										<div className="markdown-content">
											<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
												{task.details || ''}
											</ReactMarkdown>
										</div>
										<p><strong>Zugewiesen an:</strong> {task.assignedUsers.map(u => u.username).join(', ') || 'Niemand'}</p>
									</div>
								);
							})
						) : (
							<p>Für dieses Event wurden noch keine Aufgaben erstellt.</p>
						)}
					</div>

					<div className={`modal-tab-content ${activeTab === 'checklist' ? 'active' : ''}`}>
						<ChecklistTab event={event} user={user} />
					</div>

					<div className={`modal-tab-content ${activeTab === 'chat' ? 'active' : ''}`}>
						{(event.status === 'LAUFEND' || event.status === 'GEPLANT') ? (
							<>
								<div id="chat-box" style={{ height: '300px', overflowY: 'auto', border: '1px solid var(--border-color)', padding: '0.5rem', marginBottom: '1rem', background: 'var(--bg-color)', display: 'flex', flexDirection: 'column' }}>
									{chatMessages.map(msg => {
										const isSentByMe = msg.userId === user.id;
										const isMessageEditable = () => {
											if (!msg.sentAt) return false;
											const sentAt = new Date(msg.sentAt);
											const now = new Date();
											return (now - sentAt) < 24 * 60 * 60 * 1000;
										};
										const canEdit = !msg.isDeleted && isSentByMe && isMessageEditable();
										const canDelete = !msg.isDeleted && (isSentByMe || isAdmin || user.id === event.leaderUserId);
										const isEditing = editingMessageId === msg.id;
										return (
											<div
												key={msg.id}
												className={`chat-message-container ${isSentByMe ? 'current-user' : ''} ${activeOptionsMessageId === msg.id ? 'options-visible' : ''}`}
												onTouchStart={() => handleTouchStart(msg.id)}
												onTouchEnd={handleTouchEnd}
												onTouchMove={handleTouchMove}
												onClick={(e) => { if (activeOptionsMessageId) e.stopPropagation() }}
											>
												<div className="chat-bubble" style={{ backgroundColor: isSentByMe ? 'var(--primary-color)' : msg.chatColor || '#e9ecef', color: isSentByMe ? '#fff' : 'var(--text-color)' }}>
													{!msg.isDeleted ? (
														<>
															{!isSentByMe && <strong className="chat-username">{msg.username}</strong>}
															{isEditing ? (
																<div>
																	<textarea value={editingText} onChange={(e) => setEditingText(e.target.value)} className="chat-edit-input" />
																	<div style={{ marginTop: '0.5rem', display: 'flex', gap: '0.5rem' }}>
																		<button onClick={handleEditSubmit} className="btn btn-small btn-success">Speichern</button>
																		<button onClick={handleCancelEdit} className="btn btn-small btn-secondary">Abbrechen</button>
																	</div>
																</div>
															) : (
																<span className="chat-text">{renderMessageText(msg)}</span>
															)}
															<span className="chat-timestamp">{new Date(msg.sentAt).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} {msg.edited && <em style={{ opacity: 0.8 }} title={`Bearbeitet am ${new Date(msg.editedAt).toLocaleString('de-DE')}`}>(bearbeitet)</em>}</span>
														</>
													) : (
														<span className="chat-deleted-info" style={{ opacity: 0.7 }}>
															Diese Nachricht wurde von {msg.deletedByUsername} gelöscht.<br />
															<small>{new Date(msg.deletedAt).toLocaleString('de-DE')}</small>
														</span>
													)}
												</div>
												{!msg.isDeleted && !isEditing && (canEdit || canDelete) && (
													<div className="chat-options">
														{canEdit && <button className="chat-option-btn" title="Bearbeiten" onClick={() => handleEditClick(msg)}><i className="fas fa-pencil-alt"></i></button>}
														{canDelete && <button className="chat-option-btn" title="Löschen" onClick={() => handleDeleteClick(msg)}><i className="fas fa-trash"></i></button>}
													</div>
												)}
											</div>
										);
									})}
								</div>
								<form id="chat-form" onSubmit={handleChatSubmit} style={{ display: 'flex', gap: '0.5rem' }}>
									<input type="file" ref={fileInputRef} onChange={handleFileUpload} style={{ display: 'none' }} accept="image/*,application/pdf" />
									<button type="button" className="btn" onClick={() => fileInputRef.current.click()} disabled={isUploading || readyState !== WebSocket.OPEN} title="Datei anhängen">
										{isUploading ? <i className="fas fa-spinner fa-spin"></i> : <i className="fas fa-paperclip"></i>}
									</button>
									<input
										type="text"
										id="chat-message-input"
										className="form-group"
										style={{ flexGrow: 1, margin: 0 }}
										placeholder="Nachricht eingeben..."
										value={chatInput}
										onChange={(e) => setChatInput(e.target.value)}
										autoComplete="off"
										disabled={readyState !== WebSocket.OPEN}
									/>
									<button type="submit" className="btn" disabled={readyState !== WebSocket.OPEN}>Senden</button>
								</form>
							</>
						) : (
							<p>Der Chat ist nur für geplante oder laufende Events verfügbar.</p>
						)}
					</div>

				</div>
			</div>
		</div>
	);
};

export default EventDetailsPage;
========================================================================
FILE: frontend\src\pages\EventFeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const EventFeedbackPage = () => {
	const { eventId } = useParams();
	const navigate = useNavigate();
	const { addToast } = useToast();

	const [rating, setRating] = useState(0);
	const [comments, setComments] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const apiCall = useCallback(() => apiClient.get(`/public/feedback/forms?eventId=${eventId}`), [eventId]);
	const { data, loading, error: fetchError } = useApi(apiCall);

	const handleSubmit = async (e) => {
		e.preventDefault();
		if (rating === 0) {
			setError('Bitte wählen Sie eine Sternebewertung aus.');
			return;
		}
		setIsSubmitting(true);
		setError('');

		try {
			const result = await apiClient.post('/public/feedback/event', {
				formId: data.form.id,
				rating,
				comments
			});
			if (result.success) {
				addToast('Vielen Dank für dein Feedback!', 'success');
				navigate('/profil');
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Feedback konnte nicht übermittelt werden.');
		} finally {
			setIsSubmitting(false);
		}
	};

	if (loading) return <div>Lade Feedback-Formular...</div>;
	if (fetchError) return <div className="error-message">{fetchError}</div>;
	if (!data) return <div className="error-message">Formulardaten nicht gefunden.</div>;

	if (data.alreadySubmitted) {
		return (
			<div className="card" style={{ maxWidth: '700px', margin: 'auto' }}>
				<h1>Feedback bereits abgegeben</h1>
				<p className="info-message">Vielen Dank, du hast bereits Feedback für das Event "{data.event.name}" abgegeben.</p>
				<Link to="/profil" className="btn">Zurück zum Profil</Link>
			</div>
		);
	}

	return (
		<div style={{ maxWidth: '700px', margin: 'auto' }}>
			<div className="card">
				<h1>Feedback für: {data.event.name}</h1>
				<p>Dein Feedback hilft uns, zukünftige Events zu verbessern.</p>
				{error && <p className="error-message">{error}</p>}
				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label>Gesamteindruck (1 = schlecht, 5 = super)</label>
						<div className="star-rating">
							{[5, 4, 3, 2, 1].map(star => (
								<React.Fragment key={star}>
									<input type="radio" id={`star${star}`} name="rating" value={star} onChange={() => setRating(star)} checked={rating === star} />
									<label htmlFor={`star${star}`} title={`${star} Sterne`}></label>
								</React.Fragment>
							))}
						</div>
					</div>
					<div className="form-group">
						<label htmlFor="comments">Kommentare & Verbesserungsvorschläge</label>
						<textarea id="comments" name="comments" value={comments} onChange={(e) => setComments(e.target.value)} rows="5"></textarea>
					</div>
					<button type="submit" className="btn" disabled={isSubmitting}>
						{isSubmitting ? 'Wird gesendet...' : 'Feedback absenden'}
					</button>
				</form>
			</div>
		</div>
	);
};

export default EventFeedbackPage;
========================================================================
FILE: frontend\src\pages\EventsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import Modal from '../components/ui/Modal';
import StatusBadge from '../components/ui/StatusBadge';
import { useToast } from '../context/ToastContext';

const EventsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/events'), []);
	const { data: events, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const [modalState, setModalState] = useState({
		isOpen: false,
		type: null,
		event: null,
		customFields: [],
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [formError, setFormError] = useState('');

	const openSignupModal = async (event) => {
		try {
			const result = await apiClient.get(`/public/events/${event.id}/custom-fields`);
			setModalState({
				isOpen: true,
				type: 'signup',
				event,
				customFields: result.success ? result.data : [],
			});
		} catch (e) {
			console.error("Benutzerdefinierte Felder konnten nicht geladen werden", e);
			setModalState({ isOpen: true, type: 'signup', event, customFields: [] });
		}
	};

	const openSignoffModal = (event) => {
		setModalState({ isOpen: true, type: 'signoff', event, customFields: [] });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, type: null, event: null, customFields: [] });
		setFormError('');
	};

	const handleSignupSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setFormError('');
		const formData = new FormData(e.target);
		const customFieldData = Object.fromEntries(formData.entries());

		try {
			const result = await apiClient.post(`/public/events/${modalState.event.id}/signup`, customFieldData);
			if (result.success) {
				addToast('Erfolgreich angemeldet!', 'success');
				closeModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Anmeldung fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleSignoffSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setFormError('');
		const reason = new FormData(e.target).get('reason') || '';

		try {
			const result = await apiClient.post(`/public/events/${modalState.event.id}/signoff`, { reason });
			if (result.success) {
				addToast('Erfolgreich abgemeldet.', 'success');
				closeModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Abmeldung fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};


	const getAction = (event) => {
		if (event.userAttendanceStatus === 'OFFEN' || event.userAttendanceStatus === 'ABGEMELDET') {
			return (
				<button
					type="button"
					className="btn btn-small btn-success"
					onClick={() => openSignupModal(event)}
					disabled={!event.userQualified}
					title={!event.userQualified ? 'Du erfüllst die Anforderungen für dieses Event nicht.' : ''}
				>
					Anmelden
				</button>
			);
		}
		if (event.userAttendanceStatus === 'ANGEMELDET' || event.userAttendanceStatus === 'ZUGEWIESEN') {
			return (
				<button type="button" className="btn btn-small btn-danger" onClick={() => openSignoffModal(event)}>
					Abmelden
				</button>
			);
		}
		return null;
	};

	const getUserStatusText = (status) => {
		if (status === 'ZUGEWIESEN') return <strong className="text-success">Zugewiesen</strong>;
		if (status === 'ANGEMELDET') return <strong style={{ color: 'var(--primary-color)' }}>Angemeldet</strong>;
		return status;
	};

	if (loading) return <div>Lade Veranstaltungen...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<>
			<h1><i className="fas fa-calendar-check"></i> Anstehende Veranstaltungen</h1>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Veranstaltung</th>
							<th>Datum & Uhrzeit</th>
							<th>Event-Status</th>
							<th>Dein Status</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{events.map(event => (
							<tr key={event.id}>
								<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
								<td>{new Date(event.eventDateTime).toLocaleString('de-DE')}</td>
								<td><StatusBadge status={event.status} /></td>
								<td>{getUserStatusText(event.userAttendanceStatus)}</td>
								<td>{getAction(event)}</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<Modal
				isOpen={modalState.isOpen}
				onClose={closeModal}
				title={modalState.type === 'signup' ? `Anmeldung für: ${modalState.event?.name}` : `Abmeldung von: ${modalState.event?.name}`}
			>
				{formError && <p className="error-message">{formError}</p>}
				{modalState.type === 'signup' && (
					<form onSubmit={handleSignupSubmit}>
						{modalState.customFields.map(field => (
							<div className="form-group" key={field.id}>
								<label htmlFor={`customfield_${field.id}`}>{field.fieldName}{field.required ? '*' : ''}</label>
								<input type="text" id={`customfield_${field.id}`} name={`customfield_${field.id}`} required={field.required} />
							</div>
						))}
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>
							{isSubmitting ? 'Wird angemeldet...' : 'Verbindlich anmelden'}
						</button>
					</form>
				)}
				{modalState.type === 'signoff' && (
					<form onSubmit={handleSignoffSubmit}>
						{modalState.event?.status === 'LAUFEND' && (
							<>
								<p className="info-message">Da das Event bereits läuft, ist eine Begründung für die Abmeldung erforderlich.</p>
								<div className="form-group">
									<label htmlFor="signoff-reason">Begründung</label>
									<textarea id="signoff-reason" name="reason" rows="3" required></textarea>
								</div>
							</>
						)}
						{modalState.event?.status !== 'LAUFEND' && <p>Möchtest du dich wirklich von diesem Event abmelden?</p>}
						<button type="submit" className="btn btn-danger" disabled={isSubmitting}>
							{isSubmitting ? 'Wird abgemeldet...' : 'Jetzt abmelden'}
						</button>
					</form>
				)}
			</Modal>
		</>
	);
};

export default EventsPage;
========================================================================
FILE: frontend\src\pages\FeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import StatusBadge from '../components/ui/StatusBadge';
import { useToast } from '../context/ToastContext';

const FeedbackPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/feedback/user'), []);
	const { data: submissions, loading, error, reload } = useApi(apiCall);
	const [subject, setSubject] = useState('');
	const [content, setContent] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [submitError, setSubmitError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setSubmitError('');

		try {
			const result = await apiClient.post('/public/feedback/general', { subject, content });
			if (result.success) {
				addToast('Vielen Dank! Dein Feedback wurde erfolgreich übermittelt.', 'success');
				setSubject('');
				setContent('');
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setSubmitError(err.message || 'Senden fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<div>
			<h1><i className="fas fa-lightbulb"></i> Feedback & Wünsche</h1>
			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">Neues Feedback einreichen</h2>
					<p>Hast du eine Idee, einen Verbesserungsvorschlag oder ist dir ein Fehler aufgefallen?</p>

					{submitError && <p className="error-message">{submitError}</p>}

					<form onSubmit={handleSubmit}>
						<div className="form-group">
							<label htmlFor="subject">Betreff</label>
							<input type="text" id="subject" value={subject} onChange={(e) => setSubject(e.target.value)} required maxLength="255" placeholder="z.B. Feature-Wunsch: Dunkelmodus" />
						</div>
						<div className="form-group">
							<label htmlFor="content">Deine Nachricht</label>
							<textarea id="content" value={content} onChange={(e) => setContent(e.target.value)} rows="8" required placeholder="Bitte beschreibe deine Idee oder das Problem..."></textarea>
						</div>
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>
							{isSubmitting ? <><i className="fas fa-spinner fa-spin"></i> Senden...</> : <><i className="fas fa-paper-plane"></i> Feedback absenden</>}
						</button>
					</form>
				</div>
				<div className="card">
					<h2 className="card-title">Mein eingereichtes Feedback</h2>
					{loading && <p>Lade Feedback...</p>}
					{error && <p className="error-message">{error}</p>}
					{submissions && submissions.length === 0 && <p>Sie haben noch kein Feedback eingereicht.</p>}
					{submissions && submissions.length > 0 && (
						<div style={{ maxHeight: '500px', overflowY: 'auto' }}>
							{submissions.map(sub => (
								<div className="list-item-card" key={sub.id} style={{ marginBottom: '1rem' }}>
									<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
										<h3 className="card-title" style={{ border: 'none', padding: 0 }}>{sub.subject}</h3>
										<StatusBadge status={sub.status} />
									</div>
									<p style={{ color: 'var(--text-muted-color)', marginTop: '-0.75rem', marginBottom: '1rem' }}>
										Eingereicht am {new Date(sub.submittedAt).toLocaleString('de-DE')}
									</p>
									<p>{sub.content}</p>
								</div>
							))}
						</div>
					)}
				</div>
			</div>
		</div>
	);
};

export default FeedbackPage;
========================================================================
FILE: frontend\src\pages\FilesPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';

const FilesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/files'), []);
	const { data: fileData, loading, error } = useApi(apiCall);

	const renderContent = () => {
		if (loading) return <div className="card"><p>Lade Dateien...</p></div>;
		if (error) return <div className="error-message">{error}</div>;
		if (!fileData || Object.keys(fileData).length === 0) {
			return <div className="card"><p>Es sind keine Dateien oder Dokumente verfügbar.</p></div>;
		}

		return Object.entries(fileData).map(([categoryName, files]) => (
			<div className="card" key={categoryName}>
				<h2>
					<i className="fas fa-folder"></i> {categoryName}
				</h2>
				<ul className="details-list">
					{files.map(file => (
						<li key={file.id} style={{ padding: '0.75rem 0' }}>
							<div>
								<a href={`/api/v1/public/files/download/${file.id}`} target="_blank" rel="noopener noreferrer">
									<i className="fas fa-download"></i> {file.filename}
								</a>
							</div>
						</li>
					))}
				</ul>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-folder-open"></i> Dateien & Dokumente</h1>
			<p>Hier können Sie zentrale Dokumente und Vorlagen herunterladen.</p>
			{renderContent()}
		</div>
	);
};

export default FilesPage;
========================================================================
FILE: frontend\src\pages\LehrgaengePage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const LehrgaengePage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/meetings'), []);
	const { data: meetings, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const handleAction = async (meetingId, action) => {
		const endpoint = `/public/meetings/${meetingId}/${action}`;
		const successMessage = action === 'signup' ? 'Erfolgreich angemeldet!' : 'Erfolgreich abgemeldet!';
		const failureMessage = action === 'signup' ? 'Anmeldung fehlgeschlagen.' : 'Abmeldung fehlgeschlagen.';

		try {
			const result = await apiClient.post(endpoint, {});
			if (result.success) {
				addToast(successMessage, 'success');
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || failureMessage, 'error');
		}
	};

	const renderActionButtons = (meeting) => {
		if (meeting.userAttendanceStatus === 'ANGEMELDET') {
			return (
				<button
					onClick={() => handleAction(meeting.id, 'signoff')}
					className="btn btn-small btn-danger"
				>
					Abmelden
				</button>
			);
		}
		return (
			<button
				onClick={() => handleAction(meeting.id, 'signup')}
				className="btn btn-small btn-success"
			>
				Anmelden
			</button>
		);
	};

	const renderUserStatus = (status) => {
		if (status === 'ANGEMELDET') {
			return <strong className="text-success">Angemeldet</strong>;
		}
		if (status === 'ABGEMELDET') {
			return <span className="text-danger">Abgemeldet</span>;
		}
		return <span className="text-muted">Offen</span>;
	};

	if (loading) return <div>Lade Lehrgänge...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-graduation-cap"></i> Anstehende Lehrgänge & Meetings</h1>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Meeting</th>
							<th>Gehört zu Kurs</th>
							<th>Datum & Uhrzeit</th>
							<th>Dein Status</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{!meetings || meetings.length === 0 ? (
							<tr><td colSpan="5" style={{ textAlign: 'center' }}>Derzeit stehen keine Lehrgänge oder Meetings an.</td></tr>
						) : (
							meetings.map(meeting => (
								<tr key={meeting.id}>
									<td><Link to={`/lehrgaenge/details/${meeting.id}`}>{meeting.name}</Link></td>
									<td>{meeting.parentCourseName}</td>
									<td>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</td>
									<td>{renderUserStatus(meeting.userAttendanceStatus)}</td>
									<td>{renderActionButtons(meeting)}</td>
								</tr>
							))
						)}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{!meetings || meetings.length === 0 ? (
					<div className="card"><p>Derzeit stehen keine Lehrgänge oder Meetings an.</p></div>
				) : (
					meetings.map(meeting => (
						<div className="list-item-card" key={meeting.id}>
							<h3 className="card-title"><Link to={`/lehrgaenge/details/${meeting.id}`}>{meeting.name}</Link></h3>
							<div className="card-row"><strong>Kurs:</strong> <span>{meeting.parentCourseName}</span></div>
							<div className="card-row"><strong>Wann:</strong> <span>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</span></div>
							<div className="card-row"><strong>Status:</strong> <span>{renderUserStatus(meeting.userAttendanceStatus)}</span></div>
							<div className="card-actions">{renderActionButtons(meeting)}</div>
						</div>
					))
				)}
			</div>
		</div>
	);
};

export default LehrgaengePage;
========================================================================
FILE: frontend\src\pages\LoginPage.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';
// import { passkeyService } from '../../services/passkeyService'; // REMOVED

const LoginPage = () => {
	const [username, setUsername] = useState('');
	const [password, setPassword] = useState('');
	const [isPasswordVisible, setIsPasswordVisible] = useState(false);
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');
	const navigate = useNavigate();
	const location = useLocation();

	const login = useAuthStore((state) => state.login);
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

	useEffect(() => {
		if (isAuthenticated) {
			const from = location.state?.from?.pathname || '/home';
			navigate(from, { replace: true });
		}
	}, [isAuthenticated, navigate, location.state]);

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsLoading(true);
		setError('');
		try {
			await login(username, password);
		} catch (err) {
			console.error(err);
			setError(err.message || 'Login fehlgeschlagen. Bitte überprüfen Sie Ihre Eingaben.');
		} finally {
			setIsLoading(false);
		}
	};

	// REMOVED handlePasskeyLogin function

	const togglePasswordVisibility = () => {
		setIsPasswordVisible(!isPasswordVisible);
	};

	return (
		<div className="login-page-container">
			<div className="login-box">
				<h1>
					<i className="fas fa-bolt"></i> TechnikTeam
				</h1>
				{error && <p className="error-message">{error}</p>}
				<form id="login-form" onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="username">Benutzername</label>
						<input
							type="text"
							id="username"
							name="username"
							value={username}
							onChange={(e) => setUsername(e.target.value)}
							required
							autoComplete="username" // REMOVED webauthn
							autoFocus
							disabled={isLoading}
						/>
					</div>
					<div className="form-group">
						<label htmlFor="password">Passwort</label>
						<div className="password-input-wrapper">
							<input
								type={isPasswordVisible ? 'text' : 'password'}
								id="password"
								name="password"
								value={password}
								onChange={(e) => setPassword(e.target.value)}
								required
								autoComplete="current-password"
								disabled={isLoading}
							/>
							<span className="password-toggle-icon" onClick={togglePasswordVisibility} title="Passwort anzeigen/verbergen">
								<i className={`fas ${isPasswordVisible ? 'fa-eye-slash' : 'fa-eye'}`}></i>
							</span>
						</div>
					</div>
					<button
						type="submit"
						className="btn"
						style={{ width: '100%', marginBottom: '0.75rem' }}
						disabled={isLoading}
					>
						{isLoading ? (
							<>
								<i className="fas fa-spinner fa-spin"></i> Anmelden...
							</>
						) : (
							'Anmelden'
						)}
					</button>
					{/* MODIFIED Passkey Button */}
					<button
						type="button"
						className="btn btn-secondary"
						style={{ width: '100%' }}
						disabled={true}
						title="Dieses Feature ist in Kürze verfügbar."
					>
						<i className="fas fa-fingerprint"></i> Mit Passkey anmelden (in Kürze)
					</button>
				</form>
			</div>
		</div>
	);
};

export default LoginPage;
========================================================================
FILE: frontend\src\pages\MeetingDetailsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const MeetingDetailsPage = () => {
	const { meetingId } = useParams();
	const apiCall = useCallback(() => apiClient.get(`/public/meetings/${meetingId}`), [meetingId]);
	const { data, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Meeting-Details...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!data) return <div className="error-message">Meeting nicht gefunden.</div>;

	const { meeting, attachments } = data;

	return (
		<div>
			<h1>{meeting.parentCourseName}</h1>
			<h2 style={{ border: 'none', padding: 0, marginTop: '-1rem' }}>{meeting.name}</h2>

			<div className="responsive-dashboard-grid" style={{ gridTemplateColumns: '2fr 1fr', alignItems: 'flex-start' }}>
				<div className="card">
					<ul className="details-list">
						<li>
							<strong>Datum & Uhrzeit:</strong>
							<span>
								{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}
								{meeting.endDateTime && ` - ${new Date(meeting.endDateTime).toLocaleString('de-DE')}`}
							</span>
						</li>
						<li><strong>Ort:</strong> <span>{meeting.location || 'N/A'}</span></li>
						<li><strong>Leitung:</strong> <span>{meeting.leaderUsername || 'N/A'}</span></li>
					</ul>
					<h3 style={{ marginTop: '2rem' }}>Beschreibung</h3>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
							{meeting.description || 'Keine Beschreibung für dieses Meeting vorhanden.'}
						</ReactMarkdown>
					</div>
				</div>

				<div className="card">
					<h2 className="card-title">Anhänge</h2>
					{attachments?.length > 0 ? (
						<ul className="details-list">
							{attachments.map(att => (
								<li key={att.id}>
									<a href={`/api/v1/public/files/download/${att.id}`} target="_blank" rel="noopener noreferrer">{att.filename}</a>
								</li>
							))}
						</ul>
					) : (
						<p>Für dieses Meeting sind keine Anhänge verfügbar.</p>
					)}
				</div>
			</div>

			<div style={{ marginTop: '1rem' }}>
				<Link to="/lehrgaenge" className="btn btn-secondary">
					<i className="fas fa-arrow-left"></i> Zurück zu allen Lehrgängen
				</Link>
			</div>
		</div>
	);
};

export default MeetingDetailsPage;
========================================================================
FILE: frontend\src\pages\PackKitPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';

const PackKitPage = () => {
	const { kitId } = useParams();
	const apiCall = useCallback(() => apiClient.get(`/public/kits/${kitId}`), [kitId]);
	const { data: kit, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Packliste...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!kit) return <div className="error-message">Kit nicht gefunden.</div>;

	return (
		<div className="card">
			<style>{`
                @media print {
                    body * {
                        visibility: hidden;
                    }
                    .printable-area, .printable-area * {
                        visibility: visible;
                    }
                    .printable-area {
                        position: absolute;
                        left: 0;
                        top: 0;
                        width: 100%;
                    }
                    .no-print {
                        display: none !important;
                    }
                }
            `}</style>
			<div className="printable-area">
				<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
					<div>
						<h1>Packliste: {kit.name}</h1>
						<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
							{kit.description}
						</p>
					</div>
					<button className="btn no-print" onClick={() => window.print()}>
						<i className="fas fa-print"></i> Drucken
					</button>
				</div>

				{kit.location && (
					<div className="card" style={{ backgroundColor: 'var(--bg-color)' }}>
						<h3 className="card-title" style={{ border: 'none', padding: 0 }}>Standort</h3>
						<p style={{ fontSize: '1.2rem', fontWeight: '500' }}>{kit.location}</p>
					</div>
				)}

				<h3 style={{ marginTop: '2rem' }}>Inhalt zum Einpacken</h3>
				<ul className="details-list">
					{!kit.items || kit.items.length === 0 ? (
						<li>Dieses Kit hat keinen definierten Inhalt.</li>
					) : (
						kit.items.map(item => (
							<li key={item.itemId}>
								<label style={{ display: 'flex', alignItems: 'center', gap: '1rem', cursor: 'pointer', width: '100%' }}>
									<input type="checkbox" style={{ width: '1.5rem', height: '1.5rem', flexShrink: 0 }} />
									<span>
										<strong>{item.quantity}x</strong> {item.itemName}
									</span>
								</label>
							</li>
						))
					)}
				</ul>
			</div>
			<div className="no-print" style={{ marginTop: '2rem', textAlign: 'center' }}>
				<Link to="/lager" className="btn btn-secondary">Zurück zur Lagerübersicht</Link>
			</div>
		</div>
	);
};

export default PackKitPage;
========================================================================
FILE: frontend\src\pages\PasswordPage.jsx
========================================================================

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const PasswordPage = () => {
	const [currentPassword, setCurrentPassword] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [confirmPassword, setConfirmPassword] = useState('');
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setError('');

		if (newPassword.length < 10) {
			setError('Das neue Passwort muss mindestens 10 Zeichen lang sein.');
			return;
		}
		if (newPassword !== confirmPassword) {
			setError('Die neuen Passwörter stimmen nicht überein.');
			return;
		}

		setIsLoading(true);

		try {
			const result = await apiClient.put('/public/profile/password', {
				currentPassword,
				newPassword,
				confirmPassword
			});

			if (result.success) {
				addToast('Ihr Passwort wurde erfolgreich geändert.', 'success');
				setCurrentPassword('');
				setNewPassword('');
				setConfirmPassword('');
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsLoading(false);
		}
	};

	return (
		<div style={{ maxWidth: '600px', margin: 'auto' }}>
			<div className="card">
				<h1>Passwort ändern</h1>
				<p className="text-muted" style={{ marginTop: '-1rem', marginBottom: '1.5rem' }}>
					Das neue Passwort muss mindestens 10 Zeichen lang sein und Groß-, Kleinbuchstaben, Zahlen und Sonderzeichen enthalten.
				</p>

				{error && <p className="error-message">{error}</p>}

				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="currentPassword">Aktuelles Passwort</label>
						<input type="password" id="currentPassword" value={currentPassword} onChange={(e) => setCurrentPassword(e.target.value)} required autoComplete="current-password" />
					</div>
					<div className="form-group">
						<label htmlFor="newPassword">Neues Passwort</label>
						<input type="password" id="newPassword" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} required autoComplete="new-password" />
					</div>
					<div className="form-group">
						<label htmlFor="confirmPassword">Neues Passwort bestätigen</label>
						<input type="password" id="confirmPassword" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} required autoComplete="new-password" />
					</div>
					<button type="submit" className="btn" disabled={isLoading}>
						{isLoading ? <><i className="fas fa-spinner fa-spin"></i> Speichern...</> : <><i className="fas fa-save"></i> Passwort speichern</>}
					</button>
					<Link to="/profil" className="btn btn-secondary" style={{ marginLeft: '1rem' }}>Zurück zum Profil</Link>
				</form>
			</div>
		</div>
	);
};

export default PasswordPage;
========================================================================
FILE: frontend\src\pages\ProfilePage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import ProfileDetails from '../components/profile/ProfileDetails';
import ProfileSecurity from '../components/profile/ProfileSecurity';
import ProfileQualifications from '../components/profile/ProfileQualifications';
import ProfileAchievements from '../components/profile/ProfileAchievements';
import ProfileEventHistory from '../components/profile/ProfileEventHistory';
import { useToast } from '../context/ToastContext';

const ProfilePage = () => {
	const { addToast } = useToast();
	const apiCall = useCallback(() => apiClient.get('/public/profile'), []);
	const { data: profileData, loading, error, reload } = useApi(apiCall);

	const handleUpdate = () => {
		addToast('Profildaten aktualisiert', 'success');
		reload();
	};

	if (loading) {
		return (
			<div>
				<h1>Mein Profil</h1>
				<p>Lade Profildaten...</p>
			</div>
		);
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	if (!profileData) {
		return <div>Keine Profildaten gefunden.</div>;
	}

	const { user, eventHistory, qualifications, achievements, passkeys, hasPendingRequest } = profileData;

	return (
		<div>
			<h1><i className="fas fa-user-circle"></i> Mein Profil</h1>
			<p>Hier finden Sie eine Übersicht Ihrer Daten, Qualifikationen und Aktivitäten.</p>
			<div className="responsive-dashboard-grid" id="profile-container">
				<ProfileDetails user={user} hasPendingRequest={hasPendingRequest} onUpdate={handleUpdate} />
				<ProfileSecurity passkeys={passkeys} onUpdate={handleUpdate} />
				<ProfileQualifications qualifications={qualifications} />
				<ProfileAchievements achievements={achievements} />
				<ProfileEventHistory eventHistory={eventHistory} />
			</div>
		</div>
	);
};

export default ProfilePage;
========================================================================
FILE: frontend\src\pages\QrActionPage.jsx
========================================================================

import React, { useCallback, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const QrActionPage = () => {
	const { itemId } = useParams();
	const { addToast } = useToast();
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');

	const itemApiCall = useCallback(() => apiClient.get(`/public/storage/${itemId}`), [itemId]);
	const eventsApiCall = useCallback(() => apiClient.get('/public/events'), []);

	const { data: item, loading: itemLoading, error: itemError, reload: reloadItem } = useApi(itemApiCall);
	const { data: activeEvents, loading: eventsLoading, error: eventsError } = useApi(eventsApiCall);

	const handleTransaction = async (e) => {
		e.preventDefault();
		setIsLoading(true);
		setError('');

		const formData = new FormData(e.target);
		const type = e.nativeEvent.submitter.value;
		const payload = {
			itemId: parseInt(itemId, 10),
			quantity: parseInt(formData.get('quantity'), 10),
			type: type,
			eventId: formData.get('eventId') ? parseInt(formData.get('eventId'), 10) : null,
			notes: formData.get('notes'),
		};

		try {
			const result = await apiClient.post('/public/storage/transactions', payload);
			if (result.success) {
				addToast(result.message, 'success');
				reloadItem(); // Reload item data to show updated quantities
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || `Aktion '${type}' fehlgeschlagen.`);
		} finally {
			setIsLoading(false);
		}
	};

	if (itemLoading || eventsLoading) return <div>Lade...</div>;
	if (itemError) return <div className="error-message">{itemError}</div>;
	if (eventsError) return <div className="error-message">{eventsError}</div>;
	if (!item) return <div className="error-message">Artikel nicht gefunden.</div>;

	return (
		<div className="qr-action-body">
			<div className="card qr-action-container">
				<h1>Aktion für:</h1>
				<h2 className="qr-action-item-name">{item.name}</h2>
				<p>Verfügbar: <strong>{item.availableQuantity}</strong> / {item.maxQuantity}</p>

				{error && <p className="error-message">{error}</p>}

				<form onSubmit={handleTransaction}>
					<div className="form-group">
						<label htmlFor="quantity">Anzahl</label>
						<input type="number" id="quantity" name="quantity" defaultValue="1" min="1" max={item.availableQuantity} required />
					</div>
					<div className="form-group">
						<label htmlFor="eventId">Event (optional)</label>
						<select id="eventId" name="eventId">
							<option value="">Kein Event</option>
							{activeEvents?.map(event => (
								<option key={event.id} value={event.id}>{event.name}</option>
							))}
						</select>
					</div>
					<div className="form-group">
						<label htmlFor="notes">Notiz (optional)</label>
						<input type="text" id="notes" name="notes" />
					</div>
					<div className="qr-action-buttons">
						<button type="submit" name="type" value="checkout" className="btn qr-action-btn btn-danger" disabled={isLoading || item.availableQuantity <= 0}>
							{isLoading ? '...' : 'Entnehmen'}
						</button>
						<button type="submit" name="type" value="checkin" className="btn qr-action-btn btn-success" disabled={isLoading}>
							{isLoading ? '...' : 'Einräumen'}
						</button>
					</div>
				</form>

				<div style={{ marginTop: '2rem' }}>
					<Link to="/lager">Zurück zur Lagerübersicht</Link>
				</div>
			</div>
		</div>
	);
};

export default QrActionPage;
========================================================================
FILE: frontend\src\pages\SearchResultsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { useSearchParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';

const SearchResultsPage = () => {
	const [searchParams] = useSearchParams();
	const query = searchParams.get('q');

	const apiCall = useCallback(() => {
		if (!query) return Promise.resolve({ success: true, data: [] });
		return apiClient.get(`/public/search?query=${encodeURIComponent(query)}`);
	}, [query]);

	const { data: results, loading, error } = useApi(apiCall);

	const getIconForType = (type) => {
		switch (type) {
			case 'Veranstaltung': return 'fa-calendar-check';
			case 'Lagerartikel': return 'fa-cube';
			case 'Lehrgang': return 'fa-graduation-cap';
			case 'Dokumentation': return 'fa-file-alt';
			default: return 'fa-search';
		}
	};

	return (
		<div>
			<h1><i className="fas fa-search"></i> Suchergebnisse</h1>
			{query ? (
				<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
					Ergebnisse für: <strong>"{query}"</strong>
				</p>
			) : (
				<p>Bitte geben Sie einen Suchbegriff in die Suchleiste ein.</p>
			)}

			{loading && <div>Suche läuft...</div>}
			{error && <div className="error-message">{error}</div>}

			{results && (
				<div className="card">
					{results.length === 0 && !loading ? (
						<p>Keine Ergebnisse für Ihre Suche gefunden.</p>
					) : (
						<ul className="details-list">
							{results.map((result, index) => (
								<li key={index} style={{ alignItems: 'flex-start' }}>
									<div style={{ flex: '1' }}>
										<Link to={result.url}>
											<i className={`fas ${getIconForType(result.type)} fa-fw`}></i>
											<strong> {result.title}</strong>
										</Link>
										<small style={{ display: 'block', color: 'var(--text-muted-color)', marginLeft: '1.75rem' }}>
											{result.snippet}
										</small>
									</div>
									<span className="status-badge status-info">{result.type}</span>
								</li>
							))}
						</ul>
					)}
				</div>
			)}
		</div>
	);
};

export default SearchResultsPage;
========================================================================
FILE: frontend\src\pages\StorageItemDetailsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import Lightbox from '../components/ui/Lightbox';
import DamageReportModal from '../components/storage/DamageReportModal';
import { useToast } from '../context/ToastContext';

const StorageItemDetailsPage = () => {
	const { itemId } = useParams();
	const [activeTab, setActiveTab] = useState('history');
	const [isLightboxOpen, setIsLightboxOpen] = useState(false);
	const [isReportModalOpen, setIsReportModalOpen] = useState(false);
	const { addToast } = useToast();

	const fetchItemCall = useCallback(() => apiClient.get(`/public/storage/${itemId}`), [itemId]);
	const fetchHistoryCall = useCallback(() => apiClient.get(`/public/storage/${itemId}/history`), [itemId]);

	const { data: itemData, loading: itemLoading, error: itemError, reload: reloadItem } = useApi(fetchItemCall);
	const { data: historyData, loading: historyLoading, error: historyError } = useApi(fetchHistoryCall);


	const handleReportSuccess = () => {
		setIsReportModalOpen(false);
		addToast('Schadensmeldung erfolgreich übermittelt.', 'success');
		// No need to reload data, as the report is handled by admins
	};

	if (itemLoading || historyLoading) return <div>Lade Artikeldetails...</div>;
	if (itemError) return <div className="error-message">{itemError}</div>;
	if (!itemData) return <div className="error-message">Artikel nicht gefunden.</div>;

	const item = itemData;
	const { transactions, maintenance } = historyData || { transactions: [], maintenance: [] };

	return (
		<>
			<h1><i className="fas fa-cube"></i> Artikeldetails</h1>
			<div className="responsive-dashboard-grid" style={{ alignItems: 'flex-start' }}>
				<div className="card">
					<h2 className="card-title">{item.name}</h2>
					{item.imagePath && (
						<img
							src={`/api/v1/public/files/images/${item.imagePath}`}
							alt={item.name}
							style={{ width: '100%', borderRadius: 'var(--border-radius)', marginBottom: '1rem', cursor: 'zoom-in' }}
							onClick={() => setIsLightboxOpen(true)}
						/>
					)}
					<ul className="details-list">
						<li><strong>Allg. Status:</strong> <span className={`status-badge ${item.availabilityStatusCssClass}`}>{item.availabilityStatus}</span></li>
						<li><strong>Verfügbar / Gesamt:</strong> <span>{item.availableQuantity} / {item.quantity}</span></li>
						<li><strong>Defekt:</strong> <span>{item.defectiveQuantity}</span></li>
						<li><strong>Tracking-Status:</strong> <span>{item.status}</span></li>
						{item.currentHolderUsername && <li><strong>Aktueller Inhaber:</strong> <span>{item.currentHolderUsername}</span></li>}
						<li><strong>Ort:</strong> <span>{item.location}</span></li>
						<li><strong>Schrank:</strong> <span>{item.cabinet || 'N/A'}</span></li>
						<li><strong>Fach:</strong> <span>{item.compartment || 'N/A'}</span></li>
					</ul>
					<button className="btn btn-warning" style={{ marginTop: '1.5rem' }} onClick={() => setIsReportModalOpen(true)}>
						<i className="fas fa-tools"></i> Schaden melden
					</button>
				</div>

				<div className="card">
					<div className="modal-tabs">
						<button className={`modal-tab-button ${activeTab === 'history' ? 'active' : ''}`} onClick={() => setActiveTab('history')}>Verlauf</button>
						<button className={`modal-tab-button ${activeTab === 'maintenance' ? 'active' : ''}`} onClick={() => setActiveTab('maintenance')}>Wartungshistorie</button>
					</div>

					{activeTab === 'history' && (
						<div className="modal-tab-content active">
							{historyError && <p className="error-message">{historyError}</p>}
							{!historyLoading && transactions.length === 0 && <p>Kein Verlauf für diesen Artikel vorhanden.</p>}
							{transactions.length > 0 && (
								<div className="table-wrapper" style={{ maxHeight: '60vh', overflowY: 'auto' }}>
									<table className="data-table">
										<thead><tr><th>Wann</th><th>Aktion</th><th>Wer</th><th>Notiz</th></tr></thead>
										<tbody>
											{transactions.map(entry => (
												<tr key={entry.id}>
													<td>{new Date(entry.transactionTimestamp).toLocaleString('de-DE')}</td>
													<td><span className={`status-badge ${entry.quantityChange > 0 ? 'status-ok' : 'status-danger'}`}>{entry.quantityChange > 0 ? '+' : ''}{entry.quantityChange}</span></td>
													<td>{entry.username}</td>
													<td>{entry.notes || '-'}</td>
												</tr>
											))}
										</tbody>
									</table>
								</div>
							)}
						</div>
					)}

					{activeTab === 'maintenance' && (
						<div className="modal-tab-content active">
							{historyError && <p className="error-message">{historyError}</p>}
							{!historyLoading && maintenance.length === 0 && <p>Keine Wartungseinträge für diesen Artikel vorhanden.</p>}
							{maintenance.length > 0 && (
								<div className="table-wrapper" style={{ maxHeight: '60vh', overflowY: 'auto' }}>
									<table className="data-table">
										<thead><tr><th>Datum</th><th>Aktion</th><th>Bearbeiter</th><th>Notiz</th></tr></thead>
										<tbody>
											{maintenance.map(entry => (
												<tr key={entry.id}>
													<td>{new Date(entry.logDate).toLocaleString('de-DE')}</td>
													<td>{entry.action}</td>
													<td>{entry.username}</td>
													<td>{entry.notes || '-'}</td>
												</tr>
											))}
										</tbody>
									</table>
								</div>
							)}
						</div>
					)}
				</div>
			</div>
			<div style={{ marginTop: '1rem' }}>
				<Link to="/lager" className="btn btn-secondary"><i className="fas fa-arrow-left"></i> Zur Lagerübersicht</Link>
			</div>

			{isLightboxOpen && <Lightbox src={`/api/v1/public/files/images/${item.imagePath}`} onClose={() => setIsLightboxOpen(false)} />}

			<DamageReportModal
				isOpen={isReportModalOpen}
				onClose={() => setIsReportModalOpen(false)}
				onSuccess={handleReportSuccess}
				item={item}
			/>
		</>
	);
};

export default StorageItemDetailsPage;
========================================================================
FILE: frontend\src\pages\StoragePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import Modal from '../components/ui/Modal';
import Lightbox from '../components/ui/Lightbox';
import { useToast } from '../context/ToastContext';

const StoragePage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/storage'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [selectedItem, setSelectedItem] = useState(null);
	const [isLightboxOpen, setIsLightboxOpen] = useState(false);
	const [lightboxSrc, setLightboxSrc] = useState('');
	const [transactionError, setTransactionError] = useState('');
	const { addToast } = useToast();

	const handleActionClick = (item) => {
		setSelectedItem(item);
		setTransactionError('');
		setIsModalOpen(true);
	};

	const handleImageClick = (imagePath) => {
		setLightboxSrc(`/api/v1/public/files/images/${imagePath}`);
		setIsLightboxOpen(true);
	};

	const handleTransactionSubmit = async (e) => {
		e.preventDefault();
		const submitter = e.nativeEvent.submitter;
		const formData = new FormData(e.target);
		const quantity = parseInt(formData.get('quantity'), 10);

		if (isNaN(quantity) || quantity < 1) {
			setTransactionError("Bitte geben Sie eine gültige Anzahl an.");
			return;
		}

		const transactionData = {
			itemId: selectedItem.id,
			quantity: quantity,
			type: submitter.value,
			notes: formData.get('notes'),
			eventId: formData.get('eventId') ? parseInt(formData.get('eventId'), 10) : null,
		};

		try {
			const result = await apiClient.post('/public/storage/transactions', transactionData);
			if (result.success) {
				addToast(result.message, 'success');
				setIsModalOpen(false);
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setTransactionError(err.message || 'Transaction failed.');
		}
	};

	if (loading) return <div>Lade Lagerdaten...</div>;
	if (error) return <div className="error-message">{error}</div>;

	const { storageData, activeEvents } = data;

	const renderItemsForLocation = (items) => (
		<>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Gerät</th>
							<th>Schrank</th>
							<th>Fach</th>
							<th>Status</th>
							<th>Bestand</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{items.map(item => (
							<tr key={item.id}>
								<td className="item-name-cell">
									<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
									{item.imagePath && (
										<button className="btn btn-small btn-secondary" style={{ marginLeft: '0.5rem', padding: '0.2rem 0.5rem' }} title="Bild anzeigen" onClick={() => handleImageClick(item.imagePath)}>
											<i className="fas fa-camera"></i>
										</button>
									)}
								</td>
								<td>{item.cabinet || '-'}</td>
								<td>{item.compartment || '-'}</td>
								<td>
									<span className={`status-badge ${item.availabilityStatusCssClass}`}>
										{item.availabilityStatus}
									</span>
								</td>
								<td>
									<span>{item.availableQuantity} / {item.maxQuantity}</span>
									{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} defekt)</span>}
								</td>
								<td>
									<button className="btn btn-small" onClick={() => handleActionClick(item)}>Aktion</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			<div className="mobile-card-list">
				{items.map(item => (
					<div className="list-item-card" key={item.id}>
						<h3 className="card-title">
							<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
							{item.imagePath && (
								<button className="btn btn-small btn-secondary" style={{ marginLeft: '0.5rem', padding: '0.2rem 0.5rem' }} title="Bild anzeigen" onClick={() => handleImageClick(item.imagePath)}>
									<i className="fas fa-camera"></i>
								</button>
							)}
						</h3>
						<div className="card-row"><strong>Status:</strong> <span className={`status-badge ${item.availabilityStatusCssClass}`}>{item.availabilityStatus}</span></div>
						<div className="card-row"><strong>Bestand:</strong> <span>{item.availableQuantity} / {item.maxQuantity}{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} def.)</span>}</span></div>
						<div className="card-row"><strong>Schrank:</strong> <span>{item.cabinet || '-'}</span></div>
						<div className="card-row"><strong>Fach:</strong> <span>{item.compartment || '-'}</span></div>
						<div className="card-actions">
							<button className="btn btn-small" onClick={() => handleActionClick(item)}>Aktion</button>
						</div>
					</div>
				))}
			</div>
		</>
	);

	return (
		<>
			<h1><i className="fas fa-boxes"></i> Lagerübersicht</h1>
			<p>Hier finden Sie eine Übersicht aller erfassten Artikel im Lager. Klicken Sie auf einen Artikelnamen für Details und Verlauf.</p>

			{Object.entries(storageData).map(([location, items]) => (
				<div className="card" key={location}>
					<h2><i className="fas fa-map-marker-alt"></i> {location}</h2>
					{renderItemsForLocation(items)}
				</div>
			))}

			{selectedItem && (
				<Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title={`${selectedItem.name}: Entnehmen / Einräumen`}>
					<form onSubmit={handleTransactionSubmit}>
						{transactionError && <p className="error-message">{transactionError}</p>}
						<div className="form-group">
							<label htmlFor="transaction-quantity">Anzahl</label>
							<input type="number" name="quantity" id="transaction-quantity" defaultValue="1" min="1" max={selectedItem.availableQuantity} required />
						</div>
						<div className="form-group">
							<label htmlFor="transaction-notes">Notiz (optional)</label>
							<input type="text" name="notes" id="transaction-notes" placeholder="z.B. für Event XYZ" />
						</div>
						<div className="form-group">
							<label htmlFor="transaction-eventId">Zuweisen zu Event (optional)</label>
							<select name="eventId" id="transaction-eventId">
								<option value="">Kein Event</option>
								{activeEvents.map(event => (
									<option key={event.id} value={event.id}>{event.name}</option>
								))}
							</select>
						</div>
						<div style={{ display: 'flex', justifyContent: 'space-between', gap: '1rem' }}>
							<button type="submit" name="type" value="checkout" className="btn btn-danger" style={{ flexGrow: 1 }} disabled={selectedItem.availableQuantity <= 0}>Entnehmen</button>
							<button type="submit" name="type" value="checkin" className="btn btn-success" style={{ flexGrow: 1 }} disabled={selectedItem.maxQuantity > 0 && selectedItem.quantity >= selectedItem.maxQuantity}>Einräumen</button>
						</div>
					</form>
				</Modal>
			)}

			{isLightboxOpen && <Lightbox src={lightboxSrc} onClose={() => setIsLightboxOpen(false)} />}
		</>
	);
};

export default StoragePage;
========================================================================
FILE: frontend\src\pages\admin\AdminAchievementsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminAchievementsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/achievements'), []);
	const { data: achievements, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingAchievement, setEditingAchievement] = useState(null);
	const { addToast } = useToast();

	const openModal = (achievement = null) => {
		setEditingAchievement(achievement);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingAchievement(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (ach) => {
		if (window.confirm(`Abzeichen "${ach.name}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/achievements/${ach.id}`);
				if (result.success) {
					addToast('Abzeichen erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-award"></i> Abzeichen verwalten</h1>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Abzeichen
				</button>
			</div>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Icon</th>
							<th>Name</th>
							<th>Schlüssel</th>
							<th>Beschreibung</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="5">Lade Abzeichen...</td></tr>}
						{error && <tr><td colSpan="5" className="error-message">{error}</td></tr>}
						{achievements?.map(ach => (
							<tr key={ach.id}>
								<td><i className={`fas ${ach.iconClass}`} style={{ fontSize: '1.5rem' }}></i></td>
								<td>{ach.name}</td>
								<td><code>{ach.achievementKey}</code></td>
								<td>{ach.description}</td>
								<td>
									<button onClick={() => openModal(ach)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(ach)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{isModalOpen && (
				<AchievementModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					achievement={editingAchievement}
				/>
			)}
		</div>
	);
};

const AchievementModal = ({ isOpen, onClose, onSuccess, achievement }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		try {
			const result = achievement
				? await apiClient.put(`/achievements/${achievement.id}`, data)
				: await apiClient.post('/achievements', data);
			if (result.success) {
				addToast(`Abzeichen erfolgreich ${achievement ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={achievement ? 'Abzeichen bearbeiten' : 'Neues Abzeichen erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="modal-name">Name</label>
					<input id="modal-name" name="name" defaultValue={achievement?.name} required />
				</div>
				<div className="form-group">
					<label htmlFor="modal-key">Achievement Schlüssel</label>
					<input id="modal-key" name="achievementKey" defaultValue={achievement?.achievementKey} required pattern="[A-Z0-9_]+" title="Nur Großbuchstaben, Zahlen und Unterstriche" />
				</div>
				<div className="form-group">
					<label htmlFor="modal-desc">Beschreibung</label>
					<textarea id="modal-desc" name="description" defaultValue={achievement?.description} rows="3" required></textarea>
				</div>
				<div className="form-group">
					<label htmlFor="modal-icon">Font Awesome Icon-Klasse</label>
					<input id="modal-icon" name="iconClass" defaultValue={achievement?.iconClass} placeholder="z.B. fa-star" required />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminAchievementsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminChangelogPage.jsx
========================================================================

import React, { useState, useCallback, useEffect } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const AdminChangelogPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/changelogs'), []);
	const { data: changelogs, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingChangelog, setEditingChangelog] = useState(null);
	const { addToast } = useToast();

	const openModal = (changelog = null) => {
		setEditingChangelog(changelog);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingChangelog(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (changelog) => {
		if (window.confirm(`Changelog für Version "${changelog.version}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/changelogs/${changelog.id}`);
				if (result.success) {
					addToast('Changelog gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-history"></i> Changelogs verwalten</h1>
			<p>Verwalten Sie hier die "Was ist neu?"-Benachrichtigungen für die Benutzer.</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neuer Changelog-Eintrag
				</button>
			</div>
			{loading && <p>Lade Changelogs...</p>}
			{error && <p className="error-message">{error}</p>}
			{changelogs?.map(cl => (
				<div className="card" key={cl.id}>
					<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
						<h2 className="card-title" style={{ border: 'none', padding: 0 }}>Version {cl.version} - {cl.title}</h2>
						<div>
							<button onClick={() => openModal(cl)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => handleDelete(cl)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
						</div>
					</div>
					<p className="details-subtitle" style={{ marginTop: '-0.5rem' }}>
						Veröffentlicht: {new Date(cl.releaseDate).toLocaleDateString('de-DE')} | Status: {cl.isPublished ? 'Publiziert' : 'Entwurf'}
					</p>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>{cl.notes}</ReactMarkdown>
					</div>
				</div>
			))}
			{isModalOpen && (
				<ChangelogModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					changelog={editingChangelog}
				/>
			)}
		</div>
	);
};

const ChangelogModal = ({ isOpen, onClose, onSuccess, changelog }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const [isPublished, setIsPublished] = useState(changelog ? changelog.isPublished : true);
	const { addToast } = useToast();

	useEffect(() => {
		setIsPublished(changelog ? changelog.isPublished : true);
	}, [changelog]);

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const data = {
			version: formData.get('version'),
			releaseDate: formData.get('releaseDate'),
			title: formData.get('title'),
			notes: formData.get('notes'),
			isPublished: isPublished
		};

		try {
			const result = changelog
				? await apiClient.put(`/admin/changelogs/${changelog.id}`, data)
				: await apiClient.post('/admin/changelogs', data);
			if (result.success) {
				addToast(`Changelog erfolgreich ${changelog ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={changelog ? 'Changelog bearbeiten' : 'Neuen Changelog erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label>Version (z.B. 2.1.0)</label>
					<input name="version" defaultValue={changelog?.version} required />
				</div>
				<div className="form-group">
					<label>Titel</label>
					<input name="title" defaultValue={changelog?.title} required />
				</div>
				<div className="form-group">
					<label>Veröffentlichungsdatum</label>
					<input type="date" name="releaseDate" defaultValue={changelog?.releaseDate} required />
				</div>
				<div className="form-group">
					<label>Anmerkungen (Markdown unterstützt)</label>
					<textarea name="notes" defaultValue={changelog?.notes} rows="10" required></textarea>
				</div>
				<div className="form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
					<input type="checkbox" id="isPublished" name="isPublished" checked={isPublished} onChange={(e) => setIsPublished(e.target.checked)} style={{ width: 'auto' }} />
					<label htmlFor="isPublished" style={{ marginBottom: 0 }}>Veröffentlicht (sichtbar für Benutzer)</label>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminChangelogPage;
========================================================================
FILE: frontend\src\pages\admin\AdminChecklistTemplatesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminChecklistTemplatesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/checklist-templates'), []);
	const { data: templates, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingTemplate, setEditingTemplate] = useState(null);
	const { addToast } = useToast();

	const openModal = (template = null) => {
		setEditingTemplate(template);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingTemplate(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (template) => {
		if (window.confirm(`Vorlage "${template.name}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/checklist-templates/${template.id}`);
				if (result.success) {
					addToast('Vorlage gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-tasks"></i> Pre-Flight Checklisten-Vorlagen</h1>
			<p>Verwalten Sie hier Vorlagen für wiederverwendbare Checklisten (z.B. für Standard-Setups).</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neue Vorlage erstellen
				</button>
			</div>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Beschreibung</th>
							<th>Anzahl Items</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Vorlagen...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{templates?.map(template => (
							<tr key={template.id}>
								<td>{template.name}</td>
								<td>{template.description}</td>
								<td>{template.items?.length || 0}</td>
								<td>
									<button onClick={() => openModal(template)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(template)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{isModalOpen && (
				<TemplateModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					template={editingTemplate}
				/>
			)}
		</div>
	);
};

const TemplateModal = ({ isOpen, onClose, onSuccess, template }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const [items, setItems] = useState(template?.items || [{ itemText: '' }]);
	const { addToast } = useToast();

	const handleItemChange = (index, value) => {
		const newItems = [...items];
		newItems[index].itemText = value;
		setItems(newItems);
	};

	const handleAddItem = () => setItems([...items, { itemText: '' }]);
	const handleRemoveItem = (index) => setItems(items.filter((_, i) => i !== index));

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const data = {
			name: formData.get('name'),
			description: formData.get('description'),
			items: items.filter(item => item.itemText.trim() !== '')
		};

		try {
			const result = template
				? await apiClient.put(`/admin/checklist-templates/${template.id}`, data)
				: await apiClient.post('/admin/checklist-templates', data);
			if (result.success) {
				addToast(`Vorlage erfolgreich ${template ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={template ? 'Vorlage bearbeiten' : 'Neue Vorlage erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label>Name der Vorlage</label>
					<input name="name" defaultValue={template?.name} required />
				</div>
				<div className="form-group">
					<label>Beschreibung</label>
					<textarea name="description" defaultValue={template?.description} rows="2"></textarea>
				</div>
				<div className="form-group">
					<label>Checklisten-Punkte</label>
					{items.map((item, index) => (
						<div className="dynamic-row" key={index}>
							<input
								value={item.itemText}
								onChange={e => handleItemChange(index, e.target.value)}
								placeholder={`Punkt #${index + 1}`}
								className="form-group"
							/>
							<button type="button" onClick={() => handleRemoveItem(index)} className="btn btn-small btn-danger">×</button>
						</div>
					))}
					<button type="button" onClick={handleAddItem} className="btn btn-small btn-secondary" style={{ marginTop: '0.5rem' }}>Punkt hinzufügen</button>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminChecklistTemplatesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminCoursesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminCoursesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/courses'), []);
	const { data: courses, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingCourse, setEditingCourse] = useState(null);
	const [formError, setFormError] = useState('');
	const { addToast } = useToast();

	const handleOpenNewModal = () => {
		setEditingCourse(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (course) => {
		setEditingCourse(course);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingCourse(null);
		setFormError('');
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		try {
			const result = editingCourse
				? await apiClient.put(`/courses/${editingCourse.id}`, data)
				: await apiClient.post('/courses', data);

			if (result.success) {
				addToast(`Vorlage erfolgreich ${editingCourse ? 'aktualisiert' : 'erstellt'}.`, 'success');
				handleCloseModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Ein Fehler ist aufgetreten.');
		}
	};

	const handleDelete = async (course) => {
		if (window.confirm(`Vorlage '${course.name}' wirklich löschen? Alle zugehörigen Meetings und Qualifikationen werden auch gelöscht!`)) {
			try {
				const result = await apiClient.delete(`/courses/${course.id}`);
				if (result.success) {
					addToast('Vorlage erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-book"></i> Lehrgangs-Vorlagen verwalten</h1>
			<p>Dies sind die übergeordneten Lehrgänge. Einzelne Termine (Meetings) werden für jede Vorlage separat verwaltet.</p>

			<div className="table-controls">
				<button onClick={handleOpenNewModal} className="btn btn-success">
					<i className="fas fa-plus"></i> Neue Vorlage
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name der Vorlage</th>
							<th>Abkürzung (für Matrix)</th>
							<th style={{ minWidth: '350px' }}>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="3">Lade Vorlagen...</td></tr>}
						{error && <tr><td colSpan="3" className="error-message">{error}</td></tr>}
						{courses?.map(course => (
							<tr key={course.id}>
								<td>{course.name}</td>
								<td>{course.abbreviation}</td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<Link to={`/admin/lehrgaenge/${course.id}/meetings`} className="btn btn-small">
										<i className="fas fa-calendar-day"></i> Meetings
									</Link>
									<button onClick={() => handleOpenEditModal(course)} className="btn btn-small btn-secondary">
										<i className="fas fa-edit"></i> Bearbeiten
									</button>
									<button onClick={() => handleDelete(course)} className="btn btn-small btn-danger">
										<i className="fas fa-trash"></i> Löschen
									</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Vorlagen...</p>}
				{error && <p className="error-message">{error}</p>}
				{courses?.map(course => (
					<div className="list-item-card" key={course.id}>
						<h3 className="card-title">{course.name}</h3>
						<div className="card-row"><strong>Abkürzung:</strong> <span>{course.abbreviation}</span></div>
						<div className="card-actions">
							<Link to={`/admin/lehrgaenge/${course.id}/meetings`} className="btn btn-small">
								<i className="fas fa-calendar-day"></i> Meetings
							</Link>
							<button onClick={() => handleOpenEditModal(course)} className="btn btn-small btn-secondary">
								<i className="fas fa-edit"></i> Bearbeiten
							</button>
							<button onClick={() => handleDelete(course)} className="btn btn-small btn-danger">
								<i className="fas fa-trash"></i> Löschen
							</button>
						</div>
					</div>
				))}
			</div>

			{isModalOpen && (
				<Modal isOpen={isModalOpen} onClose={handleCloseModal} title={editingCourse ? "Lehrgangs-Vorlage bearbeiten" : "Neue Lehrgangs-Vorlage anlegen"}>
					<form onSubmit={handleSubmit}>
						{formError && <p className="error-message">{formError}</p>}
						<div className="form-group">
							<label htmlFor="name-modal">Name der Vorlage</label>
							<input type="text" id="name-modal" name="name" defaultValue={editingCourse?.name} required />
						</div>
						<div className="form-group">
							<label htmlFor="abbreviation-modal">Abkürzung (max. 10 Zeichen)</label>
							<input type="text" id="abbreviation-modal" name="abbreviation" defaultValue={editingCourse?.abbreviation} maxLength="10" required />
						</div>
						<div className="form-group">
							<label htmlFor="description-modal">Allgemeine Beschreibung</label>
							<textarea id="description-modal" name="description" defaultValue={editingCourse?.description} rows="4"></textarea>
						</div>
						<button type="submit" className="btn">
							<i className="fas fa-save"></i> Vorlage Speichern
						</button>
					</form>
				</Modal>
			)}
		</div>
	);
};

export default AdminCoursesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDamageReportsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminDamageReportsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/damage-reports/pending'), []);
	const { data: reports, loading, error, reload } = useApi(apiCall);
	const [selectedReport, setSelectedReport] = useState(null);
	const [action, setAction] = useState(null); // 'confirm' or 'reject'
	const { addToast } = useToast();

	const openModal = (report, act) => {
		setSelectedReport(report);
		setAction(act);
	};

	const closeModal = () => {
		setSelectedReport(null);
		setAction(null);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	return (
		<div>
			<h1><i className="fas fa-tools"></i> Offene Schadensmeldungen</h1>
			<p>Hier sehen Sie alle von Benutzern gemeldeten Schäden, die noch nicht von einem Admin bestätigt wurden.</p>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Gemeldet am</th>
							<th>Artikel</th>
							<th>Gemeldet von</th>
							<th>Beschreibung</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="5">Lade Meldungen...</td></tr>}
						{error && <tr><td colSpan="5" className="error-message">{error}</td></tr>}
						{reports?.length === 0 && <tr><td colSpan="5" style={{ textAlign: 'center' }}>Keine offenen Meldungen vorhanden.</td></tr>}
						{reports?.map(report => (
							<tr key={report.id}>
								<td>{new Date(report.reportedAt).toLocaleString('de-DE')}</td>
								<td><Link to={`/lager/details/${report.itemId}`}>{report.itemName}</Link></td>
								<td>{report.reporterUsername}</td>
								<td style={{ whiteSpace: 'normal' }}>{report.reportDescription}</td>
								<td style={{ display: 'flex', gap: '0.5rem' }}>
									<button onClick={() => openModal(report, 'confirm')} className="btn btn-small btn-success">Bestätigen</button>
									<button onClick={() => openModal(report, 'reject')} className="btn btn-small btn-danger">Ablehnen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{/* Mobile view could be added here if necessary */}

			{selectedReport && (
				<ActionModal
					isOpen={!!selectedReport}
					onClose={closeModal}
					onSuccess={handleSuccess}
					report={selectedReport}
					action={action}
				/>
			)}
		</div>
	);
};

const ActionModal = ({ isOpen, onClose, onSuccess, report, action }) => {
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');
	const [notes, setNotes] = useState('');
	const [quantity, setQuantity] = useState(1);
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsLoading(true);
		setError('');

		try {
			const payload = action === 'confirm' ? { quantity } : { adminNotes: notes };
			const result = await apiClient.post(`/admin/damage-reports/${report.id}/${action}`, payload);

			if (result.success) {
				addToast(result.message, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Aktion fehlgeschlagen');
		} finally {
			setIsLoading(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={`Meldung #${report.id} ${action === 'confirm' ? 'bestätigen' : 'ablehnen'}`}>
			<p><strong>Artikel:</strong> {report.itemName}</p>
			<p><strong>Beschreibung des Nutzers:</strong> {report.reportDescription}</p>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				{action === 'confirm' && (
					<div className="form-group">
						<label htmlFor="quantity">Anzahl als defekt markieren</label>
						<input type="number" id="quantity" value={quantity} onChange={e => setQuantity(parseInt(e.target.value, 10))} min="1" required />
					</div>
				)}
				{action === 'reject' && (
					<div className="form-group">
						<label htmlFor="notes">Grund für die Ablehnung (optional)</label>
						<textarea id="notes" value={notes} onChange={e => setNotes(e.target.value)} rows="3"></textarea>
					</div>
				)}
				<div style={{ display: 'flex', justifyContent: 'flex-end', gap: '0.5rem', marginTop: '1rem' }}>
					<button type="button" className="btn btn-secondary" onClick={onClose} disabled={isLoading}>Abbrechen</button>
					<button type="submit" className={`btn ${action === 'confirm' ? 'btn-success' : 'btn-danger'}`} disabled={isLoading}>
						{isLoading ? 'Wird verarbeitet...' : (action === 'confirm' ? 'Bestätigen' : 'Ablehnen')}
					</button>
				</div>
			</form>
		</Modal>
	);
};


export default AdminDamageReportsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDashboardPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useAuthStore } from '../../store/authStore';
import Widget from '../../components/admin/dashboard/Widget';
import EventTrendChart from '../../components/admin/dashboard/EventTrendChart';

const AdminDashboardPage = () => {
	const { user } = useAuthStore();
	// This single endpoint now provides all necessary data for the dashboard.
	const apiCall = useCallback(() => apiClient.get('/admin/dashboard'), []);
	const { data: dashboardData, loading, error } = useApi(apiCall);

	const renderWidgetContent = (widgetData, renderItem, emptyMessage) => {
		if (!widgetData || widgetData.length === 0) {
			return <p>{emptyMessage}</p>;
		}
		return <ul className="details-list">{widgetData.map(renderItem)}</ul>;
	};

	if (loading) {
		return <h1>Lade Admin Dashboard...</h1>;
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>Willkommen im Admin-Bereich, {user?.username}!</h1>
			<p>Hier können Sie die Anwendung verwalten. Wählen Sie eine Option aus der Navigation oder nutzen Sie den Schnellzugriff.</p>

			<div className="dashboard-grid">
				<Widget icon="fa-calendar-alt" title="Anstehende Events" linkTo="/admin/veranstaltungen" linkText="Alle Events anzeigen">
					{renderWidgetContent(
						dashboardData?.upcomingEvents,
						(event) => (
							<li key={event.id}>
								<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
								<small>{new Date(event.eventDateTime).toLocaleDateString('de-DE')}</small>
							</li>
						),
						'Keine anstehenden Events.'
					)}
				</Widget>

				<Widget icon="fa-box-open" title="Niedriger Lagerbestand" linkTo="/admin/lager" linkText="Lager verwalten">
					{renderWidgetContent(
						dashboardData?.lowStockItems,
						(item) => (
							<li key={item.id}>
								<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
								<span className="status-badge status-warn">{item.availableQuantity} / {item.maxQuantity}</span>
							</li>
						),
						'Alle Artikel sind ausreichend vorhanden.'
					)}
				</Widget>

				<Widget icon="fa-history" title="Letzte Aktionen" linkTo="/admin/log" linkText="Alle Logs anzeigen">
					{renderWidgetContent(
						dashboardData?.recentLogs,
						(log) => (
							<li key={log.id}>
								<span><strong>{log.adminUsername}</strong>: {log.actionType}</span>
								<small>{new Date(log.actionTimestamp).toLocaleString('de-DE')}</small>
							</li>
						),
						'Keine Aktionen protokolliert.'
					)}
				</Widget>
			</div>

			<div className="card" style={{ marginTop: '2rem' }}>
				<h2 className="card-title">Event-Trend (Letzte 12 Monate)</h2>
				<EventTrendChart trendData={dashboardData?.eventTrendData} />
			</div>
		</div>
	);
};

export default AdminDashboardPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDebriefingsListPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const AdminDebriefingsListPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/events/debriefings'), []);
	const { data: debriefings, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Debriefings...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-clipboard-check"></i> Event-Debriefings</h1>
			<p>Eine Übersicht aller nachbereiteten Veranstaltungen zur Analyse und Verbesserung.</p>

			{debriefings?.length === 0 ? (
				<div className="card"><p>Es wurden noch keine Debriefings eingereicht.</p></div>
			) : (
				debriefings?.map(debrief => (
					<div className="card" key={debrief.id}>
						<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
							<h2 className="card-title" style={{ border: 'none', padding: 0 }}>
								<Link to={`/admin/veranstaltungen/${debrief.eventId}/debriefing`}>{debrief.eventName}</Link>
							</h2>
							<small>Eingereicht von {debrief.authorUsername} am {new Date(debrief.submittedAt).toLocaleDateString('de-DE')}</small>
						</div>
						<div className="responsive-dashboard-grid" style={{ alignItems: 'flex-start' }}>
							<div>
								<h4>Was lief gut?</h4>
								<div className="markdown-content"><ReactMarkdown rehypePlugins={[rehypeSanitize]}>{debrief.whatWentWell}</ReactMarkdown></div>
							</div>
							<div>
								<h4>Was kann verbessert werden?</h4>
								<div className="markdown-content"><ReactMarkdown rehypePlugins={[rehypeSanitize]}>{debrief.whatToImprove}</ReactMarkdown></div>
							</div>
						</div>
						{debrief.standoutCrewDetails?.length > 0 && (
							<div style={{ marginTop: '1rem' }}>
								<h4>Besonders hervorgehobene Mitglieder:</h4>
								<p>{debrief.standoutCrewDetails.map(u => u.username).join(', ')}</p>
							</div>
						)}
					</div>
				))
			)}
		</div>
	);
};

export default AdminDebriefingsListPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDefectivePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StorageItemModal from '../../components/admin/storage/StorageItemModal';
import { useToast } from '../../context/ToastContext';

const AdminDefectivePage = () => {
	const apiCall = useCallback(() => apiClient.get('/storage?status=defective'), []);
	const { data: items, loading, error, reload } = useApi(apiCall);
	const [modalState, setModalState] = useState({ isOpen: false, item: null, mode: 'defect' });
	const { addToast } = useToast();

	const openModal = (mode, item) => {
		setModalState({ isOpen: true, item, mode });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, item: null, mode: 'defect' });
	};

	const handleSuccess = () => {
		addToast('Status erfolgreich aktualisiert', 'success');
		closeModal();
		reload();
	};

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade defekte Artikel...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!items || items.length === 0) return <tr><td colSpan="4" style={{ textAlign: 'center' }}>Aktuell sind keine Artikel als defekt gemeldet.</td></tr>;

		return items.map(item => (
			<tr key={item.id}>
				<td><Link to={`/lager/details/${item.id}`}>{item.name}</Link></td>
				<td>{item.defectiveQuantity} / {item.quantity}</td>
				<td>{item.defectReason || '-'}</td>
				<td>
					<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Status bearbeiten</button>
				</td>
			</tr>
		));
	};

	const renderMobileList = () => {
		if (loading) return <p>Lade defekte Artikel...</p>;
		if (error) return <p className="error-message">{error}</p>;
		if (!items || items.length === 0) return <div className="card"><p>Aktuell sind keine Artikel als defekt gemeldet.</p></div>;

		return items.map(item => (
			<div className="list-item-card" key={item.id}>
				<h3 className="card-title"><Link to={`/lager/details/${item.id}`}>{item.name}</Link></h3>
				<div className="card-row"><strong>Defekt / Gesamt:</strong> <span>{item.defectiveQuantity} / {item.quantity}</span></div>
				<div className="card-row"><strong>Grund:</strong> <span>{item.defectReason || '-'}</span></div>
				<div className="card-actions">
					<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Status bearbeiten</button>
				</div>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-wrench"></i> Defekte Artikel verwalten</h1>
			<p>Hier sind alle Artikel gelistet, von denen mindestens ein Exemplar als defekt markiert wurde.</p>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Defekt / Gesamt</th>
							<th>Grund</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{renderMobileList()}
			</div>

			{modalState.isOpen && (
				<StorageItemModal
					isOpen={modalState.isOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					item={modalState.item}
					initialMode={modalState.mode}
				/>
			)}
		</div>
	);
};

export default AdminDefectivePage;
========================================================================
FILE: frontend\src\pages\admin\AdminEventDebriefingPage.jsx
========================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useAuthStore } from '../../store/authStore';
import { useToast } from '../../context/ToastContext';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const AdminEventDebriefingPage = () => {
	const { eventId } = useParams();
	const { user } = useAuthStore();
	const { addToast } = useToast();

	// Fetch event details to get name and assigned crew
	const eventApiCall = useCallback(() => apiClient.get(`/public/events/${eventId}`), [eventId]);
	const { data: event, loading: eventLoading, error: eventError } = useApi(eventApiCall);

	// Fetch existing debriefing data
	const debriefingApiCall = useCallback(() => apiClient.get(`/admin/events/${eventId}/debriefing`), [eventId]);
	const { data: debriefing, loading: debriefingLoading, error: debriefingError, reload: reloadDebriefing } = useApi(debriefingApiCall);

	const [formData, setFormData] = useState({
		whatWentWell: '',
		whatToImprove: '',
		equipmentNotes: '',
		standoutCrewMemberIds: [],
	});
	const [isEditing, setIsEditing] = useState(false);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	useEffect(() => {
		if (debriefing) {
			setFormData({
				whatWentWell: debriefing.whatWentWell || '',
				whatToImprove: debriefing.whatToImprove || '',
				equipmentNotes: debriefing.equipmentNotes || '',
				standoutCrewMemberIds: debriefing.standoutCrewDetails?.map(u => u.id) || [],
			});
			setIsEditing(false); // Default to view mode if data exists
		} else {
			setIsEditing(true); // Default to edit mode if no data exists
		}
	}, [debriefing]);

	const handleChange = (e) => {
		const { name, value } = e.target;
		setFormData(prev => ({ ...prev, [name]: value }));
	};

	const handleMultiSelectChange = (e) => {
		const options = [...e.target.selectedOptions];
		const values = options.map(option => parseInt(option.value, 10));
		setFormData(prev => ({ ...prev, standoutCrewMemberIds: values }));
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		try {
			const result = await apiClient.post(`/admin/events/${eventId}/debriefing`, formData);
			if (result.success) {
				addToast('Debriefing erfolgreich gespeichert!', 'success');
				reloadDebriefing();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	if (eventLoading || debriefingLoading) return <div>Lade Daten...</div>;
	if (eventError) return <div className="error-message">{eventError}</div>;
	if (debriefingError) return <div className="error-message">{debriefingError}</div>;
	if (!event) return <div className="error-message">Event nicht gefunden.</div>;

	const canManage = user.isAdmin || user.id === event.leaderUserId;

	if (!isEditing && debriefing) {
		return (
			<div>
				<h1><i className="fas fa-clipboard-check"></i> Debriefing für: {event.name}</h1>
				<p className="details-subtitle">Eingereicht von {debriefing.authorUsername} am {new Date(debriefing.submittedAt).toLocaleString('de-DE')}</p>
				{canManage && <button className="btn" onClick={() => setIsEditing(true)}>Bearbeiten</button>}
				<div className="card" style={{ marginTop: '1.5rem' }}>
					<h3 className="card-title">Was lief gut?</h3>
					<div className="markdown-content"><ReactMarkdown rehypePlugins={[rehypeSanitize]}>{debriefing.whatWentWell}</ReactMarkdown></div>
				</div>
				<div className="card">
					<h3 className="card-title">Was kann verbessert werden?</h3>
					<div className="markdown-content"><ReactMarkdown rehypePlugins={[rehypeSanitize]}>{debriefing.whatToImprove}</ReactMarkdown></div>
				</div>
				<div className="card">
					<h3 className="card-title">Anmerkungen zum Material</h3>
					<div className="markdown-content"><ReactMarkdown rehypePlugins={[rehypeSanitize]}>{debriefing.equipmentNotes || 'Keine Anmerkungen.'}</ReactMarkdown></div>
				</div>
				<div className="card">
					<h3 className="card-title">Besonders hervorgehobene Mitglieder</h3>
					{debriefing.standoutCrewDetails?.length > 0 ? (
						<p>{debriefing.standoutCrewDetails.map(u => u.username).join(', ')}</p>
					) : <p>Niemand wurde besonders hervorgehoben.</p>}
				</div>
				<Link to="/admin/veranstaltungen" className="btn btn-secondary" style={{ marginTop: '1rem' }}>Zurück zur Event-Übersicht</Link>
			</div>
		);
	}


	if (!canManage) {
		return <div className="error-message">Sie haben keine Berechtigung, dieses Debriefing zu bearbeiten.</div>
	}

	return (
		<div>
			<h1><i className="fas fa-clipboard-check"></i> Debriefing für: {event.name}</h1>
			<p className="details-subtitle">Fassen Sie die wichtigsten Punkte der Veranstaltung zusammen.</p>
			{error && <p className="error-message">{error}</p>}
			<div className="card">
				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="whatWentWell">Was lief gut?</label>
						<textarea id="whatWentWell" name="whatWentWell" value={formData.whatWentWell} onChange={handleChange} rows="6" required></textarea>
					</div>
					<div className="form-group">
						<label htmlFor="whatToImprove">Was kann verbessert werden?</label>
						<textarea id="whatToImprove" name="whatToImprove" value={formData.whatToImprove} onChange={handleChange} rows="6" required></textarea>
					</div>
					<div className="form-group">
						<label htmlFor="equipmentNotes">Anmerkungen zum Material</label>
						<textarea id="equipmentNotes" name="equipmentNotes" value={formData.equipmentNotes} onChange={handleChange} rows="4"></textarea>
					</div>
					<div className="form-group">
						<label htmlFor="standoutCrewMemberIds">Besonders hervorgehobene Mitglieder (optional)</label>
						<select id="standoutCrewMemberIds" name="standoutCrewMemberIds" value={formData.standoutCrewMemberIds} onChange={handleMultiSelectChange} multiple style={{ height: '150px' }}>
							{event.assignedAttendees?.map(member => (
								<option key={member.id} value={member.id}>{member.username}</option>
							))}
						</select>
						<small>Halten Sie Strg (oder Cmd auf Mac) gedrückt, um mehrere Mitglieder auszuwählen.</small>
					</div>
					<div style={{ display: 'flex', gap: '1rem' }}>
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>
							{isSubmitting ? 'Speichern...' : 'Debriefing speichern'}
						</button>
						{debriefing && <button type="button" className="btn btn-secondary" onClick={() => setIsEditing(false)} disabled={isSubmitting}>Abbrechen</button>}
					</div>
				</form>
			</div>
		</div>
	);
};

export default AdminEventDebriefingPage;
========================================================================
FILE: frontend\src\pages\admin\AdminEventRolesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminEventRolesPage = () => {
    const apiCall = useCallback(() => apiClient.get('/admin/event-roles'), []);
    const { data: roles, loading, error, reload } = useApi(apiCall);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [editingRole, setEditingRole] = useState(null);
    const { addToast } = useToast();

    const openModal = (role = null) => {
        setEditingRole(role);
        setIsModalOpen(true);
    };

    const closeModal = () => {
        setEditingRole(null);
        setIsModalOpen(false);
    };

    const handleSuccess = () => {
        closeModal();
        reload();
    };

    const handleDelete = async (role) => {
        if (window.confirm(`Rolle "${role.name}" wirklich löschen? Sie wird von allen aktuellen Zuweisungen entfernt.`)) {
            try {
                const result = await apiClient.delete(`/admin/event-roles/${role.id}`);
                if (result.success) {
                    addToast('Rolle erfolgreich gelöscht', 'success');
                    reload();
                } else {
                    throw new Error(result.message);
                }
            } catch (err) {
                addToast(`Fehler: ${err.message}`, 'error');
            }
        }
    };

    return (
        <div>
            <h1><i className="fas fa-user-tag"></i> Event-Rollen verwalten</h1>
            <p>Definieren Sie hier wiederverwendbare Rollen, die Benutzern bei Events zugewiesen werden können.</p>
            <div className="table-controls">
                <button onClick={() => openModal()} className="btn btn-success">
                    <i className="fas fa-plus"></i> Neue Rolle
                </button>
            </div>
            <div className="desktop-table-wrapper">
                <table className="data-table">
                    <thead>
                        <tr>
                            <th>Icon</th>
                            <th>Name</th>
                            <th>Beschreibung</th>
                            <th>Aktionen</th>
                        </tr>
                    </thead>
                    <tbody>
                        {loading && <tr><td colSpan="4">Lade Rollen...</td></tr>}
                        {error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
                        {roles?.map(role => (
                            <tr key={role.id}>
                                <td><i className={`fas ${role.iconClass}`} style={{ fontSize: '1.5rem' }}></i></td>
                                <td>{role.name}</td>
                                <td>{role.description}</td>
                                <td>
                                    <button onClick={() => openModal(role)} className="btn btn-small">Bearbeiten</button>
                                    <button onClick={() => handleDelete(role)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
            </div>
            {isModalOpen && (
                <RoleModal
                    isOpen={isModalOpen}
                    onClose={closeModal}
                    onSuccess={handleSuccess}
                    role={editingRole}
                />
            )}
        </div>
    );
};

const RoleModal = ({ isOpen, onClose, onSuccess, role }) => {
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [error, setError] = useState('');
    const { addToast } = useToast();

    const handleSubmit = async (e) => {
        e.preventDefault();
        setIsSubmitting(true);
        setError('');
        const formData = new FormData(e.target);
        const data = Object.fromEntries(formData.entries());

        try {
            const result = role
                ? await apiClient.put(`/admin/event-roles/${role.id}`, data)
                : await apiClient.post('/admin/event-roles', data);
            if (result.success) {
                addToast(`Rolle erfolgreich ${role ? 'aktualisiert' : 'erstellt'}.`, 'success');
                onSuccess();
            }
            else throw new Error(result.message);
        } catch (err) {
            setError(err.message || 'Fehler beim Speichern');
        } finally {
            setIsSubmitting(false);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} title={role ? 'Rolle bearbeiten' : 'Neue Rolle erstellen'}>
            <form onSubmit={handleSubmit}>
                {error && <p className="error-message">{error}</p>}
                <div className="form-group">
                    <label htmlFor="modal-name">Name der Rolle</label>
                    <input id="modal-name" name="name" defaultValue={role?.name} required />
                </div>
                <div className="form-group">
                    <label htmlFor="modal-desc">Beschreibung</label>
                    <textarea id="modal-desc" name="description" defaultValue={role?.description} rows="3"></textarea>
                </div>
                <div className="form-group">
                    <label htmlFor="modal-icon">Font Awesome Icon-Klasse</label>
                    <input id="modal-icon" name="iconClass" defaultValue={role?.iconClass || 'fa-user-tag'} placeholder="z.B. fa-user-tie" required />
                </div>
                <button type="submit" className="btn" disabled={isSubmitting}>
                    {isSubmitting ? 'Speichern...' : 'Speichern'}
                </button>
            </form>
        </Modal>
    );
};

export default AdminEventRolesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminEventsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import useAdminData from '../../hooks/useAdminData';
import Modal from '../../components/ui/Modal';
import StatusBadge from '../../components/ui/StatusBadge';
import EventModal from '../../components/admin/events/EventModal';
import { useToast } from '../../context/ToastContext';

const AdminEventsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/events'), []);
	const { data: events, loading, error, reload } = useApi(apiCall);
	const adminFormData = useAdminData();
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingEvent, setEditingEvent] = useState(null);
	const { addToast } = useToast();
	const navigate = useNavigate();

	const openModal = (event = null) => {
		setEditingEvent(event);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingEvent(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (event) => {
		if (window.confirm(`Event '${event.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/events/${event.id}`);
				if (result.success) {
					addToast('Event erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	const handleClone = async (event) => {
		if (window.confirm(`Event '${event.name}' klonen? Ein neues Event wird erstellt und Sie werden zur Bearbeitungsseite weitergeleitet.`)) {
			try {
				const result = await apiClient.post(`/events/${event.id}/clone`);
				if (result.success) {
					addToast('Event erfolgreich geklont.', 'success');
					// Redirect to the edit page of the new event
					// This requires the backend to return the new event object
					// For now, just reload the list. A redirect would be better.
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Klonen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-calendar-plus"></i> Event-Verwaltung</h1>
			<p>Hier können alle Veranstaltungen geplant, bearbeitet und verwaltet werden.</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Event erstellen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Event-Name</th>
							<th>Datum & Uhrzeit</th>
							<th>Status</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Events...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{events?.map(event => (
							<tr key={event.id}>
								<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
								<td>{new Date(event.eventDateTime).toLocaleString('de-DE')}</td>
								<td><StatusBadge status={event.status} /></td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<button onClick={() => openModal(event)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleClone(event)} className="btn btn-small btn-secondary">Klonen</button>
									{event.status === 'ABGESCHLOSSEN' && (
										<Link to={`/admin/veranstaltungen/${event.id}/debriefing`} className="btn btn-small btn-info">
											Debriefing
										</Link>
									)}
									<button onClick={() => handleDelete(event)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Events...</p>}
				{error && <p className="error-message">{error}</p>}
				{events?.map(event => (
					<div className="list-item-card" key={event.id}>
						<h3 className="card-title"><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></h3>
						<div className="card-row"><strong>Datum:</strong> <span>{new Date(event.eventDateTime).toLocaleString('de-DE')}</span></div>
						<div className="card-row"><strong>Status:</strong> <StatusBadge status={event.status} /></div>
						<div className="card-actions">
							<button onClick={() => openModal(event)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => handleClone(event)} className="btn btn-small btn-secondary">Klonen</button>
							{event.status === 'ABGESCHLOSSEN' && (
								<Link to={`/admin/veranstaltungen/${event.id}/debriefing`} className="btn btn-small btn-info">
									Debriefing
								</Link>
							)}
							<button onClick={() => handleDelete(event)} className="btn btn-small btn-danger">Löschen</button>
						</div>
					</div>
				))}
			</div>

			{/* Prevent modal from rendering before its required data is available */}
			{isModalOpen && !adminFormData.loading && (
				<EventModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					event={editingEvent}
					adminFormData={adminFormData}
				/>
			)}
		</div>
	);
};

export default AdminEventsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminFeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StatusBadge from '../../components/ui/StatusBadge';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const FeedbackColumn = ({ title, submissions, onCardClick }) => (
	<div className="feedback-column">
		<h2>{title}</h2>
		<div className="feedback-list">
			{submissions.map(sub => (
				<div key={sub.id} className="feedback-card-item" onClick={() => onCardClick(sub)}>
					<strong className="subject">{sub.subject}</strong>
					<p className="content-preview">{sub.content}</p>
					<div className="meta">
						<span>Von: {sub.username}</span>
					</div>
				</div>
			))}
		</div>
	</div>
);

const AdminFeedbackPage = () => {
	const apiCall = useCallback(() => apiClient.get('/feedback'), []);
	const { data: submissions, loading, error, reload } = useApi(apiCall);
	const [selectedFeedback, setSelectedFeedback] = useState(null);
	const { addToast } = useToast();

	const groupedSubmissions = submissions?.reduce((acc, sub) => {
		(acc[sub.status] = acc[sub.status] || []).push(sub);
		return acc;
	}, {}) || {};

	const handleStatusChange = async (newStatus) => {
		if (!selectedFeedback) return;
		try {
			const result = await apiClient.put(`/feedback/${selectedFeedback.id}/status`, { status: newStatus });
			if (result.success) {
				addToast('Status erfolgreich aktualisiert', 'success');
				setSelectedFeedback(null);
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Ändern des Status: ${err.message}`, 'error');
		}
	};

	if (loading) return <div>Lade Feedback...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-inbox"></i> Feedback-Verwaltung</h1>
			<p>Verwalten Sie hier alle Benutzereinreichungen. Klicken Sie auf eine Karte, um den Status zu ändern.</p>
			<div className="feedback-board">
				<FeedbackColumn title="Neu" submissions={groupedSubmissions['NEW'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Gesehen" submissions={groupedSubmissions['VIEWED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Geplant" submissions={groupedSubmissions['PLANNED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Erledigt" submissions={groupedSubmissions['COMPLETED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Abgelehnt" submissions={groupedSubmissions['REJECTED'] || []} onCardClick={setSelectedFeedback} />
			</div>

			{selectedFeedback && (
				<Modal isOpen={!!selectedFeedback} onClose={() => setSelectedFeedback(null)} title={selectedFeedback.subject}>
					<p><strong>Von:</strong> {selectedFeedback.username}</p>
					<p><strong>Eingereicht am:</strong> {new Date(selectedFeedback.submittedAt).toLocaleString('de-DE')}</p>
					<div className="card" style={{ backgroundColor: 'var(--bg-color)', whiteSpace: 'pre-wrap' }}>{selectedFeedback.content}</div>
					<div style={{ marginTop: '1.5rem' }}>
						<h4>Status ändern:</h4>
						<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
							{['NEW', 'VIEWED', 'PLANNED', 'COMPLETED', 'REJECTED'].map(status => (
								<button key={status} onClick={() => handleStatusChange(status)} className="btn btn-small">
									{status}
								</button>
							))}
						</div>
					</div>
				</Modal>
			)}
		</div>
	);
};

export default AdminFeedbackPage;
========================================================================
FILE: frontend\src\pages\admin\AdminFilesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';

const FileUploadModal = ({ isOpen, onClose, onSuccess, categories }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const file = formData.get('file');

		if (file.size > 10 * 1024 * 1024) { // 10MB limit
			setError('Datei ist zu groß. Maximal 10MB erlaubt.');
			setIsSubmitting(false);
			return;
		}

		try {
			const result = await apiClient.post('/admin/files', formData);
			if (result.success) {
				addToast('Datei erfolgreich hochgeladen', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Upload fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Datei hochladen">
			<form onSubmit={handleSubmit} encType="multipart/form-data">
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="file-upload">Datei auswählen</label>
					<input type="file" id="file-upload" name="file" required />
				</div>
				<div className="form-group">
					<label htmlFor="categoryId-upload">Kategorie</label>
					<select name="categoryId" id="categoryId-upload">
						<option value="">(Ohne Kategorie)</option>
						{categories.map(cat => <option key={cat.id} value={cat.id}>{cat.name}</option>)}
					</select>
				</div>
				<div className="form-group">
					<label htmlFor="requiredRole-upload">Sichtbarkeit</label>
					<select name="requiredRole" id="requiredRole-upload" defaultValue="NUTZER">
						<option value="NUTZER">Alle Benutzer</option>
						<option value="ADMIN">Nur Admins</option>
					</select>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird hochgeladen...' : 'Hochladen'}
				</button>
			</form>
		</Modal>
	);
};


const AdminFilesPage = () => {
	const filesApiCall = useCallback(() => apiClient.get('/admin/files'), []);
	const categoriesApiCall = useCallback(() => apiClient.get('/admin/files/categories'), []);

	const { data: filesGrouped, loading: filesLoading, error: filesError, reload: reloadFiles } = useApi(filesApiCall);
	const { data: categories, loading: catsLoading, error: catsError, reload: reloadCats } = useApi(categoriesApiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const { addToast } = useToast();

	const handleSuccess = () => {
		setIsModalOpen(false);
		reloadFiles();
		reloadCats();
	};

	const handleDeleteFile = async (file) => {
		if (window.confirm(`Datei "${file.filename}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/files/${file.id}`);
				if (result.success) {
					addToast('Datei gelöscht', 'success');
					reloadFiles();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(err.message, 'error');
			}
		}
	};

	const handleCreateCategory = async () => {
		const name = prompt('Name für die neue Kategorie:');
		if (name) {
			try {
				await apiClient.post('/admin/files/categories', { name });
				addToast('Kategorie erstellt', 'success');
				reloadCats();
				reloadFiles();
			} catch (err) {
				addToast(err.message, 'error');
			}
		}
	};

	const renderContent = () => {
		if (filesLoading) return <div className="card"><p>Lade Dateien...</p></div>;
		if (filesError) return <div className="error-message">{filesError}</div>;

		if (!filesGrouped || Object.keys(filesGrouped).length === 0) {
			return <div className="card"><p>Es sind keine Dateien oder Dokumente verfügbar.</p></div>;
		}

		return Object.entries(filesGrouped).map(([categoryName, files]) => (
			<div className="card" key={categoryName}>
				<h2><i className="fas fa-folder"></i> {categoryName}</h2>
				<ul className="details-list">
					{files.map(file => (
						<li key={file.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
							<div>
								<a href={`/api/v1/public/files/download/${file.id}`} target="_blank" rel="noopener noreferrer">
									<i className="fas fa-download"></i> {file.filename}
								</a>
								<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>
									Sichtbarkeit: {file.requiredRole}
								</small>
							</div>
							<div>
								<button onClick={() => handleDeleteFile(file)} className="btn btn-small btn-danger">Löschen</button>
							</div>
						</li>
					))}
				</ul>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-file-upload"></i> Datei-Verwaltung</h1>
			<p>Hier können Sie alle zentralen Dokumente und Vorlagen verwalten.</p>
			<div className="table-controls">
				<button onClick={() => setIsModalOpen(true)} className="btn btn-success">
					<i className="fas fa-upload"></i> Neue Datei hochladen
				</button>
				<button onClick={handleCreateCategory} className="btn btn-secondary">
					<i className="fas fa-folder-plus"></i> Neue Kategorie
				</button>
			</div>
			{catsError && <p className="error-message">{catsError}</p>}
			{renderContent()}

			{isModalOpen && (
				<FileUploadModal
					isOpen={isModalOpen}
					onClose={() => setIsModalOpen(false)}
					onSuccess={handleSuccess}
					categories={categories || []}
				/>
			)}
		</div>
	);
};

export default AdminFilesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminKitsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import useAdminData from '../../hooks/useAdminData';
import apiClient from '../../services/apiClient';
import KitModal from '../../components/admin/kits/KitModal';
import KitItemsForm from '../../components/admin/kits/KitItemsForm';
import Modal from '../../components/ui/Modal';
import QRCode from 'qrcode.react';
import { useToast } from '../../context/ToastContext';

const KitAccordion = ({ kit, onEdit, onDelete, onItemsUpdate, allStorageItems }) => {
	const [isOpen, setIsOpen] = useState(false);
	const [isQrModalOpen, setIsQrModalOpen] = useState(false);
	const packKitUrl = `${window.location.origin}/pack-kit/${kit.id}`;

	return (
		<div className="kit-container" style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '1.5rem', marginBottom: '1.5rem' }}>
			<div className="kit-header" onClick={() => setIsOpen(!isOpen)} style={{ cursor: 'pointer', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
				<div>
					<h3>
						<i className={`fas ${isOpen ? 'fa-chevron-down' : 'fa-chevron-right'}`} style={{ marginRight: '0.75rem', transition: 'transform 0.2s' }}></i>
						{kit.name}
					</h3>
					<p style={{ margin: '-0.5rem 0 0 1.75rem', color: 'var(--text-muted-color)' }}>{kit.description}</p>
				</div>
				<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }} onClick={e => e.stopPropagation()}>
					<button onClick={() => setIsQrModalOpen(true)} className="btn btn-small">QR-Code</button>
					<button onClick={() => onEdit(kit)} className="btn btn-small btn-secondary">Bearbeiten</button>
					<button onClick={() => onDelete(kit)} className="btn btn-small btn-danger">Löschen</button>
				</div>
			</div>
			{isOpen && (
				<div className="kit-content" style={{ paddingLeft: '2rem', marginTop: '1rem' }}>
					<KitItemsForm kit={kit} allStorageItems={allStorageItems} onUpdateSuccess={onItemsUpdate} />
				</div>
			)}
			<Modal isOpen={isQrModalOpen} onClose={() => setIsQrModalOpen(false)} title={`QR-Code für: ${kit.name}`}>
				<div style={{ textAlign: 'center', padding: '1rem' }}>
					<QRCode value={packKitUrl} size={256} />
					<p style={{ marginTop: '1rem' }}>Scannen, um die Packliste zu öffnen.</p>
					<a href={packKitUrl} target="_blank" rel="noopener noreferrer">{packKitUrl}</a>
				</div>
			</Modal>
		</div>
	);
};

const AdminKitsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/kits'), []);
	const { data: kits, loading, error, reload } = useApi(apiCall);
	const { storageItems } = useAdminData();
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingKit, setEditingKit] = useState(null);
	const { addToast } = useToast();

	const openModal = (kit = null) => {
		setEditingKit(kit);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingKit(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (kit) => {
		if (window.confirm(`Kit '${kit.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/kits/${kit.id}`);
				if (result.success) {
					addToast('Kit erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-box-open"></i> Kit-Verwaltung</h1>
			<p>Verwalten Sie hier wiederverwendbare Material-Zusammenstellungen (Kits oder Koffer).</p>

			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Kit anlegen
				</button>
			</div>

			<div className="card">
				{loading && <p>Lade Kits...</p>}
				{error && <p className="error-message">{error}</p>}
				{kits?.map(kit => (
					<KitAccordion
						key={kit.id}
						kit={kit}
						onEdit={openModal}
						onDelete={handleDelete}
						onItemsUpdate={reload}
						allStorageItems={storageItems}
					/>
				))}
			</div>

			{isModalOpen && (
				<KitModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					kit={editingKit}
				/>
			)}
		</div>
	);
};

export default AdminKitsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminLogPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';

const AdminLogPage = () => {
	const apiCall = useCallback(() => apiClient.get('/logs'), []);
	const { data: logs, loading, error } = useApi(apiCall);

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade Logs...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!logs || logs.length === 0) return <tr><td colSpan="4" style={{ textAlign: 'center' }}>Keine Log-Einträge gefunden.</td></tr>;

		return logs.map(log => (
			<tr key={log.id}>
				<td>{new Date(log.actionTimestamp).toLocaleString('de-DE')} Uhr</td>
				<td>{log.adminUsername}</td>
				<td>{log.actionType}</td>
				<td style={{ whiteSpace: 'normal' }}>{log.details}</td>
			</tr>
		));
	};

	const renderMobileList = () => {
		if (loading) return <p>Lade Logs...</p>;
		if (error) return <p className="error-message">{error}</p>;
		if (!logs || logs.length === 0) return <div className="card"><p>Keine Log-Einträge gefunden.</p></div>;

		return logs.map(log => (
			<div className="list-item-card" key={log.id}>
				<h3 className="card-title">{log.actionType}</h3>
				<div className="card-row"><strong>Wer:</strong> <span>{log.adminUsername}</span></div>
				<div className="card-row"><strong>Wann:</strong> <span>{new Date(log.actionTimestamp).toLocaleString('de-DE')}</span></div>
				<p style={{ marginTop: '0.5rem', paddingTop: '0.5rem', borderTop: '1px solid var(--border-color)', whiteSpace: 'normal' }}>{log.details}</p>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-clipboard-list"></i> Admin Aktions-Protokoll</h1>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Wann</th>
							<th>Wer</th>
							<th>Aktionstyp</th>
							<th>Details</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>
			<div className="mobile-card-list">
				{renderMobileList()}
			</div>
		</div>
	);
};

export default AdminLogPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMatrixPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import AttendanceModal from '../../components/admin/matrix/AttendanceModal';

const AdminMatrixPage = () => {
	const apiCall = useCallback(() => apiClient.get('/matrix'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const [modalData, setModalData] = useState(null);

	const openModal = (cellData) => {
		setModalData(cellData);
	};

	const closeModal = () => {
		setModalData(null);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	if (loading) return <div>Lade Matrix-Daten...</div>;
	if (error) return <div className="error-message">{error}</div>;

	const { users, courses, meetingsByCourse, attendanceMap } = data;

	return (
		<div>
			<h1><i className="fas fa-th-list"></i> Qualifikations-Matrix</h1>
			<p>Klicken Sie auf eine Zelle, um die Teilnahme an einem Meeting zu bearbeiten. Die Kopfzeile und die Benutzerleiste bleiben beim Scrollen fixiert.</p>

			<div className="table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th rowSpan="2" className="sticky-header sticky-col" style={{ verticalAlign: 'middle', left: 0, zIndex: 15 }}>Nutzer / Lehrgang ↓</th>
							{courses.map(course => (
								<th key={course.id} colSpan={meetingsByCourse[course.id]?.length || 1} className="sticky-header" style={{ textAlign: 'center' }}>
									<Link to={`/admin/lehrgaenge/${course.id}/meetings`} title={`Meetings für '${course.name}' verwalten`}>
										{course.abbreviation}
									</Link>
								</th>
							))}
						</tr>
						<tr>
							{courses.map(course => (
								(meetingsByCourse[course.id] || []).map(meeting => (
									<th key={meeting.id} className="sticky-header" style={{ textAlign: 'center', minWidth: '120px' }}>
										{meeting.name}
									</th>
								))
							))}
						</tr>
					</thead>
					<tbody>
						{users.map(user => (
							<tr key={user.id}>
								<td className="sticky-col" style={{ fontWeight: '500', left: 0 }}>{user.username}</td>
								{courses.map(course => (
									(meetingsByCourse[course.id] || []).map(meeting => {
										const attendance = attendanceMap[`${user.id}-${meeting.id}`];
										const attended = attendance ? attendance.attended : false;

										const cellData = {
											userId: user.id,
											userName: user.username,
											meetingId: meeting.id,
											meetingName: `${course.name} - ${meeting.name}`,
											attended: attended,
											remarks: attendance?.remarks || ''
										};

										return (
											<td
												key={meeting.id}
												className="qual-cell"
												onClick={() => openModal(cellData)}
												style={{ textAlign: 'center', fontWeight: 'bold', cursor: 'pointer' }}
												title="Klicken zum Bearbeiten"
											>
												{attended ?
													<span style={{ fontSize: '1.2rem', color: 'var(--success-color)' }}>✔</span> :
													<span className="text-muted">-</span>
												}
											</td>
										);
									})
								))}
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{modalData && (
				<AttendanceModal
					isOpen={!!modalData}
					onClose={closeModal}
					onSuccess={handleSuccess}
					cellData={modalData}
				/>
			)}
		</div>
	);
};

export default AdminMatrixPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMeetingsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminMeetingsPage = () => {
	const { courseId } = useParams();
	const meetingsApiCall = useCallback(() => apiClient.get(`/meetings?courseId=${courseId}`), [courseId]);
	const usersApiCall = useCallback(() => apiClient.get('/users'), []);

	const { data: meetingsData, loading, error, reload } = useApi(meetingsApiCall);
	const { data: allUsers } = useApi(usersApiCall);
	const { addToast } = useToast();

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingMeeting, setEditingMeeting] = useState(null);
	const [formError, setFormError] = useState('');

	const courseName = meetingsData?.[0]?.parentCourseName || 'Lehrgang';

	const handleOpenNewModal = () => {
		setEditingMeeting(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (meeting) => {
		setEditingMeeting(meeting);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingMeeting(null);
		setFormError('');
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		const payload = {
			...data,
			courseId: parseInt(courseId),
			leaderUserId: data.leaderUserId ? parseInt(data.leaderUserId) : null
		};

		try {
			const result = editingMeeting
				? await apiClient.put(`/meetings/${editingMeeting.id}`, payload)
				: await apiClient.post('/meetings', payload);

			if (result.success) {
				addToast(`Meeting erfolgreich ${editingMeeting ? 'aktualisiert' : 'geplant'}.`, 'success');
				handleCloseModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Ein Fehler ist aufgetreten.');
		}
	};

	const handleDelete = async (meeting) => {
		if (window.confirm(`Meeting '${meeting.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/meetings/${meeting.id}`);
				if (result.success) {
					addToast('Meeting gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	const handleClone = async (meeting) => {
		if (window.confirm(`Meeting '${meeting.name}' klonen?`)) {
			try {
				const result = await apiClient.post(`/meetings/${meeting.id}/clone`);
				if (result.success) {
					addToast('Meeting erfolgreich geklont.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Klonen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1>Meetings für "{courseName}"</h1>
			<Link to="/admin/lehrgaenge" style={{ marginBottom: '1rem', display: 'inline-block' }}>
				<i className="fas fa-arrow-left"></i> Zurück zu allen Vorlagen
			</Link>

			<div className="table-controls">
				<button onClick={handleOpenNewModal} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Meeting planen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Meeting-Name</th>
							<th>Datum & Uhrzeit</th>
							<th>Leitung</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Meetings...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{meetingsData?.map(meeting => (
							<tr key={meeting.id}>
								<td>{meeting.name}</td>
								<td>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</td>
								<td>{meeting.leaderUsername || 'N/A'}</td>
								<td style={{ display: 'flex', gap: '0.5rem' }}>
									<button onClick={() => handleOpenEditModal(meeting)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleClone(meeting)} className="btn btn-small btn-secondary">Klonen</button>
									<button onClick={() => handleDelete(meeting)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Meetings...</p>}
				{error && <p className="error-message">{error}</p>}
				{meetingsData?.map(meeting => (
					<div className="list-item-card" key={meeting.id}>
						<h3 className="card-title">{meeting.name}</h3>
						<div className="card-row"><strong>Datum:</strong> <span>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</span></div>
						<div className="card-row"><strong>Leitung:</strong> <span>{meeting.leaderUsername || 'N/A'}</span></div>
						<div className="card-actions">
							<button onClick={() => handleOpenEditModal(meeting)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => handleClone(meeting)} className="btn btn-small btn-secondary">Klonen</button>
							<button onClick={() => handleDelete(meeting)} className="btn btn-small btn-danger">Löschen</button>
						</div>
					</div>
				))}
			</div>

			{isModalOpen && (
				<Modal isOpen={isModalOpen} onClose={handleCloseModal} title={editingMeeting ? "Meeting bearbeiten" : "Neues Meeting planen"}>
					<form onSubmit={handleSubmit}>
						{formError && <p className="error-message">{formError}</p>}
						<div className="form-group">
							<label htmlFor="name-modal">Name des Meetings</label>
							<input type="text" id="name-modal" name="name" defaultValue={editingMeeting?.name} required />
						</div>
						<div className="responsive-dashboard-grid">
							<div className="form-group">
								<label htmlFor="meetingDateTime-modal">Beginn</label>
								<input type="datetime-local" id="meetingDateTime-modal" name="meetingDateTime" defaultValue={editingMeeting?.meetingDateTime ? editingMeeting.meetingDateTime.substring(0, 16) : ''} required />
							</div>
							<div className="form-group">
								<label htmlFor="endDateTime-modal">Ende (optional)</label>
								<input type="datetime-local" id="endDateTime-modal" name="endDateTime" defaultValue={editingMeeting?.endDateTime ? editingMeeting.endDateTime.substring(0, 16) : ''} />
							</div>
						</div>
						<div className="form-group">
							<label htmlFor="location-modal">Ort</label>
							<input type="text" id="location-modal" name="location" defaultValue={editingMeeting?.location} />
						</div>
						<div className="form-group">
							<label htmlFor="leader-modal">Leitende Person</label>
							<select name="leaderUserId" id="leader-modal" defaultValue={editingMeeting?.leaderUserId}>
								<option value="">(Keine)</option>
								{allUsers?.map(user => <option key={user.id} value={user.id}>{user.username}</option>)}
							</select>
						</div>
						<div className="form-group">
							<label htmlFor="description-modal">Beschreibung</label>
							<textarea id="description-modal" name="description" defaultValue={editingMeeting?.description} rows="3"></textarea>
						</div>
						<button type="submit" className="btn"><i className="fas fa-save"></i> Speichern</button>
					</form>
				</Modal>
			)}
		</div>
	);
};

export default AdminMeetingsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminNotificationsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminNotificationsPage = () => {
	const { addToast } = useToast();
	const [formData, setFormData] = useState({
		title: '',
		description: '',
		level: 'Informational',
		targetType: 'ALL',
		targetId: ''
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const [isConfirmModalOpen, setIsConfirmModalOpen] = useState(false);
	const [isWarningConfirmModalOpen, setIsWarningConfirmModalOpen] = useState(false);

	const fetchEvents = useCallback(() => apiClient.get('/events'), []);
	const fetchMeetings = useCallback(() => apiClient.get('/meetings?courseId=0'), []); // Placeholder to fetch all

	const { data: events, loading: eventsLoading } = useApi(fetchEvents);
	const { data: meetings, loading: meetingsLoading } = useApi(fetchMeetings);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleSubmit = (e) => {
		e.preventDefault();
		setError('');
		if (!formData.title || !formData.description) {
			setError('Titel und Beschreibung sind erforderlich.');
			return;
		}
		setIsConfirmModalOpen(true);
	};

	const handleConfirmSend = () => {
		setIsConfirmModalOpen(false);
		if (formData.level === 'Warning') {
			setIsWarningConfirmModalOpen(true);
		} else {
			sendNotification();
		}
	};

	const handleWarningConfirmSend = () => {
		setIsWarningConfirmModalOpen(false);
		sendNotification();
	};

	const sendNotification = async () => {
		setIsSubmitting(true);
		setError('');
		try {
			const payload = { ...formData, targetId: formData.targetId ? parseInt(formData.targetId, 10) : null };
			const result = await apiClient.post('/admin/notifications', payload);
			if (result.success) {
				addToast(result.message, 'success');
				setFormData({ title: '', description: '', level: 'Informational', targetType: 'ALL', targetId: '' });
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Senden fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const getTargetName = () => {
		switch (formData.targetType) {
			case 'ALL': return 'Alle Benutzer';
			case 'EVENT': {
				const event = events?.find(e => e.id.toString() === formData.targetId);
				return `Alle Teilnehmer von Event: ${event?.name || 'Unbekannt'}`;
			}
			case 'MEETING': {
				const meeting = meetings?.find(m => m.id.toString() === formData.targetId);
				return `Alle Teilnehmer von Meeting: ${meeting?.name || 'Unbekannt'}`;
			}
			default: return 'Unbekannt';
		}
	};

	return (
		<div>
			<h1><i className="fas fa-bullhorn"></i> Benachrichtigungen senden</h1>
			<p>Erstellen und versenden Sie hier systemweite Benachrichtigungen an Benutzergruppen.</p>

			<div className="card">
				<h2 className="card-title">Neue Benachrichtigung</h2>
				{error && <p className="error-message">{error}</p>}
				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="title">Titel</label>
						<input type="text" id="title" name="title" value={formData.title} onChange={handleChange} required maxLength="100" />
					</div>
					<div className="form-group">
						<label htmlFor="description">Beschreibung</label>
						<textarea id="description" name="description" value={formData.description} onChange={handleChange} required rows="4"></textarea>
					</div>
					<div className="responsive-dashboard-grid">
						<div className="form-group">
							<label htmlFor="level">Stufe</label>
							<select id="level" name="level" value={formData.level} onChange={handleChange}>
								<option value="Informational">Informational</option>
								<option value="Important">Important</option>
								<option value="Warning">Warning (Notfall)</option>
							</select>
						</div>
						<div className="form-group">
							<label htmlFor="targetType">Zielgruppe</label>
							<select id="targetType" name="targetType" value={formData.targetType} onChange={handleChange}>
								<option value="ALL">Alle Benutzer</option>
								<option value="EVENT">Event-Teilnehmer</option>
								<option value="MEETING">Meeting-Teilnehmer</option>
							</select>
						</div>
					</div>

					{(formData.targetType === 'EVENT' || formData.targetType === 'MEETING') && (
						<div className="form-group">
							<label htmlFor="targetId">Spezifisches Ziel auswählen</label>
							<select id="targetId" name="targetId" value={formData.targetId} onChange={handleChange} required>
								<option value="">-- Bitte auswählen --</option>
								{formData.targetType === 'EVENT' && !eventsLoading && events?.map(e => <option key={e.id} value={e.id}>{e.name}</option>)}
								{formData.targetType === 'MEETING' && !meetingsLoading && meetings?.map(m => <option key={m.id} value={m.id}>{m.parentCourseName}: {m.name}</option>)}
							</select>
						</div>
					)}

					<button type="submit" className="btn btn-success" disabled={isSubmitting}>
						{isSubmitting ? 'Wird gesendet...' : 'Benachrichtigung prüfen & senden'}
					</button>
				</form>
			</div>

			<Modal isOpen={isConfirmModalOpen} onClose={() => setIsConfirmModalOpen(false)} title="Benachrichtigung bestätigen">
				<h4>Bitte bestätigen Sie die folgenden Details:</h4>
				<ul className="details-list">
					<li><strong>Titel:</strong> {formData.title}</li>
					<li><strong>Beschreibung:</strong> {formData.description}</li>
					<li><strong>Stufe:</strong> {formData.level}</li>
					<li><strong>Zielgruppe:</strong> {getTargetName()}</li>
				</ul>
				<div style={{ display: 'flex', justifyContent: 'flex-end', gap: '1rem', marginTop: '1.5rem' }}>
					<button onClick={() => setIsConfirmModalOpen(false)} className="btn btn-secondary">Abbrechen</button>
					<button onClick={handleConfirmSend} className="btn btn-success">Senden</button>
				</div>
			</Modal>

			<Modal isOpen={isWarningConfirmModalOpen} onClose={() => setIsWarningConfirmModalOpen(false)} title="WARNUNG: Notfall-Benachrichtigung">
				<div style={{ textAlign: 'center' }}>
					<i className="fas fa-exclamation-triangle" style={{ fontSize: '3rem', color: 'var(--danger-color)' }}></i>
					<p style={{ marginTop: '1rem' }}>Sie sind im Begriff, eine <strong>Warn-Benachrichtigung</strong> zu senden. Diese Stufe sollte nur für echte Notfälle oder äußerst wichtige, dringende Informationen verwendet werden.</p>
					<p><strong>Sind Sie sicher, dass Sie fortfahren möchten?</strong></p>
				</div>
				<div style={{ display: 'flex', justifyContent: 'center', gap: '1rem', marginTop: '1.5rem' }}>
					<button onClick={() => setIsWarningConfirmModalOpen(false)} className="btn btn-secondary">Abbrechen</button>
					<button onClick={handleWarningConfirmSend} className="btn btn-danger">Ja, Notfall-Benachrichtigung senden</button>
				</div>
			</Modal>
		</div>
	);
};

export default AdminNotificationsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminReportsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import EventTrendChart from '../../components/admin/dashboard/EventTrendChart';
import UserActivityChart from '../../components/admin/reports/UserActivityChart';

const AdminReportsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/reports/dashboard'), []);
	const { data: reportData, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Berichte...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!reportData) return <div className="card"><p>Keine Berichtsdaten verfügbar.</p></div>;

	const { eventTrend, userActivity, totalInventoryValue } = reportData;

	const getCsvLink = (reportType) => `/api/v1/reports/${reportType}?export=csv`;

	return (
		<div>
			<h1><i className="fas fa-chart-pie"></i> Berichte & Analysen</h1>
			<p>Hier finden Sie zusammengefasste Daten und Analysen über die Anwendungsnutzung.</p>

			<div className="dashboard-grid">
				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<h2 className="card-title">Event-Trend (Letzte 12 Monate)</h2>
					<EventTrendChart trendData={eventTrend} />
				</div>

				<div className="card">
					<h2 className="card-title">Top 10 Aktivste Benutzer</h2>
					<UserActivityChart activityData={userActivity} />
				</div>

				<div className="card">
					<h2 className="card-title">Sonstige Berichte & Exporte</h2>
					<ul className="details-list">
						<li>
							<span>Teilnahme-Zusammenfassung</span>
							<a href={getCsvLink('event-participation')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Nutzungsfrequenz (Material)</span>
							<a href={getCsvLink('inventory-usage')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Vollständige Benutzeraktivität</span>
							<a href={getCsvLink('user-activity')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Gesamtwert des Lagers</span>
							<span style={{ fontWeight: 'bold' }}>
								{new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalInventoryValue)}
							</span>
						</li>
					</ul>
				</div>
			</div>
		</div>
	);
};

export default AdminReportsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminRequestsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';

const AdminRequestsPage = () => {
	// Corrected API endpoint
	const apiCall = useCallback(() => apiClient.get('/requests/pending'), []);
	const { data: requests, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const handleAction = async (requestId, action) => {
		// Corrected API endpoint
		const endpoint = `/requests/${requestId}/${action}`;
		const confirmationText = action === 'approve'
			? 'Änderungen wirklich übernehmen?'
			: 'Antrag wirklich ablehnen?';

		if (window.confirm(confirmationText)) {
			try {
				const result = await apiClient.post(endpoint);
				if (result.success) {
					addToast(`Antrag erfolgreich ${action === 'approve' ? 'genehmigt' : 'abgelehnt'}.`, 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	const renderChanges = (changesJson) => {
		try {
			const changes = JSON.parse(changesJson);
			return (
				<ul style={{ paddingLeft: '1.5rem', margin: 0, listStyle: 'none' }}>
					{Object.entries(changes).map(([key, value]) => (
						<li key={key}><strong>{key}:</strong> {value}</li>
					))}
				</ul>
			);
		} catch (e) {
			return <span className="text-danger">Fehler beim Parsen der Änderungen.</span>;
		}
	};

	return (
		<div>
			<h1><i className="fas fa-inbox"></i> Offene Anträge</h1>
			<p>Hier sehen Sie alle von Benutzern beantragten Änderungen an Stammdaten. Genehmigte Änderungen werden sofort wirksam.</p>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Benutzer</th>
							<th>Beantragt am</th>
							<th>Gewünschte Änderungen</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Anträge...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{requests?.length === 0 && <tr><td colSpan="4" style={{ textAlign: 'center' }}>Keine offenen Anträge vorhanden.</td></tr>}
						{requests?.map(req => (
							<tr key={req.id}>
								<td>{req.username}</td>
								<td>{new Date(req.requestedAt).toLocaleString('de-DE')}</td>
								<td>{renderChanges(req.requestedChanges)}</td>
								<td style={{ display: 'flex', gap: '0.5rem' }}>
									<button onClick={() => handleAction(req.id, 'approve')} className="btn btn-small btn-success">Genehmigen</button>
									<button onClick={() => handleAction(req.id, 'deny')} className="btn btn-small btn-danger">Ablehnen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Anträge...</p>}
				{error && <p className="error-message">{error}</p>}
				{requests?.length === 0 && <div className="card"><p>Keine offenen Anträge vorhanden.</p></div>}
				{requests?.map(req => (
					<div className="list-item-card" key={req.id}>
						<h3 className="card-title">Antrag von {req.username}</h3>
						<div className="card-row"><strong>Beantragt am:</strong> <span>{new Date(req.requestedAt).toLocaleString('de-DE')}</span></div>
						<div style={{ marginTop: '0.5rem' }}>
							<strong>Änderungen:</strong>
							{renderChanges(req.requestedChanges)}
						</div>
						<div className="card-actions">
							<button onClick={() => handleAction(req.id, 'approve')} className="btn btn-small btn-success">Genehmigen</button>
							<button onClick={() => handleAction(req.id, 'deny')} className="btn btn-small btn-danger">Ablehnen</button>
						</div>
					</div>
				))}
			</div>
		</div>
	);
};

export default AdminRequestsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminStoragePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StorageItemModal from '../../components/admin/storage/StorageItemModal';
import Lightbox from '../../components/ui/Lightbox';
import StatusBadge from '../../components/ui/StatusBadge';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import QRCode from 'qrcode.react';

const AdminStoragePage = () => {
	const apiCall = useCallback(() => apiClient.get('/storage'), []);
	const { data: items, loading, error, reload } = useApi(apiCall);
	const [modalState, setModalState] = useState({ isOpen: false, item: null, mode: 'edit' });
	const [lightboxSrc, setLightboxSrc] = useState('');
	const [qrCodeItem, setQrCodeItem] = useState(null);
	const { addToast } = useToast();

	const openModal = (mode, item = null) => {
		setModalState({ isOpen: true, item, mode });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, item: null, mode: 'edit' });
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (item) => {
		if (window.confirm(`Artikel '${item.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/storage/${item.id}`);
				if (result.success) {
					addToast('Artikel gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-warehouse"></i> Lagerverwaltung</h1>
			<div className="table-controls">
				<button onClick={() => openModal('create')} className="btn btn-success">
					<i className="fas fa-plus"></i> Neuen Artikel anlegen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Ort</th>
							<th>Verfügbar</th>
							<th>Status</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="5">Lade Artikel...</td></tr>}
						{error && <tr><td colSpan="5" className="error-message">{error}</td></tr>}
						{items?.map(item => (
							<tr key={item.id}>
								<td className="item-name-cell">
									<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
									{item.imagePath && (
										<button className="camera-btn" onClick={() => setLightboxSrc(`/api/v1/public/files/images/${item.imagePath}`)}>
											<i className="fas fa-camera"></i>
										</button>
									)}
								</td>
								<td>{item.location}</td>
								<td>
									{item.availableQuantity}/{item.maxQuantity}
									{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} def.)</span>}
								</td>
								<td><StatusBadge status={item.status} /></td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<button onClick={() => openModal('edit', item)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Defekt</button>
									{item.defectiveQuantity > 0 && (
										<button onClick={() => openModal('repair', item)} className="btn btn-small btn-success">Repariert</button>
									)}
									<button onClick={() => setQrCodeItem(item)} className="btn btn-small btn-info">QR</button>
									<button onClick={() => handleDelete(item)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Artikel...</p>}
				{error && <p className="error-message">{error}</p>}
				{items?.map(item => (
					<div key={item.id} className="list-item-card">
						<h3 className="card-title">
							<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
							{item.imagePath && (
								<button className="camera-btn" onClick={() => setLightboxSrc(`/api/v1/public/files/images/${item.imagePath}`)}>
									<i className="fas fa-camera"></i>
								</button>
							)}
						</h3>
						<div className="card-row"><strong>Status:</strong> <StatusBadge status={item.status} /></div>
						<div className="card-row"><strong>Verfügbar:</strong> <span>{item.availableQuantity}/{item.maxQuantity}{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} def.)</span>}</span></div>
						<div className="card-row"><strong>Ort:</strong> <span>{item.location}</span></div>
						<div className="card-actions">
							<button onClick={() => openModal('edit', item)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Defekt</button>
							{item.defectiveQuantity > 0 && (
								<button onClick={() => openModal('repair', item)} className="btn btn-small btn-success">Repariert</button>
							)}
							<button onClick={() => setQrCodeItem(item)} className="btn btn-small btn-info">QR</button>
							<button onClick={() => handleDelete(item)} className="btn btn-small btn-danger">Löschen</button>
						</div>
					</div>
				))}
			</div>

			{modalState.isOpen && (
				<StorageItemModal
					isOpen={modalState.isOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					item={modalState.item}
					initialMode={modalState.mode}
				/>
			)}

			{qrCodeItem && (
				<Modal isOpen={!!qrCodeItem} onClose={() => setQrCodeItem(null)} title={`QR-Code für: ${qrCodeItem.name}`}>
					<div style={{ textAlign: 'center', padding: '1rem' }}>
						<QRCode value={`${window.location.origin}/lager/qr-aktion/${qrCodeItem.id}`} size={256} />
						<p style={{ marginTop: '1rem' }}>Scannen für schnelle Aktionen.</p>
					</div>
				</Modal>
			)}

			{lightboxSrc && <Lightbox src={lightboxSrc} onClose={() => setLightboxSrc('')} />}
		</div>
	);
};

export default AdminStoragePage;
========================================================================
FILE: frontend\src\pages\admin\AdminSystemPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';

const AdminSystemPage = () => {
	const apiCall = useCallback(() => apiClient.get('/system/stats'), []);
	const { data: stats, loading, error } = useApi(apiCall);

	const formatPercent = (value) => `${value.toFixed(1)}%`;
	const formatGB = (value) => `${value.toFixed(2)} GB`;

	if (loading) return <div>Lade Systeminformationen...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-server"></i> Systeminformationen</h1>
			<p>Live-Statistiken über den Zustand des Servers, auf dem die Anwendung läuft.</p>
			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">CPU & Speicher</h2>
					<ul className="details-list">
						<li><strong>CPU-Auslastung:</strong> <span>{stats.cpuLoad > 0 ? formatPercent(stats.cpuLoad) : 'Wird geladen...'}</span></li>
						<li><strong>RAM-Nutzung:</strong> <span>{formatGB(stats.usedMemory)} / {formatGB(stats.totalMemory)}</span></li>
					</ul>
				</div>
				<div className="card">
					<h2 className="card-title">Festplattenspeicher</h2>
					<ul className="details-list">
						<li><strong>Speichernutzung (Root):</strong> <span>{formatGB(stats.usedDiskSpace)} / {formatGB(stats.totalDiskSpace)}</span></li>
					</ul>
				</div>
				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<h2 className="card-title">Laufzeit & Energie</h2>
					<ul className="details-list">
						<li><strong>Server-Laufzeit:</strong> <span>{stats.uptime}</span></li>
						<li><strong>Batteriestatus:</strong> <span>{stats.batteryPercentage >= 0 ? `${stats.batteryPercentage}%` : 'Nicht verfügbar'}</span></li>
					</ul>
				</div>
			</div>
		</div>
	);
};

export default AdminSystemPage;
========================================================================
FILE: frontend\src\pages\admin\AdminUsersPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import UserModal from '../../components/admin/users/UserModal';
import useAdminData from '../../hooks/useAdminData';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminUsersPage = () => {
	const apiCall = useCallback(() => apiClient.get('/users'), []);
	const { data: users, loading, error, reload } = useApi(apiCall);
	const adminFormData = useAdminData();
	const { addToast } = useToast();

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingUser, setEditingUser] = useState(null);
	const [resetPasswordInfo, setResetPasswordInfo] = useState({ user: null, password: '' });

	const handleOpenNewUserModal = () => {
		setEditingUser(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (user) => {
		setEditingUser(user);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingUser(null);
	};

	const handleClosePasswordModal = () => {
		setResetPasswordInfo({ user: null, password: '' });
	};

	const handleSuccess = () => {
		handleCloseModal();
		reload();
	};

	const handleDelete = async (user) => {
		if (window.confirm(`Benutzer '${user.username}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/users/${user.id}`);
				if (result.success) {
					addToast('Benutzer erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	const handleResetPassword = async (user) => {
		if (window.confirm(`Passwort für '${user.username}' wirklich zurücksetzen?`)) {
			try {
				const result = await apiClient.post(`/users/${user.id}/reset-password`);
				if (result.success) {
					setResetPasswordInfo({ user: user, password: result.data.newPassword });
					addToast('Passwort zurückgesetzt.', 'success');
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	const copyToClipboard = () => {
		navigator.clipboard.writeText(resetPasswordInfo.password);
		addToast('Passwort in die Zwischenablage kopiert.', 'info');
	};

	return (
		<div>
			<h1><i className="fas fa-users-cog"></i> Benutzerverwaltung</h1>
			<p>Verwalten Sie hier alle Benutzerkonten und deren individuelle Berechtigungen.</p>

			<div className="table-controls">
				<button onClick={handleOpenNewUserModal} className="btn btn-success">
					<i className="fas fa-user-plus"></i> Neuen Benutzer anlegen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>ID</th>
							<th>Benutzername</th>
							<th>Rolle</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Benutzer...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{users?.map(user => (
							<tr key={user.id}>
								<td>{user.id}</td>
								<td>{user.username}</td>
								<td>{user.roleName}</td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<button onClick={() => handleOpenEditModal(user)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleResetPassword(user)} className="btn btn-small btn-warning">Passwort Reset</button>
									<button onClick={() => handleDelete(user)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{loading && <p>Lade Benutzer...</p>}
				{error && <p className="error-message">{error}</p>}
				{users?.map(user => (
					<div key={user.id} className="list-item-card">
						<h3 className="card-title">{user.username}</h3>
						<div className="card-row"><strong>ID:</strong> <span>{user.id}</span></div>
						<div className="card-row"><strong>Rolle:</strong> <span>{user.roleName}</span></div>
						<div className="card-actions">
							<button onClick={() => handleOpenEditModal(user)} className="btn btn-small">Bearbeiten</button>
							<button onClick={() => handleResetPassword(user)} className="btn btn-small btn-warning">Passwort Reset</button>
							<button onClick={() => handleDelete(user)} className="btn btn-small btn-danger">Löschen</button>
						</div>
					</div>
				))}
			</div>

			{isModalOpen && (
				<UserModal
					isOpen={isModalOpen}
					onClose={handleCloseModal}
					onSuccess={handleSuccess}
					user={editingUser}
					roles={adminFormData.roles}
					groupedPermissions={adminFormData.groupedPermissions}
					isLoadingData={adminFormData.loading}
				/>
			)}

			{resetPasswordInfo.user && (
				<Modal isOpen={!!resetPasswordInfo.user} onClose={handleClosePasswordModal} title="Passwort wurde zurückgesetzt">
					<p>Das neue, temporäre Passwort für <strong>{resetPasswordInfo.user.username}</strong> ist:</p>
					<div style={{ background: 'var(--bg-color)', padding: '1rem', borderRadius: 'var(--border-radius)', fontFamily: 'monospace', margin: '1rem 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
						<span>{resetPasswordInfo.password}</span>
						<button className="btn btn-small" onClick={copyToClipboard} title="In die Zwischenablage kopieren">
							<i className="fas fa-copy"></i>
						</button>
					</div>
					<p className="text-danger" style={{ fontWeight: 'bold' }}>Dieses Passwort wird nur einmal angezeigt! Bitte geben Sie es sicher an den Benutzer weiter.</p>
				</Modal>
			)}
		</div>
	);
};

export default AdminUsersPage;
========================================================================
FILE: frontend\src\pages\admin\AdminVenuesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminVenuesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/admin/venues'), []);
	const { data: venues, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingVenue, setEditingVenue] = useState(null);
	const { addToast } = useToast();

	const openModal = (venue = null) => {
		setEditingVenue(venue);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingVenue(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (venue) => {
		if (window.confirm(`Veranstaltungsort "${venue.name}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/venues/${venue.id}`);
				if (result.success) {
					addToast('Ort erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-map-marked-alt"></i> Veranstaltungsorte verwalten</h1>
			<p>Verwalten Sie hier die Orte und die zugehörigen Raumpläne.</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neuer Ort
				</button>
			</div>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Adresse</th>
							<th>Kartenbild</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Orte...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{venues?.map(venue => (
							<tr key={venue.id}>
								<td>{venue.name}</td>
								<td>{venue.address}</td>
								<td>{venue.mapImagePath ? 'Ja' : 'Nein'}</td>
								<td>
									<button onClick={() => openModal(venue)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(venue)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{isModalOpen && (
				<VenueModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					venue={editingVenue}
				/>
			)}
		</div>
	);
};

const VenueModal = ({ isOpen, onClose, onSuccess, venue }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const formData = new FormData();
		const venueData = {
			name: e.target.name.value,
			address: e.target.address.value,
			notes: e.target.notes.value,
			mapImagePath: venue?.mapImagePath // Preserve existing image path
		};
		formData.append('venue', new Blob([JSON.stringify(venueData)], { type: 'application/json' }));
		if (e.target.mapImage.files[0]) {
			formData.append('mapImage', e.target.mapImage.files[0]);
		}

		try {
			const endpoint = venue ? `/admin/venues/${venue.id}` : '/admin/venues';
			// Since apiClient doesn't have a dedicated `put` for FormData, we use `request`
			const result = await apiClient.request(endpoint, {
				method: venue ? 'PUT' : 'POST',
				body: formData
			});

			if (result.success) {
				addToast(`Ort erfolgreich ${venue ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={venue ? 'Ort bearbeiten' : 'Neuen Ort erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label>Name des Ortes</label>
					<input name="name" defaultValue={venue?.name} required />
				</div>
				<div className="form-group">
					<label>Adresse (optional)</label>
					<input name="address" defaultValue={venue?.address} />
				</div>
				<div className="form-group">
					<label>Notizen (z.B. Kontaktperson, Besonderheiten)</label>
					<textarea name="notes" defaultValue={venue?.notes} rows="3"></textarea>
				</div>
				<div className="form-group">
					<label>Raumplan / Kartenbild (optional)</label>
					<input type="file" name="mapImage" accept="image/*" />
					{venue?.mapImagePath && <small>Aktuelles Bild wird überschrieben, wenn eine neue Datei ausgewählt wird.</small>}
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminVenuesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminWikiPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const WikiPageModal = ({ isOpen, onClose, onSuccess, parentPath }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const formData = new FormData(e.target);
		const fileName = formData.get('fileName');
		const fullPath = parentPath ? `${parentPath}/${fileName}` : fileName;

		try {
			const result = await apiClient.post('/wiki', { filePath: fullPath, content: `# ${fileName}\n\nNeue Seite.` });
			if (result.success) {
				addToast('Seite erfolgreich erstellt', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Erstellen der Seite fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Wiki-Seite erstellen">
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="wiki-parent-path">Übergeordneter Pfad</label>
					<input id="wiki-parent-path" type="text" value={parentPath || '/'} readOnly disabled />
				</div>
				<div className="form-group">
					<label htmlFor="wiki-file-name">Dateiname (z.B. `neue-seite.md`)</label>
					<input id="wiki-file-name" name="fileName" required pattern=".*\.md$" title="Muss mit .md enden" />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird erstellt...' : 'Seite erstellen'}
				</button>
			</form>
		</Modal>
	);
};


const AdminWikiPage = () => {
	const treeApiCall = useCallback(() => apiClient.get('/wiki'), []);
	const { data: wikiTree, loading, error, reload } = useApi(treeApiCall);
	const [selectedEntry, setSelectedEntry] = useState(null);
	const [isEditing, setIsEditing] = useState(false);
	const [editContent, setEditContent] = useState('');
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [modalParentPath, setModalParentPath] = useState('');
	const { addToast } = useToast();

	const handleSelectEntry = async (entry) => {
		try {
			const result = await apiClient.get(`/wiki/${entry.id}`);
			if (result.success) {
				setSelectedEntry(result.data);
				setEditContent(result.data.content);
				setIsEditing(false);
			}
		} catch (err) {
			addToast(`Fehler beim Laden der Seite: ${err.message}`, 'error');
		}
	};

	const handleSave = async () => {
		if (!selectedEntry) return;
		try {
			const result = await apiClient.put(`/wiki/${selectedEntry.id}`, { content: editContent });
			if (result.success) {
				addToast('Seite gespeichert', 'success');
				await handleSelectEntry(selectedEntry); // Reload content
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Speichern: ${err.message}`, 'error');
		}
	};

	const handleDelete = async () => {
		if (!selectedEntry) return;
		if (window.confirm(`Seite "${selectedEntry.filePath}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/wiki/${selectedEntry.id}`);
				if (result.success) {
					addToast('Seite gelöscht', 'success');
					setSelectedEntry(null);
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler beim Löschen: ${err.message}`, 'error');
			}
		}
	};

	const renderTree = (node, path = '') => (
		<ul>
			{Object.entries(node).map(([name, child]) => (
				<li key={path + name}>
					{child.id ? ( // It's a file
						<a href="#" onClick={(e) => { e.preventDefault(); handleSelectEntry(child); }} className={selectedEntry?.id === child.id ? 'active' : ''}>
							<i className="fas fa-file-alt fa-fw"></i> {name}
						</a>
					) : ( // It's a directory
						<details open>
							<summary><i className="fas fa-folder fa-fw"></i> {name}</summary>
							{renderTree(child, `${path}${name}/`)}
						</details>
					)}
				</li>
			))}
		</ul>
	);

	if (loading) return <div>Lade Wiki-Struktur...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div className="wiki-page-wrapper">
			<aside className="wiki-sidebar">
				<div className="wiki-sidebar-header">
					<h3>Wiki-Verzeichnis</h3>
					<button className="btn btn-small" onClick={() => { setModalParentPath(''); setIsModalOpen(true); }}>+</button>
				</div>
				<div className="wiki-tree-container">
					{wikiTree && renderTree(wikiTree)}
				</div>
			</aside>
			<main className="wiki-content-pane">
				{selectedEntry ? (
					<>
						<div className="wiki-content-header">
							<h2>{selectedEntry.filePath}</h2>
							<div className="wiki-editor-controls">
								{isEditing ? (
									<>
										<button onClick={handleSave} className="btn btn-success btn-small">Speichern</button>
										<button onClick={() => setIsEditing(false)} className="btn btn-secondary btn-small">Abbrechen</button>
									</>
								) : (
									<>
										<button onClick={() => setIsEditing(true)} className="btn btn-small">Bearbeiten</button>
										<button onClick={handleDelete} className="btn btn-danger btn-small">Löschen</button>
									</>
								)}
							</div>
						</div>
						{isEditing ? (
							<textarea
								id="editor"
								className="form-group"
								value={editContent}
								onChange={(e) => setEditContent(e.target.value)}
								style={{ flexGrow: 1, fontFamily: 'monospace' }}
							/>
						) : (
							<div className="markdown-content">
								<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
									{selectedEntry.content}
								</ReactMarkdown>
							</div>
						)}
					</>
				) : (
					<div className="wiki-welcome-pane">
						<i className="fas fa-book-reader" style={{ fontSize: '4rem' }}></i>
						<h1>Wiki</h1>
						<p>Wählen Sie eine Seite aus der Navigation aus, um sie anzuzeigen oder zu bearbeiten.</p>
					</div>
				)}
			</main>
			{isModalOpen && (
				<WikiPageModal
					isOpen={isModalOpen}
					onClose={() => setIsModalOpen(false)}
					onSuccess={() => { setIsModalOpen(false); reload(); }}
					parentPath={modalParentPath}
				/>
			)}
		</div>
	);
};

export default AdminWikiPage;
========================================================================
FILE: frontend\src\pages\error\ErrorPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { useRouteError, Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const ErrorPage = () => {
	const error = useRouteError();
	console.error(error);

	// Safely determine the error message to display
	const errorMessage = useMemo(() => {
		if (typeof error === 'string') return error;
		if (error instanceof Error) return error.message;
		if (error?.statusText) return error.statusText;
		if (error?.message) return error.message;
		return "Ein unbekannter Fehler ist aufgetreten.";
	}, [error]);

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: 'SYSTEMDIAGNOSE WIRD GESTARTET...', className: 'info' },
		{ text: 'Speichermodule werden gescannt...', className: 'info', delayAfter: 500 },
		{ text: '[OK] Speicherintegritätsprüfung bestanden.', className: 'ok' },
		{ text: 'Anwendungsstatus wird überprüft...', className: 'info', delayAfter: 500 },
		{ text: `[FEHLER] Unbehandelte Ausnahme erkannt: ${errorMessage}`, className: 'fail', delayAfter: 800 },
		{ text: 'FEHLER 500: Interner Serverfehler.', className: 'fail' },
		{ text: 'Ein kritischer Fehler ist bei der Verarbeitung der Anfrage aufgetreten.', className: 'info' },
		{ text: 'Der Systemadministrator wurde benachrichtigt.', className: 'info' },
		{ text: 'Wiederherstellungsoptionen werden vorbereitet...', className: 'warn' },
	], [errorMessage]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SYSTEM_DIAGNOSTIC.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default ErrorPage;
========================================================================
FILE: frontend\src\pages\error\ErrorTrigger.jsx
========================================================================

import { useEffect } from 'react';

const ErrorTrigger = () => {
	useEffect(() => {
		// This will cause a rendering error that the boundary will catch.
		throw new Error("Dies ist ein simulierter Rendering-Fehler zum Testen der 500-Seite.");
	}, []);

	return <div>You should not see this.</div>;
};

export default ErrorTrigger;
========================================================================
FILE: frontend\src\pages\error\ForbiddenPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import { useAuthStore } from '../../store/authStore';

const ForbiddenPage = () => {
	const user = useAuthStore(state => state.user);

	const lines = useMemo(() => [
		{ text: 'Zugriffsversuch auf geschützten Bereich...', className: 'info' },
		{ text: `Benutzer wird authentifiziert: ${user?.username || 'GAST'}`, className: 'info', delayAfter: 500 },
		{ text: 'Berechtigungsstufe wird geprüft...', className: 'info', delayAfter: 800 },
		{ text: '[ZUGRIFF VERWEIGERT]', className: 'fail', speed: 80 },
		{ text: 'FEHLER 403: Unzureichende Berechtigungen.', className: 'fail' },
		{ text: 'Ihre aktuelle Rolle gewährt keinen Zugriff auf diese Ressource.', className: 'warn' },
		{ text: 'Dieser Versuch wurde protokolliert.', className: 'info' },
	], [user]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="full-screen-terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SECURITY.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<div className="terminal-footer">
				<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
					<i className="fas fa-arrow-left"></i> Zurück zum sicheren Bereich
				</Link>
			</div>
		</div>
	);
};

export default ForbiddenPage;
========================================================================
FILE: frontend\src\pages\error\NotFoundPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link, useLocation } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const NotFoundPage = () => {
	const location = useLocation();
	const path = location.pathname;

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: `Führe Befehl aus: find . -name "${path}"`, className: 'info', delayAfter: 800 },
		{ text: `find: '${path}': Datei oder Verzeichnis nicht gefunden`, className: 'warn', delayAfter: 500 },
		{ text: 'FEHLER 404: Ressource nicht gefunden.', className: 'fail' },
		{ text: 'Vorschlag: Die angeforderte Ressource ist nicht verfügbar. Versuchen Sie, zum Dashboard zurückzukehren.', className: 'info' },
		{ text: `Führe aus: cd /home`, className: 'info' },
	], [path]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">bash</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{index < 1 ? '$' : '>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default NotFoundPage;
========================================================================
FILE: frontend\src\router\AdminRoute.jsx
========================================================================

import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const AdminRoute = () => {
	const isAdmin = useAuthStore((state) => state.isAdmin);

	// Check for authentication is handled by ProtectedRoute, this just checks for admin role.
	if (!isAdmin) {
		// Instead of rendering a component directly, we navigate to a dedicated route for 403.
		// This keeps the URL consistent with the error being shown.
		return <Navigate to="/forbidden" replace />;
	}

	return <Outlet />;
};

export default AdminRoute;
========================================================================
FILE: frontend\src\router\index.jsx
========================================================================

import React, { lazy, Suspense } from 'react';
import { createBrowserRouter, Navigate } from 'react-router-dom';

// Layouts and Core Components
import App from '../App';
import MinimalLayout from '../components/layout/MinimalLayout';
import ErrorLayout from '../components/layout/ErrorLayout';
import ProtectedRoute from './ProtectedRoute';
import AdminRoute from './AdminRoute';

// Eagerly load the LoginPage, Error Pages, and the new ChatPage
import LoginPage from '../pages/LoginPage';
import ErrorPage from '../pages/error/ErrorPage';
import NotFoundPage from '../pages/error/NotFoundPage';
import ChatPage from '../pages/ChatPage'; // Eagerly load ChatPage

// Lazy load all other pages
const DashboardPage = lazy(() => import('../pages/DashboardPage'));
const StoragePage = lazy(() => import('../pages/StoragePage'));
const StorageItemDetailsPage = lazy(() => import('../pages/StorageItemDetailsPage'));
const QrActionPage = lazy(() => import('../pages/QrActionPage'));
const EventsPage = lazy(() => import('../pages/EventsPage'));
const EventDetailsPage = lazy(() => import('../pages/EventDetailsPage'));
const LehrgaengePage = lazy(() => import('../pages/LehrgaengePage'));
const MeetingDetailsPage = lazy(() => import('../pages/MeetingDetailsPage'));
const ProfilePage = lazy(() => import('../pages/ProfilePage'));
const PasswordPage = lazy(() => import('../pages/PasswordPage'));
const FilesPage = lazy(() => import('../pages/FilesPage'));
const FeedbackPage = lazy(() => import('../pages/FeedbackPage'));
const EventFeedbackPage = lazy(() => import('../pages/EventFeedbackPage'));
const CalendarPage = lazy(() => import('../pages/CalendarPage'));
const PackKitPage = lazy(() => import('../pages/PackKitPage'));
const SearchResultsPage = lazy(() => import('../pages/SearchResultsPage'));
const ChangelogPage = lazy(() => import('../pages/ChangelogPage'));

// Admin Pages
const AdminDashboardPage = lazy(() => import('../pages/admin/AdminDashboardPage'));
const AdminUsersPage = lazy(() => import('../pages/admin/AdminUsersPage'));
const AdminRequestsPage = lazy(() => import('../pages/admin/AdminRequestsPage'));
const AdminEventsPage = lazy(() => import('../pages/admin/AdminEventsPage'));
const AdminEventDebriefingPage = lazy(() => import('../pages/admin/AdminEventDebriefingPage'));
const AdminDebriefingsListPage = lazy(() => import('../pages/admin/AdminDebriefingsListPage'));
const AdminEventRolesPage = lazy(() => import('../pages/admin/AdminEventRolesPage'));
const AdminCoursesPage = lazy(() => import('../pages/admin/AdminCoursesPage'));
const AdminMeetingsPage = lazy(() => import('../pages/admin/AdminMeetingsPage'));
const AdminStoragePage = lazy(() => import('../pages/admin/AdminStoragePage'));
const AdminDefectivePage = lazy(() => import('../pages/admin/AdminDefectivePage'));
const AdminDamageReportsPage = lazy(() => import('../pages/admin/AdminDamageReportsPage'));
const AdminLogPage = lazy(() => import('../pages/admin/AdminLogPage'));
const AdminKitsPage = lazy(() => import('../pages/admin/AdminKitsPage'));
const AdminMatrixPage = lazy(() => import('../pages/admin/AdminMatrixPage'));
const AdminReportsPage = lazy(() => import('../pages/admin/AdminReportsPage'));
const AdminSystemPage = lazy(() => import('../pages/admin/AdminSystemPage'));
const AdminFilesPage = lazy(() => import('../pages/admin/AdminFilesPage'));
const AdminFeedbackPage = lazy(() => import('../pages/admin/AdminFeedbackPage'));
const AdminAchievementsPage = lazy(() => import('../pages/admin/AdminAchievementsPage'));
const AdminWikiPage = lazy(() => import('../pages/admin/AdminWikiPage'));
const AdminNotificationsPage = lazy(() => import('../pages/admin/AdminNotificationsPage'));
const AdminVenuesPage = lazy(() => import('../pages/admin/AdminVenuesPage'));
const AdminChecklistTemplatesPage = lazy(() => import('../pages/admin/AdminChecklistTemplatesPage'));
const AdminChangelogPage = lazy(() => import('../pages/admin/AdminChangelogPage'));


import ErrorTrigger from '../pages/error/ErrorTrigger';
import ForbiddenPage from '../pages/error/ForbiddenPage';

const router = createBrowserRouter([
	{
		path: '/',
		element: (
			<ProtectedRoute>
				<App />
			</ProtectedRoute>
		),
		errorElement: <ErrorLayout><ErrorPage /></ErrorLayout>,
		children: [
			{ index: true, element: <Navigate to="/home" replace /> },
			{ path: 'home', element: <DashboardPage /> },
			{ path: 'lager', element: <StoragePage /> },
			{ path: 'lager/details/:itemId', element: <StorageItemDetailsPage /> },
			{ path: 'veranstaltungen', element: <EventsPage /> },
			{ path: 'veranstaltungen/details/:eventId', element: <EventDetailsPage /> },
			{ path: 'lehrgaenge', element: <LehrgaengePage /> },
			{ path: 'lehrgaenge/details/:meetingId', element: <MeetingDetailsPage /> },
			{ path: 'profil', element: <ProfilePage /> },
			{ path: 'passwort', element: <PasswordPage /> },
			{ path: 'dateien', element: <FilesPage /> },
			{ path: 'feedback', element: <FeedbackPage /> },
			{ path: 'feedback/event/:eventId', element: <EventFeedbackPage /> },
			{ path: 'kalender', element: <CalendarPage /> },
			{ path: 'suche', element: <SearchResultsPage /> },
			{ path: 'changelogs', element: <ChangelogPage /> },
			{ path: 'chat', element: <ChatPage /> },
			{ path: 'chat/:conversationId', element: <ChatPage /> },
			{ path: 'test-500', element: <ErrorTrigger /> },

			{
				path: 'admin',
				element: <AdminRoute />,
				children: [
					{ index: true, element: <Navigate to="/admin/dashboard" replace /> },
					{ path: 'dashboard', element: <AdminDashboardPage /> },
					{ path: 'mitglieder', element: <AdminUsersPage /> },
					{ path: 'requests', element: <AdminRequestsPage /> },
					{ path: 'veranstaltungen', element: <AdminEventsPage /> },
					{ path: 'veranstaltungen/:eventId/debriefing', element: <AdminEventDebriefingPage /> },
					{ path: 'debriefings', element: <AdminDebriefingsListPage /> },
					{ path: 'event-roles', element: <AdminEventRolesPage /> },
					{ path: 'venues', element: <AdminVenuesPage /> },
					{ path: 'lehrgaenge', element: <AdminCoursesPage /> },
					{ path: 'lehrgaenge/:courseId/meetings', element: <AdminMeetingsPage /> },
					{ path: 'lager', element: <AdminStoragePage /> },
					{ path: 'dateien', element: <AdminFilesPage /> },
					{ path: 'kits', element: <AdminKitsPage /> },
					{ path: 'feedback', element: <AdminFeedbackPage /> },
					{ path: 'benachrichtigungen', element: <AdminNotificationsPage /> },
					{ path: 'achievements', element: <AdminAchievementsPage /> },
					{ path: 'defekte', element: <AdminDefectivePage /> },
					{ path: 'damage-reports', element: <AdminDamageReportsPage /> },
					{ path: 'checklist-templates', element: <AdminChecklistTemplatesPage /> },
					{ path: 'matrix', element: <AdminMatrixPage /> },
					{ path: 'berichte', element: <AdminReportsPage /> },
					{ path: 'changelogs', element: <AdminChangelogPage /> },
					{ path: 'log', element: <AdminLogPage /> },
					{ path: 'system', element: <AdminSystemPage /> },
					{ path: 'wiki', element: <AdminWikiPage /> },
				],
			},
		],
	},
	{
		path: '/pack-kit/:kitId',
		element: (
			<ProtectedRoute>
				<MinimalLayout />
			</ProtectedRoute>
		),
		children: [
			{
				index: true,
				element: <PackKitPage />
			}
		]
	},
	{
		path: '/lager/qr-aktion/:itemId',
		element: (
			<ProtectedRoute>
				<MinimalLayout />
			</ProtectedRoute>
		),
		children: [
			{
				index: true,
				element: <QrActionPage />
			}
		]
	},
	{
		path: '/login',
		element: <Suspense fallback={<div>Laden...</div>}><LoginPage /></Suspense>,
	},
	{
		path: '/forbidden',
		element: <ErrorLayout><ForbiddenPage /></ErrorLayout>,
	},
	{
		path: '*',
		element: <ErrorLayout><NotFoundPage /></ErrorLayout>,
	}
]);

export default router;
========================================================================
FILE: frontend\src\router\ProtectedRoute.jsx
========================================================================

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const ProtectedRoute = ({ children }) => {
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
	const location = useLocation();

	if (!isAuthenticated) {
		return <Navigate to="/login" state={{ from: location }} replace />;
	}

	return children;
};

export default ProtectedRoute;
========================================================================
FILE: frontend\src\services\apiClient.js
========================================================================

const BASE_URL = '/api/v1';

let onUnauthorizedCallback = () => { }; // Placeholder for the logout function

const apiClient = {
	setup: function(callbacks) {
		onUnauthorizedCallback = callbacks.onUnauthorized;
	},

	request: async function(endpoint, options = {}) {
		const headers = {
			'Content-Type': 'application/json',
			...options.headers,
		};

		if (options.body instanceof FormData) {
			delete headers['Content-Type'];
		}

		const method = options.method || 'GET';
		if (['POST', 'PUT', 'DELETE'].includes(method.toUpperCase())) {
			const match = document.cookie.match(new RegExp('(^| )' + 'XSRF-TOKEN' + '=([^;]+)'));
			if (match) {
				headers['X-XSRF-TOKEN'] = match[2];
			} else {
				// Don't warn for public endpoints that don't need CSRF
				const publicPostEndpoints = ['/auth/login', '/auth/logout', '/passkey/login/start', '/passkey/login/finish'];
				if (!publicPostEndpoints.includes(endpoint)) {
					console.warn('CSRF token not found. State-changing requests may fail.');
				}
			}
		}

		try {
			const response = await fetch(`${BASE_URL}${endpoint}`, {
				...options,
				headers: headers,
				credentials: 'include'
			});

			if (response.status === 401) {
				onUnauthorizedCallback();
				throw new Error('Nicht autorisiert. Ihre Sitzung ist möglicherweise abgelaufen.');
			}
			if (response.status === 403) {
				throw new Error('Zugriff verweigert. Sie haben nicht die erforderlichen Berechtigungen.');
			}

			if (response.status === 204) {
				return { success: true, message: 'Operation successful.', data: null };
			}

			const contentType = response.headers.get("content-type");
			if (!contentType || !contentType.includes("application/json")) {
				const textError = await response.text();
				console.error("Non-JSON API response:", textError);
				throw new Error(`Serververbindung fehlgeschlagen (Status: ${response.status}). Das Backend ist möglicherweise offline.`);
			}

			const result = await response.json();

			if (!response.ok) {
				if (response.status >= 500) {
					throw new Error("Ein interner Serverfehler ist aufgetreten. Bitte versuchen Sie es später erneut.");
				}
				throw new Error(result.message || `Ein Fehler ist aufgetreten (Status: ${response.status})`);
			}

			return result;

		} catch (error) {
			if (error instanceof TypeError && error.message === 'Failed to fetch') {
				console.error(`API Client Network Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
				throw new Error('Netzwerkfehler: Das Backend ist nicht erreichbar. Bitte überprüfen Sie, ob der Server läuft.');
			}
			console.error(`API Client Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
			throw error;
		}
	},

	get(endpoint) {
		return this.request(endpoint, { method: 'GET' });
	},

	post(endpoint, body) {
		const options = {
			method: 'POST',
			body: body instanceof FormData ? body : JSON.stringify(body),
		};
		return this.request(endpoint, options);
	},

	put(endpoint, body) {
		return this.request(endpoint, { method: 'PUT', body: JSON.stringify(body) });
	},

	delete(endpoint) {
		return this.request(endpoint, { method: 'DELETE' });
	},
};

export default apiClient;
========================================================================
FILE: frontend\src\store\authStore.js
========================================================================

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import apiClient from '../services/apiClient';

const hasAdminAccess = (roleName) => {
	// Frontend authorization check based on role.
	return roleName === 'ADMIN';
};

export const useAuthStore = create(
	persist(
		(set, get) => ({
			user: null,
			navigationItems: [],
			isAuthenticated: false,
			isAdmin: false,
			theme: 'light',
			login: async (username, password) => {
				try {
					// The login endpoint now returns the user object on success and sets the cookie
					const response = await apiClient.post('/auth/login', { username, password });
					if (response.success && response.data) {
						await get().fetchUserSession(); // Fetch full session data to be sure
						return true;
					}
					throw new Error(response.message || 'Anmeldung fehlgeschlagen');
				} catch (error) {
					console.error('Login failed:', error);
					get().logout();
					throw error;
				}
			},
			logout: async () => {
				try {
					await apiClient.post('/auth/logout');
				} catch (error) {
					console.error("Logout API call failed, clearing state anyway.", error);
				} finally {
					set({ user: null, navigationItems: [], isAuthenticated: false, isAdmin: false, theme: 'light' });
					localStorage.removeItem('auth-storage');
					document.documentElement.setAttribute('data-theme', 'light');
				}
			},
			fetchUserSession: async () => {
				try {
					const result = await apiClient.get('/auth/me');

					if (result.success && result.data.user && result.data.navigation) {
						const user = result.data.user;
						const newTheme = user.theme || 'light';
						set({
							user: user,
							navigationItems: result.data.navigation,
							isAuthenticated: true,
							isAdmin: hasAdminAccess(user.roleName),
							theme: newTheme,
						});
						document.documentElement.setAttribute('data-theme', newTheme);
					} else {
						throw new Error(result.message || "Ungültige Sitzungsdaten vom Server.");
					}

				} catch (error) {
					console.error("Could not fetch user session. Token might be invalid.", error);
					get().logout();
					throw error;
				}
			},
			setTheme: async (newTheme) => {
				try {
					const result = await apiClient.put('/public/profile/theme', { theme: newTheme });
					if (result.success && result.data) {
						const updatedUser = result.data;
						set({
							user: updatedUser,
							theme: updatedUser.theme,
						});
						document.documentElement.setAttribute('data-theme', updatedUser.theme);
					} else {
						throw new Error(result.message || 'Server konnte das Theme nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save theme preference:", error);
				}
			},
		}),
		{
			name: 'auth-storage',
			storage: createJSONStorage(() => localStorage),
			// We only persist non-sensitive UI state like theme. User/session data is fetched on load.
			partialize: (state) => ({ theme: state.theme }),
		}
	)
);
========================================================================
FILE: src\main\java\de\technikteam\TechnikTeamApplication.java
========================================================================

package de.technikteam;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "de.technikteam")
public class TechnikTeamApplication {

	public static void main(String[] args) {
		SpringApplication.run(TechnikTeamApplication.class, args);
	}

}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAchievementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/achievements")
@Tag(name = "Admin Achievements", description = "Endpoints for managing achievements.")
@SecurityRequirement(name = "bearerAuth")
public class AdminAchievementResource {

	private final AchievementDAO achievementDAO;

	@Autowired
	public AdminAchievementResource(AchievementDAO achievementDAO) {
		this.achievementDAO = achievementDAO;
	}

	@GetMapping
	@Operation(summary = "Get all achievements", description = "Retrieves a list of all available achievements.")
	public ResponseEntity<ApiResponse> getAllAchievements() {
		List<Achievement> achievements = achievementDAO.getAllAchievements();
		return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erfolgreich abgerufen.", achievements));
	}

	@PostMapping
	@Operation(summary = "Create an achievement", description = "Creates a new achievement definition.")
	public ResponseEntity<ApiResponse> createAchievement(@RequestBody Achievement achievement) {
		if (achievementDAO.createAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erstellt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Erstellen des Abzeichens.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an achievement", description = "Updates an existing achievement's details.")
	public ResponseEntity<ApiResponse> updateAchievement(@PathVariable int id, @RequestBody Achievement achievement) {
		achievement.setId(id);
		if (achievementDAO.updateAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren des Abzeichens.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an achievement", description = "Deletes an achievement definition.")
	public ResponseEntity<ApiResponse> deleteAchievement(@PathVariable int id) {
		if (achievementDAO.deleteAchievement(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen gelöscht.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Löschen des Abzeichens.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChangelogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ChangelogDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Changelog;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/changelogs")
@Tag(name = "Admin Changelogs", description = "Endpoints for managing application changelogs.")
public class AdminChangelogResource {

	private final ChangelogDAO changelogDAO;

	@Autowired
	public AdminChangelogResource(ChangelogDAO changelogDAO) {
		this.changelogDAO = changelogDAO;
	}

	@GetMapping
	@Operation(summary = "Get all changelogs")
	public ResponseEntity<ApiResponse> getAllChangelogs() {
		List<Changelog> changelogs = changelogDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Changelogs retrieved successfully.", changelogs));
	}

	@PostMapping
	@Operation(summary = "Create a new changelog entry")
	public ResponseEntity<ApiResponse> createChangelog(@RequestBody Changelog changelog) {
		if (changelogDAO.create(changelog)) {
			return new ResponseEntity<>(new ApiResponse(true, "Changelog created successfully.", changelog),
					HttpStatus.CREATED);
		}
		return ResponseEntity.internalServerError().body(new ApiResponse(false, "Failed to create changelog.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a changelog entry")
	public ResponseEntity<ApiResponse> updateChangelog(@PathVariable int id, @RequestBody Changelog changelog) {
		changelog.setId(id);
		if (changelogDAO.update(changelog)) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog updated successfully.", changelog));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a changelog entry")
	public ResponseEntity<ApiResponse> deleteChangelog(@PathVariable int id) {
		if (changelogDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Changelog deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Changelog not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminChecklistTemplateResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ChecklistTemplateDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistTemplate;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/checklist-templates")
@Tag(name = "Admin Checklist Templates", description = "Endpoints for managing pre-flight checklist templates.")
@SecurityRequirement(name = "bearerAuth")
public class AdminChecklistTemplateResource {

	private final ChecklistTemplateDAO templateDAO;

	@Autowired
	public AdminChecklistTemplateResource(ChecklistTemplateDAO templateDAO) {
		this.templateDAO = templateDAO;
	}

	@GetMapping
	@Operation(summary = "Get all checklist templates")
	public ResponseEntity<ApiResponse> getAllTemplates() {
		List<ChecklistTemplate> templates = templateDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Vorlagen erfolgreich abgerufen.", templates));
	}

	@PostMapping
	@Operation(summary = "Create a new checklist template")
	public ResponseEntity<ApiResponse> createTemplate(@RequestBody ChecklistTemplate template) {
		ChecklistTemplate savedTemplate = templateDAO.save(template);
		return new ResponseEntity<>(new ApiResponse(true, "Vorlage erfolgreich erstellt.", savedTemplate),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a checklist template")
	public ResponseEntity<ApiResponse> updateTemplate(@PathVariable int id, @RequestBody ChecklistTemplate template) {
		template.setId(id);
		ChecklistTemplate updatedTemplate = templateDAO.save(template);
		return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich aktualisiert.", updatedTemplate));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a checklist template")
	public ResponseEntity<ApiResponse> deleteTemplate(@PathVariable int id) {
		if (templateDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Vorlage erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Vorlage nicht gefunden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDamageReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.DamageReportDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.DamageReport;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/damage-reports")
@Tag(name = "Admin Damage Reports", description = "Endpoints for managing user-submitted damage reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDamageReportResource {

	private final DamageReportDAO damageReportDAO;
	private final StorageService storageService;

	@Autowired
	public AdminDamageReportResource(DamageReportDAO damageReportDAO, StorageService storageService) {
		this.damageReportDAO = damageReportDAO;
		this.storageService = storageService;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get all pending damage reports")
	public ResponseEntity<ApiResponse> getPendingReports() {
		List<DamageReport> reports = damageReportDAO.getPendingReports();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Meldungen abgerufen.", reports));
	}

	@PostMapping("/{reportId}/confirm")
	@Operation(summary = "Confirm a damage report")
	public ResponseEntity<ApiResponse> confirmReport(@PathVariable int reportId,
			@RequestBody Map<String, Integer> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		try {
			int quantity = payload.getOrDefault("quantity", 1);
			storageService.confirmDamageReport(reportId, quantity, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung bestätigt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}

	@PostMapping("/{reportId}/reject")
	@Operation(summary = "Reject a damage report")
	public ResponseEntity<ApiResponse> rejectReport(@PathVariable int reportId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String adminNotes = payload.get("adminNotes");
		try {
			storageService.rejectDamageReport(reportId, adminNotes, securityUser.getUser());
			return ResponseEntity.ok(new ApiResponse(true, "Schadensmeldung abgelehnt.", null));
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDashboardResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminDashboardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin/dashboard")
@Tag(name = "Admin Dashboard", description = "Endpoints for the administrative dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDashboardResource {

	private final AdminDashboardService dashboardService;

	@Autowired
	public AdminDashboardResource(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
	}

	@GetMapping
	@Operation(summary = "Get all data for the admin dashboard")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		// The service method doesn't require the user, but this demonstrates the
		// pattern.
		return ResponseEntity.ok(
				new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardService.getDashboardData()));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventDebriefingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventDebriefingDTO;
import de.technikteam.config.Permissions;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventDebriefingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventDebriefing;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventDebriefingService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/admin/events")
@Tag(name = "Admin Event Debriefings", description = "Endpoints for managing post-event reports.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventDebriefingResource {

	private final EventDebriefingDAO debriefingDAO;
	private final EventDebriefingService debriefingService;
	private final EventDAO eventDAO;

	@Autowired
	public AdminEventDebriefingResource(EventDebriefingDAO debriefingDAO, EventDebriefingService debriefingService,
			EventDAO eventDAO) {
		this.debriefingDAO = debriefingDAO;
		this.debriefingService = debriefingService;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/debriefings")
	@Operation(summary = "Get all debriefing reports")
	public ResponseEntity<ApiResponse> getAllDebriefings() {
		List<EventDebriefing> debriefings = debriefingDAO.findAll().stream().map(debriefingService::enrichDebriefing)
				.collect(Collectors.toList());
		return ResponseEntity.ok(new ApiResponse(true, "Debriefings abgerufen.", debriefings));
	}

	@GetMapping("/{eventId}/debriefing")
	@Operation(summary = "Get a debriefing for a specific event")
	public ResponseEntity<ApiResponse> getDebriefingForEvent(@PathVariable int eventId) {
		Optional<EventDebriefing> debriefingOpt = debriefingDAO.findByEventId(eventId);
		if (debriefingOpt.isPresent()) {
			return ResponseEntity.ok(new ApiResponse(true, "Debriefing abgerufen.",
					debriefingService.enrichDebriefing(debriefingOpt.get())));
		} else {
			return ResponseEntity.ok(new ApiResponse(true, "Kein Debriefing für dieses Event vorhanden.", null));
		}
	}

	@PostMapping("/{eventId}/debriefing")
	@Operation(summary = "Create or update a debriefing for an event")
	public ResponseEntity<ApiResponse> saveDebriefing(@PathVariable int eventId,
			@Valid @RequestBody EventDebriefingDTO dto, @AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Event nicht gefunden.", null));
		}

		try {
			EventDebriefing savedDebriefing = debriefingService.saveDebriefing(eventId, dto, user);
			return new ResponseEntity<>(new ApiResponse(true, "Debriefing erfolgreich gespeichert.", savedDebriefing),
					HttpStatus.CREATED);
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventUpdateRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events")
@Tag(name = "Admin Events", description = "Endpoints for managing events.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;

	@Autowired
	public AdminEventResource(EventDAO eventDAO, EventService eventService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(1); // Default system user ID
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all events", description = "Retrieves a list of all events in the system, sorted by date.")
	public ResponseEntity<ApiResponse> getAllEvents() {
		List<Event> events = eventDAO.getAllEvents();
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@PostMapping
	@Operation(summary = "Create a new event", description = "Creates a new event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> createEvent(@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file) {
		try {
			User adminUser = getSystemUser();
			Event event = new Event();
			mapDtoToEvent(eventData, event);

			int newEventId = eventService.createOrUpdateEvent(event, false, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return new ResponseEntity<>(
					new ApiResponse(true, "Veranstaltung erfolgreich erstellt.", Map.of("id", newEventId)),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Erstellen der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update an event", description = "Updates an existing event with attachments, skill requirements, and item reservations.")
	public ResponseEntity<ApiResponse> updateEvent(@PathVariable int id,
			@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file) {
		try {
			User adminUser = getSystemUser();
			Event event = eventDAO.getEventById(id);
			if (event == null) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
			}
			mapDtoToEvent(eventData, event);
			event.setId(id); // Ensure ID is set for update

			eventService.createOrUpdateEvent(event, true, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole(),
					eventData.reminderMinutes());

			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Fehler beim Aktualisieren der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone an event", description = "Creates a deep copy of an existing event, including its details, requirements, and tasks.")
	public ResponseEntity<ApiResponse> cloneEvent(@PathVariable int id) {
		try {
			Event clonedEvent = eventService.cloneEvent(id, getSystemUser());
			return new ResponseEntity<>(new ApiResponse(true, "Event erfolgreich geklont.", clonedEvent),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Events fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event", description = "Permanently deletes an event and all associated data.")
	public ResponseEntity<ApiResponse> deleteEvent(@PathVariable int id) {
		if (eventDAO.deleteEvent(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich gelöscht.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Löschen der Veranstaltung.", null));
		}
	}

	private void mapDtoToEvent(EventUpdateRequest dto, Event event) {
		event.setName(dto.name());
		event.setEventDateTime(dto.eventDateTime());
		event.setEndDateTime(dto.endDateTime());
		event.setDescription(dto.description());
		event.setLocation(dto.location());
		event.setStatus(dto.status());
		event.setLeaderUserId(dto.leaderUserId() != null ? dto.leaderUserId() : 0);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventRoleResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.EventRoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.EventRole;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/admin/event-roles")
@Tag(name = "Admin Event Roles", description = "Endpoints for managing predefined event roles.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventRoleResource {

	private final EventRoleDAO eventRoleDAO;

	@Autowired
	public AdminEventRoleResource(EventRoleDAO eventRoleDAO) {
		this.eventRoleDAO = eventRoleDAO;
	}

	@GetMapping
	@Operation(summary = "Get all event roles")
	public ResponseEntity<ApiResponse> getAllRoles() {
		List<EventRole> roles = eventRoleDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Rollen erfolgreich abgerufen.", roles));
	}

	@PostMapping
	@Operation(summary = "Create a new event role")
	public ResponseEntity<ApiResponse> createRole(@Valid @RequestBody EventRole role) {
		if (eventRoleDAO.create(role)) {
			return new ResponseEntity<>(new ApiResponse(true, "Rolle erfolgreich erstellt.", role), HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
				.body(new ApiResponse(false, "Rolle konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an event role")
	public ResponseEntity<ApiResponse> updateRole(@PathVariable int id, @Valid @RequestBody EventRole role) {
		role.setId(id);
		if (eventRoleDAO.update(role)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich aktualisiert.", role));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event role")
	public ResponseEntity<ApiResponse> deleteRole(@PathVariable int id) {
		if (eventRoleDAO.delete(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Rolle erfolgreich gelöscht.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Rolle nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFeedbackResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/feedback")
@Tag(name = "Admin Feedback", description = "Endpoints for managing user feedback.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;

	@Autowired
	public AdminFeedbackResource(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get all feedback submissions", description = "Retrieves all feedback submissions from all users, ordered by status.")
	public ResponseEntity<ApiResponse> getAllSubmissions() {
		List<FeedbackSubmission> submissions = submissionDAO.getAllSubmissions();
		return ResponseEntity.ok(new ApiResponse(true, "Alle Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PutMapping("/{id}/status")
	@Operation(summary = "Update feedback status", description = "Updates the status of a specific feedback submission.")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int id, @RequestBody Map<String, String> payload) {
		String newStatus = payload.get("status");
		FeedbackSubmission submission = submissionDAO.getSubmissionById(id);
		if (submission == null) {
			return ResponseEntity.notFound().build();
		}
		if (submissionDAO.updateStatusAndTitle(id, newStatus, submission.getDisplayTitle())) {
			return ResponseEntity.ok(new ApiResponse(true, "Status aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFileResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.CategoryRequest;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/files")
@Tag(name = "Admin Files", description = "Endpoints for managing files and categories.")
public class AdminFileResource {

	private final FileDAO fileDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminFileResource(FileDAO fileDAO, FileService fileService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@PostMapping
	@Operation(summary = "Upload a new file")
	public ResponseEntity<ApiResponse> uploadFile(@RequestParam("file") MultipartFile file,
			@RequestParam(required = false) Integer categoryId, @RequestParam String requiredRole) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, categoryId, requiredRole,
					getSystemUser());
			return new ResponseEntity<>(new ApiResponse(true, "Datei erfolgreich hochgeladen.", savedFile),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei konnte nicht hochgeladen werden: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a file")
	public ResponseEntity<ApiResponse> deleteFile(@PathVariable int id) {
		try {
			if (fileService.deleteFile(id, getSystemUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich gelöscht.", Map.of("deletedId", id)));
			} else {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Datei nicht gefunden.", null));
			}
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Datei konnte aufgrund eines Serverfehlers nicht gelöscht werden.", null));
		}
	}

	@PostMapping("/categories")
	@Operation(summary = "Create a new file category")
	public ResponseEntity<ApiResponse> createCategory(@Valid @RequestBody CategoryRequest request) {
		if (fileDAO.createCategory(request.name())) {
			adminLogService.log("SYSTEM", "CREATE_FILE_CATEGORY_API", "Category '" + request.name() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kategorie erfolgreich erstellt.", null),
					HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false,
				"Kategorie konnte nicht erstellt werden. Der Name existiert möglicherweise bereits.", null));
	}

	@DeleteMapping("/categories/{id}")
	@Operation(summary = "Delete a file category")
	public ResponseEntity<ApiResponse> deleteCategory(@PathVariable int id) {
		String categoryName = fileDAO.getCategoryNameById(id);
		if (categoryName != null && fileDAO.deleteCategory(id)) {
			adminLogService.log("SYSTEM", "DELETE_FILE_CATEGORY_API", "Category '" + categoryName + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kategorie erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kategorie nicht gefunden oder konnte nicht gelöscht werden.", null));
	}

	@GetMapping
	@Operation(summary = "Get all files grouped by category (Admin View)")
	public ResponseEntity<ApiResponse> getAllFiles() {
		Map<String, List<de.technikteam.model.File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(null); // Pass
																												// null
																												// as
																												// user
																												// is
																												// not
																												// authenticated
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", groupedFiles));
	}

	@GetMapping("/categories")
	@Operation(summary = "Get all file categories")
	public ResponseEntity<ApiResponse> getAllCategories() {
		List<FileCategory> categories = fileDAO.getAllCategories();
		return ResponseEntity.ok(new ApiResponse(true, "Kategorien erfolgreich abgerufen.", categories));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFormDataResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/users/form-data")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFormDataResource {

	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;

	@Autowired
	public AdminFormDataResource(RoleDAO roleDAO, PermissionDAO permissionDAO) {
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get data for user forms", description = "Retrieves all roles and grouped permissions needed to populate admin forms for creating or editing users.")
	public ResponseEntity<ApiResponse> getFormDataForUserForms() {
		List<Role> roles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			if (key.contains("_")) {
				return key.substring(0, key.indexOf("_"));
			}
			return "SYSTEM";
		}));

		Map<String, Object> formData = Map.of("roles", roles, "groupedPermissions", groupedPermissions);

		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", formData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminNotificationResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.NotificationRequest;
import de.technikteam.config.Permissions;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.NotificationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

@RestController
@RequestMapping("/api/v1/admin/notifications")
@Tag(name = "Admin Notifications", description = "Endpoints for sending and receiving notifications.")
@SecurityRequirement(name = "bearerAuth")
public class AdminNotificationResource {

	private final NotificationService notificationService;

	@Autowired
	public AdminNotificationResource(NotificationService notificationService) {
		this.notificationService = notificationService;
	}

	@GetMapping("/sse")
	@Operation(summary = "Subscribe to SSE notifications", description = "Establishes a Server-Sent Events connection for real-time notifications.")
	public SseEmitter handleSse(@AuthenticationPrincipal SecurityUser securityUser) {
		return notificationService.register(securityUser.getUser());
	}

	@PostMapping
	@Operation(summary = "Send a broadcast notification", description = "Sends a real-time notification to a specified group of users.")
	public ResponseEntity<ApiResponse> sendNotification(@Valid @RequestBody NotificationRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User adminUser = securityUser.getUser();

		try {
			int recipients = notificationService.sendBroadcastNotification(request, adminUser);
			return ResponseEntity
					.ok(new ApiResponse(true, "Benachrichtigung an " + recipients + " Empfänger gesendet.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Senden der Benachrichtigung fehlgeschlagen: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import de.technikteam.service.ProfileRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/requests")
@Tag(name = "Admin Requests", description = "Endpoints for managing user-submitted requests.")
public class AdminRequestResource {

	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService requestService;
	private final UserDAO userDAO;

	@Autowired
	public AdminRequestResource(ProfileChangeRequestDAO requestDAO, ProfileRequestService requestService,
			UserDAO userDAO) {
		this.requestDAO = requestDAO;
		this.requestService = requestService;
		this.userDAO = userDAO;
	}

	private User getSystemUser() {
		// Use the default admin user, which is guaranteed to exist by the
		// InitialAdminCreator
		User user = userDAO.getUserByUsername("admin");
		if (user == null) {
			// This is a critical state and should not happen in a properly initialized
			// system.
			// Throw a runtime exception to make the problem visible in the logs.
			throw new IllegalStateException("The default 'admin' user could not be found in the database.");
		}
		return user;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get pending requests", description = "Retrieves a list of all profile change requests that are pending review.")
	public ResponseEntity<ApiResponse> getPendingRequests() {
		List<ProfileChangeRequest> requests = requestDAO.getPendingRequests();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Anträge erfolgreich abgerufen.", requests));
	}

	@PostMapping("/{id}/approve")
	@Operation(summary = "Approve a request", description = "Approves a profile change request and applies the changes to the user's profile.")
	public ResponseEntity<ApiResponse> approveRequest(
			@Parameter(description = "ID of the request to approve") @PathVariable int id) {
		try {
			if (requestService.approveRequest(id, getSystemUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag genehmigt und Benutzer aktualisiert.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht genehmigt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/deny")
	@Operation(summary = "Deny a request", description = "Denies a profile change request.")
	public ResponseEntity<ApiResponse> denyRequest(
			@Parameter(description = "ID of the request to deny") @PathVariable int id) {
		try {
			if (requestService.denyRequest(id, getSystemUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag abgelehnt.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht abgelehnt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminVenueResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.Venue;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import de.technikteam.dao.VenueDAO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/admin/venues")
@Tag(name = "Admin Venues", description = "Endpoints for managing event venues and maps.")
public class AdminVenueResource {

	private final VenueDAO venueDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminVenueResource(VenueDAO venueDAO, FileService fileService, AdminLogService adminLogService) {
		this.venueDAO = venueDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all venues")
	public ResponseEntity<ApiResponse> getAllVenues() {
		List<Venue> venues = venueDAO.findAll();
		return ResponseEntity.ok(new ApiResponse(true, "Venues retrieved successfully.", venues));
	}

	@PostMapping
	@Operation(summary = "Create a new venue")
	public ResponseEntity<ApiResponse> createVenue(@RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage) throws IOException {
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER", getSystemUser(),
					"venues");
			venue.setMapImagePath(savedFile.getFilepath());
		}
		Venue createdVenue = venueDAO.create(venue);
		adminLogService.log(getSystemUser().getUsername(), "VENUE_CREATE",
				"Venue '" + createdVenue.getName() + "' created.");
		return new ResponseEntity<>(new ApiResponse(true, "Venue created successfully.", createdVenue),
				HttpStatus.CREATED);
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a venue")
	public ResponseEntity<ApiResponse> updateVenue(@PathVariable int id, @RequestPart("venue") Venue venue,
			@RequestPart(value = "mapImage", required = false) MultipartFile mapImage) throws IOException {
		venue.setId(id);
		if (mapImage != null && !mapImage.isEmpty()) {
			de.technikteam.model.File savedFile = fileService.storeFile(mapImage, null, "NUTZER", getSystemUser(),
					"venues");
			venue.setMapImagePath(savedFile.getFilepath());
		} else if (venue.getMapImagePath() == null) {
			// Preserve existing image if a new one is not uploaded but path is not null in
			// DTO
			Optional<Venue> existingVenue = venueDAO.findById(id);
			existingVenue.ifPresent(v -> venue.setMapImagePath(v.getMapImagePath()));
		}

		if (venueDAO.update(venue)) {
			adminLogService.log(getSystemUser().getUsername(), "VENUE_UPDATE",
					"Venue '" + venue.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue updated successfully.", venue));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a venue")
	public ResponseEntity<ApiResponse> deleteVenue(@PathVariable int id) {
		Optional<Venue> venue = venueDAO.findById(id);
		if (venue.isPresent() && venueDAO.delete(id)) {
			adminLogService.log(getSystemUser().getUsername(), "VENUE_DELETE",
					"Venue '" + venue.get().getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Venue deleted successfully.", null));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Venue not found.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ChecklistResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ChecklistDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ChecklistItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events/{eventId}/checklist")
@Tag(name = "Event Checklists", description = "Endpoints for managing event inventory checklists.")
public class ChecklistResource {

	private final ChecklistDAO checklistDAO;

	@Autowired
	public ChecklistResource(ChecklistDAO checklistDAO) {
		this.checklistDAO = checklistDAO;
	}

	@GetMapping
	@Operation(summary = "Get the checklist for an event")
	public ResponseEntity<ApiResponse> getChecklist(@PathVariable int eventId) {
		List<ChecklistItem> checklist = checklistDAO.getChecklistForEvent(eventId);
		return ResponseEntity.ok(new ApiResponse(true, "Checkliste erfolgreich abgerufen.", checklist));
	}

	@PostMapping("/generate")
	@Operation(summary = "Generate or refresh a checklist from reservations")
	public ResponseEntity<ApiResponse> generateChecklist(@PathVariable int eventId) {
		int rowsAffected = checklistDAO.generateChecklistFromReservations(eventId);
		return ResponseEntity
				.ok(new ApiResponse(true, rowsAffected + " Einträge in der Checkliste erstellt/aktualisiert.", null));
	}

	@PutMapping("/{checklistItemId}/status")
	@Operation(summary = "Update the status of a checklist item")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int eventId, @PathVariable int checklistItemId,
			@RequestBody Map<String, String> payload, @AuthenticationPrincipal SecurityUser securityUser) {
		String status = payload.get("status");
		if (status == null) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Status ist erforderlich.", null));
		}

		if (checklistDAO.updateChecklistItemStatus(checklistItemId, status, securityUser.getUser().getId())) {
			ChecklistItem updatedItem = checklistDAO.getChecklistItemById(checklistItemId);
			return ResponseEntity.ok(new ApiResponse(true, "Status erfolgreich aktualisiert.", updatedItem));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\CourseResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/courses")
@Tag(name = "Admin Courses", description = "Endpoints for managing course templates.")
public class CourseResource {

	private final CourseDAO courseDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public CourseResource(CourseDAO courseDAO, AdminLogService adminLogService) {
		this.courseDAO = courseDAO;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all course templates")
	public ResponseEntity<ApiResponse> getAllCourses() {
		List<Course> courses = courseDAO.getAllCourses();
		return ResponseEntity.ok(new ApiResponse(true, "Lehrgänge erfolgreich abgerufen.", courses));
	}

	@PostMapping
	@Operation(summary = "Create a new course template")
	public ResponseEntity<ApiResponse> createCourse(@RequestBody Course course) {
		if (courseDAO.createCourse(course)) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_COURSE_API",
					"Course '" + course.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Lehrgang erfolgreich erstellt.", course),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Lehrgang konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a course template")
	public ResponseEntity<ApiResponse> updateCourse(@PathVariable int id, @RequestBody Course course) {
		course.setId(id);
		if (courseDAO.updateCourse(course)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_COURSE_API",
					"Course '" + course.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich aktualisiert.", course));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a course template")
	public ResponseEntity<ApiResponse> deleteCourse(@PathVariable int id) {
		Course course = courseDAO.getCourseById(id);
		if (course != null && courseDAO.deleteCourse(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_COURSE_API",
					"Course '" + course.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\KitResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/kits")
@Tag(name = "Admin Kits", description = "Endpoints for managing inventory kits.")
public class KitResource {

	private final InventoryKitDAO kitDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public KitResource(InventoryKitDAO kitDAO, AdminLogService adminLogService) {
		this.kitDAO = kitDAO;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all kits with their items")
	public ResponseEntity<ApiResponse> getAllKits() {
		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		return ResponseEntity.ok(new ApiResponse(true, "Kits erfolgreich abgerufen.", kits));
	}

	@PostMapping
	@Operation(summary = "Create a new kit")
	public ResponseEntity<ApiResponse> createKit(@RequestBody InventoryKit kit) {
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			kit.setId(newId);
			adminLogService.log(getSystemUser().getUsername(), "CREATE_KIT_API",
					"Kit '" + kit.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kit erfolgreich erstellt.", kit), HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Kit konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a kit's metadata")
	public ResponseEntity<ApiResponse> updateKit(@PathVariable int id, @RequestBody InventoryKit kit) {
		kit.setId(id);
		if (kitDAO.updateKit(kit)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_KIT_API",
					"Kit '" + kit.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich aktualisiert.", kit));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a kit")
	public ResponseEntity<ApiResponse> deleteKit(@PathVariable int id) {
		InventoryKit kit = kitDAO.getKitById(id);
		if (kit != null && kitDAO.deleteKit(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_KIT_API",
					"Kit '" + kit.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\LogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
@Tag(name = "Admin Logs", description = "Endpoints for viewing the admin action log.")
@SecurityRequirement(name = "bearerAuth")
public class LogResource {

	private final AdminLogDAO logDAO;

	@Autowired
	public LogResource(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	@GetMapping
	@Operation(summary = "Get admin action logs", description = "Retrieves a list of all administrative actions. Can be limited.")
	public ResponseEntity<ApiResponse> getLogs(@RequestParam(required = false) Integer limit) {
		List<AdminLog> logs;
		if (limit != null) {
			logs = logDAO.getRecentLogs(limit);
		} else {
			logs = logDAO.getAllLogs();
		}
		return ResponseEntity.ok(new ApiResponse(true, "Protokolle erfolgreich abgerufen.", logs));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MatrixResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/matrix")
@Tag(name = "Admin Matrix", description = "Endpoints for the qualification matrix.")
@SecurityRequirement(name = "bearerAuth")
public class MatrixResource {

	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;

	@Autowired
	public MatrixResource(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get qualification matrix data")
	public ResponseEntity<ApiResponse> getMatrixData() {
		List<User> allUsers = userDAO.getAllUsers();
		List<Course> allCourses = courseDAO.getAllCourses();

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			meetingsByCourse.put(course.getId(), meetingDAO.getMeetingsForCourse(course.getId()));
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("users", allUsers);
		responseData.put("courses", allCourses);
		responseData.put("meetingsByCourse", meetingsByCourse);
		responseData.put("attendanceMap", attendanceMap);

		return ResponseEntity.ok(new ApiResponse(true, "Matrixdaten erfolgreich abgerufen.", responseData));
	}

	@PutMapping("/attendance")
	@Operation(summary = "Update meeting attendance")
	public ResponseEntity<ApiResponse> updateAttendance(@RequestBody MeetingAttendance attendance) {
		boolean success = meetingAttendanceDAO.setAttendance(attendance.getUserId(), attendance.getMeetingId(),
				attendance.getAttended(), attendance.getRemarks());
		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Teilnahme aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren der Teilnahme.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MeetingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MeetingRequest;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/meetings")
@Tag(name = "Admin Meetings", description = "Endpoints for managing specific training meetings.")
public class MeetingResource {

	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;
	private final EventService eventService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public MeetingResource(MeetingDAO meetingDAO, AdminLogService adminLogService, EventService eventService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		this.eventService = eventService;
		this.richTextPolicy = richTextPolicy;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all meetings for a course")
	public ResponseEntity<ApiResponse> getMeetingsForCourse(@RequestParam int courseId) {
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single meeting by ID")
	public ResponseEntity<ApiResponse> getMeetingById(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich abgerufen.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Termin nicht gefunden.", null));
	}

	@PostMapping
	@Operation(summary = "Create a new meeting")
	public ResponseEntity<ApiResponse> createMeeting(@Valid @RequestBody MeetingRequest request) {
		Meeting meeting = new Meeting();
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		int newId = meetingDAO.createMeeting(meeting);
		if (newId > 0) {
			meeting.setId(newId);
			adminLogService.log(getSystemUser().getUsername(), "CREATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Termin erfolgreich erstellt.", meeting),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Termin konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a meeting")
	public ResponseEntity<ApiResponse> updateMeeting(@PathVariable int id, @Valid @RequestBody MeetingRequest request) {
		Meeting meeting = new Meeting();
		meeting.setId(id);
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		if (meetingDAO.updateMeeting(meeting)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich aktualisiert.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@PostMapping("/{id}/clone")
	@Operation(summary = "Clone a meeting")
	public ResponseEntity<ApiResponse> cloneMeeting(@PathVariable int id) {
		try {
			Meeting clonedMeeting = eventService.cloneMeeting(id, getSystemUser());
			return new ResponseEntity<>(new ApiResponse(true, "Meeting erfolgreich geklont.", clonedMeeting),
					HttpStatus.CREATED);
		} catch (IllegalArgumentException e) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Klonen des Meetings fehlgeschlagen: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a meeting")
	public ResponseEntity<ApiResponse> deleteMeeting(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null && meetingDAO.deleteMeeting(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_MEETING_API",
					"Meeting '" + meeting.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ReportDAO;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/reports")
@Tag(name = "Admin Reports", description = "Endpoints for generating reports and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class ReportResource {

	private final ReportDAO reportDAO;

	@Autowired
	public ReportResource(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@GetMapping("/dashboard")
	@Operation(summary = "Get dashboard report data", description = "Retrieves aggregated data for the admin dashboard, including event trends and user activity.")
	public ResponseEntity<ApiResponse> getDashboardReport() {
		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("eventTrend", reportDAO.getEventCountByMonth(12));
		dashboardData.put("userActivity", reportDAO.getUserParticipationStats(10));
		dashboardData.put("totalInventoryValue", reportDAO.getTotalInventoryValue());
		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\StorageResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/storage")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
public class StorageResource {

	private final StorageDAO storageDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public StorageResource(StorageDAO storageDAO, AdminLogService adminLogService) {
		this.storageDAO = storageDAO;
		this.adminLogService = adminLogService;
	}

	private User getSystemUser() {
		User user = new User();
		user.setId(0);
		user.setUsername("SYSTEM");
		return user;
	}

	@GetMapping
	@Operation(summary = "Get all storage items")
	public ResponseEntity<ApiResponse> getAllItems() {
		List<StorageItem> items = storageDAO.getAllItems();
		return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich abgerufen.", items));
	}

	@PostMapping
	@Operation(summary = "Create a new storage item")
	public ResponseEntity<ApiResponse> createItem(@RequestBody StorageItem item) {
		if (storageDAO.createItem(item)) {
			adminLogService.log(getSystemUser().getUsername(), "CREATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Artikel erfolgreich erstellt.", item),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Artikel konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a storage item")
	public ResponseEntity<ApiResponse> updateItem(@PathVariable int id, @RequestBody StorageItem item) {
		item.setId(id);
		if (storageDAO.updateItem(item)) {
			adminLogService.log(getSystemUser().getUsername(), "UPDATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich aktualisiert.", item));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a storage item")
	public ResponseEntity<ApiResponse> deleteItem(@PathVariable int id) {
		StorageItem item = storageDAO.getItemById(id);
		if (item != null && storageDAO.deleteItem(id)) {
			adminLogService.log(getSystemUser().getUsername(), "DELETE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\SystemResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/system")
@Tag(name = "Admin System", description = "Endpoints for retrieving system information and statistics.")
@SecurityRequirement(name = "bearerAuth")
public class SystemResource {

	private final SystemInfoService systemInfoService;

	@Autowired
	public SystemResource(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
	}

	@GetMapping("/stats")
	@Operation(summary = "Get system statistics", description = "Retrieves current system statistics like CPU load, memory usage, and disk space.")
	public ResponseEntity<ApiResponse> getSystemStats() {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		return ResponseEntity.ok(new ApiResponse(true, "Systemstatistiken erfolgreich abgerufen.", stats));
	}
}