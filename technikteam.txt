
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}
		
		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\GuiceConfig.java
========================================================================

package de.technikteam.config;

import com.google.inject.Guice;
import com.google.inject.Injector;
import com.google.inject.servlet.GuiceServletContextListener;
import jakarta.servlet.annotation.WebListener;

@WebListener
public class GuiceConfig extends GuiceServletContextListener {

	@Override
	protected Injector getInjector() {
		return Guice.createInjector(new ServiceModule());
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * A custom serializer for the Gson library. It converts java.time.LocalDate
 * objects into the standard YYYY-MM-DD string format, which is ideal for JSON
 * data exchange and compatibility with HTML date input fields.
 */
public class LocalDateAdapter implements JsonSerializer<LocalDate> {

	@Override
	public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context) {
		return date == null ? null : new JsonPrimitive(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON)
 * and deserialization (JSON to Java), preventing reflection issues with
 * the Java Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        if (value == null) {
            out.nullValue();
        } else {
            out.value(value.format(FORMATTER));
        }
    }

    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
            in.nextNull();
            return null;
        }
        String value = in.nextString();
        return LocalDateTime.parse(value, FORMATTER);
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\Permissions.java
========================================================================

package de.technikteam.config;

/**
 * A central repository for all permission key constants used throughout the
 * application. This prevents the use of "magic strings" for permission checks,
 * reducing typos and making the code more maintainable and readable.
 */
public final class Permissions {

	private Permissions() {
		// Private constructor to prevent instantiation
	}

	// --- GLOBAL ---
	public static final String ACCESS_ADMIN_PANEL = "ACCESS_ADMIN_PANEL";

	// --- USER MANAGEMENT ---
	public static final String USER_CREATE = "USER_CREATE";
	public static final String USER_READ = "USER_READ";
	public static final String USER_UPDATE = "USER_UPDATE";
	public static final String USER_DELETE = "USER_DELETE";
	public static final String USER_PASSWORD_RESET = "USER_PASSWORD_RESET";

	// --- EVENT MANAGEMENT ---
	public static final String EVENT_CREATE = "EVENT_CREATE";
	public static final String EVENT_READ = "EVENT_READ";
	public static final String EVENT_UPDATE = "EVENT_UPDATE";
	public static final String EVENT_DELETE = "EVENT_DELETE";
	public static final String EVENT_MANAGE_ASSIGNMENTS = "EVENT_MANAGE_ASSIGNMENTS";
	public static final String EVENT_MANAGE_TASKS = "EVENT_MANAGE_TASKS";

	// --- COURSE & MEETING MANAGEMENT ---
	public static final String COURSE_CREATE = "COURSE_CREATE";
	public static final String COURSE_READ = "COURSE_READ";
	public static final String COURSE_UPDATE = "COURSE_UPDATE";
	public static final String COURSE_DELETE = "COURSE_DELETE";

	// --- STORAGE & INVENTORY ---
	public static final String STORAGE_CREATE = "STORAGE_CREATE";
	public static final String STORAGE_READ = "STORAGE_READ";
	public static final String STORAGE_UPDATE = "STORAGE_UPDATE";
	public static final String STORAGE_DELETE = "STORAGE_DELETE";

	// --- KIT MANAGEMENT ---
	public static final String KIT_CREATE = "KIT_CREATE";
	public static final String KIT_READ = "KIT_READ";
	public static final String KIT_UPDATE = "KIT_UPDATE";
	public static final String KIT_DELETE = "KIT_DELETE";

	// --- QUALIFICATIONS ---
	public static final String QUALIFICATION_READ = "QUALIFICATION_READ";
	public static final String QUALIFICATION_UPDATE = "QUALIFICATION_UPDATE";

	// --- FILE MANAGEMENT ---
	public static final String FILE_CREATE = "FILE_CREATE";
	public static final String FILE_READ = "FILE_READ";
	public static final String FILE_UPDATE = "FILE_UPDATE";
	public static final String FILE_DELETE = "FILE_DELETE";
	public static final String FILE_MANAGE = "FILE_MANAGE";

	// --- SYSTEM & REPORTING ---
	public static final String LOG_READ = "LOG_READ";
	public static final String REPORT_READ = "REPORT_READ";
	public static final String SYSTEM_READ = "SYSTEM_READ";

	// --- ACHIEVEMENTS ---
	public static final String ACHIEVEMENT_CREATE = "ACHIEVEMENT_CREATE";
	public static final String ACHIEVEMENT_UPDATE = "ACHIEVEMENT_UPDATE";
	public static final String ACHIEVEMENT_DELETE = "ACHIEVEMENT_DELETE";
	public static final String ACHIEVEMENT_VIEW = "ACHIEVEMENT_VIEW"; // Special key for navigation

	// --- NAVIGATION-SPECIFIC ---
	public static final String ADMIN_DASHBOARD_ACCESS = "ADMIN_DASHBOARD_ACCESS";
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\ServiceModule.java
========================================================================

package de.technikteam.config;

import com.google.inject.Scopes;
import com.google.inject.servlet.ServletModule;
import de.technikteam.dao.*;
import de.technikteam.service.*;
import de.technikteam.servlet.*;
import de.technikteam.servlet.admin.*;
import de.technikteam.servlet.admin.action.*;
import de.technikteam.servlet.admin.api.*;
import de.technikteam.servlet.api.*;
import de.technikteam.servlet.api.passkey.*;

public class ServiceModule extends ServletModule {

	@Override
	protected void configureServlets() {
		// --- Bind Services, DAOs, and Actions (Singletons) ---
		bind(ConfigurationService.class).in(Scopes.SINGLETON);
		bind(DatabaseManager.class).in(Scopes.SINGLETON);
		bind(AuthorizationService.class).in(Scopes.SINGLETON);
		bind(AdminLogService.class).in(Scopes.SINGLETON);
		bind(UserService.class).in(Scopes.SINGLETON);
		bind(StorageService.class).in(Scopes.SINGLETON);
		bind(EventService.class).in(Scopes.SINGLETON);
		bind(PasskeyService.class).in(Scopes.SINGLETON);
		bind(SystemInfoService.class).in(Scopes.SINGLETON);
		bind(AchievementService.class).in(Scopes.SINGLETON);
		bind(AdminDashboardService.class).in(Scopes.SINGLETON);

		bind(UserDAO.class).in(Scopes.SINGLETON);
		bind(RoleDAO.class).in(Scopes.SINGLETON);
		bind(PermissionDAO.class).in(Scopes.SINGLETON);
		bind(StorageDAO.class).in(Scopes.SINGLETON);
		bind(StorageLogDAO.class).in(Scopes.SINGLETON);
		bind(EventDAO.class).in(Scopes.SINGLETON);
		bind(EventTaskDAO.class).in(Scopes.SINGLETON);
		bind(EventChatDAO.class).in(Scopes.SINGLETON);
		bind(CourseDAO.class).in(Scopes.SINGLETON);
		bind(MeetingDAO.class).in(Scopes.SINGLETON);
		bind(MeetingAttendanceDAO.class).in(Scopes.SINGLETON);
		bind(UserQualificationsDAO.class).in(Scopes.SINGLETON);
		bind(AchievementDAO.class).in(Scopes.SINGLETON);
		bind(AdminLogDAO.class).in(Scopes.SINGLETON);
		bind(AttachmentDAO.class).in(Scopes.SINGLETON);
		bind(InventoryKitDAO.class).in(Scopes.SINGLETON);
		bind(MaintenanceLogDAO.class).in(Scopes.SINGLETON);
		bind(PasskeyDAO.class).in(Scopes.SINGLETON);
		bind(ProfileChangeRequestDAO.class).in(Scopes.SINGLETON);
		bind(EventFeedbackDAO.class).in(Scopes.SINGLETON);
		bind(EventCustomFieldDAO.class).in(Scopes.SINGLETON);
		bind(FeedbackSubmissionDAO.class).in(Scopes.SINGLETON);
		bind(FileDAO.class).in(Scopes.SINGLETON);
		bind(ReportDAO.class).in(Scopes.SINGLETON);
		bind(StatisticsDAO.class).in(Scopes.SINGLETON);

		bind(CreateUserAction.class).in(Scopes.SINGLETON);
		bind(UpdateUserAction.class).in(Scopes.SINGLETON);
		bind(DeleteUserAction.class).in(Scopes.SINGLETON);
		bind(ResetPasswordAction.class).in(Scopes.SINGLETON);
		bind(UnlockUserAction.class).in(Scopes.SINGLETON);
		bind(ApproveChangeAction.class).in(Scopes.SINGLETON);
		bind(DenyChangeAction.class).in(Scopes.SINGLETON);
		bind(UpdateFeedbackStatusAction.class).in(Scopes.SINGLETON);
		bind(DeleteFeedbackAction.class).in(Scopes.SINGLETON);

		// --- Explicitly bind all Servlets as Singletons before serving them ---
		bind(RootServlet.class).in(Scopes.SINGLETON);
		bind(LoginServlet.class).in(Scopes.SINGLETON);
		bind(LogoutServlet.class).in(Scopes.SINGLETON);
		bind(HomeServlet.class).in(Scopes.SINGLETON);
		bind(ProfileServlet.class).in(Scopes.SINGLETON);
		bind(PasswordServlet.class).in(Scopes.SINGLETON);
		bind(CalendarServlet.class).in(Scopes.SINGLETON);
		bind(IcalServlet.class).in(Scopes.SINGLETON);
		bind(EventServlet.class).in(Scopes.SINGLETON);
		bind(EventDetailsServlet.class).in(Scopes.SINGLETON);
		bind(EventActionServlet.class).in(Scopes.SINGLETON);
		bind(MeetingServlet.class).in(Scopes.SINGLETON);
		bind(MeetingDetailsServlet.class).in(Scopes.SINGLETON);
		bind(MeetingActionServlet.class).in(Scopes.SINGLETON);
		bind(StorageServlet.class).in(Scopes.SINGLETON);
		bind(StorageItemDetailsServlet.class).in(Scopes.SINGLETON);
		bind(StorageItemActionServlet.class).in(Scopes.SINGLETON);
		bind(StorageTransactionServlet.class).in(Scopes.SINGLETON);
		bind(FileServlet.class).in(Scopes.SINGLETON);
		bind(FeedbackServlet.class).in(Scopes.SINGLETON);
		bind(MyFeedbackServlet.class).in(Scopes.SINGLETON);
		bind(PackKitServlet.class).in(Scopes.SINGLETON);
		bind(DownloadServlet.class).in(Scopes.SINGLETON);
		bind(ImageServlet.class).in(Scopes.SINGLETON);
		bind(MarkdownEditorServlet.class).in(Scopes.SINGLETON);
		bind(TaskActionServlet.class).in(Scopes.SINGLETON);
		bind(NotificationServlet.class).in(Scopes.SINGLETON);
		bind(CalendarApiServlet.class).in(Scopes.SINGLETON);
		bind(StorageHistoryApiServlet.class).in(Scopes.SINGLETON);
		bind(UserPreferencesApiServlet.class).in(Scopes.SINGLETON);
		bind(EventCustomFieldsApiServlet.class).in(Scopes.SINGLETON);
		bind(EventChatApiServlet.class).in(Scopes.SINGLETON);
		bind(MarkdownApiServlet.class).in(Scopes.SINGLETON);
		bind(RegistrationStartServlet.class).in(Scopes.SINGLETON);
		bind(RegistrationFinishServlet.class).in(Scopes.SINGLETON);
		bind(AuthenticationStartServlet.class).in(Scopes.SINGLETON);
		bind(AuthenticationFinishServlet.class).in(Scopes.SINGLETON);
		bind(AdminDashboardServlet.class).in(Scopes.SINGLETON);
		bind(AdminUserServlet.class).in(Scopes.SINGLETON);
		bind(AdminEventServlet.class).in(Scopes.SINGLETON);
		bind(AdminCourseServlet.class).in(Scopes.SINGLETON);
		bind(AdminMeetingServlet.class).in(Scopes.SINGLETON);
		bind(AdminAttendanceServlet.class).in(Scopes.SINGLETON);
		bind(MatrixServlet.class).in(Scopes.SINGLETON);
		bind(AdminStorageServlet.class).in(Scopes.SINGLETON);
		bind(AdminDefectServlet.class).in(Scopes.SINGLETON);
		bind(AdminKitServlet.class).in(Scopes.SINGLETON);
		bind(AdminFileManagementServlet.class).in(Scopes.SINGLETON);
		bind(AdminFileServlet.class).in(Scopes.SINGLETON);
		bind(AdminFileCategoryServlet.class).in(Scopes.SINGLETON);
		bind(AdminLogServlet.class).in(Scopes.SINGLETON);
		bind(AdminReportServlet.class).in(Scopes.SINGLETON);
		bind(AdminSystemServlet.class).in(Scopes.SINGLETON);
		bind(AdminAchievementServlet.class).in(Scopes.SINGLETON);
		bind(AdminChangeRequestServlet.class).in(Scopes.SINGLETON);
		bind(AdminFeedbackServlet.class).in(Scopes.SINGLETON);
		bind(AdminDashboardApiServlet.class).in(Scopes.SINGLETON);
		bind(SystemStatsApiServlet.class).in(Scopes.SINGLETON);
		bind(CrewFinderApiServlet.class).in(Scopes.SINGLETON);
		bind(FrontControllerServlet.class).in(Scopes.SINGLETON);

		// --- Explicitly Map all URL Patterns to their Servlets ---
		serve("").with(RootServlet.class);
		serve("/login").with(LoginServlet.class);
		serve("/logout").with(LogoutServlet.class);
		serve("/home").with(HomeServlet.class);
		serve("/profil").with(ProfileServlet.class);
		serve("/passwort").with(PasswordServlet.class);
		serve("/kalender").with(CalendarServlet.class);
		serve("/calendar.ics").with(IcalServlet.class);
		serve("/veranstaltungen").with(EventServlet.class);
		serve("/veranstaltungen/details").with(EventDetailsServlet.class);
		serve("/event-action").with(EventActionServlet.class);
		serve("/lehrgaenge").with(MeetingServlet.class);
		serve("/meetingDetails").with(MeetingDetailsServlet.class);
		serve("/meeting-action").with(MeetingActionServlet.class);
		serve("/lager").with(StorageServlet.class);
		serve("/lager/details").with(StorageItemDetailsServlet.class);
		serve("/lager/aktionen").with(StorageItemActionServlet.class);
		serve("/lager/transaktion").with(StorageTransactionServlet.class);
		serve("/dateien").with(FileServlet.class);
		serve("/feedback").with(FeedbackServlet.class);
		serve("/my-feedback").with(MyFeedbackServlet.class);
		serve("/pack-kit").with(PackKitServlet.class);
		serve("/download").with(DownloadServlet.class);
		serve("/image").with(ImageServlet.class);
		serve("/editor").with(MarkdownEditorServlet.class);
		serve("/task-action").with(TaskActionServlet.class);
		serve("/notifications").with(NotificationServlet.class);
		serve("/api/calendar/entries").with(CalendarApiServlet.class);
		serve("/api/storage-history").with(StorageHistoryApiServlet.class);
		serve("/api/user/preferences").with(UserPreferencesApiServlet.class);
		serve("/api/public/event-custom-fields").with(EventCustomFieldsApiServlet.class);
		serve("/api/event-chat").with(EventChatApiServlet.class);
		serve("/api/save-markdown").with(MarkdownApiServlet.class);
		serve("/api/auth/passkey/register/start").with(RegistrationStartServlet.class);
		serve("/api/auth/passkey/register/finish").with(RegistrationFinishServlet.class);
		serve("/api/auth/passkey/login/start").with(AuthenticationStartServlet.class);
		serve("/api/auth/passkey/login/finish").with(AuthenticationFinishServlet.class);
		serve("/admin/dashboard").with(AdminDashboardServlet.class);
		serve("/admin/mitglieder").with(AdminUserServlet.class);
		serve("/admin/veranstaltungen").with(AdminEventServlet.class);
		serve("/admin/lehrgaenge").with(AdminCourseServlet.class);
		serve("/admin/meetings").with(AdminMeetingServlet.class);
		serve("/admin/teilnahme").with(AdminAttendanceServlet.class);
		serve("/admin/matrix").with(MatrixServlet.class);
		serve("/admin/lager").with(AdminStorageServlet.class);
		serve("/admin/defekte").with(AdminDefectServlet.class);
		serve("/admin/kits").with(AdminKitServlet.class);
		serve("/admin/dateien").with(AdminFileManagementServlet.class);
		serve("/admin/uploadFile").with(AdminFileServlet.class);
		serve("/admin/dateien/kategorien/*").with(AdminFileCategoryServlet.class);
		serve("/admin/log").with(AdminLogServlet.class);
		serve("/admin/berichte").with(AdminReportServlet.class);
		serve("/admin/system").with(AdminSystemServlet.class);
		serve("/admin/achievements").with(AdminAchievementServlet.class);
		serve("/admin/requests").with(AdminChangeRequestServlet.class);
		serve("/admin/feedback").with(AdminFeedbackServlet.class);
		serve("/api/admin/dashboard-data").with(AdminDashboardApiServlet.class);
		serve("/api/admin/system-stats").with(SystemStatsApiServlet.class);
		serve("/api/admin/crew-finder").with(CrewFinderApiServlet.class);
		serve("/admin/action/*").with(FrontControllerServlet.class);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Achievement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public AchievementDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public List<Achievement> getAllAchievements() {
		List<Achievement> achievements = new ArrayList<>();
		String sql = "SELECT * FROM achievements ORDER BY name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				achievements.add(mapResultSetToAchievement(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching all achievements", e);
		}
		return achievements;
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, id);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToAchievement(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching achievement by ID {}", id, e);
		}
		return null;
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, achievement.getAchievementKey());
			pstmt.setString(2, achievement.getName());
			pstmt.setString(3, achievement.getDescription());
			pstmt.setString(4, achievement.getIconClass());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, achievement.getName());
			pstmt.setString(2, achievement.getDescription());
			pstmt.setString(3, achievement.getIconClass());
			pstmt.setInt(4, achievement.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, id);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		List<Achievement> achievements = new ArrayList<>();
		String sql = "SELECT a.id, a.achievement_key, a.name, a.description, a.icon_class, ua.earned_at "
				+ "FROM achievements a JOIN user_achievements ua ON a.id = ua.achievement_id "
				+ "WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Achievement ach = mapResultSetToAchievement(rs);
					ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
					achievements.add(ach);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching achievements for user {}", userId, e);
		}
		return achievements;
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			return false;
		}
		String sql = "INSERT INTO user_achievements (user_id, achievement_id) SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setString(2, achievementKey);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
		}
		return false;
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT 1 FROM user_achievements ua JOIN achievements a ON ua.achievement_id = a.id WHERE ua.user_id = ? AND a.achievement_key = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setString(2, achievementKey);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
		}
		return false;
	}

	private Achievement mapResultSetToAchievement(ResultSet rs) throws SQLException {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public AdminLogDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, log.getAdminUsername());
			pstmt.setString(2, log.getActionType());
			pstmt.setString(3, log.getDetails());
			pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("Failed to create admin log for user '{}'.", log.getAdminUsername(), e);
		}
	}

	public List<AdminLog> getAllLogs() {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				logs.add(logEntry);
			}
		} catch (SQLException e) {
			logger.error("Failed to fetch admin logs from the database.", e);
		}
		return logs;
	}

	public List<AdminLog> getRecentLogs(int limit) {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC LIMIT ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					AdminLog logEntry = new AdminLog();
					logEntry.setId(rs.getInt("id"));
					logEntry.setAdminUsername(rs.getString("admin_username"));
					logEntry.setActionType(rs.getString("action_type"));
					logEntry.setDetails(rs.getString("details"));
					logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
					logs.add(logEntry);
				}
			}
		} catch (SQLException e) {
			logger.error("Failed to fetch recent admin logs from the database.", e);
		}
		return logs;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public AttachmentDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	private Attachment mapResultSetToAttachment(ResultSet rs) throws SQLException {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	}

	public boolean addAttachment(Attachment attachment) {
		try (Connection conn = dbManager.getConnection()) {
			return addAttachment(attachment, conn);
		} catch (SQLException e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public boolean addAttachment(Attachment attachment, Connection conn) throws SQLException {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, attachment.getParentType());
			pstmt.setInt(2, attachment.getParentId());
			pstmt.setString(3, attachment.getFilename());
			pstmt.setString(4, attachment.getFilepath());
			pstmt.setString(5, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		List<Attachment> attachments = new ArrayList<>();
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, parentType);
			pstmt.setInt(2, parentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					attachments.add(mapResultSetToAttachment(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
		}
		return attachments;
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToAttachment(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		return null;
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Course;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public CourseDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating course: {}", course.getName(), e);
			return false;
		}
	}

	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToCourse(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching course by ID: {}", courseId, e);
		}
		return null;
	}

	public List<Course> getAllCourses() {
		List<Course> courses = new ArrayList<>();
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				courses.add(mapResultSetToCourse(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching all courses.", e);
		}
		return courses;
	}

	private Course mapResultSetToCourse(ResultSet rs) throws SQLException {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	}

	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			pstmt.setInt(4, course.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating course: {}", course.getName(), e);
			return false;
		}
	}

	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, courseId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\DatabaseManager.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import de.technikteam.service.ConfigurationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.SQLException;

@Singleton
public class DatabaseManager {

	private static final Logger logger = LogManager.getLogger(DatabaseManager.class);
	private final HikariDataSource dataSource;

	@Inject
	public DatabaseManager(ConfigurationService configService) {
		logger.info("Initializing Guice-managed Database Connection Pool...");

		try {
			HikariConfig hikariConfig = new HikariConfig();
			hikariConfig.setJdbcUrl(configService.getProperty("db.url"));
			hikariConfig.setUsername(configService.getProperty("db.user"));
			hikariConfig.setPassword(configService.getProperty("db.password"));

			hikariConfig.setMaximumPoolSize(15);
			hikariConfig.setMinimumIdle(5);
			hikariConfig.setConnectionTimeout(30000);
			hikariConfig.setIdleTimeout(600000);
			hikariConfig.setMaxLifetime(1800000);

			this.dataSource = new HikariDataSource(hikariConfig);

			logger.info("================================================================");
			logger.info("GUICE DATABASE CONNECTION POOL INITIALIZED SUCCESSFULLY.");
			logger.info("================================================================");
		} catch (Exception e) {
			logger.fatal("Failed to initialize Guice-managed database pool!", e);
			throw new RuntimeException("Could not initialize database pool", e);
		}
	}

	public Connection getConnection() throws SQLException {
		if (dataSource == null) {
			logger.error("DataSource is null. The DatabaseManager was not initialized correctly.");
			throw new SQLException("Database connection pool is not available.");
		}
		return dataSource.getConnection();
	}

	public void closeDataSource() {
		if (dataSource != null && !dataSource.isClosed()) {
			logger.info("Closing database connection pool...");
			dataSource.close();
			logger.info("Database connection pool closed successfully.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public EventChatDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setInt(1, message.getEventId());
			preparedStatement.setInt(2, message.getUserId());
			preparedStatement.setString(3, message.getUsername());
			preparedStatement.setString(4, message.getMessageText());
			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						return getMessageById(newId, connection);
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("Error posting chat message for event {}", message.getEventId(), exception);
		}
		return null;
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		List<EventChatMessage> messages = new ArrayList<>();
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					messages.add(mapRowToMessage(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching chat messages for event {}", eventId, exception);
		}
		return messages;
	}

	private EventChatMessage getMessageById(int messageId, Connection connection) throws SQLException {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, messageId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					return mapRowToMessage(resultSet);
				}
			}
		}
		return null;
	}

	private EventChatMessage mapRowToMessage(ResultSet resultSet) throws SQLException {
		EventChatMessage message = new EventChatMessage();
		message.setId(resultSet.getInt("id"));
		message.setEventId(resultSet.getInt("event_id"));
		message.setUserId(resultSet.getInt("user_id"));
		message.setUsername(resultSet.getString("username"));
		message.setMessageText(resultSet.getString("message_text"));
		message.setEdited(resultSet.getBoolean("edited"));
		message.setDeleted(resultSet.getBoolean("is_deleted"));
		message.setDeletedByUserId(resultSet.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(resultSet.getString("deleted_by_username"));
		message.setChatColor(resultSet.getString("chat_color"));
		if (resultSet.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(resultSet.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(resultSet.getTimestamp("sent_at").toLocalDateTime());
		return message;
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE WHERE id = ? AND user_id = ? AND is_deleted = FALSE";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newText);
			preparedStatement.setInt(2, messageId);
			preparedStatement.setInt(3, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating message ID {}", messageId, exception);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql = isAdmin ? "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ?"
				: "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ? AND user_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, deletersUserId);
			preparedStatement.setInt(2, messageId);
			if (!isAdmin) {
				preparedStatement.setInt(3, deletersUserId);
			}
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error soft-deleting message ID {}:", messageId, exception);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public EventCustomFieldDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields, Connection conn)
			throws SQLException {
		String deleteSql = "DELETE FROM event_custom_fields WHERE event_id = ?";
		String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
		try (PreparedStatement deleteStatement = conn.prepareStatement(deleteSql)) {
			deleteStatement.setInt(1, eventId);
			deleteStatement.executeUpdate();
		}
		if (fields != null && !fields.isEmpty()) {
			try (PreparedStatement insertStatement = conn.prepareStatement(insertSql)) {
				for (EventCustomField field : fields) {
					insertStatement.setInt(1, eventId);
					insertStatement.setString(2, field.getFieldName());
					insertStatement.setString(3, field.getFieldType());
					insertStatement.setBoolean(4, field.isRequired());
					insertStatement.setString(5, field.getFieldOptions());
					insertStatement.addBatch();
				}
				insertStatement.executeBatch();
			}
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		List<EventCustomField> fields = new ArrayList<>();
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					EventCustomField field = new EventCustomField();
					field.setId(resultSet.getInt("id"));
					field.setEventId(resultSet.getInt("event_id"));
					field.setFieldName(resultSet.getString("field_name"));
					field.setFieldType(resultSet.getString("field_type"));
					field.setRequired(resultSet.getBoolean("is_required"));
					field.setFieldOptions(resultSet.getString("field_options"));
					fields.add(field);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
		}
		return fields;
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFieldId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setString(3, response.getResponseValue());
			preparedStatement.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Event;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public EventDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	private Event mapResultSetToEvent(ResultSet resultSet) throws SQLException {
		Event event = new Event();
		event.setId(resultSet.getInt("id"));
		event.setName(resultSet.getString("name"));
		event.setDescription(resultSet.getString("description"));
		event.setLocation(resultSet.getString("location"));
		event.setStatus(resultSet.getString("status"));

		Timestamp eventTimestamp = resultSet.getTimestamp("event_datetime");
		if (eventTimestamp != null) {
			event.setEventDateTime(eventTimestamp.toLocalDateTime());
		}
		Timestamp endTimestamp = resultSet.getTimestamp("end_datetime");
		if (endTimestamp != null) {
			event.setEndDateTime(endTimestamp.toLocalDateTime());
		}

		if (DaoUtils.hasColumn(resultSet, "leader_user_id")) {
			event.setLeaderUserId(resultSet.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(resultSet, "leader_username")) {
			event.setLeaderUsername(resultSet.getString("leader_username"));
		}
		return event;
	}

	private User mapResultSetToSimpleUser(ResultSet resultSet) throws SQLException {
		return new User(resultSet.getInt("id"), resultSet.getString("username"), resultSet.getString("role"));
	}

	public List<Event> getEventHistoryForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.*, COALESCE( (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), 'OFFEN' ) AS user_status FROM events e WHERE EXISTS ( SELECT 1 FROM event_attendance WHERE event_id = e.id AND user_id = ? UNION SELECT 1 FROM event_assignments WHERE event_id = e.id AND user_id = ? ) ORDER BY e.event_datetime DESC";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, userId);
			preparedStatement.setInt(3, userId);
			preparedStatement.setInt(4, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Event event = mapResultSetToEvent(resultSet);
					event.setUserAttendanceStatus(resultSet.getString("user_status"));
					history.add(event);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching event history for user {}", userId, exception);
		}
		return history;
	}

	public Event getEventById(int eventId) {
		try (Connection connection = dbManager.getConnection()) {
			// Re-cast is safe here as the non-transactional method will handle null.
			return getEventById((Integer) eventId, connection);
		} catch (SQLException exception) {
			logger.error("SQL error fetching event by ID: {}", eventId, exception);
		}
		return null;
	}

	public Event getEventById(Integer eventId, Connection connection) throws SQLException {
		if (eventId == null || eventId <= 0)
			return null;
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id WHERE e.id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					return mapResultSetToEvent(resultSet);
				}
			}
		}
		return null;
	}

	public List<Event> getAllEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id ORDER BY e.event_datetime DESC";
		try (Connection connection = dbManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching all events.", exception);
		}
		return events;
	}

	public List<Event> getActiveEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		try (Connection connection = dbManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active events.", exception);
		}
		return events;
	}

	public int createEvent(Event event, Connection connection) throws SQLException {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, 'GEPLANT', ?)";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null)
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			else
				preparedStatement.setNull(3, Types.TIMESTAMP);
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			if (event.getLeaderUserId() > 0)
				preparedStatement.setInt(6, event.getLeaderUserId());
			else
				preparedStatement.setNull(6, Types.INTEGER);
			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next())
						return generatedKeys.getInt(1);
				}
			}
		}
		return 0;
	}

	public boolean updateEvent(Event event, Connection connection) throws SQLException {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null)
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			else
				preparedStatement.setNull(3, Types.TIMESTAMP);
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			preparedStatement.setString(6, event.getStatus());
			if (event.getLeaderUserId() > 0)
				preparedStatement.setInt(7, event.getLeaderUserId());
			else
				preparedStatement.setNull(7, Types.INTEGER);
			preparedStatement.setInt(8, event.getId());
			return preparedStatement.executeUpdate() > 0;
		}
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error deleting event with ID: {}", eventId, exception);
		}
		return false;
	}

	public boolean updateEventStatus(int eventId, String newStatus) {
		String sql = "UPDATE events SET status = ? WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newStatus);
			preparedStatement.setInt(2, eventId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error updating status for event ID: {}", eventId, exception);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-up for user {} and event {}", userId, eventId, exception);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-off for user {} and event {}", userId, eventId, exception);
		}
	}

	public List<User> getSignedUpUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name as role FROM users u JOIN event_attendance ea ON u.id = ea.user_id LEFT JOIN roles r on u.role_id = r.id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next())
					users.add(mapResultSetToSimpleUser(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching signed-up users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		String deleteSql = "DELETE FROM event_assignments WHERE event_id = ?";
		String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
		try (Connection connection = dbManager.getConnection()) {
			connection.setAutoCommit(false);
			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (String userId : userIds) {
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(userId));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}
			connection.commit();
		} catch (SQLException | NumberFormatException exception) {
			logger.error("SQL transaction error during user assignment for event ID: {}.", eventId, exception);
		}
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		List<SkillRequirement> requirements = new ArrayList<>();
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					SkillRequirement requirement = new SkillRequirement();
					requirement.setRequiredCourseId(resultSet.getInt("required_course_id"));
					requirement.setCourseName(resultSet.getString("course_name"));
					requirement.setRequiredPersons(resultSet.getInt("required_persons"));
					requirements.add(requirement);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching skill requirements for event ID: {}", eventId, exception);
		}
		return requirements;
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons,
			Connection connection) throws SQLException {
		String deleteSql = "DELETE FROM event_skill_requirements WHERE event_id = ?";
		String insertSql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
		try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
			deleteStatement.setInt(1, eventId);
			deleteStatement.executeUpdate();
		}
		if (requiredCourseIds != null && requiredPersons != null
				&& requiredCourseIds.length == requiredPersons.length) {
			try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
				for (int i = 0; i < requiredCourseIds.length; i++) {
					if (requiredCourseIds[i] == null || requiredCourseIds[i].isEmpty())
						continue;
					insertStatement.setInt(1, eventId);
					insertStatement.setInt(2, Integer.parseInt(requiredCourseIds[i]));
					insertStatement.setInt(3, Integer.parseInt(requiredPersons[i]));
					insertStatement.addBatch();
				}
				insertStatement.executeBatch();
			}
		}
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities, Connection connection)
			throws SQLException {
		String deleteSql = "DELETE FROM event_storage_reservations WHERE event_id = ?";
		String insertSql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";
		try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
			deleteStatement.setInt(1, eventId);
			deleteStatement.executeUpdate();
		}
		if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
			try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
				for (int i = 0; i < itemIds.length; i++) {
					if (itemIds[i] == null || itemIds[i].isEmpty())
						continue;
					insertStatement.setInt(1, eventId);
					insertStatement.setInt(2, Integer.parseInt(itemIds[i]));
					insertStatement.setInt(3, Integer.parseInt(quantities[i]));
					insertStatement.addBatch();
				}
				insertStatement.executeBatch();
			}
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					StorageItem item = new StorageItem();
					item.setId(resultSet.getInt("id"));
					item.setName(resultSet.getString("name"));
					item.setQuantity(resultSet.getInt("reserved_quantity"));
					items.add(item);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching reserved items for event ID: {}", eventId, exception);
		}
		return items;
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status NOT IN ('ABGESCHLOSSEN', 'ABGESAGT') AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		try (Connection connection = dbManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active/upcoming events for calendar.", exception);
		}
		return events;
	}

	public List<Event> getUpcomingEventsForUser(User user, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, CASE WHEN eas.user_id IS NOT NULL THEN 'ZUGEWIESEN' WHEN ea.signup_status IS NOT NULL THEN ea.signup_status ELSE 'OFFEN' END AS calculated_user_status FROM events e LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.user_id = ? LEFT JOIN event_assignments eas ON e.id = eas.event_id AND eas.user_id = ? WHERE e.event_datetime >= NOW() AND ( NOT EXISTS (SELECT 1 FROM event_skill_requirements esr WHERE esr.event_id = e.id) OR EXISTS (SELECT 1 FROM event_skill_requirements esr JOIN user_qualifications uq ON esr.required_course_id = uq.course_id WHERE esr.event_id = e.id AND uq.user_id = ? AND uq.status = 'ABSOLVIERT') ) ORDER BY e.event_datetime ASC"
				+ (limit > 0 ? " LIMIT ?" : "");
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, user.getId());
			preparedStatement.setInt(2, user.getId());
			preparedStatement.setInt(3, user.getId());
			if (limit > 0) {
				preparedStatement.setInt(4, limit);
			}
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Event event = mapResultSetToEvent(resultSet);
					event.setUserAttendanceStatus(resultSet.getString("calculated_user_status"));
					events.add(event);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching qualified upcoming events for user {}", user.getId(), exception);
		}
		return events;
	}

	public boolean isUserAssociatedWithEvent(int eventId, int userId) {
		String sql = "SELECT 1 FROM event_attendance WHERE event_id = ? AND user_id = ? AND signup_status = 'ANGEMELDET' UNION SELECT 1 FROM event_assignments WHERE event_id = ? AND user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, eventId);
			pstmt.setInt(4, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user association for event {} and user {}", eventId, userId, e);
			return false;
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u JOIN event_assignments ea ON u.id = ea.user_id LEFT JOIN roles r ON u.role_id = r.id WHERE ea.event_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					users.add(mapResultSetToSimpleUser(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching assigned users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' ORDER BY e.event_datetime DESC";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					history.add(mapResultSetToEvent(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching completed event history for user {}", userId, exception);
		}
		return history;
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.event_datetime >= NOW() ORDER BY e.event_datetime ASC";
		if (limit > 0)
			sql += " LIMIT ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			if (limit > 0)
				preparedStatement.setInt(2, limit);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					events.add(mapResultSetToEvent(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching assigned events for user {}", userId, exception);
		}
		return events;
	}

	public List<User> getQualifiedAndAvailableUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE (SELECT COUNT(*) FROM event_skill_requirements WHERE event_id = ?) = (SELECT COUNT(*) FROM user_qualifications uq JOIN event_skill_requirements esr ON uq.course_id = esr.required_course_id WHERE esr.event_id = ? AND uq.user_id = u.id AND uq.status = 'ABSOLVIERT') AND u.id NOT IN ( SELECT ea.user_id FROM event_assignments ea JOIN events conflicting_event ON ea.event_id = conflicting_event.id JOIN events target_event ON target_event.id = ? WHERE conflicting_event.id != target_event.id AND conflicting_event.event_datetime < COALESCE(target_event.end_datetime, target_event.event_datetime + INTERVAL 2 HOUR) AND COALESCE(conflicting_event.end_datetime, conflicting_event.event_datetime + INTERVAL 2 HOUR) > target_event.event_datetime ) ORDER BY u.username ASC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					users.add(mapResultSetToSimpleUser(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error finding qualified and available users for event ID {}", eventId, e);
		}
		return users;
	}

	public List<Event> getUpcomingEvents(int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE event_datetime > NOW() ORDER BY event_datetime ASC LIMIT ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					events.add(mapResultSetToEvent(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching upcoming events with limit {}", limit, e);
		}
		return events;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventFeedbackDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EventFeedbackDAO {
	private static final Logger logger = LogManager.getLogger(EventFeedbackDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public EventFeedbackDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setInt(1, form.getEventId());
			preparedStatement.setString(2, form.getTitle());
			int affectedRows = preparedStatement.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
					if (resultSet.next()) {
						return resultSet.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
		}
		return 0;
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFormId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setInt(3, response.getRating());
			preparedStatement.setString(4, response.getComments());
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
		}
		return false;
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					FeedbackForm form = new FeedbackForm();
					form.setId(resultSet.getInt("id"));
					form.setEventId(resultSet.getInt("event_id"));
					form.setTitle(resultSet.getString("title"));
					form.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
					return form;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
		}
		return null;
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		List<FeedbackResponse> responses = new ArrayList<>();
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					FeedbackResponse response = new FeedbackResponse();
					response.setId(resultSet.getInt("id"));
					response.setFormId(resultSet.getInt("form_id"));
					response.setUserId(resultSet.getInt("user_id"));
					response.setUsername(resultSet.getString("username"));
					response.setRating(resultSet.getInt("rating"));
					response.setComments(resultSet.getString("comments"));
					response.setSubmittedAt(resultSet.getTimestamp("submitted_at").toLocalDateTime());
					responses.add(response);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
		}
		return responses;
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT 1 FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			preparedStatement.setInt(2, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				return resultSet.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user feedback submission status.", e);
		}
		return false;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public EventTaskDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds) {
		boolean isUpdate = task.getId() > 0;
		String taskSql = isUpdate
				? "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?"
				: "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";
		Connection conn = null;
		try {
			conn = dbManager.getConnection();
			conn.setAutoCommit(false);
			try {
				try (PreparedStatement pstmt = conn.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS)) {
					if (isUpdate) {
						setUpdateTaskStatementParams(pstmt, task);
					} else {
						setCreateTaskStatementParams(pstmt, task);
					}
					pstmt.executeUpdate();
					if (!isUpdate) {
						try (ResultSet rs = pstmt.getGeneratedKeys()) {
							if (rs.next()) {
								task.setId(rs.getInt(1));
							}
						}
					}
				}
				int taskId = task.getId();
				if (taskId == 0)
					throw new SQLException("Failed to create or find task ID.");

				clearAssociations(conn, taskId);
				saveUserAssignments(conn, taskId, userIds);
				saveItemRequirements(conn, taskId, itemIds, itemQuantities);
				saveKitRequirements(conn, taskId, kitIds);

				conn.commit();
				logger.info("Successfully saved task ID {}", taskId);
				return taskId;
			} catch (Exception e) {
				conn.rollback();
				logger.error("Error in task transaction. Rolling back.", e);
				return 0;
			}
		} catch (SQLException e) {
			logger.error("Failed to get DB connection for task transaction.", e);
			return 0;
		} finally {
			if (conn != null)
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
		}
	}

	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, u.id as user_id, u.username, si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, ik.id as kit_id, ik.name as kit_name FROM event_tasks t LEFT JOIN event_task_assignments ta ON t.id = ta.task_id LEFT JOIN users u ON ta.user_id = u.id LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id LEFT JOIN storage_items si ON tsi.item_id = si.id LEFT JOIN event_task_kits tk ON t.id = tk.task_id LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id WHERE t.event_id = ? ORDER BY t.display_order ASC, t.id ASC, u.username, si.name, ik.name";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					int currentTaskId = rs.getInt("id");
					EventTask task = tasksById.get(currentTaskId);
					if (task == null) {
						task = mapResultSetToTask(rs);
						tasksById.put(currentTaskId, task);
					}

					// CORRECTED: Perform checks outside of the lambda to avoid checked exception
					// issues.
					int currentUserId = rs.getInt("user_id");
					if (currentUserId > 0
							&& task.getAssignedUsers().stream().noneMatch(u -> u.getId() == currentUserId)) {
						User user = new User();
						user.setId(currentUserId);
						user.setUsername(rs.getString("username"));
						task.getAssignedUsers().add(user);
					}

					int currentItemId = rs.getInt("item_id");
					if (currentItemId > 0
							&& task.getRequiredItems().stream().noneMatch(i -> i.getId() == currentItemId)) {
						StorageItem item = new StorageItem();
						item.setId(currentItemId);
						item.setName(rs.getString("item_name"));
						item.setQuantity(rs.getInt("item_quantity"));
						task.getRequiredItems().add(item);
					}

					int currentKitId = rs.getInt("kit_id");
					if (currentKitId > 0 && task.getRequiredKits().stream().noneMatch(k -> k.getId() == currentKitId)) {
						InventoryKit kit = new InventoryKit();
						kit.setId(currentKitId);
						kit.setName(rs.getString("kit_name"));
						task.getRequiredKits().add(kit);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching tasks for event {}", eventId, e);
		}
		return new ArrayList<>(tasksById.values());
	}

	public EventTask getTaskById(int taskId) {
		String sql = "SELECT * FROM event_tasks WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToTask(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching task by ID {}", taskId, e);
		}
		return null;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting task {}", taskId, e);
			return false;
		}
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for task {}", taskId, e);
			return false;
		}
	}

	public boolean claimTask(int taskId, int userId) {
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) SELECT ?, ? FROM event_tasks WHERE id = ? AND required_persons > (SELECT COUNT(*) FROM event_task_assignments WHERE task_id = ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, taskId);
			pstmt.setInt(4, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			if (e.getErrorCode() == 1062) {
				return true;
			}
			logger.error("Error claiming task {} for user {}", taskId, userId, e);
			return false;
		}
	}

	public boolean unclaimTask(int taskId, int userId) {
		String sql = "DELETE FROM event_task_assignments WHERE task_id = ? AND user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error unclaiming task {} for user {}", taskId, userId, e);
			return false;
		}
	}

	public boolean isUserAssignedToTask(int taskId, int userId) {
		String sql = "SELECT 1 FROM event_task_assignments WHERE task_id = ? AND user_id = ? LIMIT 1";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user assignment for task {} and user {}", taskId, userId, e);
			return false;
		}
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		List<EventTask> tasks = new ArrayList<>();
		String sql = "SELECT t.*, e.name as event_name FROM event_tasks t JOIN event_task_assignments ta ON t.id = ta.task_id JOIN events e ON t.event_id = e.id WHERE ta.user_id = ? AND t.status = 'OFFEN' ORDER BY e.event_datetime ASC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setEventName(rs.getString("event_name"));
					tasks.add(task);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching open tasks for user {}", userId, e);
		}
		return tasks;
	}

	private EventTask mapResultSetToTask(ResultSet rs) throws SQLException {
		EventTask task = new EventTask();
		task.setId(rs.getInt("id"));
		task.setEventId(rs.getInt("event_id"));
		task.setDescription(rs.getString("description"));
		task.setDetails(rs.getString("details"));
		task.setStatus(rs.getString("status"));
		task.setDisplayOrder(rs.getInt("display_order"));
		task.setRequiredPersons(rs.getInt("required_persons"));
		task.setAssignedUsers(new ArrayList<>());
		task.setRequiredItems(new ArrayList<>());
		task.setRequiredKits(new ArrayList<>());
		return task;
	}

	private void setCreateTaskStatementParams(PreparedStatement pstmt, EventTask task) throws SQLException {
		pstmt.setInt(1, task.getEventId());
		pstmt.setString(2, task.getDescription());
		pstmt.setString(3, task.getDetails());
		pstmt.setInt(4, task.getDisplayOrder());
		pstmt.setInt(5, task.getRequiredPersons());
	}

	private void setUpdateTaskStatementParams(PreparedStatement pstmt, EventTask task) throws SQLException {
		pstmt.setString(1, task.getDescription());
		pstmt.setString(2, task.getDetails());
		pstmt.setString(3, task.getStatus());
		pstmt.setInt(4, task.getDisplayOrder());
		pstmt.setInt(5, task.getRequiredPersons());
		pstmt.setInt(6, task.getId());
	}

	private void clearAssociations(Connection conn, int taskId) throws SQLException {
		try (PreparedStatement userStmt = conn.prepareStatement("DELETE FROM event_task_assignments WHERE task_id = ?");
				PreparedStatement itemStmt = conn
						.prepareStatement("DELETE FROM event_task_storage_items WHERE task_id = ?");
				PreparedStatement kitStmt = conn.prepareStatement("DELETE FROM event_task_kits WHERE task_id = ?")) {
			userStmt.setInt(1, taskId);
			userStmt.executeUpdate();
			itemStmt.setInt(1, taskId);
			itemStmt.executeUpdate();
			kitStmt.setInt(1, taskId);
			kitStmt.executeUpdate();
		}
	}

	private void saveUserAssignments(Connection conn, int taskId, int[] userIds) throws SQLException {
		if (userIds == null || userIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (int userId : userIds) {
				pstmt.setInt(1, taskId);
				pstmt.setInt(2, userId);
				pstmt.addBatch();
			}
			pstmt.executeBatch();
		}
	}

	private void saveItemRequirements(Connection conn, int taskId, String[] itemIds, String[] itemQuantities)
			throws SQLException, NumberFormatException {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;
		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (int i = 0; i < itemIds.length; i++) {
				if (itemIds[i] != null && !itemIds[i].isEmpty()) {
					pstmt.setInt(1, taskId);
					pstmt.setInt(2, Integer.parseInt(itemIds[i]));
					pstmt.setInt(3, Integer.parseInt(itemQuantities[i]));
					pstmt.addBatch();
				}
			}
			pstmt.executeBatch();
		}
	}

	private void saveKitRequirements(Connection conn, int taskId, String[] kitIds)
			throws SQLException, NumberFormatException {
		if (kitIds == null || kitIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (String kitId : kitIds) {
				if (kitId != null && !kitId.isEmpty()) {
					pstmt.setInt(1, taskId);
					pstmt.setInt(2, Integer.parseInt(kitId));
					pstmt.addBatch();
				}
			}
			pstmt.executeBatch();
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FeedbackSubmissionDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.FeedbackSubmission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class FeedbackSubmissionDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackSubmissionDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public FeedbackSubmissionDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean createSubmission(FeedbackSubmission submission) {
		String sql = "INSERT INTO feedback_submissions (user_id, subject, content) VALUES (?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, submission.getUserId());
			pstmt.setString(2, submission.getSubject());
			pstmt.setString(3, submission.getContent());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating feedback submission for user {}", submission.getUserId(), e);
			return false;
		}
	}

	public List<FeedbackSubmission> getAllSubmissions() {
		List<FeedbackSubmission> submissions = new ArrayList<>();
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id ORDER BY FIELD(fs.status, 'NEW', 'VIEWED', 'PLANNED', 'COMPLETED', 'REJECTED'), fs.submitted_at DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				submissions.add(mapResultSetToSubmission(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching all feedback submissions", e);
		}
		return submissions;
	}

	public List<FeedbackSubmission> getSubmissionsByUserId(int userId) {
		List<FeedbackSubmission> submissions = new ArrayList<>();
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.user_id = ? ORDER BY fs.submitted_at DESC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					submissions.add(mapResultSetToSubmission(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching feedback submissions for user {}", userId, e);
		}
		return submissions;
	}

	public boolean updateStatus(int submissionId, String newStatus) {
		String sql = "UPDATE feedback_submissions SET status = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newStatus);
			pstmt.setInt(2, submissionId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for submission {}", submissionId, e);
			return false;
		}
	}

	public boolean deleteSubmission(int submissionId) {
		String sql = "DELETE FROM feedback_submissions WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, submissionId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting submission {}", submissionId, e);
			return false;
		}
	}

	private FeedbackSubmission mapResultSetToSubmission(ResultSet rs) throws SQLException {
		FeedbackSubmission sub = new FeedbackSubmission();
		sub.setId(rs.getInt("id"));
		sub.setUserId(rs.getInt("user_id"));
		sub.setUsername(rs.getString("username"));
		sub.setSubject(rs.getString("subject"));
		sub.setContent(rs.getString("content"));
		sub.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		sub.setStatus(rs.getString("status"));
		return sub;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);
	private final DatabaseManager dbManager;
	private final ConfigurationService configService;

	@Inject
	public FileDAO(DatabaseManager dbManager, ConfigurationService configService) {
		this.dbManager = dbManager;
		this.configService = configService;
	}

	private File mapResultSetToFile(ResultSet rs) throws SQLException {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));

		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}

		if (DaoUtils.hasColumn(rs, "category_name")) {
			String categoryName = rs.getString("category_name");
			file.setCategoryName(categoryName == null ? "Ohne Kategorie" : categoryName);
		} else {
			file.setCategoryName("Ohne Kategorie");
		}
		return file;
	}

	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		Map<Integer, String> categoryIdToNameMap = new HashMap<>();
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT id, name FROM file_categories")) {
			while (rs.next()) {
				categoryIdToNameMap.put(rs.getInt("id"), rs.getString("name"));
			}
		} catch (SQLException e) {
			logger.error("Could not fetch file categories for grouping.", e);
			return new HashMap<>();
		}

		List<File> files = new ArrayList<>();
		String sql = "SELECT * FROM files ";
		if (!user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			sql += "WHERE required_role = 'NUTZER' ";
		}
		sql += "ORDER BY filename";

		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				File file = new File();
				file.setId(rs.getInt("id"));
				file.setFilename(rs.getString("filename"));
				file.setFilepath(rs.getString("filepath"));
				file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
				file.setRequiredRole(rs.getString("required_role"));
				int categoryId = rs.getInt("category_id");
				file.setCategoryId(categoryId);
				String categoryName = categoryIdToNameMap.get(categoryId);
				file.setCategoryName(categoryName != null ? categoryName : "Ohne Kategorie");
				files.add(file);
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching files.", e);
		}
		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	public String getDocumentContentByPath(String filepath) {
		try {
			java.io.File physicalFile = new java.io.File(configService.getProperty("upload.directory"), filepath);
			return new String(Files.readAllBytes(physicalFile.toPath()), StandardCharsets.UTF_8);
		} catch (NoSuchFileException e) {
			logger.error("Physical file is missing at path: {}", filepath);
		} catch (IOException e) {
			logger.error("Could not read file content for path {}", filepath, e);
		}
		return "";
	}

	public boolean createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			if (file.getCategoryId() > 0) {
				pstmt.setInt(3, file.getCategoryId());
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setString(4, file.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file record for '{}'", file.getFilename(), e);
			return false;
		}
	}

	public boolean updateFileContent(String filepath, String content) {
		try {
			java.io.File targetFile = new java.io.File(configService.getProperty("upload.directory"), filepath);
			Files.write(targetFile.toPath(), content.getBytes(StandardCharsets.UTF_8));
			return true;
		} catch (IOException e) {
			logger.error("Failed to write updated content to file at path: {}", filepath, e);
			return false;
		}
	}

	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	public List<FileCategory> getAllCategories() {
		List<FileCategory> categories = new ArrayList<>();
		String sql = "SELECT * FROM file_categories ORDER BY name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				categories.add(cat);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching file categories.", e);
		}
		return categories;
	}

	public File getFileById(int fileId) {
		String sql = "SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id WHERE f.id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToFile(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching file with ID: {}", fileId, e);
		}
		return null;
	}

	public boolean deleteFile(int fileId) {
		File dbFile = getFileById(fileId);
		if (dbFile == null) {
			return false;
		}
		String sql = "DELETE FROM files WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				try {
					java.io.File physicalFile = new java.io.File(configService.getProperty("upload.directory"),
							dbFile.getFilepath());
					Files.deleteIfExists(physicalFile.toPath());
				} catch (IOException e) {
					logger.error("Error deleting physical file for ID: {}", fileId, e);
				}
				return true;
			} else {
				return false;
			}
		} catch (SQLException e) {
			logger.error("SQL error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	public boolean createCategory(String categoryName) {
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, categoryName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLIntegrityConstraintViolationException e) {
			logger.warn("Attempted to create a duplicate file category: '{}'", categoryName);
			return false;
		} catch (SQLException e) {
			logger.error("SQL error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	public boolean updateCategory(int categoryId, String newName) {
		String sql = "UPDATE file_categories SET name = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newName);
			pstmt.setInt(2, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating category ID {}", categoryId, e);
			return false;
		}
	}

	public boolean deleteCategory(int categoryId) {
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("name");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
		}
		return null;
	}

	public String getDocumentContent(String documentName) {
		String sql = "SELECT content FROM shared_documents WHERE document_name = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("content");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching document content for name: {}", documentName, e);
		}
		return "";
	}

	public boolean updateDocumentContent(String documentName, String content) {
		String sql = "INSERT INTO shared_documents (document_name, content) VALUES (?, ?) ON DUPLICATE KEY UPDATE content = VALUES(content)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			pstmt.setString(2, content);
			return pstmt.executeUpdate() >= 0;
		} catch (SQLException e) {
			logger.error("Error upserting document content for name: {}", documentName, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public InventoryKitDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try (Connection conn = dbManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			pstmt.setString(3, kit.getLocation());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						return rs.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
		}
		return 0;
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			pstmt.setString(3, kit.getLocation());
			pstmt.setInt(4, kit.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	private InventoryKit mapResultSetToKit(ResultSet rs) throws SQLException {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>());
		return kit;
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToKit(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
		}
		return null;
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, ki.item_id, ki.quantity, si.name as item_name FROM inventory_kits k LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id LEFT JOIN storage_items si ON ki.item_id = si.id ORDER BY k.name, si.name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				int kitId = rs.getInt("id");
				InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
					try {
						return mapResultSetToKit(rs);
					} catch (SQLException e) {
						throw new RuntimeException(e);
					}
				});
				if (rs.getInt("item_id") > 0) {
					InventoryKitItem item = new InventoryKitItem();
					item.setKitId(kitId);
					item.setItemId(rs.getInt("item_id"));
					item.setQuantity(rs.getInt("quantity"));
					item.setItemName(rs.getString("item_name"));
					kit.getItems().add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching all kits with their items", e);
		}
		return new ArrayList<>(kitMap.values());
	}

	public List<InventoryKitItem> getItemsForKit(int kitId) {
		List<InventoryKitItem> items = new ArrayList<>();
		String sql = "SELECT iki.*, si.name as item_name FROM inventory_kit_items iki JOIN storage_items si ON iki.item_id = si.id WHERE iki.kit_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					InventoryKitItem item = new InventoryKitItem();
					item.setKitId(rs.getInt("kit_id"));
					item.setItemId(rs.getInt("item_id"));
					item.setQuantity(rs.getInt("quantity"));
					item.setItemName(rs.getString("item_name"));
					items.add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching items for kit ID {}", kitId, e);
		}
		return items;
	}

	public boolean updateKitItems(int kitId, String[] itemIds, String[] quantities) {
		String deleteSql = "DELETE FROM inventory_kit_items WHERE kit_id = ?";
		String insertSql = "INSERT INTO inventory_kit_items (kit_id, item_id, quantity) VALUES (?, ?, ?)";
		try (Connection conn = dbManager.getConnection()) {
			conn.setAutoCommit(false);
			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, kitId);
				deleteStmt.executeUpdate();
			}
			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (int i = 0; i < itemIds.length; i++) {
						if (itemIds[i] == null || itemIds[i].isEmpty())
							continue;
						int itemId = Integer.parseInt(itemIds[i]);
						int quantity = Integer.parseInt(quantities[i]);
						if (quantity > 0) {
							insertStmt.setInt(1, kitId);
							insertStmt.setInt(2, itemId);
							insertStmt.setInt(3, quantity);
							insertStmt.addBatch();
						}
					}
					insertStmt.executeBatch();
				}
			}
			conn.commit();
			return true;
		} catch (SQLException | NumberFormatException e) {
			logger.error("Error during transaction for updating kit items for kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKits() {
		List<InventoryKit> kits = new ArrayList<>();
		String sql = "SELECT * FROM inventory_kits ORDER BY name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				kits.add(mapResultSetToKit(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching all inventory kits", e);
		}
		return kits;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public MaintenanceLogDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, log.getItemId());
			pstmt.setInt(2, log.getUserId());
			pstmt.setString(3, log.getAction());
			pstmt.setString(4, log.getNotes());
			pstmt.setDouble(5, log.getCost());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		List<MaintenanceLogEntry> history = new ArrayList<>();
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml JOIN users u ON ml.user_id = u.id WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MaintenanceLogEntry entry = new MaintenanceLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
					entry.setAction(rs.getString("action"));
					entry.setNotes(rs.getString("notes"));
					entry.setCost(rs.getDouble("cost"));
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
		}
		return history;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public MeetingAttendanceDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setInt(2, meetingId);
			pstmt.setBoolean(3, attended);
			pstmt.setString(4, remarks);
			pstmt.executeUpdate();
			return true;
		} catch (SQLException e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	public List<MeetingAttendance> getAllAttendance() {
		List<MeetingAttendance> allAttendance = new ArrayList<>();
		String sql = "SELECT * FROM meeting_attendance";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				allAttendance.add(mapResultSetToAttendance(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching all attendance records.", e);
		}
		return allAttendance;
	}

	private MeetingAttendance mapResultSetToAttendance(ResultSet rs) throws SQLException {
		MeetingAttendance attendance = new MeetingAttendance();
		attendance.setUserId(rs.getInt("user_id"));
		attendance.setMeetingId(rs.getInt("meeting_id"));
		attendance.setAttended(rs.getBoolean("attended"));
		attendance.setRemarks(rs.getString("remarks"));
		return attendance;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public MeetingDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		try (Connection conn = dbManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setInt(1, meeting.getCourseId());
			pstmt.setString(2, meeting.getName());
			pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null)
				pstmt.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
			else
				pstmt.setNull(4, Types.TIMESTAMP);
			if (meeting.getLeaderUserId() > 0)
				pstmt.setInt(5, meeting.getLeaderUserId());
			else
				pstmt.setNull(5, Types.INTEGER);
			pstmt.setString(6, meeting.getDescription());
			pstmt.setString(7, meeting.getLocation());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next())
						return rs.getInt(1);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating meeting: {}", meeting.getName(), e);
		}
		return 0;
	}

	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next())
					return mapResultSetToMeeting(rs);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meeting by ID: {}", meetingId, e);
		}
		return null;
	}

	public List<Meeting> getMeetingsForCourse(int courseId) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next())
					meetings.add(mapResultSetToMeeting(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meetings for course ID: {}", courseId, e);
		}
		return meetings;
	}

	public List<Meeting> getAllMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id ORDER BY m.meeting_datetime DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next())
				meetings.add(mapResultSetToMeeting(rs));
		} catch (SQLException e) {
			logger.error("SQL error fetching all meetings.", e);
		}
		return meetings;
	}

	private Meeting mapResultSetToMeeting(ResultSet rs) throws SQLException {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null)
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));
		return meeting;
	}

	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, meeting.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null)
				pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getEndDateTime()));
			else
				pstmt.setNull(3, Types.TIMESTAMP);
			if (meeting.getLeaderUserId() > 0)
				pstmt.setInt(4, meeting.getLeaderUserId());
			else
				pstmt.setNull(4, Types.INTEGER);
			pstmt.setString(5, meeting.getDescription());
			pstmt.setString(6, meeting.getLocation());
			pstmt.setInt(7, meeting.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, user.getId());
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Meeting meeting = mapResultSetToMeeting(rs);
					if (rs.getObject("attended") != null) {
						meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
					} else {
						meeting.setUserAttendanceStatus("OFFEN");
					}
					meetings.add(meeting);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for user {}", user.getId(), e);
		}
		return meetings;
	}

	public List<Meeting> getAllUpcomingMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username FROM meetings m JOIN courses c ON m.course_id = c.id LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for calendar.", e);
		}
		return meetings;
	}

	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
		String sql = "SELECT 1 FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			pstmt.setInt(2, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\PasskeyDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.PasskeyCredential;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Singleton
public class PasskeyDAO {
	private static final Logger logger = LogManager.getLogger(PasskeyDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public PasskeyDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean saveCredential(PasskeyCredential credential) {
		String sql = "INSERT INTO user_passkeys (user_id, name, user_handle, credential_id, public_key, signature_count) VALUES (?, ?, ?, ?, ?, ?)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, credential.getUserId());
			pstmt.setString(2, credential.getName());
			pstmt.setString(3, credential.getUserHandle());
			pstmt.setString(4, credential.getCredentialId());
			pstmt.setString(5, credential.getPublicKey());
			pstmt.setLong(6, credential.getSignatureCount());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error saving passkey credential for user {}", credential.getUserId(), e);
			return false;
		}
	}

	public List<PasskeyCredential> getCredentialsByUserId(int userId) {
		List<PasskeyCredential> credentials = new ArrayList<>();
		String sql = "SELECT * FROM user_passkeys WHERE user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					credentials.add(mapResultSetToCredential(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error retrieving passkey credentials for user {}", userId, e);
		}
		return credentials;
	}

	public Optional<PasskeyCredential> getCredentialById(String credentialId) {
		String sql = "SELECT * FROM user_passkeys WHERE credential_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, credentialId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return Optional.of(mapResultSetToCredential(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error retrieving credential by ID", e);
		}
		return Optional.empty();
	}

	public boolean deleteCredential(int credentialDbId, int userId) {
		String sql = "DELETE FROM user_passkeys WHERE id = ? AND user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, credentialDbId);
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting credential ID {} for user {}", credentialDbId, userId, e);
			return false;
		}
	}

	public boolean updateSignatureCount(String credentialId, long newSignatureCount) {
		String sql = "UPDATE user_passkeys SET signature_count = ? WHERE credential_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setLong(1, newSignatureCount);
			pstmt.setString(2, credentialId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating signature count for credential", e);
			return false;
		}
	}

	private PasskeyCredential mapResultSetToCredential(ResultSet rs) throws SQLException {
		return new PasskeyCredential(rs.getInt("id"), rs.getInt("user_id"), rs.getString("name"),
				rs.getString("user_handle"), rs.getString("credential_id"), rs.getString("public_key"),
				rs.getLong("signature_count"), rs.getTimestamp("created_at").toLocalDateTime());
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Singleton
public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public PermissionDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public List<Permission> getAllPermissions() {
		List<Permission> permissions = new ArrayList<>();
		String sql = "SELECT * FROM permissions ORDER BY description";
		try (Connection conn = dbManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			while (rs.next()) {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				permissions.add(p);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all permissions", e);
		}
		return permissions;
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		Set<Integer> permissionIds = new HashSet<>();
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					permissionIds.add(rs.getInt("permission_id"));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
		}
		return permissionIds;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\ProfileChangeRequestDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.ProfileChangeRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class ProfileChangeRequestDAO {
	private static final Logger logger = LogManager.getLogger(ProfileChangeRequestDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public ProfileChangeRequestDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean createRequest(ProfileChangeRequest request) {
		String sql = "INSERT INTO profile_change_requests (user_id, requested_changes, status) VALUES (?, ?, 'PENDING')";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, request.getUserId());
			pstmt.setString(2, request.getRequestedChanges());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating profile change request for user {}", request.getUserId(), e);
			return false;
		}
	}

	public ProfileChangeRequest getRequestById(int id) {
		String sql = "SELECT pcr.*, u.username as username, a.username as admin_username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id LEFT JOIN users a ON pcr.reviewed_by_admin_id = a.id WHERE pcr.id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, id);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToRequest(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching request by ID {}", id, e);
		}
		return null;
	}

	public List<ProfileChangeRequest> getPendingRequests() {
		List<ProfileChangeRequest> requests = new ArrayList<>();
		String sql = "SELECT pcr.*, u.username as username FROM profile_change_requests pcr JOIN users u ON pcr.user_id = u.id WHERE pcr.status = 'PENDING' ORDER BY pcr.requested_at ASC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				requests.add(mapResultSetToRequest(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching pending requests", e);
		}
		return requests;
	}

	public boolean hasPendingRequest(int userId) {
		String sql = "SELECT 1 FROM profile_change_requests WHERE user_id = ? AND status = 'PENDING'";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking for pending request for user {}", userId, e);
			return false;
		}
	}

	public boolean updateRequestStatus(int requestId, String status, int adminId) {
		String sql = "UPDATE profile_change_requests SET status = ?, reviewed_by_admin_id = ?, reviewed_at = NOW() WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, adminId);
			pstmt.setInt(3, requestId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for request {}", requestId, e);
			return false;
		}
	}

	private ProfileChangeRequest mapResultSetToRequest(ResultSet rs) throws SQLException {
		ProfileChangeRequest request = new ProfileChangeRequest();
		request.setId(rs.getInt("id"));
		request.setUserId(rs.getInt("user_id"));
		request.setRequestedChanges(rs.getString("requested_changes"));
		request.setStatus(rs.getString("status"));
		request.setRequestedAt(rs.getTimestamp("requested_at").toLocalDateTime());
		if (rs.getObject("reviewed_by_admin_id") != null) {
			request.setReviewedByAdminId(rs.getInt("reviewed_by_admin_id"));
		}
		if (rs.getTimestamp("reviewed_at") != null) {
			request.setReviewedAt(rs.getTimestamp("reviewed_at").toLocalDateTime());
		}
		if (rs.getMetaData().getColumnCount() > 7) {
			request.setUsername(rs.getString("username"));
			if (rs.getMetaData().getColumnCount() > 8) {
				request.setReviewedByAdminName(rs.getString("admin_username"));
			}
		}
		return request;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public ReportDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public List<Map<String, Object>> getEventParticipationSummary() {
		List<Map<String, Object>> summary = new ArrayList<>();
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("event_name", rs.getString("event_name"));
				row.put("participant_count", rs.getInt("participant_count"));
				summary.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating event participation summary.", e);
		}
		return summary;
	}

	public List<Map<String, Object>> getUserActivityStats() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("username", rs.getString("username"));
				row.put("events_signed_up", rs.getInt("events_signed_up"));
				row.put("meetings_attended", rs.getInt("meetings_attended"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating user activity stats.", e);
		}
		return stats;
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("item_name", rs.getString("item_name"));
				row.put("total_quantity_checked_out", rs.getInt("total_quantity_checked_out"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating inventory usage frequency report.", e);
		}
		return stats;
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			if (rs.next()) {
				return rs.getDouble("total_value");
			}
		} catch (SQLException e) {
			logger.error("Error calculating total inventory value.", e);
		}
		return 0.0;
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT CONCAT(YEAR(event_datetime), '-', LPAD(MONTH(event_datetime), 2, '0')) AS month, COUNT(*) AS count "
				+ "FROM events " + "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, months);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("month", rs.getString("month"));
					row.put("count", rs.getInt("count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating event count by month report.", e);
		}
		return data;
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("username", rs.getString("username"));
					row.put("participation_count", rs.getInt("participation_count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating user participation stats.", e);
		}
		return data;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import com.github.benmanes.caffeine.cache.Caffeine;
import com.github.benmanes.caffeine.cache.LoadingCache;
import com.google.inject.Inject;
import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);
	private final DatabaseManager dbManager;
	private final LoadingCache<String, List<Role>> roleCache;
	private static final String ALL_ROLES_KEY = "ALL_ROLES";

	@Inject
	public RoleDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
		this.roleCache = Caffeine.newBuilder().expireAfterWrite(1, TimeUnit.HOURS).maximumSize(1) // Only one entry: the
																									// list of all roles
				.build(key -> fetchAllRolesFromDb());
	}

	public List<Role> getAllRoles() {
		logger.debug("Fetching all roles from cache.");
		return roleCache.get(ALL_ROLES_KEY);
	}

	private List<Role> fetchAllRolesFromDb() {
		logger.info("Cache miss for roles. Fetching all roles from database.");
		List<Role> roles = new ArrayList<>();
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try (Connection conn = dbManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {

			while (rs.next()) {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				roles.add(role);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all roles from DB", e);
		}
		return roles;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

@Singleton
public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public StatisticsDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public int getUserCount() {
		return getCount("SELECT COUNT(*) FROM users");
	}

	public int getActiveEventCount() {
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	private int getCount(String sql) {
		try (Connection conn = dbManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			if (rs.next()) {
				return rs.getInt(1);
			}
		} catch (SQLException e) {
			logger.error("SQL error executing count query: {}", sql, e);
		}
		return 0;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public StorageDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream().collect(
				Collectors.groupingBy(item -> item.getLocation() != null ? item.getLocation().trim() : "Unbekannt"));
	}

	public List<StorageItem> getAllItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id ORDER BY si.name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching all storage items.", e);
		}
		return items;
	}

	public List<StorageItem> getDefectiveItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching defective items.", e);
		}
		return items;
	}

	private StorageItem mapResultSetToStorageItem(ResultSet rs) throws SQLException {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	}

	public StorageItem getItemById(int itemId) {
		try (Connection conn = dbManager.getConnection()) {
			return getItemById(itemId, conn);
		} catch (SQLException e) {
			logger.error("SQL error fetching storage item by ID: {}", itemId, e);
		}
		return null;
	}

	public StorageItem getItemById(int itemId, Connection conn) throws SQLException {
		String sql = "SELECT si.*, u.username as holder_username FROM storage_items si LEFT JOIN users u ON si.current_holder_user_id = u.id WHERE si.id = ?";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToStorageItem(rs);
				}
			}
		}
		return null;
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setDouble(7, item.getWeightKg());
			pstmt.setDouble(8, item.getPriceEur());
			pstmt.setString(9, item.getImagePath());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setInt(7, item.getDefectiveQuantity());
			pstmt.setString(8, item.getDefectReason());
			pstmt.setDouble(9, item.getWeightKg());
			pstmt.setDouble(10, item.getPriceEur());
			pstmt.setString(11, item.getImagePath());
			pstmt.setString(12, item.getStatus());
			if (item.getCurrentHolderUserId() > 0)
				pstmt.setInt(13, item.getCurrentHolderUserId());
			else
				pstmt.setNull(13, Types.INTEGER);
			if (item.getAssignedEventId() > 0)
				pstmt.setInt(14, item.getAssignedEventId());
			else
				pstmt.setNull(14, Types.INTEGER);
			pstmt.setInt(15, item.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean performCheckout(int itemId, int quantity, int userId, Integer eventId, Connection conn)
			throws SQLException {
		String sql = "UPDATE storage_items SET quantity = quantity - ?, status = 'CHECKED_OUT', current_holder_user_id = ?, assigned_event_id = ? WHERE id = ? AND (quantity - defective_quantity) >= ?";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantity);
			pstmt.setInt(2, userId);
			if (eventId != null) {
				pstmt.setInt(3, eventId);
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setInt(4, itemId);
			pstmt.setInt(5, quantity);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean performCheckin(int itemId, int quantity, Connection conn) throws SQLException {
		String sql = "UPDATE storage_items SET quantity = quantity + ?, status = 'IN_STORAGE', current_holder_user_id = NULL, assigned_event_id = NULL WHERE id = ?";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantity);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean updateDefectiveStatus(int itemId, int defectiveQty, String reason, Connection conn) throws SQLException {
        String sql = "UPDATE storage_items SET defective_quantity = ?, defect_reason = ? WHERE id = ? AND ? <= quantity";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, defectiveQty);
            pstmt.setString(2, reason);
            pstmt.setInt(3, itemId);
            pstmt.setInt(4, defectiveQty);
            return pstmt.executeUpdate() > 0;
        }
    }

	public boolean permanentlyReduceQuantities(int itemId, int quantityToReduce, String reason, Connection conn) throws SQLException {
        String sql = "UPDATE storage_items SET quantity = quantity - ?, defective_quantity = defective_quantity - ?, defect_reason = ? WHERE id = ? AND defective_quantity >= ?";
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, quantityToReduce);
            pstmt.setInt(2, quantityToReduce);
			pstmt.setString(3, reason);
            pstmt.setInt(4, itemId);
            pstmt.setInt(5, quantityToReduce);
            return pstmt.executeUpdate() > 0;
        }
    }

	public boolean repairItems(int itemId, int repairedQuantity) {
		String sql = "UPDATE storage_items SET defective_quantity = defective_quantity - ?, status = CASE WHEN (defective_quantity - ?) <= 0 THEN 'IN_STORAGE' ELSE status END WHERE id = ? AND defective_quantity >= ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, repairedQuantity);
			pstmt.setInt(2, repairedQuantity);
			pstmt.setInt(3, itemId);
			pstmt.setInt(4, repairedQuantity);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error repairing items for item ID {}", itemId, e);
			return false;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public boolean updateItemStatus(int itemId, String status) {
		String sql = "UPDATE storage_items SET status = ? WHERE id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating status for item ID: {}", itemId, e);
			return false;
		}
	}

	public List<StorageItem> getLowStockItems(int limit) {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items WHERE (quantity - defective_quantity) < (max_quantity * 0.25) AND max_quantity > 0 ORDER BY (quantity - defective_quantity) / max_quantity ASC LIMIT ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					items.add(mapResultSetToStorageItem(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching low stock items.", e);
		}
		return items;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public StorageLogDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId,
			Connection conn) throws SQLException {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, quantityChange);
			pstmt.setString(4, notes);
			if (eventId > 0) {
				pstmt.setInt(5, eventId);
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			return pstmt.executeUpdate() > 0;
		}
	}

	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		List<StorageLogEntry> history = new ArrayList<>();
		String sql = "SELECT sl.*, u.username FROM storage_log sl JOIN users u ON sl.user_id = u.id WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					StorageLogEntry entry = new StorageLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setQuantityChange(rs.getInt("quantity_change"));
					entry.setNotes(rs.getString("notes"));
					entry.setEventId(rs.getInt("event_id"));
					entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
		}
		return history;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

@Singleton
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
	private final DatabaseManager dbManager;

	@Inject
	public UserDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	private User mapResultSetToUser(ResultSet resultSet) throws SQLException {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	}

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, username);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					String storedHash = resultSet.getString("password_hash");
					if (passwordEncoder.matches(password, storedHash)) {
						User user = mapResultSetToUser(resultSet);
						user.setPermissions(getPermissionsForUser(user.getId()));
						return user;
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error during user validation for username: {}", username, exception);
		}
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, username);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					return mapResultSetToUser(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by username: {}", username, exception);
		}
		return null;
	}

	public Set<String> getPermissionsForUser(int userId) {
		Set<String> permissions = new HashSet<>();
		String sql = "SELECT p.permission_key FROM permissions p JOIN user_permissions up ON p.id = up.permission_id WHERE up.user_id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					permissions.add(resultSet.getString("permission_key"));
				}
			}
		} catch (SQLException exception) {
			logger.error("Could not fetch permissions for user ID: {}", userId, exception);
		}
		return permissions;
	}

	public boolean updateUserPermissions(int userId, String[] permissionIds, Connection conn) throws SQLException {
		String deleteSql = "DELETE FROM user_permissions WHERE user_id = ?";
		try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
			deleteStmt.setInt(1, userId);
			deleteStmt.executeUpdate();
		}
		if (permissionIds != null && permissionIds.length > 0) {
			String insertSql = "INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)";
			try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
				for (String permId : permissionIds) {
					insertStmt.setInt(1, userId);
					insertStmt.setInt(2, Integer.parseInt(permId));
					insertStmt.addBatch();
				}
				insertStmt.executeBatch();
			}
		}
		return true;
	}

	public int createUser(User user, String password, Connection connection) throws SQLException {
		String hashedPassword = passwordEncoder.encode(password);
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setString(2, hashedPassword);
			preparedStatement.setInt(3, user.getRoleId());
			preparedStatement.setInt(4, user.getClassYear());
			preparedStatement.setString(5, user.getClassName());
			preparedStatement.setString(6, user.getEmail());
			preparedStatement.setString(7, "light");
			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						return generatedKeys.getInt(1);
					}
				}
			}
		}
		return 0;
	}

	public boolean updateUser(User user, Connection connection) throws SQLException {
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ? WHERE id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setInt(2, user.getRoleId());
			preparedStatement.setInt(3, user.getClassYear());
			preparedStatement.setString(4, user.getClassName());
			preparedStatement.setString(5, user.getEmail());
			preparedStatement.setInt(6, user.getId());
			return preparedStatement.executeUpdate() > 0;
		}
	}

	public boolean updateUser(User user) {
		try (Connection connection = dbManager.getConnection()) {
			return updateUser(user, connection);
		} catch (SQLException e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, theme);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating theme for user ID {}", userId, exception);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, chatColor);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating chat color for user ID {}", userId, exception);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error deleting user with ID: {}", userId, exception);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, hashedPassword);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error changing password for user ID: {}", userId, exception);
			return false;
		}
	}

	public List<User> getAllUsers() {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql);
				ResultSet resultSet = preparedStatement.executeQuery()) {
			while (resultSet.next()) {
				users.add(mapResultSetToUser(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching all users", exception);
		}
		return users;
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		try (Connection connection = dbManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					User user = mapResultSetToUser(resultSet);
					user.setPermissions(getPermissionsForUser(userId));
					return user;
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by ID: {}", userId, exception);
		}
		return null;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.UserQualification;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);
	private final DatabaseManager dbManager;

	@Inject
	public UserQualificationsDAO(DatabaseManager dbManager) {
		this.dbManager = dbManager;
	}

	public List<UserQualification> getQualificationsForUser(int userId) {
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id WHERE uq.user_id = ?";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					qualifications.add(mapResultSetToUserQualification(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
		}
		return qualifications;
	}

	public List<UserQualification> getAllQualifications() {
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.user_id, uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks FROM user_qualifications uq JOIN courses c ON uq.course_id = c.id";
		try (Connection conn = dbManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				qualifications.add(mapResultSetToUserQualification(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching all qualifications.", e);
		}
		return qualifications;
	}

	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try (Connection conn = dbManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(deleteSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.executeUpdate();
				return true;
			} catch (SQLException e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try (Connection conn = dbManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(upsertSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.setString(3, status);
				if (completionDate != null) {
					pstmt.setDate(4, Date.valueOf(completionDate));
				} else {
					pstmt.setNull(4, Types.DATE);
				}
				pstmt.setString(5, remarks);
				return pstmt.executeUpdate() >= 0;
			} catch (SQLException e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}

	private UserQualification mapResultSetToUserQualification(ResultSet rs) throws SQLException {
		UserQualification uq = new UserQualification();
		if (hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}

	public int batchGrantQualifications(int courseId, int minMeetings) {
		String sql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) SELECT user_id, ?, 'ABSOLVIERT', CURDATE(), 'Automatisch vergeben' FROM meeting_attendance WHERE attended = TRUE AND meeting_id IN (SELECT id FROM meetings WHERE course_id = ?) GROUP BY user_id HAVING COUNT(meeting_id) >= ? ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
		try (Connection conn = dbManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, courseId);
			pstmt.setInt(2, courseId);
			pstmt.setInt(3, minMeetings);
			return pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error during batch qualification grant for course ID {}", courseId, e);
			return -1;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AdminFilter.java
========================================================================

package de.technikteam.filter;

import de.technikteam.model.User;
import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@WebFilter(urlPatterns = { "/admin/*", "/api/admin/*" }, asyncSupported = true)
public class AdminFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AdminFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AdminFilter initialized and protecting /admin/* and /api/admin/* paths.");
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);
		String path = request.getRequestURI().substring(request.getContextPath().length());
		logger.trace("AdminFilter is processing request for path: '{}'", path);

		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Admin access DENIED to path '{}'. No active session found. Redirecting to login.", path);
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		User user = (User) session.getAttribute("user");

		if (user.hasAdminAccess()) {
			logger.debug(
					"ADMIN area access GRANTED for user '{}' to path '{}'. User has at least one admin permission.",
					user.getUsername(), path);
			chain.doFilter(request, response);
		} else {
			logger.warn(
					"ADMIN access DENIED for user '{}' (Role: '{}') to path '{}'. No relevant admin permissions found.",
					user.getUsername(), user.getRoleName(), path);
			request.getSession().setAttribute("accessErrorMessage",
					"Sie haben keine Berechtigung, auf den Admin-Bereich zuzugreifen.");
			response.sendError(HttpServletResponse.SC_FORBIDDEN,
					"Sie haben keine Berechtigung, auf diesen Bereich zuzugreifen.");
		}
	}

	@Override
	public void destroy() {
		logger.info("AdminFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AuthenticationFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

@WebFilter(value = "/*", asyncSupported = true)
public class AuthenticationFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AuthenticationFilter.class.getName());

	private static final Set<String> PUBLIC_PATHS = new HashSet<>(Arrays.asList("/login", "/logout", "/calendar.ics"));

	// Added /api/auth to allow pre-login access for passkeys
	private static final Set<String> PUBLIC_RESOURCE_PREFIXES = new HashSet<>(
			Arrays.asList("/css", "/js", "/images", "/error", "/public", "/vendor", "/wopi", "/api/auth"));

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AuthenticationFilter initialized. Public paths: {}, Public prefixes: {}", PUBLIC_PATHS,
				PUBLIC_RESOURCE_PREFIXES);
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String contextPath = request.getContextPath();
		String requestUri = request.getRequestURI();

		// Strip jsessionid from the path, if present
		String path = requestUri.substring(contextPath.length());
		int semicolonIndex = path.indexOf(';');
		if (semicolonIndex != -1) {
			path = path.substring(0, semicolonIndex);
		}

		logger.trace("AuthenticationFilter processing request for path: '{}'", path);

		boolean isLoggedIn = (session != null && session.getAttribute("user") != null);

		// Assign to a final variable to be used in lambda, ensuring compiler
		// compatibility
		final String finalPath = path;
		boolean isPublicResource = PUBLIC_PATHS.contains(finalPath)
				|| PUBLIC_RESOURCE_PREFIXES.stream().anyMatch(prefix -> finalPath.startsWith(prefix));

		if (isLoggedIn || isPublicResource) {
			logger.trace("Access granted for path '{}'. LoggedIn: {}, IsPublic: {}", finalPath, isLoggedIn,
					isPublicResource);
			chain.doFilter(request, response);
		} else {
			logger.warn("Unauthorized access attempt by a guest to protected path: '{}'. Redirecting to login page.",
					finalPath);
			response.sendRedirect(contextPath + "/login");
		}
	}

	@Override
	public void destroy() {
		logger.info("AuthenticationFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\CharacterEncodingFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;

/**
 * A crucial utility filter that intercepts all incoming requests (`/*`) to set
 * the character encoding to UTF-8. This ensures that any data submitted in
 * requests (e.g., form fields with special characters like German umlauts) and
 * any content sent in responses is correctly interpreted and rendered by the
 * browser. It should be the first filter in the chain.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class CharacterEncodingFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(CharacterEncodingFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("CharacterEncodingFilter initialized and set to enforce UTF-8.");
	}

	/**
	 * Sets the character encoding for both the request and response to UTF-8.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		logger.trace("Applying UTF-8 character encoding to request and response.");

		request.setCharacterEncoding("UTF-8");

		response.setCharacterEncoding("UTF-8");

		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
		logger.info("CharacterEncodingFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\AppContextListener.java
========================================================================

package de.technikteam.listener;

import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * This is an application lifecycle listener that performs crucial cleanup tasks
 * when the web application is shut down or undeployed from the server. Its
 * primary purpose is to manually deregister the JDBC driver that was loaded by
 * this application's classloader. This prevents potential memory leaks in
 * application servers like Tomcat. It also explicitly shuts down the MySQL
 * cleanup thread.
 */
@WebListener
public class AppContextListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(AppContextListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Initialized <<<<<<<<<<");
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Being Destroyed. Cleaning up resources... <<<<<<<<<<");

		try {
			logger.info("Attempting to shut down MySQL abandoned connection cleanup thread...");
			AbandonedConnectionCleanupThread.checkedShutdown();
			logger.info("MySQL cleanup thread shutdown signal sent.");
		} catch (Exception e) {
			logger.error("Error shutting down MySQL cleanup thread.", e);
		}

		Enumeration<java.sql.Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			java.sql.Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getClass().getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
					logger.info("Deregistering JDBC driver: {}", driver);
				} catch (SQLException e) {
					logger.error("Error deregistering JDBC driver: {}", driver, e);
				}
			} else {
				logger.trace("Not deregistering JDBC driver {} as it does not belong to this webapp's classloader.",
						driver);
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\ApplicationInitializerListener.java
========================================================================

package de.technikteam.listener;

import de.technikteam.service.ConfigurationService;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.flywaydb.core.Flyway;
import org.flywaydb.core.api.output.MigrateResult;

@WebListener
public class ApplicationInitializerListener implements ServletContextListener {

    private static final Logger logger = LogManager.getLogger(ApplicationInitializerListener.class);

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        logger.info("Application Initializer: Context is being initialized...");

        try {
            ConfigurationService configService = new ConfigurationService();

            logger.info("Initializing Flyway for database migration...");
            Flyway flyway = Flyway.configure()
                    .dataSource(
                            configService.getProperty("db.url"),
                            configService.getProperty("db.user"),
                            configService.getProperty("db.password")
                    )
                    .locations("classpath:db/migration")
                    .loggers("slf4j")
                    .baselineOnMigrate(true)
                    .load();

            logger.info("Starting database migration...");
            MigrateResult result = flyway.migrate();
            
            // CORRECTED: Switched from direct field access to the correct getter method as recommended by the compiler.
            logger.info("Flyway migration finished. {} migrations applied in {} ms.", result.migrationsExecuted, result.getTotalMigrationTime());

            if (!result.success) {
                logger.fatal("Flyway migration failed! Application startup aborted.");
                throw new RuntimeException("Database migration failed. Check logs for details.");
            }
            logger.info("Database schema is up to date (Version: {}).", result.targetSchemaVersion);

        } catch (Exception e) {
            logger.fatal("FATAL: A critical error occurred during application initialization.", e);
            throw new RuntimeException("Failed to initialize application.", e);
        }
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
        logger.info("Application Initializer: Context is being destroyed.");
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\SessionListener.java
========================================================================

package de.technikteam.listener;

import de.technikteam.servlet.http.SessionManager;
import jakarta.servlet.annotation.WebListener;
import jakarta.servlet.http.HttpSessionEvent;
import jakarta.servlet.http.HttpSessionListener;

/**
 * Listens for HttpSession creation and destruction to keep the SessionManager
 * up to date.
 */
@WebListener
public class SessionListener implements HttpSessionListener {

	@Override
	public void sessionCreated(HttpSessionEvent se) {
		SessionManager.addSession(se.getSession());
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent se) {
		SessionManager.removeSession(se.getSession());
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ApiResponse.java
========================================================================

package de.technikteam.model;

/**
 * A generic Data Transfer Object for standardizing API responses from the server.
 * It provides a consistent structure for success/failure status, a message, and optional data payload.
 */
public class ApiResponse {
    private final boolean success;
    private final String message;
    private final Object data;

    public ApiResponse(boolean success, String message, Object data) {
        this.success = success;
        this.message = message;
        this.data = data;
    }

    /**
     * Creates a success response with a message and data.
     * @param message A descriptive success message.
     * @param data The data payload to send back to the client.
     * @return A new ApiResponse object.
     */
    public static ApiResponse success(String message, Object data) {
        return new ApiResponse(true, message, data);
    }

    /**
     * Creates a success response with only a message.
     * @param message A descriptive success message.
     * @return A new ApiResponse object.
     */
    public static ApiResponse success(String message) {
        return new ApiResponse(true, message, null);
    }

    /**
     * Creates an error response with a message.
     * @param message A descriptive error message.
     * @return A new ApiResponse object.
     */
    public static ApiResponse error(String message) {
        return new ApiResponse(false, message, null);
    }
    
    /**
     * Creates an error response with a message and additional data.
     * @param message A descriptive error message.
     * @param data Additional context about the error.
     * @return A new ApiResponse object.
     */
    public static ApiResponse error(String message, Object data) {
        return new ApiResponse(false, message, data);
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }

    public Object getData() {
        return data;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; // "EVENT" or "MEETING"
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\DashboardDataDTO.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.Map;

/**
 * A Data Transfer Object to encapsulate all data required for the dynamic admin
 * dashboard.
 */
public class DashboardDataDTO {
	private List<Event> upcomingEvents;
	private List<StorageItem> lowStockItems;
	private List<AdminLog> recentLogs;
	private List<Map<String, Object>> eventTrendData;

	// Getters and Setters
	public List<Event> getUpcomingEvents() {
		return upcomingEvents;
	}

	public void setUpcomingEvents(List<Event> upcomingEvents) {
		this.upcomingEvents = upcomingEvents;
	}

	public List<StorageItem> getLowStockItems() {
		return lowStockItems;
	}

	public void setLowStockItems(List<StorageItem> lowStockItems) {
		this.lowStockItems = lowStockItems;
	}

	public List<AdminLog> getRecentLogs() {
		return recentLogs;
	}

	public void setRecentLogs(List<AdminLog> recentLogs) {
		this.recentLogs = recentLogs;
	}

	public List<Map<String, Object>> getEventTrendData() {
		return eventTrendData;
	}

	public void setEventTrendData(List<Map<String, Object>> eventTrendData) {
		this.eventTrendData = eventTrendData;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;

	// Transient field for view logic
	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean edited;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor; 

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details; 
	private String status;
	private String eventName;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers;
	private List<StorageItem> requiredItems;
	private List<InventoryKit> requiredKits;

	private String assignedUsernames;

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public void setAssignedUsernames(String assignedUsernames) {
		this.assignedUsernames = assignedUsernames;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackSubmission.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single feedback submission from a user. Corresponds to the
 * `feedback_submissions` table.
 */
public class FeedbackSubmission {
	private int id;
	private int userId;
	private String username; // For display
	private String subject;
	private String content;
	private LocalDateTime submittedAt;
	private String status;

	public String getFormattedSubmittedAt() {
		return DateFormatter.formatDateTime(this.submittedAt);
	}

	// Standard Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSubject() {
		return subject;
	}

	public void setSubject(String subject) {
		this.subject = subject;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public LocalDateTime getSubmittedAt() {
		return submittedAt;
	}

	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;
	private String content;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\PasskeyCredential.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single Passkey/WebAuthn credential from the user_passkeys table.
 */
public class PasskeyCredential {
	private int id;
	private int userId;
	private String name;
	private String userHandle;
	private String credentialId;
	private String publicKey;
	private long signatureCount;
	private LocalDateTime createdAt;

	public PasskeyCredential(int id, int userId, String name, String userHandle, String credentialId, String publicKey,
			long signatureCount, LocalDateTime createdAt) {
		this.id = id;
		this.userId = userId;
		this.name = name;
		this.userHandle = userHandle;
		this.credentialId = credentialId;
		this.publicKey = publicKey;
		this.signatureCount = signatureCount;
		this.createdAt = createdAt;
	}

	public PasskeyCredential() {
	}

	// Getters and setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getUserHandle() {
		return userHandle;
	}

	public void setUserHandle(String userHandle) {
		this.userHandle = userHandle;
	}

	public String getCredentialId() {
		return credentialId;
	}

	public void setCredentialId(String credentialId) {
		this.credentialId = credentialId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public void setPublicKey(String publicKey) {
		this.publicKey = publicKey;
	}

	public long getSignatureCount() {
		return signatureCount;
	}

	public void setSignatureCount(long signatureCount) {
		this.signatureCount = signatureCount;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ProfileChangeRequest.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single request from a user to change their profile data.
 * Corresponds to the `profile_change_requests` table.
 */
public class ProfileChangeRequest {
	private int id;
	private int userId;
	private String username; // For display purposes
	private String requestedChanges; // JSON string
	private String status;
	private LocalDateTime requestedAt;
	private Integer reviewedByAdminId;
	private String reviewedByAdminName; // For display purposes
	private LocalDateTime reviewedAt;

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRequestedChanges() {
		return requestedChanges;
	}

	public void setRequestedChanges(String requestedChanges) {
		this.requestedChanges = requestedChanges;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDateTime getRequestedAt() {
		return requestedAt;
	}

	public void setRequestedAt(LocalDateTime requestedAt) {
		this.requestedAt = requestedAt;
	}

	public Integer getReviewedByAdminId() {
		return reviewedByAdminId;
	}

	public void setReviewedByAdminId(Integer reviewedByAdminId) {
		this.reviewedByAdminId = reviewedByAdminId;
	}

	public String getReviewedByAdminName() {
		return reviewedByAdminName;
	}

	public void setReviewedByAdminName(String reviewedByAdminName) {
		this.reviewedByAdminName = reviewedByAdminName;
	}

	public LocalDateTime getReviewedAt() {
		return reviewedAt;
	}

	public void setReviewedAt(LocalDateTime reviewedAt) {
		this.reviewedAt = reviewedAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		if (this.getAvailableQuantity() <= 0) {
			return "Vergriffen";
		}
		if (this.maxQuantity > 0 && this.getAvailableQuantity() >= this.maxQuantity) {
			return "Vollständig";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		if (this.getAvailableQuantity() <= 0) {
			return "status-danger";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.Permissions;

import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	/**
	 * A central method to determine if the user has any permission that grants them
	 * access to the admin panel. This prevents logic duplication in filters and
	 * navigation builders.
	 *
	 * @return true if the user has any admin-level permission, false otherwise.
	 */
	public boolean hasAdminAccess() {
		if (permissions == null) {
			return false;
		}
		// A user has admin access if they have the master key OR any other specific
		// admin-level permission that is not just for viewing or updating specific
		// content.
		return permissions.contains(Permissions.ACCESS_ADMIN_PANEL) || permissions.stream().anyMatch(
				p -> !p.equals(Permissions.FILE_READ) && !p.equals(Permissions.FILE_UPDATE) && (p.contains("_READ")
						|| p.contains("_MANAGE") || p.contains("_CREATE") || p.contains("_DELETE")));
	}

	// --- Standard Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.List;

@Singleton
public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);

	private final AchievementDAO achievementDAO;
	private final EventDAO eventDAO;

	@Inject
	public AchievementService(AchievementDAO achievementDAO, EventDAO eventDAO) {
		this.achievementDAO = achievementDAO;
		this.eventDAO = eventDAO;
	}

	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// This would be called from UserQualificationsDAO after an update
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminDashboardService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AdminLogDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.ReportDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.DashboardDataDTO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;

import java.util.List;
import java.util.Map;

@Singleton
public class AdminDashboardService {
	private final EventDAO eventDAO;
	private final StorageDAO storageDAO;
	private final AdminLogDAO adminLogDAO;
	private final ReportDAO reportDAO;

	private static final int WIDGET_LIMIT = 5;
	private static final int TREND_MONTHS = 12;

	@Inject
	public AdminDashboardService(EventDAO eventDAO, StorageDAO storageDAO, AdminLogDAO adminLogDAO,
			ReportDAO reportDAO) {
		this.eventDAO = eventDAO;
		this.storageDAO = storageDAO;
		this.adminLogDAO = adminLogDAO;
		this.reportDAO = reportDAO;
	}

	public DashboardDataDTO getDashboardData() {
		DashboardDataDTO dto = new DashboardDataDTO();
		dto.setUpcomingEvents(eventDAO.getUpcomingEvents(WIDGET_LIMIT));
		dto.setLowStockItems(storageDAO.getLowStockItems(WIDGET_LIMIT));
		dto.setRecentLogs(adminLogDAO.getRecentLogs(WIDGET_LIMIT));
		dto.setEventTrendData(reportDAO.getEventCountByMonth(TREND_MONTHS));
		return dto;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

@Singleton
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private final AdminLogDAO logDAO;

	@Inject
	public AdminLogService(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	private String sanitize(String input) {
		if (input == null) {
			return "";
		}
		return input.replace('\n', '_').replace('\r', '_');
	}

	public void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);
			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);
			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AuthorizationService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Singleton;
import de.technikteam.model.User;

@Singleton
public class AuthorizationService {

	/**
	 * Checks if a user has a specific permission.
	 * 
	 * @param user          The user to check.
	 * @param permissionKey The permission key to verify (e.g., "USER_CREATE").
	 * @return true if the user has the permission, false otherwise.
	 */
	public boolean checkPermission(User user, String permissionKey) {
		if (user == null || user.getPermissions() == null) {
			return false;
		}
		// A master admin can do anything.
		if (user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			return true;
		}
		return user.getPermissions().contains(permissionKey);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\ConfigurationService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Singleton;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

@Singleton
public class ConfigurationService {
	private static final Logger logger = LogManager.getLogger(ConfigurationService.class);
	private final Properties properties = new Properties();

	public ConfigurationService() {
		try (InputStream input = getClass().getClassLoader().getResourceAsStream("config.properties")) {
			if (input == null) {
				logger.error("Unable to find config.properties on the classpath.");
				throw new IllegalStateException("config.properties not found.");
			}
			properties.load(input);
			logger.info("ConfigurationService initialized and loaded properties successfully.");
		} catch (IOException ex) {
			logger.fatal("Failed to load configuration properties.", ex);
			throw new RuntimeException("Failed to load configuration properties.", ex);
		}
	}

	public String getProperty(String key) {
		return properties.getProperty(key);
	}

	public String getProperty(String key, String defaultValue) {
		return properties.getProperty(key, defaultValue);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\EventService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.*;
import de.technikteam.model.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

@Singleton
public class EventService {
	private static final Logger logger = LogManager.getLogger(EventService.class);

	private final EventDAO eventDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final DatabaseManager dbManager;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;

	@Inject
	public EventService(EventDAO eventDAO, AttachmentDAO attachmentDAO, EventCustomFieldDAO customFieldDAO,
			DatabaseManager dbManager, ConfigurationService configService, AdminLogService adminLogService) {
		this.eventDAO = eventDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.dbManager = dbManager;
		this.configService = configService;
		this.adminLogService = adminLogService;
	}

	public int createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, HttpServletRequest request) {
		try (Connection conn = dbManager.getConnection()) {
			conn.setAutoCommit(false);
			try {
				int eventId;
				if (isUpdate) {
					if (eventDAO.updateEvent(event, conn)) {
						eventId = event.getId();
						adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
								"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
					} else {
						throw new SQLException("Failed to update the core event record.");
					}
				} else {
					eventId = eventDAO.createEvent(event, conn);
					if (eventId > 0) {
						event.setId(eventId);
						adminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
								"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
					} else {
						throw new SQLException("Failed to create the core event record.");
					}
				}

				String[] requiredCourseIds = request.getParameterValues("requiredCourseId");
				String[] requiredPersons = request.getParameterValues("requiredPersons");
				eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons, conn);

				String[] itemIds = request.getParameterValues("itemId");
				String[] quantities = request.getParameterValues("itemQuantity");
				eventDAO.saveReservations(eventId, itemIds, quantities, conn);

				String[] customFieldNames = request.getParameterValues("customFieldName");
				String[] customFieldTypes = request.getParameterValues("customFieldType");
				if (customFieldNames != null) {
					List<EventCustomField> customFields = new ArrayList<>();
					for (int i = 0; i < customFieldNames.length; i++) {
						if (customFieldNames[i] != null && !customFieldNames[i].trim().isEmpty()) {
							EventCustomField cf = new EventCustomField();
							cf.setFieldName(customFieldNames[i]);
							cf.setFieldType(customFieldTypes[i]);
							cf.setRequired(true);
							customFields.add(cf);
						}
					}
					customFieldDAO.saveCustomFieldsForEvent(eventId, customFields, conn);
				}

				Part filePart = request.getPart("attachment");
				if (filePart != null && filePart.getSize() > 0) {
					String requiredRole = request.getParameter("requiredRole");
					handleAttachmentUpload(filePart, eventId, requiredRole, adminUser, conn);
				}

				conn.commit();
				logger.info("Transaction for event ID {} committed successfully.", eventId);
				return eventId;

			} catch (Exception e) {
				conn.rollback();
				logger.error("Error in event service transaction. Rolling back.", e);
				return 0;
			}
		} catch (SQLException e) {
			logger.error("Failed to get DB connection for event service transaction.", e);
			return 0;
		}
	}

	private void handleAttachmentUpload(Part filePart, int eventId, String requiredRole, User adminUser,
			Connection conn) throws IOException, SQLException {
		String uploadDir = configService.getProperty("upload.directory") + File.separator + "events";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(fileName);
		attachment.setFilepath("events/" + fileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment, conn)) {
			adminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + fileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			throw new SQLException("Failed to save attachment to database.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.model.User;
import jakarta.servlet.AsyncContext;
import jakarta.servlet.http.HttpServletRequest;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);
	private static final NotificationService INSTANCE = new NotificationService();
	private final Gson gson;

	private final Map<Integer, List<AsyncContext>> contextsByUser = new ConcurrentHashMap<>();

	private NotificationService() {
		// FIX: Initialize Gson with the custom adapter to handle LocalDateTime
		// correctly
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	public static NotificationService getInstance() {
		return INSTANCE;
	}

	public void register(HttpServletRequest request) {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			logger.warn("Attempt to register for notifications from a non-authenticated session.");
			return;
		}

		AsyncContext asyncContext = request.startAsync();
		asyncContext.setTimeout(0);

		contextsByUser.computeIfAbsent(user.getId(), k -> new CopyOnWriteArrayList<>()).add(asyncContext);
		logger.info("New client registered for SSE notifications for user ID {}. Total clients for user: {}",
				user.getId(), contextsByUser.get(user.getId()).size());
	}

	/**
	 * Broadcasts a generic message to all connected clients.
	 * 
	 * @param message The plain text message to send.
	 */
	public void broadcastGenericMessage(String message) {
		logger.info("Broadcasting generic notification to all clients: {}", message);
		Map<String, Object> payload = Map.of("type", "generic", "payload", Map.of("message", message));
		broadcast(gson.toJson(payload));
	}

	/**
	 * Broadcasts a specific UI update event to all connected clients.
	 * 
	 * @param type    The type of UI update (e.g., "user_updated",
	 *                "event_status_updated").
	 * @param payload The data associated with the update.
	 */
	public void broadcastUIUpdate(String type, Object payload) {
		logger.info("Broadcasting UI update of type '{}' to all clients.", type);
		Map<String, Object> message = Map.of("type", "ui_update", "payload",
				Map.of("updateType", type, "data", payload));
		broadcast(gson.toJson(message));
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<AsyncContext> userContexts = contextsByUser.get(userId);
		if (userContexts != null && !userContexts.isEmpty()) {
			String jsonMessage = gson.toJson(payload);
			logger.info("Sending targeted notification to user ID {}: {}", userId, jsonMessage);
			userContexts.forEach(context -> sendMessageToContext(context, jsonMessage, userContexts));
		} else {
			logger.debug("No active SSE clients found for user ID {} to send notification.", userId);
		}
	}

	public void sendEventInvitation(int userId, String eventName, int eventId) {
		String message = String.format("Du wurdest zum Event '%s' eingeladen!", eventName);
		Map<String, Object> payload = Map.of("type", "event_invitation", "payload",
				Map.of("message", message, "url", "/veranstaltungen/details?id=" + eventId));
		sendNotificationToUser(userId, payload);
	}

	/**
	 * Sends a pre-formatted JSON message to all connected clients.
	 * 
	 * @param jsonMessage The JSON string to broadcast.
	 */
	private void broadcast(String jsonMessage) {
		contextsByUser.values().forEach(contextList -> {
			contextList.forEach(context -> sendMessageToContext(context, jsonMessage, contextList));
		});
	}

	private void sendMessageToContext(AsyncContext context, String message, List<AsyncContext> contextList) {
		try {
			PrintWriter writer = context.getResponse().getWriter();
			writer.write("data: " + message + "\n\n");
			writer.flush();
		} catch (IOException | IllegalStateException e) {
			logger.warn("Failed to send notification to a client (likely disconnected), removing it. Error: {}",
					e.getMessage());
			contextList.remove(context);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\PasskeyService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.PasskeyDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.util.UUID;

@Singleton
public class PasskeyService {
	private static final Logger logger = LogManager.getLogger(PasskeyService.class);
	private final PasskeyDAO passkeyDAO;
	private final UserDAO userDAO;

	@Inject
	public PasskeyService(PasskeyDAO passkeyDAO, UserDAO userDAO) {
		this.passkeyDAO = passkeyDAO;
		this.userDAO = userDAO;
	}

	public String startRegistration(User user) {
		logger.info("Simulating passkey registration start for user '{}'", user.getUsername());
		String challenge = generateChallenge();
		String userHandle = UUID.randomUUID().toString();
		return String.format(
				"{\"challenge\": \"%s\", \"rp\": {\"name\": \"TechnikTeam\", \"id\": \"localhost\"}, \"user\": {\"id\": \"%s\", \"name\": \"%s\", \"displayName\": \"%s\"}, \"pubKeyCredParams\": [{\"type\": \"public-key\", \"alg\": -7}]}",
				challenge, userHandle, user.getUsername(), user.getUsername());
	}

	public boolean finishRegistration(int userId, String credentialData, String deviceName) {
		logger.info("Simulating passkey registration finish for user ID {}. Device: '{}'", userId, deviceName);
		de.technikteam.model.PasskeyCredential credential = new de.technikteam.model.PasskeyCredential();
		credential.setUserId(userId);
		credential.setName(deviceName);
		credential.setUserHandle(UUID.randomUUID().toString());
		credential.setCredentialId(generateChallenge());
		credential.setPublicKey("simulated-public-key-" + UUID.randomUUID());
		credential.setSignatureCount(0);
		return passkeyDAO.saveCredential(credential);
	}

	public String startAuthentication(String username) {
		logger.info("Simulating passkey authentication start for user '{}'", username);
		String challenge = generateChallenge();
		return String.format("{\"challenge\": \"%s\", \"allowCredentials\": [], \"rpId\": \"localhost\"}", challenge);
	}

	public User finishAuthentication(String credentialData) {
		logger.info("Simulating passkey authentication finish.");
		// SIMULATION: In a real implementation, you'd parse credentialId and verify.
		// For this refactoring, we'll find a user associated with any passkey.
		// This logic is a placeholder and should be replaced with real crypto.
		User user = userDAO.getUserById(1); // Placeholder: assumes user 1 is an admin for demo purposes.
		if (user != null) {
			user.setPermissions(userDAO.getPermissionsForUser(user.getId()));
			logger.info("Simulated passkey login successful for user '{}'", user.getUsername());
		}
		return user;
	}

	private String generateChallenge() {
		return UUID.randomUUID().toString().replace("-", "");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\StorageService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.DatabaseManager;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.SQLException;

@Singleton
public class StorageService {
	private static final Logger logger = LogManager.getLogger(StorageService.class);

	private final DatabaseManager dbManager;
	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;

	@Inject
	public StorageService(DatabaseManager dbManager, StorageDAO storageDAO, StorageLogDAO storageLogDAO,
			EventDAO eventDAO, AdminLogService adminLogService) {
		this.dbManager = dbManager;
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
	}

	public boolean processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes) {
		try (Connection conn = dbManager.getConnection()) {
			conn.setAutoCommit(false);
			try {
				StorageItem item = storageDAO.getItemById(itemId, conn);
				if (item == null) {
					throw new IllegalArgumentException("Item with ID " + itemId + " not found.");
				}

				boolean success;
				if ("checkout".equals(type)) {
					if (item.getAvailableQuantity() < quantity) {
						throw new IllegalStateException("Not enough items available to check out.");
					}
					success = storageDAO.performCheckout(itemId, quantity, user.getId(), eventId, conn);
				} else if ("checkin".equals(type)) {
					if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
						throw new IllegalStateException("Not enough space to check in this many items.");
					}
					success = storageDAO.performCheckin(itemId, quantity, conn);
				} else {
					throw new IllegalArgumentException("Invalid transaction type: " + type);
				}

				if (success) {
					String finalNotes = notes;
					if ("checkout".equals(type) && eventId != null) {
						Event event = eventDAO.getEventById(eventId, conn);
						if (event != null) {
							String autoNote = "Für Event: " + event.getName();
							finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes
									: autoNote;
						}
					}
					int quantityChange = "checkin".equals(type) ? quantity : -quantity;
					storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes,
							eventId != null ? eventId : 0, conn);

					conn.commit();

					String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
					String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, item.getName(),
							itemId, action, finalNotes);
					adminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

					return true;
				} else {
					throw new SQLException("DAO operation returned false, indicating failure.");
				}
			} catch (Exception e) {
				conn.rollback();
				logger.error("Transaction rolled back for storage transaction.", e);
				return false;
			}
		} catch (SQLException e) {
			logger.error("Failed to get connection for storage transaction.", e);
			return false;
		}
	}
	
	public boolean updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser) {
        try (Connection conn = dbManager.getConnection()) {
            conn.setAutoCommit(false);
            try {
                StorageItem item = storageDAO.getItemById(itemId, conn);
                if (item == null) {
                    throw new IllegalArgumentException("Item with ID " + itemId + " not found.");
                }

                boolean success;
                String logDetails;

                if ("UNREPAIRABLE".equals(status)) {
                    if (item.getQuantity() < quantity) {
                        throw new IllegalStateException("Cannot mark more items as unrepairable than exist.");
                    }
                    if (item.getDefectiveQuantity() < quantity) {
                        throw new IllegalStateException("Cannot mark more items as unrepairable than are currently defective.");
                    }
                    success = storageDAO.permanentlyReduceQuantities(itemId, quantity, reason, conn);
                    logDetails = String.format("Permanently removed %d x '%s' (ID: %d) from stock (unrepairable). Reason: %s", quantity, item.getName(), itemId, reason);
                    adminLogService.log(adminUser.getUsername(), "ITEM_UNREPAIRABLE", logDetails);
                } else { // "DEFECT"
                    int newDefectiveTotal = item.getDefectiveQuantity() + quantity;
                    if (item.getQuantity() < newDefectiveTotal) {
                        throw new IllegalStateException("Total defective quantity cannot exceed total quantity.");
                    }
                    success = storageDAO.updateDefectiveStatus(itemId, newDefectiveTotal, reason, conn);
                    logDetails = String.format("Defect status for '%s' (ID: %d) updated: %d defective. Reason: %s", item.getName(), itemId, newDefectiveTotal, reason);
                    adminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS", logDetails);
                }

                if (success) {
                    conn.commit();
                    return true;
                } else {
                    throw new SQLException("DAO operation failed, rolling back.");
                }
            } catch (Exception e) {
                conn.rollback();
                logger.error("Transaction rolled back for defect status update on item {}", itemId, e);
                return false;
            }
        } catch (SQLException e) {
            logger.error("Failed to get DB connection for defect status update.", e);
            return false;
        }
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

/**
 * A service to gather system statistics from the underlying OS. This version is
 * made more platform-independent and robust for Windows environments.
 */
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getSystemCpuLoad() * 100.0);

		long totalMemoryBytes = osBean.getTotalPhysicalMemorySize();
		long freeMemoryBytes = osBean.getFreePhysicalMemorySize();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());

		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\UserService.java
========================================================================

package de.technikteam.service;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.DatabaseManager;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.SQLException;

@Singleton
public class UserService {
	private static final Logger logger = LogManager.getLogger(UserService.class);

	private final DatabaseManager dbManager;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;

	@Inject
	public UserService(DatabaseManager dbManager, UserDAO userDAO, AdminLogService adminLogService) {
		this.dbManager = dbManager;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
	}

	public int createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername) {
		try (Connection conn = dbManager.getConnection()) {
			conn.setAutoCommit(false);
			try {
				int newUserId = userDAO.createUser(user, password, conn);
				if (newUserId > 0) {
					userDAO.updateUserPermissions(newUserId, permissionIds, conn);
					conn.commit();
					logger.info("Transaction for creating user '{}' committed successfully.", user.getUsername());

					String logDetails = String.format(
							"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %s) erstellt und Berechtigungen zugewiesen.",
							user.getUsername(), newUserId, user.getRoleId(), user.getClassName());
					adminLogService.log(adminUsername, "CREATE_USER", logDetails);

					return newUserId;
				} else {
					throw new SQLException("User creation returned an invalid ID.");
				}
			} catch (Exception e) {
				conn.rollback();
				logger.error("Transaction rolled back for createUserWithPermissions for username '{}'.",
						user.getUsername(), e);
				return 0;
			}
		} catch (SQLException e) {
			logger.error("Failed to get connection for createUserWithPermissions.", e);
			return 0;
		}
	}

	public boolean updateUserWithPermissions(User user, String[] permissionIds) {
		try (Connection conn = dbManager.getConnection()) {
			conn.setAutoCommit(false);
			try {
				boolean profileUpdated = userDAO.updateUser(user, conn);
				boolean permissionsUpdated = userDAO.updateUserPermissions(user.getId(), permissionIds, conn);
				conn.commit();
				logger.info("Transaction for updating user '{}' committed successfully.", user.getUsername());
				return profileUpdated || permissionsUpdated;
			} catch (Exception e) {
				conn.rollback();
				logger.error("Transaction rolled back for updateUserWithPermissions for user '{}'.", user.getUsername(),
						e);
				return false;
			}
		} catch (SQLException e) {
			logger.error("Failed to get connection for updateUserWithPermissions.", e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
public class CalendarApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final Gson gson;

	@Inject
	public CalendarApiServlet(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<Map<String, String>> calendarEntries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime().toString());
			if (event.getEndDateTime() != null) {
				entry.put("end", event.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/veranstaltungen/details?id=" + event.getId());
			entry.put("backgroundColor", "#dc3545");
			entry.put("borderColor", "#c82333");
			calendarEntries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime().toString());
			if (meeting.getEndDateTime() != null) {
				entry.put("end", meeting.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/meetingDetails?id=" + meeting.getId());
			entry.put("backgroundColor", "#007bff");
			entry.put("borderColor", "#0056b3");
			calendarEntries.add(entry);
		}

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(gson.toJson(calendarEntries));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

@Singleton
public class CalendarServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Inject
	public CalendarServlet(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();

		List<Map<String, Object>> combinedList = new ArrayList<>();
		DateTimeFormatter dayFormatter = DateTimeFormatter.ofPattern("dd");
		DateTimeFormatter monthAbbrFormatter = DateTimeFormatter.ofPattern("MMM", Locale.GERMANY);

		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("day", event.getEventDateTime().format(dayFormatter));
			entry.put("monthAbbr", event.getEventDateTime().format(monthAbbrFormatter));
			entry.put("type", "Event");
			entry.put("typeClass", "termin-type-event");
			entry.put("url", request.getContextPath() + "/veranstaltungen/details?id=" + event.getId());
			combinedList.add(entry);
		}

		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("day", meeting.getMeetingDateTime().format(dayFormatter));
			entry.put("monthAbbr", meeting.getMeetingDateTime().format(monthAbbrFormatter));
			entry.put("type", "Lehrgang");
			entry.put("typeClass", "termin-type-lehrgang");
			entry.put("url", request.getContextPath() + "/meetingDetails?id=" + meeting.getId());
			combinedList.add(entry);
		}

		combinedList.sort(Comparator.comparing(m -> (LocalDateTime) m.get("start")));

		DateTimeFormatter monthYearFormatter = DateTimeFormatter.ofPattern("MMMM yyyy", Locale.GERMANY);
		Map<String, List<Map<String, Object>>> groupedByMonth = new LinkedHashMap<>();
		for (Map<String, Object> entry : combinedList) {
			LocalDateTime start = (LocalDateTime) entry.get("start");
			String monthKey = start.format(monthYearFormatter);
			groupedByMonth.computeIfAbsent(monthKey, k -> new ArrayList<>()).add(entry);
		}

		request.setAttribute("groupedEntries", groupedByMonth);
		request.getRequestDispatcher("/views/public/calendar.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DownloadServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

@Singleton
public class DownloadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DownloadServlet.class);

	private final de.technikteam.dao.FileDAO fileDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final AttachmentDAO attachmentDAO;
	private final ConfigurationService configService;

	@Inject
	public DownloadServlet(de.technikteam.dao.FileDAO fileDAO, EventDAO eventDAO, MeetingDAO meetingDAO,
			AttachmentDAO attachmentDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.attachmentDAO = attachmentDAO;
		this.configService = configService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Authentication required.");
			return;
		}

		String idParam = request.getParameter("id");
		if (idParam == null || idParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required 'id' parameter.");
			return;
		}

		try {
			int id = Integer.parseInt(idParam);
			String filePathFromDb = null;
			String filenameForDownload = null;
			boolean isAuthorized = false;

			Attachment attachment = attachmentDAO.getAttachmentById(id);
			if (attachment != null) {
				filePathFromDb = attachment.getFilepath();
				filenameForDownload = attachment.getFilename();
				isAuthorized = isUserAuthorizedForAttachment(user, attachment);
			} else {
				de.technikteam.model.File dbFile = fileDAO.getFileById(id);
				if (dbFile != null) {
					filePathFromDb = dbFile.getFilepath();
					filenameForDownload = dbFile.getFilename();
					isAuthorized = user.hasAdminAccess() || "NUTZER".equalsIgnoreCase(dbFile.getRequiredRole());
				}
			}

			if (filePathFromDb == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND,
						"Die angeforderte Datei wurde in der Datenbank nicht gefunden.");
				return;
			}

			if (!isAuthorized) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN,
						"Sie haben keine Berechtigung, diese Datei herunterzuladen.");
				return;
			}

			serveFile(filePathFromDb, filenameForDownload, user, response);

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Die angegebene ID ist ungültig.");
		}
	}

	private boolean isUserAuthorizedForAttachment(User user, Attachment attachment) {
		if (user.hasAdminAccess()) {
			return true;
		}
		if ("NUTZER".equalsIgnoreCase(attachment.getRequiredRole())) {
			if ("EVENT".equals(attachment.getParentType())) {
				return eventDAO.isUserAssociatedWithEvent(attachment.getParentId(), user.getId());
			} else if ("MEETING".equals(attachment.getParentType())) {
				return meetingDAO.isUserAssociatedWithMeeting(attachment.getParentId(), user.getId());
			}
		}
		return false;
	}

	private void serveFile(String relativePathFromDb, String originalFilename, User user, HttpServletResponse response)
			throws IOException {
		if (relativePathFromDb == null || relativePathFromDb.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Der Dateipfad in der Datenbank ist ungültig.");
			return;
		}

		File baseDir = new File(configService.getProperty("upload.directory"));
		File requestedFile = new File(baseDir, relativePathFromDb);

		String baseDirCanonicalPath = baseDir.getCanonicalPath();
		String requestedFileCanonicalPath = requestedFile.getCanonicalPath();

		if (!requestedFileCanonicalPath.startsWith(baseDirCanonicalPath)) {
			logger.fatal("CRITICAL: Path Traversal Attack Detected! User: '{}' attempted to access '{}'",
					user.getUsername(), requestedFileCanonicalPath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (!requestedFile.exists() || !requestedFile.isFile()) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Die Datei wurde auf dem Server nicht gefunden.");
			return;
		}

		response.setContentType("application/octet-stream");
		response.setContentLengthLong(requestedFile.length());
		String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+", "%20");
		response.setHeader("Content-Disposition", "attachment; filename*=UTF-8''" + encodedFilename);

		try (FileInputStream inStream = new FileInputStream(requestedFile);
				OutputStream outStream = response.getOutputStream()) {
			inStream.transferTo(outStream);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventActionServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class EventActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventActionServlet.class);
	private final EventDAO eventDAO;
	private final EventCustomFieldDAO customFieldDAO;

	@Inject
	public EventActionServlet(EventDAO eventDAO, EventCustomFieldDAO customFieldDAO) {
		this.eventDAO = eventDAO;
		this.customFieldDAO = customFieldDAO;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String eventIdParam = request.getParameter("eventId");

		if (user == null || action == null || eventIdParam == null) {
			response.sendRedirect(request.getContextPath() + "/veranstaltungen");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.info("User '{}' (ID: {}) is performing action '{}' on event ID {}", user.getUsername(), user.getId(),
					action, eventId);

			if ("signup".equals(action)) {
				eventDAO.signUpForEvent(user.getId(), eventId);
				List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
				for (EventCustomField field : fields) {
					String paramName = "customfield_" + field.getId();
					String paramValue = request.getParameter(paramName);
					if (paramValue != null) {
						EventCustomFieldResponse customResponse = new EventCustomFieldResponse();
						customResponse.setFieldId(field.getId());
						customResponse.setUserId(user.getId());
						customResponse.setResponseValue(paramValue);
						customFieldDAO.saveResponse(customResponse);
					}
				}
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Event angemeldet.");
			} else if ("signoff".equals(action)) {
				eventDAO.signOffFromEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Event abgemeldet.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in EventActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventChatApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.model.EventChatMessage;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class EventChatApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventChatApiServlet.class);
	private final EventChatDAO chatDAO;
	private final Gson gson;

	@Inject
	public EventChatApiServlet(EventChatDAO chatDAO) {
		this.chatDAO = chatDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			logger.trace("GET request for chat history for event ID: {}", eventId);
			List<EventChatMessage> messages = chatDAO.getMessagesForEvent(eventId);
			String jsonResponse = gson.toJson(messages);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat history API: Invalid or missing eventId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing eventId.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventCustomFieldsApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.model.EventCustomField;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

@Singleton
public class EventCustomFieldsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventCustomFieldsApiServlet.class);
	private final EventCustomFieldDAO customFieldDAO;
	private final Gson gson;

	@Inject
	public EventCustomFieldsApiServlet(EventCustomFieldDAO customFieldDAO) {
		this.customFieldDAO = customFieldDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String eventIdParam = request.getParameter("eventId");
		if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
			logger.warn("API call rejected: eventId parameter is missing.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required 'eventId' parameter.");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.debug("API request for custom fields for event ID: {}", eventId);

			List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
			String jsonResponse = gson.toJson(fields);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);

		} catch (NumberFormatException e) {
			logger.warn("API call rejected: Invalid eventId format '{}'.", eventIdParam);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid 'eventId' format. It must be a number.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.*;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
public class EventDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventDetailsServlet.class);
	private final EventDAO eventDAO;
	private final EventTaskDAO taskDAO;
	private final EventChatDAO chatDAO;
	private final AttachmentDAO attachmentDAO;
	private final StorageDAO storageDAO;
	private final InventoryKitDAO kitDAO;
	private final Gson gson;

	@Inject
	public EventDetailsServlet(EventDAO eventDAO, EventTaskDAO taskDAO, EventChatDAO chatDAO,
			AttachmentDAO attachmentDAO, StorageDAO storageDAO, InventoryKitDAO kitDAO) {
		this.eventDAO = eventDAO;
		this.taskDAO = taskDAO;
		this.chatDAO = chatDAO;
		this.attachmentDAO = attachmentDAO;
		this.storageDAO = storageDAO;
		this.kitDAO = kitDAO;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(request.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);

			if (event == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event nicht gefunden.");
				return;
			}

			boolean isGlobalAdmin = user.getPermissions().contains("EVENT_MANAGE_TASKS") || user.hasAdminAccess();
			boolean isEventLeader = user.getId() == event.getLeaderUserId();
			boolean hasTaskManagementPermission = isGlobalAdmin || isEventLeader;
			request.setAttribute("hasTaskManagementPermission", hasTaskManagementPermission);

			String userRoleForAttachments = (hasTaskManagementPermission) ? "ADMIN" : "NUTZER";
			List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
			boolean isUserAssigned = assignedUsers.stream().anyMatch(u -> u.getId() == user.getId());
			request.setAttribute("isUserAssigned", isUserAssigned);

			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			boolean isUserParticipant = signedUpUsers.stream().anyMatch(u -> u.getId() == user.getId());
			request.setAttribute("isUserParticipant", isUserParticipant);

			event.setAttachments(attachmentDAO.getAttachmentsForParent("EVENT", eventId, userRoleForAttachments));
			event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
			event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
			event.setAssignedAttendees(assignedUsers);
			event.setEventTasks(taskDAO.getTasksForEvent(eventId));

			if ("LAUFEND".equalsIgnoreCase(event.getStatus())) {
				event.setChatMessages(chatDAO.getMessagesForEvent(eventId));
			} else {
				event.setChatMessages(new ArrayList<>());
			}

			request.setAttribute("event", event);
			if (hasTaskManagementPermission) {
				request.setAttribute("assignedUsersJson", gson.toJson(assignedUsers));
				request.setAttribute("allItemsJson", gson.toJson(storageDAO.getAllItems()));
				request.setAttribute("allKitsJson", gson.toJson(kitDAO.getAllKits()));
				request.setAttribute("tasksJson", gson.toJson(event.getEventTasks()));
			}

			request.getRequestDispatcher("/views/public/eventDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
public class EventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventServlet.class);
	private final EventDAO eventDAO;

	@Inject
	public EventServlet(EventDAO eventDAO) {
		this.eventDAO = eventDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		// CORRECTED: Added a defensive null check
		if (user == null) {
			logger.warn("EventServlet accessed without an authenticated user. Redirecting to login.");
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		logger.info("Fetching upcoming events for user '{}' (ID: {})", user.getUsername(), user.getId());

		List<Event> allUpcomingEvents = eventDAO.getAllActiveAndUpcomingEvents();
		List<Event> qualifiedEvents = eventDAO.getUpcomingEventsForUser(user, 0);
		List<Integer> qualifiedEventIds = qualifiedEvents.stream().map(Event::getId).collect(Collectors.toList());

		for (Event event : allUpcomingEvents) {
			event.setUserQualified(qualifiedEventIds.contains(event.getId()));
			qualifiedEvents.stream().filter(qe -> qe.getId() == event.getId()).findFirst()
					.ifPresent(qe -> event.setUserAttendanceStatus(qe.getUserAttendanceStatus()));
			if (event.getUserAttendanceStatus() == null) {
				event.setUserAttendanceStatus("OFFEN");
			}
		}

		request.setAttribute("events", allUpcomingEvents);
		logger.debug("Found {} upcoming events for user '{}'. Forwarding to veranstaltungen.jsp.",
				allUpcomingEvents.size(), user.getUsername());
		request.getRequestDispatcher("/views/public/events.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FeedbackServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.Event;
import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import de.technikteam.model.FeedbackSubmission;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@Singleton
public class FeedbackServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final EventFeedbackDAO eventFeedbackDAO;
	private final FeedbackSubmissionDAO submissionDAO;
	private final EventDAO eventDAO;

	@Inject
	public FeedbackServlet(EventFeedbackDAO eventFeedbackDAO, FeedbackSubmissionDAO submissionDAO, EventDAO eventDAO) {
		this.eventFeedbackDAO = eventFeedbackDAO;
		this.submissionDAO = submissionDAO;
		this.eventDAO = eventDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");

		if ("submitEventFeedback".equals(action)) {
			showSubmitEventFeedbackForm(request, response, user);
			return;
		}

		request.getRequestDispatcher("/views/public/feedback.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		if ("submitGeneralFeedback".equals(action)) {
			handleGeneralFeedback(request, response, user);
		} else if ("submitEventFeedbackResponse".equals(action)) {
			handleEventFeedbackResponse(request, response, user);
		} else {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unknown action");
		}
	}

	private void handleGeneralFeedback(HttpServletRequest request, HttpServletResponse response, User user)
			throws ServletException, IOException {
		String subject = request.getParameter("subject");
		String content = request.getParameter("content");

		if (subject == null || subject.trim().isEmpty() || content == null || content.trim().isEmpty()) {
			request.setAttribute("errorMessage", "Betreff und Inhalt dürfen nicht leer sein.");
			request.getRequestDispatcher("/views/public/feedback.jsp").forward(request, response);
			return;
		}

		FeedbackSubmission submission = new FeedbackSubmission();
		submission.setUserId(user.getId());
		submission.setSubject(subject);
		submission.setContent(content);

		if (submissionDAO.createSubmission(submission)) {
			request.getSession().setAttribute("successMessage",
					"Vielen Dank! Dein Feedback wurde erfolgreich übermittelt.");
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			request.setAttribute("errorMessage",
					"Dein Feedback konnte nicht übermittelt werden. Bitte versuche es später erneut.");
			request.getRequestDispatcher("/views/public/feedback.jsp").forward(request, response);
		}
	}

	private void handleEventFeedbackResponse(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		int formId = Integer.parseInt(request.getParameter("formId"));
		int rating = Integer.parseInt(request.getParameter("rating"));
		String comments = request.getParameter("comments");

		FeedbackResponse feedbackResponse = new FeedbackResponse();
		feedbackResponse.setFormId(formId);
		feedbackResponse.setUserId(user.getId());
		feedbackResponse.setRating(rating);
		feedbackResponse.setComments(comments);

		eventFeedbackDAO.saveFeedbackResponse(feedbackResponse);
		request.getSession().setAttribute("successMessage", "Vielen Dank für dein Feedback!");
		response.sendRedirect(request.getContextPath() + "/profil");
	}

	private void showSubmitEventFeedbackForm(HttpServletRequest request, HttpServletResponse response, User user)
			throws ServletException, IOException {
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		FeedbackForm form = eventFeedbackDAO.getFeedbackFormForEvent(eventId);

		if (form == null) {
			form = new FeedbackForm();
			form.setEventId(eventId);
			form.setTitle("Feedback für Event: " + (event != null ? event.getName() : "Unbekannt"));
			int formId = eventFeedbackDAO.createFeedbackForm(form);
			form.setId(formId);
		}

		if (eventFeedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId())) {
			request.getSession().setAttribute("infoMessage", "Du hast bereits Feedback für dieses Event abgegeben.");
			response.sendRedirect(request.getContextPath() + "/profil");
			return;
		}

		request.setAttribute("event", event);
		request.setAttribute("form", form);
		request.getRequestDispatcher("/views/public/feedback_form.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FileServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Singleton
public class FileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FileServlet.class);
	private final FileDAO fileDAO;

	@Inject
	public FileServlet(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("File page requested by user '{}' (Role: {})", user.getUsername(), user.getRoleName());

		Map<String, List<File>> fileData = fileDAO.getAllFilesGroupedByCategory(user);

		request.setAttribute("fileData", fileData);
		logger.debug("Forwarding file data to dateien.jsp.");
		request.getRequestDispatcher("/views/public/dateien.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\HomeServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class HomeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(HomeServlet.class);
	private final EventDAO eventDAO;
	private final EventTaskDAO eventTaskDAO;

	@Inject
	public HomeServlet(EventDAO eventDAO, EventTaskDAO eventTaskDAO) {
		this.eventDAO = eventDAO;
		this.eventTaskDAO = eventTaskDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		// CORRECTED: Added a defensive null check. This is a critical safeguard.
		// If for any reason a request reaches this servlet without an authenticated
		// user,
		// it will be safely redirected instead of causing a 500 error.
		if (user == null) {
			logger.warn("HomeServlet accessed without an authenticated user in the session. Redirecting to login.");
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		logger.info("Home page requested by user '{}'. Fetching dashboard data.", user.getUsername());

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getUpcomingEventsForUser(user, 5);

		logger.debug("Fetched {} assigned events, {} open tasks, and {} general upcoming events.",
				assignedEvents.size(), openTasks.size(), upcomingEvents.size());

		request.setAttribute("assignedEvents", assignedEvents);
		request.setAttribute("openTasks", openTasks);
		request.setAttribute("upcomingEvents", upcomingEvents);

		logger.debug("Forwarding to the correct home.jsp path.");
		request.getRequestDispatcher("/views/public/home.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\IcalServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.*;
import net.fortuna.ical4j.util.RandomUidGenerator;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.List;

@Singleton
public class IcalServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Inject
	public IcalServlet(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-//TechnikTeam Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
					+ request.getContextPath();
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());

				if (event.getEventDateTime() != null) {
					ZonedDateTime zdtStart = event.getEventDateTime().atZone(systemZone);
					Date utilDateStart = Date.from(zdtStart.toInstant());
					vEvent.getProperties().add(new DtStart(new DateTime(utilDateStart)));
				}
				if (event.getEndDateTime() != null) {
					ZonedDateTime zdtEnd = event.getEndDateTime().atZone(systemZone);
					Date utilDateEnd = Date.from(zdtEnd.toInstant());
					vEvent.getProperties().add(new DtEnd(new DateTime(utilDateEnd)));
				}

				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				try {
					vEvent.getProperties()
							.add(new Url(new URI(baseUrl + "/veranstaltungen/details?id=" + event.getId())));
				} catch (URISyntaxException ignored) {
				}
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());

				if (meeting.getMeetingDateTime() != null) {
					ZonedDateTime zdtStart = meeting.getMeetingDateTime().atZone(systemZone);
					Date utilDateStart = Date.from(zdtStart.toInstant());
					vMeeting.getProperties().add(new DtStart(new DateTime(utilDateStart)));
				}
				if (meeting.getEndDateTime() != null) {
					ZonedDateTime zdtEnd = meeting.getEndDateTime().atZone(systemZone);
					Date utilDateEnd = Date.from(zdtEnd.toInstant());
					vMeeting.getProperties().add(new DtEnd(new DateTime(utilDateEnd)));
				}

				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				try {
					vMeeting.getProperties().add(new Url(new URI(baseUrl + "/meetingDetails?id=" + meeting.getId())));
				} catch (URISyntaxException ignored) {
				}
				calendar.getComponents().add(vMeeting);
			}

			response.setContentType("text/calendar; charset=utf-8");
			response.setHeader("Content-Disposition", "inline; filename=\"technikteam-calendar.ics\"");
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, response.getOutputStream());

		} catch (Exception e) {
			throw new ServletException("Error generating iCal feed", e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ImageServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

@Singleton
public class ImageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(ImageServlet.class);
	private final ConfigurationService configService;

	@Inject
	public ImageServlet(ConfigurationService configService) {
		this.configService = configService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Authentication required.");
			return;
		}
		User user = (User) session.getAttribute("user");

		String filename = request.getParameter("file");
		if (filename == null || filename.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing 'file' parameter.");
			return;
		}

		try {
			filename = URLDecoder.decode(filename, StandardCharsets.UTF_8.toString());
		} catch (IllegalArgumentException e) {
			logger.warn("Could not decode filename: {}", filename, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid filename encoding.");
			return;
		}

		File imageUploadDir = new File(configService.getProperty("upload.directory"), "images");
		String imageDirCanonicalPath = imageUploadDir.getCanonicalPath();

		File imageFile = new File(imageUploadDir, filename);
		String requestedFileCanonicalPath = imageFile.getCanonicalPath();

		if (!requestedFileCanonicalPath.startsWith(imageDirCanonicalPath)) {
			String username = (user != null) ? user.getUsername() : "GUEST";
			logger.fatal(
					"CRITICAL: Path Traversal Attack Detected! User: '{}' attempted to access '{}' via image servlet.",
					username, requestedFileCanonicalPath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (!imageFile.exists() || !imageFile.isFile()) {
			logger.warn("Image not found at path: {}", imageFile.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Image not found.");
			return;
		}

		String contentType = getServletContext().getMimeType(imageFile.getName());
		if (contentType == null) {
			contentType = "application/octet-stream";
		}

		response.setContentType(contentType);
		response.setContentLengthLong(imageFile.length());
		response.setHeader("Content-Disposition", "inline; filename=\"" + imageFile.getName() + "\"");

		logger.debug("Serving image: {} with content type {}", imageFile.getAbsolutePath(), contentType);

		try (FileInputStream inStream = new FileInputStream(imageFile);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;

			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LoginServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import de.technikteam.dao.UserDAO;

@Singleton
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LoginServlet.class);
	private final UserDAO userDAO;

	public static class LoginAttemptManager {
		private static final int MAX_ATTEMPTS = 5;
		private static final long[] LOCKOUT_DURATIONS_MS = { TimeUnit.MINUTES.toMillis(1), TimeUnit.MINUTES.toMillis(2),
				TimeUnit.MINUTES.toMillis(5), TimeUnit.MINUTES.toMillis(10), TimeUnit.MINUTES.toMillis(30) };
		private static final Map<String, Integer> failedAttempts = new ConcurrentHashMap<>();
		private static final Map<String, Long> lockoutTimestamps = new ConcurrentHashMap<>();
		private static final Map<String, Integer> lockoutLevel = new ConcurrentHashMap<>();

		public static long getLockoutEndTime(String username) {
			return lockoutTimestamps.getOrDefault(username, 0L);
		}

		public static int getLockoutLevel(String username) {
			return lockoutLevel.getOrDefault(username, 0);
		}

		public static boolean isLockedOut(String username) {
			Long lockoutTime = lockoutTimestamps.get(username);
			if (lockoutTime == null)
				return false;
			int currentLevel = lockoutLevel.getOrDefault(username, 0);
			long duration = LOCKOUT_DURATIONS_MS[Math.min(currentLevel, LOCKOUT_DURATIONS_MS.length - 1)];
			return System.currentTimeMillis() - lockoutTime <= duration;
		}

		public static void recordFailedLogin(String username) {
			int attempts = failedAttempts.compute(username, (k, v) -> (v == null) ? 1 : v + 1);
			if (attempts >= MAX_ATTEMPTS) {
				int currentLevel = lockoutLevel.compute(username, (k, v) -> (v == null) ? 0 : v + 1);
				long duration = LOCKOUT_DURATIONS_MS[Math.min(currentLevel, LOCKOUT_DURATIONS_MS.length - 1)];
				logger.warn("Locking out user {} for {} minutes due to {} failed login attempts.", username,
						TimeUnit.MILLISECONDS.toMinutes(duration), attempts);
				lockoutTimestamps.put(username, System.currentTimeMillis());
				failedAttempts.remove(username);
			}
		}

		public static void clearLoginAttempts(String username) {
			failedAttempts.remove(username);
			lockoutTimestamps.remove(username);
			lockoutLevel.remove(username);
		}
	}

	@Inject
	public LoginServlet(UserDAO userDAO) {
		this.userDAO = userDAO;
	}

	private String sanitizeForLogging(String input) {
		if (input == null)
			return "";
		return input.replace('\n', '_').replace('\r', '_');
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		String sanitizedUsername = sanitizeForLogging(username);
		HttpSession session = request.getSession(true);

		if (LoginAttemptManager.isLockedOut(sanitizedUsername)) {
			session.setAttribute("errorMessage",
					"Ihr Konto ist aufgrund zu vieler fehlgeschlagener Versuche vorübergehend gesperrt.");
			session.setAttribute("lockoutEndTime", LoginAttemptManager.getLockoutEndTime(sanitizedUsername));
			session.setAttribute("lockoutLevel", LoginAttemptManager.getLockoutLevel(sanitizedUsername));
			session.setAttribute("failedUsername", username);
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		User user = userDAO.validateUser(username, password);

		if (user != null) {
			LoginAttemptManager.clearLoginAttempts(sanitizedUsername);
			session.invalidate();
			HttpSession newSession = request.getSession(true);
			newSession.setAttribute("user", user);
			CSRFUtil.storeToken(newSession);
			List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(user);
			newSession.setAttribute("navigationItems", navigationItems);
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			LoginAttemptManager.recordFailedLogin(sanitizedUsername);
			session.setAttribute("errorMessage", "Benutzername oder Passwort ungültig.");
			session.setAttribute("failedUsername", username);
			if (LoginAttemptManager.isLockedOut(sanitizedUsername)) {
				session.setAttribute("lockoutEndTime", LoginAttemptManager.getLockoutEndTime(sanitizedUsername));
				session.setAttribute("lockoutLevel", LoginAttemptManager.getLockoutLevel(sanitizedUsername));
			}
			response.sendRedirect(request.getContextPath() + "/login");
		}
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/auth/login.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LogoutServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.inject.Singleton;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

@Singleton
public class LogoutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LogoutServlet.class);

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);

		if (session != null) {
			User user = (User) session.getAttribute("user");
			String username = (user != null) ? user.getUsername() : "Gast";

			logger.info("Logging out user: {}. Invalidating session.", username);
			session.invalidate();
		} else {
			logger.warn("LogoutServlet called but no active session found.");
		}

		HttpSession newSession = request.getSession(true);
		newSession.setAttribute("successMessage", "Sie wurden erfolgreich ausgeloggt.");
		response.sendRedirect(request.getContextPath() + "/login");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MarkdownEditorServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.ConfigurationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;

@Singleton
public class MarkdownEditorServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MarkdownEditorServlet.class);
	private final FileDAO fileDAO;
	private final ConfigurationService configService;

	@Inject
	public MarkdownEditorServlet(FileDAO fileDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.configService = configService;
	}

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		String fileIdParam = request.getParameter("fileId");
		if (fileIdParam == null || fileIdParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing fileId parameter.");
			return;
		}

		int fileId;
		try {
			fileId = Integer.parseInt(fileIdParam);
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid fileId format.");
			return;
		}

		de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);
		if (dbFile == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "File not found.");
			return;
		}

		boolean canUpdate = user.getPermissions().contains("FILE_UPDATE")
				|| user.getPermissions().contains("ACCESS_ADMIN_PANEL");
		boolean canRead = user.getPermissions().contains("FILE_READ");

		if (canUpdate) {
			request.setAttribute("editorMode", "edit");
		} else if (canRead) {
			request.setAttribute("editorMode", "view");
		} else {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access denied.");
			return;
		}

		String fileContent;
		try {
			java.io.File physicalFile = new java.io.File(configService.getProperty("upload.directory"),
					dbFile.getFilepath());
			fileContent = new String(Files.readAllBytes(physicalFile.toPath()), StandardCharsets.UTF_8);
		} catch (NoSuchFileException e) {
			logger.error("File record found in DB for ID {} but physical file is missing at path: {}", fileId,
					dbFile.getFilepath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Physical file not found on server.");
			return;
		} catch (IOException e) {
			logger.error("Could not read file content for fileId {}", fileId, e);
			response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Could not read file content.");
			return;
		}

		request.setAttribute("file", dbFile);
		request.setAttribute("fileContent", fileContent);
		request.getRequestDispatcher("/views/admin/admin_editor.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingActionServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class MeetingActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingActionServlet.class);
	private final MeetingAttendanceDAO attendanceDAO;

	@Inject
	public MeetingActionServlet(MeetingAttendanceDAO attendanceDAO) {
		this.attendanceDAO = attendanceDAO;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for meeting action by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		String meetingIdParam = request.getParameter("meetingId");

		if (user == null || action == null || meetingIdParam == null) {
			logger.warn("Invalid request to MeetingActionServlet. Missing user, action, or meetingId.");
			response.sendRedirect(request.getContextPath() + "/lehrgaenge");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			logger.info("User '{}' (ID: {}) performing action '{}' on meeting ID {}", user.getUsername(), user.getId(),
					action, meetingId);

			if ("signup".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, true, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Meeting angemeldet.");
			} else if ("signoff".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, false, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Meeting abgemeldet.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format in MeetingActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Meeting-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/lehrgaenge");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class MeetingDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingDetailsServlet.class);
	private final MeetingDAO meetingDAO;
	private final AttachmentDAO attachmentDAO;

	@Inject
	public MeetingDetailsServlet(MeetingDAO meetingDAO, AttachmentDAO attachmentDAO) {
		this.meetingDAO = meetingDAO;
		this.attachmentDAO = attachmentDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String meetingIdParam = request.getParameter("id");
		if (meetingIdParam == null || meetingIdParam.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Meeting-ID fehlt.");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			User user = (User) request.getSession().getAttribute("user");
			logger.info("Meeting details for ID {} requested by user '{}'", meetingId, user.getUsername());

			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden.");
				return;
			}

			boolean hasAdminRights = user.getPermissions().contains("ACCESS_ADMIN_PANEL")
					|| user.getPermissions().contains("COURSE_READ");
			boolean isLeader = user.getId() == meeting.getLeaderUserId();
			boolean isParticipant = meetingDAO.isUserAssociatedWithMeeting(meetingId, user.getId());

			if (!hasAdminRights && !isLeader && !isParticipant) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN,
						"Sie sind nicht berechtigt, diese Meeting-Details anzuzeigen.");
				return;
			}

			String attachmentUserRole = (hasAdminRights || isLeader) ? "ADMIN" : "NUTZER";
			request.setAttribute("attachments",
					attachmentDAO.getAttachmentsForParent("MEETING", meetingId, attachmentUserRole));
			request.setAttribute("meeting", meeting);
			request.getRequestDispatcher("/views/public/meetingDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format: {}", meetingIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class MeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingServlet.class);
	private final MeetingDAO meetingDAO;

	@Inject
	public MeetingServlet(MeetingDAO meetingDAO) {
		this.meetingDAO = meetingDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming meetings for user '{}' (ID: {})", user.getUsername(), user.getId());

		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);

		request.setAttribute("meetings", meetings);
		logger.debug("Found {} upcoming meetings. Forwarding to lehrgaenge.jsp.", meetings.size());
		request.getRequestDispatcher("/views/public/lehrgaenge.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MyFeedbackServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.FeedbackSubmission;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.List;

@Singleton
public class MyFeedbackServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final FeedbackSubmissionDAO submissionDAO;

	@Inject
	public MyFeedbackServlet(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		List<FeedbackSubmission> mySubmissions = submissionDAO.getSubmissionsByUserId(user.getId());
		request.setAttribute("mySubmissions", mySubmissions);
		request.getRequestDispatcher("/views/public/my_feedback.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\NotificationServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import com.google.inject.Singleton;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

@Singleton
public class NotificationServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(NotificationServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Unauthorized attempt to connect to SSE stream. No session.");
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		de.technikteam.model.User user = (de.technikteam.model.User) session.getAttribute("user");
		logger.info("Client '{}' connecting to SSE stream.", user.getUsername());

		response.setContentType("text/event-stream");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Cache-Control", "no-cache");
		response.setHeader("Connection", "keep-alive");

		NotificationService.getInstance().register(request);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PackKitServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class PackKitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PackKitServlet.class);

	private final InventoryKitDAO kitDAO;

	@Inject
	public PackKitServlet(InventoryKitDAO kitDAO) {
		this.kitDAO = kitDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String kitIdParam = request.getParameter("kitId");
		if (kitIdParam == null || kitIdParam.isEmpty()) {
			logger.warn("Pack kit page requested with no kitId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Kit-ID fehlt.");
			return;
		}

		try {
			int kitId = Integer.parseInt(kitIdParam);
			InventoryKit kit = kitDAO.getKitById(kitId);

			if (kit == null) {
				logger.warn("Pack kit page requested for non-existent kitId: {}", kitId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Kit nicht gefunden.");
				return;
			}

			List<InventoryKitItem> kitItems = kitDAO.getItemsForKit(kitId);

			request.setAttribute("kit", kit);
			request.setAttribute("kitItems", kitItems);

			request.getRequestDispatcher("/views/public/pack_kit.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid kitId format: {}", kitIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Kit-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PasswordServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.PasswordPolicyValidator;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class PasswordServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PasswordServlet.class);
	private final UserDAO userDAO;

	@Inject
	public PasswordServlet(UserDAO userDAO) {
		this.userDAO = userDAO;
		logger.info("PasswordServlet initialized with injected UserDAO.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received, showing password change form.");
		request.getRequestDispatcher("/views/public/passwort.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		User user = (session != null) ? (User) session.getAttribute("user") : null;

		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for password change attempt by user '{}'", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid or missing CSRF token.");
			return;
		}

		logger.info("Password change attempt for user: {}", user.getUsername());

		String currentPassword = request.getParameter("currentPassword");
		String newPassword = request.getParameter("newPassword");
		String confirmPassword = request.getParameter("confirmPassword");

		User authenticatedUser = userDAO.validateUser(user.getUsername(), currentPassword);
		if (authenticatedUser == null) {
			logger.warn("Password change failed for {}: incorrect current password.", user.getUsername());
			session.setAttribute("errorMessage", "Das aktuelle Passwort ist nicht korrekt.");
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		if (!newPassword.equals(confirmPassword)) {
			logger.warn("Password change failed for {}: new passwords do not match.", user.getUsername());
			session.setAttribute("errorMessage", "Die neuen Passwörter stimmen nicht überein.");
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator.validate(newPassword);
		if (!validationResult.isValid()) {
			logger.warn("Password change for user '{}' failed due to weak password: {}", user.getUsername(),
					validationResult.getMessage());
			session.setAttribute("errorMessage", validationResult.getMessage());
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		boolean success = userDAO.changePassword(user.getId(), newPassword);
		if (success) {
			logger.info("Password successfully changed for user: {}", user.getUsername());
			CSRFUtil.storeToken(session);
			session.setAttribute("successMessage", "Ihr Passwort wurde erfolgreich geändert.");
		} else {
			logger.error("Password change failed for {} due to a DAO error.", user.getUsername());
			session.setAttribute("errorMessage", "Ein interner Fehler ist aufgetreten. Bitte versuchen Sie es erneut.");
		}
		response.sendRedirect(request.getContextPath() + "/passwort");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ProfileServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.*;
import de.technikteam.model.*;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@Singleton
public class ProfileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(ProfileServlet.class);
	private final EventDAO eventDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final UserDAO userDAO;
	private final AchievementDAO achievementDAO;
	private final PasskeyDAO passkeyDAO;
	private final ProfileChangeRequestDAO requestDAO;
	private final Gson gson = new Gson();

	@Inject
	public ProfileServlet(EventDAO eventDAO, UserQualificationsDAO qualificationsDAO, UserDAO userDAO,
			AchievementDAO achievementDAO, PasskeyDAO passkeyDAO, ProfileChangeRequestDAO requestDAO) {
		this.eventDAO = eventDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.userDAO = userDAO;
		this.achievementDAO = achievementDAO;
		this.passkeyDAO = passkeyDAO;
		this.requestDAO = requestDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		List<Event> eventHistory = eventDAO.getEventHistoryForUser(user.getId());
		List<UserQualification> qualifications = qualificationsDAO.getQualificationsForUser(user.getId());
		List<Achievement> achievements = achievementDAO.getAchievementsForUser(user.getId());
		List<PasskeyCredential> passkeys = passkeyDAO.getCredentialsByUserId(user.getId());
		boolean hasPendingRequest = requestDAO.hasPendingRequest(user.getId());

		request.setAttribute("eventHistory", eventHistory);
		request.setAttribute("qualifications", qualifications);
		request.setAttribute("achievements", achievements);
		request.setAttribute("passkeys", passkeys);
		request.setAttribute("hasPendingRequest", hasPendingRequest);

		request.getRequestDispatcher("/views/public/profile.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User user = (User) session.getAttribute("user");
		String action = request.getParameter("action");

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for profile action '{}' by user '{}'", action,
					user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		switch (action != null ? action : "") {
		case "deletePasskey":
			handleDeletePasskey(request, response, user);
			break;
		case "updateChatColor":
			handleUpdateChatColor(request, response, user);
			break;
		case "requestProfileChange":
			handleProfileChangeRequest(request, response, user);
			break;
		default:
			logger.warn("Unknown POST action '{}' received for /profil", action);
			response.sendRedirect(request.getContextPath() + "/profil");
			break;
		}
	}

	private void handleProfileChangeRequest(HttpServletRequest request, HttpServletResponse response, User currentUser)
			throws IOException {
		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");

		Map<String, String> changes = new HashMap<>();
		String newEmail = request.getParameter("email");
		if (!Objects.equals(currentUser.getEmail(), newEmail)) {
			changes.put("email", newEmail);
		}

		int newClassYear = 0;
		try {
			String classYearParam = request.getParameter("classYear");
			if (classYearParam != null && !classYearParam.isEmpty()) {
				newClassYear = Integer.parseInt(classYearParam);
			}
		} catch (NumberFormatException e) {
			/* keep 0 */ }
		if (currentUser.getClassYear() != newClassYear) {
			changes.put("classYear", String.valueOf(newClassYear));
		}

		String newClassName = request.getParameter("className");
		if (!Objects.equals(currentUser.getClassName(), newClassName)) {
			changes.put("className", newClassName);
		}

		if (changes.isEmpty()) {
			response.getWriter().write(gson.toJson(ApiResponse.error("Keine Änderungen festgestellt.")));
			return;
		}

		ProfileChangeRequest pcr = new ProfileChangeRequest();
		pcr.setUserId(currentUser.getId());
		pcr.setRequestedChanges(gson.toJson(changes));

		if (requestDAO.createRequest(pcr)) {
			response.getWriter().write(gson.toJson(ApiResponse.success("Änderungsantrag erfolgreich eingereicht.")));
		} else {
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			response.getWriter().write(gson.toJson(ApiResponse.error("Antrag konnte nicht gespeichert werden.")));
		}
	}

	private void handleUpdateChatColor(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		String chatColor = request.getParameter("chatColor");
		if (user != null && chatColor != null) {
			if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
				user.setChatColor(chatColor);
				request.getSession().setAttribute("user", user);
				request.getSession().setAttribute("successMessage", "Chat-Farbe erfolgreich gespeichert!");
			} else {
				request.getSession().setAttribute("errorMessage", "Farbe konnte nicht gespeichert werden.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/profil");
	}

	private void handleDeletePasskey(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		try {
			int credentialDbId = Integer.parseInt(request.getParameter("credentialId"));
			if (passkeyDAO.deleteCredential(credentialDbId, user.getId())) {
				request.getSession().setAttribute("successMessage", "Passkey erfolgreich entfernt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Passkey konnte nicht entfernt werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Passkey-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/profil");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\RootServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Singleton;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;

@Singleton
public class RootServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		User user = (session != null) ? (User) session.getAttribute("user") : null;

		if (user != null) {
			// User is logged in, redirect to the home page.
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			// User is not logged in, redirect to the login page.
			response.sendRedirect(request.getContextPath() + "/login");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemActionServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.List;

@Singleton
public class StorageItemActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Inject
	public StorageItemActionServlet(StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			List<Event> activeEvents = eventDAO.getActiveEvents();

			if (item == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}
			request.setAttribute("item", item);
			request.setAttribute("activeEvents", activeEvents);
			request.getRequestDispatcher("/views/public/qr_action.jsp").forward(request, response);
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class StorageItemDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageItemDetailsServlet.class);
	private final StorageDAO storageDAO;
	private final StorageLogDAO storageLogDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;

	@Inject
	public StorageItemDetailsServlet(StorageDAO storageDAO, StorageLogDAO storageLogDAO,
			MaintenanceLogDAO maintenanceLogDAO) {
		this.storageDAO = storageDAO;
		this.storageLogDAO = storageLogDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			logger.info("Comprehensive storage item details requested for ID: {}", itemId);

			StorageItem item = storageDAO.getItemById(itemId);
			if (item == null) {
				logger.warn("Storage item with ID {} not found.", itemId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}

			List<StorageLogEntry> history = storageLogDAO.getHistoryForItem(itemId);
			List<MaintenanceLogEntry> maintenanceHistory = maintenanceLogDAO.getHistoryForItem(itemId);

			request.setAttribute("item", item);
			request.setAttribute("history", history);
			request.setAttribute("maintenanceHistory", maintenanceHistory);

			logger.debug("Forwarding to storage_item_details.jsp for item '{}' with {} history entries.",
					item.getName(), history.size());
			request.getRequestDispatcher("/views/public/storage_item_details.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid storage item ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Singleton
public class StorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageServlet.class);
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Inject
	public StorageServlet(StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Main storage page requested. Fetching all items.");

		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		request.setAttribute("storageData", storageData);
		request.setAttribute("activeEvents", activeEvents);
		logger.debug("Forwarding {} location groups to /views/public/lager.jsp.", storageData.size());
		request.getRequestDispatcher("/views/public/lager.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageTransactionServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.model.User;
import de.technikteam.service.StorageService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class StorageTransactionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageTransactionServlet.class);
	private final StorageService storageService;

	@Inject
	public StorageTransactionServlet(StorageService storageService) {
		this.storageService = storageService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for storage transaction by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String redirectUrl = request.getParameter("redirectUrl");
		if (redirectUrl == null || redirectUrl.isEmpty()) {
			redirectUrl = request.getContextPath() + "/lager";
		}

		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			int quantity = Integer.parseInt(request.getParameter("quantity"));
			String type = request.getParameter("type");
			String notes = request.getParameter("notes");
			Integer eventId = null;
			String eventIdParam = request.getParameter("eventId");
			if (eventIdParam != null && !eventIdParam.isEmpty()) {
				eventId = Integer.parseInt(eventIdParam);
				if (eventId == 0)
					eventId = null;
			}

			boolean success = storageService.processTransaction(itemId, quantity, type, user, eventId, notes);

			if (success) {
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				request.getSession().setAttribute("successMessage",
						"Erfolgreich " + quantity + " Stück " + action + ".");
			} else {
				if (request.getSession().getAttribute("errorMessage") == null) {
					request.getSession().setAttribute("errorMessage",
							"Transaktion fehlgeschlagen. Grund: Nicht genügend Bestand oder Artikel ist bereits voll.");
				}
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid number format in storage transaction request.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültiges Zahlenformat.");
		} catch (Exception e) {
			logger.error("Error during storage transaction processing.", e);
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}

		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\TaskActionServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Arrays;

@Singleton
public class TaskActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(TaskActionServlet.class);
	private final EventTaskDAO taskDAO;
	private final EventDAO eventDAO;
	private final AdminLogService adminLogService;

	@Inject
	public TaskActionServlet(EventTaskDAO taskDAO, EventDAO eventDAO, AdminLogService adminLogService) {
		this.taskDAO = taskDAO;
		this.eventDAO = eventDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");

		if (user == null || action == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for task action by user '{}'", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		try {
			switch (action) {
			case "save":
				handleSaveTask(request, response, user);
				break;
			case "delete":
				handleDeleteTask(request, response, user);
				break;
			case "updateStatus":
			case "claim":
			case "unclaim":
				handleUserTaskAction(request, response, user, action);
				break;
			default:
				response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unbekannte Aktion.");
				break;
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in task action request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige ID.");
		}
	}

	private void handleSaveTask(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		boolean hasPermission = user.hasAdminAccess() || (event != null && user.getId() == event.getLeaderUserId());

		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		try {
			int displayOrder = Integer.parseInt(request.getParameter("displayOrder"));
			if (displayOrder < 0) {
				request.getSession().setAttribute("errorMessage", "Die Anzeigereihenfolge darf nicht negativ sein.");
				response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
				return;
			}

			int requiredPersons = 0;
			String assignmentType = request.getParameter("assignmentType");
			if (!"direct".equals(assignmentType)) {
				long requiredPersonsLong = Long.parseLong(request.getParameter("requiredPersons"));
				if (requiredPersonsLong > Integer.MAX_VALUE || requiredPersonsLong < 0) {
					request.getSession().setAttribute("errorMessage",
							"Die Anzahl der benötigten Personen ist ungültig.");
					response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
					return;
				}
				requiredPersons = (int) requiredPersonsLong;
			}

			boolean isUpdate = !request.getParameter("taskId").isEmpty();
			EventTask task = new EventTask();
			task.setEventId(eventId);
			task.setDescription(request.getParameter("description"));
			task.setDetails(request.getParameter("details"));
			task.setDisplayOrder(displayOrder);
			task.setRequiredPersons(requiredPersons);

			if (isUpdate) {
				task.setId(Integer.parseInt(request.getParameter("taskId")));
				task.setStatus(request.getParameter("status"));
			}

			int[] userIds = null;
			if ("direct".equals(assignmentType)) {
				String[] userIdsStr = request.getParameterValues("userIds");
				userIds = userIdsStr == null ? new int[0]
						: Arrays.stream(userIdsStr).mapToInt(Integer::parseInt).toArray();
			}

			String[] itemIds = request.getParameterValues("itemIds");
			String[] itemQuantities = request.getParameterValues("itemQuantities");
			String[] kitIds = request.getParameterValues("kitIds");

			int taskId = taskDAO.saveTask(task, userIds, itemIds, itemQuantities, kitIds);

			if (taskId > 0) {
				String logAction = isUpdate ? "UPDATE_TASK" : "CREATE_TASK";
				String logDetails = String.format("Aufgabe '%s' (ID: %d) für Event '%s' (ID: %d) %s.",
						task.getDescription(), taskId, event.getName(), eventId,
						isUpdate ? "aktualisiert" : "erstellt");
				adminLogService.log(user.getUsername(), logAction, logDetails);
				request.getSession().setAttribute("successMessage", "Aufgabe erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Speichern der Aufgabe.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid number format during task save.", e);
			request.getSession().setAttribute("errorMessage",
					"Ungültiges Zahlenformat für Reihenfolge oder benötigte Personen.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	private void handleDeleteTask(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		EventTask taskToDelete = taskDAO.getTaskById(taskId);
		if (taskToDelete == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Task not found.");
			return;
		}
		int eventId = taskToDelete.getEventId();
		Event event = eventDAO.getEventById(eventId);
		boolean hasPermission = user.hasAdminAccess() || (event != null && user.getId() == event.getLeaderUserId());

		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (taskDAO.deleteTask(taskId)) {
			String eventName = event != null ? event.getName() : "Unbekannt";
			adminLogService.log(user.getUsername(), "DELETE_TASK", "Aufgabe '" + taskToDelete.getDescription()
					+ "' (ID: " + taskId + ") von Event '" + eventName + "' gelöscht.");
			request.getSession().setAttribute("successMessage", "Aufgabe erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Aufgabe konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	private void handleUserTaskAction(HttpServletRequest request, HttpServletResponse response, User user,
			String action) throws IOException {
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		EventTask task = taskDAO.getTaskById(taskId);
		if (task == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Task not found.");
			return;
		}
		Event event = eventDAO.getEventById(task.getEventId());
		if (event == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Associated event not found.");
			return;
		}

		boolean isLeader = event.getLeaderUserId() == user.getId();
		boolean isAdmin = user.hasAdminAccess();
		boolean isTaskAssignee = taskDAO.isUserAssignedToTask(taskId, user.getId());
		boolean isUserParticipant = eventDAO.isUserAssociatedWithEvent(event.getId(), user.getId());

		switch (action) {
		case "updateStatus":
			if (!isAdmin && !isLeader && !isTaskAssignee) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}
			String status = request.getParameter("status");
			if (taskDAO.updateTaskStatus(taskId, status)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						"Status konnte nicht aktualisiert werden.");
			}
			break;
		case "claim":
		case "unclaim":
			if (!isUserParticipant) {
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}
			boolean success = "claim".equals(action) ? taskDAO.claimTask(taskId, user.getId())
					: taskDAO.unclaimTask(taskId, user.getId());
			if (!success) {
				request.getSession().setAttribute("errorMessage", "Aktion fehlgeschlagen.");
			}
			response.sendRedirect(request.getHeader("Referer"));
			break;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAchievementServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

@Singleton
public class AdminAchievementServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAchievementServlet.class);
	private final AchievementDAO achievementDAO;
	private final CourseDAO courseDAO;
	private final AdminLogService adminLogService;
	private final Gson gson;

	@Inject
	public AdminAchievementServlet(AchievementDAO achievementDAO, CourseDAO courseDAO,
			AdminLogService adminLogService) {
		this.achievementDAO = achievementDAO;
		this.courseDAO = courseDAO;
		this.adminLogService = adminLogService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		Set<String> permissions = currentUser.getPermissions();

		if (!permissions.contains("ACHIEVEMENT_CREATE") && !permissions.contains("ACHIEVEMENT_UPDATE")
				&& !permissions.contains("ACHIEVEMENT_DELETE") && !permissions.contains("ACCESS_ADMIN_PANEL")) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = request.getParameter("action");
		if ("getAchievementData".equals(action)) {
			getAchievementDataAsJson(request, response);
			return;
		}

		List<Achievement> achievements = achievementDAO.getAllAchievements();
		List<Course> allCourses = courseDAO.getAllCourses();
		request.setAttribute("achievements", achievements);
		request.setAttribute("allCourses", allCourses);
		request.getRequestDispatcher("/views/admin/admin_achievements.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response, adminUser);
			break;
		case "delete":
			handleDelete(request, response, adminUser);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/achievements");
		}
	}

	private void getAchievementDataAsJson(HttpServletRequest request, HttpServletResponse response) throws IOException {
		try {
			int id = Integer.parseInt(request.getParameter("id"));
			Achievement achievement = achievementDAO.getAchievementById(id);
			if (achievement != null) {
				response.setContentType("application/json");
				response.setCharacterEncoding("UTF-8");
				response.getWriter().write(gson.toJson(achievement));
			} else {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Achievement not found");
			}
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		String idParam = request.getParameter("id");
		boolean isUpdate = idParam != null && !idParam.isEmpty();
		Set<String> permissions = adminUser.getPermissions();
		boolean hasMasterAccess = permissions.contains("ACCESS_ADMIN_PANEL");

		if ((isUpdate && !permissions.contains("ACHIEVEMENT_UPDATE") && !hasMasterAccess)
				|| (!isUpdate && !permissions.contains("ACHIEVEMENT_CREATE") && !hasMasterAccess)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		Achievement achievement = new Achievement();
		achievement.setName(request.getParameter("name"));
		achievement.setDescription(request.getParameter("description"));
		achievement.setIconClass(request.getParameter("icon_class"));

		if (isUpdate) {
			achievement.setId(Integer.parseInt(idParam));
			if (achievementDAO.updateAchievement(achievement)) {
				adminLogService.log(adminUser.getUsername(), "UPDATE_ACHIEVEMENT",
						"Erfolg '" + achievement.getName() + "' (ID: " + achievement.getId() + ") aktualisiert.");
				request.getSession().setAttribute("successMessage", "Erfolg erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Erfolgs.");
			}
		} else {
			achievement.setAchievementKey(request.getParameter("achievement_key"));
			if (achievement.getAchievementKey() == null || achievement.getAchievementKey().trim().isEmpty()) {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Der programmatische Key darf nicht leer sein.");
			} else if (achievementDAO.createAchievement(achievement)) {
				adminLogService.log(adminUser.getUsername(), "CREATE_ACHIEVEMENT",
						"Erfolg '" + achievement.getName() + "' erstellt.");
				request.getSession().setAttribute("successMessage", "Neuer Erfolg erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler beim Erstellen des Erfolgs (Key bereits vorhanden?).");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/achievements");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		if (!adminUser.getPermissions().contains("ACHIEVEMENT_DELETE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}
		try {
			int id = Integer.parseInt(request.getParameter("id"));
			Achievement achievement = achievementDAO.getAchievementById(id);
			if (achievementDAO.deleteAchievement(id)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_ACHIEVEMENT", "Erfolg '"
						+ (achievement != null ? achievement.getName() : "N/A") + "' (ID: " + id + ") gelöscht.");
				request.getSession().setAttribute("successMessage", "Erfolg erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Erfolg konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/achievements");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAttendanceServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;

@Singleton
public class AdminAttendanceServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAttendanceServlet.class);
	private final MeetingAttendanceDAO attendanceDAO;
	private final UserDAO userDAO;
	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;

	@Inject
	public AdminAttendanceServlet(MeetingAttendanceDAO attendanceDAO, UserDAO userDAO, MeetingDAO meetingDAO,
			AdminLogService adminLogService) {
		this.attendanceDAO = attendanceDAO;
		this.userDAO = userDAO;
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}
		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			int meetingId = Integer.parseInt(request.getParameter("meetingId"));
			boolean attended = "true".equals(request.getParameter("attended"));
			String remarks = request.getParameter("remarks");

			if (attendanceDAO.setAttendance(userId, meetingId, attended, remarks)) {
				User targetUser = userDAO.getUserById(userId);
				Meeting meeting = meetingDAO.getMeetingById(meetingId);
				String status = attended ? "TEILGENOMMEN" : "NICHT TEILGENOMMEN";
				String logDetails = String.format(
						"Teilnahme für Nutzer '%s' (ID: %d) bei Meeting '%s' (ID: %d) auf '%s' gesetzt. Bemerkungen: '%s'.",
						(targetUser != null ? targetUser.getUsername() : "N/A"), userId,
						(meeting != null ? meeting.getName() : "N/A"), meetingId, status, remarks);
				adminLogService.log(adminUser.getUsername(), "UPDATE_ATTENDANCE", logDetails);
				request.getSession().setAttribute("successMessage", "Teilnahmestatus erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Teilnahmestatus konnte nicht aktualisiert werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID empfangen.");
		}
		String redirectUrl = request.getContextPath()
				+ ("/matrix".equals(returnTo) ? "/admin/matrix" : "/admin/dashboard");
		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminChangeRequestServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.util.List;

@Singleton
public class AdminChangeRequestServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final ProfileChangeRequestDAO requestDAO;
	private final UserDAO userDAO;

	@Inject
	public AdminChangeRequestServlet(ProfileChangeRequestDAO requestDAO, UserDAO userDAO) {
		this.requestDAO = requestDAO;
		this.userDAO = userDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (!user.getPermissions().contains("USER_UPDATE") && !user.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		List<ProfileChangeRequest> pendingRequests = requestDAO.getPendingRequests();
		request.setAttribute("pendingRequests", pendingRequests);
		request.getRequestDispatcher("/views/admin/admin_requests.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminCourseServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.UserQualificationsDAO;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Objects;

@Singleton
public class AdminCourseServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminCourseServlet.class);
	private final CourseDAO courseDAO;
	private final UserQualificationsDAO userQualificationsDAO;
	private final AdminLogService adminLogService;
	private final Gson gson = new Gson();

	@Inject
	public AdminCourseServlet(CourseDAO courseDAO, UserQualificationsDAO userQualificationsDAO,
			AdminLogService adminLogService) {
		this.courseDAO = courseDAO;
		this.userQualificationsDAO = userQualificationsDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getCourseData".equals(action)) {
			getCourseDataAsJson(req, resp);
			return;
		}
		List<Course> courseList = courseDAO.getAllCourses();
		req.setAttribute("courseList", courseList);
		req.getRequestDispatcher("/views/admin/admin_course_list.jsp").forward(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}
		String action = req.getParameter("action");
		switch (action) {
		case "delete":
			handleDelete(req, resp);
			break;
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "grantQualifications":
			handleGrantQualifications(req, resp);
			break;
		default:
			resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
			break;
		}
	}

	private void getCourseDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			Course course = courseDAO.getCourseById(courseId);
			if (course != null) {
				String courseJson = gson.toJson(course);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(courseJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Course not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid course ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		Course course = new Course();
		course.setName(request.getParameter("name"));
		course.setAbbreviation(request.getParameter("abbreviation"));
		course.setDescription(request.getParameter("description"));

		if (idParam != null && !idParam.isEmpty()) {
			course.setId(Integer.parseInt(idParam));
			Course originalCourse = courseDAO.getCourseById(course.getId());
			if (courseDAO.updateCourse(course) && originalCourse != null) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (ID: %d) aktualisiert. ",
						originalCourse.getName(), course.getId());
				adminLogService.log(adminUser.getUsername(), "UPDATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren der Vorlage.");
			}
		} else {
			if (courseDAO.createCourse(course)) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (Abk.: %s) erstellt.", course.getName(),
						course.getAbbreviation());
				adminLogService.log(adminUser.getUsername(), "CREATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Neue Lehrgangs-Vorlage erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Erstellen der Vorlage.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/lehrgaenge");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			Course courseToDelete = courseDAO.getCourseById(courseId);
			String courseName = (courseToDelete != null) ? courseToDelete.getName() : "N/A";
			if (courseDAO.deleteCourse(courseId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_COURSE",
						"Lehrgangs-Vorlage '" + courseName + "' (ID: " + courseId
								+ ") und alle zugehörigen Meetings, Anhänge und Qualifikationen gelöscht.");
				req.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Vorlage konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Löschvorgang.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
	}

	private void handleGrantQualifications(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("courseId"));
			int minMeetings = Integer.parseInt(req.getParameter("minMeetings"));
			int updatedCount = userQualificationsDAO.batchGrantQualifications(courseId, minMeetings);
			if (updatedCount >= 0) {
				Course course = courseDAO.getCourseById(courseId);
				String courseName = course != null ? course.getName() : "ID " + courseId;
				String logDetails = String.format(
						"Batch-Qualifikation für '%s' an %d Benutzer vergeben (min. %d Meetings).", courseName,
						updatedCount, minMeetings);
				adminLogService.log(adminUser.getUsername(), "BATCH_GRANT_QUALIFICATION", logDetails);
				req.getSession().setAttribute("successMessage",
						"Qualifikationen wurden erfolgreich an " + updatedCount + " Benutzer vergeben.");
			} else {
				req.getSession().setAttribute("errorMessage", "Qualifikationen konnten nicht vergeben werden.");
			}
		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige Kurs-ID oder Anzahl der Meetings.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDashboardServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import com.google.inject.Singleton;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Singleton
public class AdminDashboardServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminDashboardServlet.class);

	@Override
	public void init() {
		// DAOs are no longer needed here as data is fetched via API.
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Admin dashboard page requested. Forwarding to JSP for dynamic data loading.");
		request.getRequestDispatcher("/views/admin/admin_dashboard.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDefectServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@Singleton
public class AdminDefectServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final StorageDAO storageDAO;

	@Inject
	public AdminDefectServlet(StorageDAO storageDAO) {
		this.storageDAO = storageDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems();
		request.setAttribute("defectiveItems", defectiveItems);
		request.getRequestDispatcher("/views/admin/admin_defect_list.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminEventServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.*;
import de.technikteam.model.*;
import de.technikteam.service.AchievementService;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.EventService;
import de.technikteam.service.NotificationService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 40, maxRequestSize = 1024 * 1024 * 80)
public class AdminEventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminEventServlet.class);

	private final EventDAO eventDAO;
	private final CourseDAO courseDAO;
	private final StorageDAO storageDAO;
	private final UserDAO userDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventCustomFieldDAO customFieldDAO;
	private final InventoryKitDAO kitDAO;
	private final EventService eventService;
	private final AdminLogService adminLogService;
	private final AchievementService achievementService;
	private final Gson gson;

	@Inject
	public AdminEventServlet(EventDAO eventDAO, CourseDAO courseDAO, StorageDAO storageDAO, UserDAO userDAO,
			AttachmentDAO attachmentDAO, EventCustomFieldDAO customFieldDAO, InventoryKitDAO kitDAO,
			EventService eventService, AdminLogService adminLogService, AchievementService achievementService) {
		this.eventDAO = eventDAO;
		this.courseDAO = courseDAO;
		this.storageDAO = storageDAO;
		this.userDAO = userDAO;
		this.attachmentDAO = attachmentDAO;
		this.customFieldDAO = customFieldDAO;
		this.kitDAO = kitDAO;
		this.eventService = eventService;
		this.adminLogService = adminLogService;
		this.achievementService = achievementService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).setPrettyPrinting().create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User user = (User) req.getSession().getAttribute("user");
		if (!user.getPermissions().contains("EVENT_READ") && !user.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		try {
			switch (action) {
			case "getEventData":
				getEventDataAsJson(req, resp);
				break;
			case "getAssignmentData":
				getAssignmentDataAsJson(req, resp);
				break;
			default:
				listEvents(req, resp);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminEventServlet doGet", e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = req.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "assignUsers":
			handleAssignUsers(req, resp);
			break;
		case "updateStatus":
			handleStatusUpdate(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		case "inviteUsers":
			handleInviteUsers(req, resp);
			break;
		default:
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
			break;
		}
	}

	private void listEvents(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		List<Event> eventList = eventDAO.getAllEvents();
		List<Course> allCourses = courseDAO.getAllCourses();
		List<StorageItem> allItems = storageDAO.getAllItems();
		List<User> allUsers = userDAO.getAllUsers();
		List<InventoryKit> allKits = kitDAO.getAllKits();
		req.setAttribute("eventList", eventList);
		req.setAttribute("allUsers", allUsers);
		req.setAttribute("allKits", allKits);
		req.setAttribute("allCoursesJson", gson.toJson(allCourses));
		req.setAttribute("allItemsJson", gson.toJson(allItems));
		req.setAttribute("allKitsJson", gson.toJson(allKits));
		req.getRequestDispatcher("/views/admin/admin_events_list.jsp").forward(req, resp);
	}

	private void getEventDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
				event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
				event.setAttachments(attachmentDAO.getAttachmentsForParent("EVENT", eventId, "ADMIN"));
				event.setCustomFields(customFieldDAO.getCustomFieldsForEvent(eventId));
				String eventJson = gson.toJson(event);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(eventJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND);
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	private void getAssignmentDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			Set<Integer> assignedUserIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
					.collect(Collectors.toSet());
			Map<String, Object> responseData = new HashMap<>();
			responseData.put("signedUpUsers", signedUpUsers);
			responseData.put("assignedUserIds", assignedUserIds);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(gson.toJson(responseData));
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		boolean isUpdate = idParam != null && !idParam.isEmpty();
		boolean hasPermission = isUpdate
				? (adminUser.getPermissions().contains("EVENT_UPDATE") || adminUser.hasAdminAccess())
				: (adminUser.getPermissions().contains("EVENT_CREATE") || adminUser.hasAdminAccess());
		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		Event event = new Event();
		try {
			event.setName(request.getParameter("name"));
			event.setDescription(request.getParameter("description"));
			event.setLocation(request.getParameter("location"));
			event.setEventDateTime(LocalDateTime.parse(request.getParameter("eventDateTime")));
			String endDateTimeParam = request.getParameter("endDateTime");
			if (endDateTimeParam != null && !endDateTimeParam.isEmpty()) {
				event.setEndDateTime(LocalDateTime.parse(endDateTimeParam));
			}
			String leaderIdStr = request.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				event.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}
			if (isUpdate) {
				int eventId = Integer.parseInt(idParam);
				Event originalEvent = eventDAO.getEventById(eventId);
				event.setId(eventId);
				event.setStatus(originalEvent.getStatus());
			}

			int eventId = eventService.createOrUpdateEvent(event, isUpdate, adminUser, request);
			if (eventId > 0) {
				request.getSession().setAttribute("successMessage", "Event erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Event konnte nicht gespeichert werden.");
			}
		} catch (DateTimeParseException e) {
			request.getSession().setAttribute("errorMessage", "Ungültiges Datumsformat.");
		} catch (Exception e) {
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("id"));
		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment == null) {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Anhang nicht gefunden.");
			return;
		}
		if (!adminUser.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		if (attachmentDAO.deleteAttachment(attachmentId)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
					+ "' von Event ID " + attachment.getParentId() + " gelöscht.");
			resp.setContentType("application/json");
			resp.getWriter().write("{\"message\":\"Anhang gelöscht\"}");
		} else {
			resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Anhang konnte nicht aus DB gelöscht werden.");
		}
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("EVENT_DELETE") && !adminUser.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.deleteEvent(eventId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_EVENT",
						"Event '" + event.getName() + "' (ID: " + eventId + ") endgültig gelöscht.");
				req.getSession().setAttribute("successMessage", "Event wurde gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Event konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleAssignUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		if (!adminUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS") && !adminUser.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}
		try {
			String[] userIds = req.getParameterValues("userIds");
			eventDAO.assignUsersToEvent(eventId, userIds);
			String assignedUserCount = (userIds != null) ? String.valueOf(userIds.length) : "0";
			String logDetails = String.format("Team für Event '%s' (ID: %d) finalisiert. %s Benutzer zugewiesen.",
					event.getName(), eventId, assignedUserCount);
			adminLogService.log(adminUser.getUsername(), "ASSIGN_TEAM", logDetails);
			req.getSession().setAttribute("successMessage", "Team für das Event wurde erfolgreich zugewiesen.");
		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleStatusUpdate(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("id"));
		Event event = eventDAO.getEventById(eventId);
		if (!adminUser.getPermissions().contains("EVENT_UPDATE") && !adminUser.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}
		try {
			String newStatus = req.getParameter("newStatus");
			if (event != null && eventDAO.updateEventStatus(eventId, newStatus)) {
				String logDetails = String.format("Status für Event '%s' (ID: %d) von '%s' auf '%s' geändert.",
						event.getName(), eventId, event.getStatus(), newStatus);
				adminLogService.log(adminUser.getUsername(), "UPDATE_EVENT_STATUS", logDetails);
				if ("ABGESCHLOSSEN".equals(newStatus)) {
					List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
					for (User user : assignedUsers) {
						achievementService.checkAndGrantAchievements(user, "EVENT_COMPLETED");
					}
				}
				NotificationService.getInstance().broadcastUIUpdate("event_status_updated",
						Map.of("eventId", eventId, "newStatus", newStatus));
				req.getSession().setAttribute("successMessage", "Event-Status erfolgreich aktualisiert.");
			} else {
				req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Event-Status.");
			}
		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleInviteUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("eventId"));
		String[] userIdsToInvite = req.getParameterValues("userIds");
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Event not found.");
			return;
		}
		if (!adminUser.hasAdminAccess()) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}
		if (userIdsToInvite != null) {
			for (String userIdStr : userIdsToInvite) {
				try {
					int userId = Integer.parseInt(userIdStr);
					NotificationService.getInstance().sendEventInvitation(userId, event.getName(), eventId);
				} catch (NumberFormatException e) {
					logger.warn("Invalid user ID '{}' found when sending invitations.", userIdStr);
				}
			}
			req.getSession().setAttribute("successMessage",
					"Einladungen an " + userIdsToInvite.length + " Benutzer gesendet.");
			adminLogService.log(adminUser.getUsername(), "INVITE_CREW", "Einladungen für Event '" + event.getName()
					+ "' an " + userIdsToInvite.length + " Benutzer gesendet.");
		} else {
			req.getSession().setAttribute("infoMessage", "Keine Benutzer zum Einladen ausgewählt.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFeedbackServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.FeedbackSubmission;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@Singleton
public class AdminFeedbackServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private final FeedbackSubmissionDAO submissionDAO;

	@Inject
	public AdminFeedbackServlet(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		// This is a critical check. If the user is null, authentication has failed.
		if (user == null || !user.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		List<FeedbackSubmission> submissions = submissionDAO.getAllSubmissions();
		request.setAttribute("submissions", submissions);
		request.getRequestDispatcher("/views/admin/admin_feedback.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileCategoryServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@Singleton
public class AdminFileCategoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileCategoryServlet.class);
	private final FileDAO fileDAO;
	private final AdminLogService adminLogService;

	@Inject
	public AdminFileCategoryServlet(FileDAO fileDAO, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		HttpSession session = request.getSession();

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for file category action.");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String pathInfo = request.getPathInfo(); // E.g., "/erstellen", "/loeschen"
		User adminUser = (User) session.getAttribute("user");
		logger.debug("AdminFileCategoryServlet processing POST for action path: {}", pathInfo);

		try {
			if ("/erstellen".equals(pathInfo)) {
				handleCreate(request, response, adminUser);
			} else if ("/aktualisieren".equals(pathInfo)) {
				handleUpdate(request, response, adminUser);
			} else if ("/loeschen".equals(pathInfo)) {
				handleDelete(request, response, adminUser);
			} else {
				logger.warn("Unknown path received in AdminFileCategoryServlet: {}", request.getRequestURI());
				response.sendError(HttpServletResponse.SC_BAD_REQUEST);
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in AdminFileCategoryServlet for action {}", pathInfo, e);
			session.setAttribute("errorMessage", "Ungültige ID für Kategorie-Aktion.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
		}
	}

	private void handleCreate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		String categoryName = request.getParameter("categoryName");
		HttpSession session = request.getSession();
		if (categoryName == null || categoryName.trim().isEmpty()) {
			session.setAttribute("errorMessage", "Kategoriename darf nicht leer sein.");
		} else if (fileDAO.createCategory(categoryName)) {
			adminLogService.log(adminUser.getUsername(), "CREATE_FILE_CATEGORY",
					"Dateikategorie '" + categoryName + "' erstellt.");
			session.setAttribute("successMessage", "Kategorie '" + categoryName + "' erfolgreich erstellt.");
		} else {
			session.setAttribute("errorMessage",
					"Kategorie konnte nicht erstellt werden. Möglicherweise existiert der Name bereits.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleUpdate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		int categoryId = Integer.parseInt(request.getParameter("categoryId"));
		String newName = request.getParameter("categoryName");
		String oldName = fileDAO.getCategoryNameById(categoryId);
		HttpSession session = request.getSession();
		if (newName == null || newName.trim().isEmpty()) {
			session.setAttribute("errorMessage", "Kategoriename darf nicht leer sein.");
		} else if (fileDAO.updateCategory(categoryId, newName)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_FILE_CATEGORY",
					"Dateikategorie '" + oldName + "' (ID: " + categoryId + ") umbenannt in '" + newName + "'.");
			session.setAttribute("successMessage", "Kategorie erfolgreich umbenannt.");
		} else {
			session.setAttribute("errorMessage", "Kategorie konnte nicht umbenannt werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		int categoryId = Integer.parseInt(request.getParameter("categoryId"));
		String categoryName = fileDAO.getCategoryNameById(categoryId);
		HttpSession session = request.getSession();
		if (fileDAO.deleteCategory(categoryId)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_FILE_CATEGORY",
					"Dateikategorie '" + (categoryName != null ? categoryName : "ID: " + categoryId) + "' gelöscht.");
			session.setAttribute("successMessage", "Kategorie erfolgreich gelöscht.");
		} else {
			session.setAttribute("errorMessage",
					"Kategorie konnte nicht gelöscht werden. Stellen Sie sicher, dass keine untergeordneten Elemente vorhanden sind.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileManagementServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

@Singleton
public class AdminFileManagementServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileManagementServlet.class);
	private final FileDAO fileDAO;

	@Inject
	public AdminFileManagementServlet(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Admin file management page requested by user '{}' (Role: {})", user.getUsername(),
				user.getRoleName());

		// In the admin area, we always want to show all files, so we create a temporary
		// user object with admin rights to pass to the DAO.
		User adminProxy = new User();
		adminProxy.setPermissions(new HashSet<>());
		adminProxy.getPermissions().add("ACCESS_ADMIN_PANEL");

		Map<String, List<File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(adminProxy);
		List<FileCategory> allCategories = fileDAO.getAllCategories();

		request.setAttribute("groupedFiles", groupedFiles);
		request.setAttribute("allCategories", allCategories);

		logger.debug("Forwarding file and category data to admin_files.jsp.");
		request.getRequestDispatcher("/views/admin/admin_files.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileServlet.class);

	private final FileDAO fileDAO;
	private final ConfigurationService configService;
	private final AdminLogService adminLogService;

	private static final Set<String> ALLOWED_MIME_TYPES = Set.of("image/jpeg", "image/png", "image/gif",
			"application/pdf", "text/markdown", "text/plain");

	@Inject
	public AdminFileServlet(FileDAO fileDAO, ConfigurationService configService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.configService = configService;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		if ("delete".equals(action)) {
			handleDeleteUpload(request, response, adminUser);
			return;
		}

		Part filePart = request.getPart("file");
		if (filePart == null || filePart.getSize() == 0) {
			session.setAttribute("errorMessage", "Bitte wählen Sie eine Datei zum Hochladen aus.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
			return;
		}

		String contentType = filePart.getContentType();
		if (!ALLOWED_MIME_TYPES.contains(contentType)) {
			session.setAttribute("errorMessage", "Dateityp '" + contentType + "' ist nicht erlaubt.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
			return;
		}

		if ("create".equals(action)) {
			handleCreateUpload(request, response, adminUser, filePart);
		} else if ("update".equals(action)) {
			handleUpdateUpload(request, response, adminUser, filePart);
		} else {
			session.setAttribute("errorMessage", "Unbekannte Upload-Aktion.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
		}
	}

	private void handleCreateUpload(HttpServletRequest request, HttpServletResponse response, User adminUser,
			Part filePart) throws IOException {
		HttpSession session = request.getSession();
		try {
			int categoryId = Integer.parseInt(request.getParameter("categoryId"));
			String requiredRole = request.getParameter("requiredRole");
			String originalFileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
			String sanitizedOriginalFileName = originalFileName.replaceAll("[^a-zA-Z0-9.\\-_ ]", "_");
			String uniqueFileName = UUID.randomUUID().toString() + "-" + sanitizedOriginalFileName;
			File targetFile = new File(configService.getProperty("upload.directory"), uniqueFileName);
			filePart.write(targetFile.getAbsolutePath());

			de.technikteam.model.File newDbFile = new de.technikteam.model.File();
			newDbFile.setFilename(sanitizedOriginalFileName);
			newDbFile.setFilepath(uniqueFileName);
			newDbFile.setCategoryId(categoryId);
			newDbFile.setRequiredRole(requiredRole);

			if (fileDAO.createFile(newDbFile)) {
				adminLogService.log(adminUser.getUsername(), "FILE_UPLOAD",
						"Datei '" + sanitizedOriginalFileName + "' hochgeladen.");
				session.setAttribute("successMessage", "Datei erfolgreich hochgeladen.");
			} else {
				targetFile.delete();
				session.setAttribute("errorMessage", "DB-Fehler: Datei konnte nicht gespeichert werden.");
			}
		} catch (Exception e) {
			logger.error("Error during file creation upload.", e);
			session.setAttribute("errorMessage", "Fehler beim Upload: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleUpdateUpload(HttpServletRequest request, HttpServletResponse response, User adminUser,
			Part filePart) throws IOException {
		HttpSession session = request.getSession();
		try {
			int fileId = Integer.parseInt(request.getParameter("fileId"));
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);
			if (dbFile == null) {
				session.setAttribute("errorMessage", "Datei zum Aktualisieren nicht gefunden.");
				response.sendRedirect(request.getContextPath() + "/admin/dateien");
				return;
			}

			File targetFile = new File(configService.getProperty("upload.directory"), dbFile.getFilepath());
			filePart.write(targetFile.getAbsolutePath());

			if (fileDAO.touchFileRecord(dbFile.getId())) {
				adminLogService.log(adminUser.getUsername(), "FILE_UPDATE",
						"Neue Version für Datei '" + dbFile.getFilename() + "' hochgeladen.");
				session.setAttribute("successMessage", "Neue Version erfolgreich hochgeladen.");
			} else {
				session.setAttribute("errorMessage", "DB-Fehler: Datei-Metadaten konnten nicht aktualisiert werden.");
			}
		} catch (Exception e) {
			logger.error("Error during file update upload.", e);
			session.setAttribute("errorMessage", "Fehler beim Aktualisieren: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleDeleteUpload(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		HttpSession session = request.getSession();
		try {
			int fileId = Integer.parseInt(request.getParameter("fileId"));
			de.technikteam.model.File fileToDelete = fileDAO.getFileById(fileId);
			if (fileToDelete == null) {
				session.setAttribute("errorMessage", "Datei zum Löschen nicht gefunden.");
			} else if (fileDAO.deleteFile(fileId)) {
				adminLogService.log(adminUser.getUsername(), "FILE_DELETE", "Datei '" + fileToDelete.getFilename()
						+ "' (ID: " + fileId + ") aus Kategorie '" + fileToDelete.getCategoryName() + "' gelöscht.");
				session.setAttribute("successMessage", "Datei '" + fileToDelete.getFilename() + "' wurde gelöscht.");
			} else {
				session.setAttribute("errorMessage", "Datei konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			session.setAttribute("errorMessage", "Ungültige Datei-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminKitServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
public class AdminKitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminKitServlet.class);
	private final InventoryKitDAO kitDAO;
	private final StorageDAO storageDAO;
	private final AdminLogService adminLogService;
	private final Gson gson = new Gson();

	// A simple DTO for client-side use to avoid sending unnecessary data
	private static class StorageItemDTO {
		int id;
		String name;
		int availableQuantity;

		StorageItemDTO(StorageItem item) {
			this.id = item.getId();
			this.name = item.getName();
			this.availableQuantity = item.getAvailableQuantity();
		}
	}

	@Inject
	public AdminKitServlet(InventoryKitDAO kitDAO, StorageDAO storageDAO, AdminLogService adminLogService) {
		this.kitDAO = kitDAO;
		this.storageDAO = storageDAO;
		this.adminLogService = adminLogService;
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getKitItems".equals(action)) {
			getKitItemsAsJson(req, resp);
			return;
		}

		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		List<StorageItem> allItems = storageDAO.getAllItems();
		List<StorageItemDTO> allItemsDto = allItems.stream().map(StorageItemDTO::new).collect(Collectors.toList());

		req.setAttribute("kits", kits);
		req.setAttribute("allItems", allItems); // Still needed for pre-populating selects
		req.setAttribute("allItemsJson", gson.toJson(allItemsDto)); // DTO for JS logic
		req.getRequestDispatcher("/views/admin/admin_kits.jsp").forward(req, resp);
	}

	private void getKitItemsAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int kitId = Integer.parseInt(req.getParameter("id"));
			List<InventoryKitItem> items = kitDAO.getItemsForKit(kitId);
			String jsonResponse = gson.toJson(items);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid kit ID.");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		try {
			switch (action) {
			case "create":
				handleCreateKit(req, adminUser);
				break;
			case "update":
				handleUpdateKit(req, adminUser);
				break;
			case "delete":
				handleDeleteKit(req, adminUser);
				break;
			case "updateKitItems":
				handleUpdateKitItems(req, adminUser);
				break;
			}
		} catch (Exception e) {
			logger.error("Error processing kit action '{}'", action, e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
		}
		resp.sendRedirect(req.getContextPath() + "/admin/kits");
	}

	private void handleCreateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		kit.setLocation(req.getParameter("location"));
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			adminLogService.log(adminUser.getUsername(), "CREATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + newId + ") erstellt.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich erstellt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht erstellt werden.");
		}
	}

	private void handleUpdateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setId(Integer.parseInt(req.getParameter("id")));
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		kit.setLocation(req.getParameter("location"));
		if (kitDAO.updateKit(kit)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + kit.getId() + ") aktualisiert.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich aktualisiert.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht aktualisiert werden.");
		}
	}

	private void handleDeleteKit(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("id"));
		InventoryKit kit = kitDAO.getKitById(kitId);
		if (kitDAO.deleteKit(kitId)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_KIT",
					"Kit '" + (kit != null ? kit.getName() : "N/A") + "' (ID: " + kitId + ") gelöscht.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht gelöscht werden.");
		}
	}

	private void handleUpdateKitItems(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("kitId"));
		String[] itemIds = req.getParameterValues("itemIds");
		String[] quantities = req.getParameterValues("quantities");
		if (kitDAO.updateKitItems(kitId, itemIds, quantities)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_KIT_ITEMS",
					"Inhalt für Kit ID " + kitId + " aktualisiert.");
			req.getSession().setAttribute("successMessage", "Kit-Inhalt erfolgreich gespeichert.");
		} else {
			req.getSession().setAttribute("errorMessage", "Fehler beim Speichern des Kit-Inhalts.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminLogServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@Singleton
public class AdminLogServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminLogServlet.class);
	private final AdminLogDAO adminLogDAO;

	@Inject
	public AdminLogServlet(AdminLogDAO adminLogDAO) {
		this.adminLogDAO = adminLogDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (adminUser == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		List<AdminLog> logs = adminLogDAO.getAllLogs();
		request.setAttribute("logs", logs);
		request.getRequestDispatcher("/views/admin/admin_log.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);

	private final MeetingDAO meetingDAO;
	private final CourseDAO courseDAO;
	private final AttachmentDAO attachmentDAO;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final Gson gson;

	@Inject
	public AdminMeetingServlet(MeetingDAO meetingDAO, CourseDAO courseDAO, AttachmentDAO attachmentDAO, UserDAO userDAO,
			AdminLogService adminLogService, ConfigurationService configService) {
		this.meetingDAO = meetingDAO;
		this.courseDAO = courseDAO;
		this.attachmentDAO = attachmentDAO;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		if (!CSRFUtil.isTokenValid(req)) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}
		String action = req.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			resp.sendRedirect(req.getContextPath() + "/admin/meetings");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();
		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);
		req.getRequestDispatcher("/views/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<Attachment> attachments = attachmentDAO.getAttachmentsForParent("MEETING", meetingId, "ADMIN");
				Map<String, Object> responseData = new HashMap<>();
				responseData.put("meetingData", meeting);
				responseData.put("attachmentsData", attachments);
				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(req.getParameter("name"));
			meeting.setDescription(req.getParameter("description"));
			meeting.setLocation(req.getParameter("location"));

			String leaderIdStr = req.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}
			String startDateTimeStr = req.getParameter("meetingDateTime");
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = req.getParameter("endDateTime");
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(req.getParameter("id"));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					adminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Meetings.");
				}
			} else {
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					adminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				} else {
					req.getSession().setAttribute("errorMessage", "Fehler beim Erstellen des Meetings.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = req.getParameter("requiredRole");
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}
		} catch (DateTimeParseException | NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			adminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(configService.getProperty("upload.directory"), attachment.getFilepath());
			if (physicalFile.exists()) {
				physicalFile.delete();
			}
			if (attachmentDAO.deleteAttachment(attachmentId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
						+ "' von Meeting ID " + attachment.getParentId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = configService.getProperty("upload.directory") + File.separator + "meetings";
		new File(uploadDir).mkdirs();
		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());
		Attachment attachment = new Attachment();
		attachment.setParentId(meetingId);
		attachment.setParentType("MEETING");
		attachment.setFilename(fileName);
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			adminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminReportServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.ReportDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Singleton
public class AdminReportServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminReportServlet.class);
	private final ReportDAO reportDAO;
	private final Gson gson = new Gson();

	@Inject
	public AdminReportServlet(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String reportType = request.getParameter("report");
		String exportType = request.getParameter("export");

		if (reportType != null && !reportType.isEmpty()) {
			handleSpecificReport(request, response, reportType, exportType);
			return;
		}

		List<Map<String, Object>> eventTrendData = reportDAO.getEventCountByMonth(12);
		List<Map<String, Object>> userActivityData = reportDAO.getUserParticipationStats(10);
		request.setAttribute("eventTrendDataJson", gson.toJson(eventTrendData));
		request.setAttribute("userActivityDataJson", gson.toJson(userActivityData));
		request.setAttribute("totalInventoryValue", reportDAO.getTotalInventoryValue());
		request.getRequestDispatcher("/views/admin/admin_reports.jsp").forward(request, response);
	}

	private void handleSpecificReport(HttpServletRequest request, HttpServletResponse response, String reportType,
			String exportType) throws IOException, ServletException {
		List<Map<String, Object>> reportData;
		String reportTitle;
		switch (reportType) {
		case "user_activity":
			reportData = reportDAO.getUserActivityStats();
			reportTitle = "Benutzeraktivitäts-Bericht";
			break;
		case "event_participation":
			reportData = reportDAO.getEventParticipationSummary();
			reportTitle = "Event-Teilnahme-Bericht";
			break;
		case "inventory_usage":
			reportData = reportDAO.getInventoryUsageFrequency();
			reportTitle = "Lagernutzungs-Bericht";
			break;
		default:
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Unbekannter Berichtstyp.");
			return;
		}

		if ("csv".equalsIgnoreCase(exportType)) {
			exportToCsv(response, reportData, reportType + "_report.csv");
		} else {
			request.setAttribute("reportData", reportData);
			request.setAttribute("reportTitle", reportTitle);
			request.getRequestDispatcher("/views/admin/report_display.jsp").forward(request, response);
		}
	}

	private void exportToCsv(HttpServletResponse response, List<Map<String, Object>> data, String filename)
			throws IOException {
		response.setContentType("text/csv");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");
		if (data == null || data.isEmpty()) {
			response.getWriter().write("No data available to export.");
			return;
		}
		try (PrintWriter writer = response.getWriter()) {
			String header = String.join(",", data.get(0).keySet());
			writer.println(header);
			for (Map<String, Object> row : data) {
				String line = row.values().stream().map(this::escapeCsvField).collect(Collectors.joining(","));
				writer.println(line);
			}
		}
	}

	private String escapeCsvField(Object field) {
		if (field == null)
			return "";
		String fieldStr = field.toString();
		if (fieldStr.contains(",") || fieldStr.contains("\"") || fieldStr.contains("\n")) {
			return "\"" + fieldStr.replace("\"", "\"\"") + "\"";
		}
		return fieldStr;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.ConfigurationService;
import de.technikteam.service.StorageService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.List;

@Singleton
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class);
	private final StorageDAO storageDAO;
	private final MaintenanceLogDAO maintenanceLogDAO;
	private final AdminLogService adminLogService;
	private final ConfigurationService configService;
	private final StorageService storageService;
	private final Gson gson = new Gson();

	@Inject
	public AdminStorageServlet(StorageDAO storageDAO, MaintenanceLogDAO maintenanceLogDAO,
			AdminLogService adminLogService, ConfigurationService configService, StorageService storageService) {
		this.storageDAO = storageDAO;
		this.maintenanceLogDAO = maintenanceLogDAO;
		this.adminLogService = adminLogService;
		this.configService = configService;
		this.storageService = storageService;
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		List<StorageItem> storageList = storageDAO.getAllItems();
		request.setAttribute("storageList", storageList);
		request.getRequestDispatcher("/views/admin/admin_storage_list.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response);
			break;
		case "delete":
			handleDelete(request, response);
			break;
		case "updateDefectStatus":
			handleDefectStatusUpdate(request, response);
			break;
		case "updateStatus":
			handleStatusUpdate(request, response);
			break;
		case "repair":
			handleRepair(request, response);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/lager");
			break;
		}
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(request.getParameter("action"));

		try {
			StorageItem item = new StorageItem();
			item.setName(request.getParameter("name"));
			item.setLocation(request.getParameter("location"));
			item.setCabinet(request.getParameter("cabinet"));
			item.setCompartment(request.getParameter("compartment"));
			item.setQuantity(Integer.parseInt(request.getParameter("quantity")));
			item.setMaxQuantity(Integer.parseInt(request.getParameter("maxQuantity")));
			String weightStr = request.getParameter("weight_kg");
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = request.getParameter("price_eur");
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(request.getParameter("id"));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
					item.setStatus(originalItem.getStatus());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(configService.getProperty("upload.directory"), "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				adminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDefectStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
        User adminUser = (User) request.getSession().getAttribute("user");
        try {
            int itemId = Integer.parseInt(request.getParameter("id"));
            String status = request.getParameter("status"); // "DEFECT" or "UNREPAIRABLE"
            int quantity = Integer.parseInt(request.getParameter("quantity"));
            String reason = request.getParameter("reason");

            boolean success = storageService.updateDefectiveItemStatus(itemId, status, quantity, reason, adminUser);

            if (success) {
                request.getSession().setAttribute("successMessage", "Defekt-Status erfolgreich aktualisiert.");
            } else {
                request.getSession().setAttribute("errorMessage", "Status konnte nicht aktualisiert werden. Überprüfen Sie die Bestandsmengen.");
            }
        } catch (NumberFormatException e) {
            request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
        }
        response.sendRedirect(request.getContextPath() + "/admin/lager");
    }

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(configService.getProperty("upload.directory"), "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				adminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String newStatus = request.getParameter("status");
			String notes = request.getParameter("notes");
			storageDAO.updateItemStatus(itemId, newStatus);
			MaintenanceLogEntry log = new MaintenanceLogEntry();
			log.setItemId(itemId);
			log.setUserId(adminUser.getId());
			log.setNotes(notes);
			String logAction = "MAINTENANCE".equals(newStatus) ? "Marked for Maintenance" : "Returned to Service";
			log.setAction(logAction);
			maintenanceLogDAO.createLog(log);
			adminLogService.log(adminUser.getUsername(), "UPDATE_ITEM_STATUS",
					"Status für Artikel-ID " + itemId + " auf '" + newStatus + "' gesetzt. Notiz: " + notes);
			request.getSession().setAttribute("successMessage", "Artikelstatus erfolgreich aktualisiert.");
		} catch (Exception e) {
			logger.error("Error updating item status", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Status.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleRepair(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int repairedQty = Integer.parseInt(request.getParameter("repaired_quantity"));
			String notes = request.getParameter("repair_notes");
			if (storageDAO.repairItems(itemId, repairedQty)) {
				MaintenanceLogEntry log = new MaintenanceLogEntry();
				log.setItemId(itemId);
				log.setUserId(adminUser.getId());
				log.setAction(repairedQty + " Stück repariert");
				log.setNotes(notes);
				maintenanceLogDAO.createLog(log);
				adminLogService.log(adminUser.getUsername(), "REPAIR_ITEM", String.format(
						"%d Stück von Artikel-ID %d als repariert markiert. Notiz: %s", repairedQty, itemId, notes));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich als repariert markiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Reparatur konnte nicht verbucht werden (vielleicht nicht genug defekte Artikel?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		}
		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import com.google.inject.Singleton;

@Singleton
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/admin/admin_system.jsp").forward(request, response);
	}
}