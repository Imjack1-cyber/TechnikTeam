
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\AppConfig.java
========================================================================

package de.technikteam.config;

/**
 * A simple configuration class that holds a single, application-wide constant: 
 * the absolute file path for the directory where all user-uploaded files are stored.
 * This centralized approach makes it easy to change the upload location without
 * modifying multiple files.
 */
public class AppConfig {
	public static final String UPLOAD_DIRECTORY = "C:\\dev\\eclipse\\workspace\\TechnikTeam\\resources\\uploads";
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	// A formatter for a full date and time, e.g., "10.06.2025, 17:45"
	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	// A formatter for just the date, e.g., "10.06.2025"
	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	// A formatter for just the time, e.g., "17:45"
	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}
		// Case 1: No end time provided
		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		// Case 2: Start and end are on the same day
		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		// Case 3: Start and end are on different days
		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * A custom serializer for the Gson library. It converts java.time.LocalDate
 * objects into the standard YYYY-MM-DD string format, which is ideal for JSON
 * data exchange and compatibility with HTML date input fields.
 */
public class LocalDateAdapter implements JsonSerializer<LocalDate> {

	@Override
	public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context) {
		// We convert the LocalDate to its standard ISO_LOCAL_DATE string format
		// ("YYYY-MM-DD").
		// This also gracefully handles the case where the date object might be null.
		return date == null ? null : new JsonPrimitive(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON)
 * and deserialization (JSON to Java), preventing reflection issues with
 * the Java Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

    // Use the standard ISO format, which is ideal for JSON
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        if (value == null) {
            out.nullValue();
        } else {
            out.value(value.format(FORMATTER));
        }
    }

    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
            in.nextNull();
            return null;
        }
        String value = in.nextString();
        return LocalDateTime.parse(value, FORMATTER);
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A Data Access Object (DAO) responsible for all database interactions with the
 * `admin_logs` table. It provides methods to create new log entries, which are
 * used for auditing administrative actions, and to retrieve all existing logs
 * for display in the admin panel.
 */
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);

	/**
	 * Creates a new log entry in the database. This is the primary method for
	 * recording an administrative action.
	 * 
	 * @param log The AdminLog object to persist.
	 */
	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		logger.debug("Attempting to create admin log: [User: {}, Action: {}]", log.getAdminUsername(),
				log.getActionType());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, log.getAdminUsername());
			pstmt.setString(2, log.getActionType());
			pstmt.setString(3, log.getDetails());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created admin log for user '{}'.", log.getAdminUsername());
			}
		} catch (SQLException e) {
			logger.error("Failed to create admin log for user '{}'. Details: {}", log.getAdminUsername(),
					log.getDetails(), e);
		}
	}

	/**
	 * Fetches all log entries from the database, ordered with the newest first.
	 * 
	 * @return A list of AdminLog objects.
	 */
	public List<AdminLog> getAllLogs() {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		logger.debug("Executing query to fetch all admin logs.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				logs.add(logEntry);
			}
			logger.info("Fetched {} admin log entries from the database.", logs.size());
		} catch (SQLException e) {
			logger.error("Failed to fetch admin logs from the database.", e);
		}
		return logs;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Course;

/**
 * Data Access Object for managing `Course` templates in the `courses` table.
 * This DAO handles CRUD operations for the parent course definitions (e.g.,
 * "Grundlehrgang Tontechnik"), which serve as blueprints for individual,
 * schedulable `Meeting` instances.
 */
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);

	/**
	 * Creates a new parent course template in the database.
	 * 
	 * @param course The Course object to create (containing name, abbreviation, and
	 *               description).
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		logger.debug("Attempting to create parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error creating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Fetches a single parent course by its ID.
	 * 
	 * @param courseId The ID of the course.
	 * @return A Course object, or null if not found.
	 */
	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		logger.debug("Attempting to fetch course by ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found course with ID: {}", courseId);
					return mapResultSetToCourse(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching course by ID: {}", courseId, e);
		}
		logger.warn("No course found with ID: {}", courseId);
		return null;
	}

	/**
	 * Fetches all parent courses from the database, sorted alphabetically by name.
	 * 
	 * @return A list of all Course objects.
	 */
	public List<Course> getAllCourses() {
		List<Course> courses = new ArrayList<>();
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		logger.debug("Attempting to fetch all parent courses.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				courses.add(mapResultSetToCourse(rs));
			}
			logger.info("Fetched {} total parent courses.", courses.size());
		} catch (SQLException e) {
			logger.error("SQL error while fetching all courses.", e);
		}
		return courses;
	}

	/**
	 * Helper method to map a ResultSet row to a Course object.
	 * 
	 * @param rs The ResultSet to map from.
	 * @return A populated Course object.
	 * @throws SQLException If a database access error occurs.
	 */
	private Course mapResultSetToCourse(ResultSet rs) throws SQLException {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	}

	/**
	 * Updates an existing parent course's name, abbreviation, and description.
	 * 
	 * @param course The Course object with the updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		logger.debug("Attempting to update parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			pstmt.setInt(4, course.getId());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully updated parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error updating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Deletes a parent course from the database. NOTE: This relies on `ON DELETE
	 * CASCADE` in the database schema to also delete all associated meetings and
	 * qualifications.
	 * 
	 * @param courseId The ID of the course to delete.
	 * @return true if the deletion was successful, false otherwise.
	 */
	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		logger.debug("Attempting to delete parent course with ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.warn("Successfully deleted parent course with ID: {}", courseId);
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\DatabaseManager.java
========================================================================

package de.technikteam.dao;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This class manages the application's connection to the MySQL database. It
 * uses the HikariCP connection pool for efficient and high-performance database
 * communication. A single, static `HikariDataSource` is initialized when the
 * class is first loaded. All Data Access Objects (DAOs) use the static
 * `getConnection()` method to borrow a connection from the pool.
 */
public class DatabaseManager {

	private static final Logger logger = LogManager.getLogger(DatabaseManager.class);
	private static HikariDataSource dataSource;

	// This static block runs only ONCE when the class is first loaded.
	static {
		try {
			logger.info("Initializing database connection pool...");

			HikariConfig config = new HikariConfig();
			// Ensure the JDBC URL uses UTF-8 and a modern timezone for compatibility.
			config.setJdbcUrl(
					"jdbc:mysql://localhost:3306/technik_team_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false&serverTimezone=UTC");
			config.setUsername("technik_user"); // <-- SET YOUR DB USERNAME
			config.setPassword("ein_sicheres_passwort"); // <-- SET YOUR DB PASSWORD

			// --- Pool Configuration (Good Defaults) ---
			config.setMaximumPoolSize(10); // Max number of active connections
			config.setMinimumIdle(5); // Min number of idle connections to keep ready
			config.setConnectionTimeout(30000); // 30 seconds to wait for a connection before timing out
			config.setIdleTimeout(600000); // 10 minutes for an idle connection to be retired
			config.setMaxLifetime(1800000); // 30 minutes max lifetime for any single connection

			// Create the datasource pool from the configuration
			dataSource = new HikariDataSource(config);

			logger.info("================================================================");
			logger.info("DATABASE CONNECTION POOL INITIALIZED SUCCESSFULLY.");
			logger.info("================================================================");

		} catch (Exception e) {
			logger.fatal(
					"Failed to initialize database connection pool! The application cannot function without a database.",
					e);
			// This is a fatal error, so we throw an exception to stop the application from
			// starting incorrectly.
			throw new RuntimeException("Could not initialize database pool", e);
		}
	}

	/**
	 * Gets a connection from the connection pool. This method is fast because it
	 * borrows an existing, ready-to-use connection; it does not create a new one.
	 * 
	 * @return A database connection.
	 * @throws SQLException if a connection cannot be obtained from the pool.
	 */
	public static Connection getConnection() throws SQLException {
		if (dataSource == null) {
			logger.error("Datasource is null. The database manager was not initialized correctly.");
			throw new SQLException("Database connection pool is not available.");
		}
		return dataSource.getConnection();
	}

	/**
	 * Closes the entire connection pool. This should be called only when the
	 * application is shutting down to release all database resources.
	 */
	public static void closeDataSource() {
		if (dataSource != null && !dataSource.isClosed()) {
			logger.info("Closing database connection pool...");
			dataSource.close();
			logger.info("Database connection pool closed successfully.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventAttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventAttachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing file attachments for events, interacting with the
 * `event_attachments` table.
 */
public class EventAttachmentDAO {
	private static final Logger logger = LogManager.getLogger(EventAttachmentDAO.class);

	public boolean addAttachment(EventAttachment attachment) {
		String sql = "INSERT INTO event_attachments (event_id, filename, filepath, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to event ID {}", attachment.getFilename(), attachment.getEventId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachment.getEventId());
			pstmt.setString(2, attachment.getFilename());
			pstmt.setString(3, attachment.getFilepath());
			pstmt.setString(4, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to event {}", attachment.getEventId(), e);
			return false;
		}
	}

	public List<EventAttachment> getAttachmentsForEvent(int eventId, String userRole) {
		List<EventAttachment> attachments = new ArrayList<>();
		String sql = "SELECT * FROM event_attachments WHERE event_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventAttachment att = new EventAttachment();
					att.setId(rs.getInt("id"));
					att.setEventId(rs.getInt("event_id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
					att.setRequiredRole(rs.getString("required_role"));
					attachments.add(att);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for event {}", eventId, e);
		}
		return attachments;
	}

	public EventAttachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM event_attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					EventAttachment att = new EventAttachment();
					att.setId(rs.getInt("id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setEventId(rs.getInt("event_id"));
					return att;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		return null;
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM event_attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling chat messages specific to a single event. It
 * manages records in the `event_chat_messages` table, allowing users to post
 * messages and retrieve the chat history for a particular event.
 */
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);

	/**
	 * Posts a new message to an event's chat log in the database.
	 * 
	 * @param message The EventChatMessage object to persist.
	 * @return true if the message was successfully inserted, false otherwise.
	 */
	public boolean postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		logger.debug("Posting chat message for event {}: '{}'", message.getEventId(), message.getMessageText());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, message.getEventId());
			pstmt.setInt(2, message.getUserId());
			pstmt.setString(3, message.getUsername());
			pstmt.setString(4, message.getMessageText());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error posting chat message for event {}", message.getEventId(), e);
			return false;
		}
	}

	/**
	 * Fetches all messages for a specific event, ordered by the time they were
	 * sent.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of EventChatMessage objects, or an empty list if none are
	 *         found.
	 */
	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		List<EventChatMessage> messages = new ArrayList<>();
		String sql = "SELECT * FROM event_chat_messages WHERE event_id = ? ORDER BY sent_at ASC";
		logger.debug("Fetching chat messages for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventChatMessage msg = new EventChatMessage();
					msg.setId(rs.getInt("id"));
					msg.setEventId(rs.getInt("event_id"));
					msg.setUserId(rs.getInt("user_id"));
					msg.setUsername(rs.getString("username"));
					msg.setMessageText(rs.getString("message_text"));
					msg.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
					messages.add(msg);
				}
				logger.info("Found {} chat messages for event ID: {}", messages.size(), eventId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching chat messages for event {}", eventId, e);
		}
		return messages;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Event;
import de.technikteam.model.EventAttendance;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;

/**
 * A comprehensive DAO for all database operations related to the `events`
 * table. It handles creating, reading, updating, and deleting events.
 * Additionally, it manages user sign-ups/sign-offs, event skill requirements,
 * and the final assignment of users to an event. It contains methods to supply
 * data for both regular user views (like upcoming events) and administrative
 * back-end pages.
 */
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);

	// --- Private Helper Methods ---

	/**
	 * Maps a row from a ResultSet to an Event object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Event object.
	 * @throws SQLException If a database error occurs.
	 */
	private Event mapResultSetToEvent(ResultSet rs) throws SQLException {
		Event event = new Event();
		event.setId(rs.getInt("id"));
		event.setName(rs.getString("name"));
		event.setEventDateTime(rs.getTimestamp("event_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			event.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		event.setDescription(rs.getString("description"));
		event.setLocation(rs.getString("location"));
		event.setStatus(rs.getString("status"));

		if (DaoUtils.hasColumn(rs, "leader_user_id")) {
			event.setLeaderUserId(rs.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(rs, "leader_username")) {
			event.setLeaderUsername(rs.getString("leader_username"));
		}

		return event;
	}

	public void setAttendanceCommitment(int eventId, int userId, String commitment) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Setting attendance commitment for user {} event {} to '{}'", userId, eventId, commitment);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, commitment);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, userId);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("SQL error setting attendance commitment for user {} event {}", userId, eventId, e);
		}
	}

	/**
	 * Maps a row from a ResultSet to a simplified User object (ID, username, role).
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated User object.
	 * @throws SQLException If a database error occurs.
	 */
	private User mapResultSetToSimpleUser(ResultSet rs) throws SQLException {
		return new User(rs.getInt("id"), rs.getString("username"), rs.getString("role"));
	}

	// --- Methods for Public and User-Specific Views ---

	/**
	 * Fetches the event participation history for a specific user.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of all past and present events the user has interacted with.
	 */
	public List<Event> getEventHistoryForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.*, ea.signup_status FROM events e "
				+ "JOIN event_attendance ea ON e.id = ea.event_id WHERE ea.user_id = ? ORDER BY e.event_datetime DESC";
		logger.debug("Fetching event history for user ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			ResultSet rs = pstmt.executeQuery();
			while (rs.next()) {
				Event event = mapResultSetToEvent(rs);
				event.setUserAttendanceStatus(rs.getString("signup_status"));
				history.add(event);
			}
			logger.info("Found {} events in history for user ID: {}", history.size(), userId);
		} catch (SQLException e) {
			logger.error("SQL error fetching event history for user {}", userId, e);
		}
		return history;
	}

	// --- Methods for Admin Views & CRUD ---

	/**
	 * Fetches a single event by its ID.
	 * 
	 * @param eventId The ID of the event.
	 * @return An Event object, or null if not found.
	 */
	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "WHERE e.id = ?";
		logger.debug("Fetching event by ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found event '{}' with ID: {}", rs.getString("name"), eventId);
					return mapResultSetToEvent(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching event by ID: {}", eventId, e);
		}
		logger.warn("No event found with ID: {}", eventId);
		return null;
	}

	/**
	 * Fetches all events from the database, newest first.
	 * 
	 * @return A list of all Event objects.
	 */
	public List<Event> getAllEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "ORDER BY e.event_datetime DESC";
		logger.debug("Fetching all events.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				events.add(mapResultSetToEvent(rs));
			}
			logger.info("Fetched a total of {} events.", events.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all events.", e);
		}
		return events;
	}

	/**
	 * Fetches all upcoming/active events.
	 * 
	 * @return A list of all active Event objects.
	 */
	public List<Event> getActiveEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		logger.debug("Fetching active events.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				events.add(mapResultSetToEvent(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching active events.", e);
		}
		return events;
	}

	/**
	 * Creates a new event in the database.
	 * 
	 * @param event The Event object to persist.
	 * @return The ID of the newly created event, or 0 on failure.
	 */
	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create new event: {}", event.getName());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setString(1, event.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			pstmt.setString(4, event.getDescription());
			pstmt.setString(5, event.getLocation());
			pstmt.setString(6, "GEPLANT"); // Default status on creation
			if (event.getLeaderUserId() > 0) {
				pstmt.setInt(7, event.getLeaderUserId());
			} else {
				pstmt.setNull(7, Types.INTEGER);
			}

			if (pstmt.executeUpdate() > 0) {
				try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						logger.info("Successfully created event '{}' with ID {}", event.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating event '{}'.", event.getName(), e);
		}
		return 0;
	}

	/**
	 * Updates an existing event in the database.
	 * 
	 * @param event The Event object with updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		logger.debug("Attempting to update event with ID: {}", event.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, event.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			pstmt.setString(4, event.getDescription());
			pstmt.setString(5, event.getLocation());
			pstmt.setString(6, event.getStatus());
			if (event.getLeaderUserId() > 0) {
				pstmt.setInt(7, event.getLeaderUserId());
			} else {
				pstmt.setNull(7, Types.INTEGER);
			}
			pstmt.setInt(8, event.getId());

			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated event with ID: {}", event.getId());
			return success;
		} catch (SQLException e) {
			logger.error("SQL error updating event with ID: {}", event.getId(), e);
		}
		return false;
	}

	/**
	 * Deletes an event from the database.
	 * 
	 * @param eventId The ID of the event to delete.
	 * @return true if deletion was successful, false otherwise.
	 */
	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		logger.debug("Attempting to delete event with ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.warn("Successfully deleted event with ID: {}", eventId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting event with ID: {}", eventId, e);
		}
		return false;
	}

	/**
	 * Updates only the status of a specific event.
	 * 
	 * @param eventId   The ID of the event to update.
	 * @param newStatus The new status string (e.g., 'LAUFEND', 'ABGESCHLOSSEN').
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateEventStatus(int eventId, String newStatus) {
		String sql = "UPDATE events SET status = ? WHERE id = ?";
		logger.debug("Attempting to update status for event {} to '{}'", eventId, newStatus);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newStatus);
			pstmt.setInt(2, eventId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Updating status for event {} to '{}' was successful.", eventId, newStatus);
			else
				logger.warn("Updating status for event {} to '{}' failed (0 rows affected).", eventId, newStatus);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error updating status for event ID: {}", eventId, e);
			return false;
		}
	}

	// --- Methods for User Actions & Admin Management ---

	/**
	 * Signs a user up for an event, or updates their status if they previously
	 * signed off.
	 * 
	 * @param userId  The ID of the user.
	 * @param eventId The ID of the event.
	 */
	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		logger.debug("Signing up user {} for event {}", userId, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setInt(2, eventId);
			pstmt.executeUpdate();
			logger.info("User {} successfully signed up for event {}", userId, eventId);
		} catch (SQLException e) {
			logger.error("SQL error during event sign-up for user {} and event {}", userId, eventId, e);
		}
	}

	/**
	 * Signs a user off from an event.
	 * 
	 * @param userId  The ID of the user.
	 * @param eventId The ID of the event.
	 */
	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		logger.debug("Signing off user {} from event {}", userId, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setInt(2, eventId);
			pstmt.executeUpdate();
			logger.info("User {} successfully signed off from event {}", userId, eventId);
		} catch (SQLException e) {
			logger.error("SQL error during event sign-off for user {} and event {}", userId, eventId, e);
		}
	}

	/**
	 * Fetches a list of all users who have signed up for a specific event.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of User objects.
	 */
	public List<User> getSignedUpUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, u.role FROM users u JOIN event_attendance ea ON u.id = ea.user_id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching signed up users for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next())
					users.add(mapResultSetToSimpleUser(rs));
			}
			logger.info("Found {} signed-up users for event ID: {}", users.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching signed-up users for event ID: {}", eventId, e);
		}
		return users;
	}

	/**
	 * Fetches detailed attendance information for an event, including signup and
	 * commitment status.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of EventAttendance objects.
	 */
	public List<EventAttendance> getAttendanceDetailsForEvent(int eventId) {
		List<EventAttendance> attendances = new ArrayList<>();
		String sql = "SELECT u.id, u.username, ea.signup_status, ea.commitment_status FROM event_attendance ea JOIN users u ON ea.user_id = u.id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching attendance details for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventAttendance attendance = new EventAttendance();
					attendance.setUserId(rs.getInt("id"));
					attendance.setUsername(rs.getString("username"));
					attendance.setSignupStatus(rs.getString("signup_status"));
					attendance.setCommitmentStatus(rs.getString("commitment_status"));
					attendances.add(attendance);
				}
			}
			logger.info("Found {} attendance detail records for event ID: {}", attendances.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching attendance details for event ID: {}", eventId, e);
		}
		return attendances;
	}

	/**
	 * Updates the commitment status (e.g., 'BESTÄTIGT') for a user's attendance at
	 * an event.
	 * 
	 * @param eventId The ID of the event.
	 * @param userId  The ID of the user.
	 * @param status  The new commitment status.
	 * @return true if the update was successful.
	 */
	public boolean updateCommitmentStatus(int eventId, int userId, String status) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Updating commitment status for event {}, user {} to '{}'", eventId, userId, status);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error while updating commitment status for event {}, user {}", eventId, userId, e);
		}
		return false;
	}

	/**
	 * Fetches all skill requirements (required courses and number of people) for an
	 * event.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of SkillRequirement objects.
	 */
	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		List<SkillRequirement> requirements = new ArrayList<>();
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		logger.debug("Fetching skill requirements for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					SkillRequirement req = new SkillRequirement();
					req.setRequiredCourseId(rs.getInt("required_course_id"));
					req.setCourseName(rs.getString("course_name"));
					req.setRequiredPersons(rs.getInt("required_persons"));
					requirements.add(req);
				}
			}
			logger.info("Found {} skill requirements for event ID: {}", requirements.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching skill requirements for event ID: {}", eventId, e);
		}
		return requirements;
	}

	/**
	 * Saves the skill requirements for an event in a single transaction. It first
	 * deletes all existing requirements for the event, then inserts the new ones.
	 * 
	 * @param eventId           The ID of the event.
	 * @param requiredCourseIds An array of course IDs.
	 * @param requiredPersons   An array of the number of people required for each
	 *                          course.
	 */
	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		String deleteSql = "DELETE FROM event_skill_requirements WHERE event_id = ?";
		String insertSql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
		logger.debug("Saving skill requirements for event ID: {}", eventId);
		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false); // Start transaction

			try (PreparedStatement deletePstmt = conn.prepareStatement(deleteSql)) {
				deletePstmt.setInt(1, eventId);
				deletePstmt.executeUpdate();
			}

			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				try (PreparedStatement insertPstmt = conn.prepareStatement(insertSql)) {
					for (int i = 0; i < requiredCourseIds.length; i++) {
						if (requiredCourseIds[i] == null || requiredCourseIds[i].isEmpty()
								|| "0".equals(requiredPersons[i]))
							continue;
						insertPstmt.setInt(1, eventId);
						insertPstmt.setInt(2, Integer.parseInt(requiredCourseIds[i]));
						insertPstmt.setInt(3, Integer.parseInt(requiredPersons[i]));
						insertPstmt.addBatch();
					}
					insertPstmt.executeBatch();
				}
			}

			conn.commit(); // Commit transaction
			logger.info("Successfully saved skill requirements for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException e) {
			logger.error("Transaction error during saving skill requirements for event ID: {}. Rolling back.", eventId,
					e);
			if (conn != null) {
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction.", ex);
				}
			}
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
			}
		}
	}

	/**
	 * Fetches a list of users who have been definitively assigned to an event's
	 * final team.
	 * 
	 * @param eventId The ID of the event.
	 * @return A list of assigned User objects.
	 */
	public List<User> getAssignedUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, u.role FROM users u "
				+ "JOIN event_assignments ea ON u.id = ea.user_id WHERE ea.event_id = ?";
		logger.debug("Fetching assigned users for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					users.add(mapResultSetToSimpleUser(rs));
				}
			}
			logger.info("Found {} assigned users for event ID: {}", users.size(), eventId);
		} catch (SQLException e) {
			logger.error("SQL error fetching assigned users for event ID: {}", eventId, e);
		}
		return users;
	}

	/**
	 * Saves the final assignment of users to an event. This is a transactional
	 * operation: it first clears all existing assignments for the event and then
	 * inserts the new ones.
	 * 
	 * @param eventId The ID of the event.
	 * @param userIds An array of user IDs to be assigned.
	 */
	public void assignUsersToEvent(int eventId, String[] userIds) {
		String deleteSql = "DELETE FROM event_assignments WHERE event_id = ?";
		String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning users to event ID: {}", eventId);
		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false); // Start transaction

			// 1. Delete all previous assignments for this event
			try (PreparedStatement deletePstmt = conn.prepareStatement(deleteSql)) {
				deletePstmt.setInt(1, eventId);
				deletePstmt.executeUpdate();
			}

			// 2. Insert the new assignments if any users were selected
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertPstmt = conn.prepareStatement(insertSql)) {
					for (String userId : userIds) {
						insertPstmt.setInt(1, eventId);
						insertPstmt.setInt(2, Integer.parseInt(userId));
						insertPstmt.addBatch();
					}
					insertPstmt.executeBatch();
				}
			}

			conn.commit(); // Commit transaction
			logger.info("Successfully assigned {} users to event ID {}", (userIds != null ? userIds.length : 0),
					eventId);

		} catch (SQLException | NumberFormatException e) {
			logger.error("SQL transaction error during user assignment for event ID: {}. Rolling back.", eventId, e);
			if (conn != null) {
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction.", ex);
				}
			}
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
			}
		}
	}

	/**
	 * Fetches all upcoming events for a user, with a calculated status that
	 * prioritizes assignments over simple sign-ups. Status can be: ZUGEWIESEN,
	 * ANGEMELDET, ABGEMELDET, or OFFEN.
	 *
	 * @param user  The currently logged-in user.
	 * @param limit The maximum number of events to return (0 for no limit).
	 * @return A list of upcoming Event objects with the correctly calculated user
	 *         status.
	 */
	public List<Event> getUpcomingEventsForUser(User user, int limit) {
		List<Event> events = new ArrayList<>();

		// This intelligent SQL query calculates the most relevant status for the user.
		// It prioritizes "ZUGEWIESEN" (assigned) over "ANGEMELDET" (signed up).
		String sql = "SELECT e.*, " + "CASE " + "    WHEN eas.user_id IS NOT NULL THEN 'ZUGEWIESEN' " + // 1. Check for
																										// assignment
																										// first
				"    WHEN ea.signup_status IS NOT NULL THEN ea.signup_status " + // 2. Fall back to signup status
				"    ELSE 'OFFEN' " + // 3. Default to open
				"END AS calculated_user_status " + "FROM events e "
				+ "LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.user_id = ? "
				+ "LEFT JOIN event_assignments eas ON e.id = eas.event_id AND eas.user_id = ? "
				+ "WHERE e.event_datetime >= NOW() " + "AND (" + // Qualification check remains the same
				"  NOT EXISTS (SELECT 1 FROM event_skill_requirements esr WHERE esr.event_id = e.id) OR "
				+ "  EXISTS (SELECT 1 FROM event_skill_requirements esr JOIN user_qualifications uq ON esr.required_course_id = uq.course_id WHERE esr.event_id = e.id AND uq.user_id = ?)"
				+ ") " + "ORDER BY e.event_datetime ASC" + (limit > 0 ? " LIMIT ?" : "");

		logger.debug("Fetching upcoming events for user ID: {} with limit: {}", user.getId(), limit);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			// Set the user ID for all three placeholders in the query
			pstmt.setInt(1, user.getId());
			pstmt.setInt(2, user.getId());
			pstmt.setInt(3, user.getId());
			if (limit > 0) {
				pstmt.setInt(4, limit);
			}

			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Event event = mapResultSetToEvent(rs); // Use your existing helper

					// Get the final calculated status from our new CASE statement
					String finalStatus = rs.getString("calculated_user_status");
					event.setUserAttendanceStatus(finalStatus);

					events.add(event);
				}
				logger.info("Found {} qualified upcoming events for user ID {}", events.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualified upcoming events for user {}", user.getId(), e);
		}
		return events;
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		String deleteSql = "DELETE FROM event_storage_reservations WHERE event_id = ?";
		String insertSql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";

		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false); // Start transaction

			// 1. Clear existing reservations
			try (PreparedStatement deletePstmt = conn.prepareStatement(deleteSql)) {
				deletePstmt.setInt(1, eventId);
				deletePstmt.executeUpdate();
			}

			// 2. Insert new reservations
			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				try (PreparedStatement insertPstmt = conn.prepareStatement(insertSql)) {
					for (int i = 0; i < itemIds.length; i++) {
						if (itemIds[i] == null || itemIds[i].isEmpty())
							continue;
						insertPstmt.setInt(1, eventId);
						insertPstmt.setInt(2, Integer.parseInt(itemIds[i]));
						insertPstmt.setInt(3, Integer.parseInt(quantities[i]));
						insertPstmt.addBatch();
					}
					insertPstmt.executeBatch();
				}
			}
			conn.commit();
			logger.info("Successfully saved storage reservations for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException e) {
			logger.error("Error saving storage reservations for event {}. Rolling back.", eventId, e);
			if (conn != null)
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction.", ex);
				}
		} finally {
			if (conn != null)
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr "
				+ "JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					StorageItem item = new StorageItem();
					item.setId(rs.getInt("id"));
					item.setName(rs.getString("name"));
					item.setQuantity(rs.getInt("reserved_quantity")); // Use quantity field to hold reserved amount
					items.add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching reserved items for event ID: {}", eventId, e);
		}
		return items;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for managing event-specific tasks in the `event_tasks`
 * table. It handles creating, assigning, updating status, and deleting tasks
 * associated with a "running" event.
 */
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);

	/**
	 * Creates a new task for an event.
	 * 
	 * @param task The EventTask object to create.
	 * @return The ID of the newly created task, or 0 on failure.
	 */
	public int createTask(EventTask task) {
		String sql = "INSERT INTO event_tasks (event_id, description, status) VALUES (?, ?, 'OFFEN')";
		logger.debug("Creating new task '{}' for event ID {}", task.getDescription(), task.getEventId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setInt(1, task.getEventId());
			pstmt.setString(2, task.getDescription());
			if (pstmt.executeUpdate() > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int taskId = rs.getInt(1);
						logger.info("Created task '{}' with ID {} for event {}", task.getDescription(), taskId,
								task.getEventId());
						return taskId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating task for event {}", task.getEventId(), e);
		}
		return 0;
	}

	/**
	 * Assigns a task to one or more users. This is a transactional operation that
	 * first clears all existing assignments for the task and then adds the new
	 * ones.
	 * 
	 * @param taskId  The ID of the task.
	 * @param userIds The array of user IDs to assign to the task.
	 */
	public void assignTaskToUsers(int taskId, int[] userIds) {
		String deleteSql = "DELETE FROM event_task_assignments WHERE task_id = ?";
		String insertSql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning task ID {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false); // Start transaction

			// 1. Delete old assignments
			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, taskId);
				deleteStmt.executeUpdate();
			}

			// 2. Insert new assignments
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (int userId : userIds) {
						insertStmt.setInt(1, taskId);
						insertStmt.setInt(2, userId);
						insertStmt.addBatch();
					}
					insertStmt.executeBatch();
				}
			}

			conn.commit(); // Commit transaction
			logger.info("Successfully assigned task {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		} catch (SQLException e) {
			logger.error("Error during transaction for assigning task {}. Rolling back.", taskId, e);
			if (conn != null) {
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction for task assignment.", ex);
				}
			}
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection after task assignment transaction.", ex);
				}
			}
		}
	}

	/**
	 * Updates the status of a task (e.g., from "OFFEN" to "ERLEDIGT").
	 * 
	 * @param taskId The ID of the task.
	 * @param status The new status string.
	 * @return true if the update was successful.
	 */
	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		logger.debug("Updating status for task ID {} to '{}'", taskId, status);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Deletes a task and its assignments (due to database foreign key constraints).
	 * 
	 * @param taskId The ID of the task to delete.
	 * @return true if successful.
	 */
	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		logger.warn("Attempting to delete task with ID: {}", taskId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Fetches all tasks for a given event, including a comma-separated list of
	 * usernames of assigned users for easy display.
	 * 
	 * @param eventId The event's ID.
	 * @return A list of EventTask objects.
	 */
	public List<EventTask> getTasksForEvent(int eventId) {
		List<EventTask> tasks = new ArrayList<>();
		// This query uses GROUP_CONCAT to aggregate assigned usernames into a single
		// string
		String sql = "SELECT t.id, t.event_id, t.description, t.status, "
				+ "GROUP_CONCAT(u.username SEPARATOR ', ') as assigned_usernames " + "FROM event_tasks t "
				+ "LEFT JOIN event_task_assignments ta ON t.id = ta.task_id "
				+ "LEFT JOIN users u ON ta.user_id = u.id " + "WHERE t.event_id = ? "
				+ "GROUP BY t.id, t.event_id, t.description, t.status " + "ORDER BY t.id";
		logger.debug("Fetching all tasks for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setAssignedUsernames(rs.getString("assigned_usernames"));
					tasks.add(task);
				}
				logger.info("Found {} tasks for event ID: {}", tasks.size(), eventId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching tasks for event {}", eventId, e);
		}
		return tasks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * This DAO manages metadata of uploaded files stored in the `files` and
 * `file_categories` tables. It handles creating, reading, and deleting file
 * records and categories. It includes role-based filtering to control file
 * visibility and logic to group files by category for display in the UI. It
 * also provides methods to manage a simple key-value content store in the
 * `shared_documents` table.
 */
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);

	/**
	 * Helper method to map a row from a ResultSet to a File object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated File object.
	 * @throws SQLException If a database error occurs.
	 */
	private File mapResultSetToFile(ResultSet rs) throws SQLException {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));

		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}

		String categoryName = rs.getString("category_name");
		file.setCategoryName(categoryName == null ? "Ohne Kategorie" : categoryName);

		return file;
	}

	/**
	 * Fetches all file records, applying role-based filtering, and groups them by
	 * category name.
	 * 
	 * @param user The current user, used to determine their role.
	 * @return A Map where keys are category names and values are lists of files.
	 */
	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		logger.debug("Fetching all files grouped by category for user role: {}", user.getRole());
		List<File> files = new ArrayList<>();

		String sql = "SELECT f.*, fc.name as category_name FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id ";

		if (!"ADMIN".equalsIgnoreCase(user.getRole())) {
			sql += "WHERE f.required_role = 'NUTZER' ";
			logger.debug("Applying 'NUTZER' role filter for file query.");
		}

		sql += "ORDER BY fc.name, f.filename";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				files.add(mapResultSetToFile(rs));
			}
			logger.info("Fetched {} files visible to user role '{}'.", files.size(), user.getRole());
		} catch (SQLException e) {
			logger.error("SQL error while fetching files.", e);
		}

		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	/**
	 * Creates a new file metadata record in the database.
	 * 
	 * @param file The File object to persist.
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Creating file record for '{}' with role '{}'", file.getFilename(), file.getRequiredRole());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			if (file.getCategoryId() > 0) {
				pstmt.setInt(3, file.getCategoryId());
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setString(4, file.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file record for '{}'", file.getFilename(), e);
			return false;
		}
	}

	/**
	 * Fetches all file categories from the database, sorted by name.
	 * 
	 * @return A list of FileCategory objects.
	 */
	public List<FileCategory> getAllCategories() {
		List<FileCategory> categories = new ArrayList<>();
		String sql = "SELECT * FROM file_categories ORDER BY name";
		logger.debug("Fetching all file categories.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				categories.add(cat);
			}
			logger.info("Fetched {} file categories.", categories.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching file categories.", e);
		}
		return categories;
	}

	/**
	 * Retrieves a single file's metadata by its ID.
	 *
	 * @param fileId The ID of the file to retrieve.
	 * @return A File object populated with data, or null if not found.
	 */
	public File getFileById(int fileId) {
		logger.debug("Fetching file by ID: {}", fileId);
		String sql = "SELECT f.*, fc.name as category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id " + "WHERE f.id = ?";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found file with ID: {}", fileId);
					return mapResultSetToFile(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching file with ID: {}", fileId, e);
		}

		logger.warn("No file found with ID: {}", fileId);
		return null;
	}

	/**
	 * Deletes a file record from the 'files' table in the database. Note: This
	 * method ONLY deletes the database record. The physical file must be deleted
	 * separately by the calling servlet.
	 *
	 * @param fileId The ID of the file record to delete.
	 * @return true if the database record was successfully deleted, false
	 *         otherwise.
	 */
	public boolean deleteFile(int fileId) {
		logger.warn("Attempting to delete file record from database with ID: {}", fileId);
		String sql = "DELETE FROM files WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				logger.info("Successfully deleted file record with ID: {}", fileId);
				return true;
			} else {
				logger.warn("Could not delete file record with ID: {}. It might not exist.", fileId);
				return false;
			}
		} catch (SQLException e) {
			logger.error("SQL error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	/**
	 * Creates a new file category.
	 * 
	 * @param categoryName The name of the new category.
	 * @return true if successful.
	 */
	public boolean createCategory(String categoryName) {
		logger.info("Creating new file category: {}", categoryName);
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, categoryName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	/**
	 * Updates the name of an existing file category.
	 * 
	 * @param categoryId The ID of the category to update.
	 * @param newName    The new name for the category.
	 * @return true if successful.
	 */
	public boolean updateCategory(int categoryId, String newName) {
		String sql = "UPDATE file_categories SET name = ? WHERE id = ?";
		logger.debug("Updating category ID {} to new name '{}'", categoryId, newName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newName);
			pstmt.setInt(2, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Deletes a file category. Due to "ON DELETE SET NULL" constraint in the DB,
	 * files in this category will have their category_id set to NULL.
	 * 
	 * @param categoryId The ID of the category to delete.
	 * @return true if successful.
	 */
	public boolean deleteCategory(int categoryId) {
		logger.warn("Attempting to delete category ID: {}", categoryId);
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Retrieves the name of a category by its ID.
	 * 
	 * @param categoryId The ID of the category.
	 * @return The category name, or null if not found.
	 */
	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		logger.debug("Fetching category name for ID: {}", categoryId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("name");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
		}
		return null;
	}

	/**
	 * Retrieves the content of a shared document (e.g., for the collaborative
	 * editor).
	 * 
	 * @param documentName The unique name/key of the document.
	 * @return The document's content as a string, or an empty string if not found.
	 */
	public String getDocumentContent(String documentName) {
		String sql = "SELECT content FROM shared_documents WHERE document_name = ?";
		logger.trace("Fetching document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("content");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching document content for name: {}", documentName, e);
		}
		return "";
	}

	/**
	 * Updates the content of a shared document.
	 * 
	 * @param documentName The unique name/key of the document to update.
	 * @param content      The new content to save.
	 * @return true if the update was successful.
	 */
	public boolean updateDocumentContent(String documentName, String content) {
		String sql = "UPDATE shared_documents SET content = ? WHERE document_name = ?";
		logger.trace("Updating document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, content);
			pstmt.setString(2, documentName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating document content for name: {}", documentName, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.MeetingAttachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing file attachments for meetings, interacting with the
 * `meeting_attachments` table. It handles adding, retrieving (with role-based
 * filtering), and deleting file attachments associated with a specific meeting.
 */
public class MeetingAttachmentDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttachmentDAO.class);

	/**
	 * Attaches a file to a meeting by creating a record in the database.
	 * 
	 * @param attachment The MeetingAttachment object to persist.
	 * @return true if the record was successfully created.
	 */
	public boolean addAttachment(MeetingAttachment attachment) {
		String sql = "INSERT INTO meeting_attachments (meeting_id, filename, filepath, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to meeting ID {}", attachment.getFilename(), attachment.getMeetingId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachment.getMeetingId());
			pstmt.setString(2, attachment.getFilename());
			pstmt.setString(3, attachment.getFilepath());
			pstmt.setString(4, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to meeting {}", attachment.getMeetingId(), e);
			return false;
		}
	}

	/**
	 * Gets all attachments for a specific meeting, optionally filtering by user
	 * role. Admins see all files, while regular users only see files marked as
	 * 'NUTZER'.
	 * 
	 * @param meetingId The ID of the meeting.
	 * @param userRole  The role of the current user ("ADMIN" or "NUTZER").
	 * @return A list of MeetingAttachment objects.
	 */
	public List<MeetingAttachment> getAttachmentsForMeeting(int meetingId, String userRole) {
		List<MeetingAttachment> attachments = new ArrayList<>();

		String sql = "SELECT * FROM meeting_attachments WHERE meeting_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
			logger.debug("Fetching attachments for meeting {} with NUTZER role filter.", meetingId);
		} else {
			logger.debug("Fetching attachments for meeting {} with ADMIN role (no filter).", meetingId);
		}

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setMeetingId(rs.getInt("meeting_id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
					att.setRequiredRole(rs.getString("required_role"));
					attachments.add(att);
				}
				logger.info("Found {} attachments for meeting ID {}.", attachments.size(), meetingId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for meeting {}", meetingId, e);
		}
		return attachments;
	}

	/**
	 * Gets a single attachment by its ID, without any role check. This is typically
	 * used internally by admin functions like deletion.
	 * 
	 * @param attachmentId The ID of the attachment.
	 * @return A MeetingAttachment object or null if not found.
	 */
	public MeetingAttachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM meeting_attachments WHERE id = ?";
		logger.debug("Fetching attachment by ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setMeetingId(rs.getInt("meeting_id"));
					return att;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		logger.warn("No attachment found for ID: {}", attachmentId);
		return null;
	}

	/**
	 * Deletes an attachment record from the database. The physical file must be
	 * deleted separately.
	 * 
	 * @param attachmentId The ID of the attachment to delete.
	 * @return true if successful.
	 */
	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM meeting_attachments WHERE id = ?";
		logger.warn("Attempting to delete attachment with ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling user attendance at specific course meetings.
 * It interacts with the `meeting_attendance` table to record whether a user
 * attended a meeting, along with any relevant remarks.
 */
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class.getName());

	/**
	 * Sets or updates a user's attendance status for a specific meeting. Uses an
	 * efficient "INSERT ... ON DUPLICATE KEY UPDATE" (upsert) operation. This
	 * single method handles both signing up (attended=true) and signing off
	 * (attended=false).
	 *
	 * @param userId    The user's ID.
	 * @param meetingId The meeting's ID.
	 * @param attended  true if the user attended, false otherwise.
	 * @param remarks   Any notes about the attendance (e.g., "excused absence").
	 * @return true if the operation was successful.
	 */
	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";

		logger.debug("Setting attendance for user {} at meeting {} to attended={}", userId, meetingId, attended);

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			pstmt.setInt(2, meetingId);
			pstmt.setBoolean(3, attended);
			pstmt.setString(4, remarks);

			pstmt.executeUpdate();
			logger.info("Successfully set attendance for user {} at meeting {} to attended={}", userId, meetingId,
					attended);
			return true;

		} catch (SQLException e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all attendance records from the database. This is highly efficient
	 * for building the data map used by the qualification matrix view.
	 * 
	 * @return A list of all MeetingAttendance objects in the database.
	 */
	public List<MeetingAttendance> getAllAttendance() {
		List<MeetingAttendance> allAttendance = new ArrayList<>();
		String sql = "SELECT * FROM meeting_attendance";
		logger.debug("Fetching all meeting attendance records for matrix.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				allAttendance.add(mapResultSetToAttendance(rs));
			}
			logger.info("Fetched {} total attendance records.", allAttendance.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all attendance records.", e);
		}
		return allAttendance;
	}

	/**
	 * Helper method to map a ResultSet row to a MeetingAttendance object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated MeetingAttendance object.
	 * @throws SQLException If a database error occurs.
	 */
	private MeetingAttendance mapResultSetToAttendance(ResultSet rs) throws SQLException {
		MeetingAttendance attendance = new MeetingAttendance();
		attendance.setUserId(rs.getInt("user_id"));
		attendance.setMeetingId(rs.getInt("meeting_id"));
		attendance.setAttended(rs.getBoolean("attended"));
		attendance.setRemarks(rs.getString("remarks"));
		return attendance;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;

/**
 * Data Access Object for all Meeting-related database operations. It handles
 * CRUD for individual, schedulable course meetings stored in the `meetings`
 * table. It's distinct from CourseDAO, which manages the parent course
 * templates.
 */
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);

	/**
	 * Creates a new meeting in the database, linked to a parent course.
	 * 
	 * @param meeting The Meeting object to create.
	 * @return The ID of the newly created meeting, or 0 on failure.
	 */
	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create meeting '{}' for course ID {}", meeting.getName(), meeting.getCourseId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

			pstmt.setInt(1, meeting.getCourseId());
			pstmt.setString(2, meeting.getName());
			pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(4, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(5, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			pstmt.setString(6, meeting.getDescription());
			pstmt.setString(7, meeting.getLocation());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int newId = rs.getInt(1);
						logger.info("Successfully created meeting '{}' with new ID {}", meeting.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating meeting: {}", meeting.getName(), e);
		}
		return 0; // Return 0 on failure
	}

	/**
	 * Fetches a single meeting by its ID, joining with the courses and users tables
	 * to get the parent course name and leader's username.
	 * 
	 * @param meetingId The ID of the meeting to retrieve.
	 * @return A Meeting object, or null if not found.
	 */
	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		logger.debug("Fetching meeting by ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found meeting with ID: {}", meetingId);
					return mapResultSetToMeeting(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meeting by ID: {}", meetingId, e);
		}
		logger.warn("No meeting found with ID: {}", meetingId);
		return null;
	}

	/**
	 * Fetches all scheduled meetings that belong to a specific parent course.
	 * Crucial for building the qualification matrix view.
	 * 
	 * @param courseId The ID of the parent course.
	 * @return A list of Meeting objects, sorted by date.
	 */
	public List<Meeting> getMeetingsForCourse(int courseId) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username "
				+ "FROM meetings m JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		logger.debug("Fetching all meetings for course ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					meetings.add(mapResultSetToMeeting(rs));
				}
				logger.info("Found {} meetings for course ID: {}", meetings.size(), courseId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meetings for course ID: {}", courseId, e);
		}
		return meetings;
	}

	/**
	 * Fetches all meetings from the database, typically for an admin list view.
	 * Includes the parent course name and leader's username.
	 * 
	 * @return A list of all Meeting objects.
	 */
	public List<Meeting> getAllMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id " + "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "ORDER BY m.meeting_datetime DESC";
		logger.debug("Fetching all meetings from the database.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
			logger.info("Fetched a total of {} meetings.", meetings.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all meetings.", e);
		}
		return meetings;
	}

	/**
	 * Helper method to map a row from a ResultSet to a Meeting object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Meeting object.
	 * @throws SQLException If a database error occurs.
	 */
	private Meeting mapResultSetToMeeting(ResultSet rs) throws SQLException {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));

		return meeting;
	}

	/**
	 * Updates an existing meeting in the database.
	 * 
	 * @param meeting The Meeting object with updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		logger.debug("Attempting to update meeting ID: {}", meeting.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, meeting.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(4, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(4, Types.INTEGER);
			}
			pstmt.setString(5, meeting.getDescription());
			pstmt.setString(6, meeting.getLocation());
			pstmt.setInt(7, meeting.getId());

			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated meeting with ID: {}", meeting.getId());
			return success;

		} catch (SQLException e) {
			logger.error("SQL error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a meeting from the database.
	 * 
	 * @param meetingId The ID of the meeting to delete.
	 * @return true if deletion was successful.
	 */
	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		logger.warn("Attempting to delete meeting with ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully deleted meeting with ID: {}", meetingId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all upcoming meetings, enriched with the attendance status for a
	 * specific user (ANGEMELDET, ABGEMELDET, OFFEN).
	 * 
	 * @param user The currently logged-in user.
	 * @return A list of upcoming Meeting objects with user-specific status.
	 */
	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended "
				+ "FROM meetings m " + "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? "
				+ "WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";

		logger.debug("Fetching upcoming meetings for user ID: {}", user.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, user.getId());
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Meeting meeting = mapResultSetToMeeting(rs);

					// Set the user-specific status based on the 'attended' flag from the join
					if (rs.getObject("attended") != null) {
						meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
					} else {
						meeting.setUserAttendanceStatus("OFFEN");
					}
					meetings.add(meeting);
				}
				logger.info("Found {} upcoming meetings for user ID: {}", meetings.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for user {}", user.getId(), e);
		}
		return meetings;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\PasskeyCredentialDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.PasskeyCredential;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * Data Access Object for managing Passkey (WebAuthn) credentials in the
 * `user_passkeys` table.
 */
public class PasskeyCredentialDAO {
	private static final Logger logger = LogManager.getLogger(PasskeyCredentialDAO.class);

	/**
	 * Adds a new passkey credential to the database for a user.
	 *
	 * @param credential The PasskeyCredential object to save.
	 */
	public void addCredential(PasskeyCredential credential) {
		String sql = "INSERT INTO user_passkeys (user_id, name, credential_id, public_key, signature_count, user_handle) VALUES (?, ?, ?, ?, ?, ?)";
		logger.debug("Adding passkey for user ID {}", credential.getUserId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, credential.getUserId());
			pstmt.setString(2, credential.getName());
			pstmt.setString(3, credential.getCredentialId());
			pstmt.setString(4, credential.getPublicKey());
			pstmt.setLong(5, credential.getSignatureCount());
			pstmt.setString(6, credential.getUserHandle());
			pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error adding passkey credential for user ID {}", credential.getUserId(), e);
		}
	}

	/**
	 * Retrieves all passkey credentials registered for a specific user.
	 *
	 * @param userId The ID of the user.
	 * @return A list of PasskeyCredential objects.
	 */
	public List<PasskeyCredential> getCredentialsForUser(int userId) {
		List<PasskeyCredential> credentials = new ArrayList<>();
		String sql = "SELECT * FROM user_passkeys WHERE user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					credentials.add(mapResultSetToCredential(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching passkeys for user ID {}", userId, e);
		}
		return credentials;
	}

	/**
	 * Retrieves a passkey credential by its unique credential ID.
	 *
	 * @param credentialId The base64url-encoded credential ID.
	 * @return An Optional containing the PasskeyCredential if found.
	 */
	public Optional<PasskeyCredential> getCredentialById(String credentialId) {
		String sql = "SELECT * FROM user_passkeys WHERE credential_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, credentialId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return Optional.of(mapResultSetToCredential(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching passkey by credential ID {}", credentialId, e);
		}
		return Optional.empty();
	}

	/**
	 * Retrieves a passkey credential by its user handle.
	 *
	 * @param userHandle The base64url-encoded user handle.
	 * @return An Optional containing the PasskeyCredential if found.
	 */
	public Optional<PasskeyCredential> getCredentialByUserHandle(String userHandle) {
		String sql = "SELECT * FROM user_passkeys WHERE user_handle = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, userHandle);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return Optional.of(mapResultSetToCredential(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching passkey by user handle {}", userHandle, e);
		}
		return Optional.empty();
	}

	/**
	 * Updates the signature count for a given credential after a successful login.
	 *
	 * @param credentialId      The ID of the credential to update.
	 * @param newSignatureCount The new signature count.
	 */
	public void updateSignatureCount(String credentialId, long newSignatureCount) {
		String sql = "UPDATE user_passkeys SET signature_count = ? WHERE credential_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setLong(1, newSignatureCount);
			pstmt.setString(2, credentialId);
			pstmt.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error updating signature count for credential ID {}", credentialId, e);
		}
	}

	/**
	 * Deletes a passkey credential from the database.
	 *
	 * @param credentialId The ID of the credential record to delete.
	 * @param userId       The ID of the user who owns the credential.
	 * @return true if the deletion was successful, false otherwise.
	 */
	public boolean deleteCredential(int credentialId, int userId) {
		String sql = "DELETE FROM user_passkeys WHERE id = ? AND user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, credentialId);
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting passkey ID {} for user ID {}", credentialId, userId, e);
			return false;
		}
	}

	private PasskeyCredential mapResultSetToCredential(ResultSet rs) throws SQLException {
		return new PasskeyCredential(rs.getInt("id"), rs.getInt("user_id"), rs.getString("name"),
				rs.getString("credential_id"), rs.getString("public_key"), rs.getLong("signature_count"),
				rs.getString("user_handle"), rs.getTimestamp("created_at").toLocalDateTime());
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * A simple Data Access Object used to retrieve basic aggregate numbers from the
 * database, such as the total count of users and the number of active, upcoming
 * events. This is primarily used for the administrative dashboard.
 */

public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);

	/**
	 * Gets the total count of all users in the `users` table.
	 * 
	 * @return The total number of users.
	 */
	public int getUserCount() {
		logger.debug("Getting user count.");
		return getCount("SELECT COUNT(*) FROM users");
	}

	/**
	 * Gets the count of all events that are not yet in the past.
	 * 
	 * @return The number of active/upcoming events.
	 */
	public int getActiveEventCount() {
		logger.debug("Getting active event count.");
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	/**
	 * A generic helper method to execute a `SELECT COUNT(*)` query.
	 * 
	 * @param sql The SQL query to execute.
	 * @return The count, or 0 if an error occurs.
	 */
	private int getCount(String sql) {
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			if (rs.next()) {
				int count = rs.getInt(1);
				logger.info("Count query '{}' returned {}.", sql, count);
				return count;
			}
		} catch (SQLException e) {
			logger.error("SQL error executing count query: {}", sql, e);
		}
		return 0;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * DAO for managing inventory in the `storage_items` table.
 */
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class.getName());

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items ORDER BY location, cabinet, shelf, name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching storage items.", e);
		}
		return items.stream().collect(Collectors.groupingBy(StorageItem::getLocation));
	}

	public List<StorageItem> getDefectiveItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching defective items.", e);
		}
		return items;
	}

	private StorageItem mapResultSetToStorageItem(ResultSet rs) throws SQLException {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setShelf(rs.getString("shelf"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		return item;
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT * FROM storage_items WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			ResultSet rs = pstmt.executeQuery();
			if (rs.next()) {
				return mapResultSetToStorageItem(rs);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage item by ID: {}", itemId, e);
		}
		return null;
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, shelf, compartment, quantity, max_quantity, weight_kg, price_eur, image_path) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getShelf());
			pstmt.setString(5, item.getCompartment());
			pstmt.setInt(6, item.getQuantity());
			pstmt.setInt(7, item.getMaxQuantity());
			pstmt.setDouble(8, item.getWeightKg());
			pstmt.setDouble(9, item.getPriceEur());
			pstmt.setString(10, item.getImagePath());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, shelf=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=? WHERE id=?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getShelf());
			pstmt.setString(5, item.getCompartment());
			pstmt.setInt(6, item.getQuantity());
			pstmt.setInt(7, item.getMaxQuantity());
			pstmt.setInt(8, item.getDefectiveQuantity());
			pstmt.setString(9, item.getDefectReason());
			pstmt.setDouble(10, item.getWeightKg());
			pstmt.setDouble(11, item.getPriceEur());
			pstmt.setString(12, item.getImagePath());
			pstmt.setInt(13, item.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean updateItemQuantity(int itemId, int quantityChange) throws SQLException {
		String sql = "UPDATE storage_items SET quantity = quantity + ? WHERE id = ? AND quantity + ? >= defective_quantity";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantityChange);
			pstmt.setInt(2, itemId);
			pstmt.setInt(3, quantityChange);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean updateDefectiveStatus(int itemId, int defectiveQty, String reason) throws SQLException {
		String sql = "UPDATE storage_items SET defective_quantity = ?, defect_reason = ? WHERE id = ? AND ? <= quantity";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, defectiveQty);
			pstmt.setString(2, reason);
			pstmt.setInt(3, itemId);
			pstmt.setInt(4, defectiveQty);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for logging storage item transactions (check-ins and
 * check-outs) into the `storage_log` table. This provides a history of
 * inventory movements.
 */
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);

	/**
	 * Logs a single transaction (check-in or check-out) to the database.
	 * 
	 * @param itemId         The ID of the item involved in the transaction.
	 * @param userId         The ID of the user performing the transaction.
	 * @param quantityChange The number of items moved (positive for check-in,
	 *                       negative for check-out).
	 * @param notes          Optional notes for the transaction (e.g., purpose,
	 *                       event).
	 * @param eventId        Optional ID of the event this transaction is for.
	 * @return true if the log entry was created successfully.
	 */
	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Logging storage transaction for item {}, user {}, change {}, event {}", itemId, userId,
				quantityChange, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, quantityChange);
			pstmt.setString(4, notes);
			if (eventId > 0) {
				pstmt.setInt(5, eventId);
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Failed to log storage transaction for item {}", itemId, e);
			return false;
		}
	}

	/**
	 * Fetches the transaction history for a specific storage item.
	 * 
	 * @param itemId The ID of the item.
	 * @return A list of storage log entries.
	 */
	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		List<StorageLogEntry> history = new ArrayList<>();
		String sql = "SELECT sl.*, u.username FROM storage_log sl " + "JOIN users u ON sl.user_id = u.id "
				+ "WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		logger.debug("Fetching storage history for item ID: {}", itemId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					StorageLogEntry entry = new StorageLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setQuantityChange(rs.getInt("quantity_change"));
					entry.setNotes(rs.getString("notes"));
					entry.setEventId(rs.getInt("event_id"));
					entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
		}
		return history;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;

/**
 * A core DAO responsible for all user account management, interacting with the
 * `users` table. Its functions include validating user credentials for login,
 * fetching single or all user records, creating, updating, and deleting users,
 * and handling password changes.
 */
public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);

	/**
	 * Robustly maps a ResultSet row to a User object, checking for optional columns
	 * before attempting to read them.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated User object.
	 * @throws SQLException if a database error occurs.
	 */
	private User mapResultSetToUser(ResultSet rs) throws SQLException {
		User user = new User(rs.getInt("id"), rs.getString("username"), rs.getString("role"));
		if (DaoUtils.hasColumn(rs, "created_at") && rs.getTimestamp("created_at") != null) {
			user.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(rs, "class_year")) {
			user.setClassYear(rs.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(rs, "class_name")) {
			user.setClassName(rs.getString("class_name"));
		}
		return user;
	}

	/**
	 * Validates user credentials against the database. IMPORTANT: This
	 * implementation uses plaintext passwords for validation, which is insecure and
	 * should be replaced with a password hashing mechanism (e.g., BCrypt) in a
	 * production environment.
	 * 
	 * @param username The user's username.
	 * @param password The user's plaintext password.
	 * @return A User object if validation is successful, null otherwise.
	 */
	public User validateUser(String username, String password) {
		String sql = "SELECT * FROM users WHERE username = ? AND password_hash = ?";
		logger.debug("Validating user credentials for username: {}", username);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, username);
			pstmt.setString(2, password);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("User validation successful for username: {}", username);
					return mapResultSetToUser(rs);
				} else {
					logger.warn("User validation failed for username: {}", username);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error during user validation for username: {}", username, e);
		}
		return null;
	}

	/**
	 * Fetches all users from the database, sorted by username.
	 * 
	 * @return A list of all User objects.
	 */
	public List<User> getAllUsers() {
		List<User> users = new ArrayList<>();
		String sql = "SELECT * FROM users ORDER BY username";
		logger.debug("Fetching all users.");
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			while (rs.next()) {
				users.add(mapResultSetToUser(rs));
			}
			logger.info("Fetched {} total users.", users.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all users", e);
		}
		return users;
	}

	/**
	 * Fetches a single user by their unique ID.
	 * 
	 * @param userId The ID of the user to fetch.
	 * @return A User object, or null if not found.
	 */
	public User getUserById(int userId) {
		String sql = "SELECT * FROM users WHERE id = ?";
		logger.debug("Fetching user by ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found user '{}' with ID: {}", rs.getString("username"), userId);
					return mapResultSetToUser(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching user by ID: {}", userId, e);
		}
		logger.warn("No user found with ID: {}", userId);
		return null;
	}

	/**
	 * Fetches a single user by their unique username.
	 *
	 * @param username The username of the user to fetch.
	 * @return A User object, or null if not found.
	 */
	public User getUserByUsername(String username) {
		String sql = "SELECT * FROM users WHERE username = ?";
		logger.debug("Fetching user by username: {}", username);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, username);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found user with username: {}", username);
					return mapResultSetToUser(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching user by username: {}", username, e);
		}
		logger.warn("No user found with username: {}", username);
		return null;
	}

	/**
	 * Creates a new user in the database.
	 * 
	 * @param user     The User object containing the data to be inserted.
	 * @param password The plain text password (should be hashed in production).
	 * @return The ID of the newly created user, or 0 if creation failed.
	 */
	public int createUser(User user, String password) {
		String sql = "INSERT INTO users (username, password_hash, role, class_year, class_name) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Attempting to create user: {}", user.getUsername());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

			pstmt.setString(1, user.getUsername());
			pstmt.setString(2, password); // In a real app, this should be a hash.
			pstmt.setString(3, user.getRole());
			pstmt.setInt(4, user.getClassYear());
			pstmt.setString(5, user.getClassName());

			int affectedRows = pstmt.executeUpdate();

			if (affectedRows > 0) {
				try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newUserId = generatedKeys.getInt(1);
						logger.info("Successfully created user '{}' with ID: {}", user.getUsername(), newUserId);
						return newUserId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating user '{}'. Username might already exist.", user.getUsername(), e);
		}
		return 0;
	}

	/**
	 * Updates an existing user's profile information in the database.
	 * 
	 * @param user The User object containing the updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateUser(User user) {
		logger.debug("Updating user with ID: {}", user.getId());
		String sql = "UPDATE users SET username = ?, role = ?, class_year = ?, class_name = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, user.getUsername());
			pstmt.setString(2, user.getRole());
			pstmt.setInt(3, user.getClassYear());
			pstmt.setString(4, user.getClassName());
			pstmt.setInt(5, user.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating user with ID: {}", user.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a user from the database.
	 * 
	 * @param userId The ID of the user to delete.
	 * @return true if the deletion was successful.
	 */
	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		logger.warn("Attempting to delete user with ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting user with ID: {}", userId, e);
			return false;
		}
	}

	/**
	 * Changes a user's password.
	 * 
	 * @param userId      The ID of the user whose password is to be changed.
	 * @param newPassword The new plaintext password.
	 * @return true if the password was changed successfully.
	 */
	public boolean changePassword(int userId, String newPassword) {
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		logger.debug("Changing password for user ID: {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newPassword); // Should be a hash in production.
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error changing password for user ID: {}", userId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.UserQualification;

/**
 * This DAO manages the `user_qualifications` table, which links users to the
 * courses they have completed. It's used to track which skills a user
 * possesses. Its key functions are fetching qualifications for a single user or
 * all users, and updating a user's qualification status for a specific course.
 */
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);

	/**
	 * Fetches all qualifications for a single user. This is typically used for a
	 * user's profile or details page.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of UserQualification objects.
	 */
	public List<UserQualification> getQualificationsForUser(int userId) {
		logger.debug("Fetching qualifications for user ID: {}", userId);
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id " + "WHERE uq.user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					qualifications.add(mapResultSetToUserQualification(rs));
				}
				logger.info("Found {} qualifications for user ID: {}", qualifications.size(), userId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
		}
		return qualifications;
	}

	/**
	 * Fetches all qualification records for all users. This is used to build the
	 * data for an overview or matrix page.
	 * 
	 * @return A list of all UserQualification objects in the database.
	 */
	public List<UserQualification> getAllQualifications() {
		logger.debug("Fetching all user qualifications.");
		List<UserQualification> qualifications = new ArrayList<>();
		// This query needs the user_id to build a lookup map later.
		String sql = "SELECT uq.user_id, uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				qualifications.add(mapResultSetToUserQualification(rs));
			}
			logger.info("Fetched a total of {} qualification entries.", qualifications.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all qualifications.", e);
		}
		return qualifications;
	}

	/**
	 * Updates or creates a qualification status for a user and a course. If the
	 * status is set to "NICHT BESUCHT", the corresponding record is deleted.
	 * Otherwise, it performs an "upsert" (INSERT ... ON DUPLICATE KEY UPDATE) to
	 * create or modify the record. This is a key method for admin management of
	 * user skills.
	 * 
	 * @param userId         The ID of the user.
	 * @param courseId       The ID of the course.
	 * @param status         The new status ('BESUCHT', 'ABSOLVIERT', or 'NICHT
	 *                       BESUCHT').
	 * @param completionDate The date of completion (can be null).
	 * @param remarks        Additional remarks (can be null).
	 * @return true if the operation was successful, false otherwise.
	 */
	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		logger.debug("DAO: Updating qualification for user {}, course {}. New status: {}, Date: {}, Remarks: '{}'",
				userId, courseId, status, completionDate, remarks);

		if ("NICHT BESUCHT".equals(status)) {
			// If status is "Not Attended", we delete the record from the database.
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(deleteSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				int affectedRows = pstmt.executeUpdate();
				logger.info("Deleted qualification entry for user {} and course {}. Rows affected: {}", userId,
						courseId, affectedRows);
				return true; // The desired state is achieved, so return true.
			} catch (SQLException e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			// Otherwise, we insert a new record or update an existing one.
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) "
					+ "ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(upsertSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.setString(3, status);

				if (completionDate != null) {
					pstmt.setDate(4, Date.valueOf(completionDate));
				} else {
					pstmt.setNull(4, Types.DATE);
				}

				pstmt.setString(5, remarks);

				int affectedRows = pstmt.executeUpdate();
				logger.info("Upserted qualification for user {} and course {}. Rows affected: {}", userId, courseId,
						affectedRows);
				// Can return 0 (no change), 1 (insert), or 2 (update), so >= 0 is a good check
				// for success.
				return affectedRows >= 0;
			} catch (SQLException e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}

	// --- Helper Methods ---

	/**
	 * Maps a row from a ResultSet to a UserQualification object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated UserQualification object.
	 * @throws SQLException If a database error occurs.
	 */
	private UserQualification mapResultSetToUserQualification(ResultSet rs) throws SQLException {
		UserQualification uq = new UserQualification();
		// user_id is only present in the getAllQualifications query
		if (hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AdminFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.model.User;
import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * A security filter that protects all URLs under the `/admin/*` path. It
 * intercepts requests to these protected endpoints and checks if the user
 * object in the current session has the "ADMIN" role. It provides special
 * access for the 'LAGERWART' role to specific pages.
 */
@WebFilter(urlPatterns = "/admin/*", asyncSupported = true)
public class AdminFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AdminFilter.class);
	private static final List<String> LAGERWART_PATHS = Arrays.asList("/admin/storage", "/admin/defects");

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AdminFilter initialized and protecting /admin/* paths.");
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String path = request.getRequestURI().substring(request.getContextPath().length());

		logger.trace("AdminFilter is processing request for path: '{}'", path);

		// Check if the session exists AND if the user object is in the session.
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Admin access DENIED to path '{}'. No active session found. Redirecting to login.", path);
			response.sendRedirect(request.getContextPath() + "/login");
			return; // Stop processing this request.
		}

		User user = (User) session.getAttribute("user");
		String userRole = user.getRole();

		// Admins can access everything.
		if ("ADMIN".equalsIgnoreCase(userRole)) {
			logger.debug("ADMIN access GRANTED for user '{}' to path '{}'. Passing to next filter/servlet.",
					user.getUsername(), path);
			chain.doFilter(request, response);
			return;
		}

		// Check for Lagerwart specific access.
		if ("LAGERWART".equalsIgnoreCase(userRole)) {
			for (String allowedPath : LAGERWART_PATHS) {
				if (path.startsWith(allowedPath)) {
					logger.debug("LAGERWART access GRANTED for user '{}' to path '{}'.", user.getUsername(), path);
					chain.doFilter(request, response);
					return;
				}
			}
		}

		// If we reach here, the user is neither an Admin nor a Lagerwart with access to
		// a permitted page.
		logger.warn("ADMIN access DENIED for user '{}' (Role: '{}') to path '{}'. Redirecting to user home.",
				user.getUsername(), user.getRole(), path);
		request.getSession().setAttribute("accessErrorMessage",
				"Sie haben keine Berechtigung, auf diese Seite zuzugreifen.");
		response.sendRedirect(request.getContextPath() + "/home");
	}

	@Override
	public void destroy() {
		logger.info("AdminFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AuthenticationFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * A security filter that intercepts all incoming requests (`/*`) to enforce
 * authentication. It checks if a user is logged in by looking for a "user"
 * object in the session. It allows access to a predefined set of public pages
 * (like login, error pages) and resources (CSS, JS) for everyone. For all other
 * protected paths, it redirects unauthenticated users to the login page.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class AuthenticationFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AuthenticationFilter.class.getName());

	// A set of paths that are publicly accessible without logging in.
	private static final Set<String> PUBLIC_PATHS = new HashSet<>(
			Arrays.asList("/login", "/login.jsp", "/logout.jsp", "/error404.jsp", "/error500.jsp"));

	// A set of resource prefixes that are always public (e.g., /css/style.css).
	private static final Set<String> PUBLIC_RESOURCE_PREFIXES = new HashSet<>(Arrays.asList("/css", "/js", "/images"));

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AuthenticationFilter initialized. Public paths: {}, Public prefixes: {}", PUBLIC_PATHS,
				PUBLIC_RESOURCE_PREFIXES);
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String contextPath = request.getContextPath();
		String path = request.getRequestURI().substring(contextPath.length());

		logger.trace("AuthenticationFilter processing request for path: '{}'", path);

		boolean isLoggedIn = (session != null && session.getAttribute("user") != null);

		boolean isPublicResource = PUBLIC_PATHS.contains(path)
				|| PUBLIC_RESOURCE_PREFIXES.stream().anyMatch(path::startsWith);

		// If the user is logged in OR the path is public, let the request through.
		if (isLoggedIn || isPublicResource) {
			logger.trace("Access granted for path '{}'. LoggedIn: {}, IsPublic: {}", path, isLoggedIn,
					isPublicResource);
			chain.doFilter(request, response);
		} else {
			// If not logged in and not a public path, redirect to login.
			logger.warn("Unauthorized access attempt by a guest to protected path: '{}'. Redirecting to login page.",
					path);
			response.sendRedirect(contextPath + "/login");
		}
	}

	@Override
	public void destroy() {
		logger.info("AuthenticationFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\CharacterEncodingFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;

/**
 * A crucial utility filter that intercepts all incoming requests (`/*`) to set
 * the character encoding to UTF-8. This ensures that any data submitted in
 * requests (e.g., form fields with special characters like German umlauts) and
 * any content sent in responses is correctly interpreted and rendered by the
 * browser. It should be the first filter in the chain.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class CharacterEncodingFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(CharacterEncodingFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("CharacterEncodingFilter initialized and set to enforce UTF-8.");
	}

	/**
	 * Sets the character encoding for both the request and response to UTF-8.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		logger.trace("Applying UTF-8 character encoding to request and response.");

		// Set the character encoding for the request to correctly interpret incoming
		// data
		request.setCharacterEncoding("UTF-8");

		// Set the character encoding for the response to ensure the browser renders it
		// correctly
		response.setCharacterEncoding("UTF-8");

		// Pass the request along the filter chain
		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
		logger.info("CharacterEncodingFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\AppContextListener.java
========================================================================

package de.technikteam.listener;

import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * This is an application lifecycle listener that performs crucial cleanup tasks
 * when the web application is shut down or undeployed from the server. Its
 * primary purpose is to manually deregister the JDBC driver that was loaded by
 * this application's classloader. This prevents potential memory leaks in
 * application servers like Tomcat.
 */
@WebListener
public class AppContextListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(AppContextListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Initialized <<<<<<<<<<");
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Being Destroyed. Cleaning up resources... <<<<<<<<<<");

		// This is the officially supported way to prevent memory leaks caused by JDBC
		// drivers
		// when a web application is shut down. We iterate through all loaded drivers
		// and deregister any that were loaded by this application's classloader.
		Enumeration<java.sql.Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			java.sql.Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getClass().getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
					logger.info("Deregistering JDBC driver: {}", driver);
				} catch (SQLException e) {
					logger.error("Error deregistering JDBC driver: {}", driver, e);
				}
			} else {
				logger.trace("Not deregistering JDBC driver {} as it does not belong to this webapp's classloader.",
						driver);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\ApplicationInitializerListener.java
========================================================================

package de.technikteam.listener;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.dao.DatabaseManager;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * An application lifecycle listener that runs when the application starts. It
 * performs two critical initialization tasks: 1. Manually loads the MySQL JDBC
 * driver to ensure it's available for the application. This is a robust
 * practice that prevents connectivity issues if the server's automatic service
 * discovery fails. 2. Explicitly triggers the initialization of the
 * `DatabaseManager` and its connection pool, and ensures the pool is closed on
 * application shutdown.
 */
@WebListener
public class ApplicationInitializerListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(ApplicationInitializerListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being initialized...");

		try {
			// Manually load the MySQL JDBC driver.
			logger.info("Attempting to manually load MySQL JDBC driver...");
			Class.forName("com.mysql.cj.jdbc.Driver");
			logger.info("MySQL JDBC driver loaded successfully.");

			// Eagerly initialize the database connection pool on startup
			logger.info("Triggering database connection pool initialization...");
			Class.forName("de.technikteam.dao.DatabaseManager");

		} catch (ClassNotFoundException e) {
			logger.fatal("FATAL: MySQL JDBC driver or DatabaseManager not found in classpath. Application will fail.",
					e);
		}
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being destroyed.");
		// Properly shut down the database connection pool.
		DatabaseManager.closeDataSource();
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	// --- Formatted Helper ---

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus; // Specific to the logged-in user (e.g., ANGEMELDET, ZUGEWIESEN)

	// These fields are populated on-demand for detailed views and are not direct
	// table columns.
	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<EventAttachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;

	public Event() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<EventAttachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<EventAttachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	// --- Formatted Helpers ---

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the `event_attachments` table. It links a
 * file (with its path and name) to a specific event and includes a
 * `requiredRole` to control its visibility to different types of users.
 */
public class EventAttachment {
	private int id;
	private int eventId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; // To display the user's name in lists
	private String signupStatus; // e.g., ANGEMELDET, ABGEMELDET
	private String commitmentStatus; // e.g., BESTÄTIGT, OFFEN

	public EventAttendance() {
	}

	// --- Getters and Setters ---

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Represents a single chat message from the `event_chat_messages` table,
 * associated with a specific "running" event. It holds the message content,
 * sender information, and timestamp.
 */
public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private LocalDateTime sentAt;

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");

	/**
	 * A convenience method to get the sent-at timestamp as a formatted time string
	 * (e.g., "15:30"), suitable for display in the chat UI.
	 * 
	 * @return A formatted time string.
	 */
	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status
 * ("OFFEN" or "ERLEDIGT"), and a transient field for displaying assigned users.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String status; // e.g., "OFFEN" or "ERLEDIGT"
	private String assignedUsernames; // Comma-separated list for display, not a direct table column

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getAssignedUsernames() {
		return assignedUsernames;
	}

	public void setAssignedUsernames(String assignedUsernames) {
		this.assignedUsernames = assignedUsernames;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName; // For display purposes, joined from file_categories
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	// Transient fields populated by DAO joins for UI display
	private String parentCourseName;
	private String leaderUsername; // For displaying the leader's name
	private String userAttendanceStatus; // User-specific status (ANGEMELDET, ABGEMELDET, OFFEN)

	// --- Formatted Helpers ---

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	// --- Getters and Setters ---

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the `meeting_attachments` table. It links a
 * file (with its path and name) to a specific meeting and includes a
 * `requiredRole` to control its visibility to different types of users.
 */
public class MeetingAttachment {
	private int id;
	private int meetingId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	// --- Getters and Setters ---

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\PasskeyCredential.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Represents a single Passkey (WebAuthn) credential record from the
 * `user_passkeys` table.
 */
public class PasskeyCredential {
	private int id;
	private int userId;
	private String name;
	private String credentialId;
	private String publicKey;
	private long signatureCount;
	private String userHandle;
	private LocalDateTime createdAt;

	public PasskeyCredential(int id, int userId, String name, String credentialId, String publicKey,
			long signatureCount, String userHandle, LocalDateTime createdAt) {
		this.id = id;
		this.userId = userId;
		this.name = name;
		this.credentialId = credentialId;
		this.publicKey = publicKey;
		this.signatureCount = signatureCount;
		this.userHandle = userHandle;
		this.createdAt = createdAt;
	}

	public PasskeyCredential() {
	}

	public String getFormattedCreatedAt() {
		return createdAt != null ? createdAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy")) : "N/A";
	}

	// --- Getters and Setters ---
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getCredentialId() {
		return credentialId;
	}

	public void setCredentialId(String credentialId) {
		this.credentialId = credentialId;
	}

	public String getPublicKey() {
		return publicKey;
	}

	public void setPublicKey(String publicKey) {
		this.publicKey = publicKey;
	}

	public long getSignatureCount() {
		return signatureCount;
	}

	public void setSignatureCount(long signatureCount) {
		this.signatureCount = signatureCount;
	}

	public String getUserHandle() {
		return userHandle;
	}

	public void setUserHandle(String userHandle) {
		this.userHandle = userHandle;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;

	// Transient field for UI display, populated by a DAO join
	private String courseName;

	// --- Getters and Setters ---

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String shelf;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		if (this.getAvailableQuantity() <= 0) {
			return "Vergriffen";
		}
		if (this.maxQuantity > 0 && this.getAvailableQuantity() >= this.maxQuantity) {
			return "Vollständig";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		if (this.getAvailableQuantity() <= 0) {
			return "status-danger";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getShelf() {
		return shelf;
	}

	public void setShelf(String shelf) {
		this.shelf = shelf;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; // Can be 0 if not linked
	private LocalDateTime transactionTimestamp;

	// Define the formatter here
	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	// OLD METHOD - uses a different formatter
	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	// NEW GETTER for the specific locale string required by the JSP
	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	// --- Getters and Setters ---

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * The core model for an application user, representing a record from the
 * `users` table. It contains the user's ID, username, role ("ADMIN" or
 * "NUTZER"), and other profile information like class year and creation date.
 */
public class User {
	private int id;
	private String username;
	private String role;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;

	public User() {
	}

	public User(int id, String username, String role) {
		this(id, username, role, null, 0, null);
	}

	public User(int id, String username, String role, LocalDateTime createdAt, int classYear, String className) {
		this.id = id;
		this.username = username;
		this.role = role;
		this.createdAt = createdAt;
		this.classYear = classYear;
		this.className = className;
	}

	// --- Getters and Setters ---

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getRole() {
		return role;
	}

	public void setRole(String role) {
		this.role = role;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	/**
	 * A convenience method to get the creation timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; // For display, joined from 'courses' table
	private String status; // e.g., "BESUCHT", "ABSOLVIERT"
	private LocalDate completionDate;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * A simple service layer that acts as a middleman for logging administrative
 * actions. It provides a static `log` method that other parts of the
 * application can call to create an audit log entry. This decouples the
 * application logic from the direct use of the AdminLogDAO.
 */
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private static final AdminLogDAO logDAO = new AdminLogDAO();

	/**
	 * Creates and persists an administrative audit log entry. This is the central
	 * point for all audit logging.
	 * 
	 * @param adminUsername The username of the admin performing the action.
	 * @param actionType    A high-level category for the action (e.g.,
	 *                      "UPDATE_USER", "DELETE_EVENT").
	 * @param details       A detailed, human-readable description of the action and
	 *                      its context.
	 */
	public static void log(String adminUsername, String actionType, String details) {
		try {
			AdminLog log = new AdminLog();
			log.setAdminUsername(adminUsername);
			log.setActionType(actionType);
			log.setDetails(details);

			// Log the same info to the file/console for debugging purposes before DB write
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", adminUsername, actionType, details);

			logDAO.createLog(log);
		} catch (Exception e) {
			// Log the failure to write to the audit log itself
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					adminUsername, actionType, details, e);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.AsyncContext;
import jakarta.servlet.http.HttpServletRequest;

/**
 * A singleton service designed to handle real-time notifications using
 * Server-Sent Events (SSE). It manages a thread-safe list of connected clients
 * (via their `AsyncContext`) and provides a central method to broadcast a
 * notification message to all of them simultaneously.
 */
public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);
	private static final NotificationService INSTANCE = new NotificationService();

	// Use a thread-safe list because clients can register/deregister from different
	// threads.
	private final List<AsyncContext> contexts = new CopyOnWriteArrayList<>();

	private NotificationService() {
	}

	public static NotificationService getInstance() {
		return INSTANCE;
	}

	/**
	 * Registers a new client (from an incoming HttpServletRequest) to receive
	 * notifications. It starts an asynchronous context and adds it to the list of
	 * subscribers.
	 * 
	 * @param request The request from the client wishing to subscribe.
	 */
	public void register(HttpServletRequest request) {
		AsyncContext asyncContext = request.startAsync();
		asyncContext.setTimeout(0); // No timeout for SSE connections
		contexts.add(asyncContext);
		logger.info("New client registered for SSE notifications. Total clients: {}", contexts.size());
	}

	/**
	 * Sends a notification message to all currently registered clients. If a client
	 * has disconnected, it will be removed from the list.
	 * 
	 * @param message The message to send.
	 */
	public void sendNotification(String message) {
		logger.info("Sending notification to {} clients: {}", contexts.size(), message);
		for (AsyncContext context : contexts) {
			try {
				PrintWriter writer = context.getResponse().getWriter();
				// Format the message according to the SSE specification: "data: message\n\n"
				writer.write("data: " + message + "\n\n");
				writer.flush();
			} catch (IOException e) {
				logger.warn("Failed to send notification to a client (likely disconnected), removing it.", e);
				contexts.remove(context);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\PasskeyService.java
========================================================================

package de.technikteam.service;

import com.yubico.webauthn.*;
import com.yubico.webauthn.data.*;
import com.yubico.webauthn.exception.AssertionFailedException;
import com.yubico.webauthn.exception.RegistrationFailedException;
import de.technikteam.dao.PasskeyCredentialDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.PasskeyCredential;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * A service to handle the business logic of WebAuthn (Passkey) authentication,
 * using the Yubico library. This version is corrected for API version
 * compatibility.
 */
public class PasskeyService {
	private static final Logger logger = LogManager.getLogger(PasskeyService.class);
	private final RelyingParty relyingParty;
	private final PasskeyCredentialDAO passkeyDAO = new PasskeyCredentialDAO();

	// --- Singleton Pattern ---
	private static PasskeyService INSTANCE;

	private PasskeyService() {
		RelyingPartyIdentity rpIdentity = RelyingPartyIdentity.builder().id("localhost") // The domain where the app is
																							// running
				.name("TechnikTeam Web App").build();

		this.relyingParty = RelyingParty.builder().identity(rpIdentity)
				.credentialRepository(new DatabaseCredentialRepository(passkeyDAO)).allowOriginPort(true)
				.allowOriginSubdomain(false).build();
	}

	public static synchronized PasskeyService getInstance() {
		if (INSTANCE == null) {
			INSTANCE = new PasskeyService();
		}
		return INSTANCE;
	}

	// --- Registration Logic ---
	public PublicKeyCredentialCreationOptions startRegistration(User user) {

		// FIX: Make the credential decoding more robust so one bad key doesn't stop the
		// process.
		Set<PublicKeyCredentialDescriptor> excludeCredentials = passkeyDAO.getCredentialsForUser(user.getId()).stream()
				.map(cred -> {
					try {
						return PublicKeyCredentialDescriptor.builder()
								.id(ByteArray.fromBase64Url(cred.getCredentialId())).build();
					} catch (Exception e) {
						logger.error("Could not parse existing credential ID for user {}. It will not be excluded.",
								user.getUsername(), e);
						return null; // Return null for invalid entries
					}
				}).filter(java.util.Objects::nonNull) // Filter out the nulls
				.collect(Collectors.toSet());

		StartRegistrationOptions options = StartRegistrationOptions.builder()
				.user(UserIdentity.builder().name(user.getUsername()).displayName(user.getUsername())
						.id(new ByteArray(user.getUsername().getBytes())).build())
				.authenticatorSelection(Optional.of(AuthenticatorSelectionCriteria.builder()
						.userVerification(UserVerificationRequirement.PREFERRED).build()))
				// This call is now safe because the set doesn't contain errors.
				.excludeCredentials(excludeCredentials).build();

		PublicKeyCredentialCreationOptions registration = relyingParty.startRegistration(options);
		logger.info("Started passkey registration for user: {}", user.getUsername());
		return registration;
	}

	public boolean finishRegistration(String credentialJson, String requestJson, User user, String passkeyName) {
		try {
			PublicKeyCredential<AuthenticatorAttestationResponse, ClientRegistrationExtensionOutputs> credential = PublicKeyCredential
					.parseRegistrationResponseJson(credentialJson);
			PublicKeyCredentialCreationOptions request = PublicKeyCredentialCreationOptions.fromJson(requestJson);

			RegistrationResult result = relyingParty.finishRegistration(
					FinishRegistrationOptions.builder().request(request).response(credential).build());

			ByteArray userHandle = new ByteArray(user.getUsername().getBytes());

			PasskeyCredential newCredential = new PasskeyCredential();
			newCredential.setUserId(user.getId());
			newCredential.setName(passkeyName);
			newCredential.setCredentialId(result.getKeyId().getId().getBase64Url());
			newCredential.setPublicKey(result.getPublicKeyCose().getBase64());
			newCredential.setSignatureCount(result.getSignatureCount());
			newCredential.setUserHandle(userHandle.getBase64Url());
			passkeyDAO.addCredential(newCredential);

			logger.info("Successfully finished passkey registration for user: {}", user.getUsername());
			return true;
		} catch (RegistrationFailedException | IOException e) {
			logger.error("Passkey registration failed for user {}", user.getUsername(), e);
			return false;
		}
	}

	// --- Authentication Logic (now called Assertion) ---
	public AssertionRequest startAssertion() {
		StartAssertionOptions options = StartAssertionOptions.builder()
				.userVerification(Optional.of(UserVerificationRequirement.PREFERRED)).build();
		AssertionRequest request = relyingParty.startAssertion(options);
		logger.info("Started passkey assertion (authentication) ceremony.");
		return request;
	}

	public Optional<User> finishAssertion(String credentialJson, String requestJson) {
		try {
			PublicKeyCredential<AuthenticatorAssertionResponse, ClientAssertionExtensionOutputs> credential = PublicKeyCredential
					.parseAssertionResponseJson(credentialJson);
			AssertionRequest request = AssertionRequest.fromJson(requestJson);

			AssertionResult result = relyingParty
					.finishAssertion(FinishAssertionOptions.builder().request(request).response(credential).build());

			if (result.isSuccess()) {
				passkeyDAO.updateSignatureCount(result.getCredential().getCredentialId().getBase64Url(),
						result.getSignatureCount());
				UserDAO userDAO = new UserDAO();
				User user = userDAO.getUserByUsername(result.getUsername());
				logger.info("Passkey authentication successful for user: {}", result.getUsername());
				return Optional.ofNullable(user);
			}
		} catch (AssertionFailedException | IOException e) {
			logger.error("Passkey assertion failed.", e);
		}
		return Optional.empty();
	}

	/**
	 * A refactored implementation of Yubico's CredentialRepository that uses our
	 * DAOs correctly and handles exceptions.
	 */
	private static class DatabaseCredentialRepository implements CredentialRepository {
		private final PasskeyCredentialDAO passkeyDAO;
		private final UserDAO userDAO = new UserDAO();

		public DatabaseCredentialRepository(PasskeyCredentialDAO passkeyDAO) {
			this.passkeyDAO = passkeyDAO;
		}

		@Override
		public Optional<RegisteredCredential> lookup(ByteArray credentialId, ByteArray userHandle) {
			return passkeyDAO.getCredentialById(credentialId.getBase64Url()).filter(cred -> {
				try {
					return userHandle.equals(ByteArray.fromBase64Url(cred.getUserHandle()));
				} catch (Exception e) {
					logger.error("Failed to decode user handle from DB", e);
					return false;
				}
			}).map(this::toRegisteredCredential);
		}

		@Override
		public Set<RegisteredCredential> lookupAll(ByteArray credentialId) {
			return passkeyDAO.getCredentialById(credentialId.getBase64Url()).stream().map(this::toRegisteredCredential)
					.collect(Collectors.toSet());
		}

		@Override
		public Set<PublicKeyCredentialDescriptor> getCredentialIdsForUsername(String username) {
			User user = userDAO.getUserByUsername(username);
			if (user != null) {
				return passkeyDAO.getCredentialsForUser(user.getId()).stream().map(c -> {
					try {
						return PublicKeyCredentialDescriptor.builder().id(ByteArray.fromBase64Url(c.getCredentialId()))
								.build();
					} catch (Exception e) {
						logger.error("Failed to decode credential ID from Base64Url", e);
						return null;
					}
				}).filter(d -> d != null).collect(Collectors.toSet());
			}
			return Set.of();
		}

		@Override
		public Optional<ByteArray> getUserHandleForUsername(String username) {
			User user = userDAO.getUserByUsername(username);
			if (user != null) {
				return Optional.of(new ByteArray(user.getUsername().getBytes()));
			}
			return Optional.empty();
		}

		@Override
		public Optional<String> getUsernameForUserHandle(ByteArray userHandle) {
			return passkeyDAO.getCredentialByUserHandle(userHandle.getBase64Url())
					.map(cred -> userDAO.getUserById(cred.getUserId()).getUsername());
		}

		private RegisteredCredential toRegisteredCredential(PasskeyCredential cred) {
			try {
				return RegisteredCredential.builder().credentialId(ByteArray.fromBase64Url(cred.getCredentialId()))
						.userHandle(ByteArray.fromBase64Url(cred.getUserHandle()))
						.publicKeyCose(ByteArray.fromBase64(cred.getPublicKey()))
						.signatureCount(cred.getSignatureCount()).build();
			} catch (Exception e) {
				logger.error("Could not convert PasskeyCredential to RegisteredCredential", e);
				throw new RuntimeException(e);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

/**
 * A service to gather system statistics from the underlying OS. This version is
 * made more platform-independent and robust for Windows environments.
 */
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		// CPU Load (cross-platform)
		stats.setCpuLoad(osBean.getSystemCpuLoad() * 100.0);

		// Physical Memory (cross-platform)
		long totalMemoryBytes = osBean.getTotalPhysicalMemorySize();
		long freeMemoryBytes = osBean.getFreePhysicalMemorySize();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		// Disk Space (cross-platform)
		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		// Uptime (Linux-specific with fallback)
		stats.setUptime(getSystemUptime());

		// Battery (Linux-specific with fallback)
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		// This part is Linux-specific, so we wrap it in a try-catch.
		try {
			// On Linux, this file contains the system uptime in seconds.
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			// This will be caught on Windows or if the file is unreadable.
			logger.warn("Could not read /proc/uptime. Uptime not available. OS might not be Linux.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		// This part is also Linux-specific.
		try {
			// Common path for laptop batteries on Linux.
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			// This will fail on systems without a battery or non-Linux OS.
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1; // Indicates no battery or not available
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAttendanceServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;

/**
 * Mapped to `/admin/attendance`, this servlet handles all actions related to
 * updating meeting attendance records, primarily called from the modal window
 * on the administrative qualifications matrix (`admin_matrix.jsp`).
 */
@WebServlet("/admin/attendance")
public class AdminAttendanceServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAttendanceServlet.class);
	private MeetingAttendanceDAO attendanceDAO;
	private UserDAO userDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
		userDAO = new UserDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo"); // e.g., "matrix"

		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			int meetingId = Integer.parseInt(request.getParameter("meetingId"));

			// A checkbox sends "true" if checked, and null if not. This is a standard way
			// to check it.
			boolean attended = "true".equals(request.getParameter("attended"));

			String remarks = request.getParameter("remarks");
			logger.debug("Processing attendance update for user ID {}, meeting ID {}. Attended: {}, Remarks: '{}'",
					userId, meetingId, attended, remarks);

			if (attendanceDAO.setAttendance(userId, meetingId, attended, remarks)) {
				// Fetch details for rich logging
				User targetUser = userDAO.getUserById(userId);
				Meeting meeting = meetingDAO.getMeetingById(meetingId);

				String status = attended ? "TEILGENOMMEN" : "NICHT TEILGENOMMEN";
				String logDetails = String.format(
						"Teilnahme für Nutzer '%s' (ID: %d) bei Meeting '%s' (ID: %d) auf '%s' gesetzt. Bemerkungen: '%s'.",
						(targetUser != null ? targetUser.getUsername() : "N/A"), userId,
						(meeting != null ? meeting.getName() : "N/A"), meetingId, status, remarks);

				AdminLogService.log(adminUser.getUsername(), "UPDATE_ATTENDANCE", logDetails);

				request.getSession().setAttribute("successMessage", "Teilnahmestatus erfolgreich aktualisiert.");
				logger.info("Attendance update successful for user ID {} / meeting ID {}.", userId, meetingId);
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Teilnahmestatus konnte nicht aktualisiert werden.");
				logger.error("Attendance update failed for user ID {} / meeting ID {}.", userId, meetingId);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid ID received in AdminAttendanceServlet.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID empfangen.");
		}

		// Redirect back to the matrix or a default page
		String redirectUrl = request.getContextPath()
				+ ("/matrix".equals(returnTo) ? "/admin/matrix" : "/admin/dashboard");
		logger.debug("Redirecting to {}", redirectUrl);
		response.sendRedirect(redirectUrl);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminCourseServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.CourseDAO;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;
import java.util.List;
import java.util.Objects;

/**
 * 
 * Mapped to /admin/courses, this servlet manages the parent course templates.
 * 
 * It handles listing all course templates, and processing the creation, update,
 * 
 * and deletion of these templates, which are now managed via modal dialogs on
 * 
 * the list page.
 */
@WebServlet("/admin/courses")
public class AdminCourseServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminCourseServlet.class);
	private CourseDAO courseDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		courseDAO = new CourseDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getCourseData".equals(action)) {
			getCourseDataAsJson(req, resp);
			return;
		}

		logger.info("Listing all course templates for admin view.");
		List<Course> courseList = courseDAO.getAllCourses();
		req.setAttribute("courseList", courseList);
		req.getRequestDispatcher("/admin/admin_course_list.jsp").forward(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getParameter("action");
		logger.debug("AdminCourseServlet received POST request with action: {}", action);
		if ("delete".equals(action)) {
			handleDelete(req, resp);
		} else if ("create".equals(action) || "update".equals(action)) {
			handleCreateOrUpdate(req, resp);
		} else {
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/courses");
		}
	}

	private void getCourseDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			Course course = courseDAO.getCourseById(courseId);
			if (course != null) {
				String courseJson = gson.toJson(course);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(courseJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Course not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid course ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		Course course = new Course();
		course.setName(request.getParameter("name"));
		course.setAbbreviation(request.getParameter("abbreviation"));
		course.setDescription(request.getParameter("description"));

		boolean success;
		if (idParam != null && !idParam.isEmpty()) { // UPDATE
			course.setId(Integer.parseInt(idParam));
			logger.info("Attempting to update course: {}", course.getName());
			Course originalCourse = courseDAO.getCourseById(course.getId());
			success = courseDAO.updateCourse(course);
			if (success) {
				StringBuilder changes = new StringBuilder();
				if (!Objects.equals(originalCourse.getName(), course.getName())) {
					changes.append(String.format("Name: '%s' -> '%s'. ", originalCourse.getName(), course.getName()));
				}
				if (!Objects.equals(originalCourse.getAbbreviation(), course.getAbbreviation())) {
					changes.append(String.format("Abk.: '%s' -> '%s'. ", originalCourse.getAbbreviation(),
							course.getAbbreviation()));
				}
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (ID: %d) aktualisiert. %s",
						originalCourse.getName(), course.getId(), changes.toString());
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren der Vorlage.");
			}
		} else { // CREATE
			logger.info("Attempting to create new course: {}", course.getName());
			success = courseDAO.createCourse(course);
			if (success) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (Abk.: %s) erstellt.", course.getName(),
						course.getAbbreviation());
				AdminLogService.log(adminUser.getUsername(), "CREATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Neue Lehrgangs-Vorlage erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Erstellen der Vorlage.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/courses");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete course with ID: {}", courseId);
			// Fetch course details before deleting for detailed logging
			Course courseToDelete = courseDAO.getCourseById(courseId);
			String courseName = (courseToDelete != null) ? courseToDelete.getName() : "N/A";

			if (courseDAO.deleteCourse(courseId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_COURSE",
						"Lehrgangs-Vorlage '" + courseName + "' (ID: " + courseId
								+ ") und alle zugehörigen Meetings, Anhänge und Qualifikationen gelöscht.");
				req.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Vorlage konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid course ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Löschvorgang.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/courses");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDashboardServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.StatisticsDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/dashboard`, this servlet serves as the entry point for the
 * main administrative dashboard. It uses the `StatisticsDAO` to fetch key
 * metrics like the total user count and the number of active events. It then
 * forwards this data to `admin_dashboard.jsp` for display.
 */
@WebServlet("/admin/dashboard")
public class AdminDashboardServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminDashboardServlet.class);
	private StatisticsDAO statisticsDAO;

	@Override
	public void init() {
		statisticsDAO = new StatisticsDAO();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Admin dashboard requested. Fetching statistics.");

		int userCount = statisticsDAO.getUserCount();
		int activeEventCount = statisticsDAO.getActiveEventCount();

		request.setAttribute("userCount", userCount);
		request.setAttribute("activeEventCount", activeEventCount);

		logger.debug("Forwarding to admin_dashboard.jsp with userCount={} and activeEventCount={}", userCount,
				activeEventCount);
		request.getRequestDispatcher("/admin/admin_dashboard.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDefectServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * Servlet to display a list of all defective items.
 */
@WebServlet("/admin/defects")
public class AdminDefectServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems();
		request.setAttribute("defectiveItems", defectiveItems);
		request.getRequestDispatcher("/admin/admin_defect_list.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminEventServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.EventAttachmentDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Event;
import de.technikteam.model.EventAttachment;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

/**
 * Mapped to /admin/events, this is a complex servlet that manages all aspects
 * of events from an administrative perspective. It handles full CRUD operations
 * for events, manages skill requirements, file attachments, storage
 * reservations, and provides the interface for assigning users to an event's
 * final team.
 */
@WebServlet("/admin/events")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminEventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminEventServlet.class);

	private EventDAO eventDAO;
	private CourseDAO courseDAO;
	private StorageDAO storageDAO;
	private UserDAO userDAO;
	private EventAttachmentDAO attachmentDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		courseDAO = new CourseDAO();
		storageDAO = new StorageDAO();
		userDAO = new UserDAO();
		attachmentDAO = new EventAttachmentDAO();
		// Configure Gson to handle LocalDateTime and LocalDate
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).setPrettyPrinting().create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminEventServlet received GET request with action: {}", action);
		try {
			switch (action) {
			case "getEventData":
				getEventDataAsJson(req, resp);
				break;
			case "getAssignmentData":
				getAssignmentDataAsJson(req, resp);
				break;
			default:
				listEvents(req, resp);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminEventServlet doGet", e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/events");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action;

		if (req.getContentType() != null && req.getContentType().toLowerCase().startsWith("multipart/")) {
			action = ServletUtils.getPartValue(req.getPart("action"));
		} else {
			action = req.getParameter("action");
		}
		logger.debug("AdminEventServlet received POST request with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "assignUsers":
			handleAssignUsers(req, resp);
			break;
		case "updateStatus":
			handleStatusUpdate(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/events");
			break;
		}
	}

	private void listEvents(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		logger.info("Listing all events for admin view.");
		List<Event> eventList = eventDAO.getAllEvents();
		List<Course> allCourses = courseDAO.getAllCourses();
		List<StorageItem> allItems = storageDAO.getAllItemsGroupedByLocation().values().stream().flatMap(List::stream)
				.collect(Collectors.toList());
		List<User> allUsers = userDAO.getAllUsers();

		req.setAttribute("eventList", eventList);
		req.setAttribute("allCourses", allCourses);
		req.setAttribute("allItems", allItems);
		req.setAttribute("allUsers", allUsers);
		req.getRequestDispatcher("/admin/admin_events_list.jsp").forward(req, resp);
	}

	private void getEventDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
				event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
				event.setAttachments(attachmentDAO.getAttachmentsForEvent(eventId, "ADMIN"));
				String eventJson = gson.toJson(event);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(eventJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND);
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	private void getAssignmentDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			Set<Integer> assignedUserIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
					.collect(Collectors.toSet());

			Map<String, Object> responseData = new HashMap<>();
			responseData.put("signedUpUsers", signedUpUsers);
			responseData.put("assignedUserIds", assignedUserIds);

			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(gson.toJson(responseData));

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID for assignment data.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = ServletUtils.getPartValue(request.getPart("id"));
		boolean isUpdate = idParam != null && !idParam.isEmpty();
		Event event = new Event();

		try {
			event.setName(ServletUtils.getPartValue(request.getPart("name")));
			event.setDescription(ServletUtils.getPartValue(request.getPart("description")));
			event.setLocation(ServletUtils.getPartValue(request.getPart("location")));
			event.setEventDateTime(LocalDateTime.parse(ServletUtils.getPartValue(request.getPart("eventDateTime"))));

			String endDateTimeParam = ServletUtils.getPartValue(request.getPart("endDateTime"));
			if (endDateTimeParam != null && !endDateTimeParam.isEmpty()) {
				event.setEndDateTime(LocalDateTime.parse(endDateTimeParam));
			}

			String leaderIdStr = ServletUtils.getPartValue(request.getPart("leaderUserId"));
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				event.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			int eventId = 0;
			if (isUpdate) {
				eventId = Integer.parseInt(idParam);
				Event originalEvent = eventDAO.getEventById(eventId);
				event.setId(eventId);
				event.setStatus(originalEvent.getStatus()); // Status is updated via its own action
				if (eventDAO.updateEvent(event)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
				}
			} else { // CREATE
				eventId = eventDAO.createEvent(event);
				if (eventId > 0) {
					event.setId(eventId);
					AdminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
				}
			}

			if (eventId > 0) {
				// Handle requirements
				String[] requiredCourseIds = request.getParameterValues("requiredCourseId");
				String[] requiredPersons = request.getParameterValues("requiredPersons");
				eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);

				// Handle reservations
				String[] itemIds = request.getParameterValues("itemId");
				String[] quantities = request.getParameterValues("itemQuantity");
				eventDAO.saveReservations(eventId, itemIds, quantities);

				// Handle file upload
				Part filePart = request.getPart("attachment");
				if (filePart != null && filePart.getSize() > 0) {
					String requiredRole = ServletUtils.getPartValue(request.getPart("requiredRole"));
					handleAttachmentUpload(filePart, eventId, requiredRole, adminUser, request);
				}
				request.getSession().setAttribute("successMessage", "Event erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Event konnte nicht gespeichert werden.");
			}

		} catch (DateTimeParseException e) {
			logger.error("Invalid date format submitted for event.", e);
			request.getSession().setAttribute("errorMessage",
					"Ungültiges Datumsformat. Bitte das Format 'YYYY-MM-DDTHH:MM' verwenden.");
		} catch (Exception e) {
			logger.error("Error during event creation/update.", e);
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}

		response.sendRedirect(request.getContextPath() + "/admin/events");
	}

	private void handleAttachmentUpload(Part filePart, int eventId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "events";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		EventAttachment attachment = new EventAttachment();
		attachment.setEventId(eventId);
		attachment.setFilename(fileName);
		attachment.setFilepath("events/" + fileName); // Use forward slashes for URL
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			AdminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + fileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("id"));
		logger.warn("Attempting to delete event attachment ID {}", attachmentId);

		EventAttachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());
			if (physicalFile.exists())
				physicalFile.delete();

			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT_ATTACHMENT", "Anhang '"
						+ attachment.getFilename() + "' von Event ID " + attachment.getEventId() + " gelöscht.");
				resp.setContentType("application/json");
				resp.getWriter().write("{\"message\":\"Anhang gelöscht\"}");
			} else {
				resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						"Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Anhang nicht gefunden.");
		}
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete event with ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.deleteEvent(eventId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT",
						"Event '" + event.getName() + "' (ID: " + eventId + ") endgültig gelöscht.");
				req.getSession().setAttribute("successMessage", "Event wurde gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Event konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

	private void handleAssignUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("eventId"));
			String[] userIds = req.getParameterValues("userIds");
			logger.info("Assigning {} users to event ID {}", (userIds != null ? userIds.length : 0), eventId);
			Event event = eventDAO.getEventById(eventId);
			eventDAO.assignUsersToEvent(eventId, userIds);

			String assignedUserCount = (userIds != null) ? String.valueOf(userIds.length) : "0";
			String logDetails = String.format("Team für Event '%s' (ID: %d) finalisiert. %s Benutzer zugewiesen.",
					event.getName(), eventId, assignedUserCount);
			AdminLogService.log(adminUser.getUsername(), "ASSIGN_TEAM", logDetails);

			req.getSession().setAttribute("successMessage", "Team für das Event wurde erfolgreich zugewiesen.");
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for user assignment.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

	private void handleStatusUpdate(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			String newStatus = req.getParameter("newStatus");
			logger.info("Updating status for event ID {} to '{}'", eventId, newStatus);
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.updateEventStatus(eventId, newStatus)) {
				String logDetails = String.format("Status für Event '%s' (ID: %d) von '%s' auf '%s' geändert.",
						event.getName(), eventId, event.getStatus(), newStatus);
				AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT_STATUS", logDetails);
				req.getSession().setAttribute("successMessage", "Event-Status erfolgreich aktualisiert.");
			} else {
				req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Event-Status.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for status update.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/events");
	}

}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileCategoryServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet is uniquely mapped to multiple URL patterns
 * (`/admin/categories/*`) to handle specific CRUD actions for file categories.
 * It processes POST requests to create, update, or delete a category based on
 * the servlet path, logs the action, and then redirects back to the main admin
 * file management page.
 */
@WebServlet({ "/admin/categories/create", "/admin/categories/update", "/admin/categories/delete" })
public class AdminFileCategoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileCategoryServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getServletPath();
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.debug("AdminFileCategoryServlet processing POST for action path: {}", action);

		try {
			if (action.endsWith("/create")) {
				String categoryName = req.getParameter("categoryName");
				if (fileDAO.createCategory(categoryName)) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' erstellt.");
					req.getSession().setAttribute("successMessage",
							"Kategorie '" + categoryName + "' erfolgreich erstellt.");
				}
			} else if (action.endsWith("/update")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String newName = req.getParameter("categoryName");
				String oldName = fileDAO.getCategoryNameById(categoryId); // Get old name for logging
				if (fileDAO.updateCategory(categoryId, newName)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_FILE_CATEGORY", "Dateikategorie '" + oldName
							+ "' (ID: " + categoryId + ") umbenannt in '" + newName + "'.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich umbenannt.");
				}
			} else if (action.endsWith("/delete")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String categoryName = fileDAO.getCategoryNameById(categoryId); // Get name for logging
				if (fileDAO.deleteCategory(categoryId)) {
					AdminLogService.log(adminUser.getUsername(), "DELETE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' (ID: " + categoryId + ") gelöscht.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich gelöscht.");
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in AdminFileCategoryServlet for action {}", action, e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Kategorie-Aktion.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/files");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.File; // Our own model: de.technikteam.model.File
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

/**
 * Mapped to `/admin/files`, this servlet manages file uploads and deletions for
 * administrators. A GET request displays the management page
 * (`admin_files.jsp`) with a list of all files grouped by category. A POST
 * request handles either uploading a new file or deleting an existing one. It
 * correctly handles `multipart/form-data` to read form fields and the uploaded
 * file.
 */
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
@WebServlet("/admin/files")
public class AdminFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("Admin file page requested by user '{}'.", user.getUsername());

		Map<String, List<File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(user);
		List<FileCategory> allCategories = fileDAO.getAllCategories();

		request.setAttribute("groupedFiles", groupedFiles);
		request.setAttribute("allCategories", allCategories);

		logger.debug("Forwarding to admin_files.jsp with {} file groups and {} categories.", groupedFiles.size(),
				allCategories.size());
		request.getRequestDispatcher("/admin/admin_files.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();

		// Differentiate between multipart (upload) and standard (delete) forms
		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			handleUpload(request, response);
		} else {
			String action = request.getParameter("action");
			if ("delete".equals(action)) {
				handleDelete(request, response);
			} else {
				logger.warn("Received non-multipart POST with unknown or missing action: '{}'", action);
				request.getSession().setAttribute("errorMessage", "Unbekannte Aktion empfangen.");
				response.sendRedirect(request.getContextPath() + "/admin/files");
			}
		}
	}

	private void handleUpload(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			String uploadFilePath = AppConfig.UPLOAD_DIRECTORY;
			java.io.File uploadDir = new java.io.File(uploadFilePath);
			if (!uploadDir.exists())
				uploadDir.mkdirs();

			Part filePart = request.getPart("file");
			String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();

			String requiredRole = ServletUtils.getPartValue(request.getPart("requiredRole"));
			String categoryIdStr = ServletUtils.getPartValue(request.getPart("categoryId"));

			int categoryId = 0;
			try {
				if (categoryIdStr != null && !categoryIdStr.isEmpty()) {
					categoryId = Integer.parseInt(categoryIdStr);
				}
			} catch (NumberFormatException e) {
				logger.warn("No valid category ID provided during upload.");
			}

			if (fileName == null || fileName.isEmpty()) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Datei zum Hochladen aus.");
			} else if (categoryId == 0) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Kategorie aus.");
			} else {
				java.io.File targetFile = new java.io.File(uploadDir, fileName);
				filePart.write(targetFile.getAbsolutePath());
				logger.info("File '{}' uploaded by '{}' to: {}", fileName, adminUser.getUsername(),
						targetFile.getAbsolutePath());

				File newDbFile = new File();
				newDbFile.setFilename(fileName);
				newDbFile.setFilepath(fileName); // Filepath is just the filename for top-level uploads
				newDbFile.setCategoryId(categoryId);
				newDbFile.setRequiredRole(requiredRole);

				if (fileDAO.createFile(newDbFile)) {
					String categoryName = fileDAO.getCategoryNameById(categoryId);
					String logDetails = String.format("Datei '%s' in Kategorie '%s' hochgeladen. Sichtbar für: %s.",
							fileName, categoryName, requiredRole);
					AdminLogService.log(adminUser.getUsername(), "FILE_UPLOAD", logDetails);
					request.getSession().setAttribute("successMessage",
							"Datei '" + fileName + "' erfolgreich hochgeladen.");
				} else {
					request.getSession().setAttribute("errorMessage",
							"DB-Fehler: Datei konnte nicht gespeichert werden (ggf. existiert der Name bereits).");
					targetFile.delete();
				}
			}
		} catch (Exception e) {
			logger.error("File upload failed.", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Upload: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/files");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int fileId = Integer.parseInt(request.getParameter("fileId"));
			logger.warn("Attempting to delete file with ID: {} by user '{}'", fileId, adminUser.getUsername());
			File dbFile = fileDAO.getFileById(fileId);

			if (dbFile != null) {
				java.io.File physicalFile = new java.io.File(AppConfig.UPLOAD_DIRECTORY, dbFile.getFilepath());
				boolean physicalDeleted = true;

				if (physicalFile.exists()) {
					physicalDeleted = physicalFile.delete();
				} else {
					logger.warn("Physical file not found at [{}], but proceeding with DB record deletion.",
							physicalFile.getAbsolutePath());
				}

				if (physicalDeleted) {
					if (fileDAO.deleteFile(fileId)) {
						String categoryName = fileDAO.getCategoryNameById(dbFile.getCategoryId());
						String logDetails = String.format("Datei '%s' (ID: %d) aus Kategorie '%s' gelöscht.",
								dbFile.getFilename(), fileId, categoryName != null ? categoryName : "N/A");
						AdminLogService.log(adminUser.getUsername(), "FILE_DELETE", logDetails);
						request.getSession().setAttribute("successMessage",
								"Datei '" + dbFile.getFilename() + "' wurde erfolgreich gelöscht.");
					} else {
						request.getSession().setAttribute("errorMessage",
								"FEHLER: Die Datei konnte aus der Datenbank nicht gelöscht werden.");
					}
				} else {
					request.getSession().setAttribute("errorMessage",
							"FEHLER: Die physische Datei konnte nicht gelöscht werden. Bitte Berechtigungen prüfen.");
				}
			} else {
				request.getSession().setAttribute("errorMessage", "Datei in der Datenbank nicht gefunden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Datei-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/files");
	}

}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminLogServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/log`, this servlet retrieves all entries from the
 * administrative action log using the `AdminLogDAO`. It then passes the
 * complete list of logs to `admin_log.jsp` for display and filtering on the
 * client side.
 */
@WebServlet("/admin/log")
public class AdminLogServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminLogServlet.class);
	private AdminLogDAO adminLogDAO;

	@Override
	public void init() {
		adminLogDAO = new AdminLogDAO();
		logger.info("AdminLogServlet has been initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		logger.info("Admin log page requested by user '{}'.", adminUser.getUsername());
		try {
			List<AdminLog> logs = adminLogDAO.getAllLogs();
			request.setAttribute("logs", logs);
			logger.info("Fetched {} log entries. Forwarding to JSP.", logs.size());
			request.getRequestDispatcher("/admin/admin_log.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("A critical error occurred in AdminLogServlet doGet()", e);
			// Redirect to a generic error page to avoid exposing stack traces to the user
			response.sendRedirect(request.getContextPath() + "/error500.jsp");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttachment;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.List;

@WebServlet("/admin/meetings")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);
	private MeetingDAO meetingDAO;
	private CourseDAO courseDAO;
	private MeetingAttachmentDAO attachmentDAO;
	private UserDAO userDAO;
	private Gson gson;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		courseDAO = new CourseDAO();
		attachmentDAO = new MeetingAttachmentDAO();
		userDAO = new UserDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action;

		if (req.getContentType() != null && req.getContentType().toLowerCase().startsWith("multipart/")) {
			action = ServletUtils.getPartValue(req.getPart("action"));
		} else {
			action = req.getParameter("action");
		}

		logger.debug("AdminMeetingServlet received POST with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			logger.warn("Unknown action received in doPost: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/courses");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.info("Listing all meetings for course ID: {}", courseId);
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();

		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);

		req.getRequestDispatcher("/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<MeetingAttachment> attachments = attachmentDAO.getAttachmentsForMeeting(meetingId, "ADMIN");
				// Create a wrapper object to send both meeting and attachments
				var responseData = new Object() {
					final Meeting meetingData = meeting;
					final List<MeetingAttachment> attachmentsData = attachments;
				};
				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID for getting meeting data as JSON", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = ServletUtils.getPartValue(req.getPart("action"));
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(ServletUtils.getPartValue(req.getPart("courseId")));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(ServletUtils.getPartValue(req.getPart("name")));
			meeting.setDescription(ServletUtils.getPartValue(req.getPart("description")));
			meeting.setLocation(ServletUtils.getPartValue(req.getPart("location")));

			String leaderIdStr = ServletUtils.getPartValue(req.getPart("leaderUserId"));
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			String startDateTimeStr = ServletUtils.getPartValue(req.getPart("meetingDateTime"));
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = ServletUtils.getPartValue(req.getPart("endDateTime"));
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(ServletUtils.getPartValue(req.getPart("id")));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				}
			} else { // CREATE
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = ServletUtils.getPartValue(req.getPart("requiredRole"));
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}

		} catch (DateTimeParseException | NumberFormatException e) {
			logger.error("Invalid data format in meeting form.", e);
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.warn("Attempting to delete meeting ID {} from course ID {}", meetingId, courseId);

		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.warn("Attempting to delete attachment ID {}", attachmentId);

		MeetingAttachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());

			if (physicalFile.exists()) {
				physicalFile.delete();
			}

			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING_ATTACHMENT", "Anhang '"
						+ attachment.getFilename() + "' von Meeting ID " + attachment.getMeetingId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "meetings";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		MeetingAttachment attachment = new MeetingAttachment();
		attachment.setMeetingId(meetingId);
		attachment.setFilename(fileName);
		// Always use forward slashes for URL paths
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			logger.info("Attachment '{}' uploaded for meeting ID {} by '{}'", fileName, meetingId,
					adminUser.getUsername());
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			AdminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.config.AppConfig;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@WebServlet("/admin/storage")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class.getName());
	private StorageDAO storageDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		try {
			logger.info("Listing all storage items for admin view.");
			Map<String, List<StorageItem>> groupedItems = storageDAO.getAllItemsGroupedByLocation();
			List<StorageItem> flatList = groupedItems.values().stream().flatMap(List::stream)
					.collect(Collectors.toList());
			request.setAttribute("storageList", flatList);
			request.getRequestDispatcher("/admin/admin_storage_list.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("Error in doGet of AdminStorageServlet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();

		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			String action = ServletUtils.getPartValue(request.getPart("action"));
			if ("create".equals(action) || "update".equals(action)) {
				handleCreateOrUpdate(request, response);
			}
		} else {
			String action = request.getParameter("action");
			if ("delete".equals(action)) {
				handleDelete(request, response);
			} else if ("updateDefect".equals(action)) {
				handleDefectUpdate(request, response);
			}
		}
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(ServletUtils.getPartValue(request.getPart("action")));

		try {
			StorageItem item = new StorageItem();
			item.setName(ServletUtils.getPartValue(request.getPart("name")));
			item.setLocation(ServletUtils.getPartValue(request.getPart("location")));
			item.setCabinet(ServletUtils.getPartValue(request.getPart("cabinet")));
			item.setShelf(ServletUtils.getPartValue(request.getPart("shelf")));
			item.setCompartment(ServletUtils.getPartValue(request.getPart("compartment")));
			item.setQuantity(Integer.parseInt(ServletUtils.getPartValue(request.getPart("quantity"))));
			item.setMaxQuantity(Integer.parseInt(ServletUtils.getPartValue(request.getPart("maxQuantity"))));

			String weightStr = ServletUtils.getPartValue(request.getPart("weight_kg"));
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = ServletUtils.getPartValue(request.getPart("price_eur"));
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(ServletUtils.getPartValue(request.getPart("id")));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				AdminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/storage");
	}

	private void handleDefectUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int defectiveQty = Integer.parseInt(request.getParameter("defective_quantity"));
			String reason = request.getParameter("defect_reason");

			if (storageDAO.updateDefectiveStatus(itemId, defectiveQty, reason)) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS",
						String.format("Defekt-Status für Artikel-ID %d aktualisiert: %d defekt. Grund: %s", itemId,
								defectiveQty, reason));
				request.getSession().setAttribute("successMessage", "Defekt-Status aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Defekt-Status konnte nicht aktualisiert werden (vielleicht nicht genug Bestand?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		} catch (SQLException e) {
			request.getSession().setAttribute("errorMessage", "Datenbankfehler: " + e.getMessage());
		}

		String redirectUrl = request.getContextPath()
				+ ("/defects".equals(returnTo) ? "/admin/defects" : "/admin/storage");
		response.sendRedirect(redirectUrl);
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/storage");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Forwards to the system status dashboard page.
 */
@WebServlet("/admin/system")
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/admin/admin_system.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminTaskServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/tasks`, this servlet manages administrative actions for
 * event tasks. It handles POST requests for creating and assigning tasks, and
 * DELETE requests for removing them. All actions are logged to the admin audit
 * trail. It's designed to be called via forms or AJAX from the event details
 * page.
 */
@WebServlet("/admin/tasks")
public class AdminTaskServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminTaskServlet.class);
	private EventTaskDAO taskDAO;
	private UserDAO userDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
		userDAO = new UserDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		logger.debug("AdminTaskServlet received POST with action: {}", action);

		switch (action) {
		case "create":
			handleCreateTask(request, response);
			break;
		case "assign":
			handleAssignTask(request, response);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unknown action");
			break;
		}
	}

	private void handleCreateTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		String description = request.getParameter("description");
		logger.info("Creating new task '{}' for event ID {}", description, eventId);

		EventTask newTask = new EventTask();
		newTask.setEventId(eventId);
		newTask.setDescription(description);

		int newTaskId = taskDAO.createTask(newTask);
		if (newTaskId > 0) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_TASK",
					"Aufgabe '" + description + "' (ID: " + newTaskId + ") für Event-ID " + eventId + " erstellt.");
		}
		response.sendRedirect(request.getContextPath() + "/eventDetails?id=" + eventId);
	}

	private void handleAssignTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		String[] userIdsStr = request.getParameterValues("userIds");
		int[] userIds = userIdsStr == null ? new int[0]
				: Arrays.stream(userIdsStr).mapToInt(Integer::parseInt).toArray();

		logger.info("Assigning task ID {} to {} users for event ID {}", taskId, userIds.length, eventId);
		taskDAO.assignTaskToUsers(taskId, userIds);

		String assignedUsersString;
		if (userIds.length > 0) {
			List<String> usernames = new ArrayList<>();
			for (int userId : userIds) {
				User u = userDAO.getUserById(userId);
				if (u != null) {
					usernames.add(u.getUsername());
				} else {
					usernames.add("ID:" + userId);
				}
			}
			assignedUsersString = String.join(", ", usernames);
		} else {
			assignedUsersString = "niemandem";
		}

		AdminLogService.log(adminUser.getUsername(), "ASSIGN_TASK",
				"Aufgabe (ID: " + taskId + ") für Event-ID " + eventId + " an " + assignedUsersString + " zugewiesen.");

		response.sendRedirect(request.getContextPath() + "/eventDetails?id=" + eventId);
	}

	@Override
	protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int taskId = Integer.parseInt(req.getParameter("taskId"));
			logger.warn("Attempting to delete task ID {} by user '{}'", taskId, adminUser.getUsername());
			if (taskDAO.deleteTask(taskId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_TASK", "Aufgabe mit ID " + taskId + " gelöscht.");
				resp.setStatus(HttpServletResponse.SC_OK);
			} else {
				resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid task ID format for deletion.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid task ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder; // Import GsonBuilder
import de.technikteam.config.LocalDateTimeAdapter; // Import the adapter
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.security.SecureRandom;
import java.time.LocalDateTime; // Import LocalDateTime
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

@WebServlet("/admin/users")
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private UserDAO userDAO;
	private EventDAO eventDAO;
	private Gson gson; // Keep Gson instance

	@Override
	public void init() {
		userDAO = new UserDAO();
		eventDAO = new EventDAO();
		// **FIXED:** Initialize Gson with the custom adapter
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
		logger.info("AdminUserServlet initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		logger.debug("AdminUserServlet received GET with action: {}", action);
		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			case "getUserData":
				getUserDataAsJson(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/users");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		logger.debug("AdminUserServlet received POST with action: {}", action);
		if (action == null) {
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		try {
			switch (action) {
			case "create":
				handleCreateUser(request, response);
				break;
			case "update":
				handleUpdateUser(request, response);
				break;
			case "delete":
				handleDeleteUser(request, response);
				break;
			case "resetPassword":
				handleResetPassword(request, response);
				break;
			default:
				logger.warn("Unknown POST action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/users");
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doPost", e);
			request.getSession().setAttribute("errorMessage",
					"Ein schwerwiegender Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/users");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Listing all users for admin view.");
		List<User> userList = userDAO.getAllUsers();
		request.setAttribute("userList", userList);
		request.getRequestDispatcher("/admin/admin_users.jsp").forward(request, response);
	}

	private void getUserDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int userId = Integer.parseInt(req.getParameter("id"));
			User user = userDAO.getUserById(userId);
			if (user != null) {
				String userJson = gson.toJson(user);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(userJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid User ID");
		}
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		logger.info("Showing details for user ID: {}", userId);
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);
		request.setAttribute("userToView", user);
		request.setAttribute("eventHistory", eventHistory);
		logger.debug("Forwarding to user details page for user '{}'", user.getUsername());
		request.getRequestDispatcher("/admin/admin_user_details.jsp").forward(request, response);
	}

	// --- Other POST handlers remain unchanged ---
	private void handleCreateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		// Unchanged
		String username = request.getParameter("username");
		String pass = request.getParameter("password");
		String role = request.getParameter("role");
		if (username == null || username.trim().isEmpty() || pass == null || pass.trim().isEmpty()) {
			request.getSession().setAttribute("errorMessage", "Benutzername und Passwort dürfen nicht leer sein.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		logger.info("Attempting to create new user '{}' with role '{}'", username, role);
		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRole(role);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0); // Default value
		}
		newUser.setClassName(request.getParameter("className"));

		// FIXME: Passwords should be hashed in a production environment.
		int newUserId = userDAO.createUser(newUser, pass);
		if (newUserId > 0) {
			User adminUser = (User) request.getSession().getAttribute("user");
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s, Klasse: %d %s) erstellt.",
					newUser.getUsername(), newUserId, newUser.getRole(), newUser.getClassYear(),
					newUser.getClassName());
			AdminLogService.log(adminUser.getUsername(), "CREATE_USER", logDetails);
			request.getSession().setAttribute("successMessage",
					"Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.");
		} else {
			request.getSession().setAttribute("errorMessage",
					"Benutzer konnte nicht erstellt werden (ggf. existiert der Name bereits).");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}

	private void handleUpdateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		// Unchanged
		int userId = Integer.parseInt(request.getParameter("userId"));
		User adminUser = (User) request.getSession().getAttribute("user");
		User originalUser = userDAO.getUserById(userId);
		if (originalUser == null) {
			logger.error("Attempted to update non-existent user with ID: {}", userId);
			request.getSession().setAttribute("errorMessage", "Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}
		logger.info("Attempting to update user '{}' (ID: {})", originalUser.getUsername(), userId);

		User updatedUser = new User();
		updatedUser.setId(userId);
		updatedUser.setUsername(request.getParameter("username").trim());
		updatedUser.setRole(request.getParameter("role"));
		updatedUser.setClassName(request.getParameter("className"));
		try {
			updatedUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		List<String> changes = new ArrayList<>();
		if (!Objects.equals(originalUser.getUsername(), updatedUser.getUsername()))
			changes.add("Benutzername von '" + originalUser.getUsername() + "' zu '" + updatedUser.getUsername() + "'");
		if (!Objects.equals(originalUser.getRole(), updatedUser.getRole()))
			changes.add("Rolle von '" + originalUser.getRole() + "' zu '" + updatedUser.getRole() + "'");
		if (originalUser.getClassYear() != updatedUser.getClassYear())
			changes.add("Jahrgang von '" + originalUser.getClassYear() + "' zu '" + updatedUser.getClassYear() + "'");
		if (!Objects.equals(originalUser.getClassName(), updatedUser.getClassName()))
			changes.add("Klasse von '" + originalUser.getClassName() + "' zu '" + updatedUser.getClassName() + "'");

		if (!changes.isEmpty()) {
			if (userDAO.updateUser(updatedUser)) {
				String logDetails = String.format("Benutzer '%s' (ID: %d) aktualisiert. Änderungen: %s.",
						originalUser.getUsername(), userId, String.join(", ", changes));
				AdminLogService.log(adminUser.getUsername(), "UPDATE_USER", logDetails);
				request.getSession().setAttribute("successMessage", "Benutzerdaten erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Benutzerdaten konnten nicht in der DB aktualisiert werden.");
			}
		} else {
			request.getSession().setAttribute("infoMessage", "Keine Änderungen an den Benutzerdaten vorgenommen.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}

	private void handleDeleteUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		// Unchanged
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) request.getSession().getAttribute("user");
		if (loggedInAdmin.getId() == userIdToDelete) {
			logger.warn("Admin '{}' (ID: {}) attempted to delete themselves. Operation denied.",
					loggedInAdmin.getUsername(), loggedInAdmin.getId());
			request.getSession().setAttribute("errorMessage", "Sie können sich nicht selbst löschen.");
			response.sendRedirect(request.getContextPath() + "/admin/users");
			return;
		}

		User userToDelete = userDAO.getUserById(userIdToDelete);
		logger.warn("Admin '{}' is attempting to delete user '{}' (ID: {})", loggedInAdmin.getUsername(),
				userToDelete != null ? userToDelete.getUsername() : "N/A", userIdToDelete);

		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.",
					(userToDelete != null ? userToDelete.getUsername() : "N/A"), userIdToDelete,
					(userToDelete != null ? userToDelete.getRole() : "N/A"));
			AdminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);
			request.getSession().setAttribute("successMessage", "Benutzer erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Benutzer konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}

	private void handleResetPassword(HttpServletRequest request, HttpServletResponse response) throws IOException {
		// Unchanged
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			User userToReset = userDAO.getUserById(userId);

			if (userToReset == null) {
				request.getSession().setAttribute("errorMessage", "Benutzer zum Zurücksetzen nicht gefunden.");
			} else {
				String newPassword = generateRandomPassword(8);
				if (userDAO.changePassword(userId, newPassword)) {
					String logDetails = String.format("Passwort für Benutzer '%s' (ID: %d) zurückgesetzt.",
							userToReset.getUsername(), userId);
					AdminLogService.log(adminUser.getUsername(), "RESET_PASSWORD", logDetails);

					String successMessage = String.format(
							"Passwort für '%s' wurde zurückgesetzt auf: <strong class=\"copyable-password\">%s</strong> (wurde in die Zwischenablage kopiert).",
							userToReset.getUsername(), newPassword);
					request.getSession().setAttribute("passwordResetInfo", successMessage);
				} else {
					request.getSession().setAttribute("errorMessage", "Passwort konnte nicht zurückgesetzt werden.");
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid user ID for password reset.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Benutzer-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/users");
	}

	private String generateRandomPassword(int length) {
		// Unchanged
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		SecureRandom random = new SecureRandom();
		StringBuilder sb = new StringBuilder(length);
		for (int i = 0; i < length; i++) {
			sb.append(chars.charAt(random.nextInt(chars.length())));
		}
		return sb.toString();
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/matrix`, this servlet constructs the data for the
 * comprehensive qualification and attendance matrix. It fetches all users, all
 * course templates, all meetings for each course, and all attendance records.
 * It then organizes this data and forwards it to `admin_matrix.jsp` for
 * rendering a grid view that shows which users have attended which course
 * meetings.
 */
@WebServlet("/admin/matrix")
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private UserDAO userDAO;
	private CourseDAO courseDAO;
	private MeetingDAO meetingDAO;
	private MeetingAttendanceDAO meetingAttendanceDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
		courseDAO = new CourseDAO();
		meetingDAO = new MeetingDAO();
		meetingAttendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		// 1. Fetch all users who will be rows in the matrix
		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		// 2. Fetch all parent courses which define the top-level columns
		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		// 3. For each course, fetch its scheduled meetings to create sub-columns
		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		// 4. Fetch all attendance records and put them in a map for quick lookup.
		// The key is a "userId-meetingId" string.
		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		// 5. Set all data as request attributes for the JSP
		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		request.getRequestDispatcher("/admin/admin_matrix.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\PasskeyApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.yubico.webauthn.AssertionRequest;
import com.yubico.webauthn.data.PublicKeyCredentialCreationOptions;
import de.technikteam.model.User;
import de.technikteam.service.PasskeyService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Provides the REST-like API endpoints for WebAuthn (Passkey) registration and
 * login.
 */
@WebServlet("/api/passkey/*")
public class PasskeyApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PasskeyApiServlet.class);
	private final PasskeyService passkeyService = PasskeyService.getInstance();

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getPathInfo();
		if (action == null) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "No action specified.");
			return;
		}

		switch (action) {
		case "/register/start":
			handleStartRegistration(req, resp);
			break;
		case "/register/finish":
			handleFinishRegistration(req, resp);
			break;
		case "/login/start":
			handleStartLogin(req, resp);
			break;
		case "/login/finish":
			handleFinishLogin(req, resp);
			break;
		default:
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Unknown passkey action.");
			break;
		}
	}

	private void handleStartRegistration(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User user = (User) req.getSession().getAttribute("user");
		if (user == null) {
			resp.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}
		try {
			PublicKeyCredentialCreationOptions options = passkeyService.startRegistration(user);
			String optionsJson = options.toJson();
			req.getSession().setAttribute("passkeyRegistrationRequest", optionsJson);
			resp.setContentType("application/json");
			resp.getWriter().write(optionsJson);
		} catch (Exception e) {
			logger.error("Error starting passkey registration", e);
			resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}

	private void handleFinishRegistration(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User user = (User) req.getSession().getAttribute("user");
		String registrationRequest = (String) req.getSession().getAttribute("passkeyRegistrationRequest");
		if (user == null || registrationRequest == null) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "No registration in progress.");
			return;
		}

		String credentialJson = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		String passkeyName = req.getParameter("name");
		if (passkeyName == null || passkeyName.isBlank()) {
			passkeyName = "Unbenannter Schlüssel";
		}

		boolean success = passkeyService.finishRegistration(credentialJson, registrationRequest, user, passkeyName);
		if (success) {
			resp.setStatus(HttpServletResponse.SC_OK);
		} else {
			resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Registration failed.");
		}
		req.getSession().removeAttribute("passkeyRegistrationRequest");
	}

	private void handleStartLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			AssertionRequest assertionRequest = passkeyService.startAssertion();
			String optionsJson = assertionRequest.toJson();
			req.getSession().setAttribute("passkeyLoginRequest", optionsJson);
			resp.setContentType("application/json");
			resp.getWriter().write(optionsJson);
		} catch (Exception e) {
			logger.error("Error starting passkey login", e);
			resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}

	private void handleFinishLogin(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		String loginRequest = (String) req.getSession().getAttribute("passkeyLoginRequest");
		if (loginRequest == null) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "No login in progress.");
			return;
		}

		String credentialJson = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

		Optional<User> userOpt = passkeyService.finishAssertion(credentialJson, loginRequest);

		if (userOpt.isPresent()) {
			User user = userOpt.get();
			HttpSession session = req.getSession(true);
			session.setAttribute("user", user);
			session.setAttribute("username", user.getUsername());
			session.setAttribute("role", user.getRole());
			resp.setStatus(HttpServletResponse.SC_OK);
		} else {
			resp.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Passkey authentication failed.");
		}
		req.getSession().removeAttribute("passkeyLoginRequest");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\SystemStatsApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Provides system statistics as a JSON API endpoint. This servlet is protected
 * by the AdminFilter.
 */
@WebServlet("/api/admin/system-stats")
public class SystemStatsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private SystemInfoService systemInfoService;
	private Gson gson;

	@Override
	public void init() throws ServletException {
		systemInfoService = new SystemInfoService();
		gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		String jsonResponse = gson.toJson(stats);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CollaborativeEditorServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/editor-page`, this is a very simple servlet whose only purpose is
 * to forward the user to the `collaborative_editor.jsp` page. All the dynamic
 * functionality for the editor is handled client-side by JavaScript and the
 * `DocumentApiServlet`.
 */
@WebServlet("/editor-page")
public class CollaborativeEditorServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/collaborative_editor.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DocumentApiServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.stream.Collectors;

import de.technikteam.dao.FileDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/api/document`, this servlet provides a simple REST-like API for
 * the collaborative text editor. A GET request fetches the latest document
 * content, while a POST request (with the new content in its raw body) updates
 * the document in the database. It interacts with `FileDAO` to persist the
 * content.
 */
@WebServlet("/api/document")
public class DocumentApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DocumentApiServlet.class);
	private FileDAO fileDAO;
	private static final String DOCUMENT_NAME = "realtime_notes";

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	/**
	 * Handles GET requests to fetch the latest content of the shared document.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.trace("GET request for document content '{}'", DOCUMENT_NAME);
		String content = fileDAO.getDocumentContent(DOCUMENT_NAME);

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(content);
	}

	/**
	 * Handles POST requests to update the document content. It reads the raw text
	 * from the request body.
	 */
	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String content = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		logger.trace("POST request to update document content for '{}'. Content length: {}", DOCUMENT_NAME,
				content.length());

		boolean success = fileDAO.updateDocumentContent(DOCUMENT_NAME, content);

		if (success) {
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update document content for '{}'", DOCUMENT_NAME);
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DownloadServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/download`, this servlet handles file download requests for both
 * general files and meeting attachments. It takes a `file` parameter which
 * corresponds to a path relative to the application's upload directory. It
 * performs basic security checks, constructs the full file path, and streams
 * the file from the server's filesystem to the user's browser, setting the
 * correct headers to trigger a download dialog.
 */
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DownloadServlet.class);

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String relativePath = request.getParameter("file");
		if (relativePath == null || relativePath.isEmpty()) {
			logger.warn("Download request rejected: missing 'file' parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Fehlender 'file' Parameter.");
			return;
		}

		User user = (User) request.getSession().getAttribute("user");

		// Basic security measure to prevent path traversal attacks (e.g., ../../)
		if (relativePath.contains("..")) {
			logger.warn("Potential path traversal attack from user '{}' for file '{}'. Access denied.",
					(user != null ? user.getUsername() : "GUEST"), relativePath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Zugriff verweigert.");
			return;
		}

		// Normalize path separators to be OS-independent, crucial for deployment
		String sanitizedPath = relativePath.replace("/", File.separator).replace("\\", File.separator);

		File file = new File(AppConfig.UPLOAD_DIRECTORY, sanitizedPath);
		if (!file.exists() || !file.isFile()) {
			logger.error("Download failed: File not found at resolved path {}", file.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Datei nicht gefunden.");
			return;
		}

		response.setContentType("application/octet-stream");
		response.setContentLengthLong(file.length());

		String headerKey = "Content-Disposition";
		// URL-encode the filename to handle special characters and spaces correctly.
		String headerValue = String.format("attachment; filename=\"%s\"",
				URLEncoder.encode(file.getName(), StandardCharsets.UTF_8.toString()));
		response.setHeader(headerKey, headerValue);

		logger.info("User '{}' is downloading file: {}. Size: {} bytes.", (user != null ? user.getUsername() : "GUEST"),
				file.getAbsolutePath(), file.length());

		try (FileInputStream inStream = new FileInputStream(file);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;
			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventActionServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/event-action`, this servlet processes POST requests from the main
 * event listing page (`events.jsp`). It allows a logged-in user to either sign
 * up for (`signup`) or sign off from (`signoff`) an event by updating the
 * `event_attendance` table via the `EventDAO`.
 */
@WebServlet("/event-action")
public class EventActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventActionServlet.class);
	private EventDAO eventDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String eventIdParam = request.getParameter("eventId");

		if (user == null || action == null || eventIdParam == null) {
			logger.warn("Invalid request to EventActionServlet. Missing user, action, or eventId parameter.");
			response.sendRedirect(request.getContextPath() + "/events");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.info("User '{}' (ID: {}) is performing action '{}' on event ID {}", user.getUsername(), user.getId(),
					action, eventId);

			if ("signup".equals(action)) {
				eventDAO.signUpForEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Event angemeldet.");
			} else if ("signoff".equals(action)) {
				eventDAO.signOffFromEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Event abgemeldet.");
			} else {
				logger.warn("Unknown action received in EventActionServlet: {}", action);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in EventActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}

		// Redirect back to the event list page to show the updated status
		response.sendRedirect(request.getContextPath() + "/events");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventChatApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.model.EventChatMessage;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/api/event-chat`, this servlet provides a JSON API for the
 * real-time event chat feature. A GET request fetches all messages for a given
 * event ID. A POST request allows a logged-in user to submit a new message for
 * an event. It uses the Gson library for JSON serialization.
 */
@WebServlet("/api/event-chat")
public class EventChatApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventChatApiServlet.class);
	private EventChatDAO chatDAO;
	private Gson gson;

	@Override
	public void init() {
		chatDAO = new EventChatDAO();
		gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			logger.trace("GET request for chat messages for event ID: {}", eventId);
			List<EventChatMessage> messages = chatDAO.getMessagesForEvent(eventId);
			String jsonResponse = gson.toJson(messages);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat API: Invalid or missing eventId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing eventId.");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			String messageText = request.getParameter("messageText");
			User user = (User) request.getSession().getAttribute("user");

			if (user == null || messageText == null || messageText.trim().isEmpty()) {
				logger.warn("Bad POST request to event chat API: Missing user session or message text for event ID {}",
						eventId);
				response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing user or message text.");
				return;
			}

			logger.info("User '{}' posting message to event chat for event ID {}: '{}'", user.getUsername(), eventId,
					messageText);

			EventChatMessage newMessage = new EventChatMessage();
			newMessage.setEventId(eventId);
			newMessage.setUserId(user.getId());
			newMessage.setUsername(user.getUsername());
			newMessage.setMessageText(messageText);

			if (chatDAO.postMessage(newMessage)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				logger.error("Failed to post chat message for user '{}' to event ID {}", user.getUsername(), eventId);
				response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat API: Invalid eventId in POST.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid event ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventAttachmentDAO;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.util.stream.Collectors;
import java.io.IOException;
import java.util.List;
import java.util.Set;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/eventDetails`, this servlet is responsible for displaying the
 * detailed view of a single event. It fetches all relevant data for the event,
 * including its description, skill requirements, and assigned team. If the
 * event is currently 'LAUFEND' (running), it also fetches associated tasks and
 * chat history. It forwards all this data to `eventDetails.jsp`.
 */
@WebServlet("/eventDetails")
public class EventDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventDetailsServlet.class);
	private EventDAO eventDAO;
	private EventTaskDAO taskDAO;
	private EventChatDAO chatDAO;
	private EventAttachmentDAO attachmentDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		taskDAO = new EventTaskDAO();
		chatDAO = new EventChatDAO();
		attachmentDAO = new EventAttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(request.getParameter("id"));
			logger.info("Event details requested for ID: {} by user '{}'", eventId, user.getUsername());
			Event event = eventDAO.getEventById(eventId);

			if (event == null) {
				logger.warn("Event with ID {} not found. Redirecting to 404.", eventId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event nicht gefunden.");
				return;
			}

			// Fetch base data applicable to all event statuses
			event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
			event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));

			String userRoleForAttachments = (user.getRole().equals("ADMIN") || user.getId() == event.getLeaderUserId())
					? "ADMIN"
					: "NUTZER";
			event.setAttachments(attachmentDAO.getAttachmentsForEvent(eventId, userRoleForAttachments));

			List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
			event.setAssignedAttendees(assignedUsers);

			// Fetch data specific to running events (tasks, chat)
			if ("LAUFEND".equalsIgnoreCase(event.getStatus())) {
				logger.debug("Event {} is running. Fetching tasks and chat messages.", eventId);
				event.setEventTasks(taskDAO.getTasksForEvent(eventId));
				event.setChatMessages(chatDAO.getMessagesForEvent(eventId));
			}

			// For Admins and Users, provide the list of assigned users for the task assignment
			// dropdown
			if ("ADMIN".equalsIgnoreCase(user.getRole()) || "NUTZER".equalsIgnoreCase(user.getRole())) {
				request.setAttribute("assignedUsers", assignedUsers);
			}

			// For regular users, determine if they are part of the assigned team to show
			// relevant UI
			Set<Integer> assignedUserIds = assignedUsers.stream().map(User::getId).collect(Collectors.toSet());
			boolean isUserAssigned = assignedUserIds.contains(user.getId());
			request.setAttribute("isUserAssigned", isUserAssigned);

			request.setAttribute("event", event);
			logger.debug("Forwarding to eventDetails.jsp for event '{}'", event.getName());
			request.getRequestDispatcher("/eventDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		} catch (Exception e) {
			logger.error("An unexpected error occurred while fetching event details.", e);
			response.sendRedirect(request.getContextPath() + "/error500.jsp");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/events`, this servlet is responsible for the main event listing
 * page for a logged-in user. It fetches a list of all upcoming events for which
 * the user is qualified, along with their specific attendance status for each
 * event (e.g., ZUGEWIESEN, ANGEMELDET, OFFEN). It then passes this data to
 * `events.jsp`.
 */
@WebServlet("/events")
public class EventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventServlet.class);
	private EventDAO eventDAO;

	public void init() {
		eventDAO = new EventDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming events for user '{}' (ID: {})", user.getUsername(), user.getId());

		// The DAO method intelligently calculates the most relevant status for the
		// user.
		List<Event> events = eventDAO.getUpcomingEventsForUser(user, 0); // 0 means no limit

		request.setAttribute("events", events);
		logger.debug("Found {} upcoming events for user '{}'. Forwarding to events.jsp.", events.size(),
				user.getUsername());
		request.getRequestDispatcher("/events.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FileServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/dateien`, this servlet handles the display of the main files and
 * documents page for users. It fetches all files the user is permitted to see,
 * grouped by category. In a unique step, it programmatically injects a
 * "virtual" file entry that links to the collaborative live editor, placing it
 * in a specific category for a seamless user experience.
 */
@WebServlet("/dateien")
public class FileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("File page requested by user '{}' (Role: {})", user.getUsername(), user.getRole());

		// 1. Fetch files from the database, already filtered by the user's role in the
		// DAO.
		Map<String, List<File>> fileData = fileDAO.getAllFilesGroupedByCategory(user);

		// 2. Create our "virtual" file object for the collaborative editor.
		File collaborativeFile = new File();
		collaborativeFile.setId(-1); // Use a special ID to identify it in the JSP.
		collaborativeFile.setFilename("Gemeinsamer Notizblock (Live-Editor)");
		collaborativeFile.setFilepath(null); // No physical file path.

		// 3. Add the virtual file to a specific category. If the category doesn't
		// exist, create it.
		String virtualCategoryName = "Allgemeine Dokumente";
		List<File> generalFiles = fileData.computeIfAbsent(virtualCategoryName, k -> new ArrayList<>());
		generalFiles.add(0, collaborativeFile); // Add to the beginning of the list.

		// 4. Send the modified map to the JSP.
		request.setAttribute("fileData", fileData);
		logger.debug("Forwarding file data (including virtual editor link) to dateien.jsp.");
		request.getRequestDispatcher("/dateien.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\HomeServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapped to `/home`, this servlet serves the main landing page for a logged-in
 * user. It provides a quick overview by fetching a limited number of upcoming
 * events and meetings that are relevant to the user. The fetched data is then
 * forwarded to `home.jsp` for display.
 */
@WebServlet("/home")
public class HomeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(HomeServlet.class);
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;

	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Home page requested by user '{}'. Fetching dashboard data.", user.getUsername());

		// Fetch up to 3 upcoming events the user is qualified for
		List<Event> upcomingEvents = eventDAO.getUpcomingEventsForUser(user, 3);
		logger.debug("Fetched {} upcoming events for home page.", upcomingEvents.size());

		// Fetch all upcoming meetings and then limit to the first 3
		List<Meeting> upcomingMeetings = meetingDAO.getUpcomingMeetingsForUser(user).stream().limit(3)
				.collect(Collectors.toList());
		logger.debug("Fetched {} upcoming meetings for home page.", upcomingMeetings.size());

		request.setAttribute("upcomingEvents", upcomingEvents);
		request.setAttribute("upcomingMeetings", upcomingMeetings);

		logger.debug("Forwarding to home.jsp.");
		request.getRequestDispatcher("/home.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ImageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/image`, this servlet acts as a secure proxy to serve images. It
 * prevents direct filesystem access by taking a `file` parameter, locating the
 * image within a designated `images` subdirectory in the main upload path, and
 * then streaming it to the browser. It sets the `Content-Disposition: inline`
 * header so the image is displayed directly on the web page rather than
 * downloaded.
 */
@WebServlet("/image")
public class ImageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(ImageServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String filename = request.getParameter("file");
		if (filename == null || filename.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing 'file' parameter.");
			return;
		}

		try {
			filename = URLDecoder.decode(filename, StandardCharsets.UTF_8.toString());
		} catch (IllegalArgumentException e) {
			logger.warn("Could not decode filename: {}", filename, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid filename encoding.");
			return;
		}

		// Prevent path traversal
		if (filename.contains("..")) {
			logger.warn("Potential path traversal attack detected for image filename: {}", filename);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		// Construct the full path to the image file inside the 'images' subdirectory
		File imageFile = new File(AppConfig.UPLOAD_DIRECTORY + File.separator + "images", filename);

		if (!imageFile.exists() || !imageFile.isFile()) {
			logger.warn("Image not found at path: {}", imageFile.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Image not found.");
			return;
		}

		// Determine content type (MIME type) from file extension
		String contentType = getServletContext().getMimeType(imageFile.getName());
		if (contentType == null) {
			contentType = "application/octet-stream"; // Fallback if type is unknown
		}

		response.setContentType(contentType);
		response.setContentLengthLong(imageFile.length());

		// The 'inline' header tells the browser to display the file, not to download
		// it.
		response.setHeader("Content-Disposition", "inline; filename=\"" + imageFile.getName() + "\"");

		logger.debug("Serving image: {} with content type {}", imageFile.getAbsolutePath(), contentType);

		// Stream the file content to the response
		try (FileInputStream inStream = new FileInputStream(imageFile);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;

			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LoginServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/login`, this servlet is central to the application's
 * authentication. It handles GET requests to simply display the `login.jsp`
 * page. It handles POST requests by taking a username and password, validating
 * them against the database via `UserDAO`, and creating a user session upon
 * successful authentication. If authentication fails, it forwards back to the
 * login page with an error message.
 */
@WebServlet("/login")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LoginServlet.class);
	private UserDAO userDAO;

	public void init() {
		userDAO = new UserDAO();
		logger.info("LoginServlet initialized.");
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		logger.info("Login attempt for username: {}", username);

		// NOTE: This uses plaintext password validation for simplicity.
		// In a production environment, use a strong hashing library like BCrypt.
		User user = userDAO.validateUser(username, password);

		if (user != null) {
			// Create a new session for the user
			HttpSession session = request.getSession();
			session.setAttribute("user", user); // Store the entire user object
			session.setAttribute("username", user.getUsername());
			session.setAttribute("role", user.getRole());

			logger.info("Login successful for user: {}. Role: {}. Redirecting to home.", user.getUsername(),
					user.getRole());
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			logger.warn("Login failed for username: {}. Invalid credentials.", username);
			request.setAttribute("errorMessage", "Benutzername oder Passwort ungültig.");
			request.getRequestDispatcher("login.jsp").forward(request, response);
		}
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received for /login. Forwarding to login.jsp.");
		request.getRequestDispatcher("login.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LogoutServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/logout`, this servlet handles the user logout process. It
 * invalidates the current session, effectively logging the user out and
 * clearing all session attributes. It then redirects the user to a `logout.jsp`
 * confirmation page, passing the username as a parameter for a personalized
 * message.
 */
@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LogoutServlet.class);

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		String username = "Gast";

		if (session != null) {
			if (session.getAttribute("username") != null) {
				username = (String) session.getAttribute("username");
			}
			logger.info("Logging out user: {}. Invalidating session.", username);
			session.invalidate();
		} else {
			logger.warn("Logoutservlet called but no active session found.");
		}

		// Redirect to the logout page with the username as a URL parameter
		response.sendRedirect("logout.jsp?username=" + URLEncoder.encode(username, StandardCharsets.UTF_8.toString()));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/meeting-action`, this servlet processes POST requests from the
 * main course/meeting listing page (`lehrgaenge.jsp`). It allows a logged-in
 * user to either sign up for (`signup`) or sign off from (`signoff`) a specific
 * meeting by updating the `meeting_attendance` table via the
 * `MeetingAttendanceDAO`.
 */
@WebServlet("/meeting-action")
public class MeetingActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingActionServlet.class);
	private MeetingAttendanceDAO attendanceDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String meetingIdParam = request.getParameter("meetingId");

		if (user == null || action == null || meetingIdParam == null) {
			logger.warn("Invalid request to MeetingActionServlet. Missing user, action, or meetingId.");
			response.sendRedirect(request.getContextPath() + "/lehrgaenge");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			logger.info("User '{}' (ID: {}) performing action '{}' on meeting ID {}", user.getUsername(), user.getId(),
					action, meetingId);

			if ("signup".equals(action)) {
				// The DAO method handles both new signups and re-signups.
				attendanceDAO.setAttendance(user.getId(), meetingId, true, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Meeting angemeldet.");
			} else if ("signoff".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, false, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Meeting abgemeldet.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format in MeetingActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Meeting-ID.");
		}

		// Redirect back to the meeting list page to show the updated status.
		response.sendRedirect(request.getContextPath() + "/lehrgaenge");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingAttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/meetingDetails`, this servlet handles GET requests to display the
 * detailed view of a single course meeting. It fetches the core meeting data as
 * well as any associated file attachments, applying role-based filtering for
 * the attachments. The collected data is then forwarded to
 * `meetingDetails.jsp`.
 */
@WebServlet("/meetingDetails")
public class MeetingDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingDetailsServlet.class);
	private MeetingDAO meetingDAO;
	private MeetingAttachmentDAO attachmentDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		attachmentDAO = new MeetingAttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		String meetingIdParam = request.getParameter("id");
		if (meetingIdParam == null || meetingIdParam.isEmpty()) {
			logger.warn("Bad request to MeetingDetailsServlet: missing ID parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Meeting-ID fehlt.");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			User user = (User) request.getSession().getAttribute("user");
			logger.info("Meeting details for ID {} requested by user '{}'", meetingId, user.getUsername());

			Meeting meeting = meetingDAO.getMeetingById(meetingId);

			if (meeting == null) {
				logger.warn("Meeting with ID {} not found.", meetingId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden.");
				return;
			}

			// If current user is the leader, they act as an ADMIN for viewing attachments
			String attachmentUserRole = user.getRole();
			if (user.getId() == meeting.getLeaderUserId()) {
				attachmentUserRole = "ADMIN";
				logger.debug("User {} is leader of meeting {}. Granting admin view for attachments.",
						user.getUsername(), meetingId);
			}

			// Fetch attachments for the meeting, respecting the user's role (or leader
			// override)
			request.setAttribute("attachments", attachmentDAO.getAttachmentsForMeeting(meetingId, attachmentUserRole));
			request.setAttribute("meeting", meeting);

			logger.debug("Forwarding to meetingDetails.jsp for meeting '{}'", meeting.getName());
			request.getRequestDispatcher("/meetingDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format: {}", meetingIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/lehrgaenge`, this servlet is responsible for the main
 * course/meeting listing page for a logged-in user. It fetches a list of all
 * upcoming meetings and enriches each one with the user's specific attendance
 * status (e.g., ANGEMELDET, ABGEMELDET, OFFEN). This data is then passed to
 * `lehrgaenge.jsp` for rendering.
 */
@WebServlet("/lehrgaenge")
public class MeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingServlet.class);
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming meetings for user '{}' (ID: {})", user.getUsername(), user.getId());

		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);

		request.setAttribute("meetings", meetings);
		logger.debug("Found {} upcoming meetings. Forwarding to lehrgaenge.jsp.", meetings.size());
		request.getRequestDispatcher("/lehrgaenge.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\NotificationServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/notifications`, this servlet is the entry point for clients
 * wanting to receive real-time updates via Server-Sent Events (SSE). On a GET
 * request, it establishes a persistent connection by setting the appropriate
 * headers and registering the client's asynchronous context with the singleton
 * `NotificationService`. It requires an active user session to connect.
 */
@WebServlet(urlPatterns = "/notifications", asyncSupported = true)
public class NotificationServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(NotificationServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Unauthorized attempt to connect to SSE stream. No session.");
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		logger.info("Client '{}' connecting to SSE stream.", session.getAttribute("username"));

		// Set headers for Server-Sent Events
		response.setContentType("text/event-stream");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Cache-Control", "no-cache");
		response.setHeader("Connection", "keep-alive");

		// Register the client with the notification service
		NotificationService.getInstance().register(request);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PasskeyManagementServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.PasskeyCredentialDAO;
import de.technikteam.model.PasskeyCredential;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * Handles the display and management of a user's own passkeys.
 */
@WebServlet("/passkeys")
public class PasskeyManagementServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private PasskeyCredentialDAO passkeyDAO;

	@Override
	public void init() throws ServletException {
		passkeyDAO = new PasskeyCredentialDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		List<PasskeyCredential> passkeys = passkeyDAO.getCredentialsForUser(user.getId());
		request.setAttribute("passkeys", passkeys);
		request.getRequestDispatcher("/passkeys.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		String action = request.getParameter("action");
		if ("delete".equals(action)) {
			try {
				int credentialId = Integer.parseInt(request.getParameter("id"));
				if (passkeyDAO.deleteCredential(credentialId, user.getId())) {
					request.getSession().setAttribute("successMessage", "Passkey erfolgreich entfernt.");
				} else {
					request.getSession().setAttribute("errorMessage", "Passkey konnte nicht entfernt werden.");
				}
			} catch (NumberFormatException e) {
				request.getSession().setAttribute("errorMessage", "Ungültige Passkey-ID.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/passkeys");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PasswordServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/passwort`, this servlet allows a logged-in user to change their
 * own password. It handles GET requests by displaying the change form
 * (`passwort.jsp`) and POST requests by processing the password change. This
 * includes validating the user's current password and ensuring the new password
 * confirmation matches before updating the database via `UserDAO`.
 */
@WebServlet("/passwort")
public class PasswordServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PasswordServlet.class);
	private UserDAO userDAO;

	public void init() {
		userDAO = new UserDAO();
		logger.info("PasswordServlet initialized.");
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received, showing password change form.");
		request.getRequestDispatcher("passwort.jsp").forward(request, response);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		logger.info("Password change attempt for user: {}", user.getUsername());

		String currentPassword = request.getParameter("currentPassword");
		String newPassword = request.getParameter("newPassword");
		String confirmPassword = request.getParameter("confirmPassword");

		// Validate that the user knows their current password
		User authenticatedUser = userDAO.validateUser(user.getUsername(), currentPassword);
		if (authenticatedUser == null) {
			logger.warn("Password change failed for {}: incorrect current password.", user.getUsername());
			request.setAttribute("errorMessage", "Das aktuelle Passwort ist nicht korrekt.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		if (!newPassword.equals(confirmPassword)) {
			logger.warn("Password change failed for {}: new passwords do not match.", user.getUsername());
			request.setAttribute("errorMessage", "Die neuen Passwörter stimmen nicht überein.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		if (newPassword.trim().isEmpty()) {
			logger.warn("Password change failed for {}: new password is empty.", user.getUsername());
			request.setAttribute("errorMessage", "Das neue Passwort darf nicht leer sein.");
			request.getRequestDispatcher("passwort.jsp").forward(request, response);
			return;
		}

		boolean success = userDAO.changePassword(user.getId(), newPassword);
		if (success) {
			logger.info("Password successfully changed for user: {}", user.getUsername());
			request.setAttribute("successMessage", "Ihr Passwort wurde erfolgreich geändert.");
		} else {
			logger.error("Password change failed for {} due to a DAO error.", user.getUsername());
			request.setAttribute("errorMessage", "Ein interner Fehler ist aufgetreten. Bitte versuchen Sie es erneut.");
		}
		request.getRequestDispatcher("passwort.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageHistoryApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Provides a JSON API to fetch the usage history for a specific storage item.
 */
@WebServlet("/api/storage-history")
public class StorageHistoryApiServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LogManager.getLogger(StorageHistoryApiServlet.class);
    private StorageLogDAO logDAO;
    private Gson gson;

    @Override
    public void init() {
        logDAO = new StorageLogDAO();
        gson = new GsonBuilder()
                .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
                .create();
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            int itemId = Integer.parseInt(request.getParameter("itemId"));
            logger.debug("API request for storage history for item ID: {}", itemId);
            List<StorageLogEntry> history = logDAO.getHistoryForItem(itemId);

            String jsonResponse = gson.toJson(history);
            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.getWriter().write(jsonResponse);

        } catch (NumberFormatException e) {
            logger.warn("Bad request to storage history API: invalid or missing itemId");
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing itemId.");
        }
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/storage-item`, this servlet displays a public-facing detail page
 * for a single inventory item. It is typically accessed by scanning a QR code
 * that contains the URL with the item's ID. It fetches the item's data using
 * `StorageDAO` and forwards it to `storage_item_details.jsp` for rendering.
 */
@WebServlet("/storage-item")
public class StorageItemDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageItemDetailsServlet.class);
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			logger.info("Storage item details requested for ID: {}", itemId);

			StorageItem item = storageDAO.getItemById(itemId);

			if (item == null) {
				logger.warn("Storage item with ID {} not found.", itemId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}

			request.setAttribute("item", item);
			logger.debug("Forwarding to storage_item_details.jsp for item '{}'", item.getName());
			request.getRequestDispatcher("/storage_item_details.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid storage item ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet, mapped to `/lager`, is responsible for displaying the main
 * inventory/storage page for users. On a GET request, it fetches all storage
 * items from the database, grouped by their physical location, and forwards
 * this structured data to `lager.jsp` for rendering.
 */
@WebServlet("/lager")
public class StorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageServlet.class);
	private StorageDAO storageDAO;
	private EventDAO eventDAO;

	public void init() {
		storageDAO = new StorageDAO();
		eventDAO = new EventDAO();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Main storage page requested. Fetching all items.");

		// Fetch all items, grouped by their location (e.g., "Erdgeschoss",
		// "Lagercontainer").
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		request.setAttribute("storageData", storageData);
		request.setAttribute("activeEvents", activeEvents);
		logger.debug("Forwarding {} location groups to lager.jsp.", storageData.size());
		request.getRequestDispatcher("lager.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageTransactionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.sql.SQLException;

/**
 * Mapped to `/storage-transaction`, this servlet handles the business logic for
 * checking items in and out of the inventory. It processes POST requests from
 * the modal on the main storage page. It atomically updates the item quantity
 * in the `storage_items` table and creates a record of the transaction in both
 * the `storage_log` table and the main administrative audit log.
 */
@WebServlet("/storage-transaction")
public class StorageTransactionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageTransactionServlet.class);
	private StorageDAO storageDAO;
	private StorageLogDAO storageLogDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		storageLogDAO = new StorageLogDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String redirectUrl = request.getParameter("redirectUrl");
		if (redirectUrl == null || redirectUrl.isEmpty()) {
			redirectUrl = request.getContextPath() + "/lager";
		}

		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			int quantity = Integer.parseInt(request.getParameter("quantity"));
			String type = request.getParameter("type"); // "checkout" or "checkin"
			String notes = request.getParameter("notes");
			int eventId = 0;
			try {
				eventId = Integer.parseInt(request.getParameter("eventId"));
			} catch (NumberFormatException e) {
				// Ignore if not provided or invalid
			}

			int quantityChange = "checkin".equals(type) ? quantity : -quantity;
			logger.info("Processing storage transaction by user '{}': item ID {}, quantity change {}",
					user.getUsername(), itemId, quantityChange);

			// Atomically update the quantity. This can fail if there's not enough stock.
			boolean success = storageDAO.updateItemQuantity(itemId, quantityChange);

			if (success) {
				// Log the transaction in the specific storage log and the general admin log.
				storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, notes, eventId);

				StorageItem item = storageDAO.getItemById(itemId);
				String itemName = (item != null) ? item.getName() : "N/A";
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, itemName, itemId,
						action, notes);
				AdminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

				request.getSession().setAttribute("successMessage",
						"Erfolgreich " + quantity + " Stück " + action + ".");
			} else {
				logger.warn("Storage transaction failed for item ID {}. Not enough stock.", itemId);
				request.getSession().setAttribute("errorMessage",
						"Transaktion fehlgeschlagen. Nicht genügend Artikel auf Lager?");
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid number format in storage transaction request.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültiges Zahlenformat.");
		} catch (SQLException e) {
			logger.error("SQL error during storage transaction.", e);
			request.getSession().setAttribute("errorMessage", "Datenbankfehler bei der Transaktion: " + e.getMessage());
		}

		response.sendRedirect(redirectUrl);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\TaskActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/task-action`, this servlet handles task status updates initiated
 * by non-admin users, typically via AJAX from the event details page. It
 * processes a POST request to change a task's status (e.g., from "OFFEN" to
 * "ERLEDIGT") when a user checks a checkbox corresponding to their assigned
 * task.
 */
@WebServlet("/task-action")
public class TaskActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(TaskActionServlet.class);
	private EventTaskDAO taskDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		try {
			int taskId = Integer.parseInt(request.getParameter("taskId"));
			String status = request.getParameter("status");
			logger.info("User '{}' is updating task ID {} to status '{}'", user.getUsername(), taskId, status);

			if (taskDAO.updateTaskStatus(taskId, status)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				logger.error("Failed to update task status for task ID {}", taskId);
				response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Task status could not be updated.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid task ID format in task-action request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid task ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\DaoUtils.java
========================================================================

package de.technikteam.util;

import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

/**
 * A utility class for common Data Access Object (DAO) helper methods.
 */
public class DaoUtils {

    /**
     * Private constructor to prevent instantiation.
     */
    private DaoUtils() {
    }

    /**
     * Checks if a ResultSet contains a column with the given name
     * (case-insensitive).
     *
     * @param rs         The ResultSet to check.
     * @param columnName The name of the column.
     * @return true if the column exists, false otherwise.
     * @throws SQLException If a database error occurs.
     */
    public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
        ResultSetMetaData rsmd = rs.getMetaData();
        int columns = rsmd.getColumnCount();
        for (int x = 1; x <= columns; x++) {
            if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
                return true;
            }
        }
        return false;
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\util\ServletUtils.java
========================================================================

package de.technikteam.util;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;
import jakarta.servlet.http.Part;

/**
 * A utility class for common Servlet helper methods.
 */
public class ServletUtils {

	/**
	 * Private constructor to prevent instantiation.
	 */
	private ServletUtils() {
	}

	/**
	 * Extracts the string value from a `multipart/form-data` part.
	 *
	 * @param part The Part object to extract the value from.
	 * @return The string value of the part, or null if the part is null.
	 * @throws IOException if an I/O error occurs.
	 */
	public static String getPartValue(Part part) throws IOException {
		if (part == null) {
			return null;
		}
		try (InputStream inputStream = part.getInputStream();
				Scanner scanner = new Scanner(inputStream, StandardCharsets.UTF_8.name())) {
			return scanner.useDelimiter("\\A").hasNext() ? scanner.next() : "";
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\resources\log4j2.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<!-- Log4j2 Configuration File This file controls all logging behavior for 
	the application. It defines where log messages are sent (appenders) and at 
	what detail level (loggers). It's configured to log to both the server console 
	(for live debugging in Eclipse) and a rolling file on the server's filesystem 
	for persistent records. -->
<Configuration status="WARN">
	<Properties>
		<!-- Use the 'catalina.base' system property provided by Tomcat to create 
			the logs folder in a guaranteed writable location relative to the server 
			instance (e.g., .../wst.server.core/tmp0/logs). This avoids permission issues 
			with writing to the source directory. -->
		<Property name="log-path">${sys:catalina.base}/logs</Property>
	</Properties>

	<Appenders>
		<!-- Console Appender: Sends log output to SYSTEM_OUT, which is typically 
			visible in the Eclipse Console view. -->
		<Console name="Console" target="SYSTEM_OUT">
			<!-- Pattern includes: timestamp, thread name, log level, logger name 
				(abbreviated), the log message, and a newline. -->
			<PatternLayout
				pattern="%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n" />
		</Console>

		<!-- Rolling File Appender: Writes logs to a file. It "rolls over" (creates 
			a new file) based on time (daily) or size (10 MB), keeping a maximum of 10 
			old log files compressed in .gz format. -->
		<RollingFile name="RollingFile"
			fileName="${log-path}/technik-team-app.log"
			filePattern="${log-path}/technik-team-app-%d{MM-dd-yyyy}-%i.log.gz">
			<PatternLayout>
				<Pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} -
					%msg%n</Pattern>
			</PatternLayout>
			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="10 MB" />
			</Policies>
			<DefaultRolloverStrategy max="10" />
		</RollingFile>
	</Appenders>

	<Loggers>
		<!-- Application-specific Logger: Logs all messages from the 'de.technikteam' 
			package and its sub-packages at the DEBUG level or higher (DEBUG, INFO, WARN, 
			ERROR, FATAL). 'additivity="false"' prevents these messages from being passed 
			up to the root logger, avoiding duplicate output. -->
		<Logger name="de.technikteam" level="debug" additivity="false">
			<AppenderRef ref="Console" />
			<AppenderRef ref="RollingFile" />
		</Logger>

		<!-- Root Logger: This is the catch-all logger for all other libraries 
			used in the project (e.g., Tomcat, HikariCP, etc.). Setting it to WARN reduces 
			log noise by only showing important warnings and errors from third-party 
			code. -->
		<Root level="warn">
			<AppenderRef ref="Console" />
			<AppenderRef ref="RollingFile" />
		</Root>
	</Loggers>
</Configuration>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_course_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Lehrgangs-Vorlagen" />
	<c:param name="navType" value="admin" />
</c:import>

<h1>Lehrgangs-Vorlagen verwalten</h1>
<p>Dies sind die übergeordneten Lehrgänge. Einzelne Termine
	(Meetings) werden für jede Vorlage separat verwaltet.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>
<div class="table-controls">
	<button type="button" id="new-course-btn" class="btn">Neue
		Lehrgangs-Vorlage anlegen</button>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<c:if test="${empty courseList}">
	<div class="card">
		<p>Es wurden noch keine Lehrgangs-Vorlagen erstellt.</p>
	</div>
</c:if>

<div class="table-wrapper">
	<table class="data-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name der Vorlage</th>
				<th class="sortable" data-sort-type="string">Abkürzung (für
					Matrix)</th>
				<th style="width: 450px;">Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="course" items="${courseList}">
				<tr>
					<td><c:out value="${course.name}" /></td>
					<td><c:out value="${course.abbreviation}" /></td>
					<td style="display: flex; gap: 0.5rem; flex-wrap: wrap;"><a
						href="${pageContext.request.contextPath}/admin/meetings?courseId=${course.id}"
						class="btn btn-small btn-success">Meetings verwalten</a>
						<button type="button" class="btn btn-small edit-course-btn"
							data-id="${course.id}">Vorlage bearbeiten</button>
						<form action="${pageContext.request.contextPath}/admin/courses"
							method="post" class="js-confirm-form"
							data-confirm-message="Vorlage '${fn:escapeXml(course.name)}' wirklich löschen? Alle zugehörigen Meetings und Qualifikationen werden auch gelöscht!">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${course.id}">
							<button type="submit" class="btn btn-small btn-danger">Löschen</button>
						</form></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<!-- MODAL FOR CREATE/EDIT COURSE -->
<div class="modal-overlay" id="course-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3 id="course-modal-title">Lehrgangs-Vorlage</h3>
		<form id="course-modal-form"
			action="${pageContext.request.contextPath}/admin/courses"
			method="post">
			<input type="hidden" name="action" id="course-modal-action">
			<input type="hidden" name="id" id="course-modal-id">
			<div class="form-group">
				<label for="name-modal">Name der Vorlage (z.B. Grundlehrgang
					Tontechnik)</label> <input type="text" id="name-modal" name="name" required>
			</div>
			<div class="form-group">
				<label for="abbreviation-modal">Abkürzung (für Matrix, max.
					10 Zeichen, z.B. GL-Ton)</label> <input type="text" id="abbreviation-modal"
					name="abbreviation" maxlength="10" required>
			</div>
			<div class="form-group">
				<label for="description-modal">Allgemeine Beschreibung des
					Lehrgangs</label>
				<textarea id="description-modal" name="description" rows="4"></textarea>
			</div>
			<button type="submit" class="btn">Vorlage Speichern</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />
<script>
document.addEventListener('DOMContentLoaded', () => {
    const contextPath = "${'${pageContext.request.contextPath}'}";
    document.querySelectorAll('.js-confirm-form').forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
            showConfirmationModal(message, () => this.submit());
        });
    });

    const modalOverlay = document.getElementById('course-modal');
    const form = document.getElementById('course-modal-form');
    const title = document.getElementById('course-modal-title');
    const actionInput = document.getElementById('course-modal-action');
    const idInput = document.getElementById('course-modal-id');
    const nameInput = document.getElementById('name-modal');
    const abbrInput = document.getElementById('abbreviation-modal');
    const descInput = document.getElementById('description-modal');
    const closeModalBtn = modalOverlay.querySelector('.modal-close-btn');
    
    const closeModal = () => modalOverlay.classList.remove('active');
    
    const openCreateModal = () => {
        form.reset();
        title.textContent = "Neue Lehrgangs-Vorlage anlegen";
        actionInput.value = "create";
        idInput.value = "";
        modalOverlay.classList.add('active');
    };
    
    const openEditModal = async (btn) => {
        form.reset();
        title.textContent = "Lehrgangs-Vorlage bearbeiten";
        actionInput.value = "update";
        const courseId = btn.dataset.id;
        idInput.value = courseId;
        
        try {
            const response = await fetch(`${contextPath}/admin/courses?action=getCourseData&id=${courseId}`);
            if(!response.ok) throw new Error('Could not fetch course data');
            const data = await response.json();

            nameInput.value = data.name || '';
            abbrInput.value = data.abbreviation || '';
            descInput.value = data.description || '';

            modalOverlay.classList.add('active');
        } catch(error) {
            console.error("Failed to open edit modal:", error);
            alert("Fehler beim Laden der Vorlagen-Daten.");
        }
    };
    
    document.getElementById('new-course-btn').addEventListener('click', openCreateModal);
    document.querySelectorAll('.edit-course-btn').forEach(btn => {
        btn.addEventListener('click', () => openEditModal(btn));
    });
    
    closeModalBtn.addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', (e) => {
        if (e.target === modalOverlay) closeModal();
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modalOverlay.classList.contains('active')) closeModal();
    });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_dashboard.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Admin Dashboard" />
	<c:param name="navType" value="admin" />
</c:import>

<h1>
	Willkommen im Admin-Bereich,
	<c:out value="${sessionScope.user.username}" />
	!
</h1>
<p>Hier können Sie die Anwendung verwalten. Wählen Sie eine Option
	aus der Navigation.</p>

<div class="dashboard-grid">
	<div class="card">
		<h2 class="card-title">Schnellzugriff</h2>
		<ul style="list-style: none; padding: 0;">
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/users">Benutzer
					verwalten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/events">Events
					erstellen & bearbeiten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/courses">Lehrgänge
					& Meetings verwalten</a></li>
			<li style="padding: 0.5rem 0;"><a
				href="${pageContext.request.contextPath}/admin/storage">Lager
					verwalten</a></li>
		</ul>
	</div>

	<div class="card">
		<h2 class="card-title">Statistiken</h2>
		<p style="font-size: 1.1rem; margin-bottom: 0.5rem;">
			Anzahl registrierter Benutzer: <strong><c:out
					value="${userCount}" /></strong>
		</p>
		<p style="font-size: 1.1rem;">
			Anzahl aktiver Events: <strong><c:out
					value="${activeEventCount}" /></strong>
		</p>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_defect_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Defekte Artikel" />
</c:import>

<h1>
	<i class="fas fa-wrench"></i> Defekte Artikel verwalten
</h1>
<p>Hier sind alle Artikel gelistet, von denen mindestens ein
	Exemplar als defekt markiert wurde.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-wrapper">
	<table class="data-table">
		<thead>
			<tr>
				<th>Name</th>
				<th>Defekt / Gesamt</th>
				<th>Grund</th>
				<th>Aktion</th>
			</tr>
		</thead>
		<tbody>
			<c:if test="${empty defectiveItems}">
				<tr>
					<td colspan="4" style="text-align: center;">Aktuell sind keine
						Artikel als defekt gemeldet.</td>
				</tr>
			</c:if>
			<c:forEach var="item" items="${defectiveItems}">
				<tr>
					<td><c:out value="${item.name}" /></td>
					<td><c:out value="${item.defectiveQuantity}" /> / <c:out
							value="${item.quantity}" /></td>
					<td><c:out value="${item.defectReason}" /></td>
					<td>
						<button class="btn btn-small btn-success defect-modal-btn"
							data-item-id="${item.id}"
							data-item-name="${fn:escapeXml(item.name)}"
							data-current-defect-qty="${item.defectiveQuantity}"
							data-current-reason="${fn:escapeXml(item.defectReason)}">
							Status bearbeiten</button>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<!-- Modal for updating defect status -->
<div class="modal-overlay" id="defect-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3 id="defect-modal-title">Defekt-Status bearbeiten</h3>
		<form action="${pageContext.request.contextPath}/admin/storage"
			method="post">
			<input type="hidden" name="action" value="updateDefect"> <input
				type="hidden" name="id" id="defect-item-id"> <input
				type="hidden" name="returnTo" value="defects">
			<div class="form-group">
				<label for="defective_quantity">Anzahl defekter Artikel</label> <input
					type="number" name="defective_quantity" id="defective_quantity"
					min="0" required>
			</div>
			<div class="form-group">
				<label for="defect_reason">Grund (optional)</label>
				<textarea name="defect_reason" id="defect_reason" rows="3"></textarea>
			</div>
			<button type="submit" class="btn">Speichern</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />
<script>
document.addEventListener('DOMContentLoaded', () => {
    const defectModal = document.getElementById('defect-modal');
    if (!defectModal) return;

    const modalTitle = document.getElementById('defect-modal-title');
    const itemIdInput = document.getElementById('defect-item-id');
    const defectQtyInput = document.getElementById('defective_quantity');
    const reasonInput = document.getElementById('defect_reason');
    const closeModalBtn = defectModal.querySelector('.modal-close-btn');

    document.querySelectorAll('.defect-modal-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            modalTitle.textContent = `Defekt-Status für "${btn.dataset.itemName}" bearbeiten`;
            itemIdInput.value = btn.dataset.itemId;
            defectQtyInput.value = btn.dataset.currentDefectQty;
            defectQtyInput.max = btn.dataset.maxQty; // Set max based on total quantity
            reasonInput.value = btn.dataset.currentReason;
            defectModal.classList.add('active');
        });
    });

    closeModalBtn.addEventListener('click', () => defectModal.classList.remove('active'));
    defectModal.addEventListener('click', (e) => {
        if (e.target === defectModal) defectModal.classList.remove('active');
    });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_events_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Eventverwaltung" />
	<c:param name="navType" value="admin" />
</c:import>

<h1>Eventverwaltung</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">${sessionScope.successMessage}</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">${sessionScope.errorMessage}</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>
<div class="table-controls">
	<button type="button" class="btn" id="new-event-btn">Neues
		Event anlegen</button>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<c:if test="${empty eventList}">
	<div class="card">
		<p>Es wurden noch keine Events erstellt.</p>
	</div>
</c:if>
<!-- MOBILE LAYOUT: CARD LIST -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="event" items="${eventList}">
		<div class="list-item-card"
			data-searchable-content="${event.name} ${event.status}">
			<h3 class="card-title">${event.name}</h3>
			<div class="card-row">
				<span>Zeitraum:</span> <span>${event.formattedEventDateTimeRange}</span>
			</div>
			<div class="card-row">
				<span>Status:</span> <span>${event.status}</span>
			</div>
			<div class="card-actions">
				<button type="button" class="btn btn-small edit-event-btn"
					data-event-id="${event.id}">Bearbeiten</button>
				<c:if test="${event.status != 'ABGESCHLOSSEN'}">
					<button type="button"
						class="btn btn-small btn-success assign-users-btn"
						data-event-id="${event.id}"
						data-event-name="${fn:escapeXml(event.name)}">Zuweisen</button>
					<c:if
						test="${event.status == 'GEPLANT' || event.status == 'KOMPLETT'}">
						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="updateStatus">
							<input type="hidden" name="id" value="${event.id}"> <input
								type="hidden" name="newStatus" value="LAUFEND">
							<button type="submit" class="btn btn-small"
								style="background-color: orange;">Starten</button>
						</form>
					</c:if>
					<c:if test="${event.status == 'LAUFEND'}">
						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" style="display: inline;">
							<input type="hidden" name="action" value="updateStatus">
							<input type="hidden" name="id" value="${event.id}"> <input
								type="hidden" name="newStatus" value="ABGESCHLOSSEN">
							<button type="submit" class="btn btn-small"
								style="background-color: var(--text-muted-color);">Abschließen</button>
						</form>
					</c:if>
				</c:if>

				<form action="${pageContext.request.contextPath}/admin/events"
					method="post" class="inline-form js-confirm-form"
					data-confirm-message="Soll das Event '${fn:escapeXml(event.name)}' wirklich endgültig gelöscht werden?">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="id" value="${event.id}">
					<button type="submit" class="btn btn-small btn-danger">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>
<!-- DESKTOP LAYOUT: TABLE -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name</th>
				<th class="sortable" data-sort-type="string">Zeitraum</th>
				<th class="sortable" data-sort-type="string">Status</th>
				<th style="width: 450px;">Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="event" items="${eventList}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/eventDetails?id=${event.id}">${event.name}</a></td>
					<td>${event.formattedEventDateTimeRange}</td>
					<td>${event.status}</td>
					<td style="display: flex; gap: 5px; flex-wrap: wrap;">
						<button type="button" class="btn btn-small edit-event-btn"
							data-event-id="${event.id}">Bearbeiten</button> <c:if
							test="${event.status != 'ABGESCHLOSSEN'}">
							<button type="button"
								class="btn btn-small btn-success assign-users-btn"
								data-event-id="${event.id}"
								data-event-name="${fn:escapeXml(event.name)}">Zuweisen</button>
							<c:if
								test="${event.status == 'GEPLANT' || event.status == 'KOMPLETT'}">
								<form action="${pageContext.request.contextPath}/admin/events"
									method="post" style="display: inline;">
									<input type="hidden" name="action" value="updateStatus">
									<input type="hidden" name="id" value="${event.id}"> <input
										type="hidden" name="newStatus" value="LAUFEND">
									<button type="submit" class="btn btn-small"
										style="background-color: orange;">Starten</button>
								</form>
							</c:if>
							<c:if test="${event.status == 'LAUFEND'}">
								<form action="${pageContext.request.contextPath}/admin/events"
									method="post" style="display: inline;">
									<input type="hidden" name="action" value="updateStatus">
									<input type="hidden" name="id" value="${event.id}"> <input
										type="hidden" name="newStatus" value="ABGESCHLOSSEN">
									<button type="submit" class="btn btn-small"
										style="background-color: var(--text-muted-color);">Abschließen</button>
								</form>
							</c:if>
						</c:if>
						<form action="${pageContext.request.contextPath}/admin/events"
							method="post" class="inline-form js-confirm-form"
							data-confirm-message="Soll das Event '${fn:escapeXml(event.name)}' wirklich endgültig gelöscht werden?">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${event.id}">
							<button type="submit" class="btn btn-small btn-danger">Löschen</button>
						</form>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<!-- All modals are now at the bottom of the page -->
<%@ include file="/WEB-INF/jspf/event_modals.jspf"%>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />
<style>
.dynamic-row {
	display: flex;
	gap: 10px;
	margin-bottom: 10px;
	align-items: center;
}

.dynamic-row select {
	flex-grow: 1;
}

.dynamic-row input {
	max-width: 100px;
}

.inline-form {
	display: inline;
}

.user-checkbox-list {
	display: flex;
	flex-direction: column;
	gap: 0.75rem;
	max-height: 300px;
	overflow-y: auto;
	padding: 0.5rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
}

.checkbox-label {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	font-size: 1.1rem;
	cursor: pointer;
}
</style>
<script>
document.addEventListener('DOMContentLoaded', () => {
	const contextPath = "${'${pageContext.request.contextPath}'}";
	document.querySelectorAll('.js-confirm-form').forEach(form => {
		form.addEventListener('submit', function(e) {
			e.preventDefault();
			showConfirmationModal(this.dataset.confirmMessage || 'Sind Sie sicher?', () => this.submit());
		});
	});

	// --- Assign Users Modal Logic ---
	const assignModal = document.getElementById('assign-users-modal');
	const assignForm = document.getElementById('assign-users-form');
	const assignModalTitle = document.getElementById('assign-users-modal-title');
	const assignCheckboxes = document.getElementById('user-checkboxes-container');
	const assignEventIdInput = assignForm.querySelector('input[name="eventId"]');

	const openAssignModal = async (btn) => {
		const eventId = btn.dataset.eventId;
		const eventName = btn.dataset.eventName;
		assignModalTitle.textContent = `Team für "${eventName}" zuweisen`;
		assignEventIdInput.value = eventId;
		assignCheckboxes.innerHTML = '<p>Lade Benutzer...</p>';
		assignModal.classList.add('active');

		try {
			const response = await fetch(`${contextPath}/admin/events?action=getAssignmentData&id=${eventId}`);
			if (!response.ok) throw new Error('Could not fetch assignment data.');
			const data = await response.json();
			
			assignCheckboxes.innerHTML = '';
			if(data.signedUpUsers && data.signedUpUsers.length > 0) {
				data.signedUpUsers.forEach(user => {
					const isChecked = data.assignedUserIds.includes(user.id) ? 'checked' : '';
					assignCheckboxes.innerHTML += `
						<label class="checkbox-label">
							<input type="checkbox" name="userIds" value="${user.id}" ${isChecked} style="width: auto; height: 1.2rem;">
							${user.username}
						</label>`;
				});
			} else {
				assignCheckboxes.innerHTML = '<p>Es haben sich noch keine Benutzer für dieses Event angemeldet.</p>';
			}
		} catch (error) {
			assignCheckboxes.innerHTML = '<p class="error-message">Fehler beim Laden der Benutzerdaten.</p>';
			console.error('Error fetching assignment data:', error);
		}
	};
	document.querySelectorAll('.assign-users-btn').forEach(btn => btn.addEventListener('click', () => openAssignModal(btn)));
	assignModal.querySelector('.modal-close-btn').addEventListener('click', () => assignModal.classList.remove('active'));


	// --- Edit/Create Event Modal Logic ---
	const eventModal = document.getElementById('event-modal');
	const eventForm = document.getElementById('event-modal-form');
	const eventModalTitle = document.getElementById('event-modal-title');
	const actionInput = document.getElementById('event-modal-action');
	const idInput = document.getElementById('event-modal-id');
	const reqContainer = document.getElementById('modal-requirements-container');
	const resContainer = document.getElementById('modal-reservations-container');
	const attachmentsList = document.getElementById('modal-attachments-list');

	const allCourses = [<c:forEach var="c" items="${allCourses}">{id: ${c.id}, name: "${fn:escapeXml(c.name)}"},</c:forEach>];
	const allItems = [<c:forEach var="i" items="${allItems}">{id: ${i.id}, name: "${fn:escapeXml(i.name)} (verfügbar: ${i.quantity})"},</c:forEach>];

	const openEventModal = () => eventModal.classList.add('active');
	const closeEventModal = () => eventModal.classList.remove('active');

	eventModal.querySelector('.modal-close-btn').addEventListener('click', closeEventModal);
	eventModal.addEventListener('click', e => { if (e.target === eventModal) closeEventModal(); });

	const resetEventModal = () => {
		eventForm.reset();
		reqContainer.innerHTML = ''; 
		resContainer.innerHTML = '';
		attachmentsList.innerHTML = '';
	};

	document.getElementById('new-event-btn').addEventListener('click', () => {
		resetEventModal();
		eventModalTitle.textContent = "Neues Event anlegen";
		actionInput.value = "create";
		idInput.value = "";
		openEventModal();
	});

	document.querySelectorAll('.edit-event-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			const eventId = btn.dataset.eventId;
			try {
				const response = await fetch(`${contextPath}/admin/events?action=getEventData&id=${eventId}`);
				if (!response.ok) throw new Error('Event data could not be fetched.');
				const event = await response.json();
				resetEventModal();
				eventModalTitle.textContent = "Event bearbeiten";
				actionInput.value = "update";
				idInput.value = event.id;
				eventForm.querySelector('#name-modal').value = event.name || '';
				eventForm.querySelector('#location-modal').value = event.location || '';
				eventForm.querySelector('#leaderUserId-modal').value = event.leaderUserId || '';
				eventForm.querySelector('#eventDateTime-modal').value = event.eventDateTime ? event.eventDateTime.substring(0, 16) : '';
				eventForm.querySelector('#endDateTime-modal').value = event.endDateTime ? event.endDateTime.substring(0, 16) : '';
				eventForm.querySelector('#description-modal').value = event.description || '';
				event.skillRequirements?.forEach(req => addRequirementRow(req.requiredCourseId, req.requiredPersons));
				event.reservedItems?.forEach(res => addReservationRow(res.id, res.quantity));
				event.attachments?.forEach(att => addAttachmentRow(att.id, att.filename, att.filepath));
				openEventModal();
			} catch (error) {
				console.error('Error opening edit modal:', error);
				alert('Fehler beim Laden der Event-Daten.');
			}
		});
	});
	
	const createRow = (container) => {
		const newRow = document.createElement('div'); newRow.className = 'dynamic-row';
		const removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.className = 'btn-small btn-danger';
		removeBtn.innerHTML = '×'; removeBtn.onclick = () => newRow.remove();
		newRow.appendChild(removeBtn); container.appendChild(newRow);
		return newRow;
	};

	const addRequirementRow = (courseId = '', personCount = 1) => {
		const row = createRow(reqContainer);
		const select = document.createElement('select'); select.name = 'requiredCourseId';
		select.innerHTML = '<option value="">-- Lehrgang --</option>' + allCourses.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
		select.value = courseId;
		const input = document.createElement('input'); input.type = 'number'; input.name = 'requiredPersons'; input.value = personCount; input.min = '1';
		row.prepend(select, input);
	};
	document.getElementById('modal-add-requirement-btn').addEventListener('click', () => addRequirementRow());

	const addReservationRow = (itemId = '', quantity = 1) => {
		const row = createRow(resContainer);
		const select = document.createElement('select'); select.name = 'itemId';
		select.innerHTML = '<option value="">-- Material --</option>' + allItems.map(i => `<option value="${i.id}">${i.name}</option>`).join('');
		select.value = itemId;
		const input = document.createElement('input'); input.type = 'number'; input.name = 'itemQuantity'; input.value = quantity; input.min = '1';
		row.prepend(select, input);
	};
	document.getElementById('modal-add-reservation-btn').addEventListener('click', () => addReservationRow());
	
	const addAttachmentRow = (id, filename, filepath) => {
        const li = document.createElement('li'); li.id = `attachment-item-${id}`;
        li.innerHTML = `<a href="${contextPath}/download?file=${filepath}" target="_blank">${filename}</a>`;
        const removeBtn = document.createElement('button'); removeBtn.type = 'button'; removeBtn.className = 'btn btn-small btn-danger-outline';
        removeBtn.innerHTML = '×';
        removeBtn.onclick = () => {
            showConfirmationModal(`Anhang '${filename}' wirklich löschen?`, async () => {
                const formData = new FormData();
                formData.append('action', 'deleteAttachment');
                formData.append('id', id);
                const response = await fetch(`${contextPath}/admin/events`, { method: 'POST', body: formData });
                if (response.ok) li.remove();
                else alert('Fehler beim Löschen des Anhangs.');
            });
        };
        li.appendChild(removeBtn); attachmentsList.appendChild(li);
    };
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_files.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Datei- & Kategorienverwaltung"/>
</c:import>

<h1><i class="fas fa-folder-open"></i> Datei- & Kategorienverwaltung</h1>
<p>Verwalten Sie hier alle hochgeladenen Dateien und deren
	Kategorien.</p>

<c:if test="${not empty sessionScope.successMessage}"><p class="success-message"><i class="fas fa-check-circle"></i><c:out value="${sessionScope.successMessage}" /></p><c:remove var="successMessage" scope="session" /></c:if>
<c:if test="${not empty sessionScope.errorMessage}"><p class="error-message"><i class="fas fa-exclamation-triangle"></i><c:out value="${sessionScope.errorMessage}" /></p><c:remove var="errorMessage" scope="session" /></c:if>

<div class="file-manager-layout">
	<div class="card file-manager-categories">
		<h2>Kategorien</h2>
		<ul class="category-list">
			<c:forEach var="cat" items="${allCategories}">
				<li data-category-id="${cat.id}"><i class="fas fa-folder"></i>
					<c:out value="${cat.name}" /></li>
			</c:forEach>
		</ul>
		<hr>
		<h4 style="margin-top: 1rem;">Kategorie-Aktionen</h4>
		<form action="<c:url value='/admin/categories/create'/>" method="post">
			<div class="form-group">
				<label for="newCategoryName">Neue Kategorie erstellen</label> <input
					type="text" name="categoryName" id="newCategoryName" required>
			</div>
			<button type="submit" class="btn"><i class="fas fa-plus"></i> Erstellen</button>
		</form>
	</div>
	<div class="file-manager-content">
		<div id="section-placeholder" class="card" style="text-align: center; padding: 3rem; border-style: dashed;">
			<i class="fas fa-arrow-left fa-2x" style="color: var(--text-muted-color); margin-bottom: 1rem;"></i>
			<p style="font-size: 1.2rem; color: var(--text-muted-color);">Bitte
				wählen Sie links eine Kategorie aus.</p>
		</div>
		<div id="dynamic-content-area"></div>
	</div>
</div>

<template id="category-section-template">
	<div class="file-category-section">
		<div class="card">
			<h2><i class="fas fa-file-alt"></i> Dateien in "<span class="category-name"></span>"</h2>
			<ul class="file-list"></ul>
		</div>
		<div class="card">
			<h2><i class="fas fa-upload"></i> Datei zu "<span class="category-name"></span>" hochladen</h2>
			<form action="<c:url value='/admin/files'/>" method="post" enctype="multipart/form-data">
				<input type="hidden" name="categoryId" class="category-id-input">
				<div class="form-group"><label>Datei auswählen</label><input type="file" name="file" class="file-input" data-max-size="20971520" required><small class="file-size-warning" style="color: red; display: none;">Datei ist zu groß! (Max. 20 MB)</small></div>
				<div class="form-group"><label>Sichtbar für</label><select name="requiredRole"><option value="NUTZER" selected>Alle Nutzer</option><option value="ADMIN">Nur Admins</option></select></div>
				<button type="submit" class="btn"><i class="fas fa-cloud-upload-alt"></i> Hochladen</button>
			</form>
		</div>
		<div class="card">
			<h2><i class="fas fa-edit"></i> Kategorie "<span class="category-name"></span>" verwalten</h2>
			<div class="category-actions-grid">
				<form action="<c:url value='/admin/categories/update'/>" method="post" class="category-action-form">
					<input type="hidden" name="categoryId" class="category-id-input">
					<div class="form-group"><label>Umbenennen</label><input type="text" name="categoryName" class="category-name-input" required></div>
					<button type="submit" class="btn btn-small"><i class="fas fa-save"></i> Umbenennen</button>
				</form>
				<form action="<c:url value='/admin/categories/delete'/>" method="post" class="category-action-form js-confirm-form" data-confirm-message="Kategorie wirklich löschen? Zugehörige Dateien verlieren ihre Kategoriezuordnung.">
					<input type="hidden" name="categoryId" class="category-id-input">
					<div class="form-group"><label>Löschen</label><p><small>Zugehörige Dateien verlieren ihre Kategoriezuordnung.</small></p></div>
					<button type="submit" class="btn btn-small btn-danger"><i class="fas fa-trash-alt"></i> Endgültig Löschen</button>
				</form>
			</div>
		</div>
	</div>
</template>

<template id="file-item-template">
	<li>
		<div class="file-info">
			<a href="#" class="file-download-link" title="Datei herunterladen"></a>
			<small class="file-meta"></small>
		</div>
		<form action="<c:url value='/admin/files'/>" method="post" class="js-confirm-form" data-confirm-message="Datei wirklich löschen?">
			<input type="hidden" name="action" value="delete"><input type="hidden" name="fileId" class="file-id-input">
			<button type="submit" class="btn btn-small btn-danger-outline" title="Löschen"><i class="fas fa-trash-alt"></i></button>
		</form>
	</li>
</template>

<c:import url="/WEB-INF/jspf/footer.jspf" />
<style>
.file-manager-layout {
	display: flex;
	flex-direction: column;
	gap: 1.5rem;
	align-items: stretch;
}

ul.category-list {
	list-style: none;
	padding: 0;
	margin: 0 0 1rem 0;
}

ul.category-list li {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0.75rem 1rem;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s ease-in-out;
	border: 1px solid var(--border-color);
	margin-bottom: 0.5rem;
}

ul.category-list li:hover {
	background-color: var(--primary-color-light);
	border-color: var(--primary-color);
	color: var(--primary-color);
}

ul.category-list li.active {
	background-color: var(--primary-color);
	color: #fff;
	border-color: var(--primary-color);
}

ul.file-list {
	list-style: none;
	padding: 0;
}

ul.file-list li {
	display: flex;
	justify-content: space-between;
	align-items: center;
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	gap: 1rem;
}

ul.file-list li:last-child {
	border-bottom: none;
}

.file-info {
	flex-grow: 1;
	min-width: 0;
}

.file-info a {
	font-weight: 500;
	word-break: break-all;
}

.file-meta {
	color: var(--text-muted-color);
	display: block;
	font-size: 0.9em;
}

.category-actions-grid {
	display: flex;
	flex-direction: column;
	gap: 1.5rem;
}

@media ( min-width : 992px) {
	.file-manager-layout {
		display: grid;
		grid-template-columns: 320px 1fr;
		flex-direction: row;
		align-items: flex-start;
	}
	.category-actions-grid {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 1rem;
		align-items: end;
	}
}
</style>
<script>
document.addEventListener('DOMContentLoaded', () => {
    // Data from JSP to JS
    const groupedFiles = {
        <c:forEach var="entry" items="${groupedFiles}" varStatus="status">
            "<c:out value="${entry.key}"/>": [
                <c:forEach var="file" items="${entry.value}" varStatus="fileStatus">
                    { id: ${file.id}, filename: "${fn:replace(file.filename, '"', '\\"')}", filepath: "${fn:replace(file.filepath, '"', '\\"')}", requiredRole: "${file.requiredRole}" }
                    ${!fileStatus.last ? ',' : ''}
                </c:forEach>
            ]
            ${!status.last ? ',' : ''}
        </c:forEach>
    };

    const allCategories = [
        <c:forEach var="cat" items="${allCategories}" varStatus="status">
            { id: ${cat.id}, name: "${fn:replace(cat.name, '"', '\\"')}" }
            ${!status.last ? ',' : ''}
        </c:forEach>
    ];

    const categoryListItems = document.querySelectorAll('.category-list li');
    const dynamicContentArea = document.getElementById('dynamic-content-area');
    const placeholder = document.getElementById('section-placeholder');
    const sectionTemplate = document.getElementById('category-section-template');
    const fileItemTemplate = document.getElementById('file-item-template');
    const contextPath = "${pageContext.request.contextPath}";

    const switchCategoryView = (categoryId) => {
        dynamicContentArea.innerHTML = '';
        placeholder.style.display = 'none';
        categoryListItems.forEach(item => item.classList.remove('active'));

        if (!categoryId) {
            placeholder.style.display = 'block';
            return;
        }

        const category = allCategories.find(c => c.id == categoryId);
        if (!category) return;

        // Activate the selected category list item
        const activeLi = document.querySelector(`.category-list li[data-category-id='${categoryId}']`);
        if(activeLi) activeLi.classList.add('active');

        // Clone and populate the main section template
        const sectionClone = sectionTemplate.content.cloneNode(true);
        sectionClone.querySelectorAll('.category-name').forEach(el => el.textContent = category.name);
        sectionClone.querySelectorAll('.category-id-input').forEach(el => el.value = category.id);
        sectionClone.querySelector('.category-name-input').value = category.name;

        // Populate the file list
        const fileList = sectionClone.querySelector('.file-list');
        const filesForCategory = groupedFiles[category.name] || [];

        if (filesForCategory.length > 0) {
            filesForCategory.forEach(file => {
                const fileItemClone = fileItemTemplate.content.cloneNode(true);
                const downloadLink = fileItemClone.querySelector('.file-download-link');
                // CORRECTED LINE: Use standard string concatenation to avoid EL conflict
                downloadLink.href = contextPath + '/download?file=' + encodeURIComponent(file.filepath);
                downloadLink.textContent = file.filename;
                fileItemClone.querySelector('.file-meta').textContent = `(Sichtbar für: ${file.requiredRole})`;
                fileItemClone.querySelector('.file-id-input').value = file.id;
                
                const fileForm = fileItemClone.querySelector('form');
                fileForm.dataset.confirmMessage = `Datei '${file.filename}' wirklich löschen?`;
                fileForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    showConfirmationModal(this.dataset.confirmMessage, () => this.submit());
                });
                
                fileList.appendChild(fileItemClone);
            });
        } else {
            fileList.innerHTML = '<li style="justify-content: center; color: var(--text-muted-color);">Keine Dateien in dieser Kategorie.</li>';
        }

        dynamicContentArea.appendChild(sectionClone);
        
        // Re-attach file size validation and confirmation to the newly added forms
        attachFileSizeValidator(dynamicContentArea.querySelector('.file-input'));
        dynamicContentArea.querySelectorAll('.js-confirm-form').forEach(form => {
             form.addEventListener('submit', function(e) {
                e.preventDefault();
                showConfirmationModal(this.dataset.confirmMessage, () => this.submit());
            });
        });
    };
    
    const attachFileSizeValidator = (input) => {
        if (!input) return;
        input.addEventListener('change', (e) => {
            const file = e.target.files[0];
            const maxSize = parseInt(e.target.dataset.maxSize, 10);
            const warningElement = e.target.nextElementSibling;
            if (file && file.size > maxSize) {
                warningElement.style.display = 'block';
                e.target.value = '';
            } else {
                warningElement.style.display = 'none';
            }
        });
    };

    categoryListItems.forEach(item => {
        item.addEventListener('click', () => {
            switchCategoryView(item.dataset.categoryId);
        });
    });
    
    // Initial view
    switchCategoryView(null);
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_log.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Admin Log" />
	<c:param name="navType" value="admin" />
</c:import>

<h1>Admin Aktions-Protokoll</h1>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter"
			placeholder="Nach Details, Name oder Aktion filtern..."
			style="width: 100%;" aria-label="Protokoll filtern">
	</div>
</div>

<div class="table-wrapper">
	<table class="data-table searchable-table">
		<thead>
			<tr>
				<th>Wann</th>
				<th>Wer</th>
				<th>Aktionstyp</th>
				<th>Details</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="log" items="${logs}">
				<tr>
					<td><c:out value="${log.formattedActionTimestamp}" /> Uhr</td>
					<td><c:out value="${log.adminUsername}" /></td>
					<td><c:out value="${log.actionType}" /></td>
					<td><c:out value="${log.details}" /></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_matrix.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Qualifikations-Matrix" />
	<c:param name="navType" value="admin" />
</c:import>

<h1>
	<i class="fas fa-th-list"></i> Qualifikations-Matrix (Modular)
</h1>
<p>Klicken Sie auf eine Zelle, um die Teilnahme an einem Meeting zu
	bearbeiten.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i> ${sessionScope.successMessage}
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		${sessionScope.errorMessage}
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-wrapper">
	<table class="data-table">
		<thead>
			<tr>
				<th rowspan="2"
					style="vertical-align: middle; position: sticky; left: 0; z-index: 10; background-color: var(--surface-color);">Nutzer
					/ Lehrgang ↓</th>
				<c:forEach var="course" items="${allCourses}">
					<th colspan="${meetingsByCourse[course.id].size()}"
						style="text-align: center;"><a
						href="${pageContext.request.contextPath}/admin/courses?action=edit&id=${course.id}"
						title="Vorlage '${course.name}' bearbeiten">${course.abbreviation}</a>
					</th>
				</c:forEach>
			</tr>
			<tr>
				<c:forEach var="course" items="${allCourses}">
					<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
						<th style="text-align: center;"><a
							href="${pageContext.request.contextPath}/admin/meetings?action=edit&courseId=${course.id}&meetingId=${meeting.id}"
							title="Meeting '${meeting.name}' bearbeiten">${meeting.name}</a>
						</th>
					</c:forEach>
				</c:forEach>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="user" items="${allUsers}">
				<tr>
					<td
						style="font-weight: 500; position: sticky; left: 0; background-color: var(--surface-color); z-index: 5;">
						<a
						href="${pageContext.request.contextPath}/admin/users?action=details&id=${user.id}">${user.username}</a>
					</td>
					<c:forEach var="course" items="${allCourses}">
						<c:forEach var="meeting" items="${meetingsByCourse[course.id]}">
							<c:set var="attendanceKey" value="${user.id}-${meeting.id}" />
							<c:set var="attendance" value="${attendanceMap[attendanceKey]}" />
							<td class="qual-cell" data-user-id="${user.id}"
								data-user-name="${user.username}"
								data-meeting-id="${meeting.id}"
								data-meeting-name="${course.name} - ${meeting.name}"
								data-attended="${not empty attendance && attendance.attended}"
								data-remarks="${not empty attendance ? attendance.remarks : ''}"
								style="text-align: center; font-weight: bold; cursor: pointer;"
								title="Klicken zum Bearbeiten"><c:if
									test="${not empty attendance && attendance.attended}">
									<span style="color: var(--success-color);">✔</span>
								</c:if> <c:if test="${empty attendance || !attendance.attended}">-</c:if>
							</td>
						</c:forEach>
					</c:forEach>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<!-- MODAL HTML STRUCTURE -->
<div class="modal-overlay" id="attendance-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3>Teilnahme bearbeiten</h3>
		<p id="modal-title" style="font-weight: bold; margin-bottom: 1rem;"></p>
		<form action="${pageContext.request.contextPath}/admin/attendance"
			method="post">
			<input type="hidden" name="returnTo" value="matrix"> <input
				type="hidden" name="userId" id="modal-user-id"> <input
				type="hidden" name="meetingId" id="modal-meeting-id">
			<div class="form-group"
				style="display: flex; align-items: center; gap: 1rem;">
				<label for="modal-attended" style="margin-bottom: 0;">Teilgenommen:</label>
				<input type="checkbox" id="modal-attended" name="attended"
					value="true" style="width: auto; height: 1.5rem;">
			</div>
			<div class="form-group">
				<label for="modal-remarks">Bemerkungen:</label>
				<textarea name="remarks" id="modal-remarks" rows="3"></textarea>
			</div>
			<button type="submit" class="btn">
				<i class="fas fa-save"></i> Speichern
			</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    const modalOverlay = document.getElementById('attendance-modal');
    if (!modalOverlay) return;
    
    const modalTitle = document.getElementById('modal-title');
    const modalUserId = document.getElementById('modal-user-id');
    const modalMeetingId = document.getElementById('modal-meeting-id');
    const modalAttended = document.getElementById('modal-attended');
    const modalRemarks = document.getElementById('modal-remarks');
    const closeBtn = modalOverlay.querySelector('.modal-close-btn');

    const openModal = (cell) => {
        const userData = cell.dataset;
        modalTitle.textContent = `Nutzer: ${userData.userName} | Meeting: ${userData.meetingName}`;
        modalUserId.value = userData.userId;
        modalMeetingId.value = userData.meetingId;
        modalRemarks.value = userData.remarks;
        modalAttended.checked = (userData.attended === 'true');
        modalOverlay.classList.add('active');
    };

    const closeModal = () => modalOverlay.classList.remove('active');

    document.querySelectorAll('.qual-cell').forEach(cell => {
        cell.addEventListener('click', () => openModal(cell));
    });

    if (closeBtn) closeBtn.addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', (event) => { if (event.target === modalOverlay) closeModal(); });
    document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && modalOverlay.classList.contains('active')) closeModal(); });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_meeting_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<%--
admin_meeting_list.jsp

This JSP displays a list of meetings for a specific parent course. An admin
can edit or delete each meeting. Creating and editing meetings is now handled via modals.

    It is served by: AdminMeetingServlet (doGet).

    Expected attributes:
        'parentCourse' (de.technikteam.model.Course): The course whose meetings are being listed.
        'meetings' (List<de.technikteam.model.Meeting>): The list of meetings for this course.
        'allUsers' (List<de.technikteam.model.User>): For the leader dropdown in the modal.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Meetings für ${parentCourse.name}" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />
<h1>
	Meetings für "
	<c:out value="${parentCourse.name}" />
	"
</h1>
<a href="${pageContext.request.contextPath}/admin/courses"
	style="margin-bottom: 1rem; display: inline-block;"> « Zurück zu
	allen Vorlagen </a>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>
<div class="table-controls">
	<button type="button" class="btn" id="new-meeting-btn">Neues
		Meeting planen</button>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<c:if test="${empty meetings}">
	<div class="card">
		<p>Für diesen Lehrgang wurden noch keine Meetings geplant.</p>
	</div>
</c:if>
<!-- MOBILE LAYOUT -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="meeting" items="${meetings}">
		<div class="list-item-card"
			data-searchable-content="<c:out value='${meeting.name}'/> <c:out value='${meeting.leaderUsername}'/>">
			<h3 class="card-title">
				<c:out value="${meeting.name}" />
			</h3>
			<div class="card-row">
				<span>Datum:</span> <span><c:out
						value="${meeting.formattedMeetingDateTimeRange}" /></span>
			</div>
			<div class="card-row">
				<span>Leitung:</span> <span><c:out
						value="${empty meeting.leaderUsername ? 'N/A' : meeting.leaderUsername}" /></span>
			</div>
			<div class="card-actions">
				<button type="button" class="btn btn-small edit-meeting-btn"
					data-meeting-id="${meeting.id}">Bearbeiten</button>
				<form action="${pageContext.request.contextPath}/admin/meetings"
					method="post" class="inline-form js-confirm-form"
					data-confirm-message="Meeting '${fn:escapeXml(meeting.name)}' wirklich löschen?">
					<input type="hidden" name="action" value="delete"> <input
						type="hidden" name="courseId" value="${parentCourse.id}">
					<input type="hidden" name="meetingId" value="${meeting.id}">
					<button type="submit" class="btn btn-small btn-danger">Löschen</button>
				</form>
			</div>
		</div>
	</c:forEach>
</div>
<!-- DESKTOP LAYOUT -->
<div class="desktop-table-wrapper">
	<table class="desktop-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Meeting-Name</th>
				<th class="sortable" data-sort-type="string">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Leitung</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="meeting" items="${meetings}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}"><c:out
								value="${meeting.name}" /></a></td>
					<td><c:out value="${meeting.formattedMeetingDateTimeRange}" /></td>
					<td><c:out
							value="${empty meeting.leaderUsername ? 'N/A' : meeting.leaderUsername}" /></td>
					<td style="display: flex; gap: 0.5rem;">
						<button type="button" class="btn btn-small edit-meeting-btn"
							data-meeting-id="${meeting.id}">Bearbeiten & Anhänge</button>
						<form action="${pageContext.request.contextPath}/admin/meetings"
							method="post" class="inline-form js-confirm-form"
							data-confirm-message="Meeting '${fn:escapeXml(meeting.name)}' wirklich löschen?">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="courseId" value="${parentCourse.id}">
							<input type="hidden" name="meetingId" value="${meeting.id}">
							<button type="submit" class="btn btn-small btn-danger">Löschen</button>
						</form>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>
<!-- MODAL FOR CREATE/EDIT MEETING -->
<div class="modal-overlay" id="meeting-modal">
	<div class="modal-content" style="max-width: 700px;">
		<button class="modal-close-btn">×</button>
		<h3 id="meeting-modal-title">Meeting</h3>
		<form id="meeting-modal-form"
			action="${pageContext.request.contextPath}/admin/meetings"
			method="post" enctype="multipart/form-data">

			<input type="hidden" name="action" id="meeting-action"> <input
				type="hidden" name="courseId" value="${parentCourse.id}"> <input
				type="hidden" name="id" id="meeting-id">

			<div class="form-group">
				<label for="name-modal">Name des Meetings (z.B. Teil 1)</label> <input
					type="text" id="name-modal" name="name" required>
			</div>
			<div class="responsive-form-grid">
				<div class="form-group">
					<label for="meetingDateTime-modal">Beginn</label> <input
						type="datetime-local" id="meetingDateTime-modal"
						name="meetingDateTime" required>
				</div>
				<div class="form-group">
					<label for="endDateTime-modal">Ende (optional)</label> <input
						type="datetime-local" id="endDateTime-modal" name="endDateTime">
				</div>
			</div>
			<div class="responsive-form-grid">
				<div class="form-group">
					<label for="location-modal">Ort</label> <input type="text"
						id="location-modal" name="location">
				</div>
				<div class="form-group">
					<label for="leader-modal">Leitende Person</label> <select
						name="leaderUserId" id="leader-modal">
						<option value="">(Keine)</option>
						<c:forEach var="user" items="${allUsers}">
							<option value="${user.id}"><c:out
									value="${user.username}" /></option>
						</c:forEach>
					</select>
				</div>
			</div>
			<div class="form-group">
				<label for="description-modal">Beschreibung</label>
				<textarea id="description-modal" name="description" rows="3"></textarea>
			</div>

			<div class="card"
				style="margin-top: 1rem; padding: 1rem; background-color: var(--bg-color);">
				<h4 class="card-title" style="border: none; padding: 0;">Anhänge</h4>
				<ul id="modal-attachments-list" class="details-list"
					style="margin-bottom: 1rem;"></ul>
				<div class="form-group">
					<label for="attachment-modal">Neuen Anhang hochladen</label> <input
						type="file" name="attachment" id="attachment-modal"
						class="file-input" data-max-size="20971520"> <small
						class="file-size-warning" style="color: red; display: none;">Datei
						ist zu groß! (Max. 20 MB)</small>
				</div>
				<div class="form-group">
					<label for="requiredRole-modal">Sichtbar für</label> <select
						name="requiredRole" id="requiredRole-modal">
						<option value="NUTZER" selected>Alle Nutzer</option>
						<option value="ADMIN">Nur Admins</option>
					</select>
				</div>
			</div>
			<button type="submit" class="btn" style="margin-top: 1.5rem;">Speichern</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />
<script>
document.addEventListener('DOMContentLoaded', () => {
	const contextPath = "${pageContext.request.contextPath}";
    // Custom confirmation for delete forms
    document.querySelectorAll('.js-confirm-form').forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
            showConfirmationModal(message, () => this.submit());
        });
    });

    // Modal Logic
    const modal = document.getElementById('meeting-modal');
    if (!modal) return;

    const form = document.getElementById('meeting-modal-form');
    const modalTitle = document.getElementById('meeting-modal-title');
    const actionInput = document.getElementById('meeting-action');
    const idInput = document.getElementById('meeting-id');
    const attachmentsList = document.getElementById('modal-attachments-list');
    const closeModalBtn = modal.querySelector('.modal-close-btn');

    const openModal = () => modal.classList.add('active');
    const closeModal = () => modal.classList.remove('active');

    const resetModal = () => {
        form.reset();
        attachmentsList.innerHTML = '';
    };

    // Open "Create" Modal
    document.getElementById('new-meeting-btn').addEventListener('click', () => {
        resetModal();
        modalTitle.textContent = "Neues Meeting planen";
        actionInput.value = "create";
        idInput.value = "";
        openModal();
    });

    // Open "Edit" Modal
    document.querySelectorAll('.edit-meeting-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
            const meetingId = btn.dataset.meetingId;
            try {
                const response = await fetch(`${contextPath}/admin/meetings?action=getMeetingData&id=${meetingId}`);
                if (!response.ok) throw new Error('Meeting data could not be fetched.');
                const data = await response.json();
                const meeting = data.meetingData;
                const attachments = data.attachmentsData;

                resetModal();
                modalTitle.textContent = "Meeting bearbeiten";
                actionInput.value = "update";
                idInput.value = meeting.id;
                form.querySelector('#name-modal').value = meeting.name || '';
                form.querySelector('#location-modal').value = meeting.location || '';
                form.querySelector('#meetingDateTime-modal').value = meeting.meetingDateTime ? meeting.meetingDateTime.substring(0, 16) : '';
                form.querySelector('#endDateTime-modal').value = meeting.endDateTime ? meeting.endDateTime.substring(0, 16) : '';
                form.querySelector('#leader-modal').value = meeting.leaderUserId || '';
                form.querySelector('#description-modal').value = meeting.description || '';

                if (attachments && attachments.length > 0) {
                    attachments.forEach(att => addAttachmentRow(att, meeting.courseId));
                } else {
                    attachmentsList.innerHTML = '<li>Keine Anhänge vorhanden.</li>';
                }

                openModal();
            } catch (error) {
                console.error('Error fetching meeting data:', error);
                alert('Fehler beim Laden der Meeting-Daten.');
            }
        });
    });
	
	const addAttachmentRow = (attachment, courseId) => {
		const li = document.createElement('li');
		li.id = `attachment-item-${attachment.id}`;
		li.innerHTML = `<a href="${contextPath}/download?file=${attachment.filepath}" target="_blank">${attachment.filename}</a> (Rolle: ${attachment.requiredRole})`;
		const removeBtn = document.createElement('button');
		removeBtn.type = 'button';
		removeBtn.className = 'btn btn-small btn-danger-outline';
		removeBtn.innerHTML = '&times;';
		removeBtn.onclick = () => {
			showConfirmationModal(`Anhang '${attachment.filename}' wirklich löschen?`, () => {
				const deleteForm = document.createElement('form');
				deleteForm.method = 'post';
				deleteForm.action = `${contextPath}/admin/meetings`;
				deleteForm.innerHTML = `
					<input type="hidden" name="action" value="deleteAttachment">
					<input type="hidden" name="attachmentId" value="${attachment.id}">
					<input type="hidden" name="courseId" value="${courseId}">
				`;
				document.body.appendChild(deleteForm);
				deleteForm.submit();
			});
		};
		li.appendChild(removeBtn);
		attachmentsList.appendChild(li);
	};

    closeModalBtn.addEventListener('click', closeModal);
    modal.addEventListener('click', e => { if (e.target === modal) closeModal(); });
    document.addEventListener('keydown', e => { if (e.key === 'Escape' && modal.classList.contains('active')) closeModal(); });
	
	document.querySelectorAll('.file-input').forEach(input => {
		input.addEventListener('change', (e) => {
			const file = e.target.files[0];
			const maxSize = parseInt(e.target.dataset.maxSize, 10);
			const warningElement = e.target.nextElementSibling;
			if (file && file.size > maxSize) {
				warningElement.style.display = 'block';
				e.target.value = '';
			} else {
				warningElement.style.display = 'none';
			}
		});
	});
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_storage_list.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Lagerverwaltung" />
</c:import>

<h1>
	<i class="fas fa-warehouse"></i> Lagerverwaltung
</h1>

<%-- Session Messages --%>
<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i>
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<button type="button" class="btn" id="new-item-btn">Neuen
		Artikel anlegen</button>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Tabelle filtern..." aria-label="Tabelle filtern">
	</div>
</div>

<div class="table-wrapper">
	<table class="data-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Name</th>
				<th class="sortable" data-sort-type="string">Ort</th>
				<th class="sortable" data-sort-type="number">Verfügbar</th>
				<th class="sortable" data-sort-type="number">Defekt</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="item" items="${storageList}">
				<tr
					class="${item.defectiveQuantity > 0 ? 'item-status-defect' : ''}">
					<td><a href="<c:url value='/storage-item?id=${item.id}'/>"><c:out
								value="${item.name}" /></a></td>
					<td><c:out value="${item.location}" /></td>
					<td><c:out value="${item.availableQuantity}" /></td>
					<td><c:out value="${item.defectiveQuantity}" /></td>
					<td style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
						<button type="button" class="btn btn-small edit-item-btn"
							data-fetch-url="<c:url value='/admin/storage?action=getItemData&id=${item.id}'/>">Bearbeiten</button>
						<c:set var="qrData">
							<c:url value="/storage-item?id=${item.id}" />
						</c:set> <a
						href="https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${fn:escapeXml(qrData)}"
						target="_blank" class="btn btn-small btn-success">QR-Code</a>
						<button class="btn btn-small btn-warning defect-modal-btn"
							data-item-id="${item.id}"
							data-item-name="${fn:escapeXml(item.name)}"
							data-max-qty="${item.quantity}"
							data-current-defect-qty="${item.defectiveQuantity}"
							data-current-reason="${fn:escapeXml(item.defectReason)}">
							Defekt verwalten</button>
						<form action="<c:url value='/admin/storage'/>" method="post"
							class="js-confirm-form"
							data-confirm-message="Artikel '${fn:escapeXml(item.name)}' wirklich löschen?">
							<input type="hidden" name="action" value="delete"> <input
								type="hidden" name="id" value="${item.id}">
							<button type="submit" class="btn btn-small btn-danger">Löschen</button>
						</form>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<%@ include file="/WEB-INF/jspf/storage_modals.jspf"%>
<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.js-confirm-form').forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
            showConfirmationModal(message, () => this.submit());
        });
    });

    // --- Edit/Create Modal Logic ---
    const itemModal = document.getElementById('item-modal');
    if (itemModal) {
        const form = itemModal.querySelector('form');
        const title = itemModal.querySelector('h3');
        const actionInput = form.querySelector('input[name="action"]');
        const idInput = form.querySelector('input[name="id"]');
        const closeModalBtn = itemModal.querySelector('.modal-close-btn');

        document.getElementById('new-item-btn').addEventListener('click', () => {
            form.reset();
            title.textContent = 'Neuen Lagerartikel anlegen';
            actionInput.value = 'create';
            itemModal.classList.add('active');
        });

        document.querySelectorAll('.edit-item-btn').forEach(btn => {
            btn.addEventListener('click', async () => {
                form.reset();
                // **FIXED:** Read the complete URL directly from the button's data attribute
                const fetchUrl = btn.dataset.fetchUrl;
                try {
                    const response = await fetch(fetchUrl);
                    if (!response.ok) throw new Error('Could not fetch item data.');
                    const itemData = await response.json();

                    title.textContent = 'Lagerartikel bearbeiten';
                    actionInput.value = 'update';
                    idInput.value = itemData.id;
                    form.querySelector('#name-modal').value = itemData.name || '';
                    form.querySelector('#location-modal').value = itemData.location || '';
                    form.querySelector('#cabinet-modal').value = itemData.cabinet || '';
                    form.querySelector('#shelf-modal').value = itemData.shelf || '';
                    form.querySelector('#compartment-modal').value = itemData.compartment || '';
                    form.querySelector('#quantity-modal').value = itemData.quantity;
                    form.querySelector('#maxQuantity-modal').value = itemData.maxQuantity;
                    form.querySelector('#weight_kg-modal').value = itemData.weightKg || '';
                    form.querySelector('#price_eur-modal').value = itemData.priceEur || '';
                    itemModal.classList.add('active');
                } catch (error) {
                    console.error("Failed to open edit modal:", error);
                    alert("Fehler beim Laden der Artikeldaten.");
                }
            });
        });
        closeModalBtn.addEventListener('click', () => itemModal.classList.remove('active'));
    }

    // --- Defect Modal Logic ---
    const defectModal = document.getElementById('defect-modal');
    if (defectModal) {
        const modalTitle = defectModal.querySelector('h3');
        const itemIdInput = defectModal.querySelector('#defect-item-id');
        const defectQtyInput = defectModal.querySelector('#defective_quantity');
        const reasonInput = defectModal.querySelector('#defect_reason');
        const closeModalBtn = defectModal.querySelector('.modal-close-btn');

        document.querySelectorAll('.defect-modal-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                modalTitle.textContent = `Defekt-Status für "${btn.dataset.itemName}" bearbeiten`;
                itemIdInput.value = btn.dataset.itemId;
                defectQtyInput.value = btn.dataset.currentDefectQty;
                defectQtyInput.max = btn.dataset.maxQty;
                reasonInput.value = btn.dataset.currentReason;
                defectModal.classList.add('active');
            });
        });
        closeModalBtn.addEventListener('click', () => defectModal.classList.remove('active'));
    }
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_system.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Systemstatus" />
</c:import>

<h1>
	<i class="fas fa-server"></i> Systemstatus
</h1>
<p>Live-Statistiken des Servers. Die Daten werden alle 5 Sekunden
	aktualisiert.</p>

<div class="dashboard-grid">
	<div class="card">
		<h2 class="card-title">
			<i class="fas fa-microchip"></i> CPU Auslastung
		</h2>
		<div class="progress-bar-container">
			<div id="cpu-progress" class="progress-bar"></div>
		</div>
		<p id="cpu-text" class="progress-text">Lade...</p>
	</div>

	<div class="card">
		<h2 class="card-title">
			<i class="fas fa-memory"></i> Arbeitsspeicher (RAM)
		</h2>
		<div class="progress-bar-container">
			<div id="ram-progress" class="progress-bar"></div>
		</div>
		<p id="ram-text" class="progress-text">Lade...</p>
	</div>

	<div class="card">
		<h2 class="card-title">
			<i class="fas fa-hdd"></i> Festplattenspeicher
		</h2>
		<div class="progress-bar-container">
			<div id="disk-progress" class="progress-bar"></div>
		</div>
		<p id="disk-text" class="progress-text">Lade...</p>
	</div>

	<div class="card" id="battery-card" style="display: none;">
		<h2 class="card-title">
			<i class="fas fa-battery-half"></i> Akku
		</h2>
		<div class="progress-bar-container">
			<div id="battery-progress" class="progress-bar"></div>
		</div>
		<p id="battery-text" class="progress-text">Lade...</p>
	</div>

	<div class="card">
		<h2 class="card-title">
			<i class="fas fa-clock"></i> Server Uptime
		</h2>
		<p id="uptime-text"
			style="font-size: 1.5rem; font-weight: 500; color: var(--primary-color); text-align: center;">Lade...</p>
	</div>
</div>

<style>
.progress-bar-container {
	width: 100%;
	background-color: var(--border-color);
	border-radius: var(--border-radius);
	height: 30px;
	margin-bottom: 0.5rem;
	overflow: hidden;
}

.progress-bar {
	height: 100%;
	background-color: var(--primary-color);
	border-radius: var(--border-radius);
	transition: width 0.5s ease-in-out;
	width: 0%;
}

.progress-text {
	text-align: center;
	font-weight: 500;
	color: var(--text-muted-color);
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    const apiUrl = "${pageContext.request.contextPath}/api/admin/system-stats";

    const cpuProgress = document.getElementById('cpu-progress');
    const cpuText = document.getElementById('cpu-text');
    const ramProgress = document.getElementById('ram-progress');
    const ramText = document.getElementById('ram-text');
    const diskProgress = document.getElementById('disk-progress');
    const diskText = document.getElementById('disk-text');
    const uptimeText = document.getElementById('uptime-text');
    const batteryCard = document.getElementById('battery-card');
    const batteryProgress = document.getElementById('battery-progress');
    const batteryText = document.getElementById('battery-text');
    
    // All formatting logic is correctly handled here in JavaScript.
    const formatGigaBytes = (gb) => {
        if (gb === 0) return '0 GB';
        if (gb < 1) return `${(gb * 1024).toFixed(0)} MB`;
        return `${gb.toFixed(2)} GB`;
    };

    const updateUI = (stats) => {
        const cpuPercent = stats.cpuLoad.toFixed(1);
        cpuProgress.style.width = cpuPercent + '%';
        cpuText.textContent = cpuPercent + '%';

        if (stats.totalMemory > 0) {
            const ramPercent = (stats.usedMemory / stats.totalMemory) * 100;
            ramProgress.style.width = ramPercent.toFixed(1) + '%';
            ramText.textContent = `${formatGigaBytes(stats.usedMemory)} / ${formatGigaBytes(stats.totalMemory)}`;
        }

        if (stats.totalDiskSpace > 0) {
            const diskPercent = (stats.usedDiskSpace / stats.totalDiskSpace) * 100;
            diskProgress.style.width = diskPercent.toFixed(1) + '%';
            diskText.textContent = `${formatGigaBytes(stats.usedDiskSpace)} / ${formatGigaBytes(stats.totalDiskSpace)}`;
        }
        
        uptimeText.textContent = stats.uptime;
        
        if (stats.batteryPercentage >= 0) {
            batteryCard.style.display = 'block';
            const batteryPercent = stats.batteryPercentage;
            batteryProgress.style.width = batteryPercent + '%';
            batteryText.textContent = batteryPercent + '%';
        } else {
            batteryCard.style.display = 'none';
        }
    };

    const fetchStats = async () => {
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const data = await response.json();
            updateUI(data);
        } catch (error) {
            console.error("Could not fetch system stats:", error);
            cpuText.textContent = "Fehler";
            ramText.textContent = "Fehler";
            diskText.textContent = "Fehler";
            uptimeText.textContent = "Fehler";
        }
    };

    fetchStats();
    let intervalId = setInterval(fetchStats, 5000);
    
    document.addEventListener("visibilitychange", () => {
        if (document.hidden) {
            clearInterval(intervalId);
        } else {
            fetchStats();
            intervalId = setInterval(fetchStats, 5000);
        }
    });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_users.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Benutzerverwaltung" />
</c:import>

<h1>
	<i class="fas fa-users-cog"></i> Benutzerverwaltung
</h1>

<%-- Session Messages --%>
<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<i class="fas fa-check-circle"></i>
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.passwordResetInfo}">
	<p class="success-message" id="password-reset-alert">${sessionScope.passwordResetInfo}</p>
	<c:remove var="passwordResetInfo" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<i class="fas fa-exclamation-triangle"></i>
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.infoMessage}">
	<p class="info-message">
		<i class="fas fa-info-circle"></i>
		<c:out value="${sessionScope.infoMessage}" />
	</p>
	<c:remove var="infoMessage" scope="session" />
</c:if>

<div class="table-controls">
	<button type="button" class="btn" id="new-user-btn">
		<i class="fas fa-user-plus"></i> Neuen Benutzer anlegen
	</button>
	<div class="form-group" style="margin-bottom: 0;">
		<input type="search" id="table-filter"
			placeholder="Benutzer filtern..." aria-label="Benutzer filtern">
	</div>
</div>

<!-- Mobile Card View -->
<div class="mobile-card-list searchable-list">
	<c:forEach var="user" items="${userList}">
		<div class="list-item-card"
			data-searchable-content="${user.username} ${user.role}">
			<h3 class="card-title">${user.username}</h3>
			<div class="card-row">
				<span>Rolle:</span> <span>${user.role}</span>
			</div>
			<div class="card-actions">
				<button type="button" class="btn btn-small edit-user-btn"
					data-fetch-url="<c:url value='/admin/users?action=getUserData&id=${user.id}'/>">Bearbeiten</button>
				<a href="<c:url value='/admin/users?action=details&id=${user.id}'/>"
					class="btn btn-small">Details</a>
				<c:if test="${sessionScope.user.id != user.id}">
					<form action="<c:url value='/admin/users'/>" method="post"
						class="js-confirm-form"
						data-confirm-message="Benutzer '${fn:escapeXml(user.username)}' wirklich löschen?">
						<input type="hidden" name="action" value="delete"><input
							type="hidden" name="userId" value="${user.id}">
						<button type="submit" class="btn btn-small btn-danger">Löschen</button>
					</form>
				</c:if>
			</div>
		</div>
	</c:forEach>
</div>

<!-- Desktop Table View -->
<div class="desktop-table-wrapper">
	<table class="data-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="number">ID</th>
				<th class="sortable" data-sort-type="string">Benutzername</th>
				<th class="sortable" data-sort-type="string">Rolle</th>
				<th>Aktionen</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="user" items="${userList}">
				<tr>
					<td>${user.id}</td>
					<td>${user.username}</td>
					<td>${user.role}</td>
					<td style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
						<button type="button" class="btn btn-small edit-user-btn"
							data-fetch-url="<c:url value='/admin/users?action=getUserData&id=${user.id}'/>">Bearbeiten</button>
						<a
						href="<c:url value='/admin/users?action=details&id=${user.id}'/>"
						class="btn btn-small">Details</a> <c:if
							test="${sessionScope.user.id != user.id}">
							<form action="<c:url value='/admin/users'/>" method="post"
								class="js-confirm-form"
								data-confirm-message="Benutzer '${fn:escapeXml(user.username)}' wirklich löschen?">
								<input type="hidden" name="action" value="delete"><input
									type="hidden" name="userId" value="${user.id}">
								<button type="submit" class="btn btn-small btn-danger">Löschen</button>
							</form>
							<form action="<c:url value='/admin/users'/>" method="post"
								class="js-confirm-form"
								data-confirm-message="Passwort für '${fn:escapeXml(user.username)}' zurücksetzen? Das neue Passwort wird angezeigt.">
								<input type="hidden" name="action" value="resetPassword"><input
									type="hidden" name="userId" value="${user.id}">
								<button type="submit" class="btn btn-small btn-warning">Passwort
									Reset</button>
							</form>
						</c:if>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<%@ include file="/WEB-INF/jspf/user_modals.jspf"%>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
	document.querySelectorAll('.js-confirm-form').forEach(form => {
		form.addEventListener('submit', function(e) {
			e.preventDefault();
			const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
			showConfirmationModal(message, () => this.submit());
		});
	});

	const passwordAlert = document.getElementById('password-reset-alert');
	if (passwordAlert) {
		const passwordElement = passwordAlert.querySelector('strong.copyable-password');
		if(passwordElement) {
			navigator.clipboard.writeText(passwordElement.textContent)
                .then(() => console.log('Password copied to clipboard'))
                .catch(err => console.error('Failed to copy password:', err));
		}
	}

	const modal = document.getElementById('user-modal');
	const form = document.getElementById('user-modal-form');
	const title = document.getElementById('user-modal-title');
	const actionInput = form.querySelector('input[name="action"]');
	const idInput = form.querySelector('input[name="userId"]');
	const usernameInput = form.querySelector('#username-modal');
	const passwordInput = form.querySelector('#password-modal');
	const passwordGroup = form.querySelector('#password-group');
	const roleInput = form.querySelector('#role-modal');
	const classYearInput = form.querySelector('#classYear-modal');
	const classNameInput = form.querySelector('#className-modal');
	const closeModalBtn = modal.querySelector('.modal-close-btn');

	const closeModal = () => modal.classList.remove('active');

	document.getElementById('new-user-btn').addEventListener('click', () => {
		form.reset();
		title.textContent = "Neuen Benutzer anlegen";
		actionInput.value = "create";
		idInput.value = "";
		passwordInput.required = true;
		passwordGroup.style.display = 'block';
		modal.classList.add('active');
		usernameInput.focus();
	});

	document.querySelectorAll('.edit-user-btn').forEach(btn => {
		btn.addEventListener('click', async () => {
			form.reset();
			const fetchUrl = btn.dataset.fetchUrl;
			try {
				const response = await fetch(fetchUrl);
				if (!response.ok) throw new Error('Could not fetch user data');
				const data = await response.json();

				title.textContent = `Benutzer bearbeiten: ${data.username}`;
				actionInput.value = "update";
				idInput.value = data.id;
				usernameInput.value = data.username || '';
				roleInput.value = data.role || 'NUTZER';
				classYearInput.value = data.classYear || '';
				classNameInput.value = data.className || '';
				passwordInput.required = false;
				passwordGroup.style.display = 'none';
				modal.classList.add('active');
			} catch (error) {
				console.error('Failed to open edit modal:', error);
				alert('Benutzerdaten konnten nicht geladen werden.');
			}
		});
	});

	closeModalBtn.addEventListener('click', closeModal);
	modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
	document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal.classList.contains('active')) closeModal(); });
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\admin\admin_user_details.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>

<%--
admin_user_details.jsp

This JSP displays a detailed view of a single user for an administrator.
It shows the user's master data (username, role, class info) and a table
listing the user's event participation history. The user data itself is
no longer editable on this page; editing is handled by a modal on the main user list.

    It is served by: AdminUserServlet (doGet with action=details).

    Expected attributes:

        'userToView' (de.technikteam.model.User): The user whose details are being viewed.

        'eventHistory' (List<de.technikteam.model.Event>): The user's event history.
        --%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Benutzerdetails" />
</c:import>
<c:import url="/WEB-INF/jspf/admin_navigation.jspf" />
<h1>
	Benutzerdetails:
	<c:out value="${userToView.username}" />
</h1>
<a href="${pageContext.request.contextPath}/admin/users"
	style="display: inline-block; margin-bottom: 1rem;"> &laquo; Zurück
	zur Benutzerliste </a>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.infoMessage}">
	<p class="info-message">
		<c:out value="${sessionScope.infoMessage}" />
	</p>
	<c:remove var="infoMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="responsive-dashboard-grid">
	<%-- Master Data --%>
	<div class="card">
		<h2 class="card-title">Stammdaten</h2>
		<ul class="details-list">
			<li><strong>Benutzername:</strong> <c:out
					value="${userToView.username}" /></li>
			<li><strong>Rolle:</strong> <c:out value="${userToView.role}" /></li>
			<li><strong>Jahrgang:</strong> <c:out
					value="${userToView.classYear}" /></li>
			<li><strong>Klasse:</strong> <c:out
					value="${userToView.className}" /></li>
			<li><strong>Registriert seit:</strong> <c:out
					value="${userToView.formattedCreatedAt}" /> Uhr</li>
		</ul>
	</div>
	<%-- Event History --%>
	<div class="card">
		<h2 class="card-title">Event-Teilnahmehistorie</h2>
		<div class="desktop-table-wrapper"
			style="box-shadow: none; border: none; max-height: 450px; overflow-y: auto;">
			<table class="desktop-table">
				<thead>
					<tr>
						<th>Event</th>
						<th>Datum</th>
						<th>Status</th>
					</tr>
				</thead>
				<tbody>
					<c:if test="${empty eventHistory}">
						<tr>
							<td colspan="3">Keine Event-Historie vorhanden.</td>
						</tr>
					</c:if>
					<c:forEach var="event" items="${eventHistory}">
						<tr>
							<td><a
								href="${pageContext.request.contextPath}/eventDetails?id=${event.id}"><c:out
										value="${event.name}" /></a></td>
							<td><c:out value="${event.formattedEventDateTime}" /> Uhr</td>
							<td><c:out value="${event.userAttendanceStatus}" /></td>
						</tr>
					</c:forEach>
				</tbody>
			</table>
		</div>
	</div>
</div>
<style>
.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
}

.details-list li:last-child {
	border-bottom: none;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\css\style.css
========================================================================

/* =================================================================== */
/*  TECHNIKTEAM DESIGN V22 (THEMED SIDEBAR & FIXES)                    */
/* =================================================================== */

/* --- 1. THEME & COLOR PALETTE --- */
:root {
	--primary-color: #6366f1;
	--primary-color-hover: #4f46e5;
	--primary-color-light: rgba(99, 102, 241, 0.1);
	--bg-color: #f9fafb;
	--surface-color: #ffffff;
	--text-color: #111827;
	--text-muted-color: #6b7280;
	--border-color: #e5e7eb;
	--success-color: #10b981;
	--warning-color: #f59e0b;
	--danger-color: #ef4444;
	--danger-hover-color: #dc2626;
	--shadow-sm: 0 1px 2px 0 rgb(0 0 0/ 0.05);
	--shadow-md: 0 4px 6px -1px rgb(0 0 0/ 0.1), 0 2px 4px -2px
		rgb(0 0 0/ 0.1);
	--sidebar-width: 260px;
	--header-height: 64px;
	--border-radius: 8px;
	/* Sidebar colors for Light Theme */
	--sidebar-bg: var(--surface-color);
	--sidebar-border: var(--border-color);
	--sidebar-text-color: var(--text-color);
	--sidebar-text-muted: var(--text-muted-color);
	--sidebar-hover-bg: var(--primary-color-light);
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
}

[data-theme="dark"] {
	--primary-color: #818cf8;
	--primary-color-hover: #a78bfa;
	--primary-color-light: rgba(129, 140, 248, 0.15);
	--bg-color: #111827;
	--surface-color: #1f2937;
	--text-color: #f9fafb;
	--text-muted-color: #9ca3af;
	--border-color: #374151;
	--success-color: #34d399;
	--warning-color: #fbbf24;
	--danger-color: #f87171;
	--danger-hover-color: #ef4444;
	/* Sidebar colors for Dark Theme */
	--sidebar-bg: #1f2937;
	--sidebar-border: #374151;
	--sidebar-text-color: #f9fafb;
	--sidebar-text-muted: #9ca3af;
	--sidebar-hover-bg: rgba(255, 255, 255, 0.05);
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
}

/* --- 2. BASE & TYPOGRAPHY --- */
*, *::before, *::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html {
	scroll-behavior: smooth;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		"Helvetica Neue", Arial, sans-serif;
	background-color: var(--bg-color);
	color: var(--text-color);
	line-height: 1.6;
	transition: background-color 0.3s, color 0.3s;
}

h1, h2, h3, h4 {
	color: var(--text-color);
	line-height: 1.3;
}

h1 {
	font-size: clamp(1.8rem, 5vw, 2.2rem);
	font-weight: 700;
	margin-bottom: 1rem;
}

h2 {
	font-size: clamp(1.2rem, 4vw, 1.5rem);
	margin-bottom: 1.25rem;
	padding-bottom: 0.75rem;
	border-bottom: 1px solid var(--border-color);
	font-weight: 600;
}

h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	font-weight: 600;
}

a {
	color: var(--primary-color);
	text-decoration: none;
	transition: color 0.2s;
}

a:hover {
	text-decoration: underline;
	color: var(--primary-color-hover);
}

.text-success {
	color: var(--success-color);
}

.text-danger {
	color: var(--danger-color);
}

/* --- 3. UNIFIED NAVIGATION SYSTEM --- */
.sidebar {
	position: fixed;
	top: 0;
	left: calc(-1 * var(--sidebar-width));
	width: var(--sidebar-width);
	height: 100%;
	background: var(--sidebar-bg);
	border-right: 1px solid var(--sidebar-border);
	color: var(--sidebar-text-color);
	z-index: 1010;
	transition: left 0.3s ease-in-out, background-color 0.3s, border-color
		0.3s;
	display: flex;
	flex-direction: column;
}

body.nav-open .sidebar {
	left: 0;
	box-shadow: var(--shadow-md);
}

.sidebar-header {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0 1.5rem;
	height: var(--header-height);
	flex-shrink: 0;
}

.sidebar-header .logo {
	font-size: 1.25rem;
	font-weight: 700;
	color: var(--sidebar-text-color);
	text-decoration: none;
}

.sidebar-header .logo i {
	color: var(--primary-color);
}

.sidebar-nav {
	list-style: none;
	flex-grow: 1;
	overflow-y: auto;
}

.sidebar-nav a {
	display: flex;
	align-items: center;
	gap: 1rem;
	padding: 0.9rem 1.5rem;
	color: var(--sidebar-text-muted);
	font-weight: 500;
	transition: all 0.2s;
	border-left: 4px solid transparent;
	white-space: nowrap;
	text-decoration: none;
}

.sidebar-nav a:hover {
	color: var(--sidebar-text-color);
	background-color: var(--sidebar-hover-bg);
}

.sidebar-nav a.active-nav-link {
	color: var(--sidebar-text-color);
	font-weight: 600;
	border-left-color: var(--sidebar-active-border);
	background-color: var(--sidebar-active-bg);
}

.sidebar-nav a i.fa-fw {
	width: 20px;
	text-align: center;
}

.sidebar-nav .nav-section-title {
	padding: 1.5rem 1.5rem 0.5rem;
	font-size: 0.8rem;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--sidebar-text-muted);
}

.user-actions {
	padding: 1rem 1.5rem;
	border-top: 1px solid var(--sidebar-border);
	flex-shrink: 0;
}

.user-info {
	font-weight: 500;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: var(--sidebar-text-muted);
}

.user-info strong {
	color: var(--sidebar-text-color);
}

.mobile-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	height: var(--header-height);
	background-color: var(--surface-color);
	padding: 0 1rem;
	position: sticky;
	top: 0;
	z-index: 1000;
	border-bottom: 1px solid var(--border-color);
}

.mobile-nav-toggle {
	background: none;
	border: none;
	cursor: pointer;
	padding: 0.5rem;
	z-index: 1020;
}

.mobile-nav-toggle .line {
	width: 25px;
	height: 3px;
	background-color: var(--text-color);
	margin: 5px 0;
	border-radius: 3px;
	transition: all 0.3s;
}

body.nav-open .mobile-nav-toggle .line-1 {
	transform: rotate(45deg) translate(5px, 6px);
}

body.nav-open .mobile-nav-toggle .line-2 {
	opacity: 0;
}

body.nav-open .mobile-nav-toggle .line-3 {
	transform: rotate(-45deg) translate(5px, -6px);
}

.mobile-logo {
	font-weight: 600;
	font-size: 1.2rem;
	color: var(--text-color);
	text-decoration: none;
}

.main-content-wrapper {
	transition: margin-left 0.3s ease-in-out;
}

.main-content {
	padding: 1.5rem;
	max-width: 1400px;
	margin-left: auto;
	margin-right: auto;
}

.page-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 1005;
}

body.nav-open .page-overlay {
	display: block;
}

@media ( min-width : 992px) {
	.mobile-header, .page-overlay {
		display: none !important;
	}
	.sidebar {
		left: 0;
	}
	.main-content-wrapper {
		margin-left: var(--sidebar-width);
	}
}

/* --- 4. COMPONENTS --- */
.card {
	background: var(--surface-color);
	border-radius: var(--border-radius);
	padding: 1.5rem;
	margin-bottom: 1.5rem;
	box-shadow: var(--shadow-sm);
	border: 1px solid var(--border-color);
}

.card-title {
	margin-top: 0;
	margin-bottom: 1.25rem;
	padding-bottom: 0.75rem;
	border-bottom: 1px solid var(--border-color);
}

.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;
	padding: 0.6rem 1.2rem;
	background-color: var(--primary-color);
	color: #fff;
	border: 1px solid transparent;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s;
	text-align: center;
	text-decoration: none;
}

.btn:hover {
	background-color: var(--primary-color-hover);
	color: #fff;
	text-decoration: none;
	transform: translateY(-1px);
}

.btn-small {
	padding: 0.4rem 0.8rem;
	font-size: 0.9rem;
}

.btn-danger {
	background-color: var(--danger-color);
}

.btn-danger:hover {
	background-color: var(--danger-hover-color);
}

.btn-warning {
	background-color: var(--warning-color);
	color: #111827;
}

.btn-warning:hover {
	background-color: #fca103;
}

.btn-success {
	background-color: var(--success-color);
}

.btn-success:hover {
	background-color: #059669;
}

.btn[disabled] {
	background-color: var(--text-muted-color);
	cursor: not-allowed;
	transform: none !important;
}

.btn-danger-outline {
	background: transparent;
	border-color: var(--danger-color);
	color: var(--danger-color);
}

.btn-danger-outline:hover {
	background: var(--danger-color);
	color: #fff;
}

.success-message, .error-message, .info-message {
	padding: 1rem;
	margin-bottom: 1.5rem;
	border-radius: var(--border-radius);
	color: #fff;
	font-weight: 500;
	display: flex;
	align-items: center;
	gap: 0.75rem;
}

.success-message {
	background-color: var(--success-color);
}

.error-message {
	background-color: var(--danger-color);
}

.info-message {
	background-color: #3b82f6;
}

/* --- 5. THEME SWITCHER & STATUS BADGES --- */
.theme-switch-wrapper {
	display: flex;
	align-items: center;
	gap: 0.5rem;
	padding: 0.5rem 0;
}

.theme-switch {
	position: relative;
	display: inline-block;
	width: 50px;
	height: 24px;
}

.theme-switch input {
	opacity: 0;
	width: 0;
	height: 0;
}

.slider {
	position: absolute;
	cursor: pointer;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background-color: #4b5563;
	transition: .4s;
	border-radius: 24px;
}

.slider:before {
	position: absolute;
	content: "";
	height: 16px;
	width: 16px;
	left: 4px;
	bottom: 4px;
	background-color: white;
	transition: .4s;
	border-radius: 50%;
}

input:checked+.slider {
	background-color: var(--primary-color);
}

input:checked+.slider:before {
	transform: translateX(26px);
}

.status-badge {
	padding: 0.25rem 0.75rem;
	border-radius: 20px;
	font-size: 0.8rem;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.5px;
}

.status-ok {
	background-color: var(--success-color);
	color: #fff;
}

.status-warn {
	background-color: var(--warning-color);
	color: #111827;
}

.status-danger {
	background-color: var(--danger-color);
	color: #fff;
}

.status-info {
	background-color: var(--text-muted-color);
	color: #fff;
}

/* --- 6. FORMS & TABLES --- */
.form-group {
	margin-bottom: 1.25rem;
}

.form-group label {
	display: block;
	margin-bottom: 0.5rem;
	font-weight: 500;
	color: var(--text-muted-color);
}

.form-group input, .form-group select, .form-group textarea {
	width: 100%;
	padding: 0.75rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
	background-color: var(--surface-color);
	color: var(--text-color);
	font-size: 1rem;
	transition: border-color 0.2s, box-shadow 0.2s;
}

.form-group input:focus, .form-group select:focus, .form-group textarea:focus
	{
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 2px var(--primary-color-light);
}

.table-wrapper {
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	overflow-x: auto;
	background-color: var(--surface-color);
}

.data-table {
	width: 100%;
	border-collapse: collapse;
}

.data-table th, .data-table td {
	padding: 1rem;
	text-align: left;
	border-bottom: 1px solid var(--border-color);
	white-space: nowrap;
}

.data-table thead th {
	font-size: 0.8rem;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
	background-color: var(--bg-color);
}

.data-table tbody tr:last-child td {
	border-bottom: none;
}

.data-table tbody tr:hover {
	background-color: var(--primary-color-light);
}

.data-table .item-status-defect td {
	color: var(--text-muted-color);
	font-style: italic;
}

.data-table .item-status-defect a {
	color: var(--text-muted-color);
}

.table-controls {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
}

.table-controls input[type="search"] {
	max-width: 350px;
}

/* --- 7. MODALS --- */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.6);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 2000;
	opacity: 0;
	visibility: hidden;
	transition: opacity 0.3s, visibility 0.3s;
}

.modal-overlay.active {
	opacity: 1;
	visibility: visible;
}

.modal-content {
	background: var(--surface-color);
	padding: 2rem;
	border-radius: var(--border-radius);
	width: 90%;
	max-width: 600px;
	max-height: 90vh;
	overflow-y: auto;
	position: relative;
	transform: translateY(-20px);
	transition: transform 0.3s;
}

.modal-overlay.active .modal-content {
	transform: translateY(0);
}

.modal-close-btn {
	position: absolute;
	top: 1rem;
	right: 1rem;
	background: none;
	border: none;
	font-size: 1.5rem;
	cursor: pointer;
	color: var(--text-muted-color);
}

/* --- 8. RESPONSIVE LISTS/TABLES --- */
.mobile-card-list {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.list-item-card {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	padding: 1rem;
	box-shadow: var(--shadow-sm);
}

.list-item-card .card-title {
	font-size: 1.2rem;
	border: none;
	padding: 0;
	margin-bottom: 0.75rem;
}

.card-row {
	display: flex;
	justify-content: space-between;
	font-size: 0.9rem;
	padding: 0.25rem 0;
}

.card-row span:first-child {
	color: var(--text-muted-color);
}

.card-row span:last-child {
	font-weight: 500;
}

.card-actions {
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	gap: 0.5rem;
}

.desktop-table-wrapper {
	display: none;
}

@media ( min-width : 992px) {
	.mobile-card-list {
		display: none !important;
	}
	.desktop-table-wrapper {
		display: block !important;
	}
}

/* --- 9. DASHBOARD & SPECIFIC LAYOUTS --- */
.dashboard-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1.5rem;
}

.responsive-dashboard-grid {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1.5rem;
}

@media ( min-width : 992px) {
	.responsive-dashboard-grid {
		grid-template-columns: 1fr 2fr;
	}
}

.responsive-form-grid {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1rem;
}

@media ( min-width : 768px) {
	.responsive-form-grid {
		grid-template-columns: 1fr 1fr;
	}
}

/* --- 10. LOGIN PAGE --- */
.login-page-container {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	min-height: 100vh;
	padding: 1rem;
	background: var(--bg-color);
}

.login-box {
	width: 100%;
	max-width: 400px;
	padding: 2.5rem;
	background-color: var(--surface-color);
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-md);
}

.login-box h1 {
	text-align: center;
	margin-bottom: 2rem;
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\js\main.js
========================================================================

/**
 * Main JavaScript file for the TechnikTeam application.
 * This file is included on every page and handles global user interface logic.
 */
document.addEventListener('DOMContentLoaded', () => {

	const contextPath = document.body.dataset.contextPath || '';

	// --- 1. Mobile Navigation Toggle Logic ---
	const navToggle = document.querySelector('.mobile-nav-toggle');
	const pageOverlay = document.querySelector('.page-overlay');
	if (navToggle) {
		navToggle.addEventListener('click', (e) => {
			e.stopPropagation();
			document.body.classList.toggle('nav-open');
		});
	}
	if (pageOverlay) {
		pageOverlay.addEventListener('click', () => {
			document.body.classList.remove('nav-open');
		});
	}

	// --- 2. Active Navigation Link Highlighting ---
	const currentPath = window.location.pathname;
	const navLinks = document.querySelectorAll('.sidebar-nav a');
	let bestMatch = null;
	let maxMatchLength = 0;

	navLinks.forEach(link => {
		const linkPath = new URL(link.href).pathname;
		if (linkPath && currentPath.startsWith(linkPath)) {
			// Give preference to exact matches
			if (currentPath === linkPath) {
				maxMatchLength = linkPath.length + 100; // Prioritize exact match
				bestMatch = link;
			} else if (linkPath.length > maxMatchLength) {
				maxMatchLength = linkPath.length;
				bestMatch = link;
			}
		}
	});

	if (bestMatch) {
		bestMatch.classList.add('active-nav-link');
	}

	// --- 3. Theme Switcher Logic ---
	const themeSwitch = document.getElementById('theme-toggle');
	const currentTheme = localStorage.getItem('theme') || 'light';
	document.documentElement.setAttribute('data-theme', currentTheme);
	if (themeSwitch) {
		if (currentTheme === 'dark') {
			themeSwitch.checked = true;
		}
		themeSwitch.addEventListener('change', (e) => {
			const newTheme = e.target.checked ? 'dark' : 'light';
			document.documentElement.setAttribute('data-theme', newTheme);
			localStorage.setItem('theme', newTheme);
		});
	}

	// --- 4. Global Confirmation Modal Logic ---
	const confirmationModalElement = document.createElement('div');
	confirmationModalElement.className = 'modal-overlay';
	confirmationModalElement.id = 'confirmation-modal';
	confirmationModalElement.innerHTML = `
        <div class="modal-content" style="max-width: 450px;">
            <h3 id="confirmation-title">Bestätigung erforderlich</h3>
            <p id="confirmation-message" style="margin: 1.5rem 0; font-size: 1.1rem;"></p>
            <div style="display: flex; justify-content: flex-end; gap: 1rem;">
                <button id="confirmation-btn-cancel" class="btn" style="background-color: var(--text-muted-color);">Abbrechen</button>
                <button id="confirmation-btn-confirm" class="btn btn-danger">Bestätigen</button>
            </div>
        </div>`;
	document.body.appendChild(confirmationModalElement);

	const messageElement = document.getElementById('confirmation-message');
	const confirmBtn = document.getElementById('confirmation-btn-confirm');
	const cancelBtn = document.getElementById('confirmation-btn-cancel');

	let onConfirmCallback = null;

	window.showConfirmationModal = (message, onConfirm) => {
		messageElement.textContent = message;
		onConfirmCallback = onConfirm;
		confirmationModalElement.classList.add('active');
	};

	const closeConfirmModal = () => {
		confirmationModalElement.classList.remove('active');
		onConfirmCallback = null;
	};

	confirmBtn.addEventListener('click', () => {
		if (typeof onConfirmCallback === 'function') onConfirmCallback();
		closeConfirmModal();
	});

	cancelBtn.addEventListener('click', closeConfirmModal);
	confirmationModalElement.addEventListener('click', (e) => {
		if (e.target === confirmationModalElement) closeConfirmModal();
	});

	// Attach confirmation to logout link
	const logoutLink = document.getElementById('logout-link');
	if (logoutLink) {
		logoutLink.addEventListener('click', (event) => {
			event.preventDefault();
			showConfirmationModal(
				'Möchten Sie sich wirklich ausloggen?',
				() => { window.location.href = logoutLink.href; }
			);
		});
	}

	// --- 5. Server-Sent Events (SSE) Notification Logic ---
	if (document.body.dataset.isLoggedIn === 'true' && window.EventSource) {
		const eventSource = new EventSource(`${contextPath}/notifications`);
		eventSource.onopen = () => console.log("SSE connection established.");
		eventSource.onmessage = (event) => {
			console.log("SSE message received:", event.data);
			showBrowserNotification(event.data);
		};
		eventSource.onerror = (err) => {
			console.error("SSE connection error.", err);
			eventSource.close();
		};
	}

	function showBrowserNotification(message) {
		if (!("Notification" in window)) {
			console.warn("This browser does not support desktop notifications.");
			return;
		}
		if (Notification.permission === "granted") {
			new Notification("Technik Team Update", { body: message, icon: `${contextPath}/images/logo.png` });
		} else if (Notification.permission !== "denied") {
			Notification.requestPermission().then((permission) => {
				if (permission === "granted") {
					new Notification("Technik Team Update", { body: message, icon: `${contextPath}/images/logo.png` });
				}
			});
		}
	}
});

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\WEB-INF\web.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"
	version="5.0">

	<!-- web.xml: The core deployment descriptor for the web application. This 
		file configures essential, application-wide settings that cannot be handled 
		by Java annotations. It defines: - Session Timeout: How long a user's session 
		remains active during inactivity. - Welcome File: The default page a user 
		sees when they visit the root URL. - JSP Configuration: Ensures Expression 
		Language (EL) is enabled on all JSPs. - Custom Error Pages: Maps HTTP error 
		codes like 404 (Not Found) and 500 (Internal Server Error) to user-friendly, 
		custom JSP pages. Note: All Servlet, Filter, and Listener mappings are now 
		managed via annotations in their respective Java classes for a more modern 
		and decentralized configuration approach. -->

	<display-name>TechnikTeam Web Application</display-name>

	<session-config>
		<session-timeout>30</session-timeout> <!-- in minutes -->
	</session-config>

	<welcome-file-list>
		<welcome-file>login.jsp</welcome-file>
	</welcome-file-list>

	<!-- Ensures that Expression Language (${...}) is always enabled on JSPs. -->
	<jsp-config>
		<jsp-property-group>
			<url-pattern>*.jsp</url-pattern>
			<url-pattern>*.jspf</url-pattern>
			<el-ignored>false</el-ignored>
		</jsp-property-group>
	</jsp-config>

	<!-- Custom Error Pages -->
	<error-page>
		<error-code>404</error-code>
		<location>/error404.jsp</location>
	</error-page>
	<error-page>
		<error-code>500</error-code>
		<location>/error500.jsp</location>
	</error-page>
	<error-page>
		<exception-type>java.lang.Throwable</exception-type>
		<location>/error500.jsp</location>
	</error-page>

</web-app>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\collaborative_editor.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  FIX: This page now imports the standard header and footer to be
  fully integrated into the application's UI.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Gemeinsamer Editor" />
	<c:param name="navType" value="user" />
</c:import>

<h1>
	<i class="fas fa-edit"></i> Gemeinsamer Notizblock
</h1>
<p>Änderungen werden automatisch für alle Benutzer gespeichert und
	angezeigt.</p>

<div class="card">
	<textarea id="editor" class="form-group"
		style="width: 100%; height: 60vh; font-family: monospace; font-size: 16px; margin: 0; background-color: var(--surface-color);"
		placeholder="Lade Inhalt..."></textarea>
	<div id="status-indicator"
		style="text-align: right; font-style: italic; color: var(--text-muted-color); padding-top: 5px; min-height: 1.2em;"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const editor = document.getElementById('editor');
    const statusIndicator = document.getElementById('status-indicator');
    const apiUrl = "${pageContext.request.contextPath}/api/document";
    let debounceTimer;

    const saveContent = () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            const content = editor.value;
            statusIndicator.textContent = 'Speichere...';
            fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'text/plain; charset=utf-8' },
                body: content
            }).then(response => {
                if (response.ok) {
                    statusIndicator.textContent = 'Gespeichert';
                } else {
                    statusIndicator.textContent = 'Fehler beim Speichern!';
                    statusIndicator.style.color = 'var(--danger-color)';
                }
            }).catch(err => {
                 statusIndicator.textContent = 'Netzwerkfehler!';
                 statusIndicator.style.color = 'var(--danger-color)';
            });
        }, 500);
    };

    const fetchContent = () => {
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) throw new Error("Server response not OK");
                return response.text();
            })
            .then(newContent => {
                if (document.activeElement !== editor && editor.value !== newContent) {
                    const cursorPos = editor.selectionStart;
                    editor.value = newContent;
                    editor.selectionStart = editor.selectionEnd = cursorPos;
                }
            }).catch(err => {
                console.error("Error fetching document content:", err);
                statusIndicator.textContent = 'Fehler beim Laden!';
                statusIndicator.style.color = 'var(--danger-color)';
            });
    };
    
    editor.addEventListener('input', saveContent);

    const pollInterval = setInterval(fetchContent, 3000);
    fetchContent(); 
    
    window.addEventListener('beforeunload', () => {
        clearInterval(pollInterval);
    });
});
</script>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\dateien.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Dateien" />
	<c:param name="navType" value="user" />
</c:import>

<h1>Dateien & Dokumente</h1>

<c:if test="${empty fileData}">
	<div class="card">
		<p>Es sind keine Dateien oder Dokumente verfügbar.</p>
	</div>
</c:if>

<c:forEach var="categoryEntry" items="${fileData}">
	<div class="card">
		<h2>
			<c:out value="${categoryEntry.key}" />
		</h2>
		<ul style="list-style: none; padding-left: 0;">
			<c:forEach var="file" items="${categoryEntry.value}" varStatus="loop">
				<li
					style="padding: 0.75rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
					<c:choose>
						<c:when test="${file.id == -1}">
							<a href="${pageContext.request.contextPath}/editor-page"
								style="font-weight: 600;"><c:out value="${file.filename}" /></a>
						</c:when>
						<c:otherwise>
							<a
								href="${pageContext.request.contextPath}/download?file=${file.filepath}"><c:out
									value="${file.filename}" /></a>
						</c:otherwise>
					</c:choose>
				</li>
			</c:forEach>
		</ul>
	</div>
</c:forEach>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\error404.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>
<jsp:useBean id="now" class="java.util.Date" />

<%--
  error404.jsp
  
  This is a custom, user-friendly "Page Not Found" page. It is displayed
  whenever a user navigates to a URL that does not map to any servlet or
  resource in the application. The mapping is configured in web.xml.
  It does not use the standard navigation for a cleaner error display.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="404 - Seite nicht gefunden" />
</c:import>

<header class="app-header">
	<a href="${pageContext.request.contextPath}/home" class="logo">Technik
		Team</a>
</header>

<main>
	<div class="error-container">
		<div class="error-icon">⚠️</div>
		<h1>Seite nicht gefunden</h1>
		<h2>Fehlercode 404</h2>

		<p>
			Die von dir aufgerufene Seite <strong><c:out
					value="${pageContext.errorData.requestURI}" /></strong> existiert leider
			nicht.
		</p>
		<p>Möglicherweise hast du dich vertippt oder der Link ist
			veraltet.</p>

		<a href="${pageContext.request.contextPath}/home" class="btn">Zurück
			zur Startseite</a>

		<div class="error-details">
			Fehlerzeitpunkt:
			<fmt:formatDate value="${now}" type="both" dateStyle="long"
				timeStyle="medium" />
		</div>
	</div>
</main>

<style>
/* Specific styles for the error page content */
.error-container {
	text-align: center;
	padding: 2rem;
	margin: 2rem auto;
	max-width: 650px;
	background-color: var(--surface-color);
	border-radius: 12px;
	border: 1px solid var(--border-color);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.error-icon {
	font-size: 4rem;
	color: var(--primary-color);
	margin-bottom: 1rem;
}

.error-container h1 {
	font-size: 2.2rem;
	color: var(--text-color);
	margin-bottom: 0.25rem;
}

.error-container h2 {
	font-size: 1.2rem;
	color: var(--text-muted-color);
	font-weight: 500;
	margin-bottom: 2rem;
}

.error-container p {
	margin-bottom: 1rem;
	font-size: 1.1rem;
	line-height: 1.6;
}

.error-container .btn {
	margin-top: 1rem;
}

.error-details {
	margin-top: 2rem;
	font-size: 0.85rem;
	color: var(--text-muted-color);
	border-top: 1px solid var(--border-color);
	padding-top: 1rem;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\error500.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isErrorPage="true" isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>
<jsp:useBean id="now" class="java.util.Date" />

<%--
  error500.jsp
  
  This is a custom "Internal Server Error" page. It is displayed whenever an
  uncaught exception occurs during the processing of a request. The mapping
  is configured in web.xml. For developers, it includes a hidden HTML comment
  with basic debugging information (the full stack trace is available in the
  server logs).
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="500 - Interner Serverfehler" />
</c:import>

<header class="app-header">
	<a href="${pageContext.request.contextPath}/home" class="logo">Technik
		Team</a>
</header>

<main>
	<div class="error-container">
		<div class="error-icon" style="color: var(--danger-color);">⚙️</div>
		<h1>Interner Serverfehler</h1>
		<h2>Fehlercode 500</h2>

		<p>Es ist ein unerwarteter technischer Fehler aufgetreten.</p>
		<p>
			Bitte versuche es später erneut oder wende dich an <a
				href="mailto:jacques.serenz@no-bs.de">jacques.serenz@no-bs.de</a>,
			wenn der Fehler weiterhin bestehen bleibt.
		</p>

		<a href="${pageContext.request.contextPath}/home" class="btn">Zurück
			zur Startseite</a>

		<div class="error-details">
			Fehlerzeitpunkt:
			<fmt:formatDate value="${now}" type="both" dateStyle="long"
				timeStyle="medium" />
		</div>

		<%-- 
          DEBUGGING INFO: This block is hidden from regular users via an HTML comment.
          It allows developers to see error details by viewing the page source in the browser.
          The full stack trace is always available in the server logs (e.g., catalina.out).
        --%>
		<!--
            Exception Details for Developers:
            Request URI:    ${pageContext.errorData.requestURI}
            Servlet Name:   ${pageContext.errorData.servletName}
            Exception Type: ${pageContext.exception}
            Exception Msg:  ${pageContext.exception.message}
            Stack Trace:
            <c:forEach var="trace" items="${pageContext.exception.stackTrace}">
                ${trace}
            </c:forEach>
        -->
	</div>
</main>

<style>
/* Reuse the same styles from the 404 page for consistency */
.error-container {
	text-align: center;
	padding: 2rem;
	margin: 2rem auto;
	max-width: 650px;
	background-color: var(--surface-color);
	border-radius: 12px;
	border: 1px solid var(--border-color);
	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.error-icon {
	font-size: 4rem;
	color: var(--danger-color);
	margin-bottom: 1rem;
}

.error-container h1 {
	font-size: 2.2rem;
	color: var(--text-color);
	margin-bottom: 0.25rem;
	text-align: center;
}

.error-container h2 {
	font-size: 1.2rem;
	color: var(--text-muted-color);
	font-weight: 500;
	margin-bottom: 2rem;
	text-align: center;
}

.error-container p {
	margin-bottom: 1rem;
	font-size: 1.1rem;
	line-height: 1.6;
}

.error-container .btn {
	margin-top: 1rem;
}

.error-details {
	margin-top: 2rem;
	font-size: 0.85rem;
	color: var(--text-muted-color);
	border-top: 1px solid var(--border-color);
	padding-top: 1rem;
}
</style>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\eventDetails.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Event Details" />
</c:import>

<div class="details-container">

	<div
		style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
		<h1>
			<c:out value="${event.name}" />
		</h1>
		<c:if test="${not empty event.status}">
			<c:set var="statusClass"
				value="${event.status == 'KOMPLETT' or event.status == 'ZUGEWIESEN' ? 'status-ok' : event.status == 'LAUFEND' ? 'status-warn' : event.status == 'ABGESCHLOSSEN' ? 'status-info' : 'status-info'}" />
			<span class="status-badge ${statusClass}"><c:out
					value="${event.status}" /></span>
		</c:if>
	</div>

	<p class="details-subtitle">
		<strong>Zeitraum:</strong>
		<c:out value="${event.formattedEventDateTimeRange}" />
		<c:if test="${not empty event.location}">
			<span style="margin-left: 1rem;"><strong>Ort:</strong> <c:out
					value="${event.location}" /></span>
		</c:if>
	</p>

	<c:if
		test="${event.status == 'LAUFEND' and (isUserAssigned or sessionScope.user.role == 'ADMIN')}">
		<div class="dashboard-grid">
			<div class="card">
				<h2 class="card-title">Aufgaben</h2>
				<c:if test="${sessionScope.user.role == 'ADMIN'}">
					<div id="admin-task-manager">
						<ul id="task-list-admin" style="list-style: none; padding: 0;">
							<c:if test="${empty event.eventTasks}">
								<li>Noch keine Aufgaben erstellt.</li>
							</c:if>
							<c:forEach var="task" items="${event.eventTasks}">
								<li id="task-item-${task.id}"
									style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
									<div style="flex-grow: 1;">
										<strong><c:out value="${task.description}" /></strong><br>
										<small>Zugewiesen: <c:out
												value="${not empty task.assignedUsernames ? task.assignedUsernames : 'Niemand'}" />
										</small>
									</div>
									<div style="display: flex; gap: 0.5rem; flex-shrink: 0;">
										<span
											class="status-badge ${task.status == 'ERLEDIGT' ? 'status-ok' : 'status-warn'}"><c:out
												value="${task.status}" /></span>
										<button class="btn btn-small assign-task-btn"
											data-task-id="${task.id}">Zuweisen</button>
										<button class="btn btn-small btn-danger delete-task-btn"
											data-task-id="${task.id}"
											data-task-desc="${fn:escapeXml(task.description)}">×</button>
									</div>
								</li>
							</c:forEach>
						</ul>
						<form action="${pageContext.request.contextPath}/admin/tasks"
							method="post"
							style="margin-top: 1rem; border-top: 1px solid var(--border-color); padding-top: 1rem;">
							<input type="hidden" name="action" value="create"> <input
								type="hidden" name="eventId" value="${event.id}">
							<div class="form-group">
								<label for="task-description">Neue Aufgabe</label> <input
									type="text" name="description" id="task-description" required
									placeholder="z.B. Mischpult aufbauen">
							</div>
							<button type="submit" class="btn btn-small">Aufgabe
								erstellen</button>
						</form>
					</div>
				</c:if>
				<c:if test="${sessionScope.user.role != 'ADMIN'}">
					<ul id="task-list-user" style="list-style: none; padding: 0;">
						<c:if test="${empty event.eventTasks}">
							<li>Keine Aufgaben vorhanden.</li>
						</c:if>
						<c:forEach var="task" items="${event.eventTasks}">
							<c:if
								test="${fn:contains(task.assignedUsernames, sessionScope.user.username) and task.status == 'OFFEN'}">
								<li id="task-item-user-${task.id}"><label
									style="display: flex; align-items: center; gap: 0.5rem; width: 100%; cursor: pointer;">
										<input type="checkbox" class="task-checkbox"
										data-task-id="${task.id}"
										style="width: auto; height: 1.2rem; flex-shrink: 0;">
										<span><c:out value="${task.description}" /></span>
								</label></li>
							</c:if>
						</c:forEach>
					</ul>
				</c:if>
			</div>
			<div class="card">
				<h2 class="card-title">Event-Chat</h2>
				<div id="chat-box"
					style="height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 0.5rem; margin-bottom: 1rem; background: var(--bg-color);"></div>
				<form id="chat-form" style="display: flex; gap: 0.5rem;">
					<input type="text" id="chat-message-input" class="form-group"
						style="flex-grow: 1; margin: 0;"
						placeholder="Nachricht eingeben...">
					<button type="submit" class="btn">Senden</button>
				</form>
			</div>
		</div>
	</c:if>

	<div class="dashboard-grid">
		<div class="card">
			<h2 class="card-title">Beschreibung</h2>
			<p>
				<c:out
					value="${not empty event.description ? event.description : 'Keine Beschreibung für dieses Event vorhanden.'}" />
			</p>
		</div>
		<div class="card">
			<h2 class="card-title">Benötigter Personalbedarf</h2>
			<ul style="list-style: none; padding: 0;">
				<c:if test="${empty event.skillRequirements}">
					<li>Keine speziellen Qualifikationen benötigt.</li>
				</c:if>
				<c:forEach var="req" items="${event.skillRequirements}">
					<li><strong><c:out value="${req.courseName}" />:</strong> <c:out
							value="${req.requiredPersons}" /> Person(en) benötigt</li>
				</c:forEach>
			</ul>
		</div>
		<div class="card">
			<h2 class="card-title">Reserviertes Material</h2>
			<ul style="list-style: none; padding: 0;">
				<c:if test="${empty event.reservedItems}">
					<li>Kein Material für dieses Event reserviert.</li>
				</c:if>
				<c:forEach var="item" items="${event.reservedItems}">
					<li><c:out value="${item.name}" /> <span><c:out
								value="${item.quantity}" />x</span></li>
				</c:forEach>
			</ul>
		</div>
		<div class="card">
			<h2 class="card-title">Anhänge</h2>
			<ul style="list-style: none; padding: 0;">
				<c:if test="${empty event.attachments}">
					<li>Keine Anhänge für dieses Event vorhanden.</li>
				</c:if>
				<c:forEach var="att" items="${event.attachments}">
					<li><a
						href="${pageContext.request.contextPath}/download?file=${att.filepath}"><c:out
								value="${att.filename}" /></a></li>
				</c:forEach>
			</ul>
		</div>
	</div>

	<div class="card">
		<h2 class="card-title">Zugewiesenes Team</h2>
		<ul style="list-style: none; padding: 0;">
			<c:if test="${empty event.assignedAttendees}">
				<li>Noch kein Team zugewiesen.</li>
			</c:if>
			<c:forEach var="attendee" items="${event.assignedAttendees}">
				<li><a
					href="${pageContext.request.contextPath}/admin/users?action=details&id=${attendee.id}"><c:out
							value="${attendee.username}" /></a></li>
			</c:forEach>
		</ul>
	</div>

	<div style="margin-top: 2rem;">
		<a href="${pageContext.request.contextPath}/events" class="btn">Zurück
			zur Event-Übersicht</a>
	</div>
</div>

<div class="modal-overlay" id="assign-task-modal">
	<div class="modal-content">
		<button class="modal-close-btn">×</button>
		<h3>Aufgabe zuweisen</h3>
		<form action="${pageContext.request.contextPath}/admin/tasks"
			method="post">
			<input type="hidden" name="action" value="assign"> <input
				type="hidden" name="eventId" value="${event.id}"> <input
				type="hidden" name="taskId" id="modal-task-id">
			<div class="form-group">
				<label>Verfügbare Teammitglieder</label>
				<div id="modal-user-checkboxes"
					style="display: flex; flex-direction: column; gap: 0.5rem;">
					<c:forEach var="user" items="${assignedUsers}">
						<label><input type="checkbox" name="userIds"
							value="${user.id}"> <c:out value="${user.username}" /></label>
					</c:forEach>
				</div>
			</div>
			<button type="submit" class="btn">Zuweisung speichern</button>
		</form>
	</div>
</div>

<style>
.details-subtitle {
	font-size: 1.1rem;
	color: var(--text-muted-color);
	margin-bottom: 1.5rem;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.details-list li:last-child {
	border-bottom: none;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // FIX: Robustly get variables passed from the JSP model into JavaScript.
    const contextPath = "${pageContext.request.contextPath}";
    const eventId = "${event.id}";
    const currentUserId = "${sessionScope.user.id}";
    const isAdmin = "${sessionScope.user.role}" === "ADMIN";

    if (!eventId) {
        console.error("Event ID is missing from the page model. Real-time features disabled.");
        return;
    }
    
    // --- Admin-specific JS for task management ---
    if (isAdmin) {
        const assignModal = document.getElementById('assign-task-modal');
        if (assignModal) {
            const modalTaskIdInput = document.getElementById('modal-task-id');
            const modalCloseBtn = assignModal.querySelector('.modal-close-btn');
            
            document.querySelectorAll('.assign-task-btn').forEach(btn => {
				btn.addEventListener('click', (e) => {
					const taskId = e.currentTarget.dataset.taskId;
					if(taskId) {
						modalTaskIdInput.value = taskId;
						assignModal.classList.add('active');
					}
				});
			});
            
            if(modalCloseBtn) modalCloseBtn.addEventListener('click', () => assignModal.classList.remove('active'));
            assignModal.addEventListener('click', e => { if (e.target === assignModal) assignModal.classList.remove('active'); });
        }
        
        document.querySelectorAll('.delete-task-btn').forEach(btn => {
			btn.addEventListener('click', (e) => {
				e.preventDefault();
				const button = e.currentTarget;
				const taskId = button.dataset.taskId;
				const taskDesc = button.dataset.taskDesc;
				const taskItem = document.getElementById(`task-item-${taskId}`);

				if (taskId) {
					showConfirmationModal(`Aufgabe "${taskDesc}" wirklich löschen?`, () => {
						fetch(`${contextPath}/admin/tasks?taskId=${taskId}`, { method: 'DELETE' })
							.then(res => {
								if (res.ok) {
									taskItem.remove();
								} else {
									alert('Löschen fehlgeschlagen!');
								}
							});
					});
				}
			});
		});
    }

    // --- User-specific JS for completing tasks ---
    document.querySelectorAll('.task-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
			const taskId = e.target.dataset.taskId;
            const params = new URLSearchParams({ taskId: taskId, status: e.target.checked ? 'ERLEDIGT' : 'OFFEN' });
            fetch(`${contextPath}/task-action`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: params })
                .then(res => {
                    if (res.ok) {
                        if (e.target.checked) e.target.closest('li').style.display = 'none';
                    } else { e.target.checked = !e.target.checked; alert('Status konnte nicht aktualisiert werden.'); }
                }).catch(() => { e.target.checked = !e.target.checked; alert('Netzwerkfehler.'); });
        });
    });

    // --- JS for Event Chat (if present) ---
    const chatBox = document.getElementById('chat-box');
    if (chatBox) {
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-message-input');
        
        const fetchMessages = () => {
			// FIX: Use the robust eventId variable.
            fetch(`${contextPath}/api/event-chat?eventId=${eventId}`)
                .then(res => {
					if (!res.ok) { throw new Error(`HTTP error! status: ${res.status}`); }
					return res.json();
				})
                .then(messages => {
                    chatBox.innerHTML = ''; 
                    if (messages && messages.length > 0) {
                        messages.forEach(msg => {
                            const p = document.createElement('p');
                            p.style.marginBottom = '0.25rem';
                            if (msg.userId == currentUserId) p.style.textAlign = 'right';
                            
                            const strong = document.createElement('strong');
                            strong.textContent = msg.username + ': ';
                            if (msg.userId == currentUserId) strong.style.color = 'var(--primary-color)';

                            p.appendChild(strong);
                            p.appendChild(document.createTextNode(msg.messageText));
                            chatBox.appendChild(p);
                        });
                    } else {
                        const p = document.createElement('p');
                        p.textContent = 'Noch keine Nachrichten.';
                        p.style.cssText = 'color:var(--text-muted-color); text-align: center; padding-top: 1rem;';
                        chatBox.appendChild(p);
                    }
                    chatBox.scrollTop = chatBox.scrollHeight;
                }).catch(error => console.error("Error fetching chat messages:", error));
        };
        
        chatForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) {
                const formData = new URLSearchParams({ eventId: eventId, messageText: message });
                fetch(`${contextPath}/api/event-chat`, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: formData })
                    .then(res => { 
                        if (res.ok) { 
                            chatInput.value = ''; 
                            fetchMessages();
                        } else { 
                            alert('Nachricht konnte nicht gesendet werden.'); 
                        } 
                    })
                    .catch(() => alert('Netzwerkfehler beim Senden.'));
            }
        });
        
        setInterval(fetchMessages, 3000);
        fetchMessages();
    }
});
</script>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\events.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Veranstaltungen" />
	<c:param name="navType" value="user" />
</c:import>

<h1>Anstehende Veranstaltungen</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter" placeholder="Events filtern..."
			style="width: 100%;" aria-label="Events filtern">
	</div>
</div>

<c:if test="${empty events}">
	<div class="card">
		<p>Für dich stehen derzeit keine Veranstaltungen an, für die du
			qualifiziert bist.</p>
	</div>
</c:if>

<div class="table-wrapper">
	<table class="data-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Veranstaltung</th>
				<th class="sortable" data-sort-type="date">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Dein Status</th>
				<th>Aktion</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="event" items="${events}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/eventDetails?id=${event.id}"><c:out
								value="${event.name}" /></a></td>
					<td data-sort-value="${event.eventDateTime}"><c:out
							value="${event.formattedEventDateTimeRange}" /></td>
					<td><c:choose>
							<c:when test="${event.userAttendanceStatus == 'ZUGEWIESEN'}">
								<strong class="text-success">Zugewiesen</strong>
							</c:when>
							<c:when test="${event.userAttendanceStatus == 'ANGEMELDET'}">
								<span class="text-success">Angemeldet</span>
							</c:when>
							<c:when test="${event.userAttendanceStatus == 'ABGEMELDET'}">
								<span class="text-danger">Abgemeldet</span>
							</c:when>
							<c:otherwise>Offen</c:otherwise>
						</c:choose></td>
					<td><c:if test="${event.userAttendanceStatus != 'ZUGEWIESEN'}">
							<form action="${pageContext.request.contextPath}/event-action"
								method="post" style="display: flex; gap: 0.5rem;">
								<input type="hidden" name="eventId" value="${event.id}">
								<c:if
									test="${event.userAttendanceStatus == 'OFFEN' or event.userAttendanceStatus == 'ABGEMELDET'}">
									<button type="submit" name="action" value="signup"
										class="btn btn-small btn-success">Anmelden</button>
								</c:if>
								<c:if test="${event.userAttendanceStatus == 'ANGEMELDET'}">
									<button type="submit" name="action" value="signoff"
										class="btn btn-small btn-danger">Abmelden</button>
								</c:if>
							</form>
						</c:if></td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\home.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Home" />
	<c:param name="navType" value="user" />
</c:import>

<h1>
	Willkommen zurück,
	<c:out value="${sessionScope.user.username}" />
	!
</h1>

<div class="dashboard-grid">
	<div class="card">
		<h2 class="card-title">Deine nächsten 3 Veranstaltungen</h2>
		<c:choose>
			<c:when test="${not empty upcomingEvents}">
				<ul style="list-style: none; padding-left: 0;">
					<c:forEach var="event" items="${upcomingEvents}" varStatus="loop">
						<li
							style="padding: 0.5rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
							<a
							href="${pageContext.request.contextPath}/eventDetails?id=${event.id}"><c:out
									value="${event.name}" /></a> <br> <small><c:out
									value="${event.formattedEventDateTimeRange}" /></small>
						</li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Keine anstehenden Veranstaltungen.</p>
			</c:otherwise>
		</c:choose>
	</div>
	<div class="card">
		<h2 class="card-title">Deine nächsten 3 Lehrgänge/Meetings</h2>
		<c:choose>
			<c:when test="${not empty upcomingMeetings}">
				<ul style="list-style: none; padding-left: 0;">
					<c:forEach var="meeting" items="${upcomingMeetings}"
						varStatus="loop">
						<li
							style="padding: 0.5rem 0; ${!loop.last ? 'border-bottom: 1px solid var(--border-color);' : ''}">
							<a
							href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}"><c:out
									value="${meeting.name}" /></a> <br> <small><c:out
									value="${meeting.formattedMeetingDateTimeRange}" /></small>
						</li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Keine anstehenden Lehrgänge.</p>
			</c:otherwise>
		</c:choose>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\lager.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8" isELIgnored="false" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Lager"/>
</c:import>

<h1><i class="fas fa-boxes"></i> Lagerübersicht</h1>
<p>Hier finden Sie eine Übersicht aller erfassten Artikel im Lager.</p>

<%-- Session Messages --%>
<c:if test="${not empty sessionScope.successMessage}"><p class="success-message"><c:out value="${sessionScope.successMessage}"/></p><c:remove var="successMessage" scope="session"/></c:if>
<c:if test="${not empty sessionScope.errorMessage}"><p class="error-message"><c:out value="${sessionScope.errorMessage}"/></p><c:remove var="errorMessage" scope="session"/></c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter" placeholder="Alle Artikel filtern..." aria-label="Lager filtern">
	</div>
</div>

<c:if test="${empty storageData}">
	<div class="card"><p>Derzeit sind keine Artikel im Lager erfasst.</p></div>
</c:if>

<c:forEach var="locationEntry" items="${storageData}">
	<div class="card">
		<h2><i class="fas fa-map-marker-alt"></i> <c:out value="${locationEntry.key}" /></h2>
        <div class="table-wrapper">
            <table class="data-table searchable-table">
                <thead>
                    <tr>
                        <th>Gerät</th>
                        <th>Verfügbar</th>
                        <th>Defekt</th>
                        <th>Status</th>
                        <th>Aktion</th>
                    </tr>
                </thead>
                <tbody>
                    <c:forEach var="item" items="${locationEntry.value}">
                        <tr class="${item.defectiveQuantity > 0 ? 'item-status-defect' : ''}">
                            <td><a href="#" class="item-details-trigger" data-item-id="${item.id}"><c:out value="${item.name}" /></a></td>
                            <td>${item.availableQuantity} / ${item.quantity}</td>
                            <td>${item.defectiveQuantity}</td>
                            <td><span class="status-badge ${item.availabilityStatusCssClass}"><c:out value="${item.availabilityStatus}" /></span></td>
                            <td>
                                <button class="btn btn-small transaction-btn"
                                    data-item-id="${item.id}"
                                    data-item-name="${fn:escapeXml(item.name)}"
                                    data-max-qty="${item.availableQuantity}" ${item.availableQuantity <= 0 ? 'disabled' : ''}>
                                    Entnehmen/Einräumen
                                </button>
                            </td>
                        </tr>
                    </c:forEach>
                </tbody>
            </table>
        </div>
	</div>
</c:forEach>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const contextPath = "${'${pageContext.request.contextPath}'}"; // Escaped for JS
    // Lightbox Logic
    const lightbox = document.getElementById('lightbox');
    if (lightbox) {
        const lightboxImage = lightbox.querySelector('img');
        document.querySelectorAll('.lightbox-trigger').forEach(trigger => {
            trigger.addEventListener('click', (e) => {
                e.preventDefault();
                lightboxImage.setAttribute('src', trigger.dataset.src);
                lightbox.classList.add('active');
            });
        });
        lightbox.addEventListener('click', () => lightbox.classList.remove('active'));
    }

    // Transaction Modal Logic
    const transactionModal = document.getElementById('transaction-modal');
    if (transactionModal) {
        const modalTitle = document.getElementById('transaction-modal-title');
        const modalItemId = document.getElementById('transaction-item-id');
        const modalType = document.getElementById('transaction-type');
        const closeModalBtn = transactionModal.querySelector('.modal-close-btn');

        const openModal = (btn) => {
            const type = btn.dataset.type;
            const actionText = type === 'checkin' ? 'Einräumen' : 'Entnehmen';
            modalTitle.textContent = `${btn.dataset.itemName} ${actionText}`;
            modalItemId.value = btn.dataset.itemId;
            modalType.value = type;
            transactionModal.classList.add('active');
        };

        const closeModal = () => transactionModal.classList.remove('active');

        document.querySelectorAll('.transaction-btn').forEach(btn => {
            btn.addEventListener('click', () => openModal(btn));
        });

        closeModalBtn.addEventListener('click', closeModal);
        transactionModal.addEventListener('click', e => {
            if (e.target === transactionModal) closeModal();
        });
    }

    // Item Details & History Modal Logic
    const detailsModal = document.getElementById('item-details-modal');
    if(detailsModal) {
        const detailsTitle = document.getElementById('details-modal-title');
        const historyContainer = document.getElementById('item-history-container');
        const closeDetailsBtn = detailsModal.querySelector('.modal-close-btn');

        const fetchAndShowHistory = async (itemId, itemName) => {
            detailsTitle.textContent = `Verlauf für: ${itemName}`;
            historyContainer.innerHTML = '<p>Lade Verlauf...</p>';
            detailsModal.classList.add('active');
            try {
                const response = await fetch(`${contextPath}/api/storage-history?itemId=${itemId}`);
                if (!response.ok) throw new Error('Network response was not ok');
                const history = await response.json();
                
                let html = '<ul class="details-list">';
                if (history.length > 0) {
                    history.forEach(entry => {
                        const changeClass = entry.quantityChange > 0 ? 'text-success' : 'text-danger';
                        const changeSign = entry.quantityChange > 0 ? '+' : '';
                        html += `<li>
                                    <div>
                                        <strong class="${changeClass}">${changeSign}${entry.quantityChange} Stück</strong>
                                        von <strong>${entry.username}</strong>
                                        <br>
                                        <small>${entry.notes || 'Keine Notiz'}</small>
                                    </div>
                                    <small>${entry.transactionTimestampLocaleString}</small> 
                                 </li>`;
                    });
                } else {
                    html += '<li>Kein Verlauf für diesen Artikel vorhanden.</li>';
                }
                html += '</ul>';
                historyContainer.innerHTML = html;

            } catch (error) {
                historyContainer.innerHTML = '<p class="error-message">Verlauf konnte nicht geladen werden.</p>';
                console.error('Fetch error:', error);
            }
        };
        
        document.querySelectorAll('.item-details-trigger').forEach(trigger => {
            trigger.addEventListener('click', (e) => {
                e.preventDefault();
                const itemId = trigger.dataset.itemId;
                const itemName = trigger.textContent;
                fetchAndShowHistory(itemId, itemName);
            });
        });

        closeDetailsBtn.addEventListener('click', () => detailsModal.classList.remove('active'));
        detailsModal.addEventListener('click', e => {
            if (e.target === detailsModal) detailsModal.classList.remove('active');
        });
    }
});
</script>
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\lehrgaenge.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Lehrgänge" />
	<c:param name="navType" value="user" />
</c:import>

<h1>Anstehende Lehrgänge & Meetings</h1>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="table-controls">
	<div class="form-group" style="margin-bottom: 0; flex-grow: 1;">
		<input type="search" id="table-filter"
			placeholder="Lehrgänge filtern..." style="width: 100%;"
			aria-label="Lehrgänge filtern">
	</div>
</div>

<c:if test="${empty meetings}">
	<div class="card">
		<p>Derzeit stehen keine Lehrgänge oder Meetings an.</p>
	</div>
</c:if>

<div class="table-wrapper">
	<table class="data-table sortable-table searchable-table">
		<thead>
			<tr>
				<th class="sortable" data-sort-type="string">Meeting</th>
				<th class="sortable" data-sort-type="string">Gehört zu Kurs</th>
				<th class="sortable" data-sort-type="date">Datum & Uhrzeit</th>
				<th class="sortable" data-sort-type="string">Dein Status</th>
				<th>Aktion</th>
			</tr>
		</thead>
		<tbody>
			<c:forEach var="meeting" items="${meetings}">
				<tr>
					<td><a
						href="${pageContext.request.contextPath}/meetingDetails?id=${meeting.id}"><c:out
								value="${meeting.name}" /></a></td>
					<td><c:out value="${meeting.parentCourseName}" /></td>
					<td data-sort-value="${meeting.meetingDateTime}"><c:out
							value="${meeting.formattedMeetingDateTimeRange}" /></td>
					<td><c:choose>
							<c:when test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
								<span style="color: var(--success-color);">Angemeldet</span>
							</c:when>
							<c:when test="${meeting.userAttendanceStatus == 'ABGEMELDET'}">
								<span style="color: var(--danger-color);">Abgemeldet</span>
							</c:when>
							<c:otherwise>Offen</c:otherwise>
						</c:choose></td>
					<td>
						<form action="${pageContext.request.contextPath}/meeting-action"
							method="post" style="display: flex; gap: 0.5rem;">
							<input type="hidden" name="meetingId" value="${meeting.id}">
							<c:if test="${meeting.userAttendanceStatus != 'ANGEMELDET'}">
								<button type="submit" name="action" value="signup"
									class="btn btn-small btn-success">Anmelden</button>
							</c:if>
							<c:if test="${meeting.userAttendanceStatus == 'ANGEMELDET'}">
								<button type="submit" name="action" value="signoff"
									class="btn btn-small btn-danger">Abmelden</button>
							</c:if>
						</form>
					</td>
				</tr>
			</c:forEach>
		</tbody>
	</table>
</div>

<c:import url="/WEB-INF/jspf/table-helper.jspf" />
<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\login.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%-- FIX: This page no longer imports the standard header/nav to be a clean, standalone page. --%>
<!DOCTYPE html>
<html lang="de" data-theme="light">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Anmeldung - TechnikTeam</title>
<link rel="stylesheet"
	href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet"
	href="${pageContext.request.contextPath}/css/style.css">
</head>
<body data-context-path="${pageContext.request.contextPath}">

	<div class="login-page-container">
		<div class="login-box">
			<h1>
				<i class="fas fa-bolt"></i> TechnikTeam
			</h1>

			<c:if test="${not empty errorMessage}">
				<p class="error-message" id="error-message">
					<c:out value="${errorMessage}" />
				</p>
			</c:if>

			<form action="<c:url value='/login'/>" method="post">
				<div class="form-group">
					<label for="username">Benutzername</label> <input type="text"
						id="username" name="username" required autocomplete="username"
						autofocus>
				</div>
				<div class="form-group">
					<label for="password">Passwort</label> <input type="password"
						id="password" name="password" required
						autocomplete="current-password">
				</div>
				<button type="submit" class="btn" style="width: 100%;">Anmelden</button>
			</form>
			<div
				style="text-align: center; margin: 1rem 0; color: var(--text-muted-color);">ODER</div>
			<button id="passkey-login-btn" class="btn"
				style="width: 100%; background-color: var(--text-muted-color); border-color: var(--text-muted-color);">
				<i class="fas fa-fingerprint"></i> Mit Passkey anmelden
			</button>
		</div>
	</div>

	<script>
// This script is self-contained as main.js is not included on this page.
document.addEventListener('DOMContentLoaded', () => {
    const contextPath = document.body.dataset.contextPath || '';

    // Passkey Login Logic
    const passkeyLoginBtn = document.getElementById('passkey-login-btn');
    const errorMessageElement = document.getElementById('error-message');

    if (passkeyLoginBtn) {
        passkeyLoginBtn.addEventListener('click', async () => {
            try {
                const startResp = await fetch(`${contextPath}/api/passkey/login/start`, { method: 'POST' });
                if (!startResp.ok) throw new Error('Could not start passkey login.');
                const requestOptionsJson = await startResp.json();
                
                // Decode from server's Base64URL to ArrayBuffer for the browser API
                requestOptionsJson.challenge = bufferDecode(requestOptionsJson.challenge);
                if (requestOptionsJson.allowCredentials) {
                    for (let cred of requestOptionsJson.allowCredentials) {
                        cred.id = bufferDecode(cred.id);
                    }
                }

                const assertion = await navigator.credentials.get({ publicKey: requestOptionsJson });

                const verificationResp = await fetch(`${contextPath}/api/passkey/login/finish`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: assertion.id,
                        rawId: bufferEncode(assertion.rawId),
                        response: {
                            authenticatorData: bufferEncode(assertion.response.authenticatorData),
                            clientDataJSON: bufferEncode(assertion.response.clientDataJSON),
                            signature: bufferEncode(assertion.response.signature),
                            userHandle: assertion.response.userHandle ? bufferEncode(assertion.response.userHandle) : null,
                        },
                        type: assertion.type
                    })
                });

                if (verificationResp.ok) {
                    window.location.href = `${contextPath}/home`;
                } else {
                    const errorText = await verificationResp.text();
                    if(errorMessageElement) errorMessageElement.textContent = `Passkey Login fehlgeschlagen: ${errorText}`;
                }

            } catch (err) {
                console.error('Passkey login error:', err);
                if(errorMessageElement) errorMessageElement.textContent = 'Passkey-Operation fehlgeschlagen oder abgebrochen.';
            }
        });
    }

    // Helper functions for base64url encoding/decoding
    function bufferDecode(value) {
        const str = value.replace(/-/g, '+').replace(/_/g, '/');
        const decoded = atob(str);
        const buffer = new Uint8Array(decoded.length);
        for (let i = 0; i < decoded.length; i++) {
            buffer[i] = decoded.charCodeAt(i);
        }
        return buffer.buffer;
    }

    function bufferEncode(value) {
        return btoa(String.fromCharCode.apply(null, new Uint8Array(value)))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
});
</script>
</body>
</html>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\logout.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<%--
  logout.jsp
  
  This is a confirmation page shown to the user immediately after they have
  logged out. It displays a personalized message and uses JavaScript to
  automatically redirect the user to the login page after a short delay.
  
  - It is served by: LogoutServlet (via redirect).
  - Expected parameters:
    - 'username' (String): The name of the user who just logged out.
--%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="title" value="Logout" />
</c:import>

<div style="text-align: center; margin-top: 5rem; padding: 2rem;">
	<h1>
		<c:out value="${not empty param.username ? param.username : 'Du'}" />
		, du wurdest erfolgreich ausgeloggt!
	</h1>
	<p>Du wirst in 5 Sekunden automatisch zur Login-Seite
		weitergeleitet.</p>
	<p>
		<a href="${pageContext.request.contextPath}/login">Jetzt zur
			Login-Seite</a>
	</p>
</div>

<script>
	setTimeout(function() {
		// Use the contextPath to build the URL safely, making it robust
		// even if the application is deployed under a different name.
		window.location.href = "${pageContext.request.contextPath}/login";
	}, 5000); // 5000 milliseconds = 5 seconds
</script>

</body>
</html>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\meetingDetails.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Meeting-Details" />
	<c:param name="navType" value="user" />
</c:import>

<div style="max-width: 800px; margin: 0 auto;">
	<h1>
		<c:out value="${meeting.name}" />
	</h1>
	<p
		style="color: var(--text-muted-color); margin-top: -1rem; margin-bottom: 2rem;">
		Teil des Lehrgangs: <strong><c:out
				value="${meeting.parentCourseName}" /></strong>
	</p>

	<div class="card">
		<h2>Details</h2>
		<ul style="list-style: none; padding: 0;">
			<li
				style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Termin:</strong>
				<c:out value="${meeting.formattedMeetingDateTimeRange}" /></li>
			<li
				style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Ort:</strong>
				<c:out
					value="${not empty meeting.location ? meeting.location : 'N/A'}" /></li>
			<li
				style="padding: 0.75rem 0; display: flex; justify-content: space-between;"><strong>Leitung:</strong>
				<c:out
					value="${not empty meeting.leaderUsername ? meeting.leaderUsername : 'N/A'}" /></li>
		</ul>
	</div>

	<div class="card">
		<h2>Beschreibung</h2>
		<p>
			<c:out
				value="${not empty meeting.description ? meeting.description : 'Keine Beschreibung vorhanden.'}" />
		</p>
	</div>

	<div class="card">
		<h2>Anhänge</h2>
		<c:choose>
			<c:when test="${not empty attachments}">
				<ul style="list-style: none; padding: 0;">
					<c:forEach var="att" items="${attachments}">
						<li
							style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;"><a
							href="${pageContext.request.contextPath}/download?file=${att.filepath}"><c:out
									value="${att.filename}" /></a> <c:if
								test="${sessionScope.user.role == 'ADMIN'}">
								<small
									style="color: var(--text-muted-color); margin-left: 1rem;">(Sichtbar
									für: <c:out value="${att.requiredRole}" />)
								</small>
							</c:if></li>
					</c:forEach>
				</ul>
			</c:when>
			<c:otherwise>
				<p>Für dieses Meeting gibt es keine Anhänge.</p>
			</c:otherwise>
		</c:choose>
	</div>

	<a href="${pageContext.request.contextPath}/lehrgaenge" class="btn"
		style="margin-top: 1rem;"> « Zurück zur Übersicht </a>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\passkeys.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Passkeys verwalten" />
</c:import>

<h1>
	<i class="fas fa-fingerprint"></i> Passkeys verwalten
</h1>
<p>Hier können Sie Passkeys hinzufügen oder entfernen, um sich
	passwortlos anzumelden.</p>

<c:if test="${not empty sessionScope.successMessage}">
	<p class="success-message">
		<c:out value="${sessionScope.successMessage}" />
	</p>
	<c:remove var="successMessage" scope="session" />
</c:if>
<c:if test="${not empty sessionScope.errorMessage}">
	<p class="error-message">
		<c:out value="${sessionScope.errorMessage}" />
	</p>
	<c:remove var="errorMessage" scope="session" />
</c:if>

<div class="card">
	<div class="table-controls">
		<h2>Ihre registrierten Passkeys</h2>
		<button id="add-passkey-btn" class="btn">
			<i class="fas fa-plus"></i> Neuen Passkey hinzufügen
		</button>
	</div>

	<div class="desktop-table-wrapper">
		<table class="desktop-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>Registriert am</th>
					<th>Aktion</th>
				</tr>
			</thead>
			<tbody>
				<c:if test="${empty passkeys}">
					<tr>
						<td colspan="3" style="text-align: center;">Sie haben noch
							keine Passkeys registriert.</td>
					</tr>
				</c:if>
				<c:forEach var="key" items="${passkeys}">
					<tr>
						<td><c:out value="${key.name}" /></td>
						<td><c:out value="${key.formattedCreatedAt}" /></td>
						<td>
							<form action="${pageContext.request.contextPath}/passkeys"
								method="post" class="js-confirm-form"
								data-confirm-message="Passkey '${fn:escapeXml(key.name)}' wirklich entfernen?">
								<input type="hidden" name="action" value="delete"> <input
									type="hidden" name="id" value="${key.id}">
								<button type="submit" class="btn btn-small btn-danger">
									<i class="fas fa-trash"></i> Entfernen
								</button>
							</form>
						</td>
					</tr>
				</c:forEach>
			</tbody>
		</table>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

<script>
document.addEventListener('DOMContentLoaded', () => {
    const contextPath = document.body.dataset.contextPath || '';
    const addPasskeyBtn = document.getElementById('add-passkey-btn');

    document.querySelectorAll('.js-confirm-form').forEach(form => {
        form.addEventListener('submit', function (e) {
            e.preventDefault();
            const message = this.dataset.confirmMessage || 'Sind Sie sicher?';
            showConfirmationModal(message, () => this.submit());
        });
    });

    if (addPasskeyBtn) {
        addPasskeyBtn.addEventListener('click', async () => {
            const passkeyName = prompt("Bitte geben Sie einen Namen für diesen Passkey ein (z.B. 'Mein Laptop', 'Handy'):", "Neuer Passkey");
            if (!passkeyName) {
                alert("Registrierung abgebrochen.");
                return;
            }

            try {
                const startResp = await fetch(`${contextPath}/api/passkey/register/start`, { method: 'POST' });
                if (!startResp.ok) throw new Error('Could not start passkey registration.');
                const creationOptions = await startResp.json();
                
                creationOptions.challenge = bufferDecode(creationOptions.challenge);
                creationOptions.user.id = bufferDecode(creationOptions.user.id);
                if (creationOptions.excludeCredentials) {
                     creationOptions.excludeCredentials.forEach(cred => {
                        cred.id = bufferDecode(cred.id);
                    });
                }
                
                const newCredential = await navigator.credentials.create({ publicKey: creationOptions });

                // FIX: The JavaScript function encodeURIComponent is used here correctly.
                const finishUrl = `${contextPath}/api/passkey/register/finish?name=${encodeURIComponent(passkeyName)}`;
                const finishResp = await fetch(finishUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: newCredential.id,
                        rawId: bufferEncode(newCredential.rawId),
                        type: newCredential.type,
                        response: {
                            attestationObject: bufferEncode(newCredential.response.attestationObject),
                            clientDataJSON: bufferEncode(newCredential.response.clientDataJSON),
                        },
                    }),
                });

                if (finishResp.ok) {
                    alert('Passkey erfolgreich registriert!');
                    location.reload();
                } else {
                    const error = await finishResp.text();
                    throw new Error('Passkey-Registrierung fehlgeschlagen: ' + error);
                }

            } catch (err) {
                console.error("Passkey registration failed:", err);
                alert("Fehler bei der Passkey-Registrierung: " + err.message);
            }
        });
    }

    function bufferDecode(value) {
        const str = value.replace(/-/g, '+').replace(/_/g, '/');
        const decoded = atob(str);
        const buffer = new Uint8Array(decoded.length);
        for (let i = 0; i < decoded.length; i++) {
            buffer[i] = decoded.charCodeAt(i);
        }
        return buffer.buffer;
    }

    function bufferEncode(value) {
        return btoa(String.fromCharCode.apply(null, new Uint8Array(value)))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }
});
</script>

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\passwort.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Passwort ändern" />
	<c:param name="navType" value="user" />
</c:import>

<div style="max-width: 600px; margin: auto;">
	<div class="card">
		<h1>Passwort ändern</h1>

		<c:if test="${not empty successMessage}">
			<p class="success-message">
				<c:out value="${successMessage}" />
			</p>
		</c:if>
		<c:if test="${not empty errorMessage}">
			<p class="error-message">
				<c:out value="${errorMessage}" />
			</p>
		</c:if>

		<form action="${pageContext.request.contextPath}/passwort"
			method="post">
			<div class="form-group">
				<label for="currentPassword">Aktuelles Passwort</label> <input
					type="password" id="currentPassword" name="currentPassword"
					required autocomplete="current-password">
			</div>
			<div class="form-group">
				<label for="newPassword">Neues Passwort</label> <input
					type="password" id="newPassword" name="newPassword" required
					autocomplete="new-password">
			</div>
			<div class="form-group">
				<label for="confirmPassword">Neues Passwort bestätigen</label> <input
					type="password" id="confirmPassword" name="confirmPassword"
					required autocomplete="new-password">
			</div>
			<button type="submit" class="btn">Passwort speichern</button>
		</form>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\storage_item_details.jsp
========================================================================

<%@ page contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"
	isELIgnored="false"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%>

<c:import url="/WEB-INF/jspf/header.jspf">
	<c:param name="pageTitle" value="Artikeldetails" />
</c:import>

<h1>Artikeldetails</h1>

<div class="card" style="max-width: 600px; margin: 1rem auto;">
	<h2 class="card-title">
		<c:out value="${item.name}" />
	</h2>

	<ul style="list-style: none; padding: 0;">
		<li
			style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Status:</strong>
			<span class="status-badge ${item.availabilityStatusCssClass}">
				<c:out value="${item.availabilityStatus}" />
		</span></li>
		<li
			style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Verfügbare
				Anzahl:</strong> <c:out value="${item.availableQuantity}" /></li>
		<li
			style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Defekte
				Anzahl:</strong> <c:out value="${item.defectiveQuantity}" /></li>
		<li
			style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Ort:</strong>
			<c:out value="${item.location}" /></li>
		<li
			style="padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between;"><strong>Schrank:</strong>
			<c:out value="${not empty item.cabinet ? item.cabinet : 'N/A'}" /></li>
	</ul>

	<div style="margin-top: 2rem;">
		<a href="<c:url value='/lager'/>" class="btn">Zurück zur
			Lagerübersicht</a>
	</div>
</div>

<c:import url="/WEB-INF/jspf/footer.jspf" />
