
========================================================================
FILE: pom.xml
========================================================================

<?xml version="1.0" encoding="UTF-8"?>

<project xmlns="http://maven.apache.org/POM/4.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<!--
  SECURITY-AUDIT RECOMMENDATION (CWE-1104):
  Integrate an automated dependency vulnerability scanner to mitigate risks from
  vulnerable and outdated components. It is recommended to add the OWASP
  Dependency-Check Maven plugin to the <build><plugins> section and configure it
  to run as part of the CI/CD pipeline.
-->
<modelVersion>4.0.0</modelVersion>
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.3.1</version>
		<relativePath /> 
</parent>

<groupId>de.technikteam</groupId>
<artifactId>TechnikTeam</artifactId>
<version>2.0.0-SNAPSHOT</version>
<packaging>jar</packaging>

<name>TechnikTeam</name>

<properties>
    <java.version>21</java.version>
    <springdoc-openapi.version>2.5.0</springdoc-openapi.version>
    <jjwt.version>0.12.5</jjwt.version>
    <ical4j.version>3.2.4</ical4j.version>
    <diffutils.version>1.3.0</diffutils.version>
    <!-- REMOVED <webauthn.version>2.2.0</webauthn.version> -->
    <commons-io.version>2.16.1</commons-io.version>
    <owasp-java-html-sanitizer.version>20230925.1</owasp-java-html-sanitizer.version>
    <bucket4j.version>8.9.0</bucket4j.version>
</properties>

<dependencies>

    <!-- Spring Boot Starters -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-websocket</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-log4j2</artifactId>
    </dependency>

    <!-- Database & Migrations -->
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-core</artifactId>
    </dependency>
    <dependency>
        <groupId>org.flywaydb</groupId>
        <artifactId>flyway-mysql</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mariadb.jdbc</groupId>
        <artifactId>mariadb-java-client</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!-- Security & Authentication -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>${jjwt.version}</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>${jjwt.version}</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
        <version>${jjwt.version}</version>
        <scope>runtime</scope>
    </dependency>
    <!-- REMOVED YUBICO DEPENDENCY BLOCK -->
    <dependency>
        <groupId>com.google.guava</groupId>
        <artifactId>guava</artifactId>
        <version>32.1.2-jre</version>
    </dependency>
    <dependency>
        <groupId>com.googlecode.java-diff-utils</groupId>
        <artifactId>diffutils</artifactId>
        <version>${diffutils.version}</version>
    </dependency>
    <dependency>
        <groupId>com.google.code.gson</groupId>
        <artifactId>gson</artifactId>
    </dependency>
	    <dependency>
	    <groupId>com.googlecode.owasp-java-html-sanitizer</groupId>
	    <artifactId>owasp-java-html-sanitizer</artifactId>
	    <version>20240325.1</version> 
	</dependency>
    <dependency>
        <groupId>com.bucket4j</groupId>
        <artifactId>bucket4j-core</artifactId>
        <version>${bucket4j.version}</version>
    </dependency>

    <!-- API Documentation -->
    <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
        <version>${springdoc-openapi.version}</version>
    </dependency>

    <!-- Utilities -->
    <dependency>
	    <groupId>org.mnode.ical4j</groupId>
	    <artifactId>ical4j</artifactId>
	    <version>${ical4j.version}</version>
	</dependency>
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
    </dependency>
    <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>${commons-io.version}</version>
    </dependency>
    <dependency>
	    <groupId>org.apache.logging.log4j</groupId>
	    <artifactId>log4j-layout-template-json</artifactId>
	</dependency>

    <!-- Testing -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>

<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        
        <plugin>
		    <groupId>org.flywaydb</groupId>
		    <artifactId>flyway-maven-plugin</artifactId>
		    <configuration>
		        <configFile>flyway.conf</configFile>
		    </configuration>
		</plugin>
        
        <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <configuration>
                <source>${java.version}</source>
                <target>${java.version}</target>
            </configuration>
        </plugin>
</plugins>
</build>
</project>
========================================================================
FILE: README.md
========================================================================

# TechnikTeam - School Event & Crew Management System v2.0

![Spring Boot](https://img.shields.io/badge/Spring_Boot-3.3+-6DB33F?style=for-the-badge&logo=spring&logoColor=white)
![React](https://img.shields.io/badge/React-18+-61DAFB?style=for-the-badge&logo=react&logoColor=black)
![Vite](https://img.shields.io/badge/Vite-5+-646CFF?style=for-the-badge&logo=vite&logoColor=white)
![Java](https://img.shields.io/badge/Java-21+-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![MySQL](https://img.shields.io/badge/MySQL-8.0-4479A1?style=for-the-badge&logo=mysql&logoColor=white)

A comprehensive web application designed to manage a school's event technology crew ("Technik-Team"). The platform provides tools for event planning, user management, inventory tracking, and skill development, all within a granular, permission-based access control system. This version is a complete rewrite using a modern Spring Boot REST API and a React single-page application frontend.

## Key Features

### 👑 Admin-Specific Features
*   **Central Dashboard**: At-a-glance view of key metrics like upcoming events, low-stock items, and event trends.
*   **User Management**: Full CRUD functionality for user accounts with a flexible permission-based system.
*   **Event Management**: Create events with skill requirements, reserve inventory, upload files, and manage the event lifecycle.
*   **Training & Qualification**: Define course templates, schedule meetings, and track user qualifications with an interactive matrix.
*   **Inventory Management**: Full CRUD for all inventory items, including location details, quantity, images, and maintenance logs.
*   **Kit Management**: Create reusable "kits" or "cases" of equipment with printable packing lists via QR codes.
*   **File & Document Hub**: Manage file categories and upload documents with role-based access control.
*   **Feedback Kanban Board**: Manage user feedback and suggestions through a visual board.
*   **Audit Trail**: A detailed log of all administrative actions for accountability.
*   **System Monitoring**: View live server statistics, including CPU, memory, and disk usage.

### 👥 User-Facing Features
*   **Personalized Homepage**: A dashboard showing upcoming events, assigned tasks, and training meetings.
*   **Event System**: View and sign up for upcoming events, and access real-time tools like chat and task lists for "running" events.
*   **Training Hub**: View and sign up for upcoming course meetings to gain new qualifications.
*   **Inventory Browser**: Browse the entire equipment inventory and view item details.
*   **Profile Management**: Update personal details, change passwords, and manage passwordless login with Passkeys/WebAuthn.
*   **Calendar**: View all upcoming events and meetings in a list or calendar view, with an option to subscribe via an iCal feed.

## Technology Stack

*   **Backend**: Spring Boot 3.3, Java 21
    *   **Security**: Spring Security 6 with JWT Authentication via HttpOnly Cookies
    *   **Database**: Spring Data JDBC, MariaDB/MySQL
    *   **Migrations**: Flyway
    *   **Real-time**: Spring WebSocket
*   **Frontend**: React 18, Vite 5
    *   **Routing**: React Router
    *   **State Management**: Zustand
    *   **Styling**: Plain CSS with custom properties for theming
*   **API Documentation**: Springdoc OpenAPI (Swagger UI)
*   **Build Tool**: Apache Maven

## Setup and Installation

Follow these steps to get a local instance of the application running for development.

### 1. Prerequisites
*   Java Development Kit (JDK) 21 or higher
*   Apache Maven 3.8+
*   Node.js 20+ (with npm)
*   MySQL Server 8.0+ or MariaDB 10.6+

### 2. Database Setup
1.  Create a new database in your database server:
    ```sql
    CREATE DATABASE technik_team_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```
2.  Create a dedicated database user with privileges on this database.

### 3. Backend Configuration & Setup
1.  Navigate to the project's root directory.
2.  Open `src/main/resources/application.properties`.
3.  Update the `spring.datasource.*` properties to match your database connection details.
4.  Set a strong, unique secret for `jwt.secret`. This is critical for security. It **must** be at least 32 characters long.
5.  Set the `upload.directory` to an absolute path on your local machine. This directory must exist and be writable by the application.
6.  The application uses Flyway for database migrations. The necessary tables will be created automatically when the application starts for the first time.

**First-time Setup Note:** The application includes a component (`InitialAdminCreator.java`) that checks if an 'admin' user exists on first startup. If not, it creates a default `admin` user with full permissions and a strong, random password. This password is printed to the console **only once** on the very first startup. Please copy this password immediately and store it securely. Note that a Flyway migration (`V22`) is included to remove any legacy, insecurely created admin users from previous development versions.

### 4. Backend Launch
1.  From the project's root directory, run the Spring Boot application using Maven:
    ```shell
    mvn spring-boot:run
    ```
2.  The backend server will start on `http://localhost:8080`.

### 5. Frontend Setup & Launch
1.  In a separate terminal, navigate to the `frontend` directory:
    ```shell
    cd frontend
    ```
2.  Install the required Node.js dependencies:
    ```shell
    npm install
    ```
3.  Start the Vite development server:
    ```shell
    npm run dev
    ```
4.  The frontend will be available at `http://localhost:3000`. The Vite server is configured to proxy all API (`/api`) and WebSocket (`/ws`) requests to the Spring Boot backend running on port 8080.

## Usage

Once both servers are running, open `http://localhost:3000` in your browser.

*   **API Documentation**: Full, interactive API documentation is available via Swagger UI at `http://localhost:8080/TechnikTeam/swagger-ui.html` once the backend is running.
========================================================================
FILE: frontend\eslint.config.js
========================================================================

import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])

========================================================================
FILE: frontend\index.html
========================================================================

<!doctype html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<link rel="icon" type="image/x-icon" href="/favicon.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>TechnikTeam</title>
<!-- Link to Font Awesome (from original project) -->
<link rel="stylesheet"
	href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<!-- Link to our application's stylesheets -->
<link rel="stylesheet" href="/style1.css">
<link rel="stylesheet" href="/style2.css">
<link rel="stylesheet" href="/style3.css">
<link rel="stylesheet" href="/style4.css">
<script>
	// This script runs immediately to prevent a "flash" of the wrong theme.
	const savedTheme = localStorage.getItem('theme') || 'light';
	document.documentElement.setAttribute('data-theme', savedTheme);
</script>
</head>
<body>
	<div id="root"></div>
	<script type="module" src="/src/main.jsx"></script>
</body>
</html>
========================================================================
FILE: frontend\README.md
========================================================================

# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.

========================================================================
FILE: frontend\vite.config.js
========================================================================

import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { fileURLToPath, URL } from 'url'

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [react()],
	server: {
		port: 3000,
		proxy: {
			// Proxy all API requests starting with /api to the Spring Boot backend
			'/api': {
				target: 'http://localhost:8080/TechnikTeam',
				changeOrigin: true,
				secure: false,
			},
			// Proxy all WebSocket connections to the Spring Boot backend
			'/ws': {
				target: 'ws://localhost:8080/TechnikTeam',
				ws: true, // Enable WebSocket proxying
			},
		},
	},
	resolve: {
		alias: {
			'@': fileURLToPath(new URL('./src', import.meta.url))
		}
	}
})
========================================================================
FILE: frontend\public\style1.css
========================================================================

/* FILE: style1.css - Core, Base, and Layout Styles */

/* --- 1. THEME & COLOR PALETTE --- */
:root {
	--primary-color: #007bff;
	--primary-color-hover: #0056b3;
	--primary-color-light: rgba(0, 123, 255, 0.1);
	--bg-color: #f8f9fa;
	--surface-color: #ffffff;
	--text-color: #212529;
	--heading-color: #002B5B;
	/* Dark, rich blue for headings */
	--text-muted-color: #6c757d;
	--border-color: #dee2e6;
	--success-color: #28a745;
	--danger-color: #dc3545;
	--warning-color: #ffc107;
	--info-color: #0dcaf0;
	--shadow-sm: 0 1px 2px 0 rgb(0 0 0/ 0.05);
	--shadow-md: 0 4px 6px -1px rgb(0 0 0/ 0.1), 0 2px 4px -2px rgb(0 0 0/ 0.1);
	--shadow-lg: 0 10px 15px -3px rgb(0 0 0/ 0.1), 0 4px 6px -4px rgb(0 0 0/ 0.1);
	--sidebar-width: 260px;
	--header-height: 64px;
	--border-radius: 8px;
	--sidebar-bg: var(--surface-color);
	--sidebar-border: var(--border-color);
	--sidebar-text-color: #343a40;
	--sidebar-text-muted: #6c757d;
	--sidebar-icon-color: #6c757d;
	--sidebar-hover-bg: #e9ecef;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
    /* Terminal Colors */
    --terminal-bg: #010409;
    --terminal-header-bg: #0d1117;
    --terminal-border: #30363d;
    --terminal-text: #c9d1d9;
    --terminal-text-muted: #8b949e;
    --terminal-prompt: #58a6ff;
}

[data-theme="dark"] {
	--primary-color: #58a6ff;
	--primary-color-hover: #80b6ff;
	--primary-color-light: rgba(88, 166, 255, 0.15);
	--bg-color: #0d1117;
	--surface-color: #161b22;
	--text-color: #c9d1d9;
	--heading-color: var(--primary-color);
	--text-muted-color: #8b949e;
	--border-color: #30363d;
	--success-color: #56d364;
	--danger-color: #f87171;
	--warning-color: #f0b72f;
	--info-color: #67d4ed;
	--sidebar-bg: #161b22;
	--sidebar-border: #30363d;
	--sidebar-text-color: #c9d1d9;
	--sidebar-text-muted: #8b949e;
	--sidebar-icon-color: #8b949e;
	--sidebar-hover-bg: #21262d;
	--sidebar-active-bg: var(--primary-color-light);
	--sidebar-active-border: var(--primary-color);
	--sidebar-active-text: var(--primary-color);
	--sidebar-active-icon: var(--primary-color);
    /* Terminal Colors remain dark, as it's a specific component style */
}

[data-theme="light"] {
    --terminal-bg: #ffffff;
    --terminal-header-bg: #f8f9fa;
    --terminal-border: #dee2e6;
    --terminal-text: #212529;
    --terminal-text-muted: #6c757d;
    --terminal-prompt: #0056b3;
}


/* --- 2. BASE & TYPOGRAPHY --- */
*,
*::before,
*::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html,
body {
	height: 100%;
}

html {
	scroll-behavior: smooth;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		"Helvetica Neue", Arial, sans-serif;
	background-color: var(--bg-color);
	color: var(--text-color);
	line-height: 1.6;
	transition: background-color 0.3s, color 0.3s;
}

h1,
h2,
h3,
h4 {
	color: var(--heading-color);
	line-height: 1.3;
}

h1 {
	font-size: clamp(1.8rem, 5vw, 2.2rem);
	font-weight: 700;
	margin-bottom: 1rem;
}

h2 {
	font-size: clamp(1.2rem, 4vw, 1.5rem);
	margin-bottom: 1.25rem;
	padding-bottom: 0.75rem;
	border-bottom: 1px solid var(--border-color);
	font-weight: 600;
}

h3 {
	font-size: 1.25rem;
	margin-bottom: 1rem;
	font-weight: 600;
}

a {
	color: var(--primary-color);
	text-decoration: none;
	transition: color 0.2s;
}

a:hover {
	text-decoration: underline;
	color: var(--primary-color-hover);
}

.text-success {
	color: var(--success-color) !important;
}

.text-danger {
	color: var(--danger-color) !important;
}

/* --- 3. LAYOUT & CONTAINERS --- */
.main-content-wrapper {
	transition: margin-left 0.3s ease-in-out;
	height: 100vh;
	display: flex;
	flex-direction: column;
}

.main-content {
	padding: 1.5rem;
	max-width: 1600px;
	margin-left: auto;
	margin-right: auto;
	width: 100%;
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

/* Add centering for error page content */
.main-content.center-content {
    display: flex;
    justify-content: center;
    align-items: center;
}

.card {
	background: var(--surface-color);
	border-radius: var(--border-radius);
	padding: 1.5rem;
	margin-bottom: 1.5rem;
	box-shadow: var(--shadow-sm);
	border: 1px solid var(--border-color);
	transition: all .3s;
}

.card:hover {
	box-shadow: var(--shadow-md);
}

.card-title {
	border: none;
	padding: 0;
	margin-bottom: 1rem;
}

.dashboard-grid,
.responsive-dashboard-grid {
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
	gap: 1.5rem;
}

@media (max-width : 767.98px) {
	.responsive-dashboard-grid {
		grid-template-columns: 1fr;
	}
}
========================================================================
FILE: frontend\public\style2.css
========================================================================

/* FILE: style2.css - Navigation Styles */

/* --- 4. NAVIGATION --- */
.sidebar {
	position: fixed;
	top: 0;
	left: calc(-1 * var(--sidebar-width));
	width: var(--sidebar-width);
	height: 100%;
	background: var(--sidebar-bg);
	border-right: 1px solid var(--sidebar-border);
	z-index: 1010;
	transition: left 0.3s ease-in-out, background-color 0.3s, border-color
		0.3s;
	display: flex;
	flex-direction: column;
}

body.nav-open .sidebar {
	left: 0;
	box-shadow: var(--shadow-md);
}

.sidebar-header {
	display: flex;
	align-items: center;
	gap: 0.75rem;
	padding: 0 1.5rem;
	height: var(--header-height);
	flex-shrink: 0;
}

.sidebar-header .logo {
	font-size: 1.25rem;
	font-weight: 700;
	color: var(--heading-color);
	text-decoration: none;
}

.sidebar-header .logo i {
	color: var(--primary-color);
}

.sidebar-nav {
	list-style: none;
	flex-grow: 1;
	overflow-y: auto;
	padding: 0.5rem 0;
}

.sidebar-nav a {
	display: flex;
	align-items: center;
	gap: 1rem;
	padding: 0.9rem 1.5rem;
	color: var(--sidebar-text-muted);
	font-weight: 500;
	transition: all 0.2s;
	border-left: 4px solid transparent;
	white-space: nowrap;
	text-decoration: none;
}

.sidebar-nav a i.fa-fw {
	width: 20px;
	text-align: center;
	color: var(--sidebar-icon-color);
	transition: color 0.2s;
}

.sidebar-nav a:hover {
	color: var(--text-color);
	background-color: var(--sidebar-hover-bg);
}

.sidebar-nav a:hover i.fa-fw {
	color: var(--primary-color);
}

.sidebar-nav a.active-nav-link {
	color: var(--sidebar-active-text);
	font-weight: 600;
	border-left-color: var(--sidebar-active-border);
	background-color: var(--sidebar-active-bg);
}

.sidebar-nav a.active-nav-link i.fa-fw {
	color: var(--sidebar-active-icon);
}

.sidebar-nav .nav-section-title {
	padding: 1.5rem 1.5rem 0.5rem;
	font-size: 0.8rem;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
}

.user-actions {
	padding: 1rem 1.5rem;
	border-top: 1px solid var(--sidebar-border);
	flex-shrink: 0;
}

.user-info {
	font-weight: 500;
	margin-bottom: 1rem;
	font-size: 0.9rem;
	color: var(--text-muted-color);
}

.user-info strong {
	color: var(--text-color);
}

.mobile-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	height: var(--header-height);
	background-color: var(--surface-color);
	padding: 0 1rem;
	position: sticky;
	top: 0;
	z-index: 1000;
	border-bottom: 1px solid var(--border-color);
	flex-shrink: 0;
}

.mobile-header-right {
	display: flex;
	align-items: center;
	gap: 1rem;
}

.mobile-nav-toggle {
	background: none;
	border: none;
	cursor: pointer;
	padding: 0.5rem;
	z-index: 1020;
	/* --- STYLE UPDATE --- */
	width: 44px; /* Larger touch target */
	height: 44px; /* Larger touch target */
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

.mobile-nav-toggle .line {
	width: 25px;
	height: 3px;
	/* --- STYLE UPDATE --- */
	background-color: var(--primary-color); /* More visible color */
	margin: 5px 0;
	border-radius: 3px;
	transition: all 0.3s;
}

body.nav-open .mobile-nav-toggle .line-1 {
	transform: rotate(45deg) translate(5px, 6px);
}

body.nav-open .mobile-nav-toggle .line-2 {
	opacity: 0;
}

body.nav-open .mobile-nav-toggle .line-3 {
	transform: rotate(-45deg) translate(5px, -6px);
}

.mobile-logo {
	font-weight: 600;
	font-size: 1.2rem;
	color: var(--heading-color);
	text-decoration: none;
}

.page-overlay {
	display: none;
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(0, 0, 0, 0.5);
	z-index: 1005;
}

body.nav-open .page-overlay {
	display: block;
}

@media ( min-width : 992px) {
	.mobile-header, .page-overlay {
		display: none !important;
	}
	.sidebar {
		left: 0;
	}
	.main-content-wrapper {
		margin-left: var(--sidebar-width);
		height: 100vh;
	}
	.sidebar .mobile-only {
		display: none !important;
	}
}

@media ( max-width : 991.98px) {
	.sidebar .desktop-only {
		display: none !important;
	}
	.main-content-wrapper {
		height: 100vh;
	}
}
========================================================================
FILE: frontend\public\style3.css
========================================================================

/* FILE: style3.css - Reusable Component Styles */

/* --- 5. COMPONENTS --- */

/* Buttons */
.btn {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	gap: 0.5rem;
	padding: 0.6rem 1.2rem;
	background-color: var(--primary-color);
	color: #fff;
	border: 1px solid transparent;
	border-radius: 6px;
	cursor: pointer;
	font-weight: 500;
	transition: all 0.2s;
	text-align: center;
	text-decoration: none;
}

.btn:hover {
	background-color: var(--primary-color-hover);
	color: #fff;
	text-decoration: none;
	transform: translateY(-1px);
}

.btn:disabled {
	background-color: var(--text-muted-color);
	cursor: not-allowed;
	transform: none;
	opacity: 0.65;
}

.btn.btn-danger {
	background-color: var(--danger-color);
}

.btn.btn-danger-outline {
	background-color: transparent;
	border-color: var(--danger-color);
	color: var(--danger-color);
}

.btn.btn-danger-outline:hover {
	background-color: var(--danger-color);
	color: #fff;
}

.btn.btn-success {
	background-color: var(--success-color);
}

.btn.btn-secondary {
	background-color: var(--text-muted-color);
}

.btn-small {
	padding: 0.4rem 0.8rem;
	font-size: 0.875rem;
}

/* Messages & Banners */
.success-message,
.error-message,
.info-message,
.password-reset-alert {
	padding: 1rem;
	margin-bottom: 1.5rem;
	border-radius: var(--border-radius);
	font-weight: 500;
	display: flex;
	align-items: center;
	gap: 0.75rem;
	color: #fff;
}

.success-message {
	background-color: var(--success-color);
}

.error-message {
	background-color: var(--danger-color);
}

.info-message,
.password-reset-alert {
	background-color: var(--info-color);
	color: #000;
}

.password-reset-alert strong {
	cursor: pointer;
	text-decoration: underline;
}

/* Toast Notifications */
.toast {
	position: fixed;
	bottom: 20px;
	right: 20px;
	background-color: var(--surface-color);
	color: var(--text-color);
	padding: 1rem 1.5rem;
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-lg);
	z-index: 9999;
	transform: translateY(150%);
	transition: transform 0.4s ease-in-out, opacity 0.4s;
	border-left: 5px solid var(--primary-color);
	opacity: 0;
}

.toast.toast-success {
	border-left-color: var(--success-color);
}

.toast.toast-danger {
	border-left-color: var(--danger-color);
}

.toast.toast-info {
	border-left-color: var(--info-color);
}

.toast.show {
	transform: translateY(0);
	opacity: 1;
}

/* Forms & Inputs */
.form-group {
	margin-bottom: 1.25rem;
}

.form-group label {
	display: block;
	margin-bottom: 0.5rem;
	font-weight: 500;
	color: var(--text-muted-color);
}

.form-group input,
.form-group select,
.form-group textarea {
	width: 100%;
	padding: 0.75rem;
	border: 1px solid var(--border-color);
	border-radius: 6px;
	background-color: var(--surface-color);
	color: var(--text-color);
	font-size: 1rem;
	transition: border-color 0.2s, box-shadow 0.2s;
}

fieldset {
	border: none;
	padding: 0;
	margin: 0;
}

[data-theme="dark"] .form-group textarea,
[data-theme="dark"] #editor {
	color: var(--text-color);
	background-color: var(--surface-color);
}

.form-group input:focus,
.form-group select:focus,
.form-group textarea:focus {
	outline: none;
	border-color: var(--primary-color);
	box-shadow: 0 0 0 3px var(--primary-color-light);
}

.form-group input[type="file"] {
	background-color: var(--bg-color);
}

.password-input-wrapper {
	position: relative;
	display: flex;
	align-items: center;
}

.password-input-wrapper input {
	padding-right: 40px;
}

.password-toggle-icon {
	position: absolute;
	right: 0;
	top: 0;
	height: 100%;
	width: 40px;
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
	color: var(--text-muted-color);
}

.file-size-warning {
	color: var(--danger-color);
	display: none;
	font-size: 0.875rem;
	margin-top: 0.5rem;
}

/* Modals */
.modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background-color: rgba(0, 0, 0, 0.6);
	display: none;
	justify-content: center;
	align-items: center;
	z-index: 2000;
}

.modal-overlay.active {
	display: flex;
}

.modal-content {
	background-color: var(--surface-color);
	padding: 2rem;
	border-radius: var(--border-radius);
	width: 90%;
	max-width: 600px;
	max-height: 90vh;
	overflow-y: auto;
	position: relative;
	box-shadow: var(--shadow-lg);
}

.modal-close-btn {
	position: absolute;
	top: 1rem;
	right: 1rem;
	background: none;
	border: none;
	font-size: 1.5rem;
	cursor: pointer;
	color: var(--text-muted-color);
}

.modal-tabs {
	display: flex;
	border-bottom: 1px solid var(--border-color);
	margin-bottom: 1.5rem;
}

.modal-tab-button {
	padding: 0.75rem 1rem;
	border: none;
	background: none;
	cursor: pointer;
	font-size: 1rem;
	font-weight: 500;
	color: var(--text-muted-color);
	border-bottom: 3px solid transparent;
	transition: all 0.2s;
}

.modal-tab-button.active {
	color: var(--primary-color);
	border-bottom-color: var(--primary-color);
}

.modal-tab-content {
	display: none;
}

.modal-tab-content.active {
	display: block;
}

.dynamic-row {
	display: flex;
	gap: 0.5rem;
	align-items: center;
	margin-bottom: 0.5rem;
	flex-wrap: wrap;
}

.dynamic-row .form-group {
	flex-grow: 1;
	margin-bottom: 0;
}

.dynamic-row .btn-small {
	flex-shrink: 0;
}

/* --- 6. TABLES & RESPONSIVE LISTS --- */
.table-wrapper {
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	overflow-x: auto;
	background-color: var(--surface-color);
}

.data-table {
	width: 100%;
	border-collapse: collapse;
}

.data-table th,
.data-table td {
	padding: 1rem;
	text-align: left;
	border-bottom: 1px solid var(--border-color);
	white-space: nowrap;
	vertical-align: middle;
}

.data-table thead th {
	font-size: 0.8rem;
	text-transform: uppercase;
	letter-spacing: 0.05em;
	color: var(--text-muted-color);
	background-color: var(--bg-color);
}

.data-table tbody tr:hover {
	background-color: var(--bg-color);
}

.mobile-card-list {
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.list-item-card {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: var(--border-radius);
	padding: 1rem;
	box-shadow: var(--shadow-sm);
}

.list-item-card .card-title {
	margin-bottom: 0.5rem;
	font-size: 1.1rem;
	border-bottom: none;
	padding-bottom: 0;
}

.card-row {
	display: flex;
	justify-content: space-between;
	align-items: center;
	font-size: 0.9rem;
	padding: 0.4rem 0;
	border-bottom: 1px solid var(--border-color);
}

.card-row:last-of-type {
	border-bottom: none;
}

.card-actions {
	margin-top: 1rem;
	padding-top: 1rem;
	border-top: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	gap: 0.5rem;
}

.desktop-table-wrapper {
	display: none;
}

@media (min-width : 992px) {
	.mobile-card-list {
		display: none !important;
	}

	.desktop-table-wrapper {
		display: block !important;
	}
}
========================================================================
FILE: frontend\public\style4.css
========================================================================

/* FILE: style4.css - Page-Specific, Utility, and Complex Component Styles */

/* --- 7. UTILITY & PAGE-SPECIFIC --- */
.login-page-container {
	display: flex;
	align-items: center;
	justify-content: center;
	width: 100%;
	min-height: 100vh;
	padding: 1rem;
	background: var(--bg-color);
}

.login-box {
	width: 100%;
	max-width: 400px;
	padding: 2.5rem;
	background-color: var(--surface-color);
	border-radius: var(--border-radius);
	box-shadow: var(--shadow-md);
}

.table-controls {
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 1rem;
	margin-bottom: 1.5rem;
}

.status-badge {
	padding: 0.25em 0.6em;
	font-size: 0.8rem;
	font-weight: 600;
	border-radius: 20px;
	text-transform: uppercase;
}

.status-ok {
	background-color: var(--success-color);
	color: #fff;
}

.status-warn {
	background-color: var(--warning-color);
	color: #000;
}

.status-danger {
	background-color: var(--danger-color);
	color: #fff;
}

.status-info {
	background-color: var(--text-muted-color);
	color: #fff;
}

.details-list {
	list-style-type: none;
	padding-left: 0;
}

.details-list li {
	padding: 0.75rem 0;
	border-bottom: 1px solid var(--border-color);
	display: flex;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	gap: 0.5rem;
}

@media (max-width : 576px) {
	.details-list li {
		flex-direction: column;
		align-items: flex-start;
	}
}

.details-list li:last-child {
	border-bottom: none;
}

.details-subtitle {
	font-size: 1.1rem;
	color: var(--text-muted-color);
	margin-bottom: 1.5rem;
}

.star-rating {
	display: flex;
	flex-direction: row-reverse;
	justify-content: flex-end;
	font-size: 2em;
}

.star-rating input {
	display: none;
}

.star-rating label {
	color: #ccc;
	cursor: pointer;
	transition: color 0.2s;
}

.star-rating label:before {
	content: '★';
}

.star-rating input:checked~label,
.star-rating:not(:checked)>label:hover,
.star-rating:not(:checked)>label:hover~label {
	color: #ffc107;
}

.qr-action-body {
	display: flex;
	justify-content: center;
	align-items: center;
	min-height: 100vh;
	background-color: var(--bg-color);
}

.qr-action-container {
	text-align: center;
	width: 90%;
	max-width: 400px;
}

.qr-action-item-name {
	font-size: 1.5rem;
	font-weight: bold;
	margin-bottom: 2rem;
}

.qr-action-buttons {
	display: grid;
	grid-template-columns: 1fr;
	gap: 1rem;
}

.qr-action-btn {
	font-size: 1.2rem;
	padding: 1.5rem;
}

.lightbox-overlay {
	display: none;
	position: fixed;
	z-index: 3000;
	padding: 1rem;
	justify-content: center;
	align-items: center;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	overflow: auto;
	background-color: rgba(0, 0, 0, 0.8);
}

.lightbox-content {
	margin: auto;
	display: block;
	width: auto;
	height: auto;
	max-width: 90vw;
	max-height: 90vh;
}

.lightbox-close {
	position: absolute;
	top: 15px;
	right: 35px;
	color: #f1f1f1;
	font-size: 40px;
	font-weight: bold;
	transition: 0.3s;
}

.lightbox-close:hover,
.lightbox-close:focus {
	color: #bbb;
	text-decoration: none;
	cursor: pointer;
}

.data-table .sticky-header {
	position: sticky;
	top: 0;
	z-index: 10;
}

.data-table .sticky-col {
	position: sticky;
	left: 0;
	background-color: var(--surface-color);
	z-index: 5;
}

.data-table .qual-cell[data-attended="true"] {
	color: var(--success-color);
}

.horizontal-scroll-hint {
	display: none;
	text-align: center;
	padding: 0.5rem;
	background-color: var(--warning-color);
	color: #000;
	font-weight: 500;
	border-radius: var(--border-radius);
	margin-bottom: 1rem;
}

@media (max-width : 768px) {
	.horizontal-scroll-hint {
		display: block;
	}
}

/* --- 8. CREATIVE ERROR PAGES --- */
.error-page-wrapper {
    display: flex;
    /* Centering is now optional and handled by the element itself */
    min-height: 100vh;
    width: 100%;
    padding: 0; /* Remove padding for full-screen pages */
    font-family: 'Courier New', Courier, monospace;
    background-color: var(--bg-color);
}

.error-page-wrapper.center {
    justify-content: center;
    align-items: center;
    padding: 2rem;
}

.terminal {
    background-color: var(--terminal-bg);
    border: 1px solid var(--terminal-border);
    border-radius: 8px;
    padding: 1.5rem;
    width: 100%;
    max-width: 800px;
    box-shadow: var(--shadow-lg);
}

.full-screen-terminal {
    width: 100%;
    height: 100vh;
    background-color: var(--terminal-bg);
    color: var(--terminal-text);
    display: flex;
    flex-direction: column;
}

.full-screen-terminal .terminal-header {
    flex-shrink: 0;
}
.full-screen-terminal .terminal-body {
    flex-grow: 1;
    overflow-y: auto;
    padding: 1.5rem;
}
.full-screen-terminal .terminal-footer {
    flex-shrink: 0;
    padding: 1.5rem;
    border-top: 1px solid var(--terminal-border);
}


.terminal-header {
    display: flex;
    align-items: center;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--terminal-border);
    margin-bottom: 1rem;
    background-color: var(--terminal-header-bg);
    margin: -1.5rem -1.5rem 1rem -1.5rem;
    padding: 1rem 1.5rem;
    border-top-left-radius: 8px;
    border-top-right-radius: 8px;
}

.terminal-header span {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 8px;
}
.terminal-header .red { background-color: #ff5f56; }
.terminal-header .yellow { background-color: #ffbd2e; }
.terminal-header .green { background-color: #27c93f; }

.terminal-header .title {
    color: var(--terminal-text-muted);
    margin: 0 auto;
}

.terminal-body {
    min-height: 200px;
    color: var(--terminal-text);
}

.terminal-line {
    display: flex;
    white-space: pre-wrap;
    word-break: break-all;
}

.terminal-prompt {
    color: var(--terminal-prompt);
    margin-right: 0.5rem;
}

.terminal-line .cursor {
    display: inline-block;
    width: 8px;
    height: 1.2em;
    background-color: var(--terminal-text);
    animation: blink 1s step-end infinite;
}

@keyframes blink {
    from, to { background-color: transparent; }
    50% { background-color: var(--terminal-text); }
}

.error-page-wrapper .btn {
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
    margin-top: 1.5rem;
}
.full-screen-terminal .btn {
    margin-top: 0;
}


.error-page-wrapper .btn.visible {
    opacity: 1;
}

.terminal-line.info { color: var(--text-muted-color); }
.terminal-line.ok { color: var(--success-color); }
.terminal-line.warn { color: var(--warning-color); }
.terminal-line.fail { color: var(--danger-color); }


/* --- 10. CHAT INTERFACE --- */
.chat-message-container {
	display: flex;
	align-items: center;
	margin-bottom: 0.75rem;
	position: relative;
	max-width: 90%;
	align-self: flex-start;
}

.chat-message-container.current-user {
	align-self: flex-end;
	flex-direction: row-reverse;
}

.chat-bubble {
	padding: 0.6rem 0.9rem;
	border-radius: 18px;
	word-wrap: break-word;
	border: 1px solid transparent;
}

.chat-bubble.current-user-bubble {
	background-color: var(--primary-color) !important;
	color: #fff !important;
	border-color: var(--primary-color) !important;
}

.chat-username {
	display: block;
	font-size: 0.8rem;
	font-weight: 700;
	margin-bottom: 0.2rem;
}

.chat-text {
	display: block;
	font-size: 1rem;
	line-height: 1.4;
}

.chat-timestamp {
	display: block;
	font-size: 0.75rem;
	margin-top: 0.3rem;
	text-align: right;
}

.chat-edited-marker {
	font-size: 0.7em;
	font-style: italic;
	color: inherit;
}

.chat-options {
	opacity: 0;
	transition: opacity 0.2s;
	display: flex;
	gap: 0.25rem;
	background-color: var(--surface-color);
	padding: 0.25rem;
	border-radius: 20px;
	box-shadow: var(--shadow-md);
	margin: 0 0.5rem;
}

.chat-message-container:hover .chat-options {
	opacity: 1;
}

.chat-option-btn {
	background: none;
	border: none;
	cursor: pointer;
	color: var(--text-muted-color);
	width: 28px;
	height: 28px;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
}

.chat-option-btn:hover {
	background-color: var(--bg-color);
	color: var(--text-color);
}

.chat-edit-input {
	width: 100%;
	padding: 0.2rem 0.4rem;
	border: 1px solid var(--primary-color);
	border-radius: 4px;
	background: var(--surface-color);
	color: var(--text-color);
	font-family: inherit;
	font-size: 1rem;
}

.chat-bubble.deleted {
	font-style: italic;
	opacity: 0.7;
}

.chat-deleted-info {
	font-size: 0.9em;
}

#chat-box {
	display: flex;
	flex-direction: column;
}

/* --- 12. MARKDOWN STYLES --- */
.markdown-content {
	overflow-wrap: break-word;
	word-wrap: break-word;
}

.markdown-content h1,
.markdown-content h2,
.markdown-content h3,
.markdown-content h4,
.markdown-content h5,
.markdown-content h6 {
	margin-top: 1.5rem;
	margin-bottom: 1rem;
	font-weight: 600;
	border: none;
	padding: 0;
}

.markdown-content p {
	margin-bottom: 1rem;
}

.markdown-content ul,
.markdown-content ol {
	padding-left: 2rem;
	margin-bottom: 1rem;
}

.markdown-content blockquote {
	padding: 0.5rem 1rem;
	margin: 0 0 1rem;
	font-size: 1rem;
	border-left: 0.25rem solid var(--border-color);
	background-color: var(--bg-color);
	color: var(--text-muted-color);
}

.markdown-content code {
	padding: .2em .4em;
	margin: 0;
	font-size: 85%;
	background-color: var(--primary-color-light);
	border-radius: 6px;
	font-family: monospace;
}

.markdown-content pre {
	padding: 1rem;
	overflow: auto;
	font-size: 85%;
	line-height: 1.45;
	background-color: var(--bg-color);
	border-radius: 6px;
	margin-bottom: 1rem;
}

.markdown-content table {
	width: 100%;
	margin-bottom: 1rem;
	border-collapse: collapse;
	display: block;
	overflow-x: auto;
}

.markdown-content th,
.markdown-content td {
	padding: 0.75rem;
	border: 1px solid var(--border-color);
}

.markdown-content thead {
	background-color: var(--bg-color);
}

.markdown-content img {
	max-width: 100%;
	height: auto;
}

/* --- 14. CUSTOM CALENDAR STYLES --- */
.termin-list {
	list-style: none;
	padding: 0;
}

.termin-item-link {
	text-decoration: none;
	color: inherit;
	display: block;
}

.termin-item {
	display: flex;
	align-items: center;
	padding: 1rem;
	background-color: var(--surface-color);
	border-bottom: 1px solid var(--border-color);
	transition: background-color 0.2s;
}

.termin-item:hover {
	background-color: var(--bg-color);
}

.termin-list li:first-child {
	border-top: 1px solid var(--border-color);
}

.termin-date {
	flex-shrink: 0;
	text-align: center;
	margin-right: 1.5rem;
	width: 60px;
}

.termin-date-day {
	font-size: 1.8rem;
	font-weight: 600;
	display: block;
	line-height: 1;
	color: var(--primary-color);
}

.termin-date-month {
	font-size: 0.9rem;
	text-transform: uppercase;
	font-weight: 500;
	display: block;
	color: var(--text-muted-color);
}

.termin-details {
	flex-grow: 1;
}

.termin-title {
	font-weight: 600;
	display: block;
	margin-bottom: 0.25rem;
}

.termin-type-event {
	background-color: var(--danger-color);
	color: white;
}

.termin-type-lehrgang {
	background-color: var(--primary-color);
	color: white;
}

.termin-arrow {
	color: var(--text-muted-color);
	margin-left: 1rem;
}

.mobile-list-view {
	display: block;
}

.desktop-calendar-view {
	display: none;
}

@media (min-width : 992px) {
	.mobile-list-view {
		display: none;
	}

	.desktop-calendar-view {
		display: block;
	}
}

/* --- 15. WIKI PAGE STYLES --- */
body[data-page="wiki"] .main-content {
	display: flex;
	padding: 0;
	overflow: hidden;
}

.wiki-page-wrapper {
	display: flex;
	flex-grow: 1;
	min-height: 0;
	min-width: 0;
}

.wiki-sidebar {
	flex: 0 0 350px;
	height: 100%;
	display: flex;
	flex-direction: column;
	background-color: var(--surface-color);
	border-right: 1px solid var(--border-color);
	padding: 1.5rem;
}

.wiki-content-pane {
	flex-grow: 1;
	height: 100%;
	display: flex;
	flex-direction: column;
	min-width: 0;
	padding: 1.5rem;
	overflow-y: auto;
}

.wiki-sidebar-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 1rem;
	flex-shrink: 0;
}

.wiki-sidebar-header h3 {
	margin: 0;
	border: none;
	padding: 0;
}

.wiki-tree-container {
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

.wiki-welcome-pane {
	text-align: center;
	margin: auto;
	color: var(--text-muted-color);
}

.wiki-welcome-pane h1 {
	margin-top: 1rem;
}

.wiki-tree-container ul {
	list-style-type: none;
	padding-left: 1rem;
}

.wiki-tree-container summary {
	cursor: pointer;
	padding: 0.25rem 0;
	list-style: none;
}

.wiki-tree-container summary::-webkit-details-marker {
	display: none;
}

.wiki-tree-container summary:before {
	content: '\f07b';
	font-family: 'Font Awesome 5 Free';
	font-weight: 900;
	margin-right: 0.5rem;
	color: var(--text-muted-color);
	transition: transform 0.2s;
}

.wiki-tree-container details[open]>summary:before {
	content: '\f07c';
}

.wiki-tree-container a {
	display: block;
	padding: 0.25rem 0.5rem;
	border-radius: 4px;
	text-decoration: none;
}

.wiki-tree-container a:hover {
	background-color: var(--sidebar-hover-bg);
}

.wiki-tree-container a.active {
	background-color: var(--primary-color-light);
	font-weight: 600;
	color: var(--primary-color);
}

.wiki-content-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	border-bottom: 1px solid var(--border-color);
	margin-bottom: 1rem;
	flex-wrap: wrap;
	gap: 1rem;
	flex-shrink: 0;
}

.wiki-content-header h2 {
	margin: 0;
	padding: 0;
	border: none;
	font-size: 1.2rem;
	word-break: break-all;
}

@media (max-width : 991.98px) {
	.wiki-sidebar {
		position: fixed;
		top: var(--header-height);
		left: 0;
		height: calc(100% - var(--header-height));
		margin-left: -100%;
		z-index: 1000;
		box-shadow: var(--shadow-lg);
	}

	.wiki-page-wrapper.sidebar-open .wiki-sidebar {
		margin-left: 0;
	}
}

/* --- 16. UTILITY OVERFLOW STYLES --- */
.data-table td,
.data-table th,
code,
pre {
	word-break: break-word;
	white-space: normal;
}

pre,
code {
	white-space: pre-wrap;
}

/* --- 17. INLINE WIKI EDITOR STYLES --- */
.wiki-editor-controls {
	display: flex;
	align-items: center;
	gap: 1rem;
}

#wiki-content-pane .editor-container {
	display: flex;
	flex-direction: column;
	flex-grow: 1;
	min-height: 0;
	border: none;
	padding: 0;
	box-shadow: none;
	background: transparent;
}

#wiki-content-pane #editor {
	flex-grow: 1;
	min-height: 0;
	height: auto;
	overflow-y: auto;
}

#wiki-content-pane #markdown-preview {
	flex-grow: 1;
	overflow-y: auto;
	min-height: 0;
}

/* --- 18. FEEDBACK BOARD (KANBAN) --- */
.feedback-board {
	display: flex;
	gap: 1.5rem;
	overflow-x: auto;
	padding-bottom: 1rem;
	min-height: 60vh;
}

.feedback-column {
	flex: 1 0 300px;
	min-width: 300px;
	background-color: var(--bg-color);
	border-radius: var(--border-radius);
	padding: 1rem;
}

.feedback-column h2 {
	font-size: 1.2rem;
	border-bottom: 2px solid var(--border-color);
	padding-bottom: 0.5rem;
	margin-bottom: 1rem;
}

.feedback-list {
	min-height: 100px;
	display: flex;
	flex-direction: column;
	gap: 1rem;
}

.feedback-card-item {
	background-color: var(--surface-color);
	border: 1px solid var(--border-color);
	border-radius: 6px;
	padding: 1rem;
	box-shadow: var(--shadow-sm);
	cursor: pointer;
}

.feedback-card-item:active {
	cursor: grabbing;
}

.feedback-card-item .subject {
	font-weight: 600;
	margin-bottom: 0.5rem;
	display: block;
}

.feedback-card-item .content-preview {
	font-size: 0.9rem;
	color: var(--text-muted-color);
	margin-bottom: 0.75rem;
	display: -webkit-box;
	-webkit-line-clamp: 2;
	-webkit-box-orient: vertical;
	overflow: hidden;
	text-overflow: ellipsis;
}

.feedback-card-item .meta {
	font-size: 0.8rem;
	color: var(--text-muted-color);
}

.sortable-ghost {
	opacity: 0.4;
	background: var(--primary-color-light);
}
========================================================================
FILE: frontend\src\App.jsx
========================================================================

import React, { useState, useEffect, Suspense } from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import Sidebar from './components/layout/Sidebar';
import Header from './components/layout/Header';
import ToastContainer from './components/ui/ToastContainer';
import { ToastProvider } from './context/ToastContext';

function App() {
	const [isNavOpen, setIsNavOpen] = useState(false);
	const location = useLocation();

	useEffect(() => {
		// Close mobile navigation when the route changes
		setIsNavOpen(false);
	}, [location]);

	useEffect(() => {
		// Add/remove class from body for overlay effect
		if (isNavOpen) {
			document.body.classList.add('nav-open');
		} else {
			document.body.classList.remove('nav-open');
		}
	}, [isNavOpen]);


	return (
		<ToastProvider>
			<Sidebar />
			<Header onNavToggle={() => setIsNavOpen(!isNavOpen)} />
			{isNavOpen && <div className="page-overlay" onClick={() => setIsNavOpen(false)}></div>}
			<div className="main-content-wrapper">
				<main className="main-content">
					<Suspense fallback={<div>Seite wird geladen...</div>}>
						<Outlet />
					</Suspense>
				</main>
			</div>
			<ToastContainer />
		</ToastProvider>
	);
}

export default App;
========================================================================
FILE: frontend\src\main.jsx
========================================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import router from './router';
import { useAuthStore } from './store/authStore';
import apiClient from './services/apiClient'; // Import apiClient here

const initializeApp = async () => {
	// Inject the logout function into the apiClient
	apiClient.setup({ onUnauthorized: useAuthStore.getState().logout });

	// Pre-fetch CSRF token after setup
	await apiClient.fetchCsrfToken();

	const { user, fetchUserSession } = useAuthStore.getState();
	if (!user) {
		try {
			await fetchUserSession();
		} catch (error) {
			console.log("Keine gültige Sitzung gefunden. Benutzer muss sich anmelden.");
		}
	}
};

initializeApp().then(() => {
	ReactDOM.createRoot(document.getElementById('root')).render(
		<React.StrictMode>
			<RouterProvider router={router} />
		</React.StrictMode>
	);
});
========================================================================
FILE: frontend\src\components\admin\dashboard\EventTrendChart.jsx
========================================================================

import React from 'react';
import { Line } from 'react-chartjs-2';
import {
	Chart as ChartJS,
	CategoryScale,
	LinearScale,
	PointElement,
	LineElement,
	Title,
	Tooltip,
	Legend,
	Filler,
} from 'chart.js';

ChartJS.register(
	CategoryScale,
	LinearScale,
	PointElement,
	LineElement,
	Title,
	Tooltip,
	Legend,
	Filler
);

const EventTrendChart = ({ trendData }) => {
	if (!trendData || trendData.length === 0) {
		return <p>Nicht genügend Daten für den Event-Trend vorhanden.</p>;
	}

	const data = {
		labels: trendData.map(d => d.month),
		datasets: [
			{
				label: 'Anzahl Events pro Monat',
				data: trendData.map(d => d.count),
				fill: true,
				borderColor: 'rgb(0, 123, 255)',
				backgroundColor: 'rgba(0, 123, 255, 0.1)',
				tension: 0.1,
			},
		],
	};

	const options = {
		responsive: true,
		maintainAspectRatio: false,
		scales: {
			y: {
				beginAtZero: true,
				ticks: {
					stepSize: 1,
					precision: 0,
				},
			},
		},
		plugins: {
			legend: {
				display: false,
			},
		},
	};

	return (
		<div style={{ position: 'relative', height: '300px' }}>
			<Line options={options} data={data} />
		</div>
	);
};

export default EventTrendChart;
========================================================================
FILE: frontend\src\components\admin\dashboard\Widget.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';

const Widget = ({ icon, title, children, linkTo, linkText }) => {
	return (
		<div className="card">
			<h2 className="card-title">
				<i className={`fas ${icon}`}></i> {title}
			</h2>
			{children}
			{linkTo && linkText && (
				<Link to={linkTo} className="btn btn-small" style={{ marginTop: '1rem' }}>
					{linkText}
				</Link>
			)}
		</div>
	);
};

export default Widget;
========================================================================
FILE: frontend\src\components\admin\events\DynamicItemRows.jsx
========================================================================

import React from 'react';

const DynamicItemRows = ({ rows, setRows, storageItems }) => {
	const handleRowChange = (index, field, value) => {
		const newRows = [...rows];
		newRows[index][field] = value;
		setRows(newRows);
	};

	const handleAddRow = () => {
		setRows([...rows, { itemId: '', quantity: 1 }]);
	};

	const handleRemoveRow = (index) => {
		setRows(rows.filter((_, i) => i !== index));
	};

	return (
		<div>
			{rows.map((row, index) => (
				<div className="dynamic-row" key={index}>
					<select
						name="itemIds"
						value={row.itemId}
						onChange={(e) => handleRowChange(index, 'itemId', e.target.value)}
						className="form-group"
					>
						<option value="">-- Artikel auswählen --</option>
						{storageItems.map(item => <option key={item.id} value={item.id}>{item.name}</option>)}
					</select>
					<input
						type="number"
						name="quantities"
						value={row.quantity}
						onChange={(e) => handleRowChange(index, 'quantity', e.target.value)}
						className="form-group"
						style={{ maxWidth: '100px' }}
						min="1"
					/>
					<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveRow(index)} title="Zeile entfernen">×</button>
				</div>
			))}
			<button type="button" className="btn btn-small" onClick={handleAddRow}>
				<i className="fas fa-plus"></i> Artikel hinzufügen
			</button>
		</div>
	);
};

export default DynamicItemRows;
========================================================================
FILE: frontend\src\components\admin\events\DynamicSkillRows.jsx
========================================================================

import React from 'react';

const DynamicSkillRows = ({ rows, setRows, courses }) => {
	const handleRowChange = (index, field, value) => {
		const newRows = [...rows];
		newRows[index][field] = value;
		setRows(newRows);
	};

	const handleAddRow = () => {
		setRows([...rows, { requiredCourseId: '', requiredPersons: 1 }]);
	};

	const handleRemoveRow = (index) => {
		setRows(rows.filter((_, i) => i !== index));
	};

	return (
		<div>
			{rows.map((row, index) => (
				<div className="dynamic-row" key={index}>
					<select
						name="requiredCourseIds"
						value={row.requiredCourseId}
						onChange={(e) => handleRowChange(index, 'requiredCourseId', e.target.value)}
						className="form-group"
					>
						<option value="">-- Qualifikation auswählen --</option>
						{courses.map(course => <option key={course.id} value={course.id}>{course.name}</option>)}
					</select>
					<input
						type="number"
						name="requiredPersons"
						value={row.requiredPersons}
						onChange={(e) => handleRowChange(index, 'requiredPersons', e.target.value)}
						className="form-group"
						style={{ maxWidth: '100px' }}
						min="1"
					/>
					<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveRow(index)} title="Zeile entfernen">×</button>
				</div>
			))}
			<button type="button" className="btn btn-small" onClick={handleAddRow}>
				<i className="fas fa-plus"></i> Anforderung hinzufügen
			</button>
		</div>
	);
};

export default DynamicSkillRows;
========================================================================
FILE: frontend\src\components\admin\events\EventModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';
import DynamicSkillRows from './DynamicSkillRows';
import DynamicItemRows from './DynamicItemRows';

const EventModal = ({ isOpen, onClose, onSuccess, event, adminFormData }) => {
	const isEditMode = !!event;
	const { users, courses, storageItems } = adminFormData;
	const [activeTab, setActiveTab] = useState('general');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const [formData, setFormData] = useState({
		name: '',
		eventDateTime: '',
		endDateTime: '',
		location: '',
		description: '',
		status: 'GEPLANT',
		leaderUserId: '',
		requiredRole: 'NUTZER',
	});
	const [skillRows, setSkillRows] = useState([{ requiredCourseId: '', requiredPersons: 1 }]);
	const [itemRows, setItemRows] = useState([{ itemId: '', quantity: 1 }]);
	const [file, setFile] = useState(null);

	useEffect(() => {
		if (isEditMode && event) {
			setFormData({
				name: event.name || '',
				eventDateTime: event.eventDateTime ? event.eventDateTime.substring(0, 16) : '',
				endDateTime: event.endDateTime ? event.endDateTime.substring(0, 16) : '',
				location: event.location || '',
				description: event.description || '',
				status: event.status || 'GEPLANT',
				leaderUserId: event.leaderUserId || '',
				requiredRole: 'NUTZER',
			});
			setSkillRows(event.skillRequirements?.length > 0 ? event.skillRequirements : []);
			setItemRows(event.reservedItems?.length > 0 ? event.reservedItems : []);
		}
	}, [event, isEditMode]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const data = new FormData();
		const eventData = {
			...formData,
			requiredCourseIds: skillRows.map(r => r.requiredCourseId).filter(Boolean),
			requiredPersons: skillRows.map(r => r.requiredPersons).filter(Boolean),
			itemIds: itemRows.map(r => r.itemId).filter(Boolean),
			quantities: itemRows.map(r => r.quantity).filter(Boolean),
		};

		data.append('eventData', new Blob([JSON.stringify(eventData)], { type: 'application/json' }));
		if (file) {
			data.append('file', file);
		}

		try {
			const result = isEditMode
				? await apiClient.post(`/events/${event.id}`, data)
				: await apiClient.post('/events', data);
			if (result.success) {
				addToast(`Event erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? "Event bearbeiten" : "Neues Event erstellen"}>
			<div className="modal-tabs">
				<button className={`modal-tab-button ${activeTab === 'general' ? 'active' : ''}`} onClick={() => setActiveTab('general')}>Allgemein</button>
				<button className={`modal-tab-button ${activeTab === 'details' ? 'active' : ''}`} onClick={() => setActiveTab('details')}>Details & Bedarf</button>
			</div>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className={`modal-tab-content ${activeTab === 'general' ? 'active' : ''}`}>
					<div className="form-group"><label>Name</label><input name="name" value={formData.name} onChange={handleChange} required /></div>
					<div className="responsive-dashboard-grid">
						<div className="form-group"><label>Beginn</label><input type="datetime-local" name="eventDateTime" value={formData.eventDateTime} onChange={handleChange} required /></div>
						<div className="form-group"><label>Ende</label><input type="datetime-local" name="endDateTime" value={formData.endDateTime} onChange={handleChange} /></div>
					</div>
					<div className="form-group"><label>Ort</label><input name="location" value={formData.location} onChange={handleChange} /></div>
					<div className="form-group"><label>Beschreibung</label><textarea name="description" value={formData.description} onChange={handleChange} rows="4"></textarea></div>
				</div>

				<div className={`modal-tab-content ${activeTab === 'details' ? 'active' : ''}`}>
					<div className="form-group"><label>Status</label><select name="status" value={formData.status} onChange={handleChange}><option value="GEPLANT">Geplant</option><option value="LAUFEND">Laufend</option><option value="ABGESCHLOSSEN">Abgeschlossen</option><option value="ABGESAGT">Abgesagt</option></select></div>
					<div className="form-group"><label>Leitung</label><select name="leaderUserId" value={formData.leaderUserId} onChange={handleChange}><option value="">(Keine)</option>{users?.map(u => <option key={u.id} value={u.id}>{u.username}</option>)}</select></div>
					<div className="form-group"><label>Anhang (optional)</label><input type="file" name="file" onChange={(e) => setFile(e.target.files[0])} /></div>
					<h4>Personalbedarf</h4>
					<DynamicSkillRows rows={skillRows} setRows={setSkillRows} courses={courses} />
					<h4 style={{ marginTop: '1.5rem' }}>Materialreservierung</h4>
					<DynamicItemRows rows={itemRows} setRows={setItemRows} storageItems={storageItems} />
				</div>

				<button type="submit" className="btn" style={{ marginTop: '1.5rem' }} disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Event speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default EventModal;
========================================================================
FILE: frontend\src\components\admin\kits\KitItemsForm.jsx
========================================================================

import React, { useState } from 'react';
import apiClient from '../../../services/apiClient';

const KitItemsForm = ({ kit, allStorageItems, onUpdateSuccess }) => {
	const [items, setItems] = useState(kit.items || []);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const handleItemChange = (index, field, value) => {
		const newItems = [...items];
		newItems[index] = { ...newItems[index], [field]: value };
		setItems(newItems);
	};

	const handleAddItem = () => {
		setItems([...items, { itemId: '', quantity: 1 }]);
	};

	const handleRemoveItem = (index) => {
		const newItems = items.filter((_, i) => i !== index);
		setItems(newItems);
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const validItems = items.filter(item => item.itemId && item.quantity > 0)
			.map(item => ({ itemId: parseInt(item.itemId), quantity: parseInt(item.quantity) }));

		try {
			const result = await apiClient.put(`/kits/${kit.id}/items`, validItems);
			if (result.success) {
				onUpdateSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Inhalt konnte nicht gespeichert werden.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<form onSubmit={handleSubmit}>
			<h4>Inhalt bearbeiten</h4>
			{error && <p className="error-message">{error}</p>}
			<div id={`kit-items-container-${kit.id}`} className="kit-items-container">
				{items.length === 0 && <p className="no-items-message">Dieses Kit ist leer. Fügen Sie einen Artikel hinzu.</p>}
				{items.map((item, index) => (
					<div className="dynamic-row" key={index}>
						<select
							name="itemIds"
							className="form-group"
							value={item.itemId}
							onChange={(e) => handleItemChange(index, 'itemId', e.target.value)}
							required
						>
							<option value="">-- Artikel auswählen --</option>
							{allStorageItems.map(i => <option key={i.id} value={i.id}>{i.name}</option>)}
						</select>
						<input
							type="number"
							name="quantities"
							value={item.quantity}
							onChange={(e) => handleItemChange(index, 'quantity', e.target.value)}
							min="1"
							className="form-group"
							style={{ maxWidth: '100px' }}
							required
						/>
						<button type="button" className="btn btn-small btn-danger" onClick={() => handleRemoveItem(index)} title="Zeile entfernen">×</button>
					</div>
				))}
			</div>
			<div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
				<button type="button" className="btn btn-small" onClick={handleAddItem}>
					<i className="fas fa-plus"></i> Zeile hinzufügen
				</button>
				<button type="submit" className="btn btn-success" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : <><i className="fas fa-save"></i> Kit-Inhalt speichern</>}
				</button>
			</div>
		</form>
	);
};

export default KitItemsForm;
========================================================================
FILE: frontend\src\components\admin\kits\KitModal.jsx
========================================================================

import React, { useState } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const KitModal = ({ isOpen, onClose, onSuccess, kit }) => {
	const isEditMode = !!kit;
	const [formData, setFormData] = useState({
		name: kit?.name || '',
		description: kit?.description || '',
		location: kit?.location || ''
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		try {
			const result = isEditMode
				? await apiClient.put(`/kits/${kit.id}`, formData)
				: await apiClient.post('/kits', formData);

			if (result.success) {
				addToast(`Kit erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? "Kit bearbeiten" : "Neues Kit anlegen"}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="name-modal">Name des Kits</label>
					<input type="text" id="name-modal" name="name" value={formData.name} onChange={handleChange} required />
				</div>
				<div className="form-group">
					<label htmlFor="description-modal">Beschreibung</label>
					<textarea id="description-modal" name="description" value={formData.description} onChange={handleChange} rows="3"></textarea>
				</div>
				<div className="form-group">
					<label htmlFor="location-modal">Physischer Standort des Kits</label>
					<input type="text" id="location-modal" name="location" value={formData.location} onChange={handleChange} placeholder="z.B. Lager, Schrank 3, Fach A" />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default KitModal;
========================================================================
FILE: frontend\src\components\admin\matrix\AttendanceModal.jsx
========================================================================

import React, { useState } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const AttendanceModal = ({ isOpen, onClose, onSuccess, cellData }) => {
	const [attended, setAttended] = useState(cellData.attended);
	const [remarks, setRemarks] = useState(cellData.remarks);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			userId: cellData.userId,
			meetingId: cellData.meetingId,
			attended,
			remarks,
		};

		try {
			const result = await apiClient.put('/matrix/attendance', payload);
			if (result.success) {
				addToast('Teilnahme erfolgreich gespeichert.', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Speichern fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal
			isOpen={isOpen}
			onClose={onClose}
			title={`Teilnahme bearbeiten: ${cellData.userName}`}
		>
			<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
				Meeting: {cellData.meetingName}
			</p>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group" style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
					<input
						type="checkbox"
						id="modal-attended"
						name="attended"
						checked={attended}
						onChange={(e) => setAttended(e.target.checked)}
						style={{ width: '1.5rem', height: '1.5rem' }}
					/>
					<label htmlFor="modal-attended" style={{ marginBottom: 0 }}>
						Hat teilgenommen
					</label>
				</div>
				<div className="form-group">
					<label htmlFor="modal-remarks">Anmerkungen (z.B. "entschuldigt gefehlt")</label>
					<textarea
						id="modal-remarks"
						name="remarks"
						value={remarks}
						onChange={(e) => setRemarks(e.target.value)}
						rows="3"
					></textarea>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AttendanceModal;
========================================================================
FILE: frontend\src\components\admin\reports\UserActivityChart.jsx
========================================================================

import React from 'react';
import { Bar } from 'react-chartjs-2';
import {
	Chart as ChartJS,
	CategoryScale,
	LinearScale,
	BarElement,
	Title,
	Tooltip,
	Legend,
} from 'chart.js';

ChartJS.register(
	CategoryScale,
	LinearScale,
	BarElement,
	Title,
	Tooltip,
	Legend
);

const UserActivityChart = ({ activityData }) => {
	if (!activityData || activityData.length === 0) {
		return <p>Nicht genügend Daten für Benutzeraktivität vorhanden.</p>;
	}

	const data = {
		labels: activityData.map(d => d.username),
		datasets: [
			{
				label: 'Anzahl Event-Teilnahmen',
				data: activityData.map(d => d.participation_count),
				backgroundColor: 'rgba(0, 123, 255, 0.6)',
				borderColor: 'rgba(0, 123, 255, 1)',
				borderWidth: 1,
			},
		],
	};

	const options = {
		indexAxis: 'y', // Makes it a horizontal bar chart
		responsive: true,
		maintainAspectRatio: false,
		scales: {
			x: {
				beginAtZero: true,
				ticks: {
					stepSize: 1,
					precision: 0,
				},
			},
		},
		plugins: {
			legend: {
				display: false,
			},
			title: {
				display: true,
				text: 'Event-Teilnahmen pro Benutzer',
			},
		},
	};

	return (
		<div style={{ position: 'relative', height: '400px' }}>
			<Bar options={options} data={data} />
		</div>
	);
};

export default UserActivityChart;
========================================================================
FILE: frontend\src\components\admin\storage\StorageItemModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const StorageItemModal = ({ isOpen, onClose, onSuccess, item, initialMode = 'edit' }) => {
	const [mode, setMode] = useState(initialMode);
	const [formData, setFormData] = useState({});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	useEffect(() => {
		setMode(initialMode);
		if (initialMode === 'create') {
			setFormData({ name: '', location: '', quantity: 1, maxQuantity: 1 });
		} else if (item) {
			setFormData({ ...item });
		}
	}, [item, initialMode, isOpen]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleFileChange = (e) => {
		setFormData({ ...formData, imageFile: e.target.files[0] });
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const data = new FormData();
		Object.keys(formData).forEach(key => {
			if (key !== 'imageFile') {
				data.append(key, formData[key] === null ? '' : formData[key]);
			}
		});
		if (formData.imageFile) {
			data.append('imageFile', formData.imageFile);
		}

		try {
			const result = (mode === 'create')
				? await apiClient.post('/storage', data)
				: await apiClient.post(`/storage/${item.id}`, data);

			if (result.success) {
				addToast(`Artikel ${mode === 'create' ? 'erstellt' : 'aktualisiert'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleDefectSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			action: formData.status === 'UNREPAIRABLE' ? 'report_unrepairable' : 'report_defect',
			quantity: parseInt(formData.defective_quantity_change, 10),
			reason: formData.defect_reason_change
		};

		try {
			const result = await apiClient.put(`/storage/${item.id}`, payload);
			if (result.success) {
				addToast('Defekt-Status erfolgreich aktualisiert.', 'success');
				onSuccess();
			} else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Melden des Defekts.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleRepairSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			action: 'repair',
			quantity: parseInt(formData.repaired_quantity, 10),
			notes: formData.repair_notes
		};

		try {
			const result = await apiClient.put(`/storage/${item.id}`, payload);
			if (result.success) {
				addToast('Reparatur erfolgreich verbucht.', 'success');
				onSuccess();
			} else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Buchen der Reparatur.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const renderContent = () => {
		switch (mode) {
			case 'defect':
				return (
					<form onSubmit={handleDefectSubmit}>
						<div className="form-group">
							<label>Status</label>
							<select name="status" onChange={handleChange} defaultValue="DEFECT" className="form-group">
								<option value="DEFECT">Defekt melden</option>
								<option value="UNREPAIRABLE">Nicht reparierbar (wird ausgebucht)</option>
							</select>
						</div>
						<div className="form-group">
							<label>Anzahl defekter Artikel</label>
							<input type="number" name="defective_quantity_change" defaultValue="1" min="1" max={item.availableQuantity} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Grund</label>
							<textarea name="defect_reason_change" rows="3" onChange={handleChange}></textarea>
						</div>
						<button type="submit" className="btn" disabled={isSubmitting}>Speichern</button>
					</form>
				);
			case 'repair':
				return (
					<form onSubmit={handleRepairSubmit}>
						<div className="form-group">
							<label>Anzahl reparierter Artikel</label>
							<input type="number" name="repaired_quantity" defaultValue="1" min="1" max={item.defectiveQuantity} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Notiz (z.B. was wurde gemacht?)</label>
							<textarea name="repair_notes" rows="3" onChange={handleChange}></textarea>
						</div>
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>Als repariert buchen</button>
					</form>
				);
			case 'create':
			case 'edit':
			default:
				return (
					<form onSubmit={handleSubmit}>
						<div className="form-group">
							<label>Name</label>
							<input type="text" name="name" value={formData.name || ''} onChange={handleChange} required />
						</div>
						<div className="form-group">
							<label>Ort</label>
							<input type="text" name="location" value={formData.location || ''} onChange={handleChange} />
						</div>
						<div className="responsive-dashboard-grid">
							<div className="form-group">
								<label>Menge im Bestand</label>
								<input type="number" name="quantity" value={formData.quantity || 0} onChange={handleChange} min="0" required />
							</div>
							<div className="form-group">
								<label>Max. Menge</label>
								<input type="number" name="maxQuantity" value={formData.maxQuantity || 0} onChange={handleChange} min="0" required />
							</div>
						</div>
						<div className="form-group">
							<label>Bild (optional)</label>
							<input type="file" name="imageFile" onChange={handleFileChange} accept="image/*" />
						</div>
						<button type="submit" className="btn" disabled={isSubmitting}>Speichern</button>
					</form>
				);
		}
	};

	const getTitle = () => {
		switch (mode) {
			case 'create': return 'Neuen Artikel anlegen';
			case 'edit': return `Artikel bearbeiten: ${item?.name}`;
			case 'defect': return `Defekt-Status für "${item?.name}"`;
			case 'repair': return `Artikel "${item?.name}" repariert`;
			default: return 'Lagerartikel';
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={getTitle()}>
			{error && <p className="error-message">{error}</p>}
			{renderContent()}
		</Modal>
	);
};

export default StorageItemModal;
========================================================================
FILE: frontend\src\components\admin\users\PermissionTab.jsx
========================================================================

import React from 'react';

const PermissionsTab = ({ groupedPermissions, assignedIds, onPermissionChange, isLoading }) => {
	if (isLoading) {
		return <p>Lade Berechtigungen...</p>;
	}

	return (
		<div>
			<h4>Individuelle Berechtigungen</h4>
			<p>Diese Berechtigungen gelten zusätzlich zu denen, die eine Rolle evtl. standardmäßig hat.</p>
			<div style={{ maxHeight: '40vh', overflowY: 'auto', padding: '0.5rem', border: '1px solid var(--border-color)', borderRadius: 'var(--border-radius)' }}>
				{Object.entries(groupedPermissions).map(([groupName, permissionsInGroup]) => (
					<details key={groupName} open>
						<summary style={{ fontWeight: 'bold', cursor: 'pointer', padding: '0.5rem 0' }}>
							{groupName}
						</summary>
						<div style={{ paddingLeft: '1rem' }}>
							{permissionsInGroup.map(p => (
								<label key={p.id} style={{ display: 'flex', alignItems: 'flex-start', marginBottom: '0.5rem' }}>
									<input
										type="checkbox"
										value={p.id}
										checked={assignedIds.has(p.id)}
										onChange={() => onPermissionChange(p.id)}
										style={{ marginTop: '5px', marginRight: '10px' }}
									/>
									<div>
										<strong>{p.permissionKey.replace(groupName + '_', '')}</strong>
										<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>{p.description}</small>
									</div>
								</label>
							))}
						</div>
					</details>
				))}
			</div>
		</div>
	);
};

export default PermissionsTab;
========================================================================
FILE: frontend\src\components\admin\users\UserModal.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import Modal from '../../ui/Modal';
import PermissionsTab from './PermissionTab';
import apiClient from '../../../services/apiClient';
import { useToast } from '../../../context/ToastContext';

const UserModal = ({ isOpen, onClose, onSuccess, user, roles, groupedPermissions, isLoadingData }) => {
	const [activeTab, setActiveTab] = useState('general');
	const [formData, setFormData] = useState({});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const isEditMode = !!user;

	useEffect(() => {
		const fetchUserData = async () => {
			if (isEditMode && user) {
				try {
					const result = await apiClient.get(`/users/${user.id}`);
					if (result.success) {
						setFormData({
							username: result.data.username || '',
							roleId: result.data.roleId || '',
							classYear: result.data.classYear || '',
							className: result.data.className || '',
							email: result.data.email || '',
							permissionIds: new Set(result.data.permissions.map(p => p.id))
						});
					}
				} catch (err) {
					setError('Benutzerdetails konnten nicht geladen werden.');
				}
			} else {
				setFormData({
					username: '',
					password: '',
					roleId: roles.find(r => r.roleName === 'NUTZER')?.id || '',
					classYear: '',
					className: '',
					email: '',
					permissionIds: new Set()
				});
			}
		};
		fetchUserData();
	}, [user, isEditMode, roles, isOpen]);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handlePermissionChange = (permissionId) => {
		setFormData(prev => {
			const newPermissionIds = new Set(prev.permissionIds);
			if (newPermissionIds.has(permissionId)) {
				newPermissionIds.delete(permissionId);
			} else {
				newPermissionIds.add(permissionId);
			}
			return { ...prev, permissionIds: newPermissionIds };
		});
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const payload = {
			...formData,
			permissionIds: Array.from(formData.permissionIds || [])
		};

		if (!isEditMode && (!payload.password || payload.password.length < 10)) {
			setError('Für neue Benutzer ist ein Passwort erforderlich, das mindestens 10 Zeichen lang sein muss.');
			setIsSubmitting(false);
			return;
		}

		try {
			const result = isEditMode
				? await apiClient.put(`/users/${user.id}`, payload)
				: await apiClient.post('/users', payload);

			if (result.success) {
				addToast(`Benutzer erfolgreich ${isEditMode ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={isEditMode ? `Benutzer bearbeiten: ${user.username}` : 'Neuen Benutzer anlegen'}>
			<div className="modal-tabs">
				<button className={`modal-tab-button ${activeTab === 'general' ? 'active' : ''}`} onClick={() => setActiveTab('general')}>Allgemein</button>
				<button className={`modal-tab-button ${activeTab === 'permissions' ? 'active' : ''}`} onClick={() => setActiveTab('permissions')}>Berechtigungen</button>
			</div>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className={`modal-tab-content ${activeTab === 'general' ? 'active' : ''}`}>
					<div className="form-group">
						<label htmlFor="username-modal">Benutzername</label>
						<input type="text" id="username-modal" name="username" value={formData.username || ''} onChange={handleChange} required />
					</div>
					{!isEditMode && (
						<div className="form-group">
							<label htmlFor="password-modal">Passwort</label>
							<input type="password" id="password-modal" name="password" value={formData.password || ''} onChange={handleChange} minLength="10" />
							<small className="text-muted">Muss 10+ Zeichen, Groß/Kleinbuchstaben, Zahlen & Sonderzeichen enthalten.</small>
						</div>
					)}
					<div className="form-group">
						<label htmlFor="role-modal">Rolle</label>
						<select name="roleId" id="role-modal" value={formData.roleId || ''} onChange={handleChange} required>
							{roles.map(role => <option key={role.id} value={role.id}>{role.roleName}</option>)}
						</select>
					</div>
					<div className="form-group">
						<label htmlFor="email-modal">E-Mail</label>
						<input type="email" id="email-modal" name="email" value={formData.email || ''} onChange={handleChange} />
					</div>
				</div>

				<div className={`modal-tab-content ${activeTab === 'permissions' ? 'active' : ''}`}>
					<PermissionsTab
						groupedPermissions={groupedPermissions}
						assignedIds={formData.permissionIds || new Set()}
						onPermissionChange={handlePermissionChange}
						isLoading={isLoadingData}
					/>
				</div>

				<button type="submit" className="btn" style={{ marginTop: '1.5rem' }} disabled={isSubmitting}>
					{isSubmitting ? 'Wird gespeichert...' : 'Benutzer speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default UserModal;
========================================================================
FILE: frontend\src\components\calendar\CalendarDesktopView.jsx
========================================================================

import React, { useState, useMemo } from 'react';
import { Link } from 'react-router-dom';
import {
	format,
	addMonths,
	subMonths,
	startOfMonth,
	endOfMonth,
	startOfWeek,
	endOfWeek,
	eachDayOfInterval,
	isSameMonth,
	isToday,
	parseISO,
} from 'date-fns';
import { de } from 'date-fns/locale';

const CalendarDesktopView = ({ entries }) => {
	const [currentDate, setCurrentDate] = useState(new Date());

	const firstDayOfMonth = startOfMonth(currentDate);
	const lastDayOfMonth = endOfMonth(currentDate);
	const firstDayOfGrid = startOfWeek(firstDayOfMonth, { weekStartsOn: 1 }); // Monday start
	const lastDayOfGrid = endOfWeek(lastDayOfMonth, { weekStartsOn: 1 });
	const daysInGrid = eachDayOfInterval({ start: firstDayOfGrid, end: lastDayOfGrid });

	const eventsByDate = useMemo(() => {
		const grouped = {};
		entries.forEach(entry => {
			const dateKey = format(parseISO(entry.start), 'yyyy-MM-dd');
			if (!grouped[dateKey]) {
				grouped[dateKey] = [];
			}
			grouped[dateKey].push(entry);
		});
		return grouped;
	}, [entries]);

	const handlePrevMonth = () => setCurrentDate(subMonths(currentDate, 1));
	const handleNextMonth = () => setCurrentDate(addMonths(currentDate, 1));
	const handleToday = () => setCurrentDate(new Date());

	return (
		<div>
			<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '1rem' }}>
				<h2 style={{ margin: 0, border: 'none' }}>{format(currentDate, 'MMMM yyyy', { locale: de })}</h2>
				<div>
					<button onClick={handlePrevMonth} className="btn btn-secondary">{'<'}</button>
					<button onClick={handleToday} className="btn btn-secondary" style={{ margin: '0 0.5rem' }}>Heute</button>
					<button onClick={handleNextMonth} className="btn btn-secondary">{'>'}</button>
				</div>
			</div>
			<div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: '1px', backgroundColor: 'var(--border-color)', border: '1px solid var(--border-color)' }}>
				{['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].map(day => (
					<div key={day} style={{ textAlign: 'center', padding: '0.5rem', backgroundColor: 'var(--bg-color)', fontWeight: 'bold' }}>{day}</div>
				))}
				{daysInGrid.map(day => {
					const dateKey = format(day, 'yyyy-MM-dd');
					const dayEvents = eventsByDate[dateKey] || [];
					return (
						<div
							key={dateKey}
							style={{
								backgroundColor: 'var(--surface-color)',
								minHeight: '120px',
								padding: '0.5rem',
								opacity: isSameMonth(day, currentDate) ? 1 : 0.5,
								borderTop: isToday(day) ? '2px solid var(--primary-color)' : 'none'
							}}
						>
							<div style={{ fontWeight: isToday(day) ? 'bold' : 'normal' }}>{format(day, 'd')}</div>
							{dayEvents.map(event => (
								<Link
									key={`${event.type}-${event.id}`}
									to={event.url}
									style={{
										display: 'block',
										fontSize: '0.8rem',
										padding: '0.2rem 0.4rem',
										borderRadius: '4px',
										marginBottom: '0.25rem',
										whiteSpace: 'nowrap',
										overflow: 'hidden',
										textOverflow: 'ellipsis',
										backgroundColor: event.type === 'Event' ? 'var(--danger-color)' : 'var(--primary-color)',
										color: '#fff'
									}}
									title={event.title}
								>
									{event.title}
								</Link>
							))}
						</div>
					);
				})}
			</div>
		</div>
	);
};

export default CalendarDesktopView;
========================================================================
FILE: frontend\src\components\calendar\CalendarMobileView.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
import { format, parseISO } from 'date-fns';
import { de } from 'date-fns/locale';

const CalendarMobileView = ({ entries }) => {
	if (!entries || entries.length === 0) {
		return <div className="card"><p>Derzeit sind keine Termine geplant.</p></div>;
	}

	const sortedEntries = [...entries].sort((a, b) => parseISO(a.start) - parseISO(b.start));

	return (
		<ul className="termin-list">
			{sortedEntries.map(entry => (
				<li key={`${entry.type}-${entry.id}`}>
					<Link to={entry.url} className="termin-item-link">
						<div className="termin-item">
							<div className="termin-date">
								<span className="termin-date-day">{format(parseISO(entry.start), 'dd')}</span>
								<span className="termin-date-month">{format(parseISO(entry.start), 'MMM', { locale: de })}</span>
							</div>
							<div className="termin-details">
								<span className="termin-title">{entry.title}</span>
								<span className={`status-badge ${entry.type === 'Event' ? 'termin-type-event' : 'termin-type-lehrgang'}`}>
									{entry.type}
								</span>
							</div>
							<div className="termin-arrow">
								<i className="fas fa-chevron-right"></i>
							</div>
						</div>
					</Link>
				</li>
			))}
		</ul>
	);
};

export default CalendarMobileView;
========================================================================
FILE: frontend\src\components\layout\ErrorLayout.jsx
========================================================================

import React, { useEffect } from 'react';
import { Outlet } from 'react-router-dom';
import { useAuthStore } from '../../store/authStore';

const ErrorLayout = ({ children }) => {
	// Attempt to get the user's theme. Fallback to localStorage or light theme.
	const userTheme = useAuthStore.getState().user?.theme;

	useEffect(() => {
		const savedTheme = userTheme || localStorage.getItem('theme') || 'light';
		document.documentElement.setAttribute('data-theme', savedTheme);
		// Add a class to the body for specific error page styling if needed
		document.body.classList.add('error-page-active');

		// Cleanup function to remove the class when the component unmounts
		return () => {
			document.body.classList.remove('error-page-active');
		};
	}, [userTheme]);

	return (
		// The wrapper no longer centers content by default.
		// It now provides a full-page container for its children.
		<div className="error-page-wrapper">
			{children || <Outlet />}
		</div>
	);
};

export default ErrorLayout;
========================================================================
FILE: frontend\src\components\layout\Header.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';

const Header = ({ onNavToggle }) => {
	return (
		<header className="mobile-header">
			<button className="mobile-nav-toggle" aria-label="Navigation umschalten" onClick={onNavToggle}>
				<span className="line line-1"></span>
				<span className="line line-2"></span>
				<span className="line line-3"></span>
			</button>
			<Link to="/home" className="mobile-logo">TechnikTeam</Link>
			<div className="mobile-header-right">
				<Link to="/profil">
					<i className="fas fa-user-circle" style={{ fontSize: '1.5rem', color: 'var(--text-color)' }}></i>
				</Link>
			</div>
		</header>
	);
};

export default Header;
========================================================================
FILE: frontend\src\components\layout\MinimalLayout.jsx
========================================================================

import React from 'react';
import { Outlet } from 'react-router-dom';

/**
 * A minimal layout component for pages that should not have the main sidebar and header,
 * such as printable views or QR code landing pages.
 */
const MinimalLayout = () => {
	return (
		<div className="main-content" style={{ maxWidth: '800px', margin: '2rem auto' }}>
			<Outlet />
		</div>
	);
};

export default MinimalLayout;
========================================================================
FILE: frontend\src\components\layout\Sidebar.jsx
========================================================================

import React from 'react';
import { NavLink } from 'react-router-dom';
import { useAuthStore } from '../../store/authStore';
import ThemeSwitcher from '../ui/ThemeSwitcher';

const Sidebar = () => {
	const { user, navigationItems, logout } = useAuthStore();

	if (!user || !navigationItems) {
		return null;
	}

	const userNavItems = navigationItems.filter(item => item.requiredPermission === null);
	const adminNavItems = navigationItems.filter(item => item.requiredPermission !== null);

	const handleLogout = () => {
		logout();
	};

	const renderNavItem = (item) => {
		if (item.url.startsWith('/swagger-ui.html')) {
			return (
				<a href={item.url} target="_blank" rel="noopener noreferrer">
					<i className={`fas ${item.icon} fa-fw`}></i> {item.label}
				</a>
			);
		}
		return (
			<NavLink to={item.url} className={({ isActive }) => isActive ? 'active-nav-link' : ''}>
				<i className={`fas ${item.icon} fa-fw`}></i> {item.label}
			</NavLink>
		);
	};

	return (
		<aside className="sidebar">
			<header className="sidebar-header">
				<a href="/home" className="logo">
					<i className="fas fa-bolt"></i> TechnikTeam
				</a>
			</header>
			<nav className="sidebar-nav">
				<ul>
					{userNavItems.length > 0 && <li className="nav-section-title">Benutzerbereich</li>}
					{userNavItems.map(item => (
						<li key={`${item.label}-${item.url}`}>
							{renderNavItem(item)}
						</li>
					))}

					{adminNavItems.length > 0 && <li className="nav-section-title">Admin-Bereich</li>}
					{adminNavItems.map(item => (
						<li key={`${item.label}-${item.url}`}>
							{renderNavItem(item)}
						</li>
					))}
				</ul>
			</nav>
			<div className="user-actions">
				<div className="user-info">
					Angemeldet als: <strong>{user.username}</strong>
				</div>
				<div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
					<NavLink to="/profil" className="btn btn-secondary btn-small" style={{ flexGrow: 1 }}>Profil</NavLink>
					<button onClick={handleLogout} className="btn btn-danger-outline btn-small" style={{ flexGrow: 1 }}>Logout</button>
					<ThemeSwitcher />
				</div>
			</div>
		</aside>
	);
};

export default Sidebar;
========================================================================
FILE: frontend\src\components\profile\ProfileAchievements.jsx
========================================================================

import React from 'react';

const ProfileAchievements = ({ achievements }) => {
	return (
		<div className="card" style={{ gridColumn: '1 / -1' }} id="profile-achievements-container">
			<h2 className="card-title">Meine Abzeichen</h2>
			{achievements.length === 0 ? (
				<p>Du hast noch keine Abzeichen verdient. Nimm an Events teil, um sie freizuschalten!</p>
			) : (
				<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
					{achievements.map(ach => (
						<div className="card" key={ach.id} style={{ flex: '1', minWidth: '250px', textAlign: 'center' }}>
							<i className={`fas ${ach.iconClass}`} style={{ fontSize: '3rem', color: 'var(--primary-color)', marginBottom: '1rem' }}></i>
							<h4 style={{ margin: 0 }}>{ach.name}</h4>
							<p style={{ color: 'var(--text-muted-color)', fontSize: '0.9rem' }}>{ach.description}</p>
							<small>Verdient am: {new Date(ach.earnedAt).toLocaleDateString('de-DE')}</small>
						</div>
					))}
				</div>
			)}
		</div>
	);
};

export default ProfileAchievements;
========================================================================
FILE: frontend\src\components\profile\ProfileDetails.jsx
========================================================================

import React, { useState } from 'react';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';

const ProfileDetails = ({ user, hasPendingRequest, onUpdate }) => {
	const [isEditing, setIsEditing] = useState(false);
	const [formData, setFormData] = useState({
		email: user.email || '',
		classYear: user.classYear || '',
		className: user.className || ''
	});
	const [profilePicture, setProfilePicture] = useState(null);
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleEditToggle = () => setIsEditing(!isEditing);

	const handleChange = (e) => {
		setFormData({ ...formData, [e.target.name]: e.target.value });
	};

	const handleFileChange = (e) => {
		const file = e.target.files[0];
		if (file && file.size > 2 * 1024 * 1024) { // 2MB limit
			setError('Profilbild darf maximal 2MB groß sein.');
			e.target.value = null;
			setProfilePicture(null);
		} else {
			setError('');
			setProfilePicture(file);
		}
	};

	const handleCancel = () => {
		setFormData({
			email: user.email || '',
			classYear: user.classYear || '',
			className: user.className || ''
		});
		setProfilePicture(null);
		setIsEditing(false);
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const data = new FormData();
		data.append('profileData', new Blob([JSON.stringify(formData)], { type: 'application/json' }));
		if (profilePicture) {
			data.append('profilePicture', profilePicture);
		}

		try {
			const result = await apiClient.post('/public/profile/request-change', data);
			if (result.success) {
				addToast('Änderungsantrag erfolgreich eingereicht.', 'success');
				setIsEditing(false);
				onUpdate();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Fehler beim Einreichen der Anfrage.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleColorSubmit = async (e) => {
		e.preventDefault();
		const newColor = e.target.elements.chatColor.value;
		try {
			const result = await apiClient.put('/public/profile/chat-color', { chatColor: newColor });
			if (result.success) {
				addToast('Chat-Farbe gespeichert', 'success');
				onUpdate();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || 'Fehler beim Speichern', 'error');
		}
	}

	return (
		<div className="card" id="profile-details-container">
			<h2 className="card-title">Stammdaten</h2>
			{hasPendingRequest && (
				<div className="info-message"><i className="fas fa-info-circle"></i> Sie haben eine ausstehende Profiländerung.</div>
			)}
			{error && <div className="error-message">{error}</div>}
			<form onSubmit={handleSubmit}>
				<ul className="details-list">
					<li><strong>Benutzername:</strong> <span>{user.username}</span></li>
					<li><strong>Jahrgang:</strong> <input type="number" name="classYear" value={formData.classYear} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
					<li><strong>Klasse:</strong> <input type="text" name="className" value={formData.className} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
					<li><strong>E-Mail:</strong> <input type="email" name="email" value={formData.email} onChange={handleChange} readOnly={!isEditing} style={{ border: isEditing ? '' : 'none', background: isEditing ? '' : 'transparent' }} /></li>
					{isEditing && (
						<li>
							<strong>Profilbild:</strong>
							<input type="file" name="profilePicture" onChange={handleFileChange} accept="image/jpeg, image/png" />
						</li>
					)}
				</ul>
				{!hasPendingRequest && (
					<div style={{ marginTop: '1.5rem', display: 'flex', gap: '0.5rem' }}>
						{!isEditing ? (
							<button type="button" onClick={handleEditToggle} className="btn btn-secondary">Profil bearbeiten</button>
						) : (
							<>
								<button type="submit" className="btn btn-success" disabled={isSubmitting}>{isSubmitting ? 'Wird gesendet...' : 'Antrag einreichen'}</button>
								<button type="button" onClick={handleCancel} className="btn" style={{ backgroundColor: 'var(--text-muted-color)' }}>Abbrechen</button>
							</>
						)}
					</div>
				)}
			</form>
			<hr style={{ margin: '1.5rem 0' }} />
			<ul className="details-list">
				<li style={{ alignItems: 'center', gap: '1rem' }}>
					<strong>Chat-Farbe:</strong>
					<form onSubmit={handleColorSubmit} style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
						<input type="color" name="chatColor" defaultValue={user.chatColor || '#E9ECEF'} title="Wähle deine Chat-Farbe" />
						<button type="submit" className="btn btn-small">Speichern</button>
					</form>
				</li>
			</ul>
		</div>
	);
};

export default ProfileDetails;
========================================================================
FILE: frontend\src\components\profile\ProfileEventHistory.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';

const ProfileEventHistory = ({ eventHistory }) => {
	const formatDate = (dateString) => {
		if (!dateString) return '';
		return new Date(dateString).toLocaleString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
	};

	return (
		<div className="card" style={{ gridColumn: '1 / -1' }} id="profile-history-container">
			<h2 className="card-title">Meine Event-Historie</h2>
			<div className="desktop-table-wrapper">
				<div className="table-wrapper" style={{ maxHeight: '500px', overflowY: 'auto' }}>
					<table className="data-table">
						<thead>
							<tr>
								<th>Event</th>
								<th>Datum</th>
								<th>Dein Status</th>
								<th>Feedback</th>
							</tr>
						</thead>
						<tbody>
							{eventHistory.length === 0 ? (
								<tr><td colSpan="4">Keine Event-Historie vorhanden.</td></tr>
							) : (
								eventHistory.map(event => (
									<tr key={event.id}>
										<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
										<td>{formatDate(event.eventDateTime)} Uhr</td>
										<td>{event.userAttendanceStatus}</td>
										<td>
											{event.status === 'ABGESCHLOSSEN' && event.userAttendanceStatus === 'ZUGEWIESEN' ? (
												<Link to={`/feedback/event/${event.id}`} className="btn btn-small">Feedback geben</Link>
											) : (
												<span className="text-muted">-</span>
											)}
										</td>
									</tr>
								))
							)}
						</tbody>
					</table>
				</div>
			</div>
		</div>
	);
};

export default ProfileEventHistory;
========================================================================
FILE: frontend\src\components\profile\ProfileQualifications.jsx
========================================================================

import React from 'react';

const ProfileQualifications = ({ qualifications }) => {
	return (
		<div className="card" id="profile-qualifications-container">
			<h2 className="card-title">Meine Qualifikationen</h2>
			<div className="table-wrapper" style={{ maxHeight: '400px', overflowY: 'auto' }}>
				<table className="data-table">
					<thead>
						<tr>
							<th>Lehrgang</th>
							<th>Status</th>
						</tr>
					</thead>
					<tbody>
						{qualifications.length === 0 ? (
							<tr><td colSpan="2">Keine Qualifikationen erworben.</td></tr>
						) : (
							qualifications.map(qual => (
								<tr key={qual.courseId}>
									<td>{qual.courseName}</td>
									<td>{qual.status}</td>
								</tr>
							))
						)}
					</tbody>
				</table>
			</div>
		</div>
	);
};

export default ProfileQualifications;
========================================================================
FILE: frontend\src\components\profile\ProfileSecurity.jsx
========================================================================

import React from 'react';
import { Link } from 'react-router-dom';
// REMOVED unused imports

const ProfileSecurity = ({ onUpdate }) => {
	// REMOVED all passkey-related state and handlers

	return (
		<div className="card" id="profile-security-container">
			<h2 className="card-title">Sicherheit</h2>
			<ul className="details-list">
				<li>
					<Link to="/passwort" className="btn btn-secondary">Passwort ändern</Link>
				</li>
			</ul>
			<h3 style={{ marginTop: '1.5rem', fontSize: '1.1rem' }}>Passkeys (Passwortloser Login)</h3>
			{/* REPLACED passkey logic with placeholder */}
			<p className="text-muted">
				Dieses Feature wird zurzeit überarbeitet und ist in Kürze wieder verfügbar.
			</p>
			<button className="btn btn-success" disabled={true} style={{ marginBottom: '1rem' }}>
				<i className="fas fa-plus-circle"></i> Neues Gerät registrieren
			</button>
		</div>
	);
};

export default ProfileSecurity;
========================================================================
FILE: frontend\src\components\ui\Lightbox.jsx
========================================================================

import React, { useEffect } from 'react';

const Lightbox = ({ src, onClose }) => {
	useEffect(() => {
		const handleEscape = (event) => {
			if (event.key === 'Escape') {
				onClose();
			}
		};
		document.addEventListener('keydown', handleEscape);
		return () => {
			document.removeEventListener('keydown', handleEscape);
		};
	}, [onClose]);

	if (!src) {
		return null;
	}

	return (
		<div className="lightbox-overlay" style={{ display: 'flex' }} onClick={onClose}>
			<span className="lightbox-close" title="Schließen">×</span>
			<img
				className="lightbox-content"
				src={src}
				alt="Großansicht"
				onClick={(e) => e.stopPropagation()}
			/>
		</div>
	);
};

export default Lightbox;
========================================================================
FILE: frontend\src\components\ui\Modal.jsx
========================================================================

import React, { useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children }) => {
	useEffect(() => {
		const handleEscape = (event) => {
			if (event.key === 'Escape') {
				onClose();
			}
		};

		if (isOpen) {
			document.addEventListener('keydown', handleEscape);
		}

		return () => {
			document.removeEventListener('keydown', handleEscape);
		};
	}, [isOpen, onClose]);

	if (!isOpen) {
		return null;
	}

	return (
		<div className="modal-overlay active" onClick={onClose}>
			<div className="modal-content" onClick={(e) => e.stopPropagation()}>
				<button
					type="button"
					className="modal-close-btn"
					aria-label="Schließen"
					onClick={onClose}
				>
					×
				</button>
				{title && <h3>{title}</h3>}
				{children}
			</div>
		</div>
	);
};

export default Modal;
========================================================================
FILE: frontend\src\components\ui\StatusBadge.jsx
========================================================================

import React from 'react';

const StatusBadge = ({ status }) => {
	const getStatusClass = () => {
		const upperStatus = status?.toUpperCase() || '';
		switch (upperStatus) {
			case 'LAUFEND':
			case 'PENDING':
			case 'VIEWED':
			case 'PLANNED':
				return 'status-warn';
			case 'GEPLANT':
			case 'KOMPLETT':
			case 'ERLEDIGT':
			case 'APPROVED':
			case 'NEW':
				return 'status-ok';
			case 'ABGESCHLOSSEN':
			case 'ABGESAGT':
			case 'REJECTED':
			case 'COMPLETED':
				return 'status-info';
			default:
				return 'status-info';
		}
	};

	return <span className={`status-badge ${getStatusClass()}`}>{status}</span>;
};

export default StatusBadge;
========================================================================
FILE: frontend\src\components\ui\ThemeSwitcher.jsx
========================================================================

import React from 'react';
import { useAuthStore } from '../../store/authStore';

const ThemeSwitcher = () => {
	const { theme, setTheme } = useAuthStore();

	const toggleTheme = () => {
		const newTheme = theme === 'light' ? 'dark' : 'light';
		setTheme(newTheme);
	};

	return (
		<button
			onClick={toggleTheme}
			className="btn btn-secondary btn-small"
			title={`Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
			style={{ padding: '0.4rem 0.6rem' }}
		>
			<i className={`fas ${theme === 'light' ? 'fa-moon' : 'fa-sun'}`}></i>
		</button>
	);
};

export default ThemeSwitcher;
========================================================================
FILE: frontend\src\components\ui\ToastContainer.jsx
========================================================================

import React from 'react';
import { useToast } from '../../context/ToastContext';

const Toast = ({ message, type, onHide }) => {
	const [visible, setVisible] = React.useState(false);

	React.useEffect(() => {
		setVisible(true);
		const timer = setTimeout(() => {
			setVisible(false);
			// Give time for fade out animation before removing from DOM
			setTimeout(onHide, 400);
		}, 4600);
		return () => clearTimeout(timer);
	}, [onHide]);


	const getTypeClass = () => {
		switch (type) {
			case 'success':
				return 'toast-success';
			case 'error':
				return 'toast-danger';
			default:
				return 'toast-info';
		}
	};

	return (
		<div className={`toast ${visible ? 'show' : ''} ${getTypeClass()}`}>
			{message}
		</div>
	);
};


const ToastContainer = () => {
	const { toasts, addToast } = useToast(); // addToast isn't used here, but context provides it

	const handleHide = (id) => {
		// The timeout in ToastProvider already handles removal.
		// This component just renders what's in the state.
	};

	return (
		<div style={{ position: 'fixed', bottom: '20px', right: '20px', zIndex: 9999, display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
			{toasts.map(toast => (
				<Toast key={toast.id} message={toast.message} type={toast.type} onHide={() => handleHide(toast.id)} />
			))}
		</div>
	);
};

export default ToastContainer;
========================================================================
FILE: frontend\src\context\ToastContext.jsx
========================================================================

import React, { createContext, useState, useCallback, useContext } from 'react';

const ToastContext = createContext(null);

export const useToast = () => {
	const context = useContext(ToastContext);
	if (!context) {
		throw new Error('useToast muss innerhalb eines ToastProviders verwendet werden');
	}
	return context;
};

export const ToastProvider = ({ children }) => {
	const [toasts, setToasts] = useState([]);

	const addToast = useCallback((message, type = 'info') => {
		const id = Date.now() + Math.random();
		setToasts(prevToasts => [...prevToasts, { id, message, type }]);
		setTimeout(() => {
			setToasts(prevToasts => prevToasts.filter(toast => toast.id !== id));
		}, 5000);
	}, []);

	const value = { toasts, addToast };

	return (
		<ToastContext.Provider value={value}>
			{children}
		</ToastContext.Provider>
	);
};
========================================================================
FILE: frontend\src\hooks\useAdminData.js
========================================================================

import { useState, useEffect } from 'react';
import apiClient from '../services/apiClient';
import { useAuthStore } from '../store/authStore';

// Granular hooks for specific data needs
export const useAdminRolesAndPermissions = () => {
	const [data, setData] = useState({ roles: [], groupedPermissions: {}, loading: true, error: null });
	useEffect(() => {
		const fetchData = async () => {
			try {
				const result = await apiClient.get('/users/form-data');
				if (result.success) {
					setData({ roles: result.data.roles, groupedPermissions: result.data.groupedPermissions, loading: false, error: null });
				} else { throw new Error(result.message); }
			} catch (err) {
				setData({ roles: [], groupedPermissions: {}, loading: false, error: err.message });
			}
		};
		fetchData();
	}, []);
	return data;
};

export const useAdminCourses = () => {
	const [data, setData] = useState({ courses: [], loading: true, error: null });
	const canRead = useAuthStore(state => state.user.permissions.includes('COURSE_READ'));
	useEffect(() => {
		if (!canRead) {
			setData({ courses: [], loading: false, error: null });
			return;
		}
		const fetchData = async () => {
			try {
				const result = await apiClient.get('/courses');
				if (result.success) {
					setData({ courses: result.data, loading: false, error: null });
				} else { throw new Error(result.message); }
			} catch (err) {
				setData({ courses: [], loading: false, error: err.message });
			}
		};
		fetchData();
	}, [canRead]);
	return data;
};

// Main hook remains for components that need everything
const useAdminData = () => {
	const [data, setData] = useState({
		roles: [],
		groupedPermissions: {},
		storageItems: [],
		courses: [],
		users: [],
		loading: true,
		error: null,
	});

	const canReadCourses = useAuthStore(state => state.user.permissions.includes('COURSE_READ'));
	const canReadStorage = useAuthStore(state => state.user.permissions.includes('STORAGE_READ'));
	const canReadUsers = useAuthStore(state => state.user.permissions.includes('USER_READ'));


	useEffect(() => {
		const fetchData = async () => {
			try {
				const promises = [
					apiClient.get('/users/form-data'), // roles & permissions
					canReadStorage ? apiClient.get('/storage') : Promise.resolve({ success: true, data: [] }),
					canReadCourses ? apiClient.get('/courses') : Promise.resolve({ success: true, data: [] }),
					canReadUsers ? apiClient.get('/users') : Promise.resolve({ success: true, data: [] }),
				];

				const [usersFormData, storageItemsData, coursesData, usersData] = await Promise.all(promises);

				if (usersFormData.success && storageItemsData.success && coursesData.success && usersData.success) {
					setData({
						roles: usersFormData.data.roles,
						groupedPermissions: usersFormData.data.groupedPermissions,
						storageItems: storageItemsData.data,
						courses: coursesData.data,
						users: usersData.data,
						loading: false,
						error: null,
					});
				} else {
					throw new Error('Eine oder mehrere Admin-Datenquellen konnten nicht geladen werden.');
				}
			} catch (err) {
				setData(prev => ({
					...prev,
					loading: false,
					error: err.message || 'Fehler beim Laden der Admin-Formulardaten.',
				}));
			}
		};

		fetchData();
	}, [canReadCourses, canReadStorage, canReadUsers]);

	return data;
};

export default useAdminData;
========================================================================
FILE: frontend\src\hooks\useApi.js
========================================================================

import { useState, useEffect, useCallback } from 'react';
import apiClient from '../services/apiClient';

/**
 * A custom React hook to manage the state of an API call.
 * @param {Function} apiCall - The function from apiClient to execute.
 * @returns {object} An object containing data, loading state, error state, and a reload function.
 */
const useApi = (apiCall) => {
	const [data, setData] = useState(null);
	const [loading, setLoading] = useState(true);
	const [error, setError] = useState(null);

	const fetchData = useCallback(async () => {
		try {
			setLoading(true);
			setError(null);
			const result = await apiCall();
			if (result.success) {
				setData(result.data);
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein unerwarteter Fehler ist aufgetreten.');
		} finally {
			setLoading(false);
		}
	}, [apiCall]);

	useEffect(() => {
		fetchData();
	}, [fetchData]);

	return { data, loading, error, reload: fetchData };
};

export default useApi;
========================================================================
FILE: frontend\src\hooks\useTypingAnimation.js
========================================================================

import { useState, useEffect, useRef } from 'react';

const useTypingAnimation = (lines) => {
	const [renderedLines, setRenderedLines] = useState([]);
	const [isComplete, setIsComplete] = useState(false);
	const containerRef = useRef(null);
	const timeoutIds = useRef([]);

	useEffect(() => {
		let isCancelled = false;

		const typeLine = (lineIndex) => {
			if (isCancelled || lineIndex >= lines.length) {
				setIsComplete(true);
				return;
			}

			const currentLine = lines[lineIndex];
			setRenderedLines(prev => {
				const newLines = [...prev];
				newLines[lineIndex] = { ...currentLine, text: '' }; // Initialize line
				return newLines;
			});

			let charIndex = 0;
			const typeChar = () => {
				if (isCancelled) return;

				setRenderedLines(prev => {
					const newLines = [...prev];
					newLines[lineIndex] = {
						...currentLine,
						text: currentLine.text.substring(0, charIndex + 1),
					};
					return newLines;
				});

				if (containerRef.current) {
					containerRef.current.scrollTop = containerRef.current.scrollHeight;
				}

				if (charIndex < currentLine.text.length - 1) {
					charIndex++;
					const timeoutId = setTimeout(typeChar, currentLine.speed || 30);
					timeoutIds.current.push(timeoutId);
				} else {
					const timeoutId = setTimeout(() => typeLine(lineIndex + 1), currentLine.delayAfter || 300);
					timeoutIds.current.push(timeoutId);
				}
			};
			typeChar();
		};

		typeLine(0);

		return () => {
			isCancelled = true;
			timeoutIds.current.forEach(clearTimeout);
		};
	}, [lines]);

	return { containerRef, renderedLines, isComplete };
};

export default useTypingAnimation;
========================================================================
FILE: frontend\src\hooks\useWebSocket.js
========================================================================

import { useState, useEffect, useRef } from 'react';

/**
 * A custom hook to manage a WebSocket connection.
 * @param {string} url - The WebSocket URL to connect to.
 * @param {Function} onMessage - Callback function to handle incoming messages.
 * @returns {object} An object containing the WebSocket ready state and a sendMessage function.
 */
const useWebSocket = (url, onMessage) => {
	const [readyState, setReadyState] = useState(WebSocket.CONNECTING);
	const socketRef = useRef(null);

	useEffect(() => {
		if (!url) return;

		const connect = () => {
			// Authentication is now handled by the HttpOnly cookie, so no token is needed in the URL.
			const socket = new WebSocket(url);
			socketRef.current = socket;

			socket.onopen = () => {
				console.log('WebSocket-Verbindung hergestellt.');
				setReadyState(WebSocket.OPEN);
			};

			socket.onmessage = (event) => {
				try {
					const data = JSON.parse(event.data);
					if (onMessage) {
						onMessage(data);
					}
				} catch (error) {
					console.error('Fehler beim Parsen der WebSocket-Nachricht:', error);
				}
			};

			socket.onclose = (event) => {
				if (event.code === 4001 || event.code === 403) {
					console.error('WebSocket-Verbindung aufgrund von Authentifizierungs-/Autorisierungsfehler geschlossen.');
				} else {
					console.warn('WebSocket-Verbindung geschlossen. Versuche erneute Verbindung...');
					setTimeout(connect, 5000);
				}
				setReadyState(WebSocket.CLOSED);
			};

			socket.onerror = (error) => {
				console.error('WebSocket-Fehler:', error);
				setReadyState(WebSocket.CLOSED);
				socket.close();
			};
		};

		connect();

		return () => {
			if (socketRef.current) {
				socketRef.current.onclose = null; // Prevent reconnect attempts on component unmount
				socketRef.current.close();
			}
		};
	}, [url, onMessage]);

	const sendMessage = (messageObject) => {
		if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {
			socketRef.current.send(JSON.stringify(messageObject));
		} else {
			console.error('WebSocket ist nicht geöffnet. Nachricht kann nicht gesendet werden.');
		}
	};

	return { readyState, sendMessage };
};

export default useWebSocket;
========================================================================
FILE: frontend\src\pages\CalendarPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import CalendarDesktopView from '../components/calendar/CalendarDesktopView';
import CalendarMobileView from '../components/calendar/CalendarMobileView';

const CalendarPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/calendar/entries'), []);
	const { data: calendarEntries, loading, error } = useApi(apiCall);

	if (loading) {
		return <div>Lade Kalenderdaten...</div>;
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>
				<i className="fas fa-calendar-alt"></i> Terminübersicht
			</h1>
			<p>
				Übersicht aller anstehenden Veranstaltungen und Lehrgänge.
				<a href="/api/v1/public/calendar.ics" className="btn btn-small" style={{ marginLeft: '1rem', backgroundColor: 'var(--success-color)' }}>
					<i className="fas fa-rss"></i> Kalender abonnieren
				</a>
			</p>

			<div className="mobile-list-view">
				<CalendarMobileView entries={calendarEntries || []} />
			</div>

			<div className="desktop-calendar-view card">
				<CalendarDesktopView entries={calendarEntries || []} />
			</div>
		</div>
	);
};

export default CalendarPage;
========================================================================
FILE: frontend\src\pages\DashboardPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useAuthStore } from '../store/authStore';

const DashboardPage = () => {
	const { user } = useAuthStore();
	const apiCall = useCallback(() => apiClient.get('/public/dashboard'), []);
	const { data: dashboardData, loading, error } = useApi(apiCall);

	if (loading) {
		return (
			<div>
				<h1>Willkommen zurück, {user?.username}!</h1>
				<div className="dashboard-grid">
					<div className="card"><h2 className="card-title">Meine nächsten Einsätze</h2><p>Lade Daten...</p></div>
					<div className="card"><h2 className="card-title">Meine offenen Aufgaben</h2><p>Lade Daten...</p></div>
					<div className="card"><h2 className="card-title">Weitere anstehende Veranstaltungen</h2><p>Lade Daten...</p></div>
				</div>
			</div>
		);
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>Willkommen zurück, {user?.username}!</h1>
			<div className="dashboard-grid">
				<div className="card" id="assigned-events-widget">
					<h2 className="card-title">Meine nächsten Einsätze</h2>
					<div id="assigned-events-content">
						{dashboardData?.assignedEvents?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.assignedEvents.map(event => (
									<li key={event.id}>
										<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
										<small>{new Date(event.eventDateTime).toLocaleString('de-DE')}</small>
									</li>
								))}
							</ul>
						) : (
							<p>Du bist derzeit für keine kommenden Events fest eingeteilt.</p>
						)}
					</div>
					<Link to="/veranstaltungen" className="btn btn-small" style={{ marginTop: '1rem' }}>Alle Veranstaltungen anzeigen</Link>
				</div>

				<div className="card" id="open-tasks-widget">
					<h2 className="card-title">Meine offenen Aufgaben</h2>
					<div id="open-tasks-content">
						{dashboardData?.openTasks?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.openTasks.map(task => (
									<li key={task.id}>
										<Link to={`/veranstaltungen/details/${task.eventId}`}>
											{task.description}
											<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>
												Für Event: {task.eventName}
											</small>
										</Link>
									</li>
								))}
							</ul>
						) : (
							<p>Super! Du hast aktuell keine offenen Aufgaben.</p>
						)}
					</div>
				</div>

				<div className="card" id="upcoming-events-widget">
					<h2 className="card-title">Weitere anstehende Veranstaltungen</h2>
					<div id="upcoming-events-content">
						{dashboardData?.upcomingEvents?.length > 0 ? (
							<ul className="details-list">
								{dashboardData.upcomingEvents.map(event => (
									<li key={event.id}>
										<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
										<small>{new Date(event.eventDateTime).toLocaleString('de-DE')}</small>
									</li>
								))}
							</ul>
						) : (
							<p>Keine weiteren anstehenden Veranstaltungen.</p>
						)}
					</div>
				</div>
			</div>
		</div>
	);
};

export default DashboardPage;
========================================================================
FILE: frontend\src\pages\EventDetailsPage.jsx
========================================================================

import React, { useState, useEffect, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import useWebSocket from '../hooks/useWebSocket';
import { useAuthStore } from '../store/authStore';
import StatusBadge from '../components/ui/StatusBadge';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const EventDetailsPage = () => {
	const { eventId } = useParams();
	const { user } = useAuthStore();
	const apiCall = useCallback(() => apiClient.get(`/public/events/${eventId}`), [eventId]);
	const { data: event, loading, error } = useApi(apiCall);

	const [chatMessages, setChatMessages] = useState([]);
	const [chatInput, setChatInput] = useState('');

	const websocketProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
	const websocketUrl = event && (event.status === 'LAUFEND' || event.status === 'GEPLANT')
		? `${websocketProtocol}//${window.location.host}/ws/chat/${eventId}`
		: null;

	const handleChatMessage = (message) => {
		if (message.type === 'new_message') {
			setChatMessages(prevMessages => [...prevMessages, message.payload]);
		} else if (message.type === 'message_soft_deleted') {
			setChatMessages(prev => prev.map(msg =>
				msg.id === message.payload.messageId
					? { ...msg, isDeleted: true, deletedByUsername: message.payload.deletedByUsername }
					: msg
			));
		} else if (message.type === 'message_updated') {
			setChatMessages(prev => prev.map(msg =>
				msg.id === message.payload.messageId
					? { ...msg, messageText: message.payload.newText, edited: true }
					: msg
			));
		}
	};

	const { readyState, sendMessage } = useWebSocket(websocketUrl, handleChatMessage);

	useEffect(() => {
		if (event?.chatMessages) {
			setChatMessages(event.chatMessages);
		}
	}, [event]);

	const handleChatSubmit = (e) => {
		e.preventDefault();
		if (chatInput.trim()) {
			sendMessage({ type: "new_message", payload: { messageText: chatInput } });
			setChatInput('');
		}
	};

	if (loading) return <div>Lade Event-Details...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!event) return <div className="error-message">Event nicht gefunden.</div>;

	return (
		<div>
			<div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
				<h1>{event.name}</h1>
				<StatusBadge status={event.status} />
			</div>
			<p className="details-subtitle">
				<strong>Zeitraum:</strong> {new Date(event.eventDateTime).toLocaleString('de-DE')}
				{event.endDateTime && ` - ${new Date(event.endDateTime).toLocaleString('de-DE')}`}
			</p>

			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">Beschreibung</h2>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
							{event.description || 'Keine Beschreibung.'}
						</ReactMarkdown>
					</div>
				</div>

				<div className="card">
					<h2 className="card-title">Details</h2>
					<ul className="details-list">
						<li><strong>Ort:</strong> <span>{event.location || 'N/A'}</span></li>
						<li><strong>Leitung:</strong> <span>{event.leaderUsername || 'N/A'}</span></li>
					</ul>
				</div>

				<div className="card">
					<h2 className="card-title">Benötigter Personalbedarf</h2>
					<ul className="details-list">
						{event.skillRequirements?.length > 0 ? (
							event.skillRequirements.map(req => <li key={req.requiredCourseId}><strong>{req.courseName}:</strong> <span>{req.requiredPersons} Person(en)</span></li>)
						) : (
							<li>Keine speziellen Qualifikationen benötigt.</li>
						)}
					</ul>
				</div>

				<div className="card">
					<h2 className="card-title">Zugewiesenes Team</h2>
					<ul className="details-list">
						{event.assignedAttendees?.length > 0 ? (
							event.assignedAttendees.map(attendee => <li key={attendee.id}>{attendee.username}</li>)
						) : (
							<li>Noch kein Team zugewiesen.</li>
						)}
					</ul>
				</div>

				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<h2 className="card-title">Aufgaben</h2>
					{event.eventTasks?.length > 0 ? (
						event.eventTasks.map(task => (
							<div key={task.id} className="card" style={{ marginBottom: '1rem' }}>
								<div style={{ display: 'flex', justifyContent: 'space-between' }}>
									<h4 style={{ margin: 0 }}>{task.description}</h4>
									<StatusBadge status={task.status} />
								</div>
								<div className="markdown-content">
									<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
										{task.details || ''}
									</ReactMarkdown>
								</div>
								<p><strong>Zugewiesen an:</strong> {task.assignedUsers.map(u => u.username).join(', ') || 'Niemand'}</p>
							</div>
						))
					) : (
						<p>Für dieses Event wurden noch keine Aufgaben erstellt.</p>
					)}
				</div>

				{(event.status === 'LAUFEND' || event.status === 'GEPLANT') && (
					<div className="card" style={{ gridColumn: '1 / -1' }}>
						<h2 className="card-title">Event-Chat</h2>
						<div id="chat-box" style={{ height: '300px', overflowY: 'auto', border: '1px solid var(--border-color)', padding: '0.5rem', marginBottom: '1rem', background: 'var(--bg-color)', display: 'flex', flexDirection: 'column' }}>
							{chatMessages.map(msg => (
								<div key={msg.id} className={`chat-message-container ${msg.userId === user.id ? 'current-user' : ''}`}>
									<div className="chat-bubble" style={{ backgroundColor: msg.userId === user.id ? 'var(--primary-color)' : msg.chatColor || '#e9ecef', color: msg.userId === user.id ? '#fff' : 'var(--text-color)' }}>
										{!msg.isDeleted ? (
											<>
												{msg.userId !== user.id && <strong className="chat-username">{msg.username}</strong>}
												<span className="chat-text">
													<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
														{msg.messageText}
													</ReactMarkdown>
												</span>
												<span className="chat-timestamp">{new Date(msg.sentAt).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })}</span>
											</>
										) : (
											<span className="chat-deleted-info">Nachricht von {msg.deletedByUsername} gelöscht</span>
										)}
									</div>
								</div>
							))}
						</div>
						<form id="chat-form" onSubmit={handleChatSubmit} style={{ display: 'flex', gap: '0.5rem' }}>
							<input
								type="text"
								id="chat-message-input"
								className="form-group"
								style={{ flexGrow: 1, margin: 0 }}
								placeholder="Nachricht eingeben..."
								value={chatInput}
								onChange={(e) => setChatInput(e.target.value)}
								autoComplete="off"
								disabled={readyState !== WebSocket.OPEN}
							/>
							<button type="submit" className="btn" disabled={readyState !== WebSocket.OPEN}>Senden</button>
						</form>
					</div>
				)}
			</div>
		</div>
	);
};

export default EventDetailsPage;
========================================================================
FILE: frontend\src\pages\EventFeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const EventFeedbackPage = () => {
	const { eventId } = useParams();
	const navigate = useNavigate();
	const { addToast } = useToast();

	const [rating, setRating] = useState(0);
	const [comments, setComments] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');

	const apiCall = useCallback(() => apiClient.get(`/public/feedback/forms?eventId=${eventId}`), [eventId]);
	const { data, loading, error: fetchError } = useApi(apiCall);

	const handleSubmit = async (e) => {
		e.preventDefault();
		if (rating === 0) {
			setError('Bitte wählen Sie eine Sternebewertung aus.');
			return;
		}
		setIsSubmitting(true);
		setError('');

		try {
			const result = await apiClient.post('/public/feedback/event', {
				formId: data.form.id,
				rating,
				comments
			});
			if (result.success) {
				addToast('Vielen Dank für dein Feedback!', 'success');
				navigate('/profil');
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Feedback konnte nicht übermittelt werden.');
		} finally {
			setIsSubmitting(false);
		}
	};

	if (loading) return <div>Lade Feedback-Formular...</div>;
	if (fetchError) return <div className="error-message">{fetchError}</div>;
	if (!data) return <div className="error-message">Formulardaten nicht gefunden.</div>;

	if (data.alreadySubmitted) {
		return (
			<div className="card" style={{ maxWidth: '700px', margin: 'auto' }}>
				<h1>Feedback bereits abgegeben</h1>
				<p className="info-message">Vielen Dank, du hast bereits Feedback für das Event "{data.event.name}" abgegeben.</p>
				<Link to="/profil" className="btn">Zurück zum Profil</Link>
			</div>
		);
	}

	return (
		<div style={{ maxWidth: '700px', margin: 'auto' }}>
			<div className="card">
				<h1>Feedback für: {data.event.name}</h1>
				<p>Dein Feedback hilft uns, zukünftige Events zu verbessern.</p>
				{error && <p className="error-message">{error}</p>}
				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label>Gesamteindruck (1 = schlecht, 5 = super)</label>
						<div className="star-rating">
							{[5, 4, 3, 2, 1].map(star => (
								<React.Fragment key={star}>
									<input type="radio" id={`star${star}`} name="rating" value={star} onChange={() => setRating(star)} checked={rating === star} />
									<label htmlFor={`star${star}`} title={`${star} Sterne`}></label>
								</React.Fragment>
							))}
						</div>
					</div>
					<div className="form-group">
						<label htmlFor="comments">Kommentare & Verbesserungsvorschläge</label>
						<textarea id="comments" name="comments" value={comments} onChange={(e) => setComments(e.target.value)} rows="5"></textarea>
					</div>
					<button type="submit" className="btn" disabled={isSubmitting}>
						{isSubmitting ? 'Wird gesendet...' : 'Feedback absenden'}
					</button>
				</form>
			</div>
		</div>
	);
};

export default EventFeedbackPage;
========================================================================
FILE: frontend\src\pages\EventsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import Modal from '../components/ui/Modal';
import StatusBadge from '../components/ui/StatusBadge';
import { useToast } from '../context/ToastContext';

const EventsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/events'), []);
	const { data: events, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const [modalState, setModalState] = useState({
		isOpen: false,
		type: null,
		event: null,
		customFields: [],
	});
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [formError, setFormError] = useState('');

	const openSignupModal = async (event) => {
		try {
			const result = await apiClient.get(`/public/events/${event.id}/custom-fields`);
			setModalState({
				isOpen: true,
				type: 'signup',
				event,
				customFields: result.success ? result.data : [],
			});
		} catch (e) {
			console.error("Benutzerdefinierte Felder konnten nicht geladen werden", e);
			setModalState({ isOpen: true, type: 'signup', event, customFields: [] });
		}
	};

	const openSignoffModal = (event) => {
		setModalState({ isOpen: true, type: 'signoff', event, customFields: [] });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, type: null, event: null, customFields: [] });
		setFormError('');
	};

	const handleSignupSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setFormError('');
		const formData = new FormData(e.target);
		const customFieldData = Object.fromEntries(formData.entries());

		try {
			const result = await apiClient.post(`/public/events/${modalState.event.id}/signup`, customFieldData);
			if (result.success) {
				addToast('Erfolgreich angemeldet!', 'success');
				closeModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Anmeldung fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	const handleSignoffSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setFormError('');
		const reason = new FormData(e.target).get('reason') || '';

		try {
			const result = await apiClient.post(`/public/events/${modalState.event.id}/signoff`, { reason });
			if (result.success) {
				addToast('Erfolgreich abgemeldet.', 'success');
				closeModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Abmeldung fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};


	const getAction = (event) => {
		if (event.userAttendanceStatus === 'OFFEN' || event.userAttendanceStatus === 'ABGEMELDET') {
			return (
				<button
					type="button"
					className="btn btn-small btn-success"
					onClick={() => openSignupModal(event)}
					disabled={!event.userQualified}
					title={!event.userQualified ? 'Du erfüllst die Anforderungen für dieses Event nicht.' : ''}
				>
					Anmelden
				</button>
			);
		}
		if (event.userAttendanceStatus === 'ANGEMELDET' || event.userAttendanceStatus === 'ZUGEWIESEN') {
			return (
				<button type="button" className="btn btn-small btn-danger" onClick={() => openSignoffModal(event)}>
					Abmelden
				</button>
			);
		}
		return null;
	};

	const getUserStatusText = (status) => {
		if (status === 'ZUGEWIESEN') return <strong className="text-success">Zugewiesen</strong>;
		if (status === 'ANGEMELDET') return <strong style={{ color: 'var(--primary-color)' }}>Angemeldet</strong>;
		return status;
	};

	if (loading) return <div>Lade Veranstaltungen...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<>
			<h1><i className="fas fa-calendar-check"></i> Anstehende Veranstaltungen</h1>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Veranstaltung</th>
							<th>Datum & Uhrzeit</th>
							<th>Event-Status</th>
							<th>Dein Status</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{events.map(event => (
							<tr key={event.id}>
								<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
								<td>{new Date(event.eventDateTime).toLocaleString('de-DE')}</td>
								<td><StatusBadge status={event.status} /></td>
								<td>{getUserStatusText(event.userAttendanceStatus)}</td>
								<td>{getAction(event)}</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			<Modal
				isOpen={modalState.isOpen}
				onClose={closeModal}
				title={modalState.type === 'signup' ? `Anmeldung für: ${modalState.event?.name}` : `Abmeldung von: ${modalState.event?.name}`}
			>
				{formError && <p className="error-message">{formError}</p>}
				{modalState.type === 'signup' && (
					<form onSubmit={handleSignupSubmit}>
						{modalState.customFields.map(field => (
							<div className="form-group" key={field.id}>
								<label htmlFor={`customfield_${field.id}`}>{field.fieldName}{field.required ? '*' : ''}</label>
								<input type="text" id={`customfield_${field.id}`} name={`customfield_${field.id}`} required={field.required} />
							</div>
						))}
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>
							{isSubmitting ? 'Wird angemeldet...' : 'Verbindlich anmelden'}
						</button>
					</form>
				)}
				{modalState.type === 'signoff' && (
					<form onSubmit={handleSignoffSubmit}>
						{modalState.event?.status === 'LAUFEND' && (
							<>
								<p className="info-message">Da das Event bereits läuft, ist eine Begründung für die Abmeldung erforderlich.</p>
								<div className="form-group">
									<label htmlFor="signoff-reason">Begründung</label>
									<textarea id="signoff-reason" name="reason" rows="3" required></textarea>
								</div>
							</>
						)}
						{modalState.event?.status !== 'LAUFEND' && <p>Möchtest du dich wirklich von diesem Event abmelden?</p>}
						<button type="submit" className="btn btn-danger" disabled={isSubmitting}>
							{isSubmitting ? 'Wird abgemeldet...' : 'Jetzt abmelden'}
						</button>
					</form>
				)}
			</Modal>
		</>
	);
};

export default EventsPage;
========================================================================
FILE: frontend\src\pages\FeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import StatusBadge from '../components/ui/StatusBadge';
import { useToast } from '../context/ToastContext';

const FeedbackPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/feedback/user'), []);
	const { data: submissions, loading, error, reload } = useApi(apiCall);
	const [subject, setSubject] = useState('');
	const [content, setContent] = useState('');
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [submitError, setSubmitError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setSubmitError('');

		try {
			const result = await apiClient.post('/public/feedback/general', { subject, content });
			if (result.success) {
				addToast('Vielen Dank! Dein Feedback wurde erfolgreich übermittelt.', 'success');
				setSubject('');
				setContent('');
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setSubmitError(err.message || 'Senden fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<div>
			<h1><i className="fas fa-lightbulb"></i> Feedback & Wünsche</h1>
			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">Neues Feedback einreichen</h2>
					<p>Hast du eine Idee, einen Verbesserungsvorschlag oder ist dir ein Fehler aufgefallen?</p>

					{submitError && <p className="error-message">{submitError}</p>}

					<form onSubmit={handleSubmit}>
						<div className="form-group">
							<label htmlFor="subject">Betreff</label>
							<input type="text" id="subject" value={subject} onChange={(e) => setSubject(e.target.value)} required maxLength="255" placeholder="z.B. Feature-Wunsch: Dunkelmodus" />
						</div>
						<div className="form-group">
							<label htmlFor="content">Deine Nachricht</label>
							<textarea id="content" value={content} onChange={(e) => setContent(e.target.value)} rows="8" required placeholder="Bitte beschreibe deine Idee oder das Problem..."></textarea>
						</div>
						<button type="submit" className="btn btn-success" disabled={isSubmitting}>
							{isSubmitting ? <><i className="fas fa-spinner fa-spin"></i> Senden...</> : <><i className="fas fa-paper-plane"></i> Feedback absenden</>}
						</button>
					</form>
				</div>
				<div className="card">
					<h2 className="card-title">Mein eingereichtes Feedback</h2>
					{loading && <p>Lade Feedback...</p>}
					{error && <p className="error-message">{error}</p>}
					{submissions && submissions.length === 0 && <p>Sie haben noch kein Feedback eingereicht.</p>}
					{submissions && submissions.length > 0 && (
						<div style={{ maxHeight: '500px', overflowY: 'auto' }}>
							{submissions.map(sub => (
								<div className="list-item-card" key={sub.id} style={{ marginBottom: '1rem' }}>
									<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
										<h3 className="card-title" style={{ border: 'none', padding: 0 }}>{sub.subject}</h3>
										<StatusBadge status={sub.status} />
									</div>
									<p style={{ color: 'var(--text-muted-color)', marginTop: '-0.75rem', marginBottom: '1rem' }}>
										Eingereicht am {new Date(sub.submittedAt).toLocaleString('de-DE')}
									</p>
									<p>{sub.content}</p>
								</div>
							))}
						</div>
					)}
				</div>
			</div>
		</div>
	);
};

export default FeedbackPage;
========================================================================
FILE: frontend\src\pages\FilesPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';

const FilesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/files'), []);
	const { data: fileData, loading, error } = useApi(apiCall);

	const renderContent = () => {
		if (loading) return <div className="card"><p>Lade Dateien...</p></div>;
		if (error) return <div className="error-message">{error}</div>;
		if (!fileData || Object.keys(fileData).length === 0) {
			return <div className="card"><p>Es sind keine Dateien oder Dokumente verfügbar.</p></div>;
		}

		return Object.entries(fileData).map(([categoryName, files]) => (
			<div className="card" key={categoryName}>
				<h2>
					<i className="fas fa-folder"></i> {categoryName}
				</h2>
				<ul className="details-list">
					{files.map(file => (
						<li key={file.id} style={{ padding: '0.75rem 0' }}>
							<div>
								<a href={`/api/v1/public/files/download/${file.id}`} target="_blank" rel="noopener noreferrer">
									<i className="fas fa-download"></i> {file.filename}
								</a>
							</div>
						</li>
					))}
				</ul>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-folder-open"></i> Dateien & Dokumente</h1>
			<p>Hier können Sie zentrale Dokumente und Vorlagen herunterladen.</p>
			{renderContent()}
		</div>
	);
};

export default FilesPage;
========================================================================
FILE: frontend\src\pages\LehrgaengePage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const LehrgaengePage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/meetings'), []);
	const { data: meetings, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const handleAction = async (meetingId, action) => {
		const endpoint = `/public/meetings/${meetingId}/${action}`;
		const successMessage = action === 'signup' ? 'Erfolgreich angemeldet!' : 'Erfolgreich abgemeldet!';
		const failureMessage = action === 'signup' ? 'Anmeldung fehlgeschlagen.' : 'Abmeldung fehlgeschlagen.';

		try {
			const result = await apiClient.post(endpoint, {});
			if (result.success) {
				addToast(successMessage, 'success');
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(err.message || failureMessage, 'error');
		}
	};

	const renderActionButtons = (meeting) => {
		if (meeting.userAttendanceStatus === 'ANGEMELDET') {
			return (
				<button
					onClick={() => handleAction(meeting.id, 'signoff')}
					className="btn btn-small btn-danger"
				>
					Abmelden
				</button>
			);
		}
		return (
			<button
				onClick={() => handleAction(meeting.id, 'signup')}
				className="btn btn-small btn-success"
			>
				Anmelden
			</button>
		);
	};

	const renderUserStatus = (status) => {
		if (status === 'ANGEMELDET') {
			return <strong className="text-success">Angemeldet</strong>;
		}
		if (status === 'ABGEMELDET') {
			return <span className="text-danger">Abgemeldet</span>;
		}
		return <span className="text-muted">Offen</span>;
	};

	if (loading) return <div>Lade Lehrgänge...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-graduation-cap"></i> Anstehende Lehrgänge & Meetings</h1>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Meeting</th>
							<th>Gehört zu Kurs</th>
							<th>Datum & Uhrzeit</th>
							<th>Dein Status</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{!meetings || meetings.length === 0 ? (
							<tr><td colSpan="5" style={{ textAlign: 'center' }}>Derzeit stehen keine Lehrgänge oder Meetings an.</td></tr>
						) : (
							meetings.map(meeting => (
								<tr key={meeting.id}>
									<td><Link to={`/lehrgaenge/details/${meeting.id}`}>{meeting.name}</Link></td>
									<td>{meeting.parentCourseName}</td>
									<td>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</td>
									<td>{renderUserStatus(meeting.userAttendanceStatus)}</td>
									<td>{renderActionButtons(meeting)}</td>
								</tr>
							))
						)}
					</tbody>
				</table>
			</div>

			<div className="mobile-card-list">
				{!meetings || meetings.length === 0 ? (
					<div className="card"><p>Derzeit stehen keine Lehrgänge oder Meetings an.</p></div>
				) : (
					meetings.map(meeting => (
						<div className="list-item-card" key={meeting.id}>
							<h3 className="card-title"><Link to={`/lehrgaenge/details/${meeting.id}`}>{meeting.name}</Link></h3>
							<div className="card-row"><strong>Kurs:</strong> <span>{meeting.parentCourseName}</span></div>
							<div className="card-row"><strong>Wann:</strong> <span>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</span></div>
							<div className="card-row"><strong>Status:</strong> <span>{renderUserStatus(meeting.userAttendanceStatus)}</span></div>
							<div className="card-actions">{renderActionButtons(meeting)}</div>
						</div>
					))
				)}
			</div>
		</div>
	);
};

export default LehrgaengePage;
========================================================================
FILE: frontend\src\pages\LoginPage.jsx
========================================================================

import React, { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';
// import { passkeyService } from '../../services/passkeyService'; // REMOVED

const LoginPage = () => {
	const [username, setUsername] = useState('');
	const [password, setPassword] = useState('');
	const [isPasswordVisible, setIsPasswordVisible] = useState(false);
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');
	const navigate = useNavigate();
	const location = useLocation();

	const login = useAuthStore((state) => state.login);
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

	useEffect(() => {
		if (isAuthenticated) {
			const from = location.state?.from?.pathname || '/home';
			navigate(from, { replace: true });
		}
	}, [isAuthenticated, navigate, location.state]);

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsLoading(true);
		setError('');
		try {
			await login(username, password);
		} catch (err) {
			console.error(err);
			setError(err.message || 'Login fehlgeschlagen. Bitte überprüfen Sie Ihre Eingaben.');
		} finally {
			setIsLoading(false);
		}
	};

	// REMOVED handlePasskeyLogin function

	const togglePasswordVisibility = () => {
		setIsPasswordVisible(!isPasswordVisible);
	};

	return (
		<div className="login-page-container">
			<div className="login-box">
				<h1>
					<i className="fas fa-bolt"></i> TechnikTeam
				</h1>
				{error && <p className="error-message">{error}</p>}
				<form id="login-form" onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="username">Benutzername</label>
						<input
							type="text"
							id="username"
							name="username"
							value={username}
							onChange={(e) => setUsername(e.target.value)}
							required
							autoComplete="username" // REMOVED webauthn
							autoFocus
							disabled={isLoading}
						/>
					</div>
					<div className="form-group">
						<label htmlFor="password">Passwort</label>
						<div className="password-input-wrapper">
							<input
								type={isPasswordVisible ? 'text' : 'password'}
								id="password"
								name="password"
								value={password}
								onChange={(e) => setPassword(e.target.value)}
								required
								autoComplete="current-password"
								disabled={isLoading}
							/>
							<span className="password-toggle-icon" onClick={togglePasswordVisibility} title="Passwort anzeigen/verbergen">
								<i className={`fas ${isPasswordVisible ? 'fa-eye-slash' : 'fa-eye'}`}></i>
							</span>
						</div>
					</div>
					<button
						type="submit"
						className="btn"
						style={{ width: '100%', marginBottom: '0.75rem' }}
						disabled={isLoading}
					>
						{isLoading ? (
							<>
								<i className="fas fa-spinner fa-spin"></i> Anmelden...
							</>
						) : (
							'Anmelden'
						)}
					</button>
					{/* MODIFIED Passkey Button */}
					<button
						type="button"
						className="btn btn-secondary"
						style={{ width: '100%' }}
						disabled={true}
						title="Dieses Feature ist in Kürze verfügbar."
					>
						<i className="fas fa-fingerprint"></i> Mit Passkey anmelden (in Kürze)
					</button>
				</form>
			</div>
		</div>
	);
};

export default LoginPage;
========================================================================
FILE: frontend\src\pages\MeetingDetailsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const MeetingDetailsPage = () => {
	const { meetingId } = useParams();
	const apiCall = useCallback(() => apiClient.get(`/public/meetings/${meetingId}`), [meetingId]);
	const { data, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Meeting-Details...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!data) return <div className="error-message">Meeting nicht gefunden.</div>;

	const { meeting, attachments } = data;

	return (
		<div>
			<h1>{meeting.parentCourseName}</h1>
			<h2 style={{ border: 'none', padding: 0, marginTop: '-1rem' }}>{meeting.name}</h2>

			<div className="responsive-dashboard-grid" style={{ gridTemplateColumns: '2fr 1fr', alignItems: 'flex-start' }}>
				<div className="card">
					<ul className="details-list">
						<li>
							<strong>Datum & Uhrzeit:</strong>
							<span>
								{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}
								{meeting.endDateTime && ` - ${new Date(meeting.endDateTime).toLocaleString('de-DE')}`}
							</span>
						</li>
						<li><strong>Ort:</strong> <span>{meeting.location || 'N/A'}</span></li>
						<li><strong>Leitung:</strong> <span>{meeting.leaderUsername || 'N/A'}</span></li>
					</ul>
					<h3 style={{ marginTop: '2rem' }}>Beschreibung</h3>
					<div className="markdown-content">
						<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
							{meeting.description || 'Keine Beschreibung für dieses Meeting vorhanden.'}
						</ReactMarkdown>
					</div>
				</div>

				<div className="card">
					<h2 className="card-title">Anhänge</h2>
					{attachments?.length > 0 ? (
						<ul className="details-list">
							{attachments.map(att => (
								<li key={att.id}>
									<a href={`/api/v1/public/files/download/${att.id}`} target="_blank" rel="noopener noreferrer">{att.filename}</a>
								</li>
							))}
						</ul>
					) : (
						<p>Für dieses Meeting sind keine Anhänge verfügbar.</p>
					)}
				</div>
			</div>

			<div style={{ marginTop: '1rem' }}>
				<Link to="/lehrgaenge" className="btn btn-secondary">
					<i className="fas fa-arrow-left"></i> Zurück zu allen Lehrgängen
				</Link>
			</div>
		</div>
	);
};

export default MeetingDetailsPage;
========================================================================
FILE: frontend\src\pages\PackKitPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';

const PackKitPage = () => {
	const { kitId } = useParams();
	const apiCall = useCallback(() => apiClient.get(`/public/kits/${kitId}`), [kitId]);
	const { data: kit, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Packliste...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!kit) return <div className="error-message">Kit nicht gefunden.</div>;

	return (
		<div className="card">
			<style>{`
                @media print {
                    body * {
                        visibility: hidden;
                    }
                    .printable-area, .printable-area * {
                        visibility: visible;
                    }
                    .printable-area {
                        position: absolute;
                        left: 0;
                        top: 0;
                        width: 100%;
                    }
                    .no-print {
                        display: none !important;
                    }
                }
            `}</style>
			<div className="printable-area">
				<div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start' }}>
					<div>
						<h1>Packliste: {kit.name}</h1>
						<p className="details-subtitle" style={{ marginTop: '-1rem' }}>
							{kit.description}
						</p>
					</div>
					<button className="btn no-print" onClick={() => window.print()}>
						<i className="fas fa-print"></i> Drucken
					</button>
				</div>

				{kit.location && (
					<div className="card" style={{ backgroundColor: 'var(--bg-color)' }}>
						<h3 className="card-title" style={{ border: 'none', padding: 0 }}>Standort</h3>
						<p style={{ fontSize: '1.2rem', fontWeight: '500' }}>{kit.location}</p>
					</div>
				)}

				<h3 style={{ marginTop: '2rem' }}>Inhalt zum Einpacken</h3>
				<ul className="details-list">
					{!kit.items || kit.items.length === 0 ? (
						<li>Dieses Kit hat keinen definierten Inhalt.</li>
					) : (
						kit.items.map(item => (
							<li key={item.itemId}>
								<label style={{ display: 'flex', alignItems: 'center', gap: '1rem', cursor: 'pointer', width: '100%' }}>
									<input type="checkbox" style={{ width: '1.5rem', height: '1.5rem', flexShrink: 0 }} />
									<span>
										<strong>{item.quantity}x</strong> {item.itemName}
									</span>
								</label>
							</li>
						))
					)}
				</ul>
			</div>
			<div className="no-print" style={{ marginTop: '2rem', textAlign: 'center' }}>
				<Link to="/lager" className="btn btn-secondary">Zurück zur Lagerübersicht</Link>
			</div>
		</div>
	);
};

export default PackKitPage;
========================================================================
FILE: frontend\src\pages\PasswordPage.jsx
========================================================================

import React, { useState } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import { useToast } from '../context/ToastContext';

const PasswordPage = () => {
	const [currentPassword, setCurrentPassword] = useState('');
	const [newPassword, setNewPassword] = useState('');
	const [confirmPassword, setConfirmPassword] = useState('');
	const [isLoading, setIsLoading] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setError('');

		if (newPassword.length < 10) {
			setError('Das neue Passwort muss mindestens 10 Zeichen lang sein.');
			return;
		}
		if (newPassword !== confirmPassword) {
			setError('Die neuen Passwörter stimmen nicht überein.');
			return;
		}

		setIsLoading(true);

		try {
			const result = await apiClient.put('/public/profile/password', {
				currentPassword,
				newPassword,
				confirmPassword
			});

			if (result.success) {
				addToast('Ihr Passwort wurde erfolgreich geändert.', 'success');
				setCurrentPassword('');
				setNewPassword('');
				setConfirmPassword('');
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Ein Fehler ist aufgetreten.');
		} finally {
			setIsLoading(false);
		}
	};

	return (
		<div style={{ maxWidth: '600px', margin: 'auto' }}>
			<div className="card">
				<h1>Passwort ändern</h1>
				<p className="text-muted" style={{ marginTop: '-1rem', marginBottom: '1.5rem' }}>
					Das neue Passwort muss mindestens 10 Zeichen lang sein und Groß-, Kleinbuchstaben, Zahlen und Sonderzeichen enthalten.
				</p>

				{error && <p className="error-message">{error}</p>}

				<form onSubmit={handleSubmit}>
					<div className="form-group">
						<label htmlFor="currentPassword">Aktuelles Passwort</label>
						<input type="password" id="currentPassword" value={currentPassword} onChange={(e) => setCurrentPassword(e.target.value)} required autoComplete="current-password" />
					</div>
					<div className="form-group">
						<label htmlFor="newPassword">Neues Passwort</label>
						<input type="password" id="newPassword" value={newPassword} onChange={(e) => setNewPassword(e.target.value)} required autoComplete="new-password" />
					</div>
					<div className="form-group">
						<label htmlFor="confirmPassword">Neues Passwort bestätigen</label>
						<input type="password" id="confirmPassword" value={confirmPassword} onChange={(e) => setConfirmPassword(e.target.value)} required autoComplete="new-password" />
					</div>
					<button type="submit" className="btn" disabled={isLoading}>
						{isLoading ? <><i className="fas fa-spinner fa-spin"></i> Speichern...</> : <><i className="fas fa-save"></i> Passwort speichern</>}
					</button>
					<Link to="/profil" className="btn btn-secondary" style={{ marginLeft: '1rem' }}>Zurück zum Profil</Link>
				</form>
			</div>
		</div>
	);
};

export default PasswordPage;
========================================================================
FILE: frontend\src\pages\ProfilePage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import ProfileDetails from '../components/profile/ProfileDetails';
import ProfileSecurity from '../components/profile/ProfileSecurity';
import ProfileQualifications from '../components/profile/ProfileQualifications';
import ProfileAchievements from '../components/profile/ProfileAchievements';
import ProfileEventHistory from '../components/profile/ProfileEventHistory';
import { useToast } from '../context/ToastContext';

const ProfilePage = () => {
	const { addToast } = useToast();
	const apiCall = useCallback(() => apiClient.get('/public/profile'), []);
	const { data: profileData, loading, error, reload } = useApi(apiCall);

	const handleUpdate = () => {
		addToast('Profildaten aktualisiert', 'success');
		reload();
	};

	if (loading) {
		return (
			<div>
				<h1>Mein Profil</h1>
				<p>Lade Profildaten...</p>
			</div>
		);
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	if (!profileData) {
		return <div>Keine Profildaten gefunden.</div>;
	}

	const { user, eventHistory, qualifications, achievements, passkeys, hasPendingRequest } = profileData;

	return (
		<div>
			<h1><i className="fas fa-user-circle"></i> Mein Profil</h1>
			<p>Hier finden Sie eine Übersicht Ihrer Daten, Qualifikationen und Aktivitäten.</p>
			<div className="responsive-dashboard-grid" id="profile-container">
				<ProfileDetails user={user} hasPendingRequest={hasPendingRequest} onUpdate={handleUpdate} />
				<ProfileSecurity passkeys={passkeys} onUpdate={handleUpdate} />
				<ProfileQualifications qualifications={qualifications} />
				<ProfileAchievements achievements={achievements} />
				<ProfileEventHistory eventHistory={eventHistory} />
			</div>
		</div>
	);
};

export default ProfilePage;
========================================================================
FILE: frontend\src\pages\StorageItemDetailsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../hooks/useApi';
import apiClient from '../services/apiClient';
import Lightbox from '../components/ui/Lightbox';

const StorageItemDetailsPage = () => {
	const { itemId } = useParams();
	const [activeTab, setActiveTab] = useState('history');
	const [isLightboxOpen, setIsLightboxOpen] = useState(false);

	const fetchItemCall = useCallback(() => apiClient.get(`/public/storage/${itemId}`), [itemId]);
	const fetchHistoryCall = useCallback(() => apiClient.get(`/public/storage/${itemId}/history`), [itemId]);

	const { data: itemData, loading: itemLoading, error: itemError } = useApi(fetchItemCall);
	const { data: historyData, loading: historyLoading, error: historyError } = useApi(fetchHistoryCall);

	if (itemLoading || historyLoading) return <div>Lade Artikeldetails...</div>;
	if (itemError) return <div className="error-message">{itemError}</div>;
	if (!itemData) return <div className="error-message">Artikel nicht gefunden.</div>;

	const item = itemData;
	const { transactions, maintenance } = historyData || { transactions: [], maintenance: [] };

	return (
		<>
			<h1><i className="fas fa-cube"></i> Artikeldetails</h1>
			<div className="responsive-dashboard-grid" style={{ alignItems: 'flex-start' }}>
				<div className="card">
					<h2 className="card-title">{item.name}</h2>
					{item.imagePath && (
						<img
							src={`/api/v1/public/files/images/${item.imagePath}`}
							alt={item.name}
							style={{ width: '100%', borderRadius: 'var(--border-radius)', marginBottom: '1rem', cursor: 'zoom-in' }}
							onClick={() => setIsLightboxOpen(true)}
						/>
					)}
					<ul className="details-list">
						<li><strong>Allg. Status:</strong> <span className={`status-badge ${item.availabilityStatusCssClass}`}>{item.availabilityStatus}</span></li>
						<li><strong>Verfügbar / Gesamt:</strong> <span>{item.availableQuantity} / {item.quantity}</span></li>
						<li><strong>Defekt:</strong> <span>{item.defectiveQuantity}</span></li>
						<li><strong>Tracking-Status:</strong> <span>{item.status}</span></li>
						{item.currentHolderUsername && <li><strong>Aktueller Inhaber:</strong> <span>{item.currentHolderUsername}</span></li>}
						<li><strong>Ort:</strong> <span>{item.location}</span></li>
						<li><strong>Schrank:</strong> <span>{item.cabinet || 'N/A'}</span></li>
						<li><strong>Fach:</strong> <span>{item.compartment || 'N/A'}</span></li>
					</ul>
				</div>

				<div className="card">
					<div className="modal-tabs">
						<button className={`modal-tab-button ${activeTab === 'history' ? 'active' : ''}`} onClick={() => setActiveTab('history')}>Verlauf</button>
						<button className={`modal-tab-button ${activeTab === 'maintenance' ? 'active' : ''}`} onClick={() => setActiveTab('maintenance')}>Wartungshistorie</button>
					</div>

					{activeTab === 'history' && (
						<div className="modal-tab-content active">
							{historyError && <p className="error-message">{historyError}</p>}
							{!historyLoading && transactions.length === 0 && <p>Kein Verlauf für diesen Artikel vorhanden.</p>}
							{transactions.length > 0 && (
								<div className="table-wrapper" style={{ maxHeight: '60vh', overflowY: 'auto' }}>
									<table className="data-table">
										<thead><tr><th>Wann</th><th>Aktion</th><th>Wer</th><th>Notiz</th></tr></thead>
										<tbody>
											{transactions.map(entry => (
												<tr key={entry.id}>
													<td>{new Date(entry.transactionTimestamp).toLocaleString('de-DE')}</td>
													<td><span className={`status-badge ${entry.quantityChange > 0 ? 'status-ok' : 'status-danger'}`}>{entry.quantityChange > 0 ? '+' : ''}{entry.quantityChange}</span></td>
													<td>{entry.username}</td>
													<td>{entry.notes || '-'}</td>
												</tr>
											))}
										</tbody>
									</table>
								</div>
							)}
						</div>
					)}

					{activeTab === 'maintenance' && (
						<div className="modal-tab-content active">
							{historyError && <p className="error-message">{historyError}</p>}
							{!historyLoading && maintenance.length === 0 && <p>Keine Wartungseinträge für diesen Artikel vorhanden.</p>}
							{maintenance.length > 0 && (
								<div className="table-wrapper" style={{ maxHeight: '60vh', overflowY: 'auto' }}>
									<table className="data-table">
										<thead><tr><th>Datum</th><th>Aktion</th><th>Bearbeiter</th><th>Notiz</th></tr></thead>
										<tbody>
											{maintenance.map(entry => (
												<tr key={entry.id}>
													<td>{new Date(entry.logDate).toLocaleString('de-DE')}</td>
													<td>{entry.action}</td>
													<td>{entry.username}</td>
													<td>{entry.notes || '-'}</td>
												</tr>
											))}
										</tbody>
									</table>
								</div>
							)}
						</div>
					)}
				</div>
			</div>
			<div style={{ marginTop: '1rem' }}>
				<Link to="/lager" className="btn btn-secondary"><i className="fas fa-arrow-left"></i> Zur Lagerübersicht</Link>
			</div>

			{isLightboxOpen && <Lightbox src={`/api/v1/public/files/images/${item.imagePath}`} onClose={() => setIsLightboxOpen(false)} />}
		</>
	);
};

export default StorageItemDetailsPage;
========================================================================
FILE: frontend\src\pages\StoragePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import apiClient from '../services/apiClient';
import useApi from '../hooks/useApi';
import Modal from '../components/ui/Modal';
import Lightbox from '../components/ui/Lightbox';
import { useToast } from '../context/ToastContext';

const StoragePage = () => {
	const apiCall = useCallback(() => apiClient.get('/public/storage'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [selectedItem, setSelectedItem] = useState(null);
	const [isLightboxOpen, setIsLightboxOpen] = useState(false);
	const [lightboxSrc, setLightboxSrc] = useState('');
	const [transactionError, setTransactionError] = useState('');
	const { addToast } = useToast();

	const handleActionClick = (item) => {
		setSelectedItem(item);
		setTransactionError('');
		setIsModalOpen(true);
	};

	const handleImageClick = (imagePath) => {
		setLightboxSrc(`/api/v1/public/files/images/${imagePath}`);
		setIsLightboxOpen(true);
	};

	const handleTransactionSubmit = async (e) => {
		e.preventDefault();
		const submitter = e.nativeEvent.submitter;
		const formData = new FormData(e.target);
		const quantity = parseInt(formData.get('quantity'), 10);

		if (isNaN(quantity) || quantity < 1) {
			setTransactionError("Bitte geben Sie eine gültige Anzahl an.");
			return;
		}

		const transactionData = {
			itemId: selectedItem.id,
			quantity: quantity,
			type: submitter.value,
			notes: formData.get('notes'),
			eventId: formData.get('eventId') ? parseInt(formData.get('eventId'), 10) : null,
		};

		try {
			const result = await apiClient.post('/public/storage/transactions', transactionData);
			if (result.success) {
				addToast(result.message, 'success');
				setIsModalOpen(false);
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setTransactionError(err.message || 'Transaction failed.');
		}
	};

	if (loading) return <div>Lade Lagerdaten...</div>;
	if (error) return <div className="error-message">{error}</div>;

	const { storageData, activeEvents } = data;

	return (
		<>
			<h1><i className="fas fa-boxes"></i> Lagerübersicht</h1>
			<p>Hier finden Sie eine Übersicht aller erfassten Artikel im Lager. Klicken Sie auf einen Artikelnamen für Details und Verlauf.</p>

			{Object.entries(storageData).map(([location, items]) => (
				<div className="card" key={location}>
					<h2><i className="fas fa-map-marker-alt"></i> {location}</h2>
					<div className="desktop-table-wrapper">
						<table className="data-table">
							<thead>
								<tr>
									<th>Gerät</th>
									<th>Schrank</th>
									<th>Fach</th>
									<th>Status</th>
									<th>Bestand</th>
									<th>Aktion</th>
								</tr>
							</thead>
							<tbody>
								{items.map(item => (
									<tr key={item.id}>
										<td className="item-name-cell">
											<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
											{item.imagePath && (
												<button className="btn btn-small btn-secondary" style={{ marginLeft: '0.5rem', padding: '0.2rem 0.5rem' }} title="Bild anzeigen" onClick={() => handleImageClick(item.imagePath)}>
													<i className="fas fa-camera"></i>
												</button>
											)}
										</td>
										<td>{item.cabinet || '-'}</td>
										<td>{item.compartment || '-'}</td>
										<td>
											<span className={`status-badge ${item.availabilityStatusCssClass}`}>
												{item.availabilityStatus}
											</span>
										</td>
										<td>
											<span>{item.availableQuantity} / {item.maxQuantity}</span>
											{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} defekt)</span>}
										</td>
										<td>
											<button className="btn btn-small" onClick={() => handleActionClick(item)}>Aktion</button>
										</td>
									</tr>
								))}
							</tbody>
						</table>
					</div>
				</div>
			))}

			{selectedItem && (
				<Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title={`${selectedItem.name}: Entnehmen / Einräumen`}>
					<form onSubmit={handleTransactionSubmit}>
						{transactionError && <p className="error-message">{transactionError}</p>}
						<div className="form-group">
							<label htmlFor="transaction-quantity">Anzahl</label>
							<input type="number" name="quantity" id="transaction-quantity" defaultValue="1" min="1" max={selectedItem.availableQuantity} required />
						</div>
						<div className="form-group">
							<label htmlFor="transaction-notes">Notiz (optional)</label>
							<input type="text" name="notes" id="transaction-notes" placeholder="z.B. für Event XYZ" />
						</div>
						<div className="form-group">
							<label htmlFor="transaction-eventId">Zuweisen zu Event (optional)</label>
							<select name="eventId" id="transaction-eventId">
								<option value="">Kein Event</option>
								{activeEvents.map(event => (
									<option key={event.id} value={event.id}>{event.name}</option>
								))}
							</select>
						</div>
						<div style={{ display: 'flex', justifyContent: 'space-between', gap: '1rem' }}>
							<button type="submit" name="type" value="checkout" className="btn btn-danger" style={{ flexGrow: 1 }} disabled={selectedItem.availableQuantity <= 0}>Entnehmen</button>
							<button type="submit" name="type" value="checkin" className="btn btn-success" style={{ flexGrow: 1 }} disabled={selectedItem.maxQuantity > 0 && selectedItem.quantity >= selectedItem.maxQuantity}>Einräumen</button>
						</div>
					</form>
				</Modal>
			)}

			{isLightboxOpen && <Lightbox src={lightboxSrc} onClose={() => setIsLightboxOpen(false)} />}
		</>
	);
};

export default StoragePage;
========================================================================
FILE: frontend\src\pages\admin\AdminAchievementsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminAchievementsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/achievements'), []);
	const { data: achievements, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingAchievement, setEditingAchievement] = useState(null);
	const { addToast } = useToast();

	const openModal = (achievement = null) => {
		setEditingAchievement(achievement);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingAchievement(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (ach) => {
		if (window.confirm(`Abzeichen "${ach.name}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/achievements/${ach.id}`);
				if (result.success) {
					addToast('Abzeichen erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-award"></i> Abzeichen verwalten</h1>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Abzeichen
				</button>
			</div>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Icon</th>
							<th>Name</th>
							<th>Schlüssel</th>
							<th>Beschreibung</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="5">Lade Abzeichen...</td></tr>}
						{error && <tr><td colSpan="5" className="error-message">{error}</td></tr>}
						{achievements?.map(ach => (
							<tr key={ach.id}>
								<td><i className={`fas ${ach.iconClass}`} style={{ fontSize: '1.5rem' }}></i></td>
								<td>{ach.name}</td>
								<td><code>{ach.achievementKey}</code></td>
								<td>{ach.description}</td>
								<td>
									<button onClick={() => openModal(ach)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(ach)} className="btn btn-small btn-danger" style={{ marginLeft: '0.5rem' }}>Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{isModalOpen && (
				<AchievementModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					achievement={editingAchievement}
				/>
			)}
		</div>
	);
};

const AchievementModal = ({ isOpen, onClose, onSuccess, achievement }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		try {
			const result = achievement
				? await apiClient.put(`/achievements/${achievement.id}`, data)
				: await apiClient.post('/achievements', data);
			if (result.success) {
				addToast(`Abzeichen erfolgreich ${achievement ? 'aktualisiert' : 'erstellt'}.`, 'success');
				onSuccess();
			}
			else throw new Error(result.message);
		} catch (err) {
			setError(err.message || 'Fehler beim Speichern');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title={achievement ? 'Abzeichen bearbeiten' : 'Neues Abzeichen erstellen'}>
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="modal-name">Name</label>
					<input id="modal-name" name="name" defaultValue={achievement?.name} required />
				</div>
				<div className="form-group">
					<label htmlFor="modal-key">Achievement Schlüssel</label>
					<input id="modal-key" name="achievementKey" defaultValue={achievement?.achievementKey} required pattern="[A-Z0-9_]+" title="Nur Großbuchstaben, Zahlen und Unterstriche" />
				</div>
				<div className="form-group">
					<label htmlFor="modal-desc">Beschreibung</label>
					<textarea id="modal-desc" name="description" defaultValue={achievement?.description} rows="3" required></textarea>
				</div>
				<div className="form-group">
					<label htmlFor="modal-icon">Font Awesome Icon-Klasse</label>
					<input id="modal-icon" name="iconClass" defaultValue={achievement?.iconClass} placeholder="z.B. fa-star" required />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Speichern...' : 'Speichern'}
				</button>
			</form>
		</Modal>
	);
};

export default AdminAchievementsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminCoursesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminCoursesPage = () => {
	const apiCall = useCallback(() => apiClient.get('/courses'), []);
	const { data: courses, loading, error, reload } = useApi(apiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingCourse, setEditingCourse] = useState(null);
	const [formError, setFormError] = useState('');
	const { addToast } = useToast();

	const handleOpenNewModal = () => {
		setEditingCourse(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (course) => {
		setEditingCourse(course);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingCourse(null);
		setFormError('');
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		try {
			const result = editingCourse
				? await apiClient.put(`/courses/${editingCourse.id}`, data)
				: await apiClient.post('/courses', data);

			if (result.success) {
				addToast(`Vorlage erfolgreich ${editingCourse ? 'aktualisiert' : 'erstellt'}.`, 'success');
				handleCloseModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Ein Fehler ist aufgetreten.');
		}
	};

	const handleDelete = async (course) => {
		if (window.confirm(`Vorlage '${course.name}' wirklich löschen? Alle zugehörigen Meetings und Qualifikationen werden auch gelöscht!`)) {
			try {
				const result = await apiClient.delete(`/courses/${course.id}`);
				if (result.success) {
					addToast('Vorlage erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-book"></i> Lehrgangs-Vorlagen verwalten</h1>
			<p>Dies sind die übergeordneten Lehrgänge. Einzelne Termine (Meetings) werden für jede Vorlage separat verwaltet.</p>

			<div className="table-controls">
				<button onClick={handleOpenNewModal} className="btn btn-success">
					<i className="fas fa-plus"></i> Neue Vorlage
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name der Vorlage</th>
							<th>Abkürzung (für Matrix)</th>
							<th style={{ minWidth: '350px' }}>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="3">Lade Vorlagen...</td></tr>}
						{error && <tr><td colSpan="3" className="error-message">{error}</td></tr>}
						{courses?.map(course => (
							<tr key={course.id}>
								<td>{course.name}</td>
								<td>{course.abbreviation}</td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<Link to={`/admin/lehrgaenge/${course.id}/meetings`} className="btn btn-small">
										<i className="fas fa-calendar-day"></i> Meetings
									</Link>
									<button onClick={() => handleOpenEditModal(course)} className="btn btn-small btn-secondary">
										<i className="fas fa-edit"></i> Bearbeiten
									</button>
									<button onClick={() => handleDelete(course)} className="btn btn-small btn-danger">
										<i className="fas fa-trash"></i> Löschen
									</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{isModalOpen && (
				<Modal isOpen={isModalOpen} onClose={handleCloseModal} title={editingCourse ? "Lehrgangs-Vorlage bearbeiten" : "Neue Lehrgangs-Vorlage anlegen"}>
					<form onSubmit={handleSubmit}>
						{formError && <p className="error-message">{formError}</p>}
						<div className="form-group">
							<label htmlFor="name-modal">Name der Vorlage</label>
							<input type="text" id="name-modal" name="name" defaultValue={editingCourse?.name} required />
						</div>
						<div className="form-group">
							<label htmlFor="abbreviation-modal">Abkürzung (max. 10 Zeichen)</label>
							<input type="text" id="abbreviation-modal" name="abbreviation" defaultValue={editingCourse?.abbreviation} maxLength="10" required />
						</div>
						<div className="form-group">
							<label htmlFor="description-modal">Allgemeine Beschreibung</label>
							<textarea id="description-modal" name="description" defaultValue={editingCourse?.description} rows="4"></textarea>
						</div>
						<button type="submit" className="btn">
							<i className="fas fa-save"></i> Vorlage Speichern
						</button>
					</form>
				</Modal>
			)}
		</div>
	);
};

export default AdminCoursesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDashboardPage.jsx
========================================================================

import React, { useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useAuthStore } from '../../store/authStore';
import Widget from '../../components/admin/dashboard/Widget';
import EventTrendChart from '../../components/admin/dashboard/EventTrendChart';

const AdminDashboardPage = () => {
	const { user } = useAuthStore();
	// This single endpoint now provides all necessary data for the dashboard.
	const apiCall = useCallback(() => apiClient.get('/admin/dashboard'), []);
	const { data: dashboardData, loading, error } = useApi(apiCall);

	const renderWidgetContent = (widgetData, renderItem, emptyMessage) => {
		if (!widgetData || widgetData.length === 0) {
			return <p>{emptyMessage}</p>;
		}
		return <ul className="details-list">{widgetData.map(renderItem)}</ul>;
	};

	if (loading) {
		return <h1>Lade Admin Dashboard...</h1>;
	}

	if (error) {
		return <div className="error-message">{error}</div>;
	}

	return (
		<div>
			<h1>Willkommen im Admin-Bereich, {user?.username}!</h1>
			<p>Hier können Sie die Anwendung verwalten. Wählen Sie eine Option aus der Navigation oder nutzen Sie den Schnellzugriff.</p>

			<div className="dashboard-grid">
				<Widget icon="fa-calendar-alt" title="Anstehende Events" linkTo="/admin/veranstaltungen" linkText="Alle Events anzeigen">
					{renderWidgetContent(
						dashboardData?.upcomingEvents,
						(event) => (
							<li key={event.id}>
								<Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link>
								<small>{new Date(event.eventDateTime).toLocaleDateString('de-DE')}</small>
							</li>
						),
						'Keine anstehenden Events.'
					)}
				</Widget>

				<Widget icon="fa-box-open" title="Niedriger Lagerbestand" linkTo="/admin/lager" linkText="Lager verwalten">
					{renderWidgetContent(
						dashboardData?.lowStockItems,
						(item) => (
							<li key={item.id}>
								<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
								<span className="status-badge status-warn">{item.availableQuantity} / {item.maxQuantity}</span>
							</li>
						),
						'Alle Artikel sind ausreichend vorhanden.'
					)}
				</Widget>

				<Widget icon="fa-history" title="Letzte Aktionen" linkTo="/admin/log" linkText="Alle Logs anzeigen">
					{renderWidgetContent(
						dashboardData?.recentLogs,
						(log) => (
							<li key={log.id}>
								<span><strong>{log.adminUsername}</strong>: {log.actionType}</span>
								<small>{new Date(log.actionTimestamp).toLocaleString('de-DE')}</small>
							</li>
						),
						'Keine Aktionen protokolliert.'
					)}
				</Widget>
			</div>

			<div className="card" style={{ marginTop: '2rem' }}>
				<h2 className="card-title">Event-Trend (Letzte 12 Monate)</h2>
				<EventTrendChart trendData={dashboardData?.eventTrendData} />
			</div>
		</div>
	);
};

export default AdminDashboardPage;
========================================================================
FILE: frontend\src\pages\admin\AdminDefectivePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StorageItemModal from '../../components/admin/storage/StorageItemModal';
import { useToast } from '../../context/ToastContext';

const AdminDefectivePage = () => {
	const apiCall = useCallback(() => apiClient.get('/storage?status=defective'), []);
	const { data: items, loading, error, reload } = useApi(apiCall);
	const [modalState, setModalState] = useState({ isOpen: false, item: null, mode: 'defect' });
	const { addToast } = useToast();

	const openModal = (mode, item) => {
		setModalState({ isOpen: true, item, mode });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, item: null, mode: 'defect' });
	};

	const handleSuccess = () => {
		addToast('Status erfolgreich aktualisiert', 'success');
		closeModal();
		reload();
	};

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade defekte Artikel...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!items || items.length === 0) return <tr><td colSpan="4" style={{ textAlign: 'center' }}>Aktuell sind keine Artikel als defekt gemeldet.</td></tr>;

		return items.map(item => (
			<tr key={item.id}>
				<td><Link to={`/lager/details/${item.id}`}>{item.name}</Link></td>
				<td>{item.defectiveQuantity} / {item.quantity}</td>
				<td>{item.defectReason || '-'}</td>
				<td>
					<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Status bearbeiten</button>
				</td>
			</tr>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-wrench"></i> Defekte Artikel verwalten</h1>
			<p>Hier sind alle Artikel gelistet, von denen mindestens ein Exemplar als defekt markiert wurde.</p>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Defekt / Gesamt</th>
							<th>Grund</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>

			{modalState.isOpen && (
				<StorageItemModal
					isOpen={modalState.isOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					item={modalState.item}
					initialMode={modalState.mode}
				/>
			)}
		</div>
	);
};

export default AdminDefectivePage;
========================================================================
FILE: frontend\src\pages\admin\AdminEventsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import useAdminData from '../../hooks/useAdminData';
import Modal from '../../components/ui/Modal';
import StatusBadge from '../../components/ui/StatusBadge';
import EventModal from '../../components/admin/events/EventModal';
import { useToast } from '../../context/ToastContext';

const AdminEventsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/events'), []);
	const { data: events, loading, error, reload } = useApi(apiCall);
	const adminFormData = useAdminData();
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingEvent, setEditingEvent] = useState(null);
	const { addToast } = useToast();

	const openModal = (event = null) => {
		setEditingEvent(event);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingEvent(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (event) => {
		if (window.confirm(`Event '${event.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/events/${event.id}`);
				if (result.success) {
					addToast('Event erfolgreich gelöscht', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-calendar-plus"></i> Event-Verwaltung</h1>
			<p>Hier können alle Veranstaltungen geplant, bearbeitet und verwaltet werden.</p>
			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Event erstellen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Event-Name</th>
							<th>Datum & Uhrzeit</th>
							<th>Status</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Events...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{events?.map(event => (
							<tr key={event.id}>
								<td><Link to={`/veranstaltungen/details/${event.id}`}>{event.name}</Link></td>
								<td>{new Date(event.eventDateTime).toLocaleString('de-DE')}</td>
								<td><StatusBadge status={event.status} /></td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<button onClick={() => openModal(event)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(event)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>
			{/* Prevent modal from rendering before its required data is available */}
			{isModalOpen && !adminFormData.loading && (
				<EventModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					event={editingEvent}
					adminFormData={adminFormData}
				/>
			)}
		</div>
	);
};

export default AdminEventsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminFeedbackPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StatusBadge from '../../components/ui/StatusBadge';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const FeedbackColumn = ({ title, submissions, onCardClick }) => (
	<div className="feedback-column">
		<h2>{title}</h2>
		<div className="feedback-list">
			{submissions.map(sub => (
				<div key={sub.id} className="feedback-card-item" onClick={() => onCardClick(sub)}>
					<strong className="subject">{sub.subject}</strong>
					<p className="content-preview">{sub.content}</p>
					<div className="meta">
						<span>Von: {sub.username}</span>
					</div>
				</div>
			))}
		</div>
	</div>
);

const AdminFeedbackPage = () => {
	const apiCall = useCallback(() => apiClient.get('/feedback'), []);
	const { data: submissions, loading, error, reload } = useApi(apiCall);
	const [selectedFeedback, setSelectedFeedback] = useState(null);
	const { addToast } = useToast();

	const groupedSubmissions = submissions?.reduce((acc, sub) => {
		(acc[sub.status] = acc[sub.status] || []).push(sub);
		return acc;
	}, {}) || {};

	const handleStatusChange = async (newStatus) => {
		if (!selectedFeedback) return;
		try {
			const result = await apiClient.put(`/feedback/${selectedFeedback.id}/status`, { status: newStatus });
			if (result.success) {
				addToast('Status erfolgreich aktualisiert', 'success');
				setSelectedFeedback(null);
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Ändern des Status: ${err.message}`, 'error');
		}
	};

	if (loading) return <div>Lade Feedback...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-inbox"></i> Feedback-Verwaltung</h1>
			<p>Verwalten Sie hier alle Benutzereinreichungen. Klicken Sie auf eine Karte, um den Status zu ändern.</p>
			<div className="feedback-board">
				<FeedbackColumn title="Neu" submissions={groupedSubmissions['NEW'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Gesehen" submissions={groupedSubmissions['VIEWED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Geplant" submissions={groupedSubmissions['PLANNED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Erledigt" submissions={groupedSubmissions['COMPLETED'] || []} onCardClick={setSelectedFeedback} />
				<FeedbackColumn title="Abgelehnt" submissions={groupedSubmissions['REJECTED'] || []} onCardClick={setSelectedFeedback} />
			</div>

			{selectedFeedback && (
				<Modal isOpen={!!selectedFeedback} onClose={() => setSelectedFeedback(null)} title={selectedFeedback.subject}>
					<p><strong>Von:</strong> {selectedFeedback.username}</p>
					<p><strong>Eingereicht am:</strong> {new Date(selectedFeedback.submittedAt).toLocaleString('de-DE')}</p>
					<div className="card" style={{ backgroundColor: 'var(--bg-color)', whiteSpace: 'pre-wrap' }}>{selectedFeedback.content}</div>
					<div style={{ marginTop: '1.5rem' }}>
						<h4>Status ändern:</h4>
						<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
							{['NEW', 'VIEWED', 'PLANNED', 'COMPLETED', 'REJECTED'].map(status => (
								<button key={status} onClick={() => handleStatusChange(status)} className="btn btn-small">
									{status}
								</button>
							))}
						</div>
					</div>
				</Modal>
			)}
		</div>
	);
};

export default AdminFeedbackPage;
========================================================================
FILE: frontend\src\pages\admin\AdminFilesPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';

const FileUploadModal = ({ isOpen, onClose, onSuccess, categories }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');
		const formData = new FormData(e.target);
		const file = formData.get('file');

		if (file.size > 10 * 1024 * 1024) { // 10MB limit
			setError('Datei ist zu groß. Maximal 10MB erlaubt.');
			setIsSubmitting(false);
			return;
		}

		try {
			const result = await apiClient.post('/admin/files', formData);
			if (result.success) {
				addToast('Datei erfolgreich hochgeladen', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Upload fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Datei hochladen">
			<form onSubmit={handleSubmit} encType="multipart/form-data">
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="file-upload">Datei auswählen</label>
					<input type="file" id="file-upload" name="file" required />
				</div>
				<div className="form-group">
					<label htmlFor="categoryId-upload">Kategorie</label>
					<select name="categoryId" id="categoryId-upload">
						<option value="">(Ohne Kategorie)</option>
						{categories.map(cat => <option key={cat.id} value={cat.id}>{cat.name}</option>)}
					</select>
				</div>
				<div className="form-group">
					<label htmlFor="requiredRole-upload">Sichtbarkeit</label>
					<select name="requiredRole" id="requiredRole-upload" defaultValue="NUTZER">
						<option value="NUTZER">Alle Benutzer</option>
						<option value="ADMIN">Nur Admins</option>
					</select>
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird hochgeladen...' : 'Hochladen'}
				</button>
			</form>
		</Modal>
	);
};


const AdminFilesPage = () => {
	const filesApiCall = useCallback(() => apiClient.get('/admin/files'), []);
	const categoriesApiCall = useCallback(() => apiClient.get('/admin/files/categories'), []);

	const { data: filesGrouped, loading: filesLoading, error: filesError, reload: reloadFiles } = useApi(filesApiCall);
	const { data: categories, loading: catsLoading, error: catsError, reload: reloadCats } = useApi(categoriesApiCall);
	const [isModalOpen, setIsModalOpen] = useState(false);
	const { addToast } = useToast();

	const handleSuccess = () => {
		setIsModalOpen(false);
		reloadFiles();
		reloadCats();
	};

	const handleDeleteFile = async (file) => {
		if (window.confirm(`Datei "${file.filename}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/admin/files/${file.id}`);
				if (result.success) {
					addToast('Datei gelöscht', 'success');
					reloadFiles();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(err.message, 'error');
			}
		}
	};

	const handleCreateCategory = async () => {
		const name = prompt('Name für die neue Kategorie:');
		if (name) {
			try {
				await apiClient.post('/admin/files/categories', { name });
				addToast('Kategorie erstellt', 'success');
				reloadCats();
				reloadFiles();
			} catch (err) {
				addToast(err.message, 'error');
			}
		}
	};

	const renderContent = () => {
		if (filesLoading) return <div className="card"><p>Lade Dateien...</p></div>;
		if (filesError) return <div className="error-message">{filesError}</div>;

		if (!filesGrouped || Object.keys(filesGrouped).length === 0) {
			return <div className="card"><p>Es sind keine Dateien oder Dokumente verfügbar.</p></div>;
		}

		return Object.entries(filesGrouped).map(([categoryName, files]) => (
			<div className="card" key={categoryName}>
				<h2><i className="fas fa-folder"></i> {categoryName}</h2>
				<ul className="details-list">
					{files.map(file => (
						<li key={file.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
							<div>
								<a href={`/api/v1/public/files/download/${file.id}`} target="_blank" rel="noopener noreferrer">
									<i className="fas fa-download"></i> {file.filename}
								</a>
								<small style={{ display: 'block', color: 'var(--text-muted-color)' }}>
									Sichtbarkeit: {file.requiredRole}
								</small>
							</div>
							<div>
								<button onClick={() => handleDeleteFile(file)} className="btn btn-small btn-danger">Löschen</button>
							</div>
						</li>
					))}
				</ul>
			</div>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-file-upload"></i> Datei-Verwaltung</h1>
			<p>Hier können Sie alle zentralen Dokumente und Vorlagen verwalten.</p>
			<div className="table-controls">
				<button onClick={() => setIsModalOpen(true)} className="btn btn-success">
					<i className="fas fa-upload"></i> Neue Datei hochladen
				</button>
				<button onClick={handleCreateCategory} className="btn btn-secondary">
					<i className="fas fa-folder-plus"></i> Neue Kategorie
				</button>
			</div>
			{catsError && <p className="error-message">{catsError}</p>}
			{renderContent()}

			{isModalOpen && (
				<FileUploadModal
					isOpen={isModalOpen}
					onClose={() => setIsModalOpen(false)}
					onSuccess={handleSuccess}
					categories={categories || []}
				/>
			)}
		</div>
	);
};

export default AdminFilesPage;
========================================================================
FILE: frontend\src\pages\admin\AdminKitsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import useAdminData from '../../hooks/useAdminData';
import apiClient from '../../services/apiClient';
import KitModal from '../../components/admin/kits/KitModal';
import KitItemsForm from '../../components/admin/kits/KitItemsForm';
import Modal from '../../components/ui/Modal';
import QRCode from 'qrcode.react';
import { useToast } from '../../context/ToastContext';

const KitAccordion = ({ kit, onEdit, onDelete, onItemsUpdate, allStorageItems }) => {
	const [isOpen, setIsOpen] = useState(false);
	const [isQrModalOpen, setIsQrModalOpen] = useState(false);
	const packKitUrl = `${window.location.origin}/pack-kit/${kit.id}`;

	return (
		<div className="kit-container" style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '1.5rem', marginBottom: '1.5rem' }}>
			<div className="kit-header" onClick={() => setIsOpen(!isOpen)} style={{ cursor: 'pointer', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
				<div>
					<h3>
						<i className={`fas ${isOpen ? 'fa-chevron-down' : 'fa-chevron-right'}`} style={{ marginRight: '0.75rem', transition: 'transform 0.2s' }}></i>
						{kit.name}
					</h3>
					<p style={{ margin: '-0.5rem 0 0 1.75rem', color: 'var(--text-muted-color)' }}>{kit.description}</p>
				</div>
				<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }} onClick={e => e.stopPropagation()}>
					<button onClick={() => setIsQrModalOpen(true)} className="btn btn-small">QR-Code</button>
					<button onClick={() => onEdit(kit)} className="btn btn-small btn-secondary">Bearbeiten</button>
					<button onClick={() => onDelete(kit)} className="btn btn-small btn-danger">Löschen</button>
				</div>
			</div>
			{isOpen && (
				<div className="kit-content" style={{ paddingLeft: '2rem', marginTop: '1rem' }}>
					<KitItemsForm kit={kit} allStorageItems={allStorageItems} onUpdateSuccess={onItemsUpdate} />
				</div>
			)}
			<Modal isOpen={isQrModalOpen} onClose={() => setIsQrModalOpen(false)} title={`QR-Code für: ${kit.name}`}>
				<div style={{ textAlign: 'center', padding: '1rem' }}>
					<QRCode value={packKitUrl} size={256} />
					<p style={{ marginTop: '1rem' }}>Scannen, um die Packliste zu öffnen.</p>
				</div>
			</Modal>
		</div>
	);
};

const AdminKitsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/kits'), []);
	const { data: kits, loading, error, reload } = useApi(apiCall);
	const { storageItems } = useAdminData();
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingKit, setEditingKit] = useState(null);
	const { addToast } = useToast();

	const openModal = (kit = null) => {
		setEditingKit(kit);
		setIsModalOpen(true);
	};

	const closeModal = () => {
		setEditingKit(null);
		setIsModalOpen(false);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (kit) => {
		if (window.confirm(`Kit '${kit.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/kits/${kit.id}`);
				if (result.success) {
					addToast('Kit erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-box-open"></i> Kit-Verwaltung</h1>
			<p>Verwalten Sie hier wiederverwendbare Material-Zusammenstellungen (Kits oder Koffer).</p>

			<div className="table-controls">
				<button onClick={() => openModal()} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Kit anlegen
				</button>
			</div>

			<div className="card">
				{loading && <p>Lade Kits...</p>}
				{error && <p className="error-message">{error}</p>}
				{kits?.map(kit => (
					<KitAccordion
						key={kit.id}
						kit={kit}
						onEdit={openModal}
						onDelete={handleDelete}
						onItemsUpdate={reload}
						allStorageItems={storageItems}
					/>
				))}
			</div>

			{isModalOpen && (
				<KitModal
					isOpen={isModalOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					kit={editingKit}
				/>
			)}
		</div>
	);
};

export default AdminKitsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminLogPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';

const AdminLogPage = () => {
	const apiCall = useCallback(() => apiClient.get('/logs'), []);
	const { data: logs, loading, error } = useApi(apiCall);

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade Logs...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!logs || logs.length === 0) return <tr><td colSpan="4" style={{ textAlign: 'center' }}>Keine Log-Einträge gefunden.</td></tr>;

		return logs.map(log => (
			<tr key={log.id}>
				<td>{new Date(log.actionTimestamp).toLocaleString('de-DE')} Uhr</td>
				<td>{log.adminUsername}</td>
				<td>{log.actionType}</td>
				<td style={{ whiteSpace: 'normal' }}>{log.details}</td>
			</tr>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-clipboard-list"></i> Admin Aktions-Protokoll</h1>
			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Wann</th>
							<th>Wer</th>
							<th>Aktionstyp</th>
							<th>Details</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>
		</div>
	);
};

export default AdminLogPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMatrixPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import AttendanceModal from '../../components/admin/matrix/AttendanceModal';

const AdminMatrixPage = () => {
	const apiCall = useCallback(() => apiClient.get('/matrix'), []);
	const { data, loading, error, reload } = useApi(apiCall);
	const [modalData, setModalData] = useState(null);

	const openModal = (cellData) => {
		setModalData(cellData);
	};

	const closeModal = () => {
		setModalData(null);
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	if (loading) return <div>Lade Matrix-Daten...</div>;
	if (error) return <div className="error-message">{error}</div>;

	const { users, courses, meetingsByCourse, attendanceMap } = data;

	return (
		<div>
			<h1><i className="fas fa-th-list"></i> Qualifikations-Matrix</h1>
			<p>Klicken Sie auf eine Zelle, um die Teilnahme an einem Meeting zu bearbeiten. Die Kopfzeile und die Benutzerleiste bleiben beim Scrollen fixiert.</p>

			<div className="table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th rowSpan="2" className="sticky-header sticky-col" style={{ verticalAlign: 'middle', left: 0, zIndex: 15 }}>Nutzer / Lehrgang ↓</th>
							{courses.map(course => (
								<th key={course.id} colSpan={meetingsByCourse[course.id]?.length || 1} className="sticky-header" style={{ textAlign: 'center' }}>
									<Link to={`/admin/lehrgaenge/${course.id}/meetings`} title={`Meetings für '${course.name}' verwalten`}>
										{course.abbreviation}
									</Link>
								</th>
							))}
						</tr>
						<tr>
							{courses.map(course => (
								(meetingsByCourse[course.id] || []).map(meeting => (
									<th key={meeting.id} className="sticky-header" style={{ textAlign: 'center', minWidth: '120px' }}>
										{meeting.name}
									</th>
								))
							))}
						</tr>
					</thead>
					<tbody>
						{users.map(user => (
							<tr key={user.id}>
								<td className="sticky-col" style={{ fontWeight: '500', left: 0 }}>{user.username}</td>
								{courses.map(course => (
									(meetingsByCourse[course.id] || []).map(meeting => {
										const attendance = attendanceMap[`${user.id}-${meeting.id}`];
										const attended = attendance ? attendance.attended : false;

										const cellData = {
											userId: user.id,
											userName: user.username,
											meetingId: meeting.id,
											meetingName: `${course.name} - ${meeting.name}`,
											attended: attended,
											remarks: attendance?.remarks || ''
										};

										return (
											<td
												key={meeting.id}
												className="qual-cell"
												onClick={() => openModal(cellData)}
												style={{ textAlign: 'center', fontWeight: 'bold', cursor: 'pointer' }}
												title="Klicken zum Bearbeiten"
											>
												{attended ?
													<span style={{ fontSize: '1.2rem', color: 'var(--success-color)' }}>✔</span> :
													<span className="text-muted">-</span>
												}
											</td>
										);
									})
								))}
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{modalData && (
				<AttendanceModal
					isOpen={!!modalData}
					onClose={closeModal}
					onSuccess={handleSuccess}
					cellData={modalData}
				/>
			)}
		</div>
	);
};

export default AdminMatrixPage;
========================================================================
FILE: frontend\src\pages\admin\AdminMeetingsPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { useParams, Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminMeetingsPage = () => {
	const { courseId } = useParams();
	const meetingsApiCall = useCallback(() => apiClient.get(`/meetings?courseId=${courseId}`), [courseId]);
	const usersApiCall = useCallback(() => apiClient.get('/users'), []);

	const { data: meetingsData, loading, error, reload } = useApi(meetingsApiCall);
	const { data: allUsers } = useApi(usersApiCall);
	const { addToast } = useToast();

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingMeeting, setEditingMeeting] = useState(null);
	const [formError, setFormError] = useState('');

	const courseName = meetingsData?.[0]?.parentCourseName || 'Lehrgang';

	const handleOpenNewModal = () => {
		setEditingMeeting(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (meeting) => {
		setEditingMeeting(meeting);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingMeeting(null);
		setFormError('');
	};

	const handleSubmit = async (e) => {
		e.preventDefault();
		const formData = new FormData(e.target);
		const data = Object.fromEntries(formData.entries());

		const payload = {
			...data,
			courseId: parseInt(courseId),
			leaderUserId: data.leaderUserId ? parseInt(data.leaderUserId) : null
		};

		try {
			const result = editingMeeting
				? await apiClient.put(`/meetings/${editingMeeting.id}`, payload)
				: await apiClient.post('/meetings', payload);

			if (result.success) {
				addToast(`Meeting erfolgreich ${editingMeeting ? 'aktualisiert' : 'geplant'}.`, 'success');
				handleCloseModal();
				reload();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setFormError(err.message || 'Ein Fehler ist aufgetreten.');
		}
	};

	const handleDelete = async (meeting) => {
		if (window.confirm(`Meeting '${meeting.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/meetings/${meeting.id}`);
				if (result.success) {
					addToast('Meeting gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1>Meetings für "{courseName}"</h1>
			<Link to="/admin/lehrgaenge" style={{ marginBottom: '1rem', display: 'inline-block' }}>
				<i className="fas fa-arrow-left"></i> Zurück zu allen Vorlagen
			</Link>

			<div className="table-controls">
				<button onClick={handleOpenNewModal} className="btn btn-success">
					<i className="fas fa-plus"></i> Neues Meeting planen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Meeting-Name</th>
							<th>Datum & Uhrzeit</th>
							<th>Leitung</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="4">Lade Meetings...</td></tr>}
						{error && <tr><td colSpan="4" className="error-message">{error}</td></tr>}
						{meetingsData?.map(meeting => (
							<tr key={meeting.id}>
								<td>{meeting.name}</td>
								<td>{new Date(meeting.meetingDateTime).toLocaleString('de-DE')}</td>
								<td>{meeting.leaderUsername || 'N/A'}</td>
								<td style={{ display: 'flex', gap: '0.5rem' }}>
									<button onClick={() => handleOpenEditModal(meeting)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => handleDelete(meeting)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{isModalOpen && (
				<Modal isOpen={isModalOpen} onClose={handleCloseModal} title={editingMeeting ? "Meeting bearbeiten" : "Neues Meeting planen"}>
					<form onSubmit={handleSubmit}>
						{formError && <p className="error-message">{formError}</p>}
						<div className="form-group">
							<label htmlFor="name-modal">Name des Meetings</label>
							<input type="text" id="name-modal" name="name" defaultValue={editingMeeting?.name} required />
						</div>
						<div className="responsive-dashboard-grid">
							<div className="form-group">
								<label htmlFor="meetingDateTime-modal">Beginn</label>
								<input type="datetime-local" id="meetingDateTime-modal" name="meetingDateTime" defaultValue={editingMeeting?.meetingDateTime ? editingMeeting.meetingDateTime.substring(0, 16) : ''} required />
							</div>
							<div className="form-group">
								<label htmlFor="endDateTime-modal">Ende (optional)</label>
								<input type="datetime-local" id="endDateTime-modal" name="endDateTime" defaultValue={editingMeeting?.endDateTime ? editingMeeting.endDateTime.substring(0, 16) : ''} />
							</div>
						</div>
						<div className="form-group">
							<label htmlFor="location-modal">Ort</label>
							<input type="text" id="location-modal" name="location" defaultValue={editingMeeting?.location} />
						</div>
						<div className="form-group">
							<label htmlFor="leader-modal">Leitende Person</label>
							<select name="leaderUserId" id="leader-modal" defaultValue={editingMeeting?.leaderUserId}>
								<option value="">(Keine)</option>
								{allUsers?.map(user => <option key={user.id} value={user.id}>{user.username}</option>)}
							</select>
						</div>
						<div className="form-group">
							<label htmlFor="description-modal">Beschreibung</label>
							<textarea id="description-modal" name="description" defaultValue={editingMeeting?.description} rows="3"></textarea>
						</div>
						<button type="submit" className="btn"><i className="fas fa-save"></i> Speichern</button>
					</form>
				</Modal>
			)}
		</div>
	);
};

export default AdminMeetingsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminReportsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import EventTrendChart from '../../components/admin/dashboard/EventTrendChart';
import UserActivityChart from '../../components/admin/reports/UserActivityChart';

const AdminReportsPage = () => {
	const apiCall = useCallback(() => apiClient.get('/reports/dashboard'), []);
	const { data: reportData, loading, error } = useApi(apiCall);

	if (loading) return <div>Lade Berichte...</div>;
	if (error) return <div className="error-message">{error}</div>;
	if (!reportData) return <div className="card"><p>Keine Berichtsdaten verfügbar.</p></div>;

	const { eventTrend, userActivity, totalInventoryValue } = reportData;

	const getCsvLink = (reportType) => `/api/v1/reports/${reportType}?export=csv`;

	return (
		<div>
			<h1><i className="fas fa-chart-pie"></i> Berichte & Analysen</h1>
			<p>Hier finden Sie zusammengefasste Daten und Analysen über die Anwendungsnutzung.</p>

			<div className="dashboard-grid">
				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<h2 className="card-title">Event-Trend (Letzte 12 Monate)</h2>
					<EventTrendChart trendData={eventTrend} />
				</div>

				<div className="card">
					<h2 className="card-title">Top 10 Aktivste Benutzer</h2>
					<UserActivityChart activityData={userActivity} />
				</div>

				<div className="card">
					<h2 className="card-title">Sonstige Berichte & Exporte</h2>
					<ul className="details-list">
						<li>
							<span>Teilnahme-Zusammenfassung</span>
							<a href={getCsvLink('event-participation')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Nutzungsfrequenz (Material)</span>
							<a href={getCsvLink('inventory-usage')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Vollständige Benutzeraktivität</span>
							<a href={getCsvLink('user-activity')} className="btn btn-small btn-success"><i className="fas fa-file-csv"></i> Als CSV exportieren</a>
						</li>
						<li>
							<span>Gesamtwert des Lagers</span>
							<span style={{ fontWeight: 'bold' }}>
								{new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(totalInventoryValue)}
							</span>
						</li>
					</ul>
				</div>
			</div>
		</div>
	);
};

export default AdminReportsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminRequestsPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';

const AdminRequestsPage = () => {
	// Corrected API endpoint
	const apiCall = useCallback(() => apiClient.get('/requests/pending'), []);
	const { data: requests, loading, error, reload } = useApi(apiCall);
	const { addToast } = useToast();

	const handleAction = async (requestId, action) => {
		// Corrected API endpoint
		const endpoint = `/requests/${requestId}/${action}`;
		const confirmationText = action === 'approve'
			? 'Änderungen wirklich übernehmen?'
			: 'Antrag wirklich ablehnen?';

		if (window.confirm(confirmationText)) {
			try {
				const result = await apiClient.post(endpoint);
				if (result.success) {
					addToast(`Antrag erfolgreich ${action === 'approve' ? 'genehmigt' : 'abgelehnt'}.`, 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	const renderChanges = (changesJson) => {
		try {
			const changes = JSON.parse(changesJson);
			return (
				<ul style={{ paddingLeft: '1.5rem', margin: 0 }}>
					{Object.entries(changes).map(([key, value]) => (
						<li key={key}><strong>{key}:</strong> {value}</li>
					))}
				</ul>
			);
		} catch (e) {
			return <span className="text-danger">Fehler beim Parsen der Änderungen.</span>;
		}
	};

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade Anträge...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!requests || requests.length === 0) return <tr><td colSpan="4" style={{ textAlign: 'center' }}>Keine offenen Anträge vorhanden.</td></tr>;

		return requests.map(req => (
			<tr key={req.id}>
				<td>{req.username}</td>
				<td>{new Date(req.requestedAt).toLocaleString('de-DE')}</td>
				<td>{renderChanges(req.requestedChanges)}</td>
				<td style={{ display: 'flex', gap: '0.5rem' }}>
					<button onClick={() => handleAction(req.id, 'approve')} className="btn btn-small btn-success">Genehmigen</button>
					<button onClick={() => handleAction(req.id, 'deny')} className="btn btn-small btn-danger">Ablehnen</button>
				</td>
			</tr>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-inbox"></i> Offene Anträge</h1>
			<p>Hier sehen Sie alle von Benutzern beantragten Änderungen an Stammdaten. Genehmigte Änderungen werden sofort wirksam.</p>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Benutzer</th>
							<th>Beantragt am</th>
							<th>Gewünschte Änderungen</th>
							<th>Aktion</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>
		</div>
	);
};

export default AdminRequestsPage;
========================================================================
FILE: frontend\src\pages\admin\AdminStoragePage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import { Link } from 'react-router-dom';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import StorageItemModal from '../../components/admin/storage/StorageItemModal';
import Lightbox from '../../components/ui/Lightbox';
import StatusBadge from '../../components/ui/StatusBadge';
import { useToast } from '../../context/ToastContext';

const AdminStoragePage = () => {
	const apiCall = useCallback(() => apiClient.get('/storage'), []);
	const { data: items, loading, error, reload } = useApi(apiCall);
	const [modalState, setModalState] = useState({ isOpen: false, item: null, mode: 'edit' });
	const [lightboxSrc, setLightboxSrc] = useState('');
	const { addToast } = useToast();

	const openModal = (mode, item = null) => {
		setModalState({ isOpen: true, item, mode });
	};

	const closeModal = () => {
		setModalState({ isOpen: false, item: null, mode: 'edit' });
	};

	const handleSuccess = () => {
		closeModal();
		reload();
	};

	const handleDelete = async (item) => {
		if (window.confirm(`Artikel '${item.name}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/storage/${item.id}`);
				if (result.success) {
					addToast('Artikel gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	return (
		<div>
			<h1><i className="fas fa-warehouse"></i> Lagerverwaltung</h1>
			<div className="table-controls">
				<button onClick={() => openModal('create')} className="btn btn-success">
					<i className="fas fa-plus"></i> Neuen Artikel anlegen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>Name</th>
							<th>Ort</th>
							<th>Verfügbar</th>
							<th>Status</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{loading && <tr><td colSpan="5">Lade Artikel...</td></tr>}
						{error && <tr><td colSpan="5" className="error-message">{error}</td></tr>}
						{items?.map(item => (
							<tr key={item.id}>
								<td className="item-name-cell">
									<Link to={`/lager/details/${item.id}`}>{item.name}</Link>
									{item.imagePath && (
										<button className="camera-btn" onClick={() => setLightboxSrc(`/api/v1/public/files/images/${item.imagePath}`)}>
											<i className="fas fa-camera"></i>
										</button>
									)}
								</td>
								<td>{item.location}</td>
								<td>
									{item.availableQuantity}/{item.maxQuantity}
									{item.defectiveQuantity > 0 && <span className="text-danger"> ({item.defectiveQuantity} def.)</span>}
								</td>
								<td><StatusBadge status={item.status} /></td>
								<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
									<button onClick={() => openModal('edit', item)} className="btn btn-small">Bearbeiten</button>
									<button onClick={() => openModal('defect', item)} className="btn btn-small btn-warning">Defekt</button>
									{item.defectiveQuantity > 0 && (
										<button onClick={() => openModal('repair', item)} className="btn btn-small btn-success">Repariert</button>
									)}
									<button onClick={() => handleDelete(item)} className="btn btn-small btn-danger">Löschen</button>
								</td>
							</tr>
						))}
					</tbody>
				</table>
			</div>

			{modalState.isOpen && (
				<StorageItemModal
					isOpen={modalState.isOpen}
					onClose={closeModal}
					onSuccess={handleSuccess}
					item={modalState.item}
					initialMode={modalState.mode}
				/>
			)}

			{lightboxSrc && <Lightbox src={lightboxSrc} onClose={() => setLightboxSrc('')} />}
		</div>
	);
};

export default AdminStoragePage;
========================================================================
FILE: frontend\src\pages\admin\AdminSystemPage.jsx
========================================================================

import React, { useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';

const AdminSystemPage = () => {
	const apiCall = useCallback(() => apiClient.get('/system/stats'), []);
	const { data: stats, loading, error } = useApi(apiCall);

	const formatPercent = (value) => `${value.toFixed(1)}%`;
	const formatGB = (value) => `${value.toFixed(2)} GB`;

	if (loading) return <div>Lade Systeminformationen...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div>
			<h1><i className="fas fa-server"></i> Systeminformationen</h1>
			<p>Live-Statistiken über den Zustand des Servers, auf dem die Anwendung läuft.</p>
			<div className="responsive-dashboard-grid">
				<div className="card">
					<h2 className="card-title">CPU & Speicher</h2>
					<ul className="details-list">
						<li><strong>CPU-Auslastung:</strong> <span>{stats.cpuLoad > 0 ? formatPercent(stats.cpuLoad) : 'Wird geladen...'}</span></li>
						<li><strong>RAM-Nutzung:</strong> <span>{formatGB(stats.usedMemory)} / {formatGB(stats.totalMemory)}</span></li>
					</ul>
				</div>
				<div className="card">
					<h2 className="card-title">Festplattenspeicher</h2>
					<ul className="details-list">
						<li><strong>Speichernutzung (Root):</strong> <span>{formatGB(stats.usedDiskSpace)} / {formatGB(stats.totalDiskSpace)}</span></li>
					</ul>
				</div>
				<div className="card" style={{ gridColumn: '1 / -1' }}>
					<h2 className="card-title">Laufzeit & Energie</h2>
					<ul className="details-list">
						<li><strong>Server-Laufzeit:</strong> <span>{stats.uptime}</span></li>
						<li><strong>Batteriestatus:</strong> <span>{stats.batteryPercentage >= 0 ? `${stats.batteryPercentage}%` : 'Nicht verfügbar'}</span></li>
					</ul>
				</div>
			</div>
		</div>
	);
};

export default AdminSystemPage;
========================================================================
FILE: frontend\src\pages\admin\AdminUsersPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import UserModal from '../../components/admin/users/UserModal';
import useAdminData from '../../hooks/useAdminData';
import Modal from '../../components/ui/Modal';
import { useToast } from '../../context/ToastContext';

const AdminUsersPage = () => {
	const apiCall = useCallback(() => apiClient.get('/users'), []);
	const { data: users, loading, error, reload } = useApi(apiCall);
	const adminFormData = useAdminData();
	const { addToast } = useToast();

	const [isModalOpen, setIsModalOpen] = useState(false);
	const [editingUser, setEditingUser] = useState(null);
	const [resetPasswordInfo, setResetPasswordInfo] = useState({ user: null, password: '' });

	const handleOpenNewUserModal = () => {
		setEditingUser(null);
		setIsModalOpen(true);
	};

	const handleOpenEditModal = (user) => {
		setEditingUser(user);
		setIsModalOpen(true);
	};

	const handleCloseModal = () => {
		setIsModalOpen(false);
		setEditingUser(null);
	};

	const handleClosePasswordModal = () => {
		setResetPasswordInfo({ user: null, password: '' });
	};

	const handleSuccess = () => {
		handleCloseModal();
		reload();
	};

	const handleDelete = async (user) => {
		if (window.confirm(`Benutzer '${user.username}' wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/users/${user.id}`);
				if (result.success) {
					addToast('Benutzer erfolgreich gelöscht.', 'success');
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Löschen fehlgeschlagen: ${err.message}`, 'error');
			}
		}
	};

	const handleResetPassword = async (user) => {
		if (window.confirm(`Passwort für '${user.username}' wirklich zurücksetzen?`)) {
			try {
				const result = await apiClient.post(`/users/${user.id}/reset-password`);
				if (result.success) {
					setResetPasswordInfo({ user: user, password: result.data.newPassword });
					addToast('Passwort zurückgesetzt.', 'success');
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler: ${err.message}`, 'error');
			}
		}
	};

	const copyToClipboard = () => {
		navigator.clipboard.writeText(resetPasswordInfo.password);
		addToast('Passwort in die Zwischenablage kopiert.', 'info');
	};

	const renderTable = () => {
		if (loading) return <tr><td colSpan="4">Lade Benutzer...</td></tr>;
		if (error) return <tr><td colSpan="4" className="error-message">{error}</td></tr>;
		if (!users || users.length === 0) return <tr><td colSpan="4">Keine Benutzer gefunden.</td></tr>;

		return users.map(user => (
			<tr key={user.id}>
				<td>{user.id}</td>
				<td>{user.username}</td>
				<td>{user.roleName}</td>
				<td style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
					<button onClick={() => handleOpenEditModal(user)} className="btn btn-small">Bearbeiten</button>
					<button onClick={() => handleResetPassword(user)} className="btn btn-small btn-warning">Passwort Reset</button>
					<button onClick={() => handleDelete(user)} className="btn btn-small btn-danger">Löschen</button>
				</td>
			</tr>
		));
	};

	return (
		<div>
			<h1><i className="fas fa-users-cog"></i> Benutzerverwaltung</h1>
			<p>Verwalten Sie hier alle Benutzerkonten und deren individuelle Berechtigungen.</p>

			<div className="table-controls">
				<button onClick={handleOpenNewUserModal} className="btn btn-success">
					<i className="fas fa-user-plus"></i> Neuen Benutzer anlegen
				</button>
			</div>

			<div className="desktop-table-wrapper">
				<table className="data-table">
					<thead>
						<tr>
							<th>ID</th>
							<th>Benutzername</th>
							<th>Rolle</th>
							<th>Aktionen</th>
						</tr>
					</thead>
					<tbody>
						{renderTable()}
					</tbody>
				</table>
			</div>

			{isModalOpen && (
				<UserModal
					isOpen={isModalOpen}
					onClose={handleCloseModal}
					onSuccess={handleSuccess}
					user={editingUser}
					roles={adminFormData.roles}
					groupedPermissions={adminFormData.groupedPermissions}
					isLoadingData={adminFormData.loading}
				/>
			)}

			{resetPasswordInfo.user && (
				<Modal isOpen={!!resetPasswordInfo.user} onClose={handleClosePasswordModal} title="Passwort wurde zurückgesetzt">
					<p>Das neue, temporäre Passwort für <strong>{resetPasswordInfo.user.username}</strong> ist:</p>
					<div style={{ background: 'var(--bg-color)', padding: '1rem', borderRadius: 'var(--border-radius)', fontFamily: 'monospace', margin: '1rem 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
						<span>{resetPasswordInfo.password}</span>
						<button className="btn btn-small" onClick={copyToClipboard} title="In die Zwischenablage kopieren">
							<i className="fas fa-copy"></i>
						</button>
					</div>
					<p className="text-danger" style={{ fontWeight: 'bold' }}>Dieses Passwort wird nur einmal angezeigt! Bitte geben Sie es sicher an den Benutzer weiter.</p>
				</Modal>
			)}
		</div>
	);
};

export default AdminUsersPage;
========================================================================
FILE: frontend\src\pages\admin\AdminWikiPage.jsx
========================================================================

import React, { useState, useCallback } from 'react';
import useApi from '../../hooks/useApi';
import apiClient from '../../services/apiClient';
import { useToast } from '../../context/ToastContext';
import Modal from '../../components/ui/Modal';
import ReactMarkdown from 'react-markdown';
import rehypeSanitize from 'rehype-sanitize';

const WikiPageModal = ({ isOpen, onClose, onSuccess, parentPath }) => {
	const [isSubmitting, setIsSubmitting] = useState(false);
	const [error, setError] = useState('');
	const { addToast } = useToast();

	const handleSubmit = async (e) => {
		e.preventDefault();
		setIsSubmitting(true);
		setError('');

		const formData = new FormData(e.target);
		const fileName = formData.get('fileName');
		const fullPath = parentPath ? `${parentPath}/${fileName}` : fileName;

		try {
			const result = await apiClient.post('/wiki', { filePath: fullPath, content: `# ${fileName}\n\nNeue Seite.` });
			if (result.success) {
				addToast('Seite erfolgreich erstellt', 'success');
				onSuccess();
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			setError(err.message || 'Erstellen der Seite fehlgeschlagen.');
		} finally {
			setIsSubmitting(false);
		}
	};

	return (
		<Modal isOpen={isOpen} onClose={onClose} title="Neue Wiki-Seite erstellen">
			<form onSubmit={handleSubmit}>
				{error && <p className="error-message">{error}</p>}
				<div className="form-group">
					<label htmlFor="wiki-parent-path">Übergeordneter Pfad</label>
					<input id="wiki-parent-path" type="text" value={parentPath || '/'} readOnly disabled />
				</div>
				<div className="form-group">
					<label htmlFor="wiki-file-name">Dateiname (z.B. `neue-seite.md`)</label>
					<input id="wiki-file-name" name="fileName" required pattern=".*\.md$" title="Muss mit .md enden" />
				</div>
				<button type="submit" className="btn" disabled={isSubmitting}>
					{isSubmitting ? 'Wird erstellt...' : 'Seite erstellen'}
				</button>
			</form>
		</Modal>
	);
};


const AdminWikiPage = () => {
	const treeApiCall = useCallback(() => apiClient.get('/wiki'), []);
	const { data: wikiTree, loading, error, reload } = useApi(treeApiCall);
	const [selectedEntry, setSelectedEntry] = useState(null);
	const [isEditing, setIsEditing] = useState(false);
	const [editContent, setEditContent] = useState('');
	const [isModalOpen, setIsModalOpen] = useState(false);
	const [modalParentPath, setModalParentPath] = useState('');
	const { addToast } = useToast();

	const handleSelectEntry = async (entry) => {
		try {
			const result = await apiClient.get(`/wiki/${entry.id}`);
			if (result.success) {
				setSelectedEntry(result.data);
				setEditContent(result.data.content);
				setIsEditing(false);
			}
		} catch (err) {
			addToast(`Fehler beim Laden der Seite: ${err.message}`, 'error');
		}
	};

	const handleSave = async () => {
		if (!selectedEntry) return;
		try {
			const result = await apiClient.put(`/wiki/${selectedEntry.id}`, { content: editContent });
			if (result.success) {
				addToast('Seite gespeichert', 'success');
				await handleSelectEntry(selectedEntry); // Reload content
			} else {
				throw new Error(result.message);
			}
		} catch (err) {
			addToast(`Fehler beim Speichern: ${err.message}`, 'error');
		}
	};

	const handleDelete = async () => {
		if (!selectedEntry) return;
		if (window.confirm(`Seite "${selectedEntry.filePath}" wirklich löschen?`)) {
			try {
				const result = await apiClient.delete(`/wiki/${selectedEntry.id}`);
				if (result.success) {
					addToast('Seite gelöscht', 'success');
					setSelectedEntry(null);
					reload();
				} else {
					throw new Error(result.message);
				}
			} catch (err) {
				addToast(`Fehler beim Löschen: ${err.message}`, 'error');
			}
		}
	};

	const renderTree = (node, path = '') => (
		<ul>
			{Object.entries(node).map(([name, child]) => (
				<li key={path + name}>
					{child.id ? ( // It's a file
						<a href="#" onClick={(e) => { e.preventDefault(); handleSelectEntry(child); }} className={selectedEntry?.id === child.id ? 'active' : ''}>
							<i className="fas fa-file-alt fa-fw"></i> {name}
						</a>
					) : ( // It's a directory
						<details open>
							<summary><i className="fas fa-folder fa-fw"></i> {name}</summary>
							{renderTree(child, `${path}${name}/`)}
						</details>
					)}
				</li>
			))}
		</ul>
	);

	if (loading) return <div>Lade Wiki-Struktur...</div>;
	if (error) return <div className="error-message">{error}</div>;

	return (
		<div className="wiki-page-wrapper">
			<aside className="wiki-sidebar">
				<div className="wiki-sidebar-header">
					<h3>Wiki-Verzeichnis</h3>
					<button className="btn btn-small" onClick={() => { setModalParentPath(''); setIsModalOpen(true); }}>+</button>
				</div>
				<div className="wiki-tree-container">
					{wikiTree && renderTree(wikiTree)}
				</div>
			</aside>
			<main className="wiki-content-pane">
				{selectedEntry ? (
					<>
						<div className="wiki-content-header">
							<h2>{selectedEntry.filePath}</h2>
							<div className="wiki-editor-controls">
								{isEditing ? (
									<>
										<button onClick={handleSave} className="btn btn-success btn-small">Speichern</button>
										<button onClick={() => setIsEditing(false)} className="btn btn-secondary btn-small">Abbrechen</button>
									</>
								) : (
									<>
										<button onClick={() => setIsEditing(true)} className="btn btn-small">Bearbeiten</button>
										<button onClick={handleDelete} className="btn btn-danger btn-small">Löschen</button>
									</>
								)}
							</div>
						</div>
						{isEditing ? (
							<textarea
								id="editor"
								className="form-group"
								value={editContent}
								onChange={(e) => setEditContent(e.target.value)}
								style={{ flexGrow: 1, fontFamily: 'monospace' }}
							/>
						) : (
							<div className="markdown-content">
								<ReactMarkdown rehypePlugins={[rehypeSanitize]}>
									{selectedEntry.content}
								</ReactMarkdown>
							</div>
						)}
					</>
				) : (
					<div className="wiki-welcome-pane">
						<i className="fas fa-book-reader" style={{ fontSize: '4rem' }}></i>
						<h1>Wiki</h1>
						<p>Wählen Sie eine Seite aus der Navigation aus, um sie anzuzeigen oder zu bearbeiten.</p>
					</div>
				)}
			</main>
			{isModalOpen && (
				<WikiPageModal
					isOpen={isModalOpen}
					onClose={() => setIsModalOpen(false)}
					onSuccess={() => { setIsModalOpen(false); reload(); }}
					parentPath={modalParentPath}
				/>
			)}
		</div>
	);
};

export default AdminWikiPage;
========================================================================
FILE: frontend\src\pages\error\ErrorPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { useRouteError, Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const ErrorPage = () => {
	const error = useRouteError();
	console.error(error);

	// Safely determine the error message to display
	const errorMessage = useMemo(() => {
		if (typeof error === 'string') return error;
		if (error instanceof Error) return error.message;
		if (error?.statusText) return error.statusText;
		if (error?.message) return error.message;
		return "Ein unbekannter Fehler ist aufgetreten.";
	}, [error]);

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: 'SYSTEMDIAGNOSE WIRD GESTARTET...', className: 'info' },
		{ text: 'Speichermodule werden gescannt...', className: 'info', delayAfter: 500 },
		{ text: '[OK] Speicherintegritätsprüfung bestanden.', className: 'ok' },
		{ text: 'Anwendungsstatus wird überprüft...', className: 'info', delayAfter: 500 },
		{ text: `[FEHLER] Unbehandelte Ausnahme erkannt: ${errorMessage}`, className: 'fail', delayAfter: 800 },
		{ text: 'FEHLER 500: Interner Serverfehler.', className: 'fail' },
		{ text: 'Ein kritischer Fehler ist bei der Verarbeitung der Anfrage aufgetreten.', className: 'info' },
		{ text: 'Der Systemadministrator wurde benachrichtigt.', className: 'info' },
		{ text: 'Wiederherstellungsoptionen werden vorbereitet...', className: 'warn' },
	], [errorMessage]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SYSTEM_DIAGNOSTIC.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default ErrorPage;
========================================================================
FILE: frontend\src\pages\error\ErrorTrigger.jsx
========================================================================

import { useEffect } from 'react';

const ErrorTrigger = () => {
	useEffect(() => {
		// This will cause a rendering error that the boundary will catch.
		throw new Error("Dies ist ein simulierter Rendering-Fehler zum Testen der 500-Seite.");
	}, []);

	return <div>You should not see this.</div>;
};

export default ErrorTrigger;
========================================================================
FILE: frontend\src\pages\error\ForbiddenPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';
import { useAuthStore } from '../../store/authStore';

const ForbiddenPage = () => {
	const user = useAuthStore(state => state.user);

	const lines = useMemo(() => [
		{ text: 'Zugriffsversuch auf geschützten Bereich...', className: 'info' },
		{ text: `Benutzer wird authentifiziert: ${user?.username || 'GAST'}`, className: 'info', delayAfter: 500 },
		{ text: 'Berechtigungsstufe wird geprüft...', className: 'info', delayAfter: 800 },
		{ text: '[ZUGRIFF VERWEIGERT]', className: 'fail', speed: 80 },
		{ text: 'FEHLER 403: Unzureichende Berechtigungen.', className: 'fail' },
		{ text: 'Ihre aktuelle Rolle gewährt keinen Zugriff auf diese Ressource.', className: 'warn' },
		{ text: 'Dieser Versuch wurde protokolliert.', className: 'info' },
	], [user]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="full-screen-terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">SECURITY.LOG</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{'>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<div className="terminal-footer">
				<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
					<i className="fas fa-arrow-left"></i> Zurück zum sicheren Bereich
				</Link>
			</div>
		</div>
	);
};

export default ForbiddenPage;
========================================================================
FILE: frontend\src\pages\error\NotFoundPage.jsx
========================================================================

import React, { useMemo } from 'react';
import { Link, useLocation } from 'react-router-dom';
import useTypingAnimation from '../../hooks/useTypingAnimation';

const NotFoundPage = () => {
	const location = useLocation();
	const path = location.pathname;

	// useMemo ensures the 'lines' array is not re-created on every render
	const lines = useMemo(() => [
		{ text: `Führe Befehl aus: find . -name "${path}"`, className: 'info', delayAfter: 800 },
		{ text: `find: '${path}': Datei oder Verzeichnis nicht gefunden`, className: 'warn', delayAfter: 500 },
		{ text: 'FEHLER 404: Ressource nicht gefunden.', className: 'fail' },
		{ text: 'Vorschlag: Die angeforderte Ressource ist nicht verfügbar. Versuchen Sie, zum Dashboard zurückzukehren.', className: 'info' },
		{ text: `Führe aus: cd /home`, className: 'info' },
	], [path]);

	const { containerRef, renderedLines, isComplete } = useTypingAnimation(lines);

	return (
		<div className="terminal">
			<div className="terminal-header">
				<span className="red"></span>
				<span className="yellow"></span>
				<span className="green"></span>
				<div className="title">bash</div>
			</div>
			<div className="terminal-body" ref={containerRef}>
				{renderedLines.map((line, index) => (
					<div key={index} className={`terminal-line ${line.className}`}>
						<span className="terminal-prompt">{index < 1 ? '$' : '>'}</span>
						<span>{line.text}</span>
						{index === renderedLines.length - 1 && !isComplete && <span className="cursor"></span>}
					</div>
				))}
			</div>
			<Link to="/home" className={`btn ${isComplete ? 'visible' : ''}`}>
				<i className="fas fa-home"></i> Zum Dashboard
			</Link>
		</div>
	);
};

export default NotFoundPage;
========================================================================
FILE: frontend\src\router\AdminRoute.jsx
========================================================================

import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const AdminRoute = () => {
	const isAdmin = useAuthStore((state) => state.isAdmin);

	// Check for authentication is handled by ProtectedRoute, this just checks for admin role.
	if (!isAdmin) {
		// Instead of rendering a component directly, we navigate to a dedicated route for 403.
		// This keeps the URL consistent with the error being shown.
		return <Navigate to="/forbidden" replace />;
	}

	return <Outlet />;
};

export default AdminRoute;
========================================================================
FILE: frontend\src\router\index.jsx
========================================================================

import React, { lazy, Suspense } from 'react';
import { createBrowserRouter, Navigate } from 'react-router-dom';

// Layouts and Core Components
import App from '../App';
import MinimalLayout from '../components/layout/MinimalLayout';
import ErrorLayout from '../components/layout/ErrorLayout';
import ProtectedRoute from './ProtectedRoute';
import AdminRoute from './AdminRoute';

// Eagerly load the LoginPage and Error Pages
import LoginPage from '../pages/LoginPage';
import ErrorPage from '../pages/error/ErrorPage';
import NotFoundPage from '../pages/error/NotFoundPage';

// Lazy load all other pages
const DashboardPage = lazy(() => import('../pages/DashboardPage'));
const StoragePage = lazy(() => import('../pages/StoragePage'));
const StorageItemDetailsPage = lazy(() => import('../pages/StorageItemDetailsPage'));
const EventsPage = lazy(() => import('../pages/EventsPage'));
const EventDetailsPage = lazy(() => import('../pages/EventDetailsPage'));
const LehrgaengePage = lazy(() => import('../pages/LehrgaengePage'));
const MeetingDetailsPage = lazy(() => import('../pages/MeetingDetailsPage'));
const ProfilePage = lazy(() => import('../pages/ProfilePage'));
const PasswordPage = lazy(() => import('../pages/PasswordPage'));
const FilesPage = lazy(() => import('../pages/FilesPage'));
const FeedbackPage = lazy(() => import('../pages/FeedbackPage'));
const EventFeedbackPage = lazy(() => import('../pages/EventFeedbackPage'));
const CalendarPage = lazy(() => import('../pages/CalendarPage'));
const PackKitPage = lazy(() => import('../pages/PackKitPage'));

// Admin Pages
const AdminDashboardPage = lazy(() => import('../pages/admin/AdminDashboardPage'));
const AdminUsersPage = lazy(() => import('../pages/admin/AdminUsersPage'));
const AdminRequestsPage = lazy(() => import('../pages/admin/AdminRequestsPage'));
const AdminEventsPage = lazy(() => import('../pages/admin/AdminEventsPage'));
const AdminCoursesPage = lazy(() => import('../pages/admin/AdminCoursesPage'));
const AdminMeetingsPage = lazy(() => import('../pages/admin/AdminMeetingsPage'));
const AdminStoragePage = lazy(() => import('../pages/admin/AdminStoragePage'));
const AdminDefectivePage = lazy(() => import('../pages/admin/AdminDefectivePage'));
const AdminLogPage = lazy(() => import('../pages/admin/AdminLogPage'));
const AdminKitsPage = lazy(() => import('../pages/admin/AdminKitsPage'));
const AdminMatrixPage = lazy(() => import('../pages/admin/AdminMatrixPage'));
const AdminReportsPage = lazy(() => import('../pages/admin/AdminReportsPage'));
const AdminSystemPage = lazy(() => import('../pages/admin/AdminSystemPage'));
const AdminFilesPage = lazy(() => import('../pages/admin/AdminFilesPage'));
const AdminFeedbackPage = lazy(() => import('../pages/admin/AdminFeedbackPage'));
const AdminAchievementsPage = lazy(() => import('../pages/admin/AdminAchievementsPage'));
const AdminWikiPage = lazy(() => import('../pages/admin/AdminWikiPage'));

import ErrorTrigger from '../pages/error/ErrorTrigger';
import ForbiddenPage from '../pages/error/ForbiddenPage';

const router = createBrowserRouter([
	{
		path: '/',
		element: (
			<ProtectedRoute>
				<App />
			</ProtectedRoute>
		),
		errorElement: <ErrorLayout><ErrorPage /></ErrorLayout>,
		children: [
			{ index: true, element: <Navigate to="/home" replace /> },
			{ path: 'home', element: <DashboardPage /> },
			{ path: 'lager', element: <StoragePage /> },
			{ path: 'lager/details/:itemId', element: <StorageItemDetailsPage /> },
			{ path: 'veranstaltungen', element: <EventsPage /> },
			{ path: 'veranstaltungen/details/:eventId', element: <EventDetailsPage /> },
			{ path: 'lehrgaenge', element: <LehrgaengePage /> },
			{ path: 'lehrgaenge/details/:meetingId', element: <MeetingDetailsPage /> },
			{ path: 'profil', element: <ProfilePage /> },
			{ path: 'passwort', element: <PasswordPage /> },
			{ path: 'dateien', element: <FilesPage /> },
			{ path: 'feedback', element: <FeedbackPage /> },
			{ path: 'feedback/event/:eventId', element: <EventFeedbackPage /> },
			{ path: 'kalender', element: <CalendarPage /> },
			{ path: 'test-500', element: <ErrorTrigger /> },

			{
				path: 'admin',
				element: <AdminRoute />,
				children: [
					{ index: true, element: <Navigate to="/admin/dashboard" replace /> },
					{ path: 'dashboard', element: <AdminDashboardPage /> },
					{ path: 'mitglieder', element: <AdminUsersPage /> },
					{ path: 'requests', element: <AdminRequestsPage /> },
					{ path: 'veranstaltungen', element: <AdminEventsPage /> },
					{ path: 'lehrgaenge', element: <AdminCoursesPage /> },
					{ path: 'lehrgaenge/:courseId/meetings', element: <AdminMeetingsPage /> },
					{ path: 'lager', element: <AdminStoragePage /> },
					{ path: 'dateien', element: <AdminFilesPage /> },
					{ path: 'kits', element: <AdminKitsPage /> },
					{ path: 'feedback', element: <AdminFeedbackPage /> },
					{ path: 'achievements', element: <AdminAchievementsPage /> },
					{ path: 'defekte', element: <AdminDefectivePage /> },
					{ path: 'matrix', element: <AdminMatrixPage /> },
					{ path: 'berichte', element: <AdminReportsPage /> },
					{ path: 'log', element: <AdminLogPage /> },
					{ path: 'system', element: <AdminSystemPage /> },
					{ path: 'wiki', element: <AdminWikiPage /> },
				],
			},
		],
	},
	{
		path: '/pack-kit/:kitId',
		element: (
			<ProtectedRoute>
				<MinimalLayout />
			</ProtectedRoute>
		),
		children: [
			{
				index: true,
				element: <PackKitPage />
			}
		]
	},
	{
		path: '/login',
		element: <Suspense fallback={<div>Laden...</div>}><LoginPage /></Suspense>,
	},
	{
		path: '/forbidden',
		element: <ErrorLayout><ForbiddenPage /></ErrorLayout>,
	},
	{
		path: '*',
		element: <ErrorLayout><NotFoundPage /></ErrorLayout>,
	}
]);

export default router;
========================================================================
FILE: frontend\src\router\ProtectedRoute.jsx
========================================================================

import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

const ProtectedRoute = ({ children }) => {
	const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
	const location = useLocation();

	if (!isAuthenticated) {
		return <Navigate to="/login" state={{ from: location }} replace />;
	}

	return children;
};

export default ProtectedRoute;
========================================================================
FILE: frontend\src\services\apiClient.js
========================================================================

// REMOVED: import { useAuthStore } from '../store/authStore';

const BASE_URL = '/api/v1';

let csrfToken = '';
let onUnauthorizedCallback = () => { }; // Placeholder for the logout function

const apiClient = {
	// New function to inject the logout handler from the auth store
	setup: function(callbacks) {
		onUnauthorizedCallback = callbacks.onUnauthorized;
	},

	async fetchCsrfToken() {
		try {
			await this.get('/users/me');
		} catch (error) {
			console.warn("Could not pre-fetch CSRF token. It will be fetched on the first state-changing request.", error);
		}
	},

	request: async function(endpoint, options = {}) {
		// REMOVED: const { logout } = useAuthStore.getState();
		const headers = {
			'Content-Type': 'application/json',
			...options.headers,
		};

		if (options.body instanceof FormData) {
			delete headers['Content-Type'];
		}

		const method = options.method || 'GET';
		if (['POST', 'PUT', 'DELETE'].includes(method.toUpperCase())) {
			const match = document.cookie.match(new RegExp('(^| )' + 'XSRF-TOKEN' + '=([^;]+)'));
			if (match) {
				csrfToken = match[2];
			}
			if (csrfToken) {
				headers['X-XSRF-TOKEN'] = csrfToken;
			} else {
				console.warn('CSRF token not found. State-changing requests may fail.');
			}
		}

		try {
			const response = await fetch(`${BASE_URL}${endpoint}`, {
				...options,
				headers: headers,
				credentials: 'include'
			});

			if (response.status === 401) {
				onUnauthorizedCallback(); // Use the injected callback
				throw new Error('Nicht autorisiert. Ihre Sitzung ist möglicherweise abgelaufen.');
			}
			if (response.status === 403) {
				throw new Error('Zugriff verweigert. Sie haben nicht die erforderlichen Berechtigungen.');
			}

			if (response.status === 204) {
				return { success: true, message: 'Operation successful.', data: null };
			}

			const contentType = response.headers.get("content-type");
			if (!contentType || !contentType.includes("application/json")) {
				const textError = await response.text();
				console.error("Non-JSON API response:", textError);
				throw new Error(`Serververbindung fehlgeschlagen (Status: ${response.status}). Das Backend ist möglicherweise offline.`);
			}

			const result = await response.json();

			if (!response.ok) {
				if (response.status >= 500) {
					throw new Error("Ein interner Serverfehler ist aufgetreten. Bitte versuchen Sie es später erneut.");
				}
				throw new Error(result.message || `Ein Fehler ist aufgetreten (Status: ${response.status})`);
			}

			return result;

		} catch (error) {
			if (error instanceof TypeError && error.message === 'Failed to fetch') {
				console.error(`API Client Network Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
				throw new Error('Netzwerkfehler: Das Backend ist nicht erreichbar. Bitte überprüfen Sie, ob der Server läuft.');
			}
			console.error(`API Client Error: ${options.method || 'GET'} ${BASE_URL}${endpoint}`, error);
			throw error;
		}
	},

	get(endpoint) {
		return this.request(endpoint, { method: 'GET' });
	},

	post(endpoint, body) {
		const options = {
			method: 'POST',
			body: body instanceof FormData ? body : JSON.stringify(body),
		};
		return this.request(endpoint, options);
	},

	put(endpoint, body) {
		return this.request(endpoint, { method: 'PUT', body: JSON.stringify(body) });
	},

	delete(endpoint) {
		return this.request(endpoint, { method: 'DELETE' });
	},
};

export default apiClient;
========================================================================
FILE: frontend\src\store\authStore.js
========================================================================

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import apiClient from '../services/apiClient';

const hasAdminAccess = (permissions) => {
	if (!permissions || permissions.length === 0) {
		return false;
	}
	if (permissions.includes('ACCESS_ADMIN_PANEL')) {
		return true;
	}
	const adminPermissions = ['_CREATE', '_UPDATE', '_DELETE', '_MANAGE', 'LOG_READ', 'REPORT_READ', 'SYSTEM_READ', 'QUALIFICATION_UPDATE'];
	return permissions.some(p => adminPermissions.some(ap => p.includes(ap)));
};

export const useAuthStore = create(
	persist(
		(set, get) => ({
			user: null,
			navigationItems: [],
			isAuthenticated: false,
			isAdmin: false,
			theme: 'light',
			login: async (username, password) => {
				try {
					// The login endpoint now returns the user object on success and sets the cookie
					const response = await apiClient.post('/auth/login', { username, password });
					if (response.success && response.data) {
						await get().fetchUserSession(); // Fetch full session data to be sure
						return true;
					}
					throw new Error(response.message || 'Anmeldung fehlgeschlagen');
				} catch (error) {
					console.error('Login failed:', error);
					get().logout();
					throw error;
				}
			},
			logout: async () => {
				try {
					await apiClient.post('/auth/logout');
				} catch (error) {
					console.error("Logout API call failed, clearing state anyway.", error);
				} finally {
					set({ user: null, navigationItems: [], isAuthenticated: false, isAdmin: false, theme: 'light' });
					localStorage.removeItem('auth-storage');
					document.documentElement.setAttribute('data-theme', 'light');
				}
			},
			fetchUserSession: async () => {
				try {
					const result = await apiClient.get('/users/me');

					if (result.success && result.data.user && result.data.navigation) {
						const user = result.data.user;
						const newTheme = user.theme || 'light';
						set({
							user: user,
							navigationItems: result.data.navigation,
							isAuthenticated: true,
							isAdmin: hasAdminAccess(user.permissions || []),
							theme: newTheme,
						});
						document.documentElement.setAttribute('data-theme', newTheme);
					} else {
						throw new Error(result.message || "Ungültige Sitzungsdaten vom Server.");
					}

				} catch (error) {
					console.error("Could not fetch user session. Token might be invalid.", error);
					get().logout();
					throw error;
				}
			},
			setTheme: async (newTheme) => {
				try {
					const result = await apiClient.put('/public/profile/theme', { theme: newTheme });
					if (result.success && result.data) {
						const updatedUser = result.data;
						set({
							user: updatedUser,
							theme: updatedUser.theme,
						});
						document.documentElement.setAttribute('data-theme', updatedUser.theme);
					} else {
						throw new Error(result.message || 'Server konnte das Theme nicht speichern.');
					}
				} catch (error) {
					console.error("Failed to save theme preference:", error);
				}
			},
		}),
		{
			name: 'auth-storage',
			storage: createJSONStorage(() => localStorage),
			// We only persist non-sensitive UI state like theme. User/session data is fetched on load.
			partialize: (state) => ({ theme: state.theme }),
		}
	)
);
========================================================================
FILE: src\main\java\de\technikteam\TechnikTeamApplication.java
========================================================================

package de.technikteam;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan(basePackages = "de.technikteam")
public class TechnikTeamApplication {

	public static void main(String[] args) {
		SpringApplication.run(TechnikTeamApplication.class, args);
	}

}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminAchievementResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/achievements")
@Tag(name = "Admin Achievements", description = "Endpoints for managing achievements.")
@SecurityRequirement(name = "bearerAuth")
public class AdminAchievementResource {

	private final AchievementDAO achievementDAO;

	@Autowired
	public AdminAchievementResource(AchievementDAO achievementDAO) {
		this.achievementDAO = achievementDAO;
	}

	@GetMapping
	@Operation(summary = "Get all achievements", description = "Retrieves a list of all available achievements.")
	@PreAuthorize("hasAuthority('ACHIEVEMENT_VIEW')")
	public ResponseEntity<ApiResponse> getAllAchievements() {
		List<Achievement> achievements = achievementDAO.getAllAchievements();
		return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erfolgreich abgerufen.", achievements));
	}

	@PostMapping
	@Operation(summary = "Create an achievement", description = "Creates a new achievement definition.")
	@PreAuthorize("hasAuthority('ACHIEVEMENT_CREATE')")
	public ResponseEntity<ApiResponse> createAchievement(@RequestBody Achievement achievement) {
		if (achievementDAO.createAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen erstellt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Erstellen des Abzeichens.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update an achievement", description = "Updates an existing achievement's details.")
	@PreAuthorize("hasAuthority('ACHIEVEMENT_UPDATE')")
	public ResponseEntity<ApiResponse> updateAchievement(@PathVariable int id, @RequestBody Achievement achievement) {
		achievement.setId(id);
		if (achievementDAO.updateAchievement(achievement)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren des Abzeichens.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an achievement", description = "Deletes an achievement definition.")
	@PreAuthorize("hasAuthority('ACHIEVEMENT_DELETE')")
	public ResponseEntity<ApiResponse> deleteAchievement(@PathVariable int id) {
		if (achievementDAO.deleteAchievement(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Abzeichen gelöscht.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Löschen des Abzeichens.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminDashboardResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminDashboardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/admin/dashboard")
@Tag(name = "Admin Dashboard", description = "Endpoints for the administrative dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class AdminDashboardResource {

	private final AdminDashboardService dashboardService;

	@Autowired
	public AdminDashboardResource(AdminDashboardService dashboardService) {
		this.dashboardService = dashboardService;
	}

	@GetMapping
	@Operation(summary = "Get all data for the admin dashboard")
	@PreAuthorize("hasAuthority('ADMIN_DASHBOARD_ACCESS')")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		// The service method doesn't require the user, but this demonstrates the
		// pattern.
		return ResponseEntity.ok(
				new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardService.getDashboardData()));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminEventResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.EventUpdateRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/events")
@Tag(name = "Admin Events", description = "Endpoints for managing events.")
@SecurityRequirement(name = "bearerAuth")
public class AdminEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;

	@Autowired
	public AdminEventResource(EventDAO eventDAO, EventService eventService) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
	}

	@GetMapping
	@Operation(summary = "Get all events", description = "Retrieves a list of all events in the system, sorted by date.")
	@PreAuthorize("hasAuthority('EVENT_READ')")
	public ResponseEntity<ApiResponse> getAllEvents() {
		List<Event> events = eventDAO.getAllEvents();
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@PostMapping
	@Operation(summary = "Create a new event", description = "Creates a new event with attachments, skill requirements, and item reservations.")
	@PreAuthorize("hasAuthority('EVENT_CREATE')")
	public ResponseEntity<ApiResponse> createEvent(@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			User adminUser = securityUser.getUser();
			Event event = new Event();
			mapDtoToEvent(eventData, event);

			int newEventId = eventService.createOrUpdateEvent(event, false, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole());

			return new ResponseEntity<>(
					new ApiResponse(true, "Veranstaltung erfolgreich erstellt.", Map.of("id", newEventId)),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Erstellen der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}")
	@Operation(summary = "Update an event", description = "Updates an existing event with attachments, skill requirements, and item reservations.")
	@PreAuthorize("hasAuthority('EVENT_UPDATE')")
	public ResponseEntity<ApiResponse> updateEvent(@PathVariable int id,
			@RequestPart("eventData") EventUpdateRequest eventData,
			@RequestPart(value = "file", required = false) MultipartFile file,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			User adminUser = securityUser.getUser();
			Event event = eventDAO.getEventById(id);
			if (event == null) {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
			}
			mapDtoToEvent(eventData, event);
			event.setId(id); // Ensure ID is set for update

			eventService.createOrUpdateEvent(event, true, adminUser,
					eventData.requiredCourseIds().toArray(new String[0]),
					eventData.requiredPersons().toArray(new String[0]), eventData.itemIds().toArray(new String[0]),
					eventData.quantities().toArray(new String[0]), null, file, eventData.requiredRole());

			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich aktualisiert.", null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(
					new ApiResponse(false, "Fehler beim Aktualisieren der Veranstaltung: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete an event", description = "Permanently deletes an event and all associated data.")
	@PreAuthorize("hasAuthority('EVENT_DELETE')")
	public ResponseEntity<ApiResponse> deleteEvent(@PathVariable int id) {
		if (eventDAO.deleteEvent(id)) {
			return ResponseEntity.ok(new ApiResponse(true, "Veranstaltung erfolgreich gelöscht.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Fehler beim Löschen der Veranstaltung.", null));
		}
	}

	private void mapDtoToEvent(EventUpdateRequest dto, Event event) {
		event.setName(dto.name());
		event.setEventDateTime(dto.eventDateTime());
		event.setEndDateTime(dto.endDateTime());
		event.setDescription(dto.description());
		event.setLocation(dto.location());
		event.setStatus(dto.status());
		event.setLeaderUserId(dto.leaderUserId() != null ? dto.leaderUserId() : 0);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFeedbackResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FeedbackSubmission;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/feedback")
@Tag(name = "Admin Feedback", description = "Endpoints for managing user feedback.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('ADMIN_DASHBOARD_ACCESS')") // General permission for feedback management
public class AdminFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;

	@Autowired
	public AdminFeedbackResource(FeedbackSubmissionDAO submissionDAO) {
		this.submissionDAO = submissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get all feedback submissions", description = "Retrieves all feedback submissions from all users, ordered by status.")
	public ResponseEntity<ApiResponse> getAllSubmissions() {
		List<FeedbackSubmission> submissions = submissionDAO.getAllSubmissions();
		return ResponseEntity.ok(new ApiResponse(true, "Alle Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PutMapping("/{id}/status")
	@Operation(summary = "Update feedback status", description = "Updates the status of a specific feedback submission.")
	public ResponseEntity<ApiResponse> updateStatus(@PathVariable int id, @RequestBody Map<String, String> payload) {
		String newStatus = payload.get("status");
		FeedbackSubmission submission = submissionDAO.getSubmissionById(id);
		if (submission == null) {
			return ResponseEntity.notFound().build();
		}
		if (submissionDAO.updateStatusAndTitle(id, newStatus, submission.getDisplayTitle())) {
			return ResponseEntity.ok(new ApiResponse(true, "Status aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Status konnte nicht aktualisiert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFileResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.CategoryRequest;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.FileCategory;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.FileService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/admin/files")
@Tag(name = "Admin Files", description = "Endpoints for managing files and categories.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('FILE_MANAGE')")
public class AdminFileResource {

	private final FileDAO fileDAO;
	private final FileService fileService;
	private final AdminLogService adminLogService;

	@Autowired
	public AdminFileResource(FileDAO fileDAO, FileService fileService, AdminLogService adminLogService) {
		this.fileDAO = fileDAO;
		this.fileService = fileService;
		this.adminLogService = adminLogService;
	}

	@PostMapping
	@Operation(summary = "Upload a new file")
	@PreAuthorize("hasAuthority('FILE_CREATE')")
	public ResponseEntity<ApiResponse> uploadFile(@RequestParam("file") MultipartFile file,
			@RequestParam(required = false) Integer categoryId, @RequestParam String requiredRole,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			de.technikteam.model.File savedFile = fileService.storeFile(file, categoryId, requiredRole,
					securityUser.getUser());
			return new ResponseEntity<>(new ApiResponse(true, "Datei erfolgreich hochgeladen.", savedFile),
					HttpStatus.CREATED);
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Datei konnte nicht hochgeladen werden: " + e.getMessage(), null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a file")
	@PreAuthorize("hasAuthority('FILE_DELETE')")
	public ResponseEntity<ApiResponse> deleteFile(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (fileService.deleteFile(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Datei erfolgreich gelöscht.", Map.of("deletedId", id)));
			} else {
				return ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Datei nicht gefunden.", null));
			}
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Datei konnte aufgrund eines Serverfehlers nicht gelöscht werden.", null));
		}
	}

	@PostMapping("/categories")
	@Operation(summary = "Create a new file category")
	public ResponseEntity<ApiResponse> createCategory(@Valid @RequestBody CategoryRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		if (fileDAO.createCategory(request.name())) {
			adminLogService.log(securityUser.getUser().getUsername(), "CREATE_FILE_CATEGORY_API",
					"Category '" + request.name() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kategorie erfolgreich erstellt.", null),
					HttpStatus.CREATED);
		}
		return ResponseEntity.status(HttpStatus.CONFLICT).body(new ApiResponse(false,
				"Kategorie konnte nicht erstellt werden. Der Name existiert möglicherweise bereits.", null));
	}

	@DeleteMapping("/categories/{id}")
	@Operation(summary = "Delete a file category")
	public ResponseEntity<ApiResponse> deleteCategory(@PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		String categoryName = fileDAO.getCategoryNameById(id);
		if (categoryName != null && fileDAO.deleteCategory(id)) {
			adminLogService.log(securityUser.getUser().getUsername(), "DELETE_FILE_CATEGORY_API",
					"Category '" + categoryName + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kategorie erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kategorie nicht gefunden oder konnte nicht gelöscht werden.", null));
	}

	@GetMapping
	@Operation(summary = "Get all files grouped by category (Admin View)")
	public ResponseEntity<ApiResponse> getAllFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		Map<String, List<de.technikteam.model.File>> groupedFiles = fileDAO
				.getAllFilesGroupedByCategory(securityUser.getUser());
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", groupedFiles));
	}

	@GetMapping("/categories")
	@Operation(summary = "Get all file categories")
	public ResponseEntity<ApiResponse> getAllCategories() {
		List<FileCategory> categories = fileDAO.getAllCategories();
		return ResponseEntity.ok(new ApiResponse(true, "Kategorien erfolgreich abgerufen.", categories));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminFormDataResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/users/form-data")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
@SecurityRequirement(name = "bearerAuth")
public class AdminFormDataResource {

	private final RoleDAO roleDAO;
	private final PermissionDAO permissionDAO;

	@Autowired
	public AdminFormDataResource(RoleDAO roleDAO, PermissionDAO permissionDAO) {
		this.roleDAO = roleDAO;
		this.permissionDAO = permissionDAO;
	}

	@GetMapping
	@Operation(summary = "Get data for user forms", description = "Retrieves all roles and grouped permissions needed to populate admin forms for creating or editing users.")
	public ResponseEntity<ApiResponse> getFormDataForUserForms() {
		List<Role> roles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			if (key.contains("_")) {
				return key.substring(0, key.indexOf("_"));
			}
			return "SYSTEM";
		}));

		Map<String, Object> formData = Map.of("roles", roles, "groupedPermissions", groupedPermissions);

		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", formData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\AdminRequestResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ProfileChangeRequestDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.ProfileChangeRequest;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/v1/requests")
@Tag(name = "Admin Requests", description = "Endpoints for managing user-submitted requests.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('USER_UPDATE')")
public class AdminRequestResource {

	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService requestService;

	@Autowired
	public AdminRequestResource(ProfileChangeRequestDAO requestDAO, ProfileRequestService requestService) {
		this.requestDAO = requestDAO;
		this.requestService = requestService;
	}

	@GetMapping("/pending")
	@Operation(summary = "Get pending requests", description = "Retrieves a list of all profile change requests that are pending review.")
	public ResponseEntity<ApiResponse> getPendingRequests() {
		List<ProfileChangeRequest> requests = requestDAO.getPendingRequests();
		return ResponseEntity.ok(new ApiResponse(true, "Ausstehende Anträge erfolgreich abgerufen.", requests));
	}

	@PostMapping("/{id}/approve")
	@Operation(summary = "Approve a request", description = "Approves a profile change request and applies the changes to the user's profile.")
	public ResponseEntity<ApiResponse> approveRequest(
			@Parameter(description = "ID of the request to approve") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (requestService.approveRequest(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag genehmigt und Benutzer aktualisiert.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht genehmigt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}

	@PostMapping("/{id}/deny")
	@Operation(summary = "Deny a request", description = "Denies a profile change request.")
	public ResponseEntity<ApiResponse> denyRequest(
			@Parameter(description = "ID of the request to deny") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			if (requestService.denyRequest(id, securityUser.getUser())) {
				return ResponseEntity.ok(new ApiResponse(true, "Antrag abgelehnt.", null));
			}
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Antrag konnte nicht abgelehnt werden.", null));
		} catch (IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (IOException e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Ein Dateisystemfehler ist aufgetreten: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\CourseResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/courses")
@Tag(name = "Admin Courses", description = "Endpoints for managing course templates.")
@SecurityRequirement(name = "bearerAuth")
public class CourseResource {

	private final CourseDAO courseDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public CourseResource(CourseDAO courseDAO, AdminLogService adminLogService) {
		this.courseDAO = courseDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all course templates")
	@PreAuthorize("hasAuthority('COURSE_READ')")
	public ResponseEntity<ApiResponse> getAllCourses() {
		List<Course> courses = courseDAO.getAllCourses();
		return ResponseEntity.ok(new ApiResponse(true, "Lehrgänge erfolgreich abgerufen.", courses));
	}

	@PostMapping
	@Operation(summary = "Create a new course template")
	@PreAuthorize("hasAuthority('COURSE_CREATE')")
	public ResponseEntity<ApiResponse> createCourse(@RequestBody Course course,
			@AuthenticationPrincipal User adminUser) {
		if (courseDAO.createCourse(course)) {
			adminLogService.log(adminUser.getUsername(), "CREATE_COURSE_API",
					"Course '" + course.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Lehrgang erfolgreich erstellt.", course),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Lehrgang konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a course template")
	@PreAuthorize("hasAuthority('COURSE_UPDATE')")
	public ResponseEntity<ApiResponse> updateCourse(@PathVariable int id, @RequestBody Course course,
			@AuthenticationPrincipal User adminUser) {
		course.setId(id);
		if (courseDAO.updateCourse(course)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_COURSE_API",
					"Course '" + course.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich aktualisiert.", course));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a course template")
	@PreAuthorize("hasAuthority('COURSE_DELETE')")
	public ResponseEntity<ApiResponse> deleteCourse(@PathVariable int id, @AuthenticationPrincipal User adminUser) {
		Course course = courseDAO.getCourseById(id);
		if (course != null && courseDAO.deleteCourse(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_COURSE_API",
					"Course '" + course.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Lehrgang erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Lehrgang nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\KitResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/kits")
@Tag(name = "Admin Kits", description = "Endpoints for managing inventory kits.")
@SecurityRequirement(name = "bearerAuth")
public class KitResource {

	private final InventoryKitDAO kitDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public KitResource(InventoryKitDAO kitDAO, AdminLogService adminLogService) {
		this.kitDAO = kitDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all kits with their items")
	@PreAuthorize("hasAuthority('KIT_READ')")
	public ResponseEntity<ApiResponse> getAllKits() {
		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		return ResponseEntity.ok(new ApiResponse(true, "Kits erfolgreich abgerufen.", kits));
	}

	@PostMapping
	@Operation(summary = "Create a new kit")
	@PreAuthorize("hasAuthority('KIT_CREATE')")
	public ResponseEntity<ApiResponse> createKit(@RequestBody InventoryKit kit,
			@AuthenticationPrincipal User adminUser) {
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			kit.setId(newId);
			adminLogService.log(adminUser.getUsername(), "CREATE_KIT_API", "Kit '" + kit.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Kit erfolgreich erstellt.", kit), HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Kit konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a kit's metadata")
	@PreAuthorize("hasAuthority('KIT_UPDATE')")
	public ResponseEntity<ApiResponse> updateKit(@PathVariable int id, @RequestBody InventoryKit kit,
			@AuthenticationPrincipal User adminUser) {
		kit.setId(id);
		if (kitDAO.updateKit(kit)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_KIT_API", "Kit '" + kit.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich aktualisiert.", kit));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a kit")
	@PreAuthorize("hasAuthority('KIT_DELETE')")
	public ResponseEntity<ApiResponse> deleteKit(@PathVariable int id, @AuthenticationPrincipal User adminUser) {
		InventoryKit kit = kitDAO.getKitById(id);
		if (kit != null && kitDAO.deleteKit(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_KIT_API", "Kit '" + kit.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Kit erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Kit nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\LogResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
@Tag(name = "Admin Logs", description = "Endpoints for viewing the admin action log.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('LOG_READ')")
public class LogResource {

	private final AdminLogDAO logDAO;

	@Autowired
	public LogResource(AdminLogDAO logDAO) {
		this.logDAO = logDAO;
	}

	@GetMapping
	@Operation(summary = "Get admin action logs", description = "Retrieves a list of all administrative actions. Can be limited.")
	public ResponseEntity<ApiResponse> getLogs(@RequestParam(required = false) Integer limit) {
		List<AdminLog> logs;
		if (limit != null) {
			logs = logDAO.getRecentLogs(limit);
		} else {
			logs = logDAO.getAllLogs();
		}
		return ResponseEntity.ok(new ApiResponse(true, "Protokolle erfolgreich abgerufen.", logs));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MatrixResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.*;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/matrix")
@Tag(name = "Admin Matrix", description = "Endpoints for the qualification matrix.")
@SecurityRequirement(name = "bearerAuth")
public class MatrixResource {

	private final UserDAO userDAO;
	private final CourseDAO courseDAO;
	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO meetingAttendanceDAO;

	@Autowired
	public MatrixResource(UserDAO userDAO, CourseDAO courseDAO, MeetingDAO meetingDAO,
			MeetingAttendanceDAO meetingAttendanceDAO) {
		this.userDAO = userDAO;
		this.courseDAO = courseDAO;
		this.meetingDAO = meetingDAO;
		this.meetingAttendanceDAO = meetingAttendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get qualification matrix data")
	@PreAuthorize("hasAuthority('QUALIFICATION_READ')")
	public ResponseEntity<ApiResponse> getMatrixData() {
		List<User> allUsers = userDAO.getAllUsers();
		List<Course> allCourses = courseDAO.getAllCourses();

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			meetingsByCourse.put(course.getId(), meetingDAO.getMeetingsForCourse(course.getId()));
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("users", allUsers);
		responseData.put("courses", allCourses);
		responseData.put("meetingsByCourse", meetingsByCourse);
		responseData.put("attendanceMap", attendanceMap);

		return ResponseEntity.ok(new ApiResponse(true, "Matrixdaten erfolgreich abgerufen.", responseData));
	}

	@PutMapping("/attendance")
	@Operation(summary = "Update meeting attendance")
	@PreAuthorize("hasAuthority('QUALIFICATION_UPDATE')")
	public ResponseEntity<ApiResponse> updateAttendance(@RequestBody MeetingAttendance attendance) {
		boolean success = meetingAttendanceDAO.setAttendance(attendance.getUserId(), attendance.getMeetingId(),
				attendance.getAttended(), attendance.getRemarks());
		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Teilnahme aktualisiert.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Fehler beim Aktualisieren der Teilnahme.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\MeetingResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.MeetingRequest;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/meetings")
@Tag(name = "Admin Meetings", description = "Endpoints for managing specific training meetings.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('COURSE_READ')")
public class MeetingResource {

	private final MeetingDAO meetingDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public MeetingResource(MeetingDAO meetingDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.meetingDAO = meetingDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	@GetMapping
	@Operation(summary = "Get all meetings for a course")
	public ResponseEntity<ApiResponse> getMeetingsForCourse(@RequestParam int courseId) {
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single meeting by ID")
	public ResponseEntity<ApiResponse> getMeetingById(@PathVariable int id) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null) {
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich abgerufen.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "Termin nicht gefunden.", null));
	}

	@PostMapping
	@Operation(summary = "Create a new meeting")
	@PreAuthorize("hasAuthority('COURSE_CREATE')")
	public ResponseEntity<ApiResponse> createMeeting(@Valid @RequestBody MeetingRequest request,
			@AuthenticationPrincipal User adminUser) {
		Meeting meeting = new Meeting();
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		int newId = meetingDAO.createMeeting(meeting);
		if (newId > 0) {
			meeting.setId(newId);
			adminLogService.log(adminUser.getUsername(), "CREATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Termin erfolgreich erstellt.", meeting),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Termin konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a meeting")
	@PreAuthorize("hasAuthority('COURSE_UPDATE')")
	public ResponseEntity<ApiResponse> updateMeeting(@PathVariable int id, @Valid @RequestBody MeetingRequest request,
			@AuthenticationPrincipal User adminUser) {
		Meeting meeting = new Meeting();
		meeting.setId(id);
		meeting.setCourseId(request.courseId());
		meeting.setName(request.name());
		meeting.setMeetingDateTime(request.meetingDateTime());
		meeting.setEndDateTime(request.endDateTime());
		meeting.setLeaderUserId(request.leaderUserId() != null ? request.leaderUserId() : 0);
		meeting.setDescription(richTextPolicy.sanitize(request.description()));
		meeting.setLocation(request.location());

		if (meetingDAO.updateMeeting(meeting)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_MEETING_API",
					"Meeting '" + meeting.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich aktualisiert.", meeting));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a meeting")
	@PreAuthorize("hasAuthority('COURSE_DELETE')")
	public ResponseEntity<ApiResponse> deleteMeeting(@PathVariable int id, @AuthenticationPrincipal User adminUser) {
		Meeting meeting = meetingDAO.getMeetingById(id);
		if (meeting != null && meetingDAO.deleteMeeting(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_MEETING_API",
					"Meeting '" + meeting.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Termin erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Termin nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\ReportResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.ReportDAO;
import de.technikteam.model.ApiResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/reports")
@Tag(name = "Admin Reports", description = "Endpoints for generating reports and statistics.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('REPORT_READ')")
public class ReportResource {

	private final ReportDAO reportDAO;

	@Autowired
	public ReportResource(ReportDAO reportDAO) {
		this.reportDAO = reportDAO;
	}

	@GetMapping("/dashboard")
	@Operation(summary = "Get dashboard report data", description = "Retrieves aggregated data for the admin dashboard, including event trends and user activity.")
	public ResponseEntity<ApiResponse> getDashboardReport() {
		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("eventTrend", reportDAO.getEventCountByMonth(12));
		dashboardData.put("userActivity", reportDAO.getUserParticipationStats(10));
		dashboardData.put("totalInventoryValue", reportDAO.getTotalInventoryValue());
		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\StorageResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/storage")
@Tag(name = "Admin Storage", description = "Endpoints for managing inventory items.")
@SecurityRequirement(name = "bearerAuth")
public class StorageResource {

	private final StorageDAO storageDAO;
	private final AdminLogService adminLogService;

	@Autowired
	public StorageResource(StorageDAO storageDAO, AdminLogService adminLogService) {
		this.storageDAO = storageDAO;
		this.adminLogService = adminLogService;
	}

	@GetMapping
	@Operation(summary = "Get all storage items")
	@PreAuthorize("hasAuthority('STORAGE_READ')")
	public ResponseEntity<ApiResponse> getAllItems() {
		List<StorageItem> items = storageDAO.getAllItems();
		return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich abgerufen.", items));
	}

	@PostMapping
	@Operation(summary = "Create a new storage item")
	@PreAuthorize("hasAuthority('STORAGE_CREATE')")
	public ResponseEntity<ApiResponse> createItem(@RequestBody StorageItem item,
			@AuthenticationPrincipal User adminUser) {
		if (storageDAO.createItem(item)) {
			adminLogService.log(adminUser.getUsername(), "CREATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' created.");
			return new ResponseEntity<>(new ApiResponse(true, "Artikel erfolgreich erstellt.", item),
					HttpStatus.CREATED);
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Artikel konnte nicht erstellt werden.", null));
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a storage item")
	@PreAuthorize("hasAuthority('STORAGE_UPDATE')")
	public ResponseEntity<ApiResponse> updateItem(@PathVariable int id, @RequestBody StorageItem item,
			@AuthenticationPrincipal User adminUser) {
		item.setId(id);
		if (storageDAO.updateItem(item)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' updated.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich aktualisiert.", item));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Aktualisierung fehlgeschlagen.", null));
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a storage item")
	@PreAuthorize("hasAuthority('STORAGE_DELETE')")
	public ResponseEntity<ApiResponse> deleteItem(@PathVariable int id, @AuthenticationPrincipal User adminUser) {
		StorageItem item = storageDAO.getItemById(id);
		if (item != null && storageDAO.deleteItem(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM_API",
					"Item '" + item.getName() + "' deleted.");
			return ResponseEntity.ok(new ApiResponse(true, "Artikel erfolgreich gelöscht.", Map.of("deletedId", id)));
		}
		return ResponseEntity.status(HttpStatus.NOT_FOUND)
				.body(new ApiResponse(false, "Artikel nicht gefunden oder Löschung fehlgeschlagen.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\SystemResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/system")
@Tag(name = "Admin System", description = "Endpoints for retrieving system information and statistics.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('SYSTEM_READ')")
public class SystemResource {

	private final SystemInfoService systemInfoService;

	@Autowired
	public SystemResource(SystemInfoService systemInfoService) {
		this.systemInfoService = systemInfoService;
	}

	@GetMapping("/stats")
	@Operation(summary = "Get system statistics", description = "Retrieves current system statistics like CPU load, memory usage, and disk space.")
	public ResponseEntity<ApiResponse> getSystemStats() {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		return ResponseEntity.ok(new ApiResponse(true, "Systemstatistiken erfolgreich abgerufen.", stats));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\UserResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.UserCreateRequest;
import de.technikteam.api.v1.dto.UserUpdateRequest;
import de.technikteam.config.Permissions;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.service.UserService;
import de.technikteam.util.NavigationRegistry;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.security.SecureRandom;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "Admin Users", description = "Endpoints for managing users.")
public class UserResource {

	private final UserService userService;
	private final UserDAO userDAO;
	private final AdminLogService adminLogService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public UserResource(UserService userService, UserDAO userDAO, AdminLogService adminLogService,
			LoginAttemptService loginAttemptService) {
		this.userService = userService;
		this.userDAO = userDAO;
		this.adminLogService = adminLogService;
		this.loginAttemptService = loginAttemptService;
	}

	@GetMapping("/me")
	@Operation(summary = "Get current user session", description = "Retrieves the user object and navigation items for the currently authenticated user.", security = @SecurityRequirement(name = "bearerAuth"))
	public ResponseEntity<ApiResponse> getCurrentUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User authenticatedUser = securityUser.getUser();
		List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(authenticatedUser);
		Map<String, Object> responseData = Map.of("user", authenticatedUser, "navigation", navigationItems);
		return ResponseEntity.ok(new ApiResponse(true, "Current user session retrieved.", responseData));
	}

	@GetMapping
	@Operation(summary = "Get all users", description = "Retrieves a list of all users in the system.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_READ')")
	public ResponseEntity<ApiResponse> getAllUsers() {
		List<User> users = userDAO.getAllUsers();
		return ResponseEntity.ok(new ApiResponse(true, "Users retrieved successfully", users));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get user by ID", description = "Retrieves a single user by their ID, including their permissions.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_READ')")
	public ResponseEntity<ApiResponse> getUserById(
			@Parameter(description = "ID of the user to retrieve") @PathVariable int id) {
		User user = userDAO.getUserById(id);
		if (user != null) {
			return ResponseEntity.ok(new ApiResponse(true, "User retrieved successfully", user));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found", null));
		}
	}

	@PostMapping
	@Operation(summary = "Create a new user", description = "Creates a new user with a specified role and individual permissions.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_CREATE')")
	public ResponseEntity<ApiResponse> createUser(@Valid @RequestBody UserCreateRequest createRequest,
			@AuthenticationPrincipal SecurityUser securityUser) {
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(createRequest.password());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "Password does not meet policy: " + validationResult.getMessage(), null));
		}

		User newUser = new User();
		newUser.setUsername(createRequest.username());
		newUser.setRoleId(createRequest.roleId());
		newUser.setEmail(createRequest.email());
		newUser.setClassYear(createRequest.classYear() != null ? createRequest.classYear() : 0);
		newUser.setClassName(createRequest.className());

		String[] permissionIds = createRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		int newUserId = userService.createUserWithPermissions(newUser, createRequest.password(), permissionIds,
				securityUser.getUsername());
		if (newUserId > 0) {
			User createdUser = userDAO.getUserById(newUserId);
			return new ResponseEntity<>(new ApiResponse(true, "User created successfully", createdUser),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.badRequest().body(
					new ApiResponse(false, "User could not be created (username or email may already exist).", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a user", description = "Updates an existing user's profile details, role, and individual permissions.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_UPDATE')")
	public ResponseEntity<ApiResponse> updateUser(
			@Parameter(description = "ID of the user to update") @PathVariable int id,
			@Valid @RequestBody UserUpdateRequest updateRequest, @AuthenticationPrincipal SecurityUser securityUser) {

		User userToUpdate = userDAO.getUserById(id);
		if (userToUpdate == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false, "User not found.", null));
		}

		userToUpdate.setUsername(updateRequest.username());
		userToUpdate.setRoleId(updateRequest.roleId());
		userToUpdate.setEmail(updateRequest.email());
		userToUpdate.setClassYear(updateRequest.classYear() != null ? updateRequest.classYear() : 0);
		userToUpdate.setClassName(updateRequest.className());

		String[] permissionIds = updateRequest.permissionIds().stream().map(String::valueOf).toArray(String[]::new);

		if (userService.updateUserWithPermissions(userToUpdate, permissionIds)) {
			adminLogService.log(securityUser.getUsername(), "UPDATE_USER_API",
					"User '" + userToUpdate.getUsername() + "' (ID: " + id + ") updated via API.");
			User refreshedUser = userDAO.getUserById(id);
			return ResponseEntity.ok(new ApiResponse(true, "User updated successfully", refreshedUser));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to update user.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a user", description = "Permanently deletes a user from the system.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_DELETE')")
	public ResponseEntity<ApiResponse> deleteUser(
			@Parameter(description = "ID of the user to delete") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User adminUser = securityUser.getUser(); // The admin performing the action

		if (adminUser.getId() == id) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "You cannot delete your own account.", null));
		}

		User userToDelete = userDAO.getUserById(id);
		if (userToDelete == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to delete not found.", null));
		}

		// --- REMEDIATION START ---
		// Check for privilege escalation attempt
		boolean targetIsSuperAdmin = userToDelete.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL);
		boolean requesterIsSuperAdmin = adminUser.getPermissions().contains(Permissions.ACCESS_ADMIN_PANEL);

		if (targetIsSuperAdmin && !requesterIsSuperAdmin) {
			adminLogService.log(adminUser.getUsername(), "DELETE_USER_DENIED_API",
					"Denied attempt to delete super-admin '" + userToDelete.getUsername() + "'.");
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false,
					"You do not have sufficient privileges to delete a super-administrator.", null));
		}
		// --- REMEDIATION END ---

		if (userDAO.deleteUser(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_USER_API",
					"User '" + userToDelete.getUsername() + "' (ID: " + id + ") deleted via API.");
			return ResponseEntity.ok(new ApiResponse(true, "User deleted successfully", Map.of("deletedUserId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Failed to delete user.", null));
		}
	}

	@PostMapping("/{id}/reset-password")
	@Operation(summary = "Reset user's password", description = "Resets a user's password to a new, randomly generated password.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_PASSWORD_RESET')")
	public ResponseEntity<ApiResponse> resetPassword(
			@Parameter(description = "ID of the user whose password will be reset") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User userToReset = userDAO.getUserById(id);
		if (userToReset == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to reset not found.", null));
		}

		String newPassword = generateRandomPassword(12);
		if (userDAO.changePassword(id, newPassword)) {
			adminLogService.log(securityUser.getUsername(), "RESET_PASSWORD_API",
					"Password for user '" + userToReset.getUsername() + "' (ID: " + id + ") reset via API.");
			return ResponseEntity
					.ok(new ApiResponse(true, "Password for " + userToReset.getUsername() + " has been reset.",
							Map.of("username", userToReset.getUsername(), "newPassword", newPassword)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Password could not be reset.", null));
		}
	}

	@PostMapping("/{id}/unlock")
	@Operation(summary = "Unlock a user account", description = "Unlocks a user account that was locked due to too many failed login attempts.", security = @SecurityRequirement(name = "bearerAuth"))
	@PreAuthorize("hasAuthority('USER_UPDATE')")
	public ResponseEntity<ApiResponse> unlockUser(
			@Parameter(description = "ID of the user to unlock") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {

		User userToUnlock = userDAO.getUserById(id);
		if (userToUnlock == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "User to unlock not found.", null));
		}

		loginAttemptService.clearLoginAttempts(userToUnlock.getUsername());
		adminLogService.log(securityUser.getUsername(), "UNLOCK_USER_API",
				"User account '" + userToUnlock.getUsername() + "' (ID: " + id + ") unlocked via API.");
		return ResponseEntity.ok(new ApiResponse(true,
				"User account '" + userToUnlock.getUsername() + "' has been unlocked.", Map.of("unlockedUserId", id)));
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\WikiResource.java
========================================================================

package de.technikteam.api.v1;

import de.technikteam.api.v1.dto.WikiUpdateRequest;
import de.technikteam.dao.WikiDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.model.WikiEntry;
import de.technikteam.service.AdminLogService;
import de.technikteam.service.WikiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.owasp.html.PolicyFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1/wiki")
@Tag(name = "Admin Wiki", description = "Endpoints for managing the technical documentation wiki.")
@SecurityRequirement(name = "bearerAuth")
@PreAuthorize("hasAuthority('ACCESS_ADMIN_PANEL')")
public class WikiResource {

	private final WikiService wikiService;
	private final WikiDAO wikiDAO;
	private final AdminLogService adminLogService;
	private final PolicyFactory richTextPolicy;

	@Autowired
	public WikiResource(WikiService wikiService, WikiDAO wikiDAO, AdminLogService adminLogService,
			@Qualifier("richTextPolicy") PolicyFactory richTextPolicy) {
		this.wikiService = wikiService;
		this.wikiDAO = wikiDAO;
		this.adminLogService = adminLogService;
		this.richTextPolicy = richTextPolicy;
	}

	@GetMapping
	@Operation(summary = "Get wiki navigation tree", description = "Retrieves the entire wiki page structure as a hierarchical tree.")
	public ResponseEntity<ApiResponse> getWikiTree() {
		Map<String, Object> treeData = wikiService.getWikiTreeAsData();
		return ResponseEntity.ok(new ApiResponse(true, "Wiki-Struktur erfolgreich abgerufen.", treeData));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get a single wiki page", description = "Retrieves the content of a single wiki page by its ID.")
	public ResponseEntity<ApiResponse> getWikiEntryById(
			@Parameter(description = "ID of the wiki page to retrieve") @PathVariable int id) {
		Optional<WikiEntry> entryOptional = wikiDAO.getWikiEntryById(id);
		return entryOptional.map(entry -> ResponseEntity.ok(new ApiResponse(true, "Inhalt geladen.", entry)))
				.orElseGet(() -> ResponseEntity.status(HttpStatus.NOT_FOUND)
						.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null)));
	}

	@PostMapping
	@Operation(summary = "Create a new wiki page", description = "Creates a new documentation page in the wiki.")
	public ResponseEntity<ApiResponse> createWikiEntry(@Valid @RequestBody WikiEntry newEntry,
			@AuthenticationPrincipal User adminUser) {
		if (newEntry.getFilePath() == null || newEntry.getFilePath().isBlank()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Dateipfad darf nicht leer sein.", null));
		}
		if (wikiDAO.findByFilePath(newEntry.getFilePath()).isPresent()) {
			return ResponseEntity.status(HttpStatus.CONFLICT)
					.body(new ApiResponse(false, "Ein Eintrag mit diesem Dateipfad existiert bereits.", null));
		}

		newEntry.setContent(richTextPolicy.sanitize(newEntry.getContent()));
		Optional<WikiEntry> createdEntryOptional = wikiDAO.createWikiEntry(newEntry);
		if (createdEntryOptional.isPresent()) {
			adminLogService.log(adminUser.getUsername(), "CREATE_WIKI_PAGE",
					"Created wiki page: " + createdEntryOptional.get().getFilePath());
			return new ResponseEntity<>(
					new ApiResponse(true, "Seite erfolgreich erstellt.", createdEntryOptional.get()),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Seite konnte nicht in der Datenbank erstellt werden.", null));
		}
	}

	@PutMapping("/{id}")
	@Operation(summary = "Update a wiki page", description = "Updates the content of an existing wiki page.")
	public ResponseEntity<ApiResponse> updateWikiEntry(
			@Parameter(description = "ID of the wiki page to update") @PathVariable int id,
			@Valid @RequestBody WikiUpdateRequest updateRequest, @AuthenticationPrincipal User adminUser) {

		String sanitizedContent = richTextPolicy.sanitize(updateRequest.content());
		if (wikiDAO.updateWikiContent(id, sanitizedContent)) {
			adminLogService.log(adminUser.getUsername(), "UPDATE_WIKI_PAGE", "Updated wiki page ID: " + id);
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ApiResponse(false,
					"Seite konnte nicht aktualisiert werden. Sie existiert möglicherweise nicht.", null));
		}
	}

	@DeleteMapping("/{id}")
	@Operation(summary = "Delete a wiki page", description = "Permanently deletes a wiki page.")
	public ResponseEntity<ApiResponse> deleteWikiEntry(
			@Parameter(description = "ID of the wiki page to delete") @PathVariable int id,
			@AuthenticationPrincipal User adminUser) {

		Optional<WikiEntry> entryToDelete = wikiDAO.getWikiEntryById(id);
		if (entryToDelete.isEmpty()) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Wiki-Eintrag nicht gefunden.", null));
		}

		if (wikiDAO.deleteWikiEntry(id)) {
			adminLogService.log(adminUser.getUsername(), "DELETE_WIKI_PAGE",
					"Deleted wiki page: " + entryToDelete.get().getFilePath());
			return ResponseEntity.ok(new ApiResponse(true, "Seite erfolgreich gelöscht.", Map.of("deletedId", id)));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Fehler beim Löschen der Seite.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\AuthResource.java
========================================================================

package de.technikteam.api.v1.auth;

import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.service.AuthService;
import de.technikteam.service.LoginAttemptService;
import de.technikteam.dao.UserDAO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.parameters.RequestBody;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api/v1/auth")
@Tag(name = "Authentication", description = "Endpoints for user authentication.")
public class AuthResource {
	private static final Logger logger = LogManager.getLogger(AuthResource.class);

	private final UserDAO userDAO;
	private final AuthService authService;
	private final LoginAttemptService loginAttemptService;

	@Autowired
	public AuthResource(UserDAO userDAO, AuthService authService, LoginAttemptService loginAttemptService) {
		this.userDAO = userDAO;
		this.authService = authService;
		this.loginAttemptService = loginAttemptService;
	}

	@PostMapping("/login")
	@Operation(summary = "User Login", description = "Authenticates a user with username and password. On success, it sets an HttpOnly cookie with the JWT and returns user session data.", requestBody = @RequestBody(description = "User credentials for login.", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = LoginRequest.class))))
	public ResponseEntity<ApiResponse> login(
			@org.springframework.web.bind.annotation.RequestBody LoginRequest loginRequest, HttpServletRequest request,
			HttpServletResponse response) {
		String username = loginRequest.username();
		String password = loginRequest.password();
		String ipAddress = getClientIp(request);

		if (loginAttemptService.isLockedOut(username, ipAddress)) {
			logger.warn("Blocked login attempt for locked-out user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Konto ist vorübergehend gesperrt.", null),
					HttpStatus.FORBIDDEN);
		}

		User user = userDAO.validateUser(username, password);
		if (user != null) {
			loginAttemptService.clearLoginAttempts(username);
			authService.addJwtCookie(user, response);
			logger.info("JWT cookie set successfully for user '{}'", username);
			// Return user data but not the token itself
			return ResponseEntity.ok(new ApiResponse(true, "Anmeldung erfolgreich", user));
		} else {
			loginAttemptService.recordFailedLogin(username, ipAddress);
			logger.warn("Failed API login attempt for user '{}' from IP {}", username, ipAddress);
			return new ResponseEntity<>(new ApiResponse(false, "Falscher Benutzername oder Passwort.", null),
					HttpStatus.UNAUTHORIZED);
		}
	}

	@PostMapping("/logout")
	@Operation(summary = "User Logout", description = "Logs out the user by clearing the JWT authentication cookie.")
	public ResponseEntity<ApiResponse> logout(HttpServletResponse response) {
		authService.clearJwtCookie(response);
		return ResponseEntity.ok(new ApiResponse(true, "Abmeldung erfolgreich", null));
	}

	private String getClientIp(HttpServletRequest request) {
		String xfHeader = request.getHeader("X-Forwarded-For");
		if (xfHeader == null || xfHeader.isEmpty()) {
			return request.getRemoteAddr();
		}
		return xfHeader.split(",")[0];
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\auth\LoginRequest.java
========================================================================

package de.technikteam.api.v1.auth;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/**
 * A Data Transfer Object (DTO) representing the credentials for a login
 * request. Using a dedicated DTO provides type safety and allows for
 * declarative validation.
 */
public record LoginRequest(
		@NotBlank(message = "Username cannot be blank") @Schema(description = "The user's unique username.", example = "admin", required = true) String username,

		@NotBlank(message = "Password cannot be blank") @Schema(description = "The user's password.", example = "admin123", required = true) String password) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\CategoryRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record CategoryRequest(
		@NotBlank(message = "Kategoriename darf nicht leer sein") @Size(min = 2, max = 100, message = "Kategoriename muss zwischen 2 und 100 Zeichen lang sein") @Schema(description = "The name for the new file category.", required = true) String name) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\EventUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;
import java.util.List;

public record EventUpdateRequest(@NotBlank @Schema(description = "Name of the event") String name,
		@NotNull @Schema(description = "Start date and time of the event") LocalDateTime eventDateTime,
		@Schema(description = "End date and time of the event") LocalDateTime endDateTime,
		@Schema(description = "Detailed description of the event") String description,
		@Schema(description = "Location of the event") String location,
		@Schema(description = "Current status of the event (e.g., GEPLANT, LAUFEND)") String status,
		@Schema(description = "ID of the user leading the event") Integer leaderUserId,
		@Schema(description = "Required role for viewing attachments") String requiredRole,
		@Schema(description = "Array of course IDs for skill requirements") List<String> requiredCourseIds,
		@Schema(description = "Array of required person counts for skills") List<String> requiredPersons,
		@Schema(description = "Array of item IDs for reservations") List<String> itemIds,
		@Schema(description = "Array of quantities for reserved items") List<String> quantities) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\GeneralFeedbackRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public record GeneralFeedbackRequest(
		@NotBlank(message = "Betreff darf nicht leer sein") @Size(max = 255, message = "Betreff darf nicht länger als 255 Zeichen sein") @Schema(description = "The subject line of the feedback.", required = true) String subject,

		@NotBlank(message = "Inhalt darf nicht leer sein") @Schema(description = "The detailed content of the feedback.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\MeetingRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.FutureOrPresent;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import java.time.LocalDateTime;

public record MeetingRequest(
		@NotNull(message = "Kurs-ID darf nicht null sein") @Schema(description = "The ID of the parent course for this meeting.", required = true) Integer courseId,

		@NotBlank(message = "Meeting-Name darf nicht leer sein") @Schema(description = "The name of the meeting.", required = true, example = "Teil 1: Grundlagen") String name,

		@NotNull(message = "Datum und Uhrzeit des Meetings dürfen nicht null sein") @FutureOrPresent(message = "Das Datum des Meetings muss in der Gegenwart oder Zukunft liegen") @Schema(description = "The start date and time of the meeting.", required = true) LocalDateTime meetingDateTime,

		@Schema(description = "The optional end date and time of the meeting.") LocalDateTime endDateTime,

		@Schema(description = "The ID of the user leading the meeting.") Integer leaderUserId,

		@Schema(description = "A description of the meeting's content.") String description,

		@Schema(description = "The location of the meeting.") String location) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\PasswordChangeRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

public record PasswordChangeRequest(
		@NotBlank(message = "Aktuelles Passwort darf nicht leer sein") @Schema(description = "The user's current password.", required = true) String currentPassword,

		@NotBlank(message = "Neues Passwort darf nicht leer sein") @Schema(description = "The desired new password. Must meet the password policy.", required = true) String newPassword,

		@NotBlank(message = "Bestätigungspasswort darf nicht leer sein") @Schema(description = "Confirmation of the new password.", required = true) String confirmPassword) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\ProfileChangeRequestDTO.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;

public record ProfileChangeRequestDTO(
		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's new email address.") String email,

		@Schema(description = "The user's new class year.") Integer classYear,

		@Schema(description = "The user's new class name.") String className) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserCreateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserCreateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotBlank(message = "Passwort darf nicht leer sein") @Schema(description = "The user's initial password. Must meet the password policy.", required = true) String password,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\UserUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

import java.util.List;

public record UserUpdateRequest(
		@NotBlank(message = "Benutzername darf nicht leer sein") @Size(min = 3, max = 50, message = "Benutzername muss zwischen 3 und 50 Zeichen lang sein") @Schema(description = "The user's unique username.", required = true) String username,

		@NotNull(message = "Rollen-ID darf nicht null sein") @Schema(description = "The ID of the user's role.", required = true) Integer roleId,

		@Email(message = "Muss ein gültiges E-Mail-Format sein") @Schema(description = "The user's email address.") String email,

		@Schema(description = "The user's class year.") Integer classYear,

		@Schema(description = "The user's class name.") String className,

		@NotNull(message = "Berechtigungsliste darf nicht null sein") @Schema(description = "A list of IDs for the user's individual permissions.") List<Integer> permissionIds) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\dto\WikiUpdateRequest.java
========================================================================

package de.technikteam.api.v1.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record WikiUpdateRequest(
		@NotNull(message = "Inhalt darf nicht null sein") @Schema(description = "The full Markdown content of the wiki page.", required = true) String content) {
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarEntriesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/calendar")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarEntriesResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarEntriesResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/entries")
	@Operation(summary = "Get calendar entries", description = "Retrieves a combined list of upcoming events and meetings for display in a calendar.")
	public ResponseEntity<ApiResponse> getCalendarEntries() {
		List<Map<String, Object>> entries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", event.getId());
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("end", event.getEndDateTime());
			entry.put("type", "Event");
			entry.put("url", "/veranstaltungen/details/" + event.getId());
			entries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("id", meeting.getId());
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("end", meeting.getEndDateTime());
			entry.put("type", "Lehrgang");
			entry.put("url", "/lehrgaenge/details/" + meeting.getId());
			entries.add(entry);
		}

		return ResponseEntity.ok(new ApiResponse(true, "Kalendereinträge erfolgreich abgerufen.", entries));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicCalendarResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.servlet.http.HttpServletRequest;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.DateTime;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.*;
import net.fortuna.ical4j.util.RandomUidGenerator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.ByteArrayOutputStream;
import java.net.URI;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

@RestController
@RequestMapping("/api/v1/public")
@Tag(name = "Public Calendar", description = "Endpoints for calendar data.")
@SecurityRequirement(name = "bearerAuth")
public class PublicCalendarResource {

	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;

	@Autowired
	public PublicCalendarResource(EventDAO eventDAO, MeetingDAO meetingDAO) {
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
	}

	@GetMapping("/calendar.ics")
	@Operation(summary = "Get iCalendar Feed", description = "Provides an iCalendar (.ics) feed of all upcoming events and meetings.", responses = {
			@ApiResponse(responseCode = "200", description = "iCalendar feed generated successfully", content = @Content(mediaType = "text/calendar")),
			@ApiResponse(responseCode = "500", description = "Internal server error while generating the feed") })
	public ResponseEntity<byte[]> getICalendarFeed(HttpServletRequest request) {
		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-//TechnikTeam Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
					+ request.getContextPath();
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());
				if (event.getEventDateTime() != null) {
					vEvent.getProperties().add(new DtStart(
							new DateTime(Date.from(event.getEventDateTime().atZone(systemZone).toInstant()))));
				}
				if (event.getEndDateTime() != null) {
					vEvent.getProperties().add(
							new DtEnd(new DateTime(Date.from(event.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				vEvent.getProperties().add(new Url(new URI(baseUrl + "/veranstaltungen/details/" + event.getId())));
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());
				if (meeting.getMeetingDateTime() != null) {
					vMeeting.getProperties().add(new DtStart(
							new DateTime(Date.from(meeting.getMeetingDateTime().atZone(systemZone).toInstant()))));
				}
				if (meeting.getEndDateTime() != null) {
					vMeeting.getProperties().add(new DtEnd(
							new DateTime(Date.from(meeting.getEndDateTime().atZone(systemZone).toInstant()))));
				}
				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				vMeeting.getProperties().add(new Url(new URI(baseUrl + "/lehrgaenge/details/" + meeting.getId())));
				calendar.getComponents().add(vMeeting);
			}

			ByteArrayOutputStream boas = new ByteArrayOutputStream();
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, boas);

			HttpHeaders headers = new HttpHeaders();
			headers.setContentType(MediaType.parseMediaType("text/calendar"));
			headers.setContentDispositionFormData("attachment", "technikteam-calendar.ics");

			return new ResponseEntity<>(boas.toByteArray(), headers, HttpStatus.OK);

		} catch (Exception e) {
			return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicDashboardResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/dashboard")
@Tag(name = "Public Dashboard", description = "Endpoints for the user-facing dashboard.")
@SecurityRequirement(name = "bearerAuth")
public class PublicDashboardResource {

	private final EventDAO eventDAO;
	private final EventTaskDAO eventTaskDAO;

	@Autowired
	public PublicDashboardResource(EventDAO eventDAO, EventTaskDAO eventTaskDAO) {
		this.eventDAO = eventDAO;
		this.eventTaskDAO = eventTaskDAO;
	}

	@GetMapping
	@Operation(summary = "Get dashboard data", description = "Retrieves all necessary data for the user's main dashboard view.")
	public ResponseEntity<ApiResponse> getDashboardData(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getAllActiveAndUpcomingEvents(); // Simplified for now

		Map<String, Object> dashboardData = new HashMap<>();
		dashboardData.put("assignedEvents", assignedEvents);
		dashboardData.put("openTasks", openTasks);
		dashboardData.put("upcomingEvents", upcomingEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Dashboard-Daten erfolgreich abgerufen.", dashboardData));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicEventResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.EventService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/events")
@Tag(name = "Public Events", description = "Endpoints for user interactions with events.")
@SecurityRequirement(name = "bearerAuth")
public class PublicEventResource {

	private final EventDAO eventDAO;
	private final EventService eventService;
	private final EventCustomFieldDAO customFieldDAO;

	@Autowired
	public PublicEventResource(EventDAO eventDAO, EventService eventService, EventCustomFieldDAO customFieldDAO) {
		this.eventDAO = eventDAO;
		this.eventService = eventService;
		this.customFieldDAO = customFieldDAO;
	}

	@GetMapping
	@Operation(summary = "Get upcoming events for user", description = "Retrieves a list of upcoming events, indicating the user's current attendance and qualification status for each.")
	public ResponseEntity<ApiResponse> getUpcomingEventsForUser(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Event> events = eventDAO.getUpcomingEventsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungen erfolgreich abgerufen.", events));
	}

	@GetMapping("/{id}")
	@Operation(summary = "Get event details", description = "Retrieves detailed information for a single event.")
	public ResponseEntity<ApiResponse> getEventDetails(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		Event event = eventDAO.getEventById(id);
		if (event == null) {
			return ResponseEntity.status(404).body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		return ResponseEntity.ok(new ApiResponse(true, "Veranstaltungsdetails erfolgreich abgerufen.", event));
	}

	@PostMapping("/{id}/signup")
	@Operation(summary = "Sign up for an event", description = "Allows the current user to sign up for an event and submit custom field responses.")
	public ResponseEntity<ApiResponse> signUpForEvent(@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> customFieldResponses) {
		User user = securityUser.getUser();
		eventDAO.signUpForEvent(user.getId(), id);
		if (customFieldResponses != null) {
			customFieldResponses.forEach((key, value) -> {
				if (key.startsWith("customfield_")) {
					int fieldId = Integer.parseInt(key.substring("customfield_".length()));
					EventCustomFieldResponse response = new EventCustomFieldResponse();
					response.setFieldId(fieldId);
					response.setUserId(user.getId());
					response.setResponseValue(value);
					customFieldDAO.saveResponse(response);
				}
			});
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich für die Veranstaltung angemeldet.", null));
	}

	@PostMapping("/{id}/signoff")
	@Operation(summary = "Sign off from an event", description = "Allows the current user to sign off from an event.")
	public ResponseEntity<ApiResponse> signOffFromEvent(
			@Parameter(description = "ID of the event") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser, @RequestBody Map<String, String> payload) {
		User user = securityUser.getUser();
		String reason = payload.get("reason");
		Event event = eventDAO.getEventById(id);
		if ("LAUFEND".equals(event.getStatus())) {
			eventService.signOffUserFromRunningEvent(user.getId(), user.getUsername(), id, reason);
		} else {
			eventDAO.signOffFromEvent(user.getId(), id);
		}
		return ResponseEntity.ok(new ApiResponse(true, "Erfolgreich von der Veranstaltung abgemeldet.", null));
	}

	@GetMapping("/{id}/custom-fields")
	@Operation(summary = "Get custom fields for an event", description = "Retrieves the list of custom fields required for signing up for a specific event.")
	public ResponseEntity<ApiResponse> getEventCustomFields(
			@Parameter(description = "ID of the event") @PathVariable int id) {
		List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(id);
		return ResponseEntity.ok(new ApiResponse(true, "Zusatzfelder erfolgreich abgerufen.", fields));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFeedbackResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.api.v1.dto.GeneralFeedbackRequest;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventFeedbackDAO;
import de.technikteam.dao.FeedbackSubmissionDAO;
import de.technikteam.model.*;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/feedback")
@Tag(name = "Public Feedback", description = "Endpoints for users to submit and view feedback.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFeedbackResource {

	private final FeedbackSubmissionDAO submissionDAO;
	private final EventFeedbackDAO eventFeedbackDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicFeedbackResource(FeedbackSubmissionDAO submissionDAO, EventFeedbackDAO eventFeedbackDAO,
			EventDAO eventDAO) {
		this.submissionDAO = submissionDAO;
		this.eventFeedbackDAO = eventFeedbackDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping("/user")
	@Operation(summary = "Get user's feedback submissions", description = "Retrieves a list of all general feedback submissions made by the current user.")
	public ResponseEntity<ApiResponse> getMyFeedbackSubmissions(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<FeedbackSubmission> submissions = submissionDAO.getSubmissionsByUserId(user.getId());
		return ResponseEntity.ok(new ApiResponse(true, "Einreichungen erfolgreich abgerufen.", submissions));
	}

	@PostMapping("/general")
	@Operation(summary = "Submit general feedback", description = "Allows a user to submit a new general feedback entry.")
	public ResponseEntity<ApiResponse> submitGeneralFeedback(@Valid @RequestBody GeneralFeedbackRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		FeedbackSubmission submission = new FeedbackSubmission();
		submission.setUserId(user.getId());
		submission.setSubject(request.subject());
		submission.setContent(request.content());

		if (submissionDAO.createSubmission(submission)) {
			return new ResponseEntity<>(new ApiResponse(true, "Feedback erfolgreich übermittelt.", submission),
					HttpStatus.CREATED);
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Feedback konnte nicht gespeichert werden.", null));
		}
	}

	@GetMapping("/forms")
	@Operation(summary = "Get feedback form for an event", description = "Retrieves the feedback form for a specific event and checks if the user has already submitted a response.")
	public ResponseEntity<ApiResponse> getEventFeedbackForm(
			@Parameter(description = "ID of the event") @RequestParam int eventId,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Veranstaltung nicht gefunden.", null));
		}
		FeedbackForm form = eventFeedbackDAO.getFeedbackFormForEvent(eventId);
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Kein Feedback-Formular für diese Veranstaltung.", null));
		}
		boolean alreadySubmitted = eventFeedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId());

		Map<String, Object> responseData = Map.of("event", event, "form", form, "alreadySubmitted", alreadySubmitted);
		return ResponseEntity.ok(new ApiResponse(true, "Formulardaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/event")
	@Operation(summary = "Submit event feedback", description = "Submits a user's rating and comments for an event feedback form.")
	public ResponseEntity<ApiResponse> submitEventFeedback(@RequestBody FeedbackResponse response,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		response.setUserId(user.getId());

		// --- REMEDIATION START ---
		FeedbackForm form = eventFeedbackDAO.getFormById(response.getFormId());
		if (form == null) {
			return ResponseEntity.status(HttpStatus.NOT_FOUND)
					.body(new ApiResponse(false, "Feedback-Formular nicht gefunden.", null));
		}
		// Check if user was actually assigned to the event for which they are giving
		// feedback
		if (!eventDAO.isUserAssociatedWithEvent(form.getEventId(), user.getId())) {
			return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ApiResponse(false,
					"Sie können nur Feedback für Veranstaltungen abgeben, an denen Sie teilgenommen haben.", null));
		}
		// --- REMEDIATION END ---

		if (eventFeedbackDAO.saveFeedbackResponse(response)) {
			return ResponseEntity.ok(new ApiResponse(true, "Event-Feedback erfolgreich übermittelt.", null));
		}
		return ResponseEntity.internalServerError()
				.body(new ApiResponse(false, "Event-Feedback konnte nicht gespeichert werden.", null));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFilesResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.File;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
@SecurityRequirement(name = "bearerAuth")
public class PublicFilesResource {

	private final FileDAO fileDAO;

	@Autowired
	public PublicFilesResource(FileDAO fileDAO) {
		this.fileDAO = fileDAO;
	}

	@GetMapping
	@Operation(summary = "Get all accessible files grouped by category", description = "Retrieves files visible to the current user, grouped by their category.")
	public ResponseEntity<ApiResponse> getFiles(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, List<File>> files = fileDAO.getAllFilesGroupedByCategory(user);
		return ResponseEntity.ok(new ApiResponse(true, "Dateien erfolgreich abgerufen.", files));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicFileStreamResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.FileDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ConfigurationService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@RestController
@RequestMapping("/api/v1/public/files")
@Tag(name = "Public Files", description = "Endpoints for downloading files and viewing images.")
public class PublicFileStreamResource {
	private static final Logger logger = LogManager.getLogger(PublicFileStreamResource.class);

	private final FileDAO fileDAO;
	private final UserDAO userDAO;
	private final AttachmentDAO attachmentDAO;
	private final EventDAO eventDAO;
	private final MeetingDAO meetingDAO;
	private final Path fileStorageLocation;

	@Autowired
	public PublicFileStreamResource(FileDAO fileDAO, UserDAO userDAO, AttachmentDAO attachmentDAO, EventDAO eventDAO,
			MeetingDAO meetingDAO, ConfigurationService configService) {
		this.fileDAO = fileDAO;
		this.userDAO = userDAO;
		this.attachmentDAO = attachmentDAO;
		this.eventDAO = eventDAO;
		this.meetingDAO = meetingDAO;
		this.fileStorageLocation = Paths.get(configService.getProperty("upload.directory")).toAbsolutePath()
				.normalize();
	}

	@GetMapping("/download/{id}")
	@Operation(summary = "Download a file", description = "Downloads a file (general or attachment) by its database ID after checking permissions.", security = @SecurityRequirement(name = "bearerAuth"))
	@ApiResponse(responseCode = "200", description = "File content", content = @Content(mediaType = "application/octet-stream"))
	public ResponseEntity<Resource> downloadFile(
			@Parameter(description = "ID of the file or attachment record") @PathVariable int id,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String filePathFromDb = null;
		String filenameForDownload = null;
		boolean isAuthorized = false;

		Attachment attachment = attachmentDAO.getAttachmentById(id);
		if (attachment != null) {
			filePathFromDb = attachment.getFilepath();
			filenameForDownload = attachment.getFilename();
			isAuthorized = isUserAuthorizedForAttachment(user, attachment);
		} else {
			de.technikteam.model.File dbFile = fileDAO.getFileById(id);
			if (dbFile != null) {
				filePathFromDb = dbFile.getFilepath();
				filenameForDownload = dbFile.getFilename();
				isAuthorized = "NUTZER".equalsIgnoreCase(dbFile.getRequiredRole()) || user.hasAdminAccess();
			}
		}

		if (filePathFromDb == null)
			return ResponseEntity.notFound().build();
		if (!isAuthorized)
			return ResponseEntity.status(403).build();

		return serveFile(filePathFromDb, filenameForDownload, false);
	}

	@GetMapping("/images/{filename:.+}")
	@Operation(summary = "Get an inventory image", description = "Retrieves an inventory image for display. The filename usually corresponds to a storage item's image path.", security = @SecurityRequirement(name = "bearerAuth"))
	@ApiResponse(responseCode = "200", description = "Image content", content = @Content(mediaType = "image/*"))
	public ResponseEntity<Resource> getImage(
			@Parameter(description = "The filename of the image") @PathVariable String filename) {
		return serveFile("images/" + filename, filename, true);
	}

	@GetMapping("/avatars/user/{userId}")
	@Operation(summary = "Get a user avatar", description = "Retrieves a user's profile picture for display. This endpoint is secured and requires authentication.")
	@ApiResponse(responseCode = "200", description = "Image content", content = @Content(mediaType = "image/*"))
	@SecurityRequirement(name = "bearerAuth")
	public ResponseEntity<Resource> getAvatar(
			@Parameter(description = "The ID of the user whose avatar is requested") @PathVariable int userId) {
		User user = userDAO.getUserById(userId);
		if (user == null || user.getProfilePicturePath() == null || user.getProfilePicturePath().isBlank()) {
			return ResponseEntity.notFound().build();
		}
		return serveFile("avatars/" + user.getProfilePicturePath(), user.getProfilePicturePath(), true);
	}

	private boolean isUserAuthorizedForAttachment(User user, Attachment attachment) {
		if (user.hasAdminAccess())
			return true;
		if ("NUTZER".equalsIgnoreCase(attachment.getRequiredRole())) {
			if ("EVENT".equals(attachment.getParentType())) {
				return eventDAO.isUserAssociatedWithEvent(attachment.getParentId(), user.getId());
			} else if ("MEETING".equals(attachment.getParentType())) {
				return meetingDAO.isUserAssociatedWithMeeting(attachment.getParentId(), user.getId());
			}
		}
		return false;
	}

	private ResponseEntity<Resource> serveFile(String relativePath, String originalFilename, boolean inline) {
		try {
			Path filePath = this.fileStorageLocation.resolve(relativePath).normalize();
			if (!filePath.startsWith(this.fileStorageLocation)) {
				logger.warn("Path Traversal Attack attempt detected for path '{}'", filePath);
				return ResponseEntity.status(403).build();
			}

			Resource resource = new UrlResource(filePath.toUri());
			if (resource.exists() || resource.isReadable()) {
				String contentType = "application/octet-stream"; // fallback
				try {
					contentType = Files.probeContentType(filePath);
				} catch (IOException e) {
					logger.warn("Could not determine content type for file {}", filePath);
				}

				String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+",
						"%20");
				String disposition = inline ? "inline" : "attachment";

				return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))
						.header(HttpHeaders.CONTENT_DISPOSITION, disposition + "; filename*=UTF-8''" + encodedFilename)
						.body(resource);
			} else {
				logger.error("File not found or not readable at path: {}", filePath);
				return ResponseEntity.notFound().build();
			}
		} catch (MalformedURLException ex) {
			logger.error("Malformed URL for file path: {}", relativePath, ex);
			return ResponseEntity.notFound().build();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicMeetingResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/v1/public/meetings")
@Tag(name = "Public Meetings", description = "Endpoints for user interactions with training meetings.")
@SecurityRequirement(name = "bearerAuth")
public class PublicMeetingResource {

	private final MeetingDAO meetingDAO;
	private final MeetingAttendanceDAO attendanceDAO;

	@Autowired
	public PublicMeetingResource(MeetingDAO meetingDAO, MeetingAttendanceDAO attendanceDAO) {
		this.meetingDAO = meetingDAO;
		this.attendanceDAO = attendanceDAO;
	}

	@GetMapping
	@Operation(summary = "Get upcoming meetings for user", description = "Retrieves a list of upcoming meetings, indicating the user's current attendance status for each.")
	public ResponseEntity<ApiResponse> getUpcomingMeetings(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);
		return ResponseEntity.ok(new ApiResponse(true, "Termine erfolgreich abgerufen.", meetings));
	}

	@PostMapping("/{id}/{action}")
	@Operation(summary = "Sign up or off from a meeting", description = "Allows the current user to sign up for or sign off from a specific meeting.")
	public ResponseEntity<ApiResponse> handleMeetingAction(
			@Parameter(description = "ID of the meeting") @PathVariable int id,
			@Parameter(description = "Action to perform. Must be 'signup' or 'signoff'.") @PathVariable String action,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();

		boolean success;
		if ("signup".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, true, "");
		} else if ("signoff".equalsIgnoreCase(action)) {
			success = attendanceDAO.setAttendance(user.getId(), id, false, "");
		} else {
			return ResponseEntity.badRequest().body(new ApiResponse(false, "Unbekannte Aktion.", null));
		}

		if (success) {
			return ResponseEntity.ok(new ApiResponse(true, "Aktion erfolgreich ausgeführt.", null));
		} else {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Aktion konnte nicht verarbeitet werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicProfileResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import com.google.gson.Gson;
import de.technikteam.api.v1.dto.PasswordChangeRequest;
import de.technikteam.api.v1.dto.ProfileChangeRequestDTO;
import de.technikteam.dao.*;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.ProfileRequestService;
import de.technikteam.util.PasswordPolicyValidator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/profile")
@Tag(name = "Public Profile", description = "Endpoints for managing the current user's profile.")
@SecurityRequirement(name = "bearerAuth")
public class PublicProfileResource {

	private final UserDAO userDAO;
	private final EventDAO eventDAO;
	private final UserQualificationsDAO qualificationsDAO;
	private final AchievementDAO achievementDAO;
	// private final PasskeyDAO passkeyDAO; // REMOVED
	private final ProfileChangeRequestDAO requestDAO;
	private final ProfileRequestService profileRequestService;

	@Autowired
	public PublicProfileResource(UserDAO userDAO, EventDAO eventDAO, UserQualificationsDAO qualificationsDAO,
			AchievementDAO achievementDAO, /* PasskeyDAO passkeyDAO, */ ProfileChangeRequestDAO requestDAO, // REMOVED
			ProfileRequestService profileRequestService, Gson gson) {
		this.userDAO = userDAO;
		this.eventDAO = eventDAO;
		this.qualificationsDAO = qualificationsDAO;
		this.achievementDAO = achievementDAO;
		// this.passkeyDAO = passkeyDAO; // REMOVED
		this.requestDAO = requestDAO;
		this.profileRequestService = profileRequestService;
	}

	@GetMapping
	@Operation(summary = "Get current user's profile data", description = "Retrieves a comprehensive set of data for the authenticated user's profile page.")
	public ResponseEntity<ApiResponse> getMyProfile(@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		Map<String, Object> profileData = new HashMap<>();
		profileData.put("user", user);
		profileData.put("eventHistory", eventDAO.getEventHistoryForUser(user.getId()));
		profileData.put("qualifications", qualificationsDAO.getQualificationsForUser(user.getId()));
		profileData.put("achievements", achievementDAO.getAchievementsForUser(user.getId()));
		profileData.put("passkeys", Collections.emptyList()); // REMOVED passkeyDAO call, return empty list
		profileData.put("hasPendingRequest", requestDAO.hasPendingRequest(user.getId()));

		return ResponseEntity.ok(new ApiResponse(true, "Profildaten erfolgreich abgerufen.", profileData));
	}

	@PostMapping("/request-change")
	@Operation(summary = "Request a profile data change", description = "Submits a request for an administrator to approve changes to the user's profile data, including an optional profile picture.")
	public ResponseEntity<ApiResponse> requestProfileChange(
			@RequestPart("profileData") @Valid ProfileChangeRequestDTO requestDTO,
			@RequestPart(value = "profilePicture", required = false) MultipartFile profilePicture,
			@AuthenticationPrincipal SecurityUser securityUser) {
		try {
			profileRequestService.createChangeRequest(securityUser.getUser(), requestDTO, profilePicture);
			return ResponseEntity.ok(new ApiResponse(true, "Änderungsantrag erfolgreich eingereicht.", null));
		} catch (Exception e) {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
					new ApiResponse(false, "Ihr Antrag konnte nicht gespeichert werden: " + e.getMessage(), null));
		}
	}

	@PutMapping("/theme")
	@Operation(summary = "Update user theme", description = "Updates the user's preferred theme (light/dark).")
	public ResponseEntity<ApiResponse> updateUserTheme(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String theme = payload.get("theme");
		if (theme != null && (theme.equals("light") || theme.equals("dark"))) {
			if (userDAO.updateUserTheme(user.getId(), theme)) {
				User updatedUser = userDAO.getUserById(user.getId());
				return ResponseEntity.ok(new ApiResponse(true, "Theme aktualisiert.", updatedUser));
			}
		}
		return ResponseEntity.badRequest().body(new ApiResponse(false, "Ungültiges Theme angegeben.", null));
	}

	@PutMapping("/chat-color")
	@Operation(summary = "Update chat color", description = "Updates the user's preferred color for chat messages.")
	public ResponseEntity<ApiResponse> updateChatColor(@RequestBody Map<String, String> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		String chatColor = payload.get("chatColor");
		if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
			return ResponseEntity.ok(new ApiResponse(true, "Chatfarbe aktualisiert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Chatfarbe konnte nicht gespeichert werden.", null));
		}
	}

	@PutMapping("/password")
	@Operation(summary = "Change password", description = "Allows the authenticated user to change their own password after verifying their current one.")
	public ResponseEntity<ApiResponse> updatePassword(@Valid @RequestBody PasswordChangeRequest request,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		if (userDAO.validateUser(user.getUsername(), request.currentPassword()) == null) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Das aktuelle Passwort ist nicht korrekt.", null));
		}
		if (!request.newPassword().equals(request.confirmPassword())) {
			return ResponseEntity.badRequest()
					.body(new ApiResponse(false, "Die neuen Passwörter stimmen nicht überein.", null));
		}
		PasswordPolicyValidator.ValidationResult validationResult = PasswordPolicyValidator
				.validate(request.newPassword());
		if (!validationResult.isValid()) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, validationResult.getMessage(), null));
		}
		if (userDAO.changePassword(user.getId(), request.newPassword())) {
			return ResponseEntity.ok(new ApiResponse(true, "Ihr Passwort wurde erfolgreich geändert.", null));
		} else {
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
					.body(new ApiResponse(false, "Passwort konnte nicht geändert werden.", null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\api\v1\public_api\PublicStorageResource.java
========================================================================

package de.technikteam.api.v1.public_api;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.ApiResponse;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.security.SecurityUser;
import de.technikteam.service.StorageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/public/storage")
@Tag(name = "Public Storage", description = "Endpoints for user interaction with the inventory.")
@SecurityRequirement(name = "bearerAuth")
public class PublicStorageResource {

	private final StorageService storageService;
	private final StorageDAO storageDAO;
	private final EventDAO eventDAO;

	@Autowired
	public PublicStorageResource(StorageService storageService, StorageDAO storageDAO, EventDAO eventDAO) {
		this.storageService = storageService;
		this.storageDAO = storageDAO;
		this.eventDAO = eventDAO;
	}

	@GetMapping
	@Operation(summary = "Get all storage data for display", description = "Retrieves all storage items grouped by location and a list of active events for the transaction modal.")
	public ResponseEntity<ApiResponse> getStoragePageData() {
		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("storageData", storageData);
		responseData.put("activeEvents", activeEvents);

		return ResponseEntity.ok(new ApiResponse(true, "Lagerdaten erfolgreich abgerufen.", responseData));
	}

	@PostMapping("/transactions")
	@Operation(summary = "Perform a storage transaction", description = "Checks out or checks in a specified quantity of a storage item.")
	public ResponseEntity<ApiResponse> performTransaction(@RequestBody Map<String, Object> payload,
			@AuthenticationPrincipal SecurityUser securityUser) {
		User user = securityUser.getUser();
		try {
			int itemId = ((Number) payload.get("itemId")).intValue();
			int quantity = ((Number) payload.get("quantity")).intValue();
			String type = (String) payload.get("type");
			String notes = (String) payload.get("notes");
			Integer eventId = payload.get("eventId") != null && !payload.get("eventId").toString().isEmpty()
					? ((Number) payload.get("eventId")).intValue()
					: null;

			if (storageService.processTransaction(itemId, quantity, type, user, eventId, notes)) {
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				return ResponseEntity
						.ok(new ApiResponse(true, "Erfolgreich " + quantity + " Stück " + action + ".", null));
			} else {
				return ResponseEntity.badRequest().body(new ApiResponse(false, "Transaktion fehlgeschlagen.", null));
			}
		} catch (IllegalArgumentException | IllegalStateException e) {
			return ResponseEntity.badRequest().body(new ApiResponse(false, e.getMessage(), null));
		} catch (Exception e) {
			return ResponseEntity.internalServerError()
					.body(new ApiResponse(false, "Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage(), null));
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}

		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\GlobalExceptionHandler.java
========================================================================

package de.technikteam.config;

import de.technikteam.model.ApiResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

	private static final Logger logger = LogManager.getLogger(GlobalExceptionHandler.class);

	@ExceptionHandler(MethodArgumentNotValidException.class)
	public ResponseEntity<ApiResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
		String errors = ex.getBindingResult().getFieldErrors().stream()
				.map(error -> error.getField() + ": " + error.getDefaultMessage()).collect(Collectors.joining(", "));
		ApiResponse apiResponse = new ApiResponse(false, "Validierung fehlgeschlagen: " + errors, null);
		return new ResponseEntity<>(apiResponse, HttpStatus.BAD_REQUEST);
	}

	@ExceptionHandler(AccessDeniedException.class)
	public ResponseEntity<ApiResponse> handleAccessDeniedException(AccessDeniedException ex) {
		ApiResponse apiResponse = new ApiResponse(false,
				"Zugriff verweigert: Sie haben nicht die erforderlichen Berechtigungen für diese Aktion.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.FORBIDDEN);
	}

	@ExceptionHandler(Exception.class)
	public ResponseEntity<ApiResponse> handleAllExceptions(Exception ex) {
		logger.error("An unexpected internal server error occurred", ex);
		ApiResponse apiResponse = new ApiResponse(false,
				"Ein unerwarteter interner Serverfehler ist aufgetreten. Bitte kontaktieren Sie den Support.", null);
		return new ResponseEntity<>(apiResponse, HttpStatus.INTERNAL_SERVER_ERROR);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\InitialAdminCreator.java
========================================================================

package de.technikteam.config;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.service.UserService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

import java.security.SecureRandom;

@Component
public class InitialAdminCreator implements CommandLineRunner {

	private static final Logger logger = LogManager.getLogger(InitialAdminCreator.class);

	private final UserDAO userDAO;
	private final UserService userService;

	@Autowired
	public InitialAdminCreator(UserDAO userDAO, UserService userService) {
		this.userDAO = userDAO;
		this.userService = userService;
	}

	@Override
	public void run(String... args) throws Exception {
		if (userDAO.getUserByUsername("admin") == null) {
			logger.warn("############################################################");
			logger.warn("##              FIRST TIME SETUP DETECTED                 ##");
			logger.warn("##     Creating default 'admin' user with a random pass   ##");
			logger.warn("############################################################");

			User adminUser = new User();
			adminUser.setUsername("admin");
			adminUser.setRoleId(1); // Assuming 1 is the ADMIN role ID

			String randomPassword = generateRandomPassword(16);

			// Give admin all permissions by default
			String[] allPermissionIds = {}; // Let service handle default permissions for ADMIN role

			userService.createUserWithPermissions(adminUser, randomPassword, allPermissionIds, "SYSTEM");

			logger.warn("############################################################");
			logger.warn("##                ADMIN USER CREATED                      ##");
			logger.warn("##                                                        ##");
			logger.warn("##    Username: admin                                     ##");
			logger.warn("##    Password: " + randomPassword + "                     ##");
			logger.warn("##                                                        ##");
			logger.warn("##   !!! PLEASE COPY THIS PASSWORD AND STORE IT SAFELY.   ##");
			logger.warn("##             IT WILL NOT BE SHOWN AGAIN.                ##");
			logger.warn("############################################################");
		}
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON) and
 * deserialization (JSON to Java), preventing reflection issues with the Java
 * Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

	private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

	@Override
	public void write(JsonWriter out, LocalDateTime value) throws IOException {
		if (value == null) {
			out.nullValue();
		} else {
			out.value(value.format(FORMATTER));
		}
	}

	@Override
	public LocalDateTime read(JsonReader in) throws IOException {
		if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
			in.nextNull();
			return null;
		}
		String value = in.nextString();
		return LocalDateTime.parse(value, FORMATTER);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\OpenApiConfig.java
========================================================================

package de.technikteam.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

	@Bean
	public OpenAPI customOpenAPI() {
		final String securitySchemeName = "bearerAuth";
		return new OpenAPI()
				.info(new Info().title("TechnikTeam API").version("v1.0.0").description(
						"This is the complete REST API for the TechnikTeam Event & Crew Management System."))
				.addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
				.components(new Components().addSecuritySchemes(securitySchemeName, new SecurityScheme()
						.name(securitySchemeName).type(SecurityScheme.Type.HTTP).scheme("bearer").bearerFormat("JWT")));
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\Permissions.java
========================================================================

package de.technikteam.config;

/**
 * A central repository for all permission key constants used throughout the
 * application. This prevents the use of "magic strings" for permission checks,
 * reducing typos and making the code more maintainable and readable.
 */
public final class Permissions {

	private Permissions() {
	}

	// --- GLOBAL ---
	public static final String ACCESS_ADMIN_PANEL = "ACCESS_ADMIN_PANEL";

	// --- USER MANAGEMENT ---
	public static final String USER_CREATE = "USER_CREATE";
	public static final String USER_READ = "USER_READ";
	public static final String USER_UPDATE = "USER_UPDATE";
	public static final String USER_DELETE = "USER_DELETE";
	public static final String USER_PASSWORD_RESET = "USER_PASSWORD_RESET";

	// --- EVENT MANAGEMENT ---
	public static final String EVENT_CREATE = "EVENT_CREATE";
	public static final String EVENT_READ = "EVENT_READ";
	public static final String EVENT_UPDATE = "EVENT_UPDATE";
	public static final String EVENT_DELETE = "EVENT_DELETE";
	public static final String EVENT_MANAGE_ASSIGNMENTS = "EVENT_MANAGE_ASSIGNMENTS";
	public static final String EVENT_MANAGE_TASKS = "EVENT_MANAGE_TASKS";

	// --- COURSE & MEETING MANAGEMENT ---
	public static final String COURSE_CREATE = "COURSE_CREATE";
	public static final String COURSE_READ = "COURSE_READ";
	public static final String COURSE_UPDATE = "COURSE_UPDATE";
	public static final String COURSE_DELETE = "COURSE_DELETE";

	// --- STORAGE & INVENTORY ---
	public static final String STORAGE_CREATE = "STORAGE_CREATE";
	public static final String STORAGE_READ = "STORAGE_READ";
	public static final String STORAGE_UPDATE = "STORAGE_UPDATE";
	public static final String STORAGE_DELETE = "STORAGE_DELETE";

	// --- KIT MANAGEMENT ---
	public static final String KIT_CREATE = "KIT_CREATE";
	public static final String KIT_READ = "KIT_READ";
	public static final String KIT_UPDATE = "KIT_UPDATE";
	public static final String KIT_DELETE = "KIT_DELETE";

	// --- QUALIFICATIONS ---
	public static final String QUALIFICATION_READ = "QUALIFICATION_READ";
	public static final String QUALIFICATION_UPDATE = "QUALIFICATION_UPDATE";

	// --- FILE MANAGEMENT ---
	public static final String FILE_CREATE = "FILE_CREATE";
	public static final String FILE_READ = "FILE_READ";
	public static final String FILE_UPDATE = "FILE_UPDATE";
	public static final String FILE_DELETE = "FILE_DELETE";
	public static final String FILE_MANAGE = "FILE_MANAGE";

	// --- SYSTEM & REPORTING ---
	public static final String LOG_READ = "LOG_READ";
	public static final String REPORT_READ = "REPORT_READ";
	public static final String SYSTEM_READ = "SYSTEM_READ";

	// --- ACHIEVEMENTS ---
	public static final String ACHIEVEMENT_CREATE = "ACHIEVEMENT_CREATE";
	public static final String ACHIEVEMENT_UPDATE = "ACHIEVEMENT_UPDATE";
	public static final String ACHIEVEMENT_DELETE = "ACHIEVEMENT_DELETE";
	public static final String ACHIEVEMENT_VIEW = "ACHIEVEMENT_VIEW";

	// --- NAVIGATION-SPECIFIC ---
	public static final String ADMIN_DASHBOARD_ACCESS = "ADMIN_DASHBOARD_ACCESS";
}
========================================================================
FILE: src\main\java\de\technikteam\config\SanitizerConfig.java
========================================================================

package de.technikteam.config;

import org.owasp.html.HtmlPolicyBuilder;
import org.owasp.html.PolicyFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SanitizerConfig {

	/**
	 * A policy factory that allows common text formatting and block-level elements.
	 * Suitable for rich text content like event descriptions. Allows: <b>, <i>,
	 * <u>, <s>, <sub>, <sup>,
	 * <p>
	 * , <blockquote>,
	 * <ul>
	 * ,
	 * <ol>
	 * ,
	 * <li>, <br>
	 * ,
	 * <h1>-
	 * <h6>
	 */
	@Bean("richTextPolicy")
	public PolicyFactory richTextPolicy() {
		return new HtmlPolicyBuilder().allowCommonBlockElements() // p, div, h1-h6, etc.
				.allowCommonInlineFormattingElements() // b, i, u, etc.
				.allowElements("br", "ul", "ol", "li", "blockquote", "s", "sub", "sup").toFactory();
	}

	/**
	 * A stricter policy that only allows inline formatting, no block elements.
	 * Suitable for single-line content or chat messages where block elements are
	 * undesirable. Allows: <b>, <i>, <u>, <s>, <sub>, <sup>
	 */
	@Bean("inlineFormattingPolicy")
	public PolicyFactory inlineFormattingPolicy() {
		return new HtmlPolicyBuilder().allowCommonInlineFormattingElements().allowElements("s", "sub", "sup")
				.toFactory();
	}

	/**
	 * A policy that strips all HTML, leaving only plain text. Useful for fields
	 * that should not contain any formatting.
	 */
	@Bean("plainTextPolicy")
	public PolicyFactory plainTextPolicy() {
		return new HtmlPolicyBuilder().toFactory(); // No elements allowed
	}
}
========================================================================
FILE: src\main\java\de\technikteam\config\WebMvcConfig.java
========================================================================

package de.technikteam.config;

import de.technikteam.security.RateLimitingInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
	private final RateLimitingInterceptor rateLimitingInterceptor;

	@Autowired
	public WebMvcConfig(RateLimitingInterceptor rateLimitingInterceptor) {
		this.rateLimitingInterceptor = rateLimitingInterceptor;
	}

	@Override
	public void addInterceptors(InterceptorRegistry registry) {
		// Apply rate limiting to sensitive state-changing endpoints
		registry.addInterceptor(rateLimitingInterceptor).addPathPatterns("/api/v1/auth/login")
				.addPathPatterns("/api/v1/users/**").addPathPatterns("/api/v1/events/**")
				.addPathPatterns("/api/v1/storage/**").addPathPatterns("/api/v1/kits/**")
				.addPathPatterns("/api/v1/courses/**").addPathPatterns("/api/v1/meetings/**")
				.addPathPatterns("/api/v1/feedback/**").addPathPatterns("/api/v1/public/feedback/**")
				.addPathPatterns("/api/v1/public/profile/**");
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Achievement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AchievementDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Achievement> achievementRowMapper = (rs, rowNum) -> {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	};

	public List<Achievement> getAllAchievements() {
		String sql = "SELECT * FROM achievements ORDER BY name";
		try {
			return jdbcTemplate.query(sql, achievementRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all achievements", e);
			return List.of();
		}
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, achievementRowMapper, id);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching achievement by ID {}", id, e);
			return null;
		}
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, achievement.getAchievementKey(), achievement.getName(),
					achievement.getDescription(), achievement.getIconClass()) > 0;
		} catch (Exception e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, achievement.getName(), achievement.getDescription(),
					achievement.getIconClass(), achievement.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try {
			// First, delete dependencies in user_achievements
			jdbcTemplate.update("DELETE FROM user_achievements WHERE achievement_id = ?", id);
			return jdbcTemplate.update(sql, id) > 0;
		} catch (Exception e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		String sql = "SELECT a.*, ua.earned_at FROM achievements a JOIN user_achievements ua ON a.id = ua.achievement_id WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Achievement ach = achievementRowMapper.mapRow(rs, rowNum);
				ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
				return ach;
			}, userId);
		} catch (Exception e) {
			logger.error("Error fetching achievements for user {}", userId, e);
			return List.of();
		}
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			return false; // Already has it, not an error
		}
		String sql = "INSERT INTO user_achievements (user_id, achievement_id) SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try {
			return jdbcTemplate.update(sql, userId, achievementKey) > 0;
		} catch (Exception e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
			return false;
		}
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT COUNT(*) FROM user_achievements ua JOIN achievements a ON ua.achievement_id = a.id WHERE ua.user_id = ? AND a.achievement_key = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, userId, achievementKey);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AdminLogDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		try {
			jdbcTemplate.update(sql, log.getAdminUsername(), log.getActionType(), log.getDetails());
		} catch (Exception e) {
			logger.error("Failed to create admin log for user '{}'.", log.getAdminUsername(), e);
		}
	}

	public List<AdminLog> getAllLogs() {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			});
		} catch (Exception e) {
			logger.error("Failed to fetch admin logs from the database.", e);
			return List.of();
		}
	}

	public List<AdminLog> getRecentLogs(int limit) {
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				return logEntry;
			}, limit);
		} catch (Exception e) {
			logger.error("Failed to fetch recent admin logs from the database.", e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public AttachmentDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Attachment> attachmentRowMapper = (rs, rowNum) -> {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	};

	public boolean addAttachment(Attachment attachment) {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, attachment.getParentType(), attachment.getParentId(),
					attachment.getFilename(), attachment.getFilepath(), attachment.getRequiredRole()) > 0;
		} catch (Exception e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try {
			return jdbcTemplate.query(sql, attachmentRowMapper, parentType, parentId);
		} catch (Exception e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
			return List.of();
		}
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, attachmentRowMapper, attachmentId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
			return null;
		}
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, attachmentId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Course;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public CourseDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Course> courseRowMapper = (rs, rowNum) -> {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	};

	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription()) > 0;
		} catch (Exception e) {
			logger.error("Error creating course: {}", course.getName(), e);
			return false;
		}
	}

	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, courseRowMapper, courseId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching course by ID: {}", courseId, e);
			return null;
		}
	}

	public List<Course> getAllCourses() {
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		try {
			return jdbcTemplate.query(sql, courseRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching all courses.", e);
			return List.of();
		}
	}

	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, course.getName(), course.getAbbreviation(), course.getDescription(),
					course.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating course: {}", course.getName(), e);
			return false;
		}
	}

	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		try {
			// Manually delete related data due to foreign key constraints
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE required_course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM user_qualifications WHERE course_id = ?", courseId);
			jdbcTemplate.update("DELETE FROM meetings WHERE course_id = ?", courseId);

			return jdbcTemplate.update(sql, courseId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventChatDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<EventChatMessage> chatMessageRowMapper = (rs, rowNum) -> {
		EventChatMessage message = new EventChatMessage();
		message.setId(rs.getInt("id"));
		message.setEventId(rs.getInt("event_id"));
		message.setUserId(rs.getInt("user_id"));
		message.setUsername(rs.getString("username"));
		message.setMessageText(rs.getString("message_text"));
		message.setEdited(rs.getBoolean("edited"));
		message.setDeleted(rs.getBoolean("is_deleted"));
		message.setDeletedByUserId(rs.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(rs.getString("deleted_by_username"));
		message.setChatColor(rs.getString("chat_color"));
		if (rs.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(rs.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(rs.getTimestamp("sent_at").toLocalDateTime());
		return message;
	};

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, message.getEventId());
				ps.setInt(2, message.getUserId());
				ps.setString(3, message.getUsername());
				ps.setString(4, message.getMessageText());
				return ps;
			}, keyHolder);

			int newId = Objects.requireNonNull(keyHolder.getKey()).intValue();
			return getMessageById(newId);
		} catch (Exception e) {
			logger.error("Error posting chat message for event {}", message.getEventId(), e);
			return null;
		}
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try {
			return jdbcTemplate.query(sql, chatMessageRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching chat messages for event {}", eventId, e);
			return List.of();
		}
	}

	public EventChatMessage getMessageById(int messageId) {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color FROM event_chat_messages m LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id JOIN users u_orig ON m.user_id = u_orig.id WHERE m.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, chatMessageRowMapper, messageId);
		} catch (Exception e) {
			logger.error("Error fetching message by ID {}", messageId, e);
			return null;
		}
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE WHERE id = ? AND user_id = ? AND is_deleted = FALSE";
		try {
			return jdbcTemplate.update(sql, newText, messageId, userId) > 0;
		} catch (Exception e) {
			logger.error("Error updating message ID {}", messageId, e);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql = isAdmin
				? "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ?"
				: "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ?, deleted_at = NOW() WHERE id = ? AND user_id = ?";
		try {
			if (isAdmin) {
				return jdbcTemplate.update(sql, deletersUserId, messageId) > 0;
			} else {
				return jdbcTemplate.update(sql, deletersUserId, messageId, deletersUserId) > 0;
			}
		} catch (Exception e) {
			logger.error("Error soft-deleting message ID {}:", messageId, e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Repository
public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventCustomFieldDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields) {
		try {
			jdbcTemplate.update("DELETE FROM event_custom_fields WHERE event_id = ?", eventId);

			if (fields != null && !fields.isEmpty()) {
				String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
				jdbcTemplate.batchUpdate(insertSql, fields, 100, (ps, field) -> {
					ps.setInt(1, eventId);
					ps.setString(2, field.getFieldName());
					ps.setString(3, field.getFieldType());
					ps.setBoolean(4, field.isRequired());
					ps.setString(5, field.getFieldOptions());
				});
			}
		} catch (Exception e) {
			logger.error("Error in transaction for saving custom fields for event {}", eventId, e);
			// Transactional annotation will handle rollback
			throw new RuntimeException(e);
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				EventCustomField field = new EventCustomField();
				field.setId(rs.getInt("id"));
				field.setEventId(rs.getInt("event_id"));
				field.setFieldName(rs.getString("field_name"));
				field.setFieldType(rs.getString("field_type"));
				field.setRequired(rs.getBoolean("is_required"));
				field.setFieldOptions(rs.getString("field_options"));
				return field;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
			return List.of();
		}
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try {
			jdbcTemplate.update(sql, response.getFieldId(), response.getUserId(), response.getResponseValue());
		} catch (Exception e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Event;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.*;
import java.util.List;
import java.util.Objects;

@Repository
public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<Event> eventRowMapper = (rs, rowNum) -> {
		Event event = new Event();
		event.setId(rs.getInt("id"));
		event.setName(rs.getString("name"));
		event.setDescription(rs.getString("description"));
		event.setLocation(rs.getString("location"));
		event.setStatus(rs.getString("status"));
		event.setEventDateTime(rs.getTimestamp("event_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			event.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(rs, "leader_user_id")) {
			event.setLeaderUserId(rs.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(rs, "leader_username")) {
			event.setLeaderUsername(rs.getString("leader_username"));
		}
		return event;
	};

	private final RowMapper<User> simpleUserRowMapper = (rs, rowNum) -> new User(rs.getInt("id"),
			rs.getString("username"), rs.getString("role"));

	public List<Event> getUpcomingEventsForUser(User user) {
		String sql = "SELECT e.*, u_leader.username AS leader_username, " + "COALESCE("
				+ "    (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), "
				+ "    (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), "
				+ "    'OFFEN'" + ") AS user_attendance_status, " + "(" + "    SELECT COUNT(*) = 0 "
				+ "    FROM event_skill_requirements esr " + "    WHERE esr.event_id = e.id " + "    AND NOT EXISTS ("
				+ "        SELECT 1 FROM user_qualifications uq "
				+ "        WHERE uq.user_id = ? AND uq.course_id = esr.required_course_id AND uq.status = 'BESTANDEN'"
				+ "    )" + ") AS is_user_qualified " + "FROM events e "
				+ "LEFT JOIN users u_leader ON e.leader_user_id = u_leader.id "
				+ "WHERE e.status IN ('GEPLANT', 'LAUFEND') AND e.event_datetime >= NOW() - INTERVAL 1 DAY "
				+ "ORDER BY e.event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_attendance_status"));
				event.setUserQualified(rs.getBoolean("is_user_qualified"));
				return event;
			}, user.getId(), user.getId(), user.getId());
		} catch (Exception e) {
			logger.error("Error fetching upcoming events for user {}: {}", user.getUsername(), e.getMessage());
			return List.of();
		}
	}

	public List<Event> getEventHistoryForUser(int userId) {
		String sql = "SELECT e.*, COALESCE( (SELECT 'ZUGEWIESEN' FROM event_assignments WHERE event_id = e.id AND user_id = ?), (SELECT signup_status FROM event_attendance WHERE event_id = e.id AND user_id = ?), 'OFFEN' ) AS user_status FROM events e WHERE EXISTS ( SELECT 1 FROM event_attendance WHERE event_id = e.id AND user_id = ? UNION SELECT 1 FROM event_assignments WHERE event_id = e.id AND user_id = ? ) ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				Event event = eventRowMapper.mapRow(rs, rowNum);
				event.setUserAttendanceStatus(rs.getString("user_status"));
				return event;
			}, userId, userId, userId, userId);
		} catch (Exception e) {
			logger.error("Error fetching event history for user {}", userId, e);
			return List.of();
		}
	}

	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id WHERE e.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, eventRowMapper, eventId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching event by ID: {}", eventId, e);
			return null;
		}
	}

	public List<Event> getAllEvents() {
		String sql = "SELECT e.*, u.username as leader_username FROM events e LEFT JOIN users u ON e.leader_user_id = u.id ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all events.", e);
			return List.of();
		}
	}

	public List<Event> getActiveEvents() {
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active events.", e);
			return List.of();
		}
	}

	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, 'GEPLANT', ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, event.getName());
				ps.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
				if (event.getEndDateTime() != null)
					ps.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
				else
					ps.setNull(3, Types.TIMESTAMP);
				ps.setString(4, event.getDescription());
				ps.setString(5, event.getLocation());
				if (event.getLeaderUserId() > 0)
					ps.setInt(6, event.getLeaderUserId());
				else
					ps.setNull(6, Types.INTEGER);
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating event {}", event.getName(), e);
			return 0;
		}
	}

	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, event.getName(), Timestamp.valueOf(event.getEventDateTime()),
					event.getEndDateTime() != null ? Timestamp.valueOf(event.getEndDateTime()) : null,
					event.getDescription(), event.getLocation(), event.getStatus(),
					event.getLeaderUserId() > 0 ? event.getLeaderUserId() : null, event.getId()) > 0;
		} catch (Exception e) {
			logger.error("Error updating event {}", event.getName(), e);
			return false;
		}
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, eventId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting event with ID: {}", eventId, e);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-up for user {} and event {}", userId, eventId, e);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		try {
			jdbcTemplate.update(sql, userId, eventId);
		} catch (Exception e) {
			logger.error("Error during event sign-off for user {} and event {}", userId, eventId, e);
		}
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		try {
			jdbcTemplate.update("DELETE FROM event_assignments WHERE event_id = ?", eventId);
			if (userIds != null && userIds.length > 0) {
				String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
				jdbcTemplate.batchUpdate(insertSql, List.of(userIds), 100, (ps, userId) -> {
					ps.setInt(1, eventId);
					ps.setInt(2, Integer.parseInt(userId));
				});
			}
		} catch (Exception e) {
			logger.error("Error during user assignment for event ID: {}.", eventId, e);
		}
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				SkillRequirement req = new SkillRequirement();
				req.setRequiredCourseId(rs.getInt("required_course_id"));
				req.setCourseName(rs.getString("course_name"));
				req.setRequiredPersons(rs.getInt("required_persons"));
				return req;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching skill requirements for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		try {
			jdbcTemplate.update("DELETE FROM event_skill_requirements WHERE event_id = ?", eventId);
			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				String sql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(requiredCourseIds), 100, (ps, courseId) -> {
					// This is a bit clumsy but necessary to align arrays
					int index = List.of(requiredCourseIds).indexOf(courseId);
					if (!courseId.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(courseId));
						ps.setInt(3, Integer.parseInt(requiredPersons[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving skill requirements for event ID: {}.", eventId, e);
		}
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		try {
			jdbcTemplate.update("DELETE FROM event_storage_reservations WHERE event_id = ?", eventId);
			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				String sql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";
				jdbcTemplate.batchUpdate(sql, List.of(itemIds), 100, (ps, itemId) -> {
					int index = List.of(itemIds).indexOf(itemId);
					if (!itemId.isEmpty()) {
						ps.setInt(1, eventId);
						ps.setInt(2, Integer.parseInt(itemId));
						ps.setInt(3, Integer.parseInt(quantities[index]));
					}
				});
			}
		} catch (Exception e) {
			logger.error("Error saving reservations for event ID: {}.", eventId, e);
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				StorageItem item = new StorageItem();
				item.setId(rs.getInt("id"));
				item.setName(rs.getString("name"));
				item.setQuantity(rs.getInt("reserved_quantity"));
				return item;
			}, eventId);
		} catch (Exception e) {
			logger.error("Error fetching reserved items for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		String sql = "SELECT * FROM events WHERE status NOT IN ('ABGESCHLOSSEN', 'ABGESAGT') AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching active/upcoming events for calendar.", e);
			return List.of();
		}
	}

	public boolean isUserAssociatedWithEvent(int eventId, int userId) {
		String sql = "SELECT COUNT(*) FROM (SELECT 1 FROM event_attendance WHERE event_id = ? AND user_id = ? AND signup_status = 'ANGEMELDET' UNION ALL SELECT 1 FROM event_assignments WHERE event_id = ? AND user_id = ?) AS combined";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, eventId, userId, eventId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user association for event {} and user {}", eventId, userId, e);
			return false;
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u JOIN event_assignments ea ON u.id = ea.user_id LEFT JOIN roles r ON u.role_id = r.id WHERE ea.event_id = ?";
		try {
			return jdbcTemplate.query(sql, simpleUserRowMapper, eventId);
		} catch (Exception e) {
			logger.error("Error fetching assigned users for event ID: {}", eventId, e);
			return List.of();
		}
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' ORDER BY e.event_datetime DESC";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching completed event history for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		String sql = "SELECT e.* FROM events e JOIN event_assignments ea ON e.id = ea.event_id WHERE ea.user_id = ? AND e.event_datetime >= NOW() ORDER BY e.event_datetime ASC";
		if (limit > 0) {
			sql += " LIMIT ?";
		}
		try {
			if (limit > 0) {
				return jdbcTemplate.query(sql, eventRowMapper, userId, limit);
			} else {
				return jdbcTemplate.query(sql, eventRowMapper, userId);
			}
		} catch (Exception e) {
			logger.error("Error fetching assigned events for user {}", userId, e);
			return List.of();
		}
	}

	public List<Event> getUpcomingEvents(int limit) {
		String sql = "SELECT * FROM events WHERE event_datetime > NOW() ORDER BY event_datetime ASC LIMIT ?";
		try {
			return jdbcTemplate.query(sql, eventRowMapper, limit);
		} catch (Exception e) {
			logger.error("Error fetching upcoming events with limit {}", limit, e);
			return List.of();
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventFeedbackDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.util.List;
import java.util.Objects;

@Repository
public class EventFeedbackDAO {
	private static final Logger logger = LogManager.getLogger(EventFeedbackDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventFeedbackDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setInt(1, form.getEventId());
				ps.setString(2, form.getTitle());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
			return 0;
		}
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try {
			return jdbcTemplate.update(sql, response.getFormId(), response.getUserId(), response.getRating(),
					response.getComments()) > 0;
		} catch (Exception e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
			return false;
		}
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, eventId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
			return null;
		}
	}

	public FeedbackForm getFormById(int formId) {
		String sql = "SELECT * FROM feedback_forms WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
				FeedbackForm form = new FeedbackForm();
				form.setId(rs.getInt("id"));
				form.setEventId(rs.getInt("event_id"));
				form.setTitle(rs.getString("title"));
				form.setCreatedAt(rs.getTimestamp("created_at").toLocalDateTime());
				return form;
			}, formId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback form for form ID {}", formId, e);
			return null;
		}
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FeedbackResponse response = new FeedbackResponse();
				response.setId(rs.getInt("id"));
				response.setFormId(rs.getInt("form_id"));
				response.setUserId(rs.getInt("user_id"));
				response.setUsername(rs.getString("username"));
				response.setRating(rs.getInt("rating"));
				response.setComments(rs.getString("comments"));
				response.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
				return response;
			}, formId);
		} catch (Exception e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
			return List.of();
		}
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT COUNT(*) FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try {
			Integer count = jdbcTemplate.queryForObject(sql, Integer.class, formId, userId);
			return count != null && count > 0;
		} catch (Exception e) {
			logger.error("Error checking user feedback submission status.", e);
			return false;
		}
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.stream.Collectors;

@Repository
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public EventTaskDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	@Transactional
	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds) {
		boolean isUpdate = task.getId() > 0;
		if (isUpdate) {
			updateTask(task);
		} else {
			int newId = createTask(task);
			task.setId(newId);
		}

		if (task.getId() == 0) {
			throw new RuntimeException("Failed to create or find task ID.");
		}

		clearAssociations(task.getId());
		saveUserAssignments(task.getId(), userIds);
		saveItemRequirements(task.getId(), itemIds, itemQuantities);
		saveKitRequirements(task.getId(), kitIds);

		logger.info("Successfully saved task ID {}", task.getId());
		return task.getId();
	}

	private int createTask(EventTask task) {
		String taskSql = "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		jdbcTemplate.update(connection -> {
			PreparedStatement ps = connection.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS);
			ps.setInt(1, task.getEventId());
			ps.setString(2, task.getDescription());
			ps.setString(3, task.getDetails());
			ps.setInt(4, task.getDisplayOrder());
			ps.setInt(5, task.getRequiredPersons());
			return ps;
		}, keyHolder);
		return Objects.requireNonNull(keyHolder.getKey()).intValue();
	}

	private void updateTask(EventTask task) {
		String taskSql = "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?";
		jdbcTemplate.update(taskSql, task.getDescription(), task.getDetails(), task.getStatus(), task.getDisplayOrder(),
				task.getRequiredPersons(), task.getId());
	}

	private void clearAssociations(int taskId) {
		jdbcTemplate.update("DELETE FROM event_task_assignments WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_storage_items WHERE task_id = ?", taskId);
		jdbcTemplate.update("DELETE FROM event_task_kits WHERE task_id = ?", taskId);
	}

	private void saveUserAssignments(int taskId, int[] userIds) {
		if (userIds == null || userIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		List<Integer> userIdList = Arrays.stream(userIds).boxed().collect(Collectors.toList());
		jdbcTemplate.batchUpdate(sql, userIdList, 100, (ps, userId) -> {
			ps.setInt(1, taskId);
			ps.setInt(2, userId);
		});
	}

	private void saveItemRequirements(int taskId, String[] itemIds, String[] itemQuantities) {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;
		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		List<String> itemIdList = List.of(itemIds);
		jdbcTemplate.batchUpdate(sql, itemIdList, 100, (ps, itemIdStr) -> {
			if (itemIdStr != null && !itemIdStr.isEmpty()) {
				int index = itemIdList.indexOf(itemIdStr);
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(itemIdStr));
				ps.setInt(3, Integer.parseInt(itemQuantities[index]));
			}
		});
	}

	private void saveKitRequirements(int taskId, String[] kitIds) {
		if (kitIds == null || kitIds.length == 0)
			return;
		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		List<String> kitIdList = List.of(kitIds);
		jdbcTemplate.batchUpdate(sql, kitIdList, 100, (ps, kitIdStr) -> {
			if (kitIdStr != null && !kitIdStr.isEmpty()) {
				ps.setInt(1, taskId);
				ps.setInt(2, Integer.parseInt(kitIdStr));
			}
		});
	}

	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, u.id as user_id, u.username, si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, ik.id as kit_id, ik.name as kit_name FROM event_tasks t LEFT JOIN event_task_assignments ta ON t.id = ta.task_id LEFT JOIN users u ON ta.user_id = u.id LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id LEFT JOIN storage_items si ON tsi.item_id = si.id LEFT JOIN event_task_kits tk ON t.id = tk.task_id LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id WHERE t.event_id = ? ORDER BY t.display_order ASC, t.id ASC, u.username, si.name, ik.name";

		jdbcTemplate.query(sql, (ResultSet rs) -> {
			int currentTaskId = rs.getInt("id");
			EventTask task = tasksById.computeIfAbsent(currentTaskId, id -> mapResultSetToTask(rs));

			int currentUserId = rs.getInt("user_id");
			if (currentUserId > 0 && task.getAssignedUsers().stream().noneMatch(u -> u.getId() == currentUserId)) {
				User user = new User();
				user.setId(currentUserId);
				user.setUsername(rs.getString("username"));
				task.getAssignedUsers().add(user);
			}
			int currentItemId = rs.getInt("item_id");
			if (currentItemId > 0 && task.getRequiredItems().stream().noneMatch(i -> i.getId() == currentItemId)) {
				StorageItem item = new StorageItem();
				item.setId(currentItemId);
				item.setName(rs.getString("item_name"));
				item.setQuantity(rs.getInt("item_quantity"));
				task.getRequiredItems().add(item);
			}
			int currentKitId = rs.getInt("kit_id");
			if (currentKitId > 0 && task.getRequiredKits().stream().noneMatch(k -> k.getId() == currentKitId)) {
				InventoryKit kit = new InventoryKit();
				kit.setId(currentKitId);
				kit.setName(rs.getString("kit_name"));
				task.getRequiredKits().add(kit);
			}
		}, eventId);

		return new ArrayList<>(tasksById.values());
	}

	private EventTask mapResultSetToTask(ResultSet rs) {
		try {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setDetails(rs.getString("details"));
			task.setStatus(rs.getString("status"));
			task.setDisplayOrder(rs.getInt("display_order"));
			task.setRequiredPersons(rs.getInt("required_persons"));
			task.setAssignedUsers(new ArrayList<>());
			task.setRequiredItems(new ArrayList<>());
			task.setRequiredKits(new ArrayList<>());
			return task;
		} catch (SQLException e) {
			throw new RuntimeException("Failed to map ResultSet to EventTask", e);
		}
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		return jdbcTemplate.update(sql, taskId) > 0;
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		return jdbcTemplate.update(sql, status, taskId) > 0;
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		String sql = "SELECT t.*, e.name as event_name FROM event_tasks t JOIN event_task_assignments ta ON t.id = ta.task_id JOIN events e ON t.event_id = e.id WHERE ta.user_id = ? AND t.status = 'OFFEN' ORDER BY e.event_datetime ASC";
		return jdbcTemplate.query(sql, (rs, rowNum) -> {
			EventTask task = new EventTask();
			task.setId(rs.getInt("id"));
			task.setEventId(rs.getInt("event_id"));
			task.setDescription(rs.getString("description"));
			task.setStatus(rs.getString("status"));
			task.setEventName(rs.getString("event_name"));
			return task;
		}, userId);
	}
}
========================================================================
FILE: src\main\java\de\technikteam\dao\FeedbackSubmissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackSubmission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public class FeedbackSubmissionDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackSubmissionDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FeedbackSubmissionDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<FeedbackSubmission> submissionRowMapper = (rs, rowNum) -> {
		FeedbackSubmission sub = new FeedbackSubmission();
		sub.setId(rs.getInt("id"));
		sub.setUserId(rs.getInt("user_id"));
		sub.setUsername(rs.getString("username"));
		sub.setSubject(rs.getString("subject"));
		sub.setDisplayTitle(rs.getString("display_title"));
		sub.setContent(rs.getString("content"));
		sub.setSubmittedAt(rs.getTimestamp("submitted_at").toLocalDateTime());
		sub.setStatus(rs.getString("status"));
		sub.setDisplayOrder(rs.getInt("display_order"));
		return sub;
	};

	public boolean createSubmission(FeedbackSubmission submission) {
		String sql = "INSERT INTO feedback_submissions (user_id, subject, content) VALUES (?, ?, ?)";
		try {
			return jdbcTemplate.update(sql, submission.getUserId(), submission.getSubject(),
					submission.getContent()) > 0;
		} catch (Exception e) {
			logger.error("Error creating feedback submission for user {}", submission.getUserId(), e);
			return false;
		}
	}

	public List<FeedbackSubmission> getAllSubmissions() {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id ORDER BY FIELD(fs.status, 'NEW', 'VIEWED', 'PLANNED', 'REJECTED', 'COMPLETED'), fs.display_order ASC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper);
		} catch (Exception e) {
			logger.error("Error fetching all feedback submissions", e);
			return List.of();
		}
	}

	public FeedbackSubmission getSubmissionById(int submissionId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, submissionRowMapper, submissionId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching feedback submission by ID {}", submissionId, e);
			return null;
		}
	}

	public List<FeedbackSubmission> getSubmissionsByUserId(int userId) {
		String sql = "SELECT fs.*, u.username FROM feedback_submissions fs JOIN users u ON fs.user_id = u.id WHERE fs.user_id = ? ORDER BY fs.submitted_at DESC";
		try {
			return jdbcTemplate.query(sql, submissionRowMapper, userId);
		} catch (Exception e) {
			logger.error("Error fetching feedback submissions for user {}", userId, e);
			return List.of();
		}
	}

	public boolean updateStatusAndTitle(int submissionId, String newStatus, String displayTitle) {
		String sql = "UPDATE feedback_submissions SET status = ?, display_title = ? WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, newStatus, displayTitle, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error updating status and title for submission {}", submissionId, e);
			return false;
		}
	}

	public boolean deleteSubmission(int submissionId) {
		String sql = "DELETE FROM feedback_submissions WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, submissionId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting submission {}", submissionId, e);
			return false;
		}
	}

}
========================================================================
FILE: src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.stereotype.Repository;

import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.Types;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

@Repository
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);
	private final JdbcTemplate jdbcTemplate;

	@Autowired
	public FileDAO(JdbcTemplate jdbcTemplate) {
		this.jdbcTemplate = jdbcTemplate;
	}

	private final RowMapper<File> fileRowMapper = (rs, rowNum) -> {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));
		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}
		if (DaoUtils.hasColumn(rs, "category_name")) {
			file.setCategoryName(
					rs.getString("category_name") == null ? "Ohne Kategorie" : rs.getString("category_name"));
		} else {
			file.setCategoryName("Ohne Kategorie");
		}
		return file;
	};

	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		List<File> files = getAllFiles(user);
		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	public List<File> getAllFiles(User user) {
		StringBuilder sql = new StringBuilder(
				"SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id ");
		if (!user.hasAdminAccess()) {
			sql.append("WHERE f.required_role = 'NUTZER' ");
		}
		sql.append("ORDER BY fc.name, f.filename");

		try {
			return jdbcTemplate.query(sql.toString(), fileRowMapper);
		} catch (Exception e) {
			logger.error("Error while fetching files.", e);
			return List.of();
		}
	}

	public int createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			jdbcTemplate.update(connection -> {
				PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
				ps.setString(1, file.getFilename());
				ps.setString(2, file.getFilepath());
				if (file.getCategoryId() > 0) {
					ps.setInt(3, file.getCategoryId());
				} else {
					ps.setNull(3, Types.INTEGER);
				}
				ps.setString(4, file.getRequiredRole());
				return ps;
			}, keyHolder);
			return Objects.requireNonNull(keyHolder.getKey()).intValue();
		} catch (Exception e) {
			logger.error("Error creating file record for '{}'", file.getFilename(), e);
			return 0;
		}
	}

	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	public boolean reassignFileToCategory(int fileId, int categoryId) {
		String sql = "UPDATE files SET category_id = ? WHERE id = ?";
		try {
			Object newCategoryId = categoryId > 0 ? categoryId : null;
			return jdbcTemplate.update(sql, newCategoryId, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error reassigning file {} to category {}", fileId, categoryId, e);
			return false;
		}
	}

	public List<FileCategory> getAllCategories() {
		String sql = "SELECT * FROM file_categories ORDER BY name";
		try {
			return jdbcTemplate.query(sql, (rs, rowNum) -> {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				return cat;
			});
		} catch (Exception e) {
			logger.error("Error fetching file categories.", e);
			return List.of();
		}
	}

	public File getFileById(int fileId) {
		String sql = "SELECT f.*, fc.name as category_name FROM files f LEFT JOIN file_categories fc ON f.category_id = fc.id WHERE f.id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, fileRowMapper, fileId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error while fetching file with ID: {}", fileId, e);
			return null;
		}
	}

	public boolean deleteFile(int fileId) {
		String sql = "DELETE FROM files WHERE id = ?";
		try {
			return jdbcTemplate.update(sql, fileId) > 0;
		} catch (Exception e) {
			logger.error("Error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	public boolean createCategory(String categoryName) {
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try {
			return jdbcTemplate.update(sql, categoryName) > 0;
		} catch (Exception e) {
			logger.error("Error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	public boolean deleteCategory(int categoryId) {
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try {
			// First, un-assign files from this category
			jdbcTemplate.update("UPDATE files SET category_id = NULL WHERE category_id = ?", categoryId);
			return jdbcTemplate.update(sql, categoryId) > 0;
		} catch (Exception e) {
			logger.error("Error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		try {
			return jdbcTemplate.queryForObject(sql, String.class, categoryId);
		} catch (EmptyResultDataAccessException e) {
			return null;
		} catch (Exception e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
			return null;
		}
	}
}