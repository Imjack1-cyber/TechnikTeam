
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\AppConfig.java
========================================================================

package de.technikteam.config;

/**
 * A simple configuration class that holds a single, application-wide constant:
 * the absolute file path for the directory where all user-uploaded files are
 * stored. This centralized approach makes it easy to change the upload location
 * without modifying multiple files.
 */
public class AppConfig {
	public static final String UPLOAD_DIRECTORY = "C:\\dev\\eclipse\\workspace\\TechnikTeam\\resources\\uploads";

	// URL to the Collabora Online server. Must be accessible by the user's browser.
	// Replace with your actual Collabora server address.
	public static final String COLLABORA_SERVER_URL = "http://localhost:9980";
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}
		
		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * A custom serializer for the Gson library. It converts java.time.LocalDate
 * objects into the standard YYYY-MM-DD string format, which is ideal for JSON
 * data exchange and compatibility with HTML date input fields.
 */
public class LocalDateAdapter implements JsonSerializer<LocalDate> {

	@Override
	public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context) {
		return date == null ? null : new JsonPrimitive(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON)
 * and deserialization (JSON to Java), preventing reflection issues with
 * the Java Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        if (value == null) {
            out.nullValue();
        } else {
            out.value(value.format(FORMATTER));
        }
    }

    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
            in.nextNull();
            return null;
        }
        String value = in.nextString();
        return LocalDateTime.parse(value, FORMATTER);
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AchievementDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Achievement;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class AchievementDAO {
	private static final Logger logger = LogManager.getLogger(AchievementDAO.class);

	public List<Achievement> getAllAchievements() {
		List<Achievement> achievements = new ArrayList<>();
		String sql = "SELECT * FROM achievements ORDER BY name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				achievements.add(mapResultSetToAchievement(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching all achievements", e);
		}
		return achievements;
	}

	public Achievement getAchievementById(int id) {
		String sql = "SELECT * FROM achievements WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, id);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToAchievement(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching achievement by ID {}", id, e);
		}
		return null;
	}

	public boolean createAchievement(Achievement achievement) {
		String sql = "INSERT INTO achievements (achievement_key, name, description, icon_class) VALUES (?, ?, ?, ?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, achievement.getAchievementKey());
			pstmt.setString(2, achievement.getName());
			pstmt.setString(3, achievement.getDescription());
			pstmt.setString(4, achievement.getIconClass());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating achievement '{}'", achievement.getName(), e);
			return false;
		}
	}

	public boolean updateAchievement(Achievement achievement) {
		// Note: achievement_key is intentionally not updated as it's a programmatic
		// identifier.
		String sql = "UPDATE achievements SET name = ?, description = ?, icon_class = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, achievement.getName());
			pstmt.setString(2, achievement.getDescription());
			pstmt.setString(3, achievement.getIconClass());
			pstmt.setInt(4, achievement.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating achievement ID {}", achievement.getId(), e);
			return false;
		}
	}

	public boolean deleteAchievement(int id) {
		String sql = "DELETE FROM achievements WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, id);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting achievement ID {}", id, e);
			return false;
		}
	}

	public List<Achievement> getAchievementsForUser(int userId) {
		List<Achievement> achievements = new ArrayList<>();
		String sql = "SELECT a.id, a.achievement_key, a.name, a.description, a.icon_class, ua.earned_at "
				+ "FROM achievements a " + "JOIN user_achievements ua ON a.id = ua.achievement_id "
				+ "WHERE ua.user_id = ? ORDER BY ua.earned_at DESC";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Achievement ach = mapResultSetToAchievement(rs);
					ach.setEarnedAt(rs.getTimestamp("earned_at").toLocalDateTime());
					achievements.add(ach);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching achievements for user {}", userId, e);
		}
		return achievements;
	}

	public boolean grantAchievementToUser(int userId, String achievementKey) {
		if (hasAchievement(userId, achievementKey)) {
			logger.debug("User {} already has achievement '{}'. Skipping grant.", userId, achievementKey);
			return false;
		}

		String sql = "INSERT INTO user_achievements (user_id, achievement_id) "
				+ "SELECT ?, id FROM achievements WHERE achievement_key = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setString(2, achievementKey);
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Achievement '{}' granted to user {}", achievementKey, userId);
				return true;
			}
		} catch (SQLException e) {
			logger.error("Error granting achievement '{}' to user {}", achievementKey, userId, e);
		}
		return false;
	}

	public boolean hasAchievement(int userId, String achievementKey) {
		String sql = "SELECT 1 FROM user_achievements ua " + "JOIN achievements a ON ua.achievement_id = a.id "
				+ "WHERE ua.user_id = ? AND a.achievement_key = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			pstmt.setString(2, achievementKey);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking for achievement '{}' for user {}", achievementKey, userId, e);
		}
		return false;
	}

	private Achievement mapResultSetToAchievement(ResultSet rs) throws SQLException {
		Achievement ach = new Achievement();
		ach.setId(rs.getInt("id"));
		ach.setAchievementKey(rs.getString("achievement_key"));
		ach.setName(rs.getString("name"));
		ach.setDescription(rs.getString("description"));
		ach.setIconClass(rs.getString("icon_class"));
		return ach;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A Data Access Object (DAO) responsible for all database interactions with the
 * `admin_logs` table. It provides methods to create new log entries, which are
 * used for auditing administrative actions, and to retrieve all existing logs
 * for display in the admin panel.
 */
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);

	/**
	 * Creates a new log entry in the database. This is the primary method for
	 * recording an administrative action.
	 * 
	 * @param log The AdminLog object to persist.
	 */
	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		logger.debug("Attempting to create admin log: [User: {}, Action: {}]", log.getAdminUsername(),
				log.getActionType());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, log.getAdminUsername());
			pstmt.setString(2, log.getActionType());
			pstmt.setString(3, log.getDetails());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created admin log for user '{}'.", log.getAdminUsername());
			}
		} catch (SQLException e) {
			logger.error("Failed to create admin log for user '{}'. Details: {}", log.getAdminUsername(),
					log.getDetails(), e);
		}
	}

	/**
	 * Fetches all log entries from the database, ordered with the newest first.
	 * 
	 * @return A list of AdminLog objects.
	 */
	public List<AdminLog> getAllLogs() {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		logger.debug("Executing query to fetch all admin logs.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				logs.add(logEntry);
			}
			logger.info("Fetched {} admin log entries from the database.", logs.size());
		} catch (SQLException e) {
			logger.error("Failed to fetch admin logs from the database.", e);
		}
		return logs;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Attachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * A unified DAO for managing file attachments for various parent entities
 * (e.g., Events, Meetings), interacting with the generic `attachments` table.
 */
public class AttachmentDAO {
	private static final Logger logger = LogManager.getLogger(AttachmentDAO.class);

	private Attachment mapResultSetToAttachment(ResultSet rs) throws SQLException {
		Attachment att = new Attachment();
		att.setId(rs.getInt("id"));
		att.setParentType(rs.getString("parent_type"));
		att.setParentId(rs.getInt("parent_id"));
		att.setFilename(rs.getString("filename"));
		att.setFilepath(rs.getString("filepath"));
		att.setRequiredRole(rs.getString("required_role"));
		att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		return att;
	}

	public boolean addAttachment(Attachment attachment) {
		String sql = "INSERT INTO attachments (parent_type, parent_id, filename, filepath, required_role) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to {} ID {}", attachment.getFilename(), attachment.getParentType(),
				attachment.getParentId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, attachment.getParentType());
			pstmt.setInt(2, attachment.getParentId());
			pstmt.setString(3, attachment.getFilename());
			pstmt.setString(4, attachment.getFilepath());
			pstmt.setString(5, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to {} ID {}", attachment.getParentType(), attachment.getParentId(),
					e);
			return false;
		}
	}

	public List<Attachment> getAttachmentsForParent(String parentType, int parentId, String userRole) {
		List<Attachment> attachments = new ArrayList<>();
		String sql = "SELECT * FROM attachments WHERE parent_type = ? AND parent_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, parentType);
			pstmt.setInt(2, parentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					attachments.add(mapResultSetToAttachment(rs));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for {} ID {}", parentType, parentId, e);
		}
		return attachments;
	}

	public Attachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToAttachment(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		return null;
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Course;

/**
 * Data Access Object for managing `Course` templates in the `courses` table.
 * This DAO handles CRUD operations for the parent course definitions (e.g.,
 * "Grundlehrgang Tontechnik"), which serve as blueprints for individual,
 * schedulable `Meeting` instances.
 */
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);

	/**
	 * Creates a new parent course template in the database.
	 * 
	 * @param course The Course object to create (containing name, abbreviation, and
	 *               description).
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		logger.debug("Attempting to create parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error creating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Fetches a single parent course by its ID.
	 * 
	 * @param courseId The ID of the course.
	 * @return A Course object, or null if not found.
	 */
	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		logger.debug("Attempting to fetch course by ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found course with ID: {}", courseId);
					return mapResultSetToCourse(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching course by ID: {}", courseId, e);
		}
		logger.warn("No course found with ID: {}", courseId);
		return null;
	}

	/**
	 * Fetches all parent courses from the database, sorted alphabetically by name.
	 * 
	 * @return A list of all Course objects.
	 */
	public List<Course> getAllCourses() {
		List<Course> courses = new ArrayList<>();
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		logger.debug("Attempting to fetch all parent courses.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				courses.add(mapResultSetToCourse(rs));
			}
			logger.info("Fetched {} total parent courses.", courses.size());
		} catch (SQLException e) {
			logger.error("SQL error while fetching all courses.", e);
		}
		return courses;
	}

	/**
	 * Helper method to map a ResultSet row to a Course object.
	 * 
	 * @param rs The ResultSet to map from.
	 * @return A populated Course object.
	 * @throws SQLException If a database access error occurs.
	 */
	private Course mapResultSetToCourse(ResultSet rs) throws SQLException {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	}

	/**
	 * Updates an existing parent course's name, abbreviation, and description.
	 * 
	 * @param course The Course object with the updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		logger.debug("Attempting to update parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			pstmt.setInt(4, course.getId());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully updated parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error updating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Deletes a parent course from the database. NOTE: This relies on `ON DELETE
	 * CASCADE` in the database schema to also delete all associated meetings and
	 * qualifications.
	 * 
	 * @param courseId The ID of the course to delete.
	 * @return true if the deletion was successful, false otherwise.
	 */
	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		logger.debug("Attempting to delete parent course with ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.warn("Successfully deleted parent course with ID: {}", courseId);
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\DatabaseManager.java
========================================================================

package de.technikteam.dao;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.io.InputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class DatabaseManager {

	private static final Logger logger = LogManager.getLogger(DatabaseManager.class);
	private static HikariDataSource dataSource;

	private static Properties loadDbProperties() {
		Properties props = new Properties();
		try (InputStream input = DatabaseManager.class.getClassLoader().getResourceAsStream("db.properties")) {
			if (input == null) {
				logger.warn("db.properties file not found on classpath. Cannot use file-based credentials.");
				return null;
			}
			props.load(input);
			return props;
		} catch (Exception ex) {
			logger.error("Error loading db.properties file.", ex);
			return null;
		}
	}

	public static void initDataSource() {
		if (dataSource != null) {
			logger.warn("Database connection pool already initialized.");
			return;
		}

		try {
			logger.info("Initializing database connection pool...");

			HikariConfig hikariConfiguration = new HikariConfig();
			hikariConfiguration.setJdbcUrl(
					"jdbc:mysql://localhost:3306/technik_team_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false&useLegacyDatetimeCode=false");

			String dbUser = System.getenv("DB_USER");
			String dbPassword = System.getenv("DB_PASSWORD");

			if (dbUser == null || dbUser.isEmpty()) {
				logger.info("DB_USER environment variable not found. Attempting to load from db.properties...");
				Properties props = loadDbProperties();
				if (props != null) {
					dbUser = props.getProperty("db.user");
					dbPassword = props.getProperty("db.password");
					if (dbUser != null && !dbUser.isEmpty()) {
						logger.info("Successfully loaded database credentials from db.properties file.");
					}
				}
			} else {
				logger.info("Successfully loaded database credentials from environment variables.");
			}

			if (dbUser == null || dbUser.isEmpty() || dbPassword == null || dbPassword.isEmpty()) {
				logger.fatal("!!! CRITICAL SECURITY ERROR !!!");
				logger.fatal(
						"Database credentials not found in environment variables (DB_USER, DB_PASSWORD) or db.properties.");
				logger.fatal("Application startup aborted. Set credentials in one of these locations to proceed.");
				throw new RuntimeException("Database credentials are not configured.");
			}

			hikariConfiguration.setUsername(dbUser);
			hikariConfiguration.setPassword(dbPassword);

			hikariConfiguration.setMaximumPoolSize(10);
			hikariConfiguration.setMinimumIdle(5);
			hikariConfiguration.setConnectionTimeout(30000);
			hikariConfiguration.setIdleTimeout(600000);
			hikariConfiguration.setMaxLifetime(1800000);

			dataSource = new HikariDataSource(hikariConfiguration);

			logger.info("================================================================");
			logger.info("DATABASE CONNECTION POOL INITIALIZED SUCCESSFULLY.");
			logger.info("================================================================");

		} catch (Exception exception) {
			logger.fatal(
					"Failed to initialize database connection pool! The application cannot function without a database.",
					exception);
			throw new RuntimeException("Could not initialize database pool", exception);
		}
	}

	public static Connection getConnection() throws SQLException {
		if (dataSource == null) {
			logger.error("Datasource is null. The database manager was not initialized correctly.");
			throw new SQLException("Database connection pool is not available.");
		}
		return dataSource.getConnection();
	}

	public static void closeDataSource() {
		if (dataSource != null && !dataSource.isClosed()) {
			logger.info("Closing database connection pool...");
			dataSource.close();
			logger.info("Database connection pool closed successfully.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {

			preparedStatement.setInt(1, message.getEventId());
			preparedStatement.setInt(2, message.getUserId());
			preparedStatement.setString(3, message.getUsername());
			preparedStatement.setString(4, message.getMessageText());

			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						return getMessageById(newId, connection);
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("Error posting chat message for event {}", message.getEventId(), exception);
		}
		return null;
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		List<EventChatMessage> messages = new ArrayList<>();
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color "
				+ "FROM event_chat_messages m " + "LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id "
				+ "JOIN users u_orig ON m.user_id = u_orig.id " + 
				"WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					messages.add(mapRowToMessage(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching chat messages for event {}", eventId, exception);
		}
		return messages;
	}

	private EventChatMessage getMessageById(int messageId, Connection connection) throws SQLException {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color "
				+ "FROM event_chat_messages m " + "LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id "
				+ "JOIN users u_orig ON m.user_id = u_orig.id " + "WHERE m.id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, messageId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					return mapRowToMessage(resultSet);
				}
			}
		}
		return null;
	}

	private EventChatMessage mapRowToMessage(ResultSet resultSet) throws SQLException {
		EventChatMessage message = new EventChatMessage();
		message.setId(resultSet.getInt("id"));
		message.setEventId(resultSet.getInt("event_id"));
		message.setUserId(resultSet.getInt("user_id"));
		message.setUsername(resultSet.getString("username"));
		message.setMessageText(resultSet.getString("message_text"));
		message.setEdited(resultSet.getBoolean("edited"));
		message.setDeleted(resultSet.getBoolean("is_deleted"));
		message.setDeletedByUserId(resultSet.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(resultSet.getString("deleted_by_username"));
		message.setChatColor(resultSet.getString("chat_color")); 

		if (resultSet.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(resultSet.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(resultSet.getTimestamp("sent_at").toLocalDateTime());
		return message;
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE WHERE id = ? AND user_id = ? AND is_deleted = FALSE";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newText);
			preparedStatement.setInt(2, messageId);
			preparedStatement.setInt(3, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating message ID {}", messageId, exception);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql;
		if (isAdmin) {
			sql = "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ?";
		} else {
			sql = "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ? AND user_id = ?";
		}

		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, deletersUserId);
			preparedStatement.setInt(2, messageId);
			if (!isAdmin) {
				preparedStatement.setInt(3, deletersUserId);
			}
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error soft-deleting message ID {}:", messageId, exception);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);

	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields) {
		String deleteSql = "DELETE FROM event_custom_fields WHERE event_id = ?";
		String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
		Connection connection = null;
		try {
			connection = DatabaseManager.getConnection();
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (fields != null && !fields.isEmpty()) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (EventCustomField field : fields) {
						insertStatement.setInt(1, eventId);
						insertStatement.setString(2, field.getFieldName());
						insertStatement.setString(3, field.getFieldType());
						insertStatement.setBoolean(4, field.isRequired());
						insertStatement.setString(5, field.getFieldOptions());
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}
			connection.commit();
			logger.info("Successfully saved {} custom fields for event ID {}", fields != null ? fields.size() : 0,
					eventId);
		} catch (SQLException e) {
			logger.error("Error saving custom fields for event ID {}. Rolling back.", eventId, e);
			if (connection != null)
				try {
					connection.rollback();
				} catch (SQLException ex) {
					logger.error("Rollback failed.", ex);
				}
		} finally {
			if (connection != null)
				try {
					connection.setAutoCommit(true);
					connection.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		List<EventCustomField> fields = new ArrayList<>();
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					EventCustomField field = new EventCustomField();
					field.setId(resultSet.getInt("id"));
					field.setEventId(resultSet.getInt("event_id"));
					field.setFieldName(resultSet.getString("field_name"));
					field.setFieldType(resultSet.getString("field_type"));
					field.setRequired(resultSet.getBoolean("is_required"));
					field.setFieldOptions(resultSet.getString("field_options"));
					fields.add(field);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
		}
		return fields;
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFieldId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setString(3, response.getResponseValue());
			preparedStatement.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Event;
import de.technikteam.model.EventAttendance;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);

	private Event mapResultSetToEvent(ResultSet resultSet) throws SQLException {
		Event event = new Event();
		event.setId(resultSet.getInt("id"));
		event.setName(resultSet.getString("name"));
		event.setDescription(resultSet.getString("description"));
		event.setLocation(resultSet.getString("location"));
		event.setStatus(resultSet.getString("status"));

		Timestamp eventTimestamp = resultSet.getTimestamp("event_datetime");
		if (eventTimestamp != null) {
			event.setEventDateTime(eventTimestamp.toLocalDateTime());
		}
		Timestamp endTimestamp = resultSet.getTimestamp("end_datetime");
		if (endTimestamp != null) {
			event.setEndDateTime(endTimestamp.toLocalDateTime());
		}

		if (DaoUtils.hasColumn(resultSet, "leader_user_id")) {
			event.setLeaderUserId(resultSet.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(resultSet, "leader_username")) {
			event.setLeaderUsername(resultSet.getString("leader_username"));
		}
		return event;
	}

	private User mapResultSetToSimpleUser(ResultSet resultSet) throws SQLException {
		return new User(resultSet.getInt("id"), resultSet.getString("username"), resultSet.getString("role"));
	}

	public List<Event> getEventHistoryForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.*, ea.signup_status FROM events e "
				+ "JOIN event_attendance ea ON e.id = ea.event_id WHERE ea.user_id = ? ORDER BY e.event_datetime DESC";
		logger.debug("Fetching event history for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Event event = mapResultSetToEvent(resultSet);
					event.setUserAttendanceStatus(resultSet.getString("signup_status"));
					history.add(event);
				}
			}
			logger.info("Found {} events in history for user ID: {}", history.size(), userId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching event history for user {}", userId, exception);
		}
		return history;
	}

	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "WHERE e.id = ?";
		logger.debug("Fetching event by ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found event '{}' with ID: {}", resultSet.getString("name"), eventId);
					return mapResultSetToEvent(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching event by ID: {}", eventId, exception);
		}
		logger.warn("No event found with ID: {}", eventId);
		return null;
	}

	public List<Event> getAllEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "ORDER BY e.event_datetime DESC";
		logger.debug("Fetching all events.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
			logger.info("Fetched a total of {} events.", events.size());
		} catch (SQLException exception) {
			logger.error("SQL error fetching all events.", exception);
		}
		return events;
	}

	public List<Event> getActiveEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		logger.debug("Fetching active events.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active events.", exception);
		}
		return events;
	}

	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, 'GEPLANT', ?)";
		logger.debug("Attempting to create new event: {}", event.getName());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				preparedStatement.setNull(3, Types.TIMESTAMP);
			}
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			if (event.getLeaderUserId() > 0) {
				preparedStatement.setInt(6, event.getLeaderUserId());
			} else {
				preparedStatement.setNull(6, Types.INTEGER);
			}

			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						logger.info("Successfully created event '{}' with ID {}", event.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error creating event '{}'.", event.getName(), exception);
		}
		return 0;
	}

	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		logger.debug("Attempting to update event with ID: {}", event.getId());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				preparedStatement.setNull(3, Types.TIMESTAMP);
			}
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			preparedStatement.setString(6, event.getStatus());
			if (event.getLeaderUserId() > 0) {
				preparedStatement.setInt(7, event.getLeaderUserId());
			} else {
				preparedStatement.setNull(7, Types.INTEGER);
			}
			preparedStatement.setInt(8, event.getId());

			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error updating event with ID: {}", event.getId(), exception);
		}
		return false;
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		logger.debug("Attempting to delete event with ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error deleting event with ID: {}", eventId, exception);
		}
		return false;
	}

	public boolean updateEventStatus(int eventId, String newStatus) {
		String sql = "UPDATE events SET status = ? WHERE id = ?";
		logger.debug("Attempting to update status for event {} to '{}'", eventId, newStatus);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newStatus);
			preparedStatement.setInt(2, eventId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error updating status for event ID: {}", eventId, exception);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		logger.debug("Signing up user {} for event {}", userId, eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
			logger.info("User {} successfully signed up for event {}", userId, eventId);
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-up for user {} and event {}", userId, eventId, exception);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		logger.debug("Signing off user {} from event {}", userId, eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
			logger.info("User {} successfully signed off from event {}", userId, eventId);
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-off for user {} and event {}", userId, eventId, exception);
		}
	}

	public List<User> getSignedUpUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name as role FROM users u "
				+ "JOIN event_attendance ea ON u.id = ea.user_id " + "LEFT JOIN roles r on u.role_id = r.id "
				+ "WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching signed up users for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next())
					users.add(mapResultSetToSimpleUser(resultSet));
			}
			logger.info("Found {} signed-up users for event ID: {}", users.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching signed-up users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		String deleteSql = "DELETE FROM event_assignments WHERE event_id = ?";
		String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning users to event ID: {}", eventId);

		try (Connection connection = DatabaseManager.getConnection()) {
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (String userId : userIds) {
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(userId));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}

			connection.commit();
			logger.info("Successfully assigned {} users to event ID {}", (userIds != null ? userIds.length : 0),
					eventId);

		} catch (SQLException | NumberFormatException exception) {
			logger.error(
					"SQL transaction error during user assignment for event ID: {}. Transaction will be rolled back.",
					eventId, exception);
			// The try-with-resources on the connection will handle rollback if autoCommit
			// is false.
		}
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		List<SkillRequirement> requirements = new ArrayList<>();
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons "
				+ "FROM event_skill_requirements esr " + "JOIN courses c ON esr.required_course_id = c.id "
				+ "WHERE esr.event_id = ?";
		logger.debug("Fetching skill requirements for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					SkillRequirement requirement = new SkillRequirement();
					requirement.setRequiredCourseId(resultSet.getInt("required_course_id"));
					requirement.setCourseName(resultSet.getString("course_name"));
					requirement.setRequiredPersons(resultSet.getInt("required_persons"));
					requirements.add(requirement);
				}
			}
			logger.info("Found {} skill requirements for event ID: {}", requirements.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching skill requirements for event ID: {}", eventId, exception);
		}
		return requirements;
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		String deleteSql = "DELETE FROM event_skill_requirements WHERE event_id = ?";
		String insertSql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
		logger.debug("Saving skill requirements for event ID: {}", eventId);

		try (Connection connection = DatabaseManager.getConnection()) {
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (int i = 0; i < requiredCourseIds.length; i++) {
						if (requiredCourseIds[i] == null || requiredCourseIds[i].isEmpty())
							continue;
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(requiredCourseIds[i]));
						insertStatement.setInt(3, Integer.parseInt(requiredPersons[i]));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}

			connection.commit();
			logger.info("Successfully saved skill requirements for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException exception) {
			logger.error(
					"Transaction error during saving skill requirements for event ID: {}. Transaction will be rolled back.",
					eventId, exception);
		}
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		String deleteSql = "DELETE FROM event_storage_reservations WHERE event_id = ?";
		String insertSql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";

		try (Connection connection = DatabaseManager.getConnection()) {
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (int i = 0; i < itemIds.length; i++) {
						if (itemIds[i] == null || itemIds[i].isEmpty())
							continue;
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(itemIds[i]));
						insertStatement.setInt(3, Integer.parseInt(quantities[i]));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}
			connection.commit();
			logger.info("Successfully saved storage reservations for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException exception) {
			logger.error("Error saving storage reservations for event {}. Transaction will be rolled back.", eventId,
					exception);
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr "
				+ "JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					StorageItem item = new StorageItem();
					item.setId(resultSet.getInt("id"));
					item.setName(resultSet.getString("name"));
					item.setQuantity(resultSet.getInt("reserved_quantity"));
					items.add(item);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching reserved items for event ID: {}", eventId, exception);
		}
		return items;
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status NOT IN ('ABGESCHLOSSEN', 'ABGESAGT') AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		logger.debug("Fetching all active and upcoming events for calendar feed.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active/upcoming events for calendar.", exception);
		}
		return events;
	}

	public List<Event> getUpcomingEventsForUser(User user, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, " + "CASE " + "    WHEN eas.user_id IS NOT NULL THEN 'ZUGEWIESEN' "
				+ "    WHEN ea.signup_status IS NOT NULL THEN ea.signup_status " + "    ELSE 'OFFEN' "
				+ "END AS calculated_user_status " + "FROM events e "
				+ "LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.user_id = ? "
				+ "LEFT JOIN event_assignments eas ON e.id = eas.event_id AND eas.user_id = ? "
				+ "WHERE e.event_datetime >= NOW() " + "AND ("
				+ "  NOT EXISTS (SELECT 1 FROM event_skill_requirements esr WHERE esr.event_id = e.id) OR "
				+ "  EXISTS (SELECT 1 FROM event_skill_requirements esr JOIN user_qualifications uq ON esr.required_course_id = uq.course_id WHERE esr.event_id = e.id AND uq.user_id = ? AND uq.status = 'ABSOLVIERT')"
				+ ") " + "ORDER BY e.event_datetime ASC" + (limit > 0 ? " LIMIT ?" : "");

		logger.debug("Fetching upcoming events for user ID: {} with limit: {}", user.getId(), limit);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

			preparedStatement.setInt(1, user.getId());
			preparedStatement.setInt(2, user.getId());
			preparedStatement.setInt(3, user.getId());
			if (limit > 0) {
				preparedStatement.setInt(4, limit);
			}

			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Event event = mapResultSetToEvent(resultSet);
					String finalStatus = resultSet.getString("calculated_user_status");
					event.setUserAttendanceStatus(finalStatus);
					events.add(event);
				}
				logger.info("Found {} qualified upcoming events for user ID {}", events.size(), user.getId());
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching qualified upcoming events for user {}", user.getId(), exception);
		}
		return events;
	}

	public boolean isUserAssociatedWithEvent(int eventId, int userId) {
		String sql = "SELECT 1 FROM event_attendance WHERE event_id = ? AND user_id = ? AND signup_status = 'ANGEMELDET' "
				+ "UNION " + "SELECT 1 FROM event_assignments WHERE event_id = ? AND user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, eventId);
			pstmt.setInt(4, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user association for event {} and user {}", eventId, userId, e);
			return false;
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u "
				+ "JOIN event_assignments ea ON u.id = ea.user_id " + "LEFT JOIN roles r ON u.role_id = r.id "
				+ "WHERE ea.event_id = ?";
		logger.debug("Fetching assigned users for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					users.add(mapResultSetToSimpleUser(resultSet));
				}
			}
			logger.info("Found {} assigned users for event ID: {}", users.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching assigned users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.* FROM events e " + "JOIN event_assignments ea ON e.id = ea.event_id "
				+ "WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' " + "ORDER BY e.event_datetime DESC";
		logger.debug("Fetching completed event history for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					history.add(mapResultSetToEvent(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching completed event history for user {}", userId, exception);
		}
		return history;
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.* FROM events e " + "JOIN event_assignments ea ON e.id = ea.event_id "
				+ "WHERE ea.user_id = ? AND e.event_datetime >= NOW() " + "ORDER BY e.event_datetime ASC";
		if (limit > 0) {
			sql += " LIMIT ?";
		}
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			if (limit > 0) {
				preparedStatement.setInt(2, limit);
			}
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					events.add(mapResultSetToEvent(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching assigned events for user {}", userId, exception);
		}
		return events;
	}

	public List<User> getQualifiedAndAvailableUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		// This complex query first identifies all users who meet ALL skill requirements
		// for the event.
		// It then excludes users who are already assigned to an overlapping event.
		String sql = "SELECT u.id, u.username, r.role_name AS role " + "FROM users u "
				+ "LEFT JOIN roles r ON u.role_id = r.id " +
				// Condition 1: User has ALL required skills for the event.
				// This subquery counts the required skills for the event and ensures the user
				// has all of them.
				"WHERE (SELECT COUNT(*) FROM event_skill_requirements WHERE event_id = ?) = "
				+ "      (SELECT COUNT(*) FROM user_qualifications uq "
				+ "       JOIN event_skill_requirements esr ON uq.course_id = esr.required_course_id "
				+ "       WHERE esr.event_id = ? AND uq.user_id = u.id AND uq.status = 'ABSOLVIERT') " + "AND " +
				// Condition 2: User is not already assigned to an overlapping event.
				"u.id NOT IN ( " + "  SELECT ea.user_id FROM event_assignments ea "
				+ "  JOIN events conflicting_event ON ea.event_id = conflicting_event.id "
				+ "  JOIN events target_event ON target_event.id = ? "
				+ "  WHERE conflicting_event.id != target_event.id "
				+ "  AND conflicting_event.event_datetime < COALESCE(target_event.end_datetime, target_event.event_datetime + INTERVAL 2 HOUR) "
				+ "  AND COALESCE(conflicting_event.end_datetime, conflicting_event.event_datetime + INTERVAL 2 HOUR) > target_event.event_datetime "
				+ ") " + "ORDER BY u.username ASC";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			pstmt.setInt(2, eventId);
			pstmt.setInt(3, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					users.add(mapResultSetToSimpleUser(rs));
				}
			}
			logger.info("Found {} qualified and available users for event ID {}", users.size(), eventId);
		} catch (SQLException e) {
			logger.error("Error finding qualified and available users for event ID {}", eventId, e);
		}
		return users;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Manages all database operations for EventTask entities and their
 * associations.
 */
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);

	/**
	 * Saves or updates a task and all its associations in a single transaction.
	 *
	 * @param task           The task to save.
	 * @param userIds        Array of user IDs to assign directly.
	 * @param itemIds        Array of required storage item IDs.
	 * @param itemQuantities Array of quantities for required items.
	 * @param kitIds         Array of required inventory kit IDs.
	 * @return The ID of the saved or updated task, or 0 on failure.
	 */
	public int saveTask(EventTask task, int[] userIds, String[] itemIds, String[] itemQuantities, String[] kitIds) {
		boolean isUpdate = task.getId() > 0;
		String taskSql = isUpdate
				? "UPDATE event_tasks SET description = ?, details = ?, status = ?, display_order = ?, required_persons = ? WHERE id = ?"
				: "INSERT INTO event_tasks (event_id, description, details, status, display_order, required_persons) VALUES (?, ?, ?, 'OFFEN', ?, ?)";

		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false);

			// Step 1: Save the main task record
			try (PreparedStatement pstmt = conn.prepareStatement(taskSql, Statement.RETURN_GENERATED_KEYS)) {
				if (isUpdate) {
					setUpdateTaskStatementParams(pstmt, task);
				} else {
					setCreateTaskStatementParams(pstmt, task);
				}
				pstmt.executeUpdate();

				if (!isUpdate) {
					try (ResultSet rs = pstmt.getGeneratedKeys()) {
						if (rs.next()) {
							task.setId(rs.getInt(1));
						}
					}
				}
			}

			int taskId = task.getId();
			if (taskId == 0) {
				throw new SQLException("Failed to create or find task ID, no ID obtained.");
			}

			// Step 2: Manage associations
			clearAssociations(conn, taskId);
			saveUserAssignments(conn, taskId, userIds);
			saveItemRequirements(conn, taskId, itemIds, itemQuantities);
			saveKitRequirements(conn, taskId, kitIds);

			conn.commit();
			logger.info("Successfully saved task ID {}", taskId);
			return taskId;

		} catch (SQLException | NumberFormatException e) {
			logger.error("Error in task transaction. Rolling back.", e);
			rollback(conn);
			return 0;
		} finally {
			closeConnection(conn);
		}
	}

	/**
	 * Efficiently fetches all tasks for a given event, including all associated
	 * users, items, and kits, using a single database query to prevent the N+1
	 * problem.
	 *
	 * @param eventId The ID of the event.
	 * @return A list of fully populated EventTask objects.
	 */
	public List<EventTask> getTasksForEvent(int eventId) {
		Map<Integer, EventTask> tasksById = new LinkedHashMap<>();
		String sql = "SELECT t.*, " + "u.id as user_id, u.username, "
				+ "si.id as item_id, si.name as item_name, tsi.quantity as item_quantity, "
				+ "ik.id as kit_id, ik.name as kit_name " + "FROM event_tasks t "
				+ "LEFT JOIN event_task_assignments ta ON t.id = ta.task_id "
				+ "LEFT JOIN users u ON ta.user_id = u.id "
				+ "LEFT JOIN event_task_storage_items tsi ON t.id = tsi.task_id "
				+ "LEFT JOIN storage_items si ON tsi.item_id = si.id "
				+ "LEFT JOIN event_task_kits tk ON t.id = tk.task_id "
				+ "LEFT JOIN inventory_kits ik ON tk.kit_id = ik.id " + "WHERE t.event_id = ? "
				+ "ORDER BY t.display_order ASC, t.id ASC, u.username, si.name, ik.name";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					int currentTaskId = rs.getInt("id");
					EventTask task = tasksById.computeIfAbsent(currentTaskId, id -> {
						try {
							return mapResultSetToTask(rs);
						} catch (SQLException e) {
							throw new RuntimeException(e);
						}
					});

					// Add associated user if present
					if (rs.getInt("user_id") > 0) {
						User user = new User();
						user.setId(rs.getInt("user_id"));
						user.setUsername(rs.getString("username"));
						if (!task.getAssignedUsers().stream().anyMatch(u -> u.getId() == user.getId())) {
							task.getAssignedUsers().add(user);
						}
					}

					// Add associated item if present
					if (rs.getInt("item_id") > 0) {
						StorageItem item = new StorageItem();
						item.setId(rs.getInt("item_id"));
						item.setName(rs.getString("item_name"));
						item.setQuantity(rs.getInt("item_quantity"));
						if (!task.getRequiredItems().stream().anyMatch(i -> i.getId() == item.getId())) {
							task.getRequiredItems().add(item);
						}
					}

					// Add associated kit if present
					if (rs.getInt("kit_id") > 0) {
						InventoryKit kit = new InventoryKit();
						kit.setId(rs.getInt("kit_id"));
						kit.setName(rs.getString("kit_name"));
						if (!task.getRequiredKits().stream().anyMatch(k -> k.getId() == kit.getId())) {
							task.getRequiredKits().add(kit);
						}
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching tasks for event {}", eventId, e);
		} catch (RuntimeException e) {
			logger.error("Error mapping result set for event tasks {}", eventId, e.getCause());
		}
		return new ArrayList<>(tasksById.values());
	}

	public EventTask getTaskById(int taskId) {
		String sql = "SELECT * FROM event_tasks WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					return task;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching task by ID {}", taskId, e);
		}
		return null;
	}

	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting task {}", taskId, e);
			return false;
		}
	}

	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for task {}", taskId, e);
			return false;
		}
	}

	public boolean claimTask(int taskId, int userId) {
		String sql = "INSERT INTO event_task_assignments (task_id, user_id) " + "SELECT ?, ? FROM event_tasks "
				+ "WHERE id = ? AND required_persons > (SELECT COUNT(*) FROM event_task_assignments WHERE task_id = ?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, taskId);
			pstmt.setInt(4, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			if (e.getErrorCode() == 1062) { // Duplicate entry
				logger.warn("User {} already claimed task {}. Ignoring.", userId, taskId);
				return true; // Or false depending on desired behavior for duplicate claims
			}
			logger.error("Error claiming task {} for user {}", taskId, userId, e);
			return false;
		}
	}

	public boolean unclaimTask(int taskId, int userId) {
		String sql = "DELETE FROM event_task_assignments WHERE task_id = ? AND user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error unclaiming task {} for user {}", taskId, userId, e);
			return false;
		}
	}

	public boolean isUserAssignedToTask(int taskId, int userId) {
		String sql = "SELECT 1 FROM event_task_assignments WHERE task_id = ? AND user_id = ? LIMIT 1";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			pstmt.setInt(2, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				return rs.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user assignment for task {} and user {}", taskId, userId, e);
			return false;
		}
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		List<EventTask> tasks = new ArrayList<>();
		String sql = "SELECT t.*, e.name as event_name " + "FROM event_tasks t "
				+ "JOIN event_task_assignments ta ON t.id = ta.task_id " + "JOIN events e ON t.event_id = e.id "
				+ "WHERE ta.user_id = ? AND t.status = 'OFFEN' " + "ORDER BY e.event_datetime ASC";
		logger.debug("Fetching open tasks for user ID {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setEventName(rs.getString("event_name"));
					tasks.add(task);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching open tasks for user {}", userId, e);
		}
		return tasks;
	}

	// --- Private Helper Methods ---

	private EventTask mapResultSetToTask(ResultSet rs) throws SQLException {
		EventTask task = new EventTask();
		task.setId(rs.getInt("id"));
		task.setEventId(rs.getInt("event_id"));
		task.setDescription(rs.getString("description"));
		task.setDetails(rs.getString("details"));
		task.setStatus(rs.getString("status"));
		task.setDisplayOrder(rs.getInt("display_order"));
		task.setRequiredPersons(rs.getInt("required_persons"));
		task.setAssignedUsers(new ArrayList<>());
		task.setRequiredItems(new ArrayList<>());
		task.setRequiredKits(new ArrayList<>());
		return task;
	}

	private void setCreateTaskStatementParams(PreparedStatement pstmt, EventTask task) throws SQLException {
		pstmt.setInt(1, task.getEventId());
		pstmt.setString(2, task.getDescription());
		pstmt.setString(3, task.getDetails());
		pstmt.setInt(4, task.getDisplayOrder());
		pstmt.setInt(5, task.getRequiredPersons());
	}

	private void setUpdateTaskStatementParams(PreparedStatement pstmt, EventTask task) throws SQLException {
		pstmt.setString(1, task.getDescription());
		pstmt.setString(2, task.getDetails());
		pstmt.setString(3, task.getStatus());
		pstmt.setInt(4, task.getDisplayOrder());
		pstmt.setInt(5, task.getRequiredPersons());
		pstmt.setInt(6, task.getId());
	}

	private void clearAssociations(Connection conn, int taskId) throws SQLException {
		try (PreparedStatement userStmt = conn.prepareStatement("DELETE FROM event_task_assignments WHERE task_id = ?");
				PreparedStatement itemStmt = conn
						.prepareStatement("DELETE FROM event_task_storage_items WHERE task_id = ?");
				PreparedStatement kitStmt = conn.prepareStatement("DELETE FROM event_task_kits WHERE task_id = ?")) {

			userStmt.setInt(1, taskId);
			userStmt.executeUpdate();

			itemStmt.setInt(1, taskId);
			itemStmt.executeUpdate();

			kitStmt.setInt(1, taskId);
			kitStmt.executeUpdate();
		}
	}

	private void saveUserAssignments(Connection conn, int taskId, int[] userIds) throws SQLException {
		if (userIds == null || userIds.length == 0)
			return;

		String sql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (int userId : userIds) {
				pstmt.setInt(1, taskId);
				pstmt.setInt(2, userId);
				pstmt.addBatch();
			}
			pstmt.executeBatch();
		}
	}

	private void saveItemRequirements(Connection conn, int taskId, String[] itemIds, String[] itemQuantities)
			throws SQLException, NumberFormatException {
		if (itemIds == null || itemQuantities == null || itemIds.length != itemQuantities.length)
			return;

		String sql = "INSERT INTO event_task_storage_items (task_id, item_id, quantity) VALUES (?, ?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (int i = 0; i < itemIds.length; i++) {
				if (!itemIds[i].isEmpty()) {
					pstmt.setInt(1, taskId);
					pstmt.setInt(2, Integer.parseInt(itemIds[i]));
					pstmt.setInt(3, Integer.parseInt(itemQuantities[i]));
					pstmt.addBatch();
				}
			}
			pstmt.executeBatch();
		}
	}

	private void saveKitRequirements(Connection conn, int taskId, String[] kitIds)
			throws SQLException, NumberFormatException {
		if (kitIds == null || kitIds.length == 0)
			return;

		String sql = "INSERT INTO event_task_kits (task_id, kit_id) VALUES (?, ?)";
		try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
			for (String kitId : kitIds) {
				if (!kitId.isEmpty()) {
					pstmt.setInt(1, taskId);
					pstmt.setInt(2, Integer.parseInt(kitId));
					pstmt.addBatch();
				}
			}
			pstmt.executeBatch();
		}
	}

	private void rollback(Connection conn) {
		if (conn != null) {
			try {
				conn.rollback();
			} catch (SQLException ex) {
				logger.error("Transaction rollback failed.", ex);
			}
		}
	}

	private void closeConnection(Connection conn) {
		if (conn != null) {
			try {
				conn.setAutoCommit(true);
				conn.close();
			} catch (SQLException ex) {
				logger.error("Failed to close connection.", ex);
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FeedbackDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class FeedbackDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackDAO.class);

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setInt(1, form.getEventId());
			preparedStatement.setString(2, form.getTitle());
			int affectedRows = preparedStatement.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
					if (resultSet.next()) {
						return resultSet.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
		}
		return 0;
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFormId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setInt(3, response.getRating());
			preparedStatement.setString(4, response.getComments());
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
		}
		return false;
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					FeedbackForm form = new FeedbackForm();
					form.setId(resultSet.getInt("id"));
					form.setEventId(resultSet.getInt("event_id"));
					form.setTitle(resultSet.getString("title"));
					form.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
					return form;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
		}
		return null;
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		List<FeedbackResponse> responses = new ArrayList<>();
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					FeedbackResponse response = new FeedbackResponse();
					response.setId(resultSet.getInt("id"));
					response.setFormId(resultSet.getInt("form_id"));
					response.setUserId(resultSet.getInt("user_id"));
					response.setUsername(resultSet.getString("username")); 
					response.setRating(resultSet.getInt("rating"));
					response.setComments(resultSet.getString("comments"));
					response.setSubmittedAt(resultSet.getTimestamp("submitted_at").toLocalDateTime());
					responses.add(response);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
		}
		return responses;
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT 1 FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			preparedStatement.setInt(2, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				return resultSet.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user feedback submission status.", e);
		}
		return false;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * This DAO manages metadata of uploaded files stored in the `files` and
 * `file_categories` tables. It handles creating, reading, and deleting file
 * records and categories. It includes role-based filtering to control file
 * visibility and logic to group files by category for display in the UI. It
 * also provides methods to manage a simple key-value content store in the
 * `shared_documents` table.
 */
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);

	/**
	 * Helper method to map a row from a ResultSet to a File object.
	 *
	 * @param rs The ResultSet to map.
	 * @return A populated File object.
	 * @throws SQLException If a database error occurs.
	 */
	private File mapResultSetToFile(ResultSet rs) throws SQLException {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));

		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}

		if (DaoUtils.hasColumn(rs, "category_name")) {
			String categoryName = rs.getString("category_name");
			file.setCategoryName(categoryName == null ? "Ohne Kategorie" : categoryName);
		} else {
			file.setCategoryName("Ohne Kategorie");
		}

		return file;
	}

	/**
	 * Fetches all file records, applying role-based filtering, and groups them by
	 * category name. This implementation uses a two-query approach to be robust
	 * against potential database join issues.
	 *
	 * @param user The current user, used to determine their role.
	 * @return A Map where keys are category names and values are lists of files.
	 */
	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		logger.debug("Fetching all files grouped by category for user role: {}", user.getRoleName());

		Map<Integer, String> categoryIdToNameMap = new HashMap<>();
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery("SELECT id, name FROM file_categories")) {
			while (rs.next()) {
				categoryIdToNameMap.put(rs.getInt("id"), rs.getString("name"));
			}
		} catch (SQLException e) {
			logger.error("Could not fetch file categories for grouping.", e);
			return new HashMap<>();
		}

		List<File> files = new ArrayList<>();
		String sql = "SELECT * FROM files ";

		if (!user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			sql += "WHERE required_role = 'NUTZER' ";
			logger.debug("Applying 'NUTZER' role filter for file query.");
		}
		sql += "ORDER BY filename";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				File file = new File();
				file.setId(rs.getInt("id"));
				file.setFilename(rs.getString("filename"));
				file.setFilepath(rs.getString("filepath"));
				file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
				file.setRequiredRole(rs.getString("required_role"));

				int categoryId = rs.getInt("category_id");
				file.setCategoryId(categoryId);

				String categoryName = categoryIdToNameMap.get(categoryId);
				file.setCategoryName(categoryName != null ? categoryName : "Ohne Kategorie");

				files.add(file);
			}
			logger.info("Fetched and processed {} files visible to user role '{}'.", files.size(), user.getRoleName());
		} catch (SQLException e) {
			logger.error("SQL error while fetching files.", e);
		}

		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	/**
	 * Creates a new file metadata record in the database.
	 *
	 * @param file The File object to persist.
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Creating file record for '{}' with role '{}'", file.getFilename(), file.getRequiredRole());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			if (file.getCategoryId() > 0) {
				pstmt.setInt(3, file.getCategoryId());
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setString(4, file.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file record for '{}'", file.getFilename(), e);
			return false;
		}
	}

	/**
	 * Updates the metadata of an existing file record, typically after a new
	 * version is uploaded. It updates the filename and the timestamp.
	 * 
	 * @param file The File object with the updated data (must include ID).
	 * @return true if the update was successful.
	 */
	public boolean updateFileRecord(File file) {
		String sql = "UPDATE files SET filename = ?, filepath = ?, uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		logger.debug("Updating file record for ID {}", file.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			pstmt.setInt(3, file.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating file record for ID {}", file.getId(), e);
			return false;
		}
	}

	/**
	 * Updates the timestamp of a file record to the current time. Used by WOPI to
	 * indicate a new version has been saved.
	 * 
	 * @param fileId The ID of the file to "touch".
	 * @return true if the update was successful.
	 */
	public boolean touchFileRecord(int fileId) {
		String sql = "UPDATE files SET uploaded_at = CURRENT_TIMESTAMP WHERE id = ?";
		logger.debug("Touching file record for ID {}", fileId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error touching file record for ID {}", fileId, e);
			return false;
		}
	}

	/**
	 * Fetches all file categories from the database, sorted by name.
	 *
	 * @return A list of FileCategory objects.
	 */
	public List<FileCategory> getAllCategories() {
		List<FileCategory> categories = new ArrayList<>();
		String sql = "SELECT * FROM file_categories ORDER BY name";
		logger.debug("Fetching all file categories.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				categories.add(cat);
			}
			logger.info("Fetched {} file categories.", categories.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching file categories.", e);
		}
		return categories;
	}

	/**
	 * Retrieves a single file's metadata by its ID.
	 *
	 * @param fileId The ID of the file to retrieve.
	 * @return A File object populated with data, or null if not found.
	 */
	public File getFileById(int fileId) {
		logger.debug("Fetching file by ID: {}", fileId);
		String sql = "SELECT f.*, fc.name as category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id " + "WHERE f.id = ?";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found file with ID: {}", fileId);
					return mapResultSetToFile(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching file with ID: {}", fileId, e);
		}

		logger.warn("No file found with ID: {}", fileId);
		return null;
	}

	/**
	 * Deletes a file record from the 'files' table in the database. Note: This
	 * method ONLY deletes the database record. The physical file must be deleted
	 * separately by the calling servlet.
	 *
	 * @param fileId The ID of the file record to delete.
	 * @return true if the database record was successfully deleted, false
	 *         otherwise.
	 */
	public boolean deleteFile(int fileId) {
		logger.warn("Attempting to delete file record from database with ID: {}", fileId);
		String sql = "DELETE FROM files WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				logger.info("Successfully deleted file record with ID: {}", fileId);
				return true;
			} else {
				logger.warn("Could not delete file record with ID: {}. It might not exist.", fileId);
				return false;
			}
		} catch (SQLException e) {
			logger.error("SQL error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	/**
	 * Creates a new file category.
	 *
	 * @param categoryName The name of the new category.
	 * @return true if successful.
	 */
	public boolean createCategory(String categoryName) {
		logger.info("Creating new file category: {}", categoryName);
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, categoryName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLIntegrityConstraintViolationException e) {
			logger.warn("Attempted to create a duplicate file category: '{}'", categoryName);
			return false;
		} catch (SQLException e) {
			logger.error("SQL error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	/**
	 * Updates the name of an existing file category.
	 *
	 * @param categoryId The ID of the category to update.
	 * @param newName    The new name for the category.
	 * @return true if successful.
	 */
	public boolean updateCategory(int categoryId, String newName) {
		String sql = "UPDATE file_categories SET name = ? WHERE id = ?";
		logger.debug("Updating category ID {} to new name '{}'", categoryId, newName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newName);
			pstmt.setInt(2, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Deletes a file category. Due to "ON DELETE SET NULL" constraint in the DB,
	 * files in this category will have their category_id set to NULL.
	 *
	 * @param categoryId The ID of the category to delete.
	 * @return true if successful.
	 */
	public boolean deleteCategory(int categoryId) {
		logger.warn("Attempting to delete category ID: {}", categoryId);
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Retrieves the name of a category by its ID.
	 *
	 * @param categoryId The ID of the category.
	 * @return The category name, or null if not found.
	 */
	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		logger.debug("Fetching category name for ID: {}", categoryId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("name");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
		}
		return null;
	}

	/**
	 * Retrieves the content of a shared document (e.g., for the collaborative
	 * editor).
	 *
	 * @param documentName The unique name/key of the document.
	 * @return The document's content as a string, or an empty string if not found.
	 */
	public String getDocumentContent(String documentName) {
		String sql = "SELECT content FROM shared_documents WHERE document_name = ?";
		logger.trace("Fetching document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("content");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching document content for name: {}", documentName, e);
		}
		return "";
	}

	/**
	 * Updates or creates the content of a shared document using an "upsert"
	 * operation. This ensures that the document can be saved even if it doesn't
	 * exist yet.
	 *
	 * @param documentName The unique name/key of the document to update.
	 * @param content      The new content to save.
	 * @return true if the update was successful.
	 */
	public boolean updateDocumentContent(String documentName, String content) {
		String sql = "INSERT INTO shared_documents (document_name, content) VALUES (?, ?) "
				+ "ON DUPLICATE KEY UPDATE content = VALUES(content)";
		logger.trace("Upserting document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			pstmt.setString(2, content);
			return pstmt.executeUpdate() >= 0;
		} catch (SQLException e) {
			logger.error("Error upserting document content for name: {}", documentName, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * DAO for managing inventory kits and their contents.
 */
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description, location) VALUES (?, ?, ?)";
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			pstmt.setString(3, kit.getLocation());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						return rs.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
		}
		return 0;
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ?, location = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			pstmt.setString(3, kit.getLocation());
			pstmt.setInt(4, kit.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	private InventoryKit mapResultSetToKit(ResultSet rs) throws SQLException {
		InventoryKit kit = new InventoryKit();
		kit.setId(rs.getInt("id"));
		kit.setName(rs.getString("name"));
		kit.setDescription(rs.getString("description"));
		kit.setLocation(rs.getString("location"));
		kit.setItems(new ArrayList<>()); // Initialize item list
		return kit;
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return mapResultSetToKit(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
		}
		return null;
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	/**
	 * Efficiently fetches all kits and their associated items in a single query to
	 * avoid the N+1 problem.
	 *
	 * @return A list of InventoryKit objects, each populated with its list of
	 *         items.
	 */
	public List<InventoryKit> getAllKitsWithItems() {
		Map<Integer, InventoryKit> kitMap = new LinkedHashMap<>();
		String sql = "SELECT k.id, k.name, k.description, k.location, "
				+ "ki.item_id, ki.quantity, si.name as item_name " + "FROM inventory_kits k "
				+ "LEFT JOIN inventory_kit_items ki ON k.id = ki.kit_id "
				+ "LEFT JOIN storage_items si ON ki.item_id = si.id " + "ORDER BY k.name, si.name";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				int kitId = rs.getInt("id");
				InventoryKit kit = kitMap.computeIfAbsent(kitId, id -> {
					try {
						return mapResultSetToKit(rs);
					} catch (SQLException e) {
						throw new RuntimeException(e);
					}
				});

				if (rs.getInt("item_id") > 0) {
					InventoryKitItem item = new InventoryKitItem();
					item.setKitId(kitId);
					item.setItemId(rs.getInt("item_id"));
					item.setQuantity(rs.getInt("quantity"));
					item.setItemName(rs.getString("item_name"));
					kit.getItems().add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching all kits with their items", e);
		} catch (RuntimeException e) {
			// Un-wrap SQLException from the lambda
			logger.error("Error mapping result set in kit fetching", e.getCause());
		}
		return new ArrayList<>(kitMap.values());
	}

	public List<InventoryKitItem> getItemsForKit(int kitId) {
		List<InventoryKitItem> items = new ArrayList<>();
		String sql = "SELECT iki.*, si.name as item_name FROM inventory_kit_items iki "
				+ "JOIN storage_items si ON iki.item_id = si.id " + "WHERE iki.kit_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					InventoryKitItem item = new InventoryKitItem();
					item.setKitId(rs.getInt("kit_id"));
					item.setItemId(rs.getInt("item_id"));
					item.setQuantity(rs.getInt("quantity"));
					item.setItemName(rs.getString("item_name"));
					items.add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching items for kit ID {}", kitId, e);
		}
		return items;
	}

	public boolean updateKitItems(int kitId, String[] itemIds, String[] quantities) {
		String deleteSql = "DELETE FROM inventory_kit_items WHERE kit_id = ?";
		String insertSql = "INSERT INTO inventory_kit_items (kit_id, item_id, quantity) VALUES (?, ?, ?)";

		try (Connection conn = DatabaseManager.getConnection()) {
			conn.setAutoCommit(false);

			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, kitId);
				deleteStmt.executeUpdate();
			}

			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (int i = 0; i < itemIds.length; i++) {
						if (itemIds[i] == null || itemIds[i].isEmpty()) {
							continue;
						}
						int itemId = Integer.parseInt(itemIds[i]);
						int quantity = Integer.parseInt(quantities[i]);
						if (quantity > 0) {
							insertStmt.setInt(1, kitId);
							insertStmt.setInt(2, itemId);
							insertStmt.setInt(3, quantity);
							insertStmt.addBatch();
						}
					}
					insertStmt.executeBatch();
				}
			}
			conn.commit();
			logger.info("Successfully updated items for kit ID: {}", kitId);
			return true;
		} catch (SQLException | NumberFormatException e) {
			logger.error(
					"Error during transaction for updating kit items for kit ID {}. Transaction will be rolled back.",
					kitId, e);
			// Rollback is handled automatically by the try-with-resources on the Connection
			// when an exception occurs.
			return false;
		}
	}

	public List<InventoryKit> getAllKits() {
		List<InventoryKit> kits = new ArrayList<>();
		String sql = "SELECT * FROM inventory_kits ORDER BY name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				kits.add(mapResultSetToKit(rs));
			}
		} catch (SQLException e) {
			logger.error("Error fetching all inventory kits", e);
		}
		return kits;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing maintenance log entries in the `maintenance_log` table.
 */
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, log.getItemId());
			pstmt.setInt(2, log.getUserId());
			pstmt.setString(3, log.getAction());
			pstmt.setString(4, log.getNotes());
			pstmt.setDouble(5, log.getCost());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		List<MaintenanceLogEntry> history = new ArrayList<>();
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml " + "JOIN users u ON ml.user_id = u.id "
				+ "WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MaintenanceLogEntry entry = new MaintenanceLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
					entry.setAction(rs.getString("action"));
					entry.setNotes(rs.getString("notes"));
					entry.setCost(rs.getDouble("cost"));
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
		}
		return history;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling user attendance at specific course meetings.
 * It interacts with the `meeting_attendance` table to record whether a user
 * attended a meeting, along with any relevant remarks.
 */
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class.getName());

	/**
	 * Sets or updates a user's attendance status for a specific meeting. Uses an
	 * efficient "INSERT ... ON DUPLICATE KEY UPDATE" (upsert) operation. This
	 * single method handles both signing up (attended=true) and signing off
	 * (attended=false).
	 *
	 * @param userId    The user's ID.
	 * @param meetingId The meeting's ID.
	 * @param attended  true if the user attended, false otherwise.
	 * @param remarks   Any notes about the attendance (e.g., "excused absence").
	 * @return true if the operation was successful.
	 */
	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";

		logger.debug("Setting attendance for user {} at meeting {} to attended={}", userId, meetingId, attended);

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			pstmt.setInt(2, meetingId);
			pstmt.setBoolean(3, attended);
			pstmt.setString(4, remarks);

			pstmt.executeUpdate();
			logger.info("Successfully set attendance for user {} at meeting {} to attended={}", userId, meetingId,
					attended);
			return true;

		} catch (SQLException e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all attendance records from the database. This is highly efficient
	 * for building the data map used by the qualification matrix view.
	 * 
	 * @return A list of all MeetingAttendance objects in the database.
	 */
	public List<MeetingAttendance> getAllAttendance() {
		List<MeetingAttendance> allAttendance = new ArrayList<>();
		String sql = "SELECT * FROM meeting_attendance";
		logger.debug("Fetching all meeting attendance records for matrix.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				allAttendance.add(mapResultSetToAttendance(rs));
			}
			logger.info("Fetched {} total attendance records.", allAttendance.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all attendance records.", e);
		}
		return allAttendance;
	}

	/**
	 * Helper method to map a ResultSet row to a MeetingAttendance object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated MeetingAttendance object.
	 * @throws SQLException If a database error occurs.
	 */
	private MeetingAttendance mapResultSetToAttendance(ResultSet rs) throws SQLException {
		MeetingAttendance attendance = new MeetingAttendance();
		attendance.setUserId(rs.getInt("user_id"));
		attendance.setMeetingId(rs.getInt("meeting_id"));
		attendance.setAttended(rs.getBoolean("attended"));
		attendance.setRemarks(rs.getString("remarks"));
		return attendance;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;

/**
 * Data Access Object for all Meeting-related database operations. It handles
 * CRUD for individual, schedulable course meetings stored in the `meetings`
 * table. It's distinct from CourseDAO, which manages the parent course
 * templates.
 */
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);

	/**
	 * Creates a new meeting in the database, linked to a parent course.
	 * 
	 * @param meeting The Meeting object to create.
	 * @return The ID of the newly created meeting, or 0 on failure.
	 */
	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create meeting '{}' for course ID {}", meeting.getName(), meeting.getCourseId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

			pstmt.setInt(1, meeting.getCourseId());
			pstmt.setString(2, meeting.getName());
			pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(4, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(5, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			pstmt.setString(6, meeting.getDescription());
			pstmt.setString(7, meeting.getLocation());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int newId = rs.getInt(1);
						logger.info("Successfully created meeting '{}' with new ID {}", meeting.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating meeting: {}", meeting.getName(), e);
		}
		return 0; 
	}

	/**
	 * Fetches a single meeting by its ID, joining with the courses and users tables
	 * to get the parent course name and leader's username.
	 * 
	 * @param meetingId The ID of the meeting to retrieve.
	 * @return A Meeting object, or null if not found.
	 */
	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		logger.debug("Fetching meeting by ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found meeting with ID: {}", meetingId);
					return mapResultSetToMeeting(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meeting by ID: {}", meetingId, e);
		}
		logger.warn("No meeting found with ID: {}", meetingId);
		return null;
	}

	/**
	 * Fetches all scheduled meetings that belong to a specific parent course.
	 * Crucial for building the qualification matrix view.
	 * 
	 * @param courseId The ID of the parent course.
	 * @return A list of Meeting objects, sorted by date.
	 */
	public List<Meeting> getMeetingsForCourse(int courseId) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username "
				+ "FROM meetings m JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		logger.debug("Fetching all meetings for course ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					meetings.add(mapResultSetToMeeting(rs));
				}
				logger.info("Found {} meetings for course ID: {}", meetings.size(), courseId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meetings for course ID: {}", courseId, e);
		}
		return meetings;
	}

	/**
	 * Fetches all meetings from the database, typically for an admin list view.
	 * Includes the parent course name and leader's username.
	 * 
	 * @return A list of all Meeting objects.
	 */
	public List<Meeting> getAllMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id " + "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "ORDER BY m.meeting_datetime DESC";
		logger.debug("Fetching all meetings from the database.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
			logger.info("Fetched a total of {} meetings.", meetings.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all meetings.", e);
		}
		return meetings;
	}

	/**
	 * Helper method to map a row from a ResultSet to a Meeting object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Meeting object.
	 * @throws SQLException If a database error occurs.
	 */
	private Meeting mapResultSetToMeeting(ResultSet rs) throws SQLException {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));

		return meeting;
	}

	/**
	 * Updates an existing meeting in the database.
	 * 
	 * @param meeting The Meeting object with updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		logger.debug("Attempting to update meeting ID: {}", meeting.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, meeting.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(4, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(4, Types.INTEGER);
			}
			pstmt.setString(5, meeting.getDescription());
			pstmt.setString(6, meeting.getLocation());
			pstmt.setInt(7, meeting.getId());

			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated meeting with ID: {}", meeting.getId());
			return success;

		} catch (SQLException e) {
			logger.error("SQL error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a meeting from the database.
	 * 
	 * @param meetingId The ID of the meeting to delete.
	 * @return true if deletion was successful.
	 */
	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		logger.warn("Attempting to delete meeting with ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully deleted meeting with ID: {}", meetingId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all upcoming meetings, enriched with the attendance status for a
	 * specific user (ANGEMELDET, ABGEMELDET, OFFEN).
	 * 
	 * @param user The currently logged-in user.
	 * @return A list of upcoming Meeting objects with user-specific status.
	 */
	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended "
				+ "FROM meetings m " + "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? "
				+ "WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";

		logger.debug("Fetching upcoming meetings for user ID: {}", user.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, user.getId());
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Meeting meeting = mapResultSetToMeeting(rs);

					if (rs.getObject("attended") != null) {
						meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
					} else {
						meeting.setUserAttendanceStatus("OFFEN");
					}
					meetings.add(meeting);
				}
				logger.info("Found {} upcoming meetings for user ID: {}", meetings.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for user {}", user.getId(), e);
		}
		return meetings;
	}

	/**
	 * Fetches all upcoming meetings. This is a simplified query for use in the
	 * calendar/iCal feeds.
	 * 
	 * @return A list of all relevant Meeting objects.
	 */
	public List<Meeting> getAllUpcomingMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id " + "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		logger.debug("Fetching all upcoming meetings for calendar feed.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for calendar.", e);
		}
		return meetings;
	}

	/**
	 * Checks if a given user is registered as attended for a specific meeting.
	 * @param meetingId The ID of the meeting.
	 * @param userId The ID of the user.
	 * @return true if the user has an attendance record, false otherwise.
	 */
	public boolean isUserAssociatedWithMeeting(int meetingId, int userId) {
	    String sql = "SELECT 1 FROM meeting_attendance WHERE meeting_id = ? AND user_id = ?";
	    try (Connection conn = DatabaseManager.getConnection();
	         PreparedStatement pstmt = conn.prepareStatement(sql)) {
	        pstmt.setInt(1, meetingId);
	        pstmt.setInt(2, userId);
	        try (ResultSet rs = pstmt.executeQuery()) {
	            return rs.next();
	        }
	    } catch (SQLException e) {
	        logger.error("Error checking user association for meeting {} and user {}", meetingId, userId, e);
	        return false;
	    }
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\PermissionDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Permission;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class PermissionDAO {
	private static final Logger logger = LogManager.getLogger(PermissionDAO.class);

	public List<Permission> getAllPermissions() {
		List<Permission> permissions = new ArrayList<>();
		String sql = "SELECT * FROM permissions ORDER BY description";
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			while (rs.next()) {
				Permission p = new Permission();
				p.setId(rs.getInt("id"));
				p.setPermissionKey(rs.getString("permission_key"));
				p.setDescription(rs.getString("description"));
				permissions.add(p);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all permissions", e);
		}
		return permissions;
	}

	public Set<Integer> getPermissionIdsForUser(int userId) {
		Set<Integer> permissionIds = new HashSet<>();
		String sql = "SELECT permission_id FROM user_permissions WHERE user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					permissionIds.add(rs.getInt("permission_id"));
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching permission IDs for user {}", userId, e);
		}
		return permissionIds;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ParticipationHistory;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);

	public List<Map<String, Object>> getEventParticipationSummary() {
		List<Map<String, Object>> summary = new ArrayList<>();
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_assignments ea ON e.id = ea.event_id " + "GROUP BY e.id, e.name "
				+ "ORDER BY participant_count DESC, e.event_datetime DESC";
		logger.debug("Executing event participation summary query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("event_name", rs.getString("event_name"));
				row.put("participant_count", rs.getInt("participant_count"));
				summary.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating event participation summary.", e);
		}
		return summary;
	}

	public List<Map<String, Object>> getUserActivityStats() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		logger.debug("Executing user activity stats query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("username", rs.getString("username"));
				row.put("events_signed_up", rs.getInt("events_signed_up"));
				row.put("meetings_attended", rs.getInt("meetings_attended"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating user activity stats.", e);
		}
		return stats;
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT si.name AS item_name, SUM(ABS(sl.quantity_change)) AS total_quantity_checked_out "
				+ "FROM storage_items si " + "JOIN storage_log sl ON si.id = sl.item_id "
				+ "WHERE sl.quantity_change < 0 " + "GROUP BY si.id, si.name "
				+ "ORDER BY total_quantity_checked_out DESC";
		logger.debug("Executing inventory usage frequency query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("item_name", rs.getString("item_name"));
				row.put("total_quantity_checked_out", rs.getInt("total_quantity_checked_out"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating inventory usage frequency report.", e);
		}
		return stats;
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		logger.debug("Executing total inventory value query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			if (rs.next()) {
				return rs.getDouble("total_value");
			}
		} catch (SQLException e) {
			logger.error("Error calculating total inventory value.", e);
		}
		return 0.0;
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT CONCAT(YEAR(event_datetime), '-', LPAD(MONTH(event_datetime), 2, '0')) AS month, COUNT(*) AS count "
				+ "FROM events " + "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, months);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("month", rs.getString("month"));
					row.put("count", rs.getInt("count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating event count by month report.", e);
		}
		return data;
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("username", rs.getString("username"));
					row.put("participation_count", rs.getInt("participation_count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating user participation stats.", e);
		}
		return data;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Role;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * A minimal DAO to fetch role information for populating UI elements. It is no
 * longer responsible for managing permissions.
 */
public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);

	public List<Role> getAllRoles() {
		List<Role> roles = new ArrayList<>();
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {

			while (rs.next()) {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				roles.add(role);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all roles", e);
		}
		return roles;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * A simple Data Access Object used to retrieve basic aggregate numbers from the
 * database, such as the total count of users and the number of active, upcoming
 * events. This is primarily used for the administrative dashboard.
 */

public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);

	/**
	 * Gets the total count of all users in the `users` table.
	 * 
	 * @return The total number of users.
	 */
	public int getUserCount() {
		logger.debug("Getting user count.");
		return getCount("SELECT COUNT(*) FROM users");
	}

	/**
	 * Gets the count of all events that are not yet in the past.
	 * 
	 * @return The number of active/upcoming events.
	 */
	public int getActiveEventCount() {
		logger.debug("Getting active event count.");
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	/**
	 * A generic helper method to execute a `SELECT COUNT(*)` query.
	 * 
	 * @param sql The SQL query to execute.
	 * @return The count, or 0 if an error occurs.
	 */
	private int getCount(String sql) {
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			if (rs.next()) {
				int count = rs.getInt(1);
				logger.info("Count query '{}' returned {}.", sql, count);
				return count;
			}
		} catch (SQLException e) {
			logger.error("SQL error executing count query: {}", sql, e);
		}
		return 0;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * DAO for managing inventory in the `storage_items` table.
 */
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class.getName());

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream().collect(Collectors.groupingBy(item -> item.getLocation().trim()));
	}

	public List<StorageItem> getAllItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.*, u.username as holder_username " + "FROM storage_items si "
				+ "LEFT JOIN users u ON si.current_holder_user_id = u.id " + "ORDER BY si.name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching all storage items.", e);
		}
		return items;
	}

	public List<StorageItem> getDefectiveItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching defective items.", e);
		}
		return items;
	}

	private StorageItem mapResultSetToStorageItem(ResultSet rs) throws SQLException {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username " + "FROM storage_items si "
				+ "LEFT JOIN users u ON si.current_holder_user_id = u.id " + "WHERE si.id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			ResultSet rs = pstmt.executeQuery();
			if (rs.next()) {
				return mapResultSetToStorageItem(rs);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage item by ID: {}", itemId, e);
		}
		return null;
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setDouble(7, item.getWeightKg());
			pstmt.setDouble(8, item.getPriceEur());
			pstmt.setString(9, item.getImagePath());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setInt(7, item.getDefectiveQuantity());
			pstmt.setString(8, item.getDefectReason());
			pstmt.setDouble(9, item.getWeightKg());
			pstmt.setDouble(10, item.getPriceEur());
			pstmt.setString(11, item.getImagePath());
			pstmt.setString(12, item.getStatus());
			if (item.getCurrentHolderUserId() > 0)
				pstmt.setInt(13, item.getCurrentHolderUserId());
			else
				pstmt.setNull(13, Types.INTEGER);
			if (item.getAssignedEventId() > 0)
				pstmt.setInt(14, item.getAssignedEventId());
			else
				pstmt.setNull(14, Types.INTEGER);
			pstmt.setInt(15, item.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean performCheckout(int itemId, int quantity, int userId, Integer eventId) throws SQLException {
		String sql = "UPDATE storage_items "
				+ "SET quantity = quantity - ?, status = 'CHECKED_OUT', current_holder_user_id = ?, assigned_event_id = ? "
				+ "WHERE id = ? AND (quantity - defective_quantity) >= ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantity);
			pstmt.setInt(2, userId);
			if (eventId != null) {
				pstmt.setInt(3, eventId);
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setInt(4, itemId);
			pstmt.setInt(5, quantity);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean performCheckin(int itemId, int quantity) throws SQLException {
		String sql = "UPDATE storage_items "
				+ "SET quantity = quantity + ?, status = 'IN_STORAGE', current_holder_user_id = NULL, assigned_event_id = NULL "
				+ "WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantity);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean updateDefectiveStatus(int itemId, int defectiveQty, String reason) throws SQLException {
		String sql = "UPDATE storage_items SET defective_quantity = ?, defect_reason = ? WHERE id = ? AND ? <= quantity";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, defectiveQty);
			pstmt.setString(2, reason);
			pstmt.setInt(3, itemId);
			pstmt.setInt(4, defectiveQty);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean repairItems(int itemId, int repairedQuantity) throws SQLException {
		String sql = "UPDATE storage_items "
				+ "SET defective_quantity = defective_quantity - ?, status = CASE WHEN (defective_quantity - ?) <= 0 THEN 'IN_STORAGE' ELSE status END "
				+ "WHERE id = ? AND defective_quantity >= ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, repairedQuantity);
			pstmt.setInt(2, repairedQuantity);
			pstmt.setInt(3, itemId);
			pstmt.setInt(4, repairedQuantity);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public boolean updateItemStatus(int itemId, String status) {
		String sql = "UPDATE storage_items SET status = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating status for item ID: {}", itemId, e);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for logging storage item transactions (check-ins and
 * check-outs) into the `storage_log` table. This provides a history of
 * inventory movements.
 */
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);

	/**
	 * Logs a single transaction (check-in or check-out) to the database.
	 * 
	 * @param itemId         The ID of the item involved in the transaction.
	 * @param userId         The ID of the user performing the transaction.
	 * @param quantityChange The number of items moved (positive for check-in,
	 *                       negative for check-out).
	 * @param notes          Optional notes for the transaction (e.g., purpose,
	 *                       event).
	 * @param eventId        Optional ID of the event this transaction is for.
	 * @return true if the log entry was created successfully.
	 */
	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Logging storage transaction for item {}, user {}, change {}, event {}", itemId, userId,
				quantityChange, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, quantityChange);
			pstmt.setString(4, notes);
			if (eventId > 0) {
				pstmt.setInt(5, eventId);
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Failed to log storage transaction for item {}", itemId, e);
			return false;
		}
	}

	/**
	 * Fetches the transaction history for a specific storage item.
	 * 
	 * @param itemId The ID of the item.
	 * @return A list of storage log entries.
	 */
	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		List<StorageLogEntry> history = new ArrayList<>();
		String sql = "SELECT sl.*, u.username FROM storage_log sl " + "JOIN users u ON sl.user_id = u.id "
				+ "WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		logger.debug("Fetching storage history for item ID: {}", itemId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					StorageLogEntry entry = new StorageLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setQuantityChange(rs.getInt("quantity_change"));
					entry.setNotes(rs.getString("notes"));
					entry.setEventId(rs.getInt("event_id"));
					entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
		}
		return history;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);
	private final PermissionDAO permissionDAO = new PermissionDAO();
	private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

	private User mapResultSetToUser(ResultSet resultSet) throws SQLException {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		if (DaoUtils.hasColumn(resultSet, "theme")) {
			user.setTheme(resultSet.getString("theme"));
		}
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	}

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u " + "LEFT JOIN roles r ON u.role_id = r.id "
				+ "WHERE u.username = ?";
		logger.debug("Attempting to validate user: {}", username);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

			preparedStatement.setString(1, username);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					String storedHash = resultSet.getString("password_hash");
					if (passwordEncoder.matches(password, storedHash)) {
						logger.info("User validation successful for username: {}", username);
						User user = mapResultSetToUser(resultSet);
						user.setPermissions(getPermissionsForUser(user.getId()));
						return user;
					}
				}
				logger.warn("User validation failed for username: {}. Incorrect username or password.", username);
			}
		} catch (SQLException exception) {
			logger.error("SQL error during user validation for username: {}", username, exception);
		} catch (IllegalArgumentException e) {
			logger.error("BCrypt Error: The stored password for user '{}' is not a valid hash. "
					+ "Please run a password migration utility.", username, e);
		}
		return null;
	}

	public Set<String> getPermissionsForUser(int userId) {
		Set<String> permissions = new HashSet<>();
		String sql = "SELECT p.permission_key FROM permissions p "
				+ "JOIN user_permissions up ON p.id = up.permission_id " + "WHERE up.user_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					permissions.add(resultSet.getString("permission_key"));
				}
			}
		} catch (SQLException exception) {
			logger.error("Could not fetch permissions for user ID: {}", userId, exception);
		}
		logger.debug("Fetched {} permissions for user ID {}", permissions.size(), userId);
		return permissions;
	}

	public boolean updateUserPermissions(int userId, String[] permissionIds) {
		String deleteSql = "DELETE FROM user_permissions WHERE user_id = ?";
		String insertSql = "INSERT INTO user_permissions (user_id, permission_id) VALUES (?, ?)";
		Connection conn = null;

		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false);

			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, userId);
				deleteStmt.executeUpdate();
			}

			if (permissionIds != null && permissionIds.length > 0) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (String permId : permissionIds) {
						insertStmt.setInt(1, userId);
						insertStmt.setInt(2, Integer.parseInt(permId));
						insertStmt.addBatch();
					}
					insertStmt.executeBatch();
				}
			}

			conn.commit();
			logger.info("Successfully updated permissions for user ID: {}", userId);
			return true;
		} catch (SQLException | NumberFormatException e) {
			logger.error("Error during transaction for updating user permissions for user ID {}. Rolling back.", userId,
					e);
			if (conn != null) {
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction for user permissions update.", ex);
				}
			}
			return false;
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection after user permissions update.", ex);
				}
			}
		}
	}

	public List<User> getAllUsers() {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		logger.debug("Fetching all users.");
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql);
				ResultSet resultSet = preparedStatement.executeQuery()) {
			while (resultSet.next()) {
				users.add(mapResultSetToUser(resultSet));
			}
			logger.info("Fetched {} total users.", users.size());
		} catch (SQLException exception) {
			logger.error("SQL error fetching all users", exception);
		}
		return users;
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		logger.debug("Fetching user by ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found user '{}' with ID: {}", resultSet.getString("username"), userId);
					return mapResultSetToUser(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by ID: {}", userId, exception);
		}
		logger.warn("No user found with ID: {}", userId);
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		logger.debug("Fetching user by username: {}", username);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, username);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found user with username: {}", username);
					return mapResultSetToUser(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by username: {}", username, exception);
		}
		logger.warn("No user found with username: {}", username);
		return null;
	}

	public int createUser(User user, String password) {
		String hashedPassword = passwordEncoder.encode(password);

		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email, theme) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create user: {}", user.getUsername());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {

			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setString(2, hashedPassword);
			preparedStatement.setInt(3, user.getRoleId());
			preparedStatement.setInt(4, user.getClassYear());
			preparedStatement.setString(5, user.getClassName());
			preparedStatement.setString(6, user.getEmail());
			preparedStatement.setString(7, "light"); // Default theme

			int affectedRows = preparedStatement.executeUpdate();

			if (affectedRows > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newUserId = generatedKeys.getInt(1);
						logger.info("Successfully created user '{}' with ID: {}", user.getUsername(), newUserId);
						return newUserId;
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error creating user '{}'. Username or email might already exist.", user.getUsername(),
					exception);
		}
		return 0;
	}

	public boolean updateUser(User user) {
		logger.debug("Updating user with ID: {}", user.getId());
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ? WHERE id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setInt(2, user.getRoleId());
			preparedStatement.setInt(3, user.getClassYear());
			preparedStatement.setString(4, user.getClassName());
			preparedStatement.setString(5, user.getEmail());
			preparedStatement.setInt(6, user.getId());
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error updating user with ID: {}", user.getId(), exception);
			return false;
		}
	}

	public boolean updateUserTheme(int userId, String theme) {
		String sql = "UPDATE users SET theme = ? WHERE id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, theme);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating theme for user ID {}", userId, exception);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, chatColor);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating chat color for user ID {}", userId, exception);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		logger.warn("Attempting to delete user with ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error deleting user with ID: {}", userId, exception);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String hashedPassword = passwordEncoder.encode(newPassword);

		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		logger.debug("Changing password for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, hashedPassword);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error changing password for user ID: {}", userId, exception);
			return false;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import de.technikteam.service.AchievementService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.UserQualification;

/**
 * This DAO manages the `user_qualifications` table, which links users to the
 * courses they have completed. It's used to track which skills a user
 * possesses. Its key functions are fetching qualifications for a single user or
 * all users, and updating a user's qualification status for a specific course.
 */
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);

	/**
	 * Fetches all qualifications for a single user. This is typically used for a
	 * user's profile or details page.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of UserQualification objects.
	 */
	public List<UserQualification> getQualificationsForUser(int userId) {
		logger.debug("Fetching qualifications for user ID: {}", userId);
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id " + "WHERE uq.user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					qualifications.add(mapResultSetToUserQualification(rs));
				}
				logger.info("Found {} qualifications for user ID: {}", qualifications.size(), userId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
		}
		return qualifications;
	}

	/**
	 * Fetches all qualification records for all users. This is used to build the
	 * data for an overview or matrix page.
	 * 
	 * @return A list of all UserQualification objects in the database.
	 */
	public List<UserQualification> getAllQualifications() {
		logger.debug("Fetching all user qualifications.");
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.user_id, uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				qualifications.add(mapResultSetToUserQualification(rs));
			}
			logger.info("Fetched a total of {} qualification entries.", qualifications.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all qualifications.", e);
		}
		return qualifications;
	}

	/**
	 * Updates or creates a qualification status for a user and a course. If the
	 * status is set to "NICHT BESUCHT", the corresponding record is deleted.
	 * Otherwise, it performs an "upsert" (INSERT ... ON DUPLICATE KEY UPDATE) to
	 * create or modify the record. This is a key method for admin management of
	 * user skills.
	 * 
	 * @param userId         The ID of the user.
	 * @param courseId       The ID of the course.
	 * @param status         The new status ('BESUCHT', 'ABSOLVIERT', or 'NICHT
	 *                       BESUCHT').
	 * @param completionDate The date of completion (can be null).
	 * @param remarks        Additional remarks (can be null).
	 * @return true if the operation was successful, false otherwise.
	 */
	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		logger.debug("DAO: Updating qualification for user {}, course {}. New status: {}, Date: {}, Remarks: '{}'",
				userId, courseId, status, completionDate, remarks);

		if ("NICHT BESUCHT".equals(status)) {
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(deleteSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				int affectedRows = pstmt.executeUpdate();
				logger.info("Deleted qualification entry for user {} and course {}. Rows affected: {}", userId,
						courseId, affectedRows);
				return true;
			} catch (SQLException e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) "
					+ "ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(upsertSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.setString(3, status);

				if (completionDate != null) {
					pstmt.setDate(4, Date.valueOf(completionDate));
				} else {
					pstmt.setNull(4, Types.DATE);
				}

				pstmt.setString(5, remarks);

				int affectedRows = pstmt.executeUpdate();
				logger.info("Upserted qualification for user {} and course {}. Rows affected: {}", userId, courseId,
						affectedRows);

				// TODO: Check and grant achievements

				return affectedRows >= 0;
			} catch (SQLException e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}

	/**
	 * Maps a row from a ResultSet to a UserQualification object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated UserQualification object.
	 * @throws SQLException If a database error occurs.
	 */
	private UserQualification mapResultSetToUserQualification(ResultSet rs) throws SQLException {
		UserQualification uq = new UserQualification();
		if (hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}

	public int batchGrantQualifications(int courseId, int minMeetings) {
		String sql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) "
				+ "SELECT user_id, ?, 'ABSOLVIERT', CURDATE(), 'Automatisch vergeben' " + "FROM meeting_attendance "
				+ "WHERE attended = TRUE AND meeting_id IN (SELECT id FROM meetings WHERE course_id = ?) "
				+ "GROUP BY user_id " + "HAVING COUNT(meeting_id) >= ? " + "ON DUPLICATE KEY UPDATE "
				+ "status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, courseId);
			pstmt.setInt(2, courseId);
			pstmt.setInt(3, minMeetings);
			int affectedRows = pstmt.executeUpdate();
			logger.info("Batch granted qualifications for course ID {} with min {} meetings. {} users updated.",
					courseId, minMeetings, affectedRows);
			return affectedRows;
		} catch (SQLException e) {
			logger.error("Error during batch qualification grant for course ID {}", courseId, e);
			return -1; // Indicate error
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AdminFilter.java
========================================================================

package de.technikteam.filter;

import de.technikteam.model.User;
import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

@WebFilter(urlPatterns = { "/admin/*", "/api/admin/*" }, asyncSupported = true)
public class AdminFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AdminFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AdminFilter initialized and protecting /admin/* and /api/admin/* paths.");
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);
		String path = request.getRequestURI().substring(request.getContextPath().length());
		logger.trace("AdminFilter is processing request for path: '{}'", path);

		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Admin access DENIED to path '{}'. No active session found. Redirecting to login.", path);
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		User user = (User) session.getAttribute("user");

		if (user.hasAdminAccess()) {
			logger.debug(
					"ADMIN area access GRANTED for user '{}' to path '{}'. User has at least one admin permission.",
					user.getUsername(), path);
			chain.doFilter(request, response);
		} else {
			logger.warn(
					"ADMIN access DENIED for user '{}' (Role: '{}') to path '{}'. No relevant admin permissions found.",
					user.getUsername(), user.getRoleName(), path);
			request.getSession().setAttribute("accessErrorMessage",
					"Sie haben keine Berechtigung, auf den Admin-Bereich zuzugreifen.");
			response.sendError(HttpServletResponse.SC_FORBIDDEN,
					"Sie haben keine Berechtigung, auf diesen Bereich zuzugreifen.");
		}
	}

	@Override
	public void destroy() {
		logger.info("AdminFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AuthenticationFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

@WebFilter(value = "/*", asyncSupported = true)
public class AuthenticationFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AuthenticationFilter.class.getName());

	private static final Set<String> PUBLIC_PATHS = new HashSet<>(Arrays.asList("/login", "/logout", "/calendar.ics"));

	private static final Set<String> PUBLIC_RESOURCE_PREFIXES = new HashSet<>(
			Arrays.asList("/css", "/js", "/images", "/error", "/public", "/vendor", "/wopi"));

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AuthenticationFilter initialized. Public paths: {}, Public prefixes: {}", PUBLIC_PATHS,
				PUBLIC_RESOURCE_PREFIXES);
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String contextPath = request.getContextPath();
		String requestUri = request.getRequestURI();

		// Strip jsessionid from the path, if present
		String path = requestUri.substring(contextPath.length());
		int semicolonIndex = path.indexOf(';');
		if (semicolonIndex != -1) {
			path = path.substring(0, semicolonIndex);
		}

		logger.trace("AuthenticationFilter processing request for path: '{}'", path);

		boolean isLoggedIn = (session != null && session.getAttribute("user") != null);

		// Assign to a final variable to be used in lambda, ensuring compiler
		// compatibility
		final String finalPath = path;
		boolean isPublicResource = PUBLIC_PATHS.contains(finalPath)
				|| PUBLIC_RESOURCE_PREFIXES.stream().anyMatch(prefix -> finalPath.startsWith(prefix));

		if (isLoggedIn || isPublicResource) {
			logger.trace("Access granted for path '{}'. LoggedIn: {}, IsPublic: {}", finalPath, isLoggedIn,
					isPublicResource);
			chain.doFilter(request, response);
		} else {
			logger.warn("Unauthorized access attempt by a guest to protected path: '{}'. Redirecting to login page.",
					finalPath);
			response.sendRedirect(contextPath + "/login");
		}
	}

	@Override
	public void destroy() {
		logger.info("AuthenticationFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\CharacterEncodingFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;

/**
 * A crucial utility filter that intercepts all incoming requests (`/*`) to set
 * the character encoding to UTF-8. This ensures that any data submitted in
 * requests (e.g., form fields with special characters like German umlauts) and
 * any content sent in responses is correctly interpreted and rendered by the
 * browser. It should be the first filter in the chain.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class CharacterEncodingFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(CharacterEncodingFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("CharacterEncodingFilter initialized and set to enforce UTF-8.");
	}

	/**
	 * Sets the character encoding for both the request and response to UTF-8.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		logger.trace("Applying UTF-8 character encoding to request and response.");

		request.setCharacterEncoding("UTF-8");

		response.setCharacterEncoding("UTF-8");

		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
		logger.info("CharacterEncodingFilter destroyed.");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\AppContextListener.java
========================================================================

package de.technikteam.listener;

import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.mysql.cj.jdbc.AbandonedConnectionCleanupThread;

import de.technikteam.util.WopiTokenManager;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * This is an application lifecycle listener that performs crucial cleanup tasks
 * when the web application is shut down or undeployed from the server. Its
 * primary purpose is to manually deregister the JDBC driver that was loaded by
 * this application's classloader. This prevents potential memory leaks in
 * application servers like Tomcat. It also explicitly shuts down the MySQL
 * cleanup thread and the WOPI Token Manager's thread pool.
 */
@WebListener
public class AppContextListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(AppContextListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Initialized <<<<<<<<<<");
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Being Destroyed. Cleaning up resources... <<<<<<<<<<");

		try {
			logger.info("Attempting to shut down WOPI Token Manager thread pool...");
			WopiTokenManager.getInstance().shutdown();
			logger.info("WOPI Token Manager shutdown signal sent.");
		} catch (Exception e) {
			logger.error("Error shutting down WOPI Token Manager.", e);
		}

		try {
			logger.info("Attempting to shut down MySQL abandoned connection cleanup thread...");
			AbandonedConnectionCleanupThread.checkedShutdown();
			logger.info("MySQL cleanup thread shutdown signal sent.");
		} catch (Exception e) {
			logger.error("Error shutting down MySQL cleanup thread.", e);
		}

		Enumeration<java.sql.Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			java.sql.Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getClass().getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
					logger.info("Deregistering JDBC driver: {}", driver);
				} catch (SQLException e) {
					logger.error("Error deregistering JDBC driver: {}", driver, e);
				}
			} else {
				logger.trace("Not deregistering JDBC driver {} as it does not belong to this webapp's classloader.",
						driver);
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\ApplicationInitializerListener.java
========================================================================

package de.technikteam.listener;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.dao.DatabaseManager;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * An application lifecycle listener that runs when the application starts. It
 * performs two critical initialization tasks: 1. Manually loads the MySQL JDBC
 * driver to ensure it's available for the application. This is a robust
 * practice that prevents connectivity issues if the server's automatic service
 * discovery fails. 2. Explicitly triggers the initialization of the
 * `DatabaseManager` and its connection pool, and ensures the pool is closed on
 * application shutdown.
 */
@WebListener
public class ApplicationInitializerListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(ApplicationInitializerListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being initialized...");

		try {
			logger.info("Attempting to manually load MySQL JDBC driver...");
			Class.forName("com.mysql.cj.jdbc.Driver");
			logger.info("MySQL JDBC driver loaded successfully.");

			logger.info("Triggering database connection pool initialization...");
			DatabaseManager.initDataSource();

		} catch (ClassNotFoundException e) {
			logger.fatal("FATAL: MySQL JDBC driver not found in classpath. Application will fail.", e);
			throw new RuntimeException("Failed to load JDBC driver", e);
		} catch (Exception e) {
			logger.fatal("FATAL: Database pool could not be initialized. Application startup aborted.", e);
			throw new RuntimeException("Failed to initialize database pool", e);
		}
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being destroyed.");
		DatabaseManager.closeDataSource();
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Achievement.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Achievement {
	private int id;
	private String achievementKey;
	private String name;
	private String description;
	private String iconClass;
	private LocalDateTime earnedAt;

	public String getFormattedEarnedAt() {
		if (earnedAt == null)
			return "";
		return earnedAt.format(DateTimeFormatter.ofPattern("dd.MM.yyyy"));
	}

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAchievementKey() {
		return achievementKey;
	}

	public void setAchievementKey(String achievementKey) {
		this.achievementKey = achievementKey;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getIconClass() {
		return iconClass;
	}

	public void setIconClass(String iconClass) {
		this.iconClass = iconClass;
	}

	public LocalDateTime getEarnedAt() {
		return earnedAt;
	}

	public void setEarnedAt(LocalDateTime earnedAt) {
		this.earnedAt = earnedAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Attachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the unified `attachments` table. It links a
 * file (with its path and name) to a specific parent entity (like an Event or
 * Meeting) and includes a `requiredRole` to control its visibility.
 */
public class Attachment {
	private int id;
	private String parentType; // "EVENT" or "MEETING"
	private int parentId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getParentType() {
		return parentType;
	}

	public void setParentType(String parentType) {
		this.parentType = parentType;
	}

	public int getParentId() {
		return parentId;
	}

	public void setParentId(int parentId) {
		this.parentId = parentId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus;

	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<Attachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields;

	// Transient field for view logic
	private boolean isUserQualified;

	public Event() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<Attachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<Attachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	public boolean isUserQualified() {
		return isUserQualified;
	}

	public void setUserQualified(boolean isUserQualified) {
		this.isUserQualified = isUserQualified;
	}

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; 
	private String signupStatus; 
	private String commitmentStatus;

	public EventAttendance() {
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean edited;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor; 

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status,
 * required personnel, ordering, and linked equipment.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String details; 
	private String status;
	private String eventName;

	private int displayOrder;
	private int requiredPersons;

	private List<User> assignedUsers;
	private List<StorageItem> requiredItems;
	private List<InventoryKit> requiredKits;

	private String assignedUsernames;

	public String getAssignedUsernames() {
		if (assignedUsers != null && !assignedUsers.isEmpty()) {
			return assignedUsers.stream().map(User::getUsername).collect(Collectors.joining(", "));
		}
		return "Niemand";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public void setAssignedUsernames(String assignedUsernames) {
		this.assignedUsernames = assignedUsernames;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public int getDisplayOrder() {
		return displayOrder;
	}

	public void setDisplayOrder(int displayOrder) {
		this.displayOrder = displayOrder;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}

	public List<User> getAssignedUsers() {
		return assignedUsers;
	}

	public void setAssignedUsers(List<User> assignedUsers) {
		this.assignedUsers = assignedUsers;
	}

	public List<StorageItem> getRequiredItems() {
		return requiredItems;
	}

	public void setRequiredItems(List<StorageItem> requiredItems) {
		this.requiredItems = requiredItems;
	}

	public List<InventoryKit> getRequiredKits() {
		return requiredKits;
	}

	public void setRequiredKits(List<InventoryKit> requiredKits) {
		this.requiredKits = requiredKits;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName;
	private LocalDateTime uploadedAt;
	private String requiredRole;

	public String getFormattedUploadedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.uploadedAt);
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;
	private String location; 

	private List<InventoryKitItem> items;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;
	private String itemName;
	
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	private String username;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	private String parentCourseName;
	private String leaderUsername;
	private String userAttendanceStatus;

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Permission.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single permission from the `permissions` table. It defines a
 * specific, granular action that can be assigned to a role.
 */
public class Permission {
	private int id;
	private String permissionKey;
	private String description;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getPermissionKey() {
		return permissionKey;
	}

	public void setPermissionKey(String permissionKey) {
		this.permissionKey = permissionKey;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;
    
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;
	private String courseName;

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	private String status;
	private int currentHolderUserId;
	private int assignedEventId;
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		if (this.getAvailableQuantity() <= 0) {
			return "Vergriffen";
		}
		if (this.maxQuantity > 0 && this.getAvailableQuantity() >= this.maxQuantity) {
			return "Vollständig";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		if (this.getAvailableQuantity() <= 0) {
			return "status-danger";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; 
	private LocalDateTime transactionTimestamp;

	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor;
	private String theme;

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	/**
	 * A central method to determine if the user has any permission that grants them
	 * access to the admin panel. This prevents logic duplication in filters and
	 * navigation builders.
	 *
	 * @return true if the user has any admin-level permission, false otherwise.
	 */
	public boolean hasAdminAccess() {
		if (permissions == null) {
			return false;
		}
		// A user has admin access if they have the master key OR any other specific
		// admin-level permission.
		return permissions.contains("ACCESS_ADMIN_PANEL") || permissions.stream()
				.anyMatch(p -> !"ACCESS_ADMIN_PANEL".equals(p) && (p.contains("_READ") || p.contains("_MANAGE")
						|| p.contains("_UPDATE") || p.contains("_CREATE") || p.contains("_DELETE")));
	}

	// --- Standard Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}

	public String getTheme() {
		return theme;
	}

	public void setTheme(String theme) {
		this.theme = theme;
	}

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; 
	private String status; 
	private LocalDate completionDate;
	private String remarks;

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AchievementService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.List;

public class AchievementService {
	private static final Logger logger = LogManager.getLogger(AchievementService.class);
	private static final AchievementService INSTANCE = new AchievementService();

	private final AchievementDAO achievementDAO = new AchievementDAO();
	private final EventDAO eventDAO = new EventDAO();

	private AchievementService() {
	}

	public static AchievementService getInstance() {
		return INSTANCE;
	}

	public void checkAndGrantAchievements(User user, String triggerType) {
		switch (triggerType) {
		case "EVENT_COMPLETED":
			checkEventParticipationAchievements(user);
			checkEventLeaderAchievements(user);
			break;
		case "QUALIFICATION_GAINED":
			// This would be called from UserQualificationsDAO after an update
			break;
		}
	}

	private void checkEventParticipationAchievements(User user) {
		int completedEvents = eventDAO.getCompletedEventsForUser(user.getId()).size();
		logger.debug("Checking event participation achievements for user {}. Completed events: {}", user.getUsername(),
				completedEvents);
		if (completedEvents >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_1");
		}
		if (completedEvents >= 5) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_5");
		}
		if (completedEvents >= 10) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_PARTICIPANT_10");
		}
	}

	private void checkEventLeaderAchievements(User user) {
		List<Event> allEvents = eventDAO.getAllEvents();
		long ledEventsCount = allEvents.stream()
				.filter(event -> event.getLeaderUserId() == user.getId() && "ABGESCHLOSSEN".equals(event.getStatus()))
				.count();

		if (ledEventsCount >= 1) {
			achievementDAO.grantAchievementToUser(user.getId(), "EVENT_LEADER_1");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * A simple service layer that acts as a middleman for logging administrative
 * actions. It provides a static `log` method that other parts of the
 * application can call to create an audit log entry. This decouples the
 * application logic from the direct use of the AdminLogDAO.
 */
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private static final AdminLogDAO logDAO = new AdminLogDAO();

	/**
	 * Removes characters that could be used for log injection attacks.
	 * 
	 * @param input The string to sanitize.
	 * @return The sanitized string.
	 */
	private static String sanitize(String input) {
		if (input == null) {
			return "";
		}
		return input.replace('\n', '_').replace('\r', '_');
	}

	/**
	 * Creates and persists an administrative audit log entry. This is the central
	 * point for all audit logging.
	 * 
	 * @param adminUsername The username of the admin performing the action.
	 * @param actionType    A high-level category for the action (e.g.,
	 *                      "UPDATE_USER", "DELETE_EVENT").
	 * @param details       A detailed, human-readable description of the action and
	 *                      its context.
	 */
	public static void log(String adminUsername, String actionType, String details) {
		try {
			String saneAdminUsername = sanitize(adminUsername);
			String saneActionType = sanitize(actionType);
			String saneDetails = sanitize(details);

			AdminLog log = new AdminLog();
			log.setAdminUsername(saneAdminUsername);
			log.setActionType(saneActionType);
			log.setDetails(saneDetails);

			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", saneAdminUsername, saneActionType,
					saneDetails);

			logDAO.createLog(log);
		} catch (Exception e) {
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					sanitize(adminUsername), sanitize(actionType), sanitize(details), e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

import com.google.gson.Gson;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.User;
import jakarta.servlet.AsyncContext;
import jakarta.servlet.http.HttpServletRequest;

public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);
	private static final NotificationService INSTANCE = new NotificationService();
	private final Gson gson = new Gson();

	private final Map<Integer, List<AsyncContext>> contextsByUser = new ConcurrentHashMap<>();

	private NotificationService() {
	}

	public static NotificationService getInstance() {
		return INSTANCE;
	}

	public void register(HttpServletRequest request) {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			logger.warn("Attempt to register for notifications from a non-authenticated session.");
			return;
		}

		AsyncContext asyncContext = request.startAsync();
		asyncContext.setTimeout(0);

		contextsByUser.computeIfAbsent(user.getId(), k -> new CopyOnWriteArrayList<>()).add(asyncContext);
		logger.info("New client registered for SSE notifications for user ID {}. Total clients for user: {}",
				user.getId(), contextsByUser.get(user.getId()).size());
	}

	public void sendNotification(String message) {
		logger.info("Broadcasting notification to all clients: {}", message);
		Map<String, Object> payload = Map.of("type", "generic", "payload", Map.of("message", message));
		String jsonMessage = gson.toJson(payload);
		contextsByUser.values().forEach(contextList -> {
			contextList.forEach(context -> sendMessageToContext(context, jsonMessage, contextList));
		});
	}

	public void sendNotificationToUser(int userId, Map<String, Object> payload) {
		List<AsyncContext> userContexts = contextsByUser.get(userId);
		if (userContexts != null && !userContexts.isEmpty()) {
			String jsonMessage = gson.toJson(payload);
			logger.info("Sending targeted notification to user ID {}: {}", userId, jsonMessage);
			userContexts.forEach(context -> sendMessageToContext(context, jsonMessage, userContexts));
		} else {
			logger.debug("No active SSE clients found for user ID {} to send notification.", userId);
		}
	}

	public void sendEventInvitation(int userId, String eventName, int eventId) {
		String message = String.format("Du wurdest zum Event '%s' eingeladen!", eventName);
		Map<String, Object> payload = Map.of("type", "event_invitation", "payload",
				Map.of("message", message, "url", "/veranstaltungen/details?id=" + eventId));
		sendNotificationToUser(userId, payload);
	}

	private void sendMessageToContext(AsyncContext context, String message, List<AsyncContext> contextList) {
		try {
			PrintWriter writer = context.getResponse().getWriter();
			writer.write("data: " + message + "\n\n");
			writer.flush();
		} catch (IOException e) {
			logger.warn("Failed to send notification to a client (likely disconnected), removing it.");
			contextList.remove(context);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

/**
 * A service to gather system statistics from the underlying OS. This version is
 * made more platform-independent and robust for Windows environments.
 */
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;
	private static final boolean IS_LINUX = System.getProperty("os.name").toLowerCase().startsWith("linux");

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		stats.setCpuLoad(osBean.getSystemCpuLoad() * 100.0);

		long totalMemoryBytes = osBean.getTotalPhysicalMemorySize();
		long freeMemoryBytes = osBean.getFreePhysicalMemorySize();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		stats.setUptime(getSystemUptime());

		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		if (!IS_LINUX) {
			logger.trace("Uptime not available on non-Linux OS.");
			return "Nicht verfügbar";
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			logger.warn("Could not read /proc/uptime, even on a Linux-like system.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		if (!IS_LINUX) {
			logger.trace("Battery status not available on non-Linux OS.");
			return -1;
		}
		try {
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet("/api/calendar/entries")
public class CalendarApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<Map<String, String>> calendarEntries = new ArrayList<>();

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime().toString());
			if (event.getEndDateTime() != null) {
				entry.put("end", event.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/veranstaltungen/details?id=" + event.getId());
			entry.put("backgroundColor", "#dc3545"); 
			entry.put("borderColor", "#c82333");
			calendarEntries.add(entry);
		}

		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime().toString());
			if (meeting.getEndDateTime() != null) {
				entry.put("end", meeting.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/meetingDetails?id=" + meeting.getId());
			entry.put("backgroundColor", "#007bff"); 
			entry.put("borderColor", "#0056b3");
			calendarEntries.add(entry);
		}

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(gson.toJson(calendarEntries));
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

/**
 * This servlet handles the request for the main calendar page. It fetches all
 * upcoming events and meetings, combines and sorts them, groups them by month,
 * and then forwards the data to the calendar.jsp page for rendering in a custom
 * list view.
 */
@WebServlet("/kalender")
public class CalendarServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();

		List<Map<String, Object>> combinedList = new ArrayList<>();
		DateTimeFormatter dayFormatter = DateTimeFormatter.ofPattern("dd");
		DateTimeFormatter monthAbbrFormatter = DateTimeFormatter.ofPattern("MMM", Locale.GERMANY);

		for (Event event : events) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime());
			entry.put("day", event.getEventDateTime().format(dayFormatter));
			entry.put("monthAbbr", event.getEventDateTime().format(monthAbbrFormatter));
			entry.put("type", "Event");
			entry.put("typeClass", "termin-type-event");
			entry.put("url", request.getContextPath() + "/veranstaltungen/details?id=" + event.getId());
			combinedList.add(entry);
		}

		for (Meeting meeting : meetings) {
			Map<String, Object> entry = new HashMap<>();
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime());
			entry.put("day", meeting.getMeetingDateTime().format(dayFormatter));
			entry.put("monthAbbr", meeting.getMeetingDateTime().format(monthAbbrFormatter));
			entry.put("type", "Lehrgang");
			entry.put("typeClass", "termin-type-lehrgang");
			entry.put("url", request.getContextPath() + "/meetingDetails?id=" + meeting.getId());
			combinedList.add(entry);
		}

		combinedList.sort(Comparator.comparing(m -> (LocalDateTime) m.get("start")));

		DateTimeFormatter monthYearFormatter = DateTimeFormatter.ofPattern("MMMM yyyy", Locale.GERMANY);
		Map<String, List<Map<String, Object>>> groupedByMonth = new LinkedHashMap<>();
		for (Map<String, Object> entry : combinedList) {
			LocalDateTime start = (LocalDateTime) entry.get("start");
			String monthKey = start.format(monthYearFormatter);
			groupedByMonth.computeIfAbsent(monthKey, k -> new ArrayList<>()).add(entry);
		}

		request.setAttribute("groupedEntries", groupedByMonth);
		request.getRequestDispatcher("/views/public/calendar.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DownloadServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

/**
 * Handles secure file downloads for both general files and specific entity
 * attachments. It ensures that only authorized users can download files and
 * protects against path traversal attacks.
 */
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DownloadServlet.class);

	private de.technikteam.dao.FileDAO fileDAO;
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;
	private AttachmentDAO attachmentDAO;

	@Override
	public void init() {
		fileDAO = new de.technikteam.dao.FileDAO();
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
		attachmentDAO = new AttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Authentication required.");
			return;
		}

		String idParam = request.getParameter("id");
		if (idParam == null || idParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required 'id' parameter.");
			return;
		}

		try {
			int id = Integer.parseInt(idParam);
			String filePathFromDb = null;
			String filenameForDownload = null;
			boolean isAuthorized = false;

			// Unified attachments are the primary type of file to check for.
			Attachment attachment = attachmentDAO.getAttachmentById(id);
			if (attachment != null) {
				filePathFromDb = attachment.getFilepath();
				filenameForDownload = attachment.getFilename();
				isAuthorized = isUserAuthorizedForAttachment(user, attachment);
			} else {
				// Fallback to checking the general 'files' table for legacy links or general
				// documents.
				de.technikteam.model.File dbFile = fileDAO.getFileById(id);
				if (dbFile != null) {
					filePathFromDb = dbFile.getFilepath();
					filenameForDownload = dbFile.getFilename();
					// General files are accessible if the user has admin rights or the file is
					// marked for 'NUTZER'
					isAuthorized = user.hasAdminAccess() || "NUTZER".equalsIgnoreCase(dbFile.getRequiredRole());
				}
			}

			if (filePathFromDb == null) {
				logger.error("Download failed for user '{}': No file or attachment record found for ID {}",
						user.getUsername(), id);
				response.sendError(HttpServletResponse.SC_NOT_FOUND,
						"Die angeforderte Datei wurde in der Datenbank nicht gefunden.");
				return;
			}

			if (!isAuthorized) {
				logger.warn("Authorization DENIED for user '{}' trying to download content with ID {}",
						user.getUsername(), id);
				response.sendError(HttpServletResponse.SC_FORBIDDEN,
						"Sie haben keine Berechtigung, diese Datei herunterzuladen.");
				return;
			}

			serveFile(filePathFromDb, filenameForDownload, user, response);

		} catch (NumberFormatException e) {
			logger.warn("Invalid ID format for download: {}", idParam);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Die angegebene ID ist ungültig.");
		}
	}

	/**
	 * Determines if a user is authorized to download a specific attachment.
	 *
	 * @param user       The user requesting the download.
	 * @param attachment The attachment metadata from the database.
	 * @return true if the user is authorized, false otherwise.
	 */
	private boolean isUserAuthorizedForAttachment(User user, Attachment attachment) {
		// Admins can download any attachment.
		if (user.hasAdminAccess()) {
			return true;
		}

		// If the attachment is public to all users, we check their association with the
		// parent entity.
		if ("NUTZER".equalsIgnoreCase(attachment.getRequiredRole())) {
			if ("EVENT".equals(attachment.getParentType())) {
				return eventDAO.isUserAssociatedWithEvent(attachment.getParentId(), user.getId());
			} else if ("MEETING".equals(attachment.getParentType())) {
				return meetingDAO.isUserAssociatedWithMeeting(attachment.getParentId(), user.getId());
			}
		}

		// By default, access is denied.
		return false;
	}

	/**
	 * Securely serves a file from the disk to the client.
	 *
	 * @param relativePathFromDb The relative path of the file as stored in the
	 *                           database.
	 * @param originalFilename   The original filename to be sent to the client.
	 * @param user               The user requesting the file (for logging).
	 * @param response           The HttpServletResponse object.
	 * @throws IOException If an I/O error occurs.
	 */
	private void serveFile(String relativePathFromDb, String originalFilename, User user, HttpServletResponse response)
			throws IOException {
		if (relativePathFromDb == null || relativePathFromDb.trim().isEmpty()) {
			logger.error("File path from DB is null or empty for user '{}'.", user.getUsername());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Der Dateipfad in der Datenbank ist ungültig.");
			return;
		}

		// Security: Prevent path traversal attacks by ensuring the resolved file path
		// is within the allowed directory.
		File baseDir = new File(AppConfig.UPLOAD_DIRECTORY);
		File requestedFile = new File(baseDir, relativePathFromDb);

		// Canonicalize paths to resolve any ".." or "." in the path string and get the
		// absolute path.
		String baseDirCanonicalPath = baseDir.getCanonicalPath();
		String requestedFileCanonicalPath = requestedFile.getCanonicalPath();

		if (!requestedFileCanonicalPath.startsWith(baseDirCanonicalPath)) {
			logger.fatal(
					"CRITICAL: Path Traversal Attack Detected! User: '{}' attempted to access '{}' via db path '{}'",
					user.getUsername(), requestedFileCanonicalPath, relativePathFromDb);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Zugriff verweigert.");
			return;
		}

		if (!requestedFile.exists() || !requestedFile.isFile()) {
			logger.error("Download failed for user '{}': File not found at resolved path {}", user.getUsername(),
					requestedFile.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Die Datei wurde auf dem Server nicht gefunden.");
			return;
		}

		response.setContentType("application/octet-stream");
		response.setContentLengthLong(requestedFile.length());

		// URL-encode the filename to handle special characters, spaces, etc., according
		// to RFC 5987.
		String encodedFilename = URLEncoder.encode(originalFilename, StandardCharsets.UTF_8).replace("+", "%20");
		response.setHeader("Content-Disposition", "attachment; filename*=UTF-8''" + encodedFilename);

		logger.info("User '{}' is downloading file: {}. Size: {} bytes.", user.getUsername(),
				requestedFile.getAbsolutePath(), requestedFile.length());

		try (FileInputStream inStream = new FileInputStream(requestedFile);
				OutputStream outStream = response.getOutputStream()) {
			inStream.transferTo(outStream);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EditorServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.config.AppConfig;
import de.technikteam.model.User;
import de.technikteam.util.WopiTokenManager;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * A secure controller servlet for launching the Collabora Online editor. It
 * generates the necessary iframe URL with a secure access token.
 */
@WebServlet("/editor")
public class EditorServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EditorServlet.class);

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");

		if (user == null || !user.hasAdminAccess()) {
			logger.warn("Non-admin user '{}' or guest attempted to access the editor.",
					(user != null ? user.getUsername() : "GUEST"));
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access denied.");
			return;
		}

		String fileId = request.getParameter("fileId");
		if (fileId == null || fileId.trim().isEmpty()) {
			logger.warn("EditorServlet called without a fileId parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing fileId parameter.");
			return;
		}

		// Generate a secure, single-use access token and store it in our dedicated
		// token manager.
		String accessToken = UUID.randomUUID().toString();
		WopiTokenManager.getInstance().storeToken(accessToken, fileId, user.getUsername());
		logger.debug("Generated and stored WOPI access token for file {} and user {}", fileId, user.getUsername());

		// Capture the browser's origin. This is what Collabora needs for PostMessage.
		String browserOrigin = String.format("%s://%s:%d", request.getScheme(), request.getServerName(),
				request.getServerPort());

		// Construct the WOPI source URL, which points to our new WOPI API servlet,
		// and pass the browser's origin along with it.
		String wopiSrcUrl = String.format("%s/wopi/files/%s?origin=%s", getBaseUrl(request), fileId,
				URLEncoder.encode(browserOrigin, StandardCharsets.UTF_8));

		// Construct the full Collabora URL for the iframe.
		String collaboraUrl = String.format("%s/loleaflet.html?WOPISrc=%s", AppConfig.COLLABORA_SERVER_URL,
				URLEncoder.encode(wopiSrcUrl, StandardCharsets.UTF_8));

		// Pass the access token and the Collabora URL to the JSP.
		request.setAttribute("collaboraUrl", collaboraUrl);
		request.setAttribute("accessToken", accessToken);

		logger.info("Forwarding user '{}' to Collabora editor for file ID {}.", user.getUsername(), fileId);
		request.getRequestDispatcher("/views/public/collabora_editor.jsp").forward(request, response);
	}

	private String getBaseUrl(HttpServletRequest request) {
		String scheme = request.getScheme();

		// *** BUG FIX: Use the special Docker DNS name 'host.docker.internal'. ***
		// This is the standard, reliable way for a container to reach the host machine
		// in Docker Desktop environments (Windows/macOS).
		String serverName = "host.docker.internal";

		int serverPort = request.getServerPort();
		String contextPath = request.getContextPath();

		StringBuilder url = new StringBuilder();
		url.append(scheme).append("://").append(serverName);

		if ((serverPort != 80 && "http".equals(scheme)) || (serverPort != 443 && "https".equals(scheme))) {
			url.append(':').append(serverPort);
		}

		url.append(contextPath);

		logger.debug("Generated WOPI Base URL for Collabora callback: {}", url.toString());
		return url.toString();
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventActionServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@WebServlet("/event-action")
public class EventActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventActionServlet.class);
	private EventDAO eventDAO;
	private EventCustomFieldDAO customFieldDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		customFieldDAO = new EventCustomFieldDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String eventIdParam = request.getParameter("eventId");

		if (user == null || action == null || eventIdParam == null) {
			logger.warn("Invalid request to EventActionServlet. Missing user, action, or eventId parameter.");
			response.sendRedirect(request.getContextPath() + "/veranstaltungen");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.info("User '{}' (ID: {}) is performing action '{}' on event ID {}", user.getUsername(), user.getId(),
					action, eventId);

			if ("signup".equals(action)) {
				eventDAO.signUpForEvent(user.getId(), eventId);

				List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
				for (EventCustomField field : fields) {
					String paramName = "customfield_" + field.getId();
					String paramValue = request.getParameter(paramName);

					if (paramValue != null) {
						EventCustomFieldResponse customResponse = new EventCustomFieldResponse();
						customResponse.setFieldId(field.getId());
						customResponse.setUserId(user.getId());
						customResponse.setResponseValue(paramValue);
						customFieldDAO.saveResponse(customResponse);
						logger.debug("Saved custom response for field ID {} and user ID {}.", field.getId(),
								user.getId());
					}
				}

				request.getSession().setAttribute("successMessage", "Erfolgreich zum Event angemeldet.");
			} else if ("signoff".equals(action)) {
				eventDAO.signOffFromEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Event abgemeldet.");
			} else {
				logger.warn("Unknown action received in EventActionServlet: {}", action);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in EventActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}

		response.sendRedirect(request.getContextPath() + "/veranstaltungen");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventChatApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.model.EventChatMessage;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Provides a JSON API to fetch the historical messages for a given event chat.
 * New messages are handled by the EventChatSocket WebSocket.
 */
@WebServlet("/api/event-chat")
public class EventChatApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventChatApiServlet.class);
	private EventChatDAO chatDAO;
	private Gson gson;

	@Override
	public void init() {
		chatDAO = new EventChatDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	/**
	 * Handles GET requests to fetch the message history for an event.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			logger.trace("GET request for chat history for event ID: {}", eventId);
			List<EventChatMessage> messages = chatDAO.getMessagesForEvent(eventId);
			String jsonResponse = gson.toJson(messages);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat history API: Invalid or missing eventId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing eventId.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventCustomFieldsApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.model.EventCustomField;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * A public API endpoint that securely provides the list of custom sign-up
 * fields for a specific event. This is called by the JavaScript on the main
 * events page to populate the sign-up modal window.
 */
@WebServlet("/api/public/event-custom-fields")
public class EventCustomFieldsApiServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LogManager.getLogger(EventCustomFieldsApiServlet.class);
    private EventCustomFieldDAO customFieldDAO;
    private Gson gson;

    @Override
    public void init() {
        customFieldDAO = new EventCustomFieldDAO();
        gson = new GsonBuilder()
                .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
                .create();
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String eventIdParam = request.getParameter("eventId");
        if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
            logger.warn("API call rejected: eventId parameter is missing.");
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required 'eventId' parameter.");
            return;
        }

        try {
            int eventId = Integer.parseInt(eventIdParam);
            logger.debug("API request for custom fields for event ID: {}", eventId);

            List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
            String jsonResponse = gson.toJson(fields);

            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.getWriter().write(jsonResponse);

        } catch (NumberFormatException e) {
            logger.warn("API call rejected: Invalid eventId format '{}'.", eventIdParam);
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid 'eventId' format. It must be a number.");
        }
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@WebServlet("/veranstaltungen/details")
public class EventDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventDetailsServlet.class);
	private EventDAO eventDAO;
	private EventTaskDAO taskDAO;
	private EventChatDAO chatDAO;
	private AttachmentDAO attachmentDAO;
	private StorageDAO storageDAO;
	private InventoryKitDAO kitDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		taskDAO = new EventTaskDAO();
		chatDAO = new EventChatDAO();
		attachmentDAO = new AttachmentDAO();
		storageDAO = new StorageDAO();
		kitDAO = new InventoryKitDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(request.getParameter("id"));
			logger.info("Event details requested for ID: {} by user '{}'", eventId, user.getUsername());
			Event event = eventDAO.getEventById(eventId);

			if (event == null) {
				logger.warn("Event with ID {} not found. Redirecting to 404.", eventId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event nicht gefunden.");
				return;
			}

			boolean isGlobalAdmin = user.getPermissions().contains("EVENT_MANAGE_TASKS")
					|| user.getPermissions().contains("ACCESS_ADMIN_PANEL");
			boolean isEventLeader = user.getId() == event.getLeaderUserId();
			boolean hasTaskManagementPermission = isGlobalAdmin || isEventLeader;
			request.setAttribute("hasTaskManagementPermission", hasTaskManagementPermission);

			String userRoleForAttachments = (hasTaskManagementPermission) ? "ADMIN" : "NUTZER";

			List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
			Set<Integer> assignedUserIds = assignedUsers.stream().map(User::getId).collect(Collectors.toSet());
			boolean isUserAssigned = assignedUserIds.contains(user.getId());
			request.setAttribute("isUserAssigned", isUserAssigned);

			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			boolean isUserParticipant = signedUpUsers.stream().anyMatch(u -> u.getId() == user.getId());
			request.setAttribute("isUserParticipant", isUserParticipant);

			event.setAttachments(attachmentDAO.getAttachmentsForParent("EVENT", eventId, userRoleForAttachments));
			event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
			event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
			event.setAssignedAttendees(assignedUsers);
			event.setEventTasks(taskDAO.getTasksForEvent(eventId));

			if ("LAUFEND".equalsIgnoreCase(event.getStatus())) {
				event.setChatMessages(chatDAO.getMessagesForEvent(eventId));
			} else {
				event.setChatMessages(new ArrayList<>());
			}

			request.setAttribute("event", event);

			if (hasTaskManagementPermission) {
				request.setAttribute("assignedUsersJson", gson.toJson(assignedUsers));
				request.setAttribute("allItemsJson", gson.toJson(storageDAO.getAllItems()));
				request.setAttribute("allKitsJson", gson.toJson(kitDAO.getAllKits()));
				request.setAttribute("tasksJson", gson.toJson(event.getEventTasks()));
			} else {
				request.setAttribute("assignedUsersJson", "[]");
				request.setAttribute("allItemsJson", "[]");
				request.setAttribute("allKitsJson", "[]");
				request.setAttribute("tasksJson", "[]");
			}

			logger.debug("Forwarding to eventDetails.jsp for event '{}'", event.getName());
			request.getRequestDispatcher("/views/public/eventDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		} catch (Exception e) {
			logger.error("An unexpected error occurred while fetching event details.", e);
			response.sendRedirect(request.getContextPath() + "/error500");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/veranstaltungen`, this servlet is responsible for the main event
 * listing page for a logged-in user. It fetches a list of all upcoming events
 * and enriches each with user-specific data, such as attendance status and
 * qualification status.
 */
@WebServlet("/veranstaltungen")
public class EventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventServlet.class);
	private EventDAO eventDAO;

	public void init() {
		eventDAO = new EventDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming events for user '{}' (ID: {})", user.getUsername(), user.getId());

		// Fetch all active/upcoming events first
		List<Event> allUpcomingEvents = eventDAO.getAllActiveAndUpcomingEvents();

		// Fetch events the user is qualified for to determine signup eligibility and
		// status
		List<Event> qualifiedEvents = eventDAO.getUpcomingEventsForUser(user, 0);
		List<Integer> qualifiedEventIds = qualifiedEvents.stream().map(Event::getId).collect(Collectors.toList());

		// Enrich all events with user-specific data
		for (Event event : allUpcomingEvents) {
			// Is the user qualified?
			event.setUserQualified(qualifiedEventIds.contains(event.getId()));

			// What is the user's status for this event?
			qualifiedEvents.stream().filter(qe -> qe.getId() == event.getId()).findFirst()
					.ifPresent(qe -> event.setUserAttendanceStatus(qe.getUserAttendanceStatus()));

			if (event.getUserAttendanceStatus() == null) {
				event.setUserAttendanceStatus("OFFEN");
			}
		}

		request.setAttribute("events", allUpcomingEvents);
		logger.debug("Found {} upcoming events for user '{}'. Forwarding to veranstaltungen.jsp.",
				allUpcomingEvents.size(), user.getUsername());
		request.getRequestDispatcher("/views/public/events.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FeedbackServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.FeedbackDAO;
import de.technikteam.model.Event;
import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet("/feedback")
public class FeedbackServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private FeedbackDAO feedbackDAO;
	private EventDAO eventDAO;

	@Override
	public void init() {
		feedbackDAO = new FeedbackDAO();
		eventDAO = new EventDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");

		try {
			switch (action) {
			case "submit":
				showSubmitForm(request, response, user);
				break;
			case "view":
				viewFeedbackResults(request, response);
				break;
			default:
				response.sendRedirect(request.getContextPath() + "/profil");
				break;
			}
		} catch (Exception e) {
			throw new ServletException(e);
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");

		if ("createForm".equals(action)) {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			Event event = eventDAO.getEventById(eventId);
			FeedbackForm form = new FeedbackForm();
			form.setEventId(eventId);
			form.setTitle("Feedback für Event: " + (event != null ? event.getName() : "Unbekannt"));
			feedbackDAO.createFeedbackForm(form);
			AdminLogService.log(user.getUsername(), "CREATE_FEEDBACK_FORM",
					"Feedback-Formular für Event-ID " + eventId + " erstellt.");
			response.sendRedirect(request.getContextPath() + "/admin/veranstaltungen");

		} else if ("submitResponse".equals(action)) {
			int formId = Integer.parseInt(request.getParameter("formId"));
			int rating = Integer.parseInt(request.getParameter("rating"));
			String comments = request.getParameter("comments");

			FeedbackResponse feedbackResponse = new FeedbackResponse();
			feedbackResponse.setFormId(formId);
			feedbackResponse.setUserId(user.getId());
			feedbackResponse.setRating(rating);
			feedbackResponse.setComments(comments);

			feedbackDAO.saveFeedbackResponse(feedbackResponse);
			request.getSession().setAttribute("successMessage", "Vielen Dank für dein Feedback!");
			response.sendRedirect(request.getContextPath() + "/profil");
		}
	}

	private void showSubmitForm(HttpServletRequest request, HttpServletResponse response, User user)
			throws ServletException, IOException {
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		FeedbackForm form = feedbackDAO.getFeedbackFormForEvent(eventId);

		if (form == null) {
			request.getSession().setAttribute("errorMessage", "Für dieses Event wurde noch kein Feedback angefordert.");
			response.sendRedirect(request.getContextPath() + "/profil");
			return;
		}

		if (feedbackDAO.hasUserSubmittedFeedback(form.getId(), user.getId())) {
			request.getSession().setAttribute("infoMessage", "Du hast bereits Feedback für dieses Event abgegeben.");
			response.sendRedirect(request.getContextPath() + "/profil");
			return;
		}

		request.setAttribute("event", event);
		request.setAttribute("form", form);
		request.getRequestDispatcher("/views/public/feedback_form.jsp").forward(request, response);
	}

	private void viewFeedbackResults(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		FeedbackForm form = feedbackDAO.getFeedbackFormForEvent(eventId);

		if (form != null) {
			List<FeedbackResponse> responses = feedbackDAO.getResponsesForForm(form.getId());
			request.setAttribute("responses", responses);
		}

		request.setAttribute("event", event);
		request.getRequestDispatcher("/views/public/feedback_results.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\FileServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/dateien`, this servlet handles the display of the main files and
 * documents page for users. It fetches all files the user is permitted to see,
 * grouped by category.
 */
@WebServlet("/dateien")
public class FileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(FileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("File page requested by user '{}' (Role: {})", user.getUsername(), user.getRoleName());

		Map<String, List<File>> fileData = fileDAO.getAllFilesGroupedByCategory(user);

		request.setAttribute("fileData", fileData);
		logger.debug("Forwarding file data to dateien.jsp.");
		request.getRequestDispatcher("/views/public/dateien.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\HomeServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

@WebServlet("/home")
public class HomeServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(HomeServlet.class);
	private EventDAO eventDAO;
	private EventTaskDAO eventTaskDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		eventTaskDAO = new EventTaskDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Home page requested by user '{}'. Fetching dashboard data.", user.getUsername());

		List<Event> assignedEvents = eventDAO.getAssignedEventsForUser(user.getId(), 5);
		List<EventTask> openTasks = eventTaskDAO.getOpenTasksForUser(user.getId());
		List<Event> upcomingEvents = eventDAO.getUpcomingEventsForUser(user, 5);

		logger.debug("Fetched {} assigned events, {} open tasks, and {} general upcoming events.",
				assignedEvents.size(), openTasks.size(), upcomingEvents.size());

		request.setAttribute("assignedEvents", assignedEvents);
		request.setAttribute("openTasks", openTasks);
		request.setAttribute("upcomingEvents", upcomingEvents);

		logger.debug("Forwarding to the correct home.jsp path.");
		request.getRequestDispatcher("/views/public/home.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\IcalServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import net.fortuna.ical4j.data.CalendarOutputter;
import net.fortuna.ical4j.model.Calendar;
import net.fortuna.ical4j.model.component.VEvent;
import net.fortuna.ical4j.model.property.Description;
import net.fortuna.ical4j.model.property.DtEnd;
import net.fortuna.ical4j.model.property.DtStart;
import net.fortuna.ical4j.model.property.Location;
import net.fortuna.ical4j.model.property.ProdId;
import net.fortuna.ical4j.model.property.Summary;
import net.fortuna.ical4j.model.property.Url;
import net.fortuna.ical4j.model.property.Version;
import net.fortuna.ical4j.util.RandomUidGenerator;
import net.fortuna.ical4j.model.DateTime;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.Date;
import java.util.List;

@WebServlet("/calendar.ics")
public class IcalServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		try {
			Calendar calendar = new Calendar();
			calendar.getProperties().add(new ProdId("-//TechnikTeam Calendar//iCal4j 3.2.4//DE"));
			calendar.getProperties().add(Version.VERSION_2_0);

			RandomUidGenerator uidGenerator = new RandomUidGenerator();
			String baseUrl = request.getScheme() + "://" + request.getServerName() + ":" + request.getServerPort()
					+ request.getContextPath();
			ZoneId systemZone = ZoneId.systemDefault();

			List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
			for (Event event : events) {
				VEvent vEvent = new VEvent();
				vEvent.getProperties().add(uidGenerator.generateUid());

				if (event.getEventDateTime() != null) {
					ZonedDateTime zdtStart = event.getEventDateTime().atZone(systemZone);
					Date utilDateStart = Date.from(zdtStart.toInstant());
					vEvent.getProperties().add(new DtStart(new DateTime(utilDateStart)));
				}
				if (event.getEndDateTime() != null) {
					ZonedDateTime zdtEnd = event.getEndDateTime().atZone(systemZone);
					Date utilDateEnd = Date.from(zdtEnd.toInstant());
					vEvent.getProperties().add(new DtEnd(new DateTime(utilDateEnd)));
				}

				vEvent.getProperties().add(new Summary(event.getName()));
				if (event.getDescription() != null)
					vEvent.getProperties().add(new Description(event.getDescription()));
				if (event.getLocation() != null)
					vEvent.getProperties().add(new Location(event.getLocation()));
				try {
					vEvent.getProperties().add(new Url(new URI(baseUrl + "/eventDetails?id=" + event.getId())));
				} catch (URISyntaxException ignored) {
				}
				calendar.getComponents().add(vEvent);
			}

			List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
			for (Meeting meeting : meetings) {
				String title = meeting.getParentCourseName() + ": " + meeting.getName();
				VEvent vMeeting = new VEvent();
				vMeeting.getProperties().add(uidGenerator.generateUid());

				if (meeting.getMeetingDateTime() != null) {
					ZonedDateTime zdtStart = meeting.getMeetingDateTime().atZone(systemZone);
					Date utilDateStart = Date.from(zdtStart.toInstant());
					vMeeting.getProperties().add(new DtStart(new DateTime(utilDateStart)));
				}
				if (meeting.getEndDateTime() != null) {
					ZonedDateTime zdtEnd = meeting.getEndDateTime().atZone(systemZone);
					Date utilDateEnd = Date.from(zdtEnd.toInstant());
					vMeeting.getProperties().add(new DtEnd(new DateTime(utilDateEnd)));
				}

				vMeeting.getProperties().add(new Summary(title));
				if (meeting.getDescription() != null)
					vMeeting.getProperties().add(new Description(meeting.getDescription()));
				if (meeting.getLocation() != null)
					vMeeting.getProperties().add(new Location(meeting.getLocation()));
				try {
					vMeeting.getProperties().add(new Url(new URI(baseUrl + "/meetingDetails?id=" + meeting.getId())));
				} catch (URISyntaxException ignored) {
				}
				calendar.getComponents().add(vMeeting);
			}

			response.setContentType("text/calendar; charset=utf-8");
			response.setHeader("Content-Disposition", "inline; filename=\"technikteam-calendar.ics\"");
			CalendarOutputter outputter = new CalendarOutputter();
			outputter.output(calendar, response.getOutputStream());

		} catch (Exception e) {
			throw new ServletException("Error generating iCal feed", e);
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ImageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import de.technikteam.model.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/image`, this servlet acts as a secure proxy to serve images. It
 * prevents direct filesystem access by taking a `file` parameter, locating the
 * image within a designated `images` subdirectory in the main upload path, and
 * then streaming it to the browser. It sets the `Content-Disposition: inline`
 * header so the image is displayed directly on the web page rather than
 * downloaded.
 */
@WebServlet("/image")
public class ImageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(ImageServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Authentication required.");
			return;
		}
		User user = (User) session.getAttribute("user");

		String filename = request.getParameter("file");
		if (filename == null || filename.isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing 'file' parameter.");
			return;
		}

		try {
			filename = URLDecoder.decode(filename, StandardCharsets.UTF_8.toString());
		} catch (IllegalArgumentException e) {
			logger.warn("Could not decode filename: {}", filename, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid filename encoding.");
			return;
		}

		File imageUploadDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
		String imageDirCanonicalPath = imageUploadDir.getCanonicalPath();

		File imageFile = new File(imageUploadDir, filename);
		String requestedFileCanonicalPath = imageFile.getCanonicalPath();

		if (!requestedFileCanonicalPath.startsWith(imageDirCanonicalPath)) {
			String username = (user != null) ? user.getUsername() : "GUEST";
			logger.fatal(
					"CRITICAL: Path Traversal Attack Detected! User: '{}' attempted to access '{}' via image servlet.",
					username, requestedFileCanonicalPath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (!imageFile.exists() || !imageFile.isFile()) {
			logger.warn("Image not found at path: {}", imageFile.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Image not found.");
			return;
		}

		String contentType = getServletContext().getMimeType(imageFile.getName());
		if (contentType == null) {
			contentType = "application/octet-stream";
		}

		response.setContentType(contentType);
		response.setContentLengthLong(imageFile.length());

		response.setHeader("Content-Disposition", "inline; filename=\"" + imageFile.getName() + "\"");

		logger.debug("Serving image: {} with content type {}", imageFile.getAbsolutePath(), contentType);

		try (FileInputStream inStream = new FileInputStream(imageFile);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;

			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LoginServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.model.NavigationItem;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.security.SecureRandom;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import de.technikteam.dao.UserDAO;

@WebServlet("/login")
public class LoginServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LoginServlet.class);
	private UserDAO userDAO;

	private static final int MAX_ATTEMPTS = 5;
	private static final long LOCKOUT_TIME_MS = 15 * 60 * 1000;
	private static final Map<String, Integer> failedAttempts = new ConcurrentHashMap<>();
	private static final Map<String, Long> lockoutTimestamps = new ConcurrentHashMap<>();

	@Override
	public void init() {
		userDAO = new UserDAO();
	}

	private String sanitizeForLogging(String input) {
		if (input == null)
			return "";
		return input.replace('\n', '_').replace('\r', '_');
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		String username = request.getParameter("username");
		String password = request.getParameter("password");
		String sanitizedUsername = sanitizeForLogging(username);

		logger.info("Login attempt for username: {}", sanitizedUsername);

		if (isLockedOut(sanitizedUsername)) {
			logger.warn("Login attempt for locked-out user: {}", sanitizedUsername);
			request.getSession().setAttribute("errorMessage",
					"Ihr Konto ist aufgrund zu vieler fehlgeschlagener Versuche vorübergehend gesperrt.");
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		User user = userDAO.validateUser(username, password);

		if (user != null) {
			failedAttempts.remove(sanitizedUsername);
			lockoutTimestamps.remove(sanitizedUsername);

			// Invalidate any old session to prevent session fixation
			HttpSession oldSession = request.getSession(false);
			if (oldSession != null) {
				oldSession.invalidate();
			}

			// Create a new session for the authenticated user
			HttpSession newSession = request.getSession(true);
			newSession.setAttribute("user", user);

			CSRFUtil.storeToken(newSession);

			List<NavigationItem> navigationItems = NavigationRegistry.getNavigationItemsForUser(user);
			newSession.setAttribute("navigationItems", navigationItems);

			logger.info("Login successful for user: {}. Role: {}. Redirecting to home.", user.getUsername(),
					user.getRoleName());
			response.sendRedirect(request.getContextPath() + "/home");
		} else {
			handleFailedLogin(sanitizedUsername);
			// Get or create a session to store the error message
			HttpSession session = request.getSession(true);
			session.setAttribute("errorMessage", "Benutzername oder Passwort ungültig.");
			response.sendRedirect(request.getContextPath() + "/login");
		}
	}

	private boolean isLockedOut(String username) {
		Long lockoutTime = lockoutTimestamps.get(username);
		if (lockoutTime == null) {
			return false;
		}
		if (System.currentTimeMillis() - lockoutTime > LOCKOUT_TIME_MS) {
			lockoutTimestamps.remove(username);
			failedAttempts.remove(username);
			return false;
		}
		return true;
	}

	private void handleFailedLogin(String username) {
		int attempts = failedAttempts.compute(username, (k, v) -> (v == null) ? 1 : v + 1);

		if (attempts >= MAX_ATTEMPTS) {
			logger.warn("Locking out user {} due to {} failed login attempts.", username, attempts);
			lockoutTimestamps.put(username, System.currentTimeMillis());
			failedAttempts.remove(username);
		}
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/auth/login.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\LogoutServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

@WebServlet("/logout")
public class LogoutServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(LogoutServlet.class);

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);

		if (session != null) {
			User user = (User) session.getAttribute("user");
			String username = (user != null) ? user.getUsername() : "Gast";

			logger.info("Logging out user: {}. Invalidating session.", username);
			session.invalidate();
		} else {
			logger.warn("LogoutServlet called but no active session found.");
		}

		HttpSession newSession = request.getSession(true);
		newSession.setAttribute("successMessage", "Sie wurden erfolgreich ausgeloggt.");
		response.sendRedirect(request.getContextPath() + "/login");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * Mapped to `/meeting-action`, this servlet processes POST requests from the
 * main course/meeting listing page (`lehrgaenge.jsp`). It allows a logged-in
 * user to either sign up for (`signup`) or sign off from (`signoff`) a specific
 * meeting by updating the `meeting_attendance` table via the
 * `MeetingAttendanceDAO`.
 */
@WebServlet("/meeting-action")
public class MeetingActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingActionServlet.class);
	private MeetingAttendanceDAO attendanceDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for meeting action by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		String meetingIdParam = request.getParameter("meetingId");

		if (user == null || action == null || meetingIdParam == null) {
			logger.warn("Invalid request to MeetingActionServlet. Missing user, action, or meetingId.");
			response.sendRedirect(request.getContextPath() + "/lehrgaenge");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			logger.info("User '{}' (ID: {}) performing action '{}' on meeting ID {}", user.getUsername(), user.getId(),
					action, meetingId);

			if ("signup".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, true, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich zum Meeting angemeldet.");
			} else if ("signoff".equals(action)) {
				attendanceDAO.setAttendance(user.getId(), meetingId, false, "");
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Meeting abgemeldet.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format in MeetingActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Meeting-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/lehrgaenge");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapped to `/meetingDetails`, this servlet handles GET requests to display the
 * detailed view of a single course meeting. It fetches the core meeting data as
 * well as any associated file attachments, applying role-based filtering for
 * the attachments.
 */
@WebServlet("/meetingDetails")
public class MeetingDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingDetailsServlet.class);
	private MeetingDAO meetingDAO;
	private AttachmentDAO attachmentDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		attachmentDAO = new AttachmentDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		String meetingIdParam = request.getParameter("id");
		if (meetingIdParam == null || meetingIdParam.isEmpty()) {
			logger.warn("Bad request to MeetingDetailsServlet: missing ID parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Meeting-ID fehlt.");
			return;
		}

		try {
			int meetingId = Integer.parseInt(meetingIdParam);
			User user = (User) request.getSession().getAttribute("user");
			logger.info("Meeting details for ID {} requested by user '{}'", meetingId, user.getUsername());

			Meeting meeting = meetingDAO.getMeetingById(meetingId);

			if (meeting == null) {
				logger.warn("Meeting with ID {} not found.", meetingId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden.");
				return;
			}

			boolean hasAdminRights = user.getPermissions().contains("ACCESS_ADMIN_PANEL")
					|| user.getPermissions().contains("COURSE_READ");
			boolean isLeader = user.getId() == meeting.getLeaderUserId();

			boolean isParticipant = meetingDAO.isUserAssociatedWithMeeting(meetingId, user.getId());

			if (!hasAdminRights && !isLeader && !isParticipant) {
				logger.warn("Authorization DENIED for user '{}' trying to access meeting details for ID {}",
						user.getUsername(), meetingId);
				response.sendError(HttpServletResponse.SC_FORBIDDEN,
						"Sie sind nicht berechtigt, diese Meeting-Details anzuzeigen.");
				return;
			}

			String attachmentUserRole = "NUTZER";
			if (hasAdminRights || isLeader) {
				attachmentUserRole = "ADMIN";
				logger.debug("User {} granted admin view for attachments of meeting {}.", user.getUsername(),
						meetingId);
			}

			request.setAttribute("attachments",
					attachmentDAO.getAttachmentsForParent("MEETING", meetingId, attachmentUserRole));
			request.setAttribute("meeting", meeting);

			logger.debug("Forwarding to meetingDetails.jsp for meeting '{}'", meeting.getName());
			request.getRequestDispatcher("/views/public/meetingDetails.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid meeting ID format: {}", meetingIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\MeetingServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/lehrgaenge`, this servlet is responsible for the main
 * course/meeting listing page for a logged-in user. It fetches a list of all
 * upcoming meetings and enriches each one with the user's specific attendance
 * status (e.g., ANGEMELDET, ABGEMELDET, OFFEN). This data is then passed to
 * `lehrgaenge.jsp` for rendering.
 */
@WebServlet("/lehrgaenge")
public class MeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MeetingServlet.class);
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		logger.info("Fetching upcoming meetings for user '{}' (ID: {})", user.getUsername(), user.getId());

		List<Meeting> meetings = meetingDAO.getUpcomingMeetingsForUser(user);

		request.setAttribute("meetings", meetings);
		logger.debug("Found {} upcoming meetings. Forwarding to lehrgaenge.jsp.", meetings.size());
		request.getRequestDispatcher("/views/public/lehrgaenge.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\NotificationServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import de.technikteam.service.NotificationService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/notifications`, this servlet is the entry point for clients
 * wanting to receive real-time updates via Server-Sent Events (SSE). On a GET
 * request, it establishes a persistent connection by setting the appropriate
 * headers and registering the client's asynchronous context with the singleton
 * `NotificationService`. It requires an active user session to connect.
 */
@WebServlet(urlPatterns = "/notifications", asyncSupported = true)
public class NotificationServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(NotificationServlet.class);

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Unauthorized attempt to connect to SSE stream. No session.");
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		de.technikteam.model.User user = (de.technikteam.model.User) session.getAttribute("user");
		logger.info("Client '{}' connecting to SSE stream.", user.getUsername());

		response.setContentType("text/event-stream");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Cache-Control", "no-cache");
		response.setHeader("Connection", "keep-alive");

		NotificationService.getInstance().register(request);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PackKitServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Optional;

@WebServlet("/pack-kit")
public class PackKitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PackKitServlet.class);

	private InventoryKitDAO kitDAO;

	@Override
	public void init() {
		kitDAO = new InventoryKitDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String kitIdParam = request.getParameter("kitId");
		if (kitIdParam == null || kitIdParam.isEmpty()) {
			logger.warn("Pack kit page requested with no kitId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Kit-ID fehlt.");
			return;
		}

		try {
			int kitId = Integer.parseInt(kitIdParam);
			InventoryKit kit = kitDAO.getKitById(kitId);

			if (kit == null) {
				logger.warn("Pack kit page requested for non-existent kitId: {}", kitId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Kit nicht gefunden.");
				return;
			}

			List<InventoryKitItem> kitItems = kitDAO.getItemsForKit(kitId);

			request.setAttribute("kit", kit);
			request.setAttribute("kitItems", kitItems);

			request.getRequestDispatcher("/views/public/pack_kit.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid kitId format: {}", kitIdParam, e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Kit-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\PasswordServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

/**
 * Mapped to `/passwort`, this servlet allows a logged-in user to change their
 * own password. It handles GET requests by displaying the change form
 * (`passwort.jsp`) and POST requests by processing the password change. This
 * includes validating the user's current password and ensuring the new password
 * confirmation matches before updating the database via `UserDAO`.
 */
@WebServlet("/passwort")
public class PasswordServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(PasswordServlet.class);
	private UserDAO userDAO;

	public void init() {
		userDAO = new UserDAO();
		logger.info("PasswordServlet initialized.");
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.debug("GET request received, showing password change form.");
		request.getRequestDispatcher("/views/public/passwort.jsp").forward(request, response);
	}

	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		User user = (session != null) ? (User) session.getAttribute("user") : null;

		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for password change attempt by user '{}'", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid or missing CSRF token.");
			return;
		}

		logger.info("Password change attempt for user: {}", user.getUsername());

		String currentPassword = request.getParameter("currentPassword");
		String newPassword = request.getParameter("newPassword");
		String confirmPassword = request.getParameter("confirmPassword");

		User authenticatedUser = userDAO.validateUser(user.getUsername(), currentPassword);
		if (authenticatedUser == null) {
			logger.warn("Password change failed for {}: incorrect current password.", user.getUsername());
			session.setAttribute("errorMessage", "Das aktuelle Passwort ist nicht korrekt.");
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		if (!newPassword.equals(confirmPassword)) {
			logger.warn("Password change failed for {}: new passwords do not match.", user.getUsername());
			session.setAttribute("errorMessage", "Die neuen Passwörter stimmen nicht überein.");
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		if (newPassword.trim().isEmpty()) {
			logger.warn("Password change failed for {}: new password is empty.", user.getUsername());
			session.setAttribute("errorMessage", "Das neue Passwort darf nicht leer sein.");
			response.sendRedirect(request.getContextPath() + "/passwort");
			return;
		}

		boolean success = userDAO.changePassword(user.getId(), newPassword);
		if (success) {
			logger.info("Password successfully changed for user: {}", user.getUsername());
			CSRFUtil.storeToken(session);
			session.setAttribute("successMessage", "Ihr Passwort wurde erfolgreich geändert.");
		} else {
			logger.error("Password change failed for {} due to a DAO error.", user.getUsername());
			session.setAttribute("errorMessage", "Ein interner Fehler ist aufgetreten. Bitte versuchen Sie es erneut.");
		}
		response.sendRedirect(request.getContextPath() + "/passwort");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\ProfileServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.dao.UserQualificationsDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import de.technikteam.model.UserQualification;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.util.List;

@WebServlet("/profil")
public class ProfileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private UserQualificationsDAO qualificationsDAO;
	private UserDAO userDAO;
	private AchievementDAO achievementDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		qualificationsDAO = new UserQualificationsDAO();
		userDAO = new UserDAO();
		achievementDAO = new AchievementDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		List<Event> eventHistory = eventDAO.getEventHistoryForUser(user.getId());
		List<UserQualification> qualifications = qualificationsDAO.getQualificationsForUser(user.getId());
		List<Achievement> achievements = achievementDAO.getAchievementsForUser(user.getId());

		request.setAttribute("eventHistory", eventHistory);
		request.setAttribute("qualifications", qualifications);
		request.setAttribute("achievements", achievements);

		request.getRequestDispatcher("/views/public/profile.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User user = (User) session.getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String chatColor = request.getParameter("chatColor");

		if (user != null && chatColor != null) {
			if (userDAO.updateUserChatColor(user.getId(), chatColor)) {
				user.setChatColor(chatColor);
				session.setAttribute("user", user);
				session.setAttribute("successMessage", "Chat-Farbe erfolgreich gespeichert!");
			} else {
				session.setAttribute("errorMessage", "Farbe konnte nicht gespeichert werden.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/profil");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageHistoryApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Provides a JSON API to fetch the usage history for a specific storage item.
 */
@WebServlet("/api/storage-history")
public class StorageHistoryApiServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LogManager.getLogger(StorageHistoryApiServlet.class);
    private StorageLogDAO logDAO;
    private Gson gson;

    @Override
    public void init() {
        logDAO = new StorageLogDAO();
        gson = new GsonBuilder()
                .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
                .create();
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        try {
            int itemId = Integer.parseInt(request.getParameter("itemId"));
            logger.debug("API request for storage history for item ID: {}", itemId);
            List<StorageLogEntry> history = logDAO.getHistoryForItem(itemId);

            String jsonResponse = gson.toJson(history);
            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.getWriter().write(jsonResponse);

        } catch (NumberFormatException e) {
            logger.warn("Bad request to storage history API: invalid or missing itemId");
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing itemId.");
        }
    }
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

@WebServlet("/lager/aktionen")
public class StorageItemActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private StorageDAO storageDAO;
	private EventDAO eventDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		eventDAO = new EventDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			List<Event> activeEvents = eventDAO.getActiveEvents();

			if (item == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}
			request.setAttribute("item", item);
			request.setAttribute("activeEvents", activeEvents);
			request.getRequestDispatcher("/views/public/qr_action.jsp").forward(request, response);
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageItemDetailsServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.StorageLogEntry;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

/**
 * Mapped to `/lager/details`, this servlet now displays a comprehensive,
 * public-facing detail page for a single inventory item. It fetches the item's
 * core data AND its full transaction history ("chronic"), forwarding both to
 * `storage_item_details.jsp` for rendering a unified view.
 */
@WebServlet("/lager/details")
public class StorageItemDetailsServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageItemDetailsServlet.class);
	private StorageDAO storageDAO;
	private StorageLogDAO storageLogDAO;
	private MaintenanceLogDAO maintenanceLogDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		storageLogDAO = new StorageLogDAO();
		maintenanceLogDAO = new MaintenanceLogDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			logger.info("Comprehensive storage item details requested for ID: {}", itemId);

			StorageItem item = storageDAO.getItemById(itemId);

			if (item == null) {
				logger.warn("Storage item with ID {} not found.", itemId);
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Artikel nicht gefunden.");
				return;
			}

			List<StorageLogEntry> history = storageLogDAO.getHistoryForItem(itemId);
			List<MaintenanceLogEntry> maintenanceHistory = maintenanceLogDAO.getHistoryForItem(itemId);

			request.setAttribute("item", item);
			request.setAttribute("history", history);
			request.setAttribute("maintenanceHistory", maintenanceHistory);

			logger.debug("Forwarding to storage_item_details.jsp for item '{}' with {} history entries.",
					item.getName(), history.size());
			request.getRequestDispatcher("/views/public/storage_item_details.jsp").forward(request, response);

		} catch (NumberFormatException e) {
			logger.error("Invalid storage item ID format in request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Artikel-ID.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet, mapped to `/lager`, is responsible for displaying the main
 * inventory/storage page for users. On a GET request, it fetches all storage
 * items from the database, grouped by their physical location, and forwards
 * this structured data to `/views/public/lager.jsp` for rendering.
 */
@WebServlet("/lager")
public class StorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageServlet.class);
	private StorageDAO storageDAO;
	private EventDAO eventDAO;

	public void init() {
		storageDAO = new StorageDAO();
		eventDAO = new EventDAO();
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Main storage page requested. Fetching all items.");

		Map<String, List<StorageItem>> storageData = storageDAO.getAllItemsGroupedByLocation();
		List<Event> activeEvents = eventDAO.getActiveEvents();

		request.setAttribute("storageData", storageData);
		request.setAttribute("activeEvents", activeEvents);
		logger.debug("Forwarding {} location groups to /views/public/lager.jsp.", storageData.size());
		request.getRequestDispatcher("/views/public/lager.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\StorageTransactionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.StorageLogDAO;
import de.technikteam.model.Event;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.sql.SQLException;

@WebServlet("/lager/transaktion")
public class StorageTransactionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(StorageTransactionServlet.class);
	private StorageDAO storageDAO;
	private StorageLogDAO storageLogDAO;
	private EventDAO eventDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		storageLogDAO = new StorageLogDAO();
		eventDAO = new EventDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User user = (User) request.getSession().getAttribute("user");
		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for storage transaction by user '{}'",
					user != null ? user.getUsername() : "GUEST");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String redirectUrl = request.getParameter("redirectUrl");
		if (redirectUrl == null || redirectUrl.isEmpty()) {
			redirectUrl = request.getContextPath() + "/lager";
		}

		try {
			int itemId = Integer.parseInt(request.getParameter("itemId"));
			int quantity = Integer.parseInt(request.getParameter("quantity"));
			String type = request.getParameter("type");
			String notes = request.getParameter("notes");
			Integer eventId = null;
			try {
				String eventIdParam = request.getParameter("eventId");
				if (eventIdParam != null && !eventIdParam.isEmpty()) {
					eventId = Integer.parseInt(eventIdParam);
					if (eventId == 0)
						eventId = null;
				}
			} catch (NumberFormatException e) {
			}

			int quantityChange = "checkin".equals(type) ? quantity : -quantity;
			logger.info("Processing storage transaction by user '{}': item ID {}, quantity change {}",
					user.getUsername(), itemId, quantityChange);

			boolean success = false;
			StorageItem item = storageDAO.getItemById(itemId);

			if (item == null) {
				throw new ServletException("Item with ID " + itemId + " not found.");
			}

			if ("checkout".equals(type)) {
				if (item.getAvailableQuantity() < quantity) {
					request.getSession().setAttribute("errorMessage",
							"Entnahme fehlgeschlagen: Nicht genügend Artikel verfügbar.");
				} else {
					success = storageDAO.performCheckout(itemId, quantity, user.getId(), eventId);
				}
			} else if ("checkin".equals(type)) {
				if (item.getMaxQuantity() > 0 && (item.getQuantity() + quantity > item.getMaxQuantity())) {
					int availableSpace = item.getMaxQuantity() - item.getQuantity();
					if (availableSpace > 0) {
						request.getSession().setAttribute("errorMessage",
								"Einräumen fehlgeschlagen: Es ist nur Platz für " + availableSpace
										+ " weitere Artikel.");
					} else {
						request.getSession().setAttribute("errorMessage",
								"Einräumen fehlgeschlagen: Das Lager für diesen Artikel ist bereits voll.");
					}
				} else {
					success = storageDAO.performCheckin(itemId, quantity);
				}
			}

			if (success) {
				String finalNotes = notes;
				if ("checkout".equals(type) && eventId != null) {
					Event event = eventDAO.getEventById(eventId);
					if (event != null) {
						String autoNote = "Für Event: " + event.getName();
						finalNotes = (notes != null && !notes.trim().isEmpty()) ? autoNote + " - " + notes : autoNote;
					}
				}

				storageLogDAO.logTransaction(itemId, user.getId(), quantityChange, finalNotes,
						eventId != null ? eventId : 0);

				String itemName = item.getName();
				String action = "checkin".equals(type) ? "eingeräumt" : "entnommen";
				String logDetails = String.format("%d x '%s' (ID: %d) %s. Notiz: %s", quantity, itemName, itemId,
						action, finalNotes);
				AdminLogService.log(user.getUsername(), "STORAGE_TRANSACTION", logDetails);

				request.getSession().setAttribute("successMessage",
						"Erfolgreich " + quantity + " Stück " + action + ".");
			} else {
				if (request.getSession().getAttribute("errorMessage") == null) {
					request.getSession().setAttribute("errorMessage",
							"Transaktion fehlgeschlagen. Bitte erneut versuchen.");
				}
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid number format in storage transaction request.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültiges Zahlenformat.");
		} catch (SQLException e) {
			logger.error("SQL error during storage transaction.", e);
			request.getSession().setAttribute("errorMessage", "Datenbankfehler bei der Transaktion: " + e.getMessage());
		}

		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\TaskActionServlet.java
========================================================================

package de.technikteam.servlet;

import de.technikteam.dao.EventDAO;
import de.technikteam.dao.EventTaskDAO;
import de.technikteam.model.Event;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@WebServlet("/task-action")
public class TaskActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(TaskActionServlet.class);
	private EventTaskDAO taskDAO;
	private EventDAO eventDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
		eventDAO = new EventDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");

		if (user == null || action == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for task action by user '{}'", user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		try {
			switch (action) {
			case "save":
				handleSaveTask(request, response, user);
				break;
			case "delete":
				handleDeleteTask(request, response, user);
				break;
			case "updateStatus":
			case "claim":
			case "unclaim":
				handleUserTaskAction(request, response, user, action);
				break;
			default:
				response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unbekannte Aktion.");
				break;
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in task action request.", e);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige ID.");
		}
	}

	private void handleSaveTask(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		boolean hasPermission = user.getPermissions().contains("ACCESS_ADMIN_PANEL")
				|| user.getPermissions().contains("EVENT_MANAGE_TASKS")
				|| (event != null && user.getId() == event.getLeaderUserId());

		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		boolean isUpdate = !request.getParameter("taskId").isEmpty();
		EventTask task = new EventTask();
		task.setEventId(eventId);
		task.setDescription(request.getParameter("description"));
		task.setDetails(request.getParameter("details"));
		task.setDisplayOrder(Integer.parseInt(request.getParameter("displayOrder")));

		if (isUpdate) {
			task.setId(Integer.parseInt(request.getParameter("taskId")));
			task.setStatus(request.getParameter("status"));
		}

		String assignmentType = request.getParameter("assignmentType");
		int[] userIds = null;
		if ("direct".equals(assignmentType)) {
			String[] userIdsStr = request.getParameterValues("userIds");
			userIds = userIdsStr == null ? new int[0] : Arrays.stream(userIdsStr).mapToInt(Integer::parseInt).toArray();
			task.setRequiredPersons(0);
		} else {
			task.setRequiredPersons(Integer.parseInt(request.getParameter("requiredPersons")));
		}

		String[] itemIds = request.getParameterValues("itemIds");
		String[] itemQuantities = request.getParameterValues("itemQuantities");
		String[] kitIds = request.getParameterValues("kitIds");

		int taskId = taskDAO.saveTask(task, userIds, itemIds, itemQuantities, kitIds);

		if (taskId > 0) {
			String logAction = isUpdate ? "UPDATE_TASK" : "CREATE_TASK";
			String logDetails = String.format("Aufgabe '%s' (ID: %d) für Event '%s' (ID: %d) %s.",
					task.getDescription(), taskId, event.getName(), eventId, isUpdate ? "aktualisiert" : "erstellt");
			AdminLogService.log(user.getUsername(), logAction, logDetails);
			request.getSession().setAttribute("successMessage", "Aufgabe erfolgreich gespeichert.");
		} else {
			request.getSession().setAttribute("errorMessage", "Fehler beim Speichern der Aufgabe.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	private void handleDeleteTask(HttpServletRequest request, HttpServletResponse response, User user)
			throws IOException {
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		int eventId = Integer.parseInt(request.getParameter("eventId"));

		EventTask taskToDelete = taskDAO.getTaskById(taskId);
		if (taskToDelete == null) {
			request.getSession().setAttribute("errorMessage", "Fehler: Aufgabe nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
			return;
		}

		Event event = eventDAO.getEventById(taskToDelete.getEventId());
		boolean hasPermission = user.getPermissions().contains("ACCESS_ADMIN_PANEL")
				|| user.getPermissions().contains("EVENT_MANAGE_TASKS")
				|| (event != null && user.getId() == event.getLeaderUserId());

		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (taskDAO.deleteTask(taskId)) {
			String eventName = event != null ? event.getName() : "Unbekannt";
			AdminLogService.log(user.getUsername(), "DELETE_TASK", "Aufgabe '" + taskToDelete.getDescription()
					+ "' (ID: " + taskId + ") von Event '" + eventName + "' gelöscht.");
			request.getSession().setAttribute("successMessage", "Aufgabe erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Aufgabe konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	private void handleUserTaskAction(HttpServletRequest request, HttpServletResponse response, User user,
			String action) throws IOException {
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		EventTask task = taskDAO.getTaskById(taskId);
		if (task == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Task not found.");
			return;
		}
		Event event = eventDAO.getEventById(task.getEventId());
		if (event == null) {
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Associated event not found.");
			return;
		}

		boolean isLeader = event.getLeaderUserId() == user.getId();
		boolean isAdmin = user.getPermissions().contains("ACCESS_ADMIN_PANEL")
				|| user.getPermissions().contains("EVENT_MANAGE_TASKS");
		boolean isTaskAssignee = taskDAO.isUserAssignedToTask(taskId, user.getId());

		boolean isUserAssigned = eventDAO.getAssignedUsersForEvent(event.getId()).stream()
				.anyMatch(u -> u.getId() == user.getId());
		boolean isUserParticipant = eventDAO.getSignedUpUsersForEvent(event.getId()).stream()
				.anyMatch(u -> u.getId() == user.getId());

		switch (action) {
		case "updateStatus":
			if (!isAdmin && !isLeader && !isTaskAssignee) {
				logger.warn("Authorization DENIED for user '{}' to update status on task {}", user.getUsername(),
						taskId);
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}
			String status = request.getParameter("status");
			if (taskDAO.updateTaskStatus(taskId, status)) {
				response.setStatus(HttpServletResponse.SC_OK);
			} else {
				response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						"Status konnte nicht aktualisiert werden.");
			}
			break;
		case "claim":
		case "unclaim":
			if (!isUserAssigned && !isUserParticipant) {
				logger.warn("Authorization DENIED for user '{}' to {} task {}. Not a participant.", user.getUsername(),
						action, taskId);
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}

			boolean success = false;
			String errorMessage = "";
			if ("claim".equals(action)) {
				success = taskDAO.claimTask(taskId, user.getId());
				errorMessage = "Aufgabe konnte nicht übernommen werden (vielleicht schon voll?).";
			} else {
				success = taskDAO.unclaimTask(taskId, user.getId());
				errorMessage = "Aufgabe konnte nicht zurückgegeben werden.";
			}

			if (success) {
				response.sendRedirect(request.getHeader("Referer"));
			} else {
				request.getSession().setAttribute("errorMessage", errorMessage);
				response.sendRedirect(request.getHeader("Referer"));
			}
			break;
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAchievementServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AchievementDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.model.Achievement;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;

@WebServlet("/admin/achievements")
public class AdminAchievementServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAchievementServlet.class);
	private AchievementDAO achievementDAO;
	private CourseDAO courseDAO;
	private Gson gson;

	@Override
	public void init() {
		achievementDAO = new AchievementDAO();
		courseDAO = new CourseDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		Set<String> permissions = currentUser.getPermissions();

		if (!permissions.contains("ACHIEVEMENT_CREATE") && !permissions.contains("ACHIEVEMENT_UPDATE")
				&& !permissions.contains("ACHIEVEMENT_DELETE") && !permissions.contains("ACCESS_ADMIN_PANEL")) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = request.getParameter("action");
		if ("getAchievementData".equals(action)) {
			getAchievementDataAsJson(request, response);
			return;
		}

		List<Achievement> achievements = achievementDAO.getAllAchievements();
		List<Course> allCourses = courseDAO.getAllCourses();
		request.setAttribute("achievements", achievements);
		request.setAttribute("allCourses", allCourses);
		request.getRequestDispatcher("/views/admin/admin_achievements.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		Set<String> permissions = adminUser.getPermissions();

		String action = request.getParameter("action");
		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response, adminUser);
			break;
		case "delete":
			handleDelete(request, response, adminUser);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/achievements");
		}
	}

	private void getAchievementDataAsJson(HttpServletRequest request, HttpServletResponse response) throws IOException {
		try {
			int id = Integer.parseInt(request.getParameter("id"));
			Achievement achievement = achievementDAO.getAchievementById(id);
			if (achievement != null) {
				response.setContentType("application/json");
				response.setCharacterEncoding("UTF-8");
				response.getWriter().write(gson.toJson(achievement));
			} else {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Achievement not found");
			}
		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		String idParam = request.getParameter("id");
		boolean isUpdate = idParam != null && !idParam.isEmpty();
		Set<String> permissions = adminUser.getPermissions();
		boolean hasMasterAccess = permissions.contains("ACCESS_ADMIN_PANEL");

		if ((isUpdate && !permissions.contains("ACHIEVEMENT_UPDATE") && !hasMasterAccess)
				|| (!isUpdate && !permissions.contains("ACHIEVEMENT_CREATE") && !hasMasterAccess)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		Achievement achievement = new Achievement();
		achievement.setName(request.getParameter("name"));
		achievement.setDescription(request.getParameter("description"));
		achievement.setIconClass(request.getParameter("icon_class"));

		if (isUpdate) {
			achievement.setId(Integer.parseInt(idParam));
			if (achievementDAO.updateAchievement(achievement)) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_ACHIEVEMENT",
						"Erfolg '" + achievement.getName() + "' (ID: " + achievement.getId() + ") aktualisiert.");
				request.getSession().setAttribute("successMessage", "Erfolg erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Erfolgs.");
			}
		} else {
			// Read the generated key from the hidden input
			achievement.setAchievementKey(request.getParameter("achievement_key"));
			if (achievement.getAchievementKey() == null || achievement.getAchievementKey().trim().isEmpty()) {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Der programmatische Key darf nicht leer sein.");
			} else if (achievementDAO.createAchievement(achievement)) {
				AdminLogService.log(adminUser.getUsername(), "CREATE_ACHIEVEMENT",
						"Erfolg '" + achievement.getName() + "' erstellt.");
				request.getSession().setAttribute("successMessage", "Neuer Erfolg erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler beim Erstellen des Erfolgs (Key bereits vorhanden?).");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/achievements");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		if (!adminUser.getPermissions().contains("ACHIEVEMENT_DELETE")
				&& !adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		try {
			int id = Integer.parseInt(request.getParameter("id"));
			Achievement achievement = achievementDAO.getAchievementById(id);
			if (achievementDAO.deleteAchievement(id)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_ACHIEVEMENT", "Erfolg '"
						+ (achievement != null ? achievement.getName() : "N/A") + "' (ID: " + id + ") gelöscht.");
				request.getSession().setAttribute("successMessage", "Erfolg erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Erfolg konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/achievements");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAttendanceServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;

/**
 * Mapped to `/admin/attendance`, this servlet handles all actions related to
 * updating meeting attendance records, primarily called from the modal window
 * on the administrative qualifications matrix (`admin_matrix.jsp`).
 */
@WebServlet("/admin/teilnahme")
public class AdminAttendanceServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAttendanceServlet.class);
	private MeetingAttendanceDAO attendanceDAO;
	private UserDAO userDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
		userDAO = new UserDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");

		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			int meetingId = Integer.parseInt(request.getParameter("meetingId"));
			boolean attended = "true".equals(request.getParameter("attended"));

			String remarks = request.getParameter("remarks");
			logger.debug("Processing attendance update for user ID {}, meeting ID {}. Attended: {}, Remarks: '{}'",
					userId, meetingId, attended, remarks);

			if (attendanceDAO.setAttendance(userId, meetingId, attended, remarks)) {
				User targetUser = userDAO.getUserById(userId);
				Meeting meeting = meetingDAO.getMeetingById(meetingId);

				String status = attended ? "TEILGENOMMEN" : "NICHT TEILGENOMMEN";
				String logDetails = String.format(
						"Teilnahme für Nutzer '%s' (ID: %d) bei Meeting '%s' (ID: %d) auf '%s' gesetzt. Bemerkungen: '%s'.",
						(targetUser != null ? targetUser.getUsername() : "N/A"), userId,
						(meeting != null ? meeting.getName() : "N/A"), meetingId, status, remarks);

				AdminLogService.log(adminUser.getUsername(), "UPDATE_ATTENDANCE", logDetails);

				request.getSession().setAttribute("successMessage", "Teilnahmestatus erfolgreich aktualisiert.");
				logger.info("Attendance update successful for user ID {} / meeting ID {}.", userId, meetingId);
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Teilnahmestatus konnte nicht aktualisiert werden.");
				logger.error("Attendance update failed for user ID {} / meeting ID {}.", userId, meetingId);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid ID received in AdminAttendanceServlet.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID empfangen.");
		}

		String redirectUrl = request.getContextPath()
				+ ("/matrix".equals(returnTo) ? "/admin/matrix" : "/admin/dashboard");
		logger.debug("Redirecting to {}", redirectUrl);
		response.sendRedirect(redirectUrl);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminCourseServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.UserQualificationsDAO;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;
import java.util.List;
import java.util.Objects;

/**
 * 
 * Mapped to /admin/lehrgaenge, this servlet manages the parent course
 * templates.
 * 
 * It handles listing all course templates, and processing the creation, update,
 * 
 * and deletion of these templates, which are now managed via modal dialogs on
 * 
 * the list page.
 */
@WebServlet("/admin/lehrgaenge")
public class AdminCourseServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminCourseServlet.class);
	private CourseDAO courseDAO;
	private UserQualificationsDAO userQualificationsDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		courseDAO = new CourseDAO();
		userQualificationsDAO = new UserQualificationsDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getCourseData".equals(action)) {
			getCourseDataAsJson(req, resp);
			return;
		}

		logger.info("Listing all course templates for admin view.");
		List<Course> courseList = courseDAO.getAllCourses();
		req.setAttribute("courseList", courseList);
		req.getRequestDispatcher("/views/admin/admin_course_list.jsp").forward(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		req.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(req)) {
			logger.warn("CSRF token validation failed for course action.");
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = req.getParameter("action");
		logger.debug("AdminCourseServlet received POST with action: {}", action);

		switch (action) {
		case "delete":
			handleDelete(req, resp);
			break;
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "grantQualifications":
			handleGrantQualifications(req, resp);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
			break;
		}
	}

	private void getCourseDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			Course course = courseDAO.getCourseById(courseId);
			if (course != null) {
				String courseJson = gson.toJson(course);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(courseJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Course not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid course ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		Course course = new Course();
		course.setName(request.getParameter("name"));
		course.setAbbreviation(request.getParameter("abbreviation"));
		course.setDescription(request.getParameter("description"));

		boolean success;
		if (idParam != null && !idParam.isEmpty()) {
			course.setId(Integer.parseInt(idParam));
			logger.info("Attempting to update course: {}", course.getName());
			Course originalCourse = courseDAO.getCourseById(course.getId());
			success = courseDAO.updateCourse(course);
			if (success && originalCourse != null) {
				StringBuilder changes = new StringBuilder();
				if (!Objects.equals(originalCourse.getName(), course.getName())) {
					changes.append(String.format("Name: '%s' -> '%s'. ", originalCourse.getName(), course.getName()));
				}
				if (!Objects.equals(originalCourse.getAbbreviation(), course.getAbbreviation())) {
					changes.append(String.format("Abk.: '%s' -> '%s'. ", originalCourse.getAbbreviation(),
							course.getAbbreviation()));
				}
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (ID: %d) aktualisiert. %s",
						originalCourse.getName(), course.getId(), changes.toString());
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else if (success) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE",
						"Lehrgangs-Vorlage (ID: " + course.getId() + ") aktualisiert.");
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren der Vorlage.");
			}
		} else {
			logger.info("Attempting to create new course: {}", course.getName());
			success = courseDAO.createCourse(course);
			if (success) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (Abk.: %s) erstellt.", course.getName(),
						course.getAbbreviation());
				AdminLogService.log(adminUser.getUsername(), "CREATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Neue Lehrgangs-Vorlage erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Erstellen der Vorlage.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/lehrgaenge");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete course with ID: {}", courseId);
			Course courseToDelete = courseDAO.getCourseById(courseId);
			String courseName = (courseToDelete != null) ? courseToDelete.getName() : "N/A";

			if (courseDAO.deleteCourse(courseId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_COURSE",
						"Lehrgangs-Vorlage '" + courseName + "' (ID: " + courseId
								+ ") und alle zugehörigen Meetings, Anhänge und Qualifikationen gelöscht.");
				req.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Vorlage konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid course ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Löschvorgang.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
	}

	private void handleGrantQualifications(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("courseId"));
			int minMeetings = Integer.parseInt(req.getParameter("minMeetings"));

			int updatedCount = userQualificationsDAO.batchGrantQualifications(courseId, minMeetings);

			if (updatedCount >= 0) {
				Course course = courseDAO.getCourseById(courseId);
				String courseName = course != null ? course.getName() : "ID " + courseId;
				String logDetails = String.format(
						"Batch-Qualifikation für '%s' an %d Benutzer vergeben (min. %d Meetings).", courseName,
						updatedCount, minMeetings);
				AdminLogService.log(adminUser.getUsername(), "BATCH_GRANT_QUALIFICATION", logDetails);
				req.getSession().setAttribute("successMessage",
						"Qualifikationen wurden erfolgreich an " + updatedCount + " Benutzer vergeben.");
			} else {
				req.getSession().setAttribute("errorMessage", "Qualifikationen konnten nicht vergeben werden.");
			}

		} catch (NumberFormatException e) {
			req.getSession().setAttribute("errorMessage", "Ungültige Kurs-ID oder Anzahl der Meetings.");
			logger.error("Error in handleGrantQualifications due to number format", e);
		}
		resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDashboardServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.StatisticsDAO;
import de.technikteam.dao.StorageDAO; 
import de.technikteam.model.StorageItem; 
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/dashboard`, this servlet serves as the entry point for the
 * main administrative dashboard. It uses the `StatisticsDAO` to fetch key
 * metrics like the total user count and the number of active events. It then
 * forwards this data to `admin_dashboard.jsp` for display.
 */
@WebServlet("/admin/dashboard")
public class AdminDashboardServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminDashboardServlet.class);
	private StatisticsDAO statisticsDAO;
	private StorageDAO storageDAO;

	@Override
	public void init() {
		statisticsDAO = new StatisticsDAO();
		storageDAO = new StorageDAO(); 
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Admin dashboard requested. Fetching statistics.");

		int userCount = statisticsDAO.getUserCount();
		int activeEventCount = statisticsDAO.getActiveEventCount();
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems(); 

		request.setAttribute("userCount", userCount);
		request.setAttribute("activeEventCount", activeEventCount);
		request.setAttribute("defectiveItems", defectiveItems); 

		logger.debug("Forwarding to admin_dashboard.jsp with userCount={}, activeEventCount={}, defectiveItems={}",
				userCount, activeEventCount, defectiveItems.size());
		request.getRequestDispatcher("/views/admin/admin_dashboard.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDefectServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * Servlet to display a list of all defective items.
 */
@WebServlet("/admin/defekte")
public class AdminDefectServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems();
		request.setAttribute("defectiveItems", defectiveItems);
		request.getRequestDispatcher("/views/admin/admin_defect_list.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminEventServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import de.technikteam.service.AchievementService;
import de.technikteam.service.NotificationService;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Course;
import de.technikteam.model.Event;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

@WebServlet("/admin/veranstaltungen")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 40, maxRequestSize = 1024 * 1024 * 80)
public class AdminEventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminEventServlet.class);

	private EventDAO eventDAO;
	private CourseDAO courseDAO;
	private StorageDAO storageDAO;
	private UserDAO userDAO;
	private AttachmentDAO attachmentDAO;
	private EventCustomFieldDAO customFieldDAO;
	private InventoryKitDAO kitDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		courseDAO = new CourseDAO();
		storageDAO = new StorageDAO();
		userDAO = new UserDAO();
		attachmentDAO = new AttachmentDAO();
		customFieldDAO = new EventCustomFieldDAO();
		kitDAO = new InventoryKitDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).setPrettyPrinting().create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User user = (User) req.getSession().getAttribute("user");
		if (!user.getPermissions().contains("EVENT_READ") && !user.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminEventServlet received GET with action: {}", action);
		try {
			switch (action) {
			case "getEventData":
				getEventDataAsJson(req, resp);
				break;
			case "getAssignmentData":
				getAssignmentDataAsJson(req, resp);
				break;
			default:
				listEvents(req, resp);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminEventServlet doGet", e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(req)) {
			logger.warn("CSRF token validation failed for event action.");
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = req.getParameter("action");

		logger.debug("AdminEventServlet received POST with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "assignUsers":
			handleAssignUsers(req, resp);
			break;
		case "updateStatus":
			handleStatusUpdate(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		case "inviteUsers":
			handleInviteUsers(req, resp);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
			break;
		}
	}

	private void listEvents(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		logger.info("Listing all events for admin view.");
		List<Event> eventList = eventDAO.getAllEvents();
		List<Course> allCourses = courseDAO.getAllCourses();
		List<StorageItem> allItems = storageDAO.getAllItems();
		List<User> allUsers = userDAO.getAllUsers();
		List<InventoryKit> allKits = kitDAO.getAllKits();

		req.setAttribute("eventList", eventList);
		req.setAttribute("allUsers", allUsers);
		req.setAttribute("allKits", allKits);
		req.setAttribute("allCoursesJson", gson.toJson(allCourses));
		req.setAttribute("allItemsJson", gson.toJson(allItems));
		req.setAttribute("allKitsJson", gson.toJson(allKits));

		req.getRequestDispatcher("/views/admin/admin_events_list.jsp").forward(req, resp);
	}

	private void getEventDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
				event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
				event.setAttachments(attachmentDAO.getAttachmentsForParent("EVENT", eventId, "ADMIN"));
				event.setCustomFields(customFieldDAO.getCustomFieldsForEvent(eventId));
				String eventJson = gson.toJson(event);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(eventJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND);
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	private void getAssignmentDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			Set<Integer> assignedUserIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
					.collect(Collectors.toSet());

			Map<String, Object> responseData = new HashMap<>();
			responseData.put("signedUpUsers", signedUpUsers);
			responseData.put("assignedUserIds", assignedUserIds);

			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(gson.toJson(responseData));

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID for assignment data.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		boolean isUpdate = idParam != null && !idParam.isEmpty();

		boolean hasPermission = false;
		if (isUpdate) {
			int eventId = Integer.parseInt(idParam);
			Event event = eventDAO.getEventById(eventId);
			boolean isLeader = event != null && event.getLeaderUserId() == adminUser.getId();
			hasPermission = adminUser.getPermissions().contains("EVENT_UPDATE")
					|| adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL") || isLeader;
		} else {
			hasPermission = adminUser.getPermissions().contains("EVENT_CREATE")
					|| adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL");
		}

		if (!hasPermission) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		Event event = new Event();

		try {
			event.setName(request.getParameter("name"));
			event.setDescription(request.getParameter("description"));
			event.setLocation(request.getParameter("location"));
			event.setEventDateTime(LocalDateTime.parse(request.getParameter("eventDateTime")));

			String endDateTimeParam = request.getParameter("endDateTime");
			if (endDateTimeParam != null && !endDateTimeParam.isEmpty()) {
				event.setEndDateTime(LocalDateTime.parse(endDateTimeParam));
			}

			String leaderIdStr = request.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				event.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			int eventId = 0;
			if (isUpdate) {
				eventId = Integer.parseInt(idParam);
				Event originalEvent = eventDAO.getEventById(eventId);
				event.setId(eventId);
				event.setStatus(originalEvent.getStatus());
				if (eventDAO.updateEvent(event)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
				}
			} else {
				eventId = eventDAO.createEvent(event);
				if (eventId > 0) {
					event.setId(eventId);
					AdminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
				}
			}

			if (eventId > 0) {
				String[] requiredCourseIds = request.getParameterValues("requiredCourseId");
				String[] requiredPersons = request.getParameterValues("requiredPersons");
				eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);

				String[] itemIds = request.getParameterValues("itemId");
				String[] quantities = request.getParameterValues("itemQuantity");
				eventDAO.saveReservations(eventId, itemIds, quantities);

				String[] customFieldNames = request.getParameterValues("customFieldName");
				String[] customFieldTypes = request.getParameterValues("customFieldType");
				if (customFieldNames != null) {
					List<EventCustomField> customFields = new ArrayList<>();
					for (int i = 0; i < customFieldNames.length; i++) {
						if (customFieldNames[i] != null && !customFieldNames[i].trim().isEmpty()) {
							EventCustomField cf = new EventCustomField();
							cf.setFieldName(customFieldNames[i]);
							cf.setFieldType(customFieldTypes[i]);
							cf.setRequired(true);
							customFields.add(cf);
						}
					}
					customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
				}

				Part filePart = request.getPart("attachment");
				if (filePart != null && filePart.getSize() > 0) {
					String requiredRole = request.getParameter("requiredRole");
					handleAttachmentUpload(filePart, eventId, requiredRole, adminUser, request);
				}
				request.getSession().setAttribute("successMessage", "Event erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Event konnte nicht gespeichert werden.");
			}

		} catch (DateTimeParseException e) {
			logger.error("Invalid date format submitted for event.", e);
			request.getSession().setAttribute("errorMessage",
					"Ungültiges Datumsformat. Bitte das Format 'YYYY-MM-DDTHH:MM' verwenden.");
		} catch (Exception e) {
			logger.error("Error during event creation/update.", e);
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}

		response.sendRedirect(request.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleAttachmentUpload(Part filePart, int eventId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "events";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		Attachment attachment = new Attachment();
		attachment.setParentId(eventId);
		attachment.setParentType("EVENT");
		attachment.setFilename(fileName);
		attachment.setFilepath("events/" + fileName);
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			AdminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + fileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("id"));
		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);

		if (attachment == null) {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Anhang nicht gefunden.");
			return;
		}

		Event event = eventDAO.getEventById(attachment.getParentId());
		boolean isLeader = event != null && event.getLeaderUserId() == adminUser.getId();
		boolean hasPermission = adminUser.getPermissions().contains("EVENT_UPDATE")
				|| adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL") || isLeader;

		if (!hasPermission) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		logger.warn("Attempting to delete event attachment ID {}", attachmentId);

		File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());
		if (physicalFile.exists())
			physicalFile.delete();

		if (attachmentDAO.deleteAttachment(attachmentId)) {
			AdminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
					+ "' von Event ID " + attachment.getParentId() + " gelöscht.");
			resp.setContentType("application/json");
			resp.getWriter().write("{\"message\":\"Anhang gelöscht\"}");
		} else {
			resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Anhang konnte nicht aus DB gelöscht werden.");
		}
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("EVENT_DELETE")
				&& !adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete event with ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.deleteEvent(eventId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT",
						"Event '" + event.getName() + "' (ID: " + eventId + ") endgültig gelöscht.");
				req.getSession().setAttribute("successMessage", "Event wurde gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Event konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleAssignUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("eventId"));
		Event event = eventDAO.getEventById(eventId);
		boolean isLeader = event != null && event.getLeaderUserId() == adminUser.getId();

		if (!adminUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS")
				&& !adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL") && !isLeader) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		try {
			String[] userIds = req.getParameterValues("userIds");
			logger.info("Assigning {} users to event ID {}", (userIds != null ? userIds.length : 0), eventId);
			eventDAO.assignUsersToEvent(eventId, userIds);

			String assignedUserCount = (userIds != null) ? String.valueOf(userIds.length) : "0";
			String logDetails = String.format("Team für Event '%s' (ID: %d) finalisiert. %s Benutzer zugewiesen.",
					event.getName(), eventId, assignedUserCount);
			AdminLogService.log(adminUser.getUsername(), "ASSIGN_TEAM", logDetails);

			req.getSession().setAttribute("successMessage", "Team für das Event wurde erfolgreich zugewiesen.");
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for user assignment.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleStatusUpdate(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("id"));
		Event event = eventDAO.getEventById(eventId);
		boolean isLeader = event != null && event.getLeaderUserId() == adminUser.getId();

		if (!adminUser.getPermissions().contains("EVENT_UPDATE")
				&& !adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL") && !isLeader) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		try {
			String newStatus = req.getParameter("newStatus");
			logger.info("Updating status for event ID {} to '{}'", eventId, newStatus);
			if (event != null && eventDAO.updateEventStatus(eventId, newStatus)) {
				String logDetails = String.format("Status für Event '%s' (ID: %d) von '%s' auf '%s' geändert.",
						event.getName(), eventId, event.getStatus(), newStatus);
				AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT_STATUS", logDetails);

				if ("ABGESCHLOSSEN".equals(newStatus)) {
					List<User> assignedUsers = eventDAO.getAssignedUsersForEvent(eventId);
					for (User user : assignedUsers) {
						AchievementService.getInstance().checkAndGrantAchievements(user, "EVENT_COMPLETED");
					}
				}

				req.getSession().setAttribute("successMessage", "Event-Status erfolgreich aktualisiert.");
			} else {
				req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Event-Status.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for status update.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleInviteUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int eventId = Integer.parseInt(req.getParameter("eventId"));
		String[] userIdsToInvite = req.getParameterValues("userIds");

		Event event = eventDAO.getEventById(eventId);
		if (event == null) {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Event not found.");
			return;
		}

		boolean hasPermission = adminUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS")
				|| adminUser.getPermissions().contains("ACCESS_ADMIN_PANEL")
				|| adminUser.getId() == event.getLeaderUserId();

		if (!hasPermission) {
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
			return;
		}

		if (userIdsToInvite != null) {
			for (String userIdStr : userIdsToInvite) {
				try {
					int userId = Integer.parseInt(userIdStr);
					NotificationService.getInstance().sendEventInvitation(userId, event.getName(), eventId);
				} catch (NumberFormatException e) {
					logger.warn("Invalid user ID '{}' found when sending invitations.", userIdStr);
				}
			}
			req.getSession().setAttribute("successMessage",
					"Einladungen an " + userIdsToInvite.length + " Benutzer gesendet.");
			AdminLogService.log(adminUser.getUsername(), "INVITE_CREW", "Einladungen für Event '" + event.getName()
					+ "' an " + userIdsToInvite.length + " Benutzer gesendet.");
		} else {
			req.getSession().setAttribute("infoMessage", "Keine Benutzer zum Einladen ausgewählt.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileCategoryServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;

/**
 * This servlet is uniquely mapped to multiple URL patterns to handle specific
 * CRUD actions for file categories. It processes POST requests to create,
 * update, or delete a category based on the servlet path, logs the action, and
 * then redirects back to the main admin file management page.
 */
@WebServlet({ "/admin/dateien/kategorien/erstellen", "/admin/dateien/kategorien/aktualisieren",
		"/admin/dateien/kategorien/loeschen" })
public class AdminFileCategoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileCategoryServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		HttpSession session = request.getSession();

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for file category action.");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String path = request.getServletPath();
		User adminUser = (User) session.getAttribute("user");
		logger.debug("AdminFileCategoryServlet processing POST for action path: {}", path);

		try {
			if (path.endsWith("/erstellen")) {
				handleCreate(request, response, adminUser);
			} else if (path.endsWith("/aktualisieren")) {
				handleUpdate(request, response, adminUser);
			} else if (path.endsWith("/loeschen")) {
				handleDelete(request, response, adminUser);
			} else {
				logger.warn("Unknown path received in AdminFileCategoryServlet: {}", path);
				response.sendError(HttpServletResponse.SC_BAD_REQUEST);
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in AdminFileCategoryServlet for action {}", path, e);
			session.setAttribute("errorMessage", "Ungültige ID für Kategorie-Aktion.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
		} catch (Exception e) {
			logger.error("An unexpected error occurred in AdminFileCategoryServlet", e);
			session.setAttribute("errorMessage", "Ein unerwarteter Fehler ist aufgetreten.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
		}
	}

	/**
	 * Handles the creation of a new file category.
	 */
	private void handleCreate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		String categoryName = request.getParameter("categoryName");
		HttpSession session = request.getSession();

		if (categoryName == null || categoryName.trim().isEmpty()) {
			session.setAttribute("errorMessage", "Kategoriename darf nicht leer sein.");
		} else if (fileDAO.createCategory(categoryName)) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_FILE_CATEGORY",
					"Dateikategorie '" + categoryName + "' erstellt.");
			session.setAttribute("successMessage", "Kategorie '" + categoryName + "' erfolgreich erstellt.");
		} else {
			session.setAttribute("errorMessage",
					"Kategorie konnte nicht erstellt werden. Möglicherweise existiert der Name bereits.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	/**
	 * Handles the update of an existing file category's name.
	 */
	private void handleUpdate(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		int categoryId = Integer.parseInt(request.getParameter("categoryId"));
		String newName = request.getParameter("categoryName");
		String oldName = fileDAO.getCategoryNameById(categoryId);
		HttpSession session = request.getSession();

		if (newName == null || newName.trim().isEmpty()) {
			session.setAttribute("errorMessage", "Kategoriename darf nicht leer sein.");
		} else if (fileDAO.updateCategory(categoryId, newName)) {
			AdminLogService.log(adminUser.getUsername(), "UPDATE_FILE_CATEGORY",
					"Dateikategorie '" + oldName + "' (ID: " + categoryId + ") umbenannt in '" + newName + "'.");
			session.setAttribute("successMessage", "Kategorie erfolgreich umbenannt.");
		} else {
			session.setAttribute("errorMessage", "Kategorie konnte nicht umbenannt werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	/**
	 * Handles the deletion of a file category.
	 */
	private void handleDelete(HttpServletRequest request, HttpServletResponse response, User adminUser)
			throws IOException {
		int categoryId = Integer.parseInt(request.getParameter("categoryId"));
		String categoryName = fileDAO.getCategoryNameById(categoryId);
		HttpSession session = request.getSession();

		if (fileDAO.deleteCategory(categoryId)) {
			AdminLogService.log(adminUser.getUsername(), "DELETE_FILE_CATEGORY",
					"Dateikategorie '" + (categoryName != null ? categoryName : "ID: " + categoryId) + "' gelöscht.");
			session.setAttribute("successMessage", "Kategorie erfolgreich gelöscht.");
		} else {
			session.setAttribute("errorMessage",
					"Kategorie konnte nicht gelöscht werden. Stellen Sie sicher, dass keine untergeordneten Elemente vorhanden sind.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileManagementServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Handles the main administrative page for file management. It lists all files
 * and categories, and provides the forms for creating/updating them.
 */
@WebServlet("/admin/dateien")
public class AdminFileManagementServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileManagementServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("Admin file management page requested by user '{}' (Role: {})", user.getUsername(),
				user.getRoleName());

		Map<String, List<File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(user);
		List<FileCategory> allCategories = fileDAO.getAllCategories();

		request.setAttribute("groupedFiles", groupedFiles);
		request.setAttribute("allCategories", allCategories);

		logger.debug("Forwarding file and category data to admin_files.jsp.");
		request.getRequestDispatcher("/views/admin/admin_files.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;

/**
 * Handles all administrative file upload actions, including creating new files
 * and uploading new versions of existing files. Note: A similarly named
 * `UploadFileServlet` using Apache Commons exists but is obsolete. This version
 * uses the standard `@MultipartConfig`.
 */
@WebServlet("/admin/uploadFile")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, // 1 MB
		maxFileSize = 1024 * 1024 * 20, // 20 MB
		maxRequestSize = 1024 * 1024 * 50) // 50 MB
public class AdminFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for file upload action by user '{}'.", adminUser.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");
		Part filePart;
		try {
			filePart = request.getPart("file");
		} catch (IOException | ServletException e) {
			logger.error("Error getting file part from multipart request.", e);
			session.setAttribute("errorMessage", "Fehler beim Verarbeiten der Anfrage: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
			return;
		}

		if (filePart == null || filePart.getSize() == 0) {
			logger.warn("Upload failed: File part is missing or empty.");
			session.setAttribute("errorMessage", "Bitte wählen Sie eine Datei zum Hochladen aus.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
			return;
		}

		if ("create".equals(action)) {
			handleCreateUpload(request, response, adminUser, filePart);
		} else if ("update".equals(action)) {
			handleUpdateUpload(request, response, adminUser, filePart);
		} else {
			logger.warn("Received upload POST with unknown action: '{}'", action);
			session.setAttribute("errorMessage", "Unbekannte Upload-Aktion.");
			response.sendRedirect(request.getContextPath() + "/admin/dateien");
		}
	}

	private void handleCreateUpload(HttpServletRequest request, HttpServletResponse response, User adminUser,
			Part filePart) throws IOException {
		HttpSession session = request.getSession();
		try {
			String categoryIdStr = request.getParameter("categoryId");
			String requiredRole = request.getParameter("requiredRole");
			if (categoryIdStr == null || requiredRole == null) {
				throw new IllegalArgumentException("Missing required form fields for file creation.");
			}

			int categoryId = Integer.parseInt(categoryIdStr);
			String submittedFileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();

			// Security: Sanitize filename to prevent path traversal and other injection
			// attacks.
			String sanitizedFileName = submittedFileName.replaceAll("[^a-zA-Z0-9.\\-_ ]", "_");
			File targetFile = new File(AppConfig.UPLOAD_DIRECTORY, sanitizedFileName);

			// Prevent overwriting existing files on create
			if (targetFile.exists()) {
				session.setAttribute("errorMessage",
						"Eine Datei mit diesem Namen existiert bereits. Bitte benennen Sie die Datei um oder laden Sie eine neue Version auf der Dateiliste hoch.");
				response.sendRedirect(request.getContextPath() + "/admin/dateien");
				return;
			}

			filePart.write(targetFile.getAbsolutePath());
			logger.info("CREATE: File '{}' successfully written to disk for user '{}'.", sanitizedFileName,
					adminUser.getUsername());

			de.technikteam.model.File newDbFile = new de.technikteam.model.File();
			newDbFile.setFilename(sanitizedFileName);
			newDbFile.setFilepath(sanitizedFileName); // Filepath is relative to the UPLOAD_DIRECTORY
			newDbFile.setCategoryId(categoryId);
			newDbFile.setRequiredRole(requiredRole);

			if (fileDAO.createFile(newDbFile)) {
				AdminLogService.log(adminUser.getUsername(), "FILE_UPLOAD",
						"Datei '" + sanitizedFileName + "' hochgeladen.");
				session.setAttribute("successMessage", "Datei erfolgreich hochgeladen.");
			} else {
				if (!targetFile.delete()) {
					logger.warn("Failed to clean up file '{}' after DB insert failure.", targetFile.getAbsolutePath());
				}
				session.setAttribute("errorMessage", "DB-Fehler: Datei konnte nicht gespeichert werden.");
			}
		} catch (Exception e) {
			logger.error("Error during file creation upload.", e);
			session.setAttribute("errorMessage", "Fehler beim Upload: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleUpdateUpload(HttpServletRequest request, HttpServletResponse response, User adminUser,
			Part filePart) throws IOException {
		HttpSession session = request.getSession();
		try {
			String fileIdStr = request.getParameter("fileId");
			if (fileIdStr == null) {
				throw new IllegalArgumentException("Missing fileId for update operation.");
			}

			int fileId = Integer.parseInt(fileIdStr);
			de.technikteam.model.File dbFile = fileDAO.getFileById(fileId);
			if (dbFile == null) {
				session.setAttribute("errorMessage", "Datei zum Aktualisieren nicht gefunden.");
				response.sendRedirect(request.getContextPath() + "/admin/dateien");
				return;
			}

			// Security: Overwrite the existing file using its sanitized path from the
			// database.
			File targetFile = new File(AppConfig.UPLOAD_DIRECTORY, dbFile.getFilepath());
			filePart.write(targetFile.getAbsolutePath());
			logger.info("UPDATE: File '{}' (ID: {}) successfully overwritten on disk by user '{}'.",
					dbFile.getFilename(), fileId, adminUser.getUsername());

			// Update the timestamp in the database to reflect the new version.
			if (fileDAO.updateFileRecord(dbFile)) {
				AdminLogService.log(adminUser.getUsername(), "FILE_UPDATE",
						"Neue Version für Datei '" + dbFile.getFilename() + "' hochgeladen.");
				session.setAttribute("successMessage", "Neue Version erfolgreich hochgeladen.");
			} else {
				session.setAttribute("errorMessage", "DB-Fehler: Datei-Metadaten konnten nicht aktualisiert werden.");
			}
		} catch (Exception e) {
			logger.error("Error during file update upload.", e);
			session.setAttribute("errorMessage", "Fehler beim Aktualisieren: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminKitServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@WebServlet("/admin/kits")
public class AdminKitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminKitServlet.class);
	private InventoryKitDAO kitDAO;
	private StorageDAO storageDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		kitDAO = new InventoryKitDAO();
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");

		if ("getKitItems".equals(action)) {
			getKitItemsAsJson(req, resp);
			return;
		}

		// Performance: Fetch all kits and their items in one go to prevent N+1 queries.
		List<InventoryKit> kits = kitDAO.getAllKitsWithItems();
		List<StorageItem> allItems = storageDAO.getAllItems();

		req.setAttribute("kits", kits);
		req.setAttribute("allItems", allItems);
		req.setAttribute("allItemsJson", gson.toJson(allItems));

		req.getRequestDispatcher("/views/admin/admin_kits.jsp").forward(req, resp);
	}

	private void getKitItemsAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int kitId = Integer.parseInt(req.getParameter("id"));
			List<InventoryKitItem> items = kitDAO.getItemsForKit(kitId);
			String jsonResponse = gson.toJson(items);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid kit ID.");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		req.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(req)) {
			logger.warn("CSRF token validation failed for kit action.");
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		logger.debug("AdminKitServlet received POST with action: {}", action);

		try {
			switch (action) {
			case "create":
				handleCreateKit(req, adminUser);
				break;
			case "update":
				handleUpdateKit(req, adminUser);
				break;
			case "delete":
				handleDeleteKit(req, adminUser);
				break;
			case "updateKitItems":
				handleUpdateKitItems(req, adminUser);
				break;
			default:
				logger.warn("Unknown kit action: {}", action);
				break;
			}
		} catch (Exception e) {
			logger.error("Error processing kit action '{}'", action, e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
		}

		resp.sendRedirect(req.getContextPath() + "/admin/kits");
	}

	private void handleCreateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		kit.setLocation(req.getParameter("location"));
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + newId + ") erstellt.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich erstellt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht erstellt werden.");
		}
	}

	private void handleUpdateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setId(Integer.parseInt(req.getParameter("id")));
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		kit.setLocation(req.getParameter("location"));

		if (kitDAO.updateKit(kit)) {
			AdminLogService.log(adminUser.getUsername(), "UPDATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + kit.getId() + ") aktualisiert.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich aktualisiert.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht aktualisiert werden.");
		}
	}

	private void handleDeleteKit(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("id"));
		InventoryKit kit = kitDAO.getKitById(kitId);
		if (kitDAO.deleteKit(kitId)) {
			AdminLogService.log(adminUser.getUsername(), "DELETE_KIT",
					"Kit '" + (kit != null ? kit.getName() : "N/A") + "' (ID: " + kitId + ") gelöscht.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht gelöscht werden.");
		}
	}

	private void handleUpdateKitItems(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("kitId"));
		String[] itemIds = req.getParameterValues("itemIds");
		String[] quantities = req.getParameterValues("quantities");

		if (kitDAO.updateKitItems(kitId, itemIds, quantities)) {
			AdminLogService.log(adminUser.getUsername(), "UPDATE_KIT_ITEMS",
					"Inhalt für Kit ID " + kitId + " aktualisiert.");
			req.getSession().setAttribute("successMessage", "Kit-Inhalt erfolgreich gespeichert.");
		} else {
			req.getSession().setAttribute("errorMessage", "Fehler beim Speichern des Kit-Inhalts.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminLogServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/log`, this servlet retrieves all entries from the
 * administrative action log using the `AdminLogDAO`. It then passes the
 * complete list of logs to `admin_log.jsp` for display and filtering on the
 * client side.
 */
@WebServlet("/admin/log")
public class AdminLogServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminLogServlet.class);
	private AdminLogDAO adminLogDAO;

	@Override
	public void init() {
		adminLogDAO = new AdminLogDAO();
		logger.info("AdminLogServlet has been initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		logger.info("Admin log page requested by user '{}'.", adminUser.getUsername());
		try {
			List<AdminLog> logs = adminLogDAO.getAllLogs();
			request.setAttribute("logs", logs);
			logger.info("Fetched {} log entries. Forwarding to JSP.", logs.size());
			request.getRequestDispatcher("/views/admin/admin_log.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("A critical error occurred in AdminLogServlet doGet()", e);
			response.sendRedirect(request.getContextPath() + "/error500");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.AttachmentDAO;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Attachment;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet("/admin/meetings")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);
	private MeetingDAO meetingDAO;
	private CourseDAO courseDAO;
	private AttachmentDAO attachmentDAO;
	private UserDAO userDAO;
	private Gson gson;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		courseDAO = new CourseDAO();
		attachmentDAO = new AttachmentDAO();
		userDAO = new UserDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(req)) {
			logger.warn("CSRF token validation failed for meeting action.");
			resp.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = req.getParameter("action");

		logger.debug("AdminMeetingServlet received POST with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			logger.warn("Unknown action received in doPost: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/meetings");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.info("Listing all meetings for course ID: {}", courseId);
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();

		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);

		req.getRequestDispatcher("/views/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<Attachment> attachments = attachmentDAO.getAttachmentsForParent("MEETING", meetingId, "ADMIN");
				Map<String, Object> responseData = new HashMap<>();
				responseData.put("meetingData", meeting);
				responseData.put("attachmentsData", attachments);

				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID for getting meeting data as JSON", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(req.getParameter("name"));
			meeting.setDescription(req.getParameter("description"));
			meeting.setLocation(req.getParameter("location"));

			String leaderIdStr = req.getParameter("leaderUserId");
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			String startDateTimeStr = req.getParameter("meetingDateTime");
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = req.getParameter("endDateTime");
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(req.getParameter("id"));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				}
			} else {
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = req.getParameter("requiredRole");
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}

		} catch (DateTimeParseException | NumberFormatException e) {
			logger.error("Invalid data format in meeting form.", e);
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.warn("Attempting to delete meeting ID {} from course ID {}", meetingId, courseId);

		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.warn("Attempting to delete attachment ID {}", attachmentId);

		Attachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());

			if (physicalFile.exists()) {
				physicalFile.delete();
			}

			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_ATTACHMENT", "Anhang '" + attachment.getFilename()
						+ "' von Meeting ID " + attachment.getParentId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "meetings";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		Attachment attachment = new Attachment();
		attachment.setParentId(meetingId);
		attachment.setParentType("MEETING");
		attachment.setFilename(fileName);
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			logger.info("Attachment '{}' uploaded for meeting ID {} by '{}'", fileName, meetingId,
					adminUser.getUsername());
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			AdminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminReportServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.ReportDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@WebServlet("/admin/berichte")
public class AdminReportServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminReportServlet.class);
	private ReportDAO reportDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		reportDAO = new ReportDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String reportType = request.getParameter("report");
		String exportType = request.getParameter("export");

		if (reportType != null && !reportType.isEmpty()) {
			handleSpecificReport(request, response, reportType, exportType);
			return;
		}

		logger.debug("Serving main reports dashboard.");

		List<Map<String, Object>> eventTrendData = reportDAO.getEventCountByMonth(12);
		List<Map<String, Object>> userActivityData = reportDAO.getUserParticipationStats(10);

		request.setAttribute("eventTrendDataJson", gson.toJson(eventTrendData));
		request.setAttribute("userActivityDataJson", gson.toJson(userActivityData));

		request.setAttribute("totalInventoryValue", reportDAO.getTotalInventoryValue());
		request.getRequestDispatcher("/views/admin/admin_reports.jsp").forward(request, response);
	}

	private void handleSpecificReport(HttpServletRequest request, HttpServletResponse response, String reportType,
			String exportType) throws IOException, ServletException {
		List<Map<String, Object>> reportData = null;
		String reportTitle = "";
		String jspPath = "/views/admin/report_display.jsp";

		switch (reportType) {
		case "user_activity":
			reportData = reportDAO.getUserActivityStats();
			reportTitle = "Benutzeraktivitäts-Bericht";
			break;
		case "event_participation":
			reportData = reportDAO.getEventParticipationSummary();
			reportTitle = "Event-Teilnahme-Bericht";
			break;
		case "inventory_usage":
			reportData = reportDAO.getInventoryUsageFrequency();
			reportTitle = "Lagernutzungs-Bericht";
			break;
		default:
			logger.warn("Unknown report type requested: {}", reportType);
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Unbekannter Berichtstyp.");
			return;
		}

		if ("csv".equalsIgnoreCase(exportType)) {
			logger.info("Exporting report '{}' to CSV.", reportType);
			exportToCsv(response, reportData, reportType + "_report.csv");
		} else {
			logger.debug("Forwarding data for report '{}' to JSP.", reportType);
			request.setAttribute("reportData", reportData);
			request.setAttribute("reportTitle", reportTitle);
			request.getRequestDispatcher(jspPath).forward(request, response);
		}
	}

	private void exportToCsv(HttpServletResponse response, List<Map<String, Object>> data, String filename)
			throws IOException {
		response.setContentType("text/csv");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");

		if (data == null || data.isEmpty()) {
			response.getWriter().write("No data available to export.");
			return;
		}

		try (PrintWriter writer = response.getWriter()) {
			String header = String.join(",", data.get(0).keySet());
			writer.println(header);

			for (Map<String, Object> row : data) {
				String line = row.values().stream().map(this::escapeCsvField).collect(Collectors.joining(","));
				writer.println(line);
			}
		}
	}

	private String escapeCsvField(Object field) {
		if (field == null) {
			return "";
		}
		String fieldStr = field.toString();
		if (fieldStr.contains(",") || fieldStr.contains("\"") || fieldStr.contains("\n")) {
			return "\"" + fieldStr.replace("\"", "\"\"") + "\"";
		}
		return fieldStr;
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.config.AppConfig;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

@WebServlet("/admin/lager")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class.getName());
	private StorageDAO storageDAO;
	private MaintenanceLogDAO maintenanceLogDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		maintenanceLogDAO = new MaintenanceLogDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		try {
			logger.info("Listing all storage items for admin view.");
			List<StorageItem> storageList = storageDAO.getAllItems();
			request.setAttribute("storageList", storageList);
			request.getRequestDispatcher("/views/admin/admin_storage_list.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("Error in doGet of AdminStorageServlet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for storage action.");
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token");
			return;
		}

		String action = request.getParameter("action");

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response);
			break;
		case "delete":
			handleDelete(request, response);
			break;
		case "updateDefect":
			handleDefectUpdate(request, response);
			break;
		case "updateStatus":
			handleStatusUpdate(request, response);
			break;
		case "repair":
			handleRepair(request, response);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/lager");
			break;
		}
	}

	private void handleRepair(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int repairedQty = Integer.parseInt(request.getParameter("repaired_quantity"));
			String notes = request.getParameter("repair_notes");

			if (storageDAO.repairItems(itemId, repairedQty)) {
				MaintenanceLogEntry log = new MaintenanceLogEntry();
				log.setItemId(itemId);
				log.setUserId(adminUser.getId());
				log.setAction(repairedQty + " Stück repariert");
				log.setNotes(notes);
				maintenanceLogDAO.createLog(log);

				AdminLogService.log(adminUser.getUsername(), "REPAIR_ITEM", String.format(
						"%d Stück von Artikel-ID %d als repariert markiert. Notiz: %s", repairedQty, itemId, notes));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich als repariert markiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Reparatur konnte nicht verbucht werden (vielleicht nicht genug defekte Artikel?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		} catch (SQLException e) {
			request.getSession().setAttribute("errorMessage", "Datenbankfehler: " + e.getMessage());
		}
		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}

	private void handleStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String newStatus = request.getParameter("status");
			String notes = request.getParameter("notes");

			storageDAO.updateItemStatus(itemId, newStatus);

			MaintenanceLogEntry log = new MaintenanceLogEntry();
			log.setItemId(itemId);
			log.setUserId(adminUser.getId());
			log.setNotes(notes);

			String logAction;
			if ("MAINTENANCE".equals(newStatus)) {
				logAction = "Marked for Maintenance";
			} else {
				logAction = "Returned to Service";
			}
			log.setAction(logAction);

			maintenanceLogDAO.createLog(log);
			AdminLogService.log(adminUser.getUsername(), "UPDATE_ITEM_STATUS",
					"Status für Artikel-ID " + itemId + " auf '" + newStatus + "' gesetzt. Notiz: " + notes);
			request.getSession().setAttribute("successMessage", "Artikelstatus erfolgreich aktualisiert.");
		} catch (Exception e) {
			logger.error("Error updating item status", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Status.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(request.getParameter("action"));

		try {
			StorageItem item = new StorageItem();
			item.setName(request.getParameter("name"));
			item.setLocation(request.getParameter("location"));
			item.setCabinet(request.getParameter("cabinet"));
			item.setCompartment(request.getParameter("compartment"));
			item.setQuantity(Integer.parseInt(request.getParameter("quantity")));
			item.setMaxQuantity(Integer.parseInt(request.getParameter("maxQuantity")));

			String weightStr = request.getParameter("weight_kg");
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = request.getParameter("price_eur");
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(request.getParameter("id"));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
					item.setStatus(originalItem.getStatus());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				AdminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDefectUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int defectiveQty = Integer.parseInt(request.getParameter("defective_quantity"));
			String reason = request.getParameter("defect_reason");

			if (storageDAO.updateDefectiveStatus(itemId, defectiveQty, reason)) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS",
						String.format("Defekt-Status für Artikel-ID %d aktualisiert: %d defekt. Grund: %s", itemId,
								defectiveQty, reason));
				request.getSession().setAttribute("successMessage", "Defekt-Status aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Defekt-Status konnte nicht aktualisiert werden (vielleicht nicht genug Bestand?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		} catch (SQLException e) {
			request.getSession().setAttribute("errorMessage", "Datenbankfehler: " + e.getMessage());
		}

		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Forwards to the system status dashboard page.
 */
@WebServlet("/admin/system")
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/admin/admin_system.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.PermissionDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Permission;
import de.technikteam.model.Role;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.CSRFUtil;
import de.technikteam.util.NavigationRegistry;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@WebServlet("/admin/mitglieder")
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private UserDAO userDAO;
	private EventDAO eventDAO;
	private RoleDAO roleDAO;
	private PermissionDAO permissionDAO;
	private Gson gson;

	@Override
	public void init() {
		userDAO = new UserDAO();
		eventDAO = new EventDAO();
		roleDAO = new RoleDAO();
		permissionDAO = new PermissionDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		if (!currentUser.getPermissions().contains("USER_READ") && !currentUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		logger.debug("AdminUserServlet received GET with action: {}", action);

		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			case "getUserData":
				getUserDataAsJson(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (NumberFormatException e) {
			logger.warn("Invalid ID format in GET request: {}", e.getMessage());
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige ID angegeben.");
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		if (action == null) {
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			logger.warn("CSRF token validation failed for action '{}'.", action);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid or missing CSRF token.");
			return;
		}

		try {
			switch (action) {
			case "create":
				handleCreateUser(request, response);
				break;
			case "update":
				handleUpdateUser(request, response);
				break;
			case "delete":
				handleDeleteUser(request, response);
				break;
			case "resetPassword":
				handleResetPassword(request, response);
				break;
			default:
				logger.warn("Unknown POST action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
				break;
			}
		} catch (NumberFormatException e) {
			logger.warn("Invalid ID format in POST request: {}", e.getMessage());
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID übermittelt.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doPost", e);
			request.getSession().setAttribute("errorMessage",
					"Ein schwerwiegender Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Executing listUsers method.");
		List<User> userList = userDAO.getAllUsers();
		List<Role> allRoles = roleDAO.getAllRoles();
		List<Permission> allPermissions = permissionDAO.getAllPermissions();

		Map<String, List<Permission>> groupedPermissions = allPermissions.stream().collect(Collectors.groupingBy(p -> {
			String key = p.getPermissionKey();
			int underscoreIndex = key.indexOf('_');
			return (underscoreIndex != -1) ? key.substring(0, underscoreIndex) : "ALLGEMEIN";
		}, LinkedHashMap::new, Collectors.toList()));

		logger.debug("Fetched {} users, {} roles, and {} permissions from DAOs.", userList.size(), allRoles.size(),
				allPermissions.size());
		request.setAttribute("userList", userList);
		request.setAttribute("allRoles", allRoles);
		request.setAttribute("groupedPermissionsJson", gson.toJson(groupedPermissions));
		request.getRequestDispatcher("/views/admin/admin_users.jsp").forward(request, response);
	}

	private void getUserDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int userId = Integer.parseInt(req.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user != null) {
			Set<Integer> permissionIds = permissionDAO.getPermissionIdsForUser(userId);
			Map<String, Object> responseData = new HashMap<>();
			responseData.put("user", user);
			responseData.put("permissionIds", permissionIds);

			String userJson = gson.toJson(responseData);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(userJson);
		} else {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
		}
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);
		request.setAttribute("userToView", user);
		request.setAttribute("eventHistory", eventHistory);
		request.getRequestDispatcher("/views/admin/admin_user_details.jsp").forward(request, response);
	}

	private void handleCreateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_CREATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		String username = request.getParameter("username");
		String pass = request.getParameter("password");
		if (username == null || username.trim().isEmpty() || pass == null || pass.trim().length() < 8) {
			request.getSession().setAttribute("errorMessage",
					"Benutzername darf nicht leer sein und Passwort muss mindestens 8 Zeichen lang sein.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		int roleId = Integer.parseInt(request.getParameter("roleId"));
		String[] permissionIds = request.getParameterValues("permissionIds");

		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRoleId(roleId);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0);
		}
		newUser.setClassName(request.getParameter("className"));

		String email = request.getParameter("email");
		newUser.setEmail(email != null && !email.trim().isEmpty() ? email.trim() : null);

		int newUserId = userDAO.createUser(newUser, pass);
		if (newUserId > 0) {
			userDAO.updateUserPermissions(newUserId, permissionIds);
			String logDetails = String.format(
					"Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %d %s) erstellt und Berechtigungen zugewiesen.",
					newUser.getUsername(), newUserId, newUser.getRoleId(), newUser.getClassYear(),
					newUser.getClassName());
			AdminLogService.log(adminUser.getUsername(), "CREATE_USER", logDetails);
			request.getSession().setAttribute("successMessage",
					"Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.");
		} else {
			request.getSession().setAttribute("errorMessage",
					"Benutzer konnte nicht erstellt werden (ggf. existiert der Name oder die E-Mail bereits).");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleUpdateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userId = Integer.parseInt(request.getParameter("userId"));
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");

		if (!adminUser.getPermissions().contains("USER_UPDATE") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		User originalUser = userDAO.getUserById(userId);
		if (originalUser == null) {
			logger.error("Attempted to update non-existent user with ID: {}", userId);
			request.getSession().setAttribute("errorMessage", "Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		int roleId = Integer.parseInt(request.getParameter("roleId"));
		String[] permissionIds = request.getParameterValues("permissionIds");

		User updatedUser = new User();
		updatedUser.setId(userId);
		updatedUser.setUsername(request.getParameter("username").trim());
		updatedUser.setRoleId(roleId);
		updatedUser.setClassName(request.getParameter("className"));

		String email = request.getParameter("email");
		updatedUser.setEmail(email != null && !email.trim().isEmpty() ? email.trim() : null);

		try {
			updatedUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		boolean profileUpdated = userDAO.updateUser(updatedUser);
		boolean permissionsUpdated = userDAO.updateUserPermissions(userId, permissionIds);

		if (profileUpdated || permissionsUpdated) {
			// If the admin is editing their own profile, refresh their session object
			if (adminUser.getId() == userId) {
				User refreshedUserInSession = userDAO.getUserById(userId);
				refreshedUserInSession.setPermissions(userDAO.getPermissionsForUser(userId));
				session.setAttribute("user", refreshedUserInSession);
				session.setAttribute("navigationItems",
						NavigationRegistry.getNavigationItemsForUser(refreshedUserInSession));
			}
			AdminLogService.log(adminUser.getUsername(), "UPDATE_USER",
					"Benutzer '" + originalUser.getUsername() + "' (ID: " + userId + ") aktualisiert.");
			request.getSession().setAttribute("successMessage", "Benutzerdaten erfolgreich aktualisiert.");
		} else {
			request.getSession().setAttribute("infoMessage", "Keine Änderungen an den Benutzerdaten vorgenommen.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleDeleteUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) request.getSession().getAttribute("user");

		if (!loggedInAdmin.getPermissions().contains("USER_DELETE") && !loggedInAdmin.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		if (loggedInAdmin.getId() == userIdToDelete) {
			request.getSession().setAttribute("errorMessage", "Sie können sich nicht selbst löschen.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}

		User userToDelete = userDAO.getUserById(userIdToDelete);
		if (userToDelete == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer mit ID " + userIdToDelete + " nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}

		// Prevent a regular admin from deleting a super-admin.
		if (userToDelete.getPermissions().contains("ACCESS_ADMIN_PANEL")
				&& !loggedInAdmin.getPermissions().contains("ACCESS_ADMIN_PANEL")) {
			logger.warn("Privilege Escalation Attempt: User '{}' tried to delete super-admin '{}'",
					loggedInAdmin.getUsername(), userToDelete.getUsername());
			request.getSession().setAttribute("errorMessage",
					"Sie haben keine Berechtigung, einen Haupt-Administrator zu löschen.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}

		String deletedUsername = userToDelete.getUsername();
		String deletedRoleName = userToDelete.getRoleName();

		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.", deletedUsername,
					userIdToDelete, deletedRoleName);
			AdminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);
			request.getSession().setAttribute("successMessage", "Benutzer erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Benutzer konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleResetPassword(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		if (!adminUser.getPermissions().contains("USER_PASSWORD_RESET") && !adminUser.hasAdminAccess()) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied");
			return;
		}

		int userId = Integer.parseInt(request.getParameter("userId"));
		User userToReset = userDAO.getUserById(userId);

		if (userToReset == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer zum Zurücksetzen nicht gefunden.");
		} else {
			String newPassword = generateRandomPassword(12);
			if (userDAO.changePassword(userId, newPassword)) {
				String logDetails = String.format("Passwort für Benutzer '%s' (ID: %d) zurückgesetzt.",
						userToReset.getUsername(), userId);
				AdminLogService.log(adminUser.getUsername(), "RESET_PASSWORD", logDetails);

				request.getSession().setAttribute("passwordResetUser", userToReset.getUsername());
				request.getSession().setAttribute("passwordResetNewPassword", newPassword);
			} else {
				request.getSession().setAttribute("errorMessage", "Passwort konnte nicht zurückgesetzt werden.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		SecureRandom random = new SecureRandom();
		return random.ints(length, 0, chars.length()).mapToObj(chars::charAt)
				.collect(StringBuilder::new, StringBuilder::append, StringBuilder::append).toString();
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/matrix`, this servlet constructs the data for the
 * comprehensive qualification and attendance matrix. It fetches all users, all
 * course templates, all meetings for each course, and all attendance records.
 * It then organizes this data and forwards it to `admin_matrix.jsp` for
 * rendering a grid view that shows which users have attended which course
 * meetings.
 */
@WebServlet("/admin/matrix")
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private UserDAO userDAO;
	private CourseDAO courseDAO;
	private MeetingDAO meetingDAO;
	private MeetingAttendanceDAO meetingAttendanceDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
		courseDAO = new CourseDAO();
		meetingDAO = new MeetingDAO();
		meetingAttendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		request.getRequestDispatcher("/views/admin/admin_matrix.jsp").forward(request, response);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\api\CrewFinderApiServlet.java
========================================================================

package de.technikteam.servlet.admin.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.Event;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * An API endpoint for finding qualified and available users for a specific
 * event. This is used by the "Crew Finder" feature in the event management
 * modal.
 */
@WebServlet("/api/admin/crew-finder")
public class CrewFinderApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(CrewFinderApiServlet.class);
	private EventDAO eventDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User currentUser = (User) request.getSession().getAttribute("user");
		String eventIdParam = request.getParameter("eventId");

		if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing eventId parameter.");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			Event event = eventDAO.getEventById(eventId);
			if (event == null) {
				response.sendError(HttpServletResponse.SC_NOT_FOUND, "Event not found.");
				return;
			}

			// Security: User must have general assignment rights OR be the leader of this
			// specific event.
			boolean hasPermission = currentUser.getPermissions().contains("EVENT_MANAGE_ASSIGNMENTS")
					|| currentUser.getPermissions().contains("ACCESS_ADMIN_PANEL")
					|| currentUser.getId() == event.getLeaderUserId();

			if (!hasPermission) {
				logger.warn("User '{}' tried to find crew for event {} without permission.", currentUser.getUsername(),
						eventId);
				response.sendError(HttpServletResponse.SC_FORBIDDEN, "Access Denied.");
				return;
			}

			List<User> qualifiedUsers = eventDAO.getQualifiedAndAvailableUsersForEvent(eventId);
			logger.info("Found {} qualified and available users for event ID {}.", qualifiedUsers.size(), eventId);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(gson.toJson(qualifiedUsers));

		} catch (NumberFormatException e) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid eventId format.");
		}
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\SystemStatsApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Provides system statistics as a JSON API endpoint. This servlet is protected
 * by the AdminFilter.
 */
@WebServlet("/api/admin/system-stats")
public class SystemStatsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private SystemInfoService systemInfoService;
	private Gson gson;

	@Override
	public void init() throws ServletException {
		systemInfoService = new SystemInfoService();
		gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		String jsonResponse = gson.toJson(stats);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\UserPreferencesApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import de.technikteam.dao.UserDAO;
import de.technikteam.model.User;
import de.technikteam.util.CSRFUtil;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Set;

@WebServlet("/api/user/preferences")
public class UserPreferencesApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(UserPreferencesApiServlet.class);
	private static final Set<String> VALID_THEMES = Set.of("light", "dark");
	private UserDAO userDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		HttpSession session = request.getSession(false);
		if (session == null || session.getAttribute("user") == null) {
			response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "User not authenticated.");
			return;
		}

		if (!CSRFUtil.isTokenValid(request)) {
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Invalid CSRF Token.");
			return;
		}

		User user = (User) session.getAttribute("user");
		String theme = request.getParameter("theme");

		if (theme == null || !VALID_THEMES.contains(theme)) {
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid theme value.");
			return;
		}

		if (userDAO.updateUserTheme(user.getId(), theme)) {
			user.setTheme(theme);
			session.setAttribute("user", user); // Update user object in session
			logger.info("Updated theme for user '{}' to '{}'.", user.getUsername(), theme);
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update theme for user '{}' in database.", user.getUsername());
			response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Could not save theme preference.");
		}
	}
}