
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\AppConfig.java
========================================================================

package de.technikteam.config;

/**
 * A simple configuration class that holds a single, application-wide constant: 
 * the absolute file path for the directory where all user-uploaded files are stored.
 * This centralized approach makes it easy to change the upload location without
 * modifying multiple files.
 */
public class AppConfig {
	public static final String UPLOAD_DIRECTORY = "C:\\dev\\eclipse\\workspace\\TechnikTeam\\resources\\uploads";
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\DateFormatter.java
========================================================================

package de.technikteam.config;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Locale;

/**
 * A utility class with static methods to format java.time.LocalDateTime objects
 * into German-style date (dd.MM.yyyy) and date-time (dd.MM.yyyy, HH:mm) strings
 * for consistent display in the user interface. It also provides a method to
 * format a date range intelligently.
 */
public class DateFormatter {

	// A formatter for a full date and time, e.g., "10.06.2025, 17:45"
	private static final DateTimeFormatter GERMAN_DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy, HH:mm",
			Locale.GERMANY);

	// A formatter for just the date, e.g., "10.06.2025"
	private static final DateTimeFormatter GERMAN_DATE_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yyyy",
			Locale.GERMANY);

	// A formatter for just the time, e.g., "17:45"
	private static final DateTimeFormatter GERMAN_TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm", Locale.GERMANY);

	/**
	 * Formats a LocalDateTime object into a German date and time string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025, 17:45"), or an empty string
	 *         if input is null.
	 */
	public static String formatDateTime(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_TIME_FORMATTER);
	}

	/**
	 * Formats a LocalDateTime object into a German date string.
	 * 
	 * @param ldt The LocalDateTime to format.
	 * @return The formatted string (e.g., "10.06.2025"), or an empty string if
	 *         input is null.
	 */
	public static String formatDate(LocalDateTime ldt) {
		if (ldt == null) {
			return "";
		}
		return ldt.format(GERMAN_DATE_FORMATTER);
	}

	/**
	 * Formats a start and end LocalDateTime into a human-readable German range.
	 * Examples: - "10.06.2025, 17:45 Uhr" (if end is null) - "10.06.2025, 17:45 -
	 * 19:00 Uhr" (if on the same day) - "10.06.2025, 17:45 Uhr - 11.06.2025, 18:00
	 * Uhr" (if on different days)
	 * 
	 * @param start The start time.
	 * @param end   The end time.
	 * @return The formatted string.
	 */
	public static String formatDateTimeRange(LocalDateTime start, LocalDateTime end) {
		if (start == null) {
			return "";
		}
		// Case 1: No end time provided
		if (end == null) {
			return formatDateTime(start) + " Uhr";
		}

		// Case 2: Start and end are on the same day
		if (start.toLocalDate().equals(end.toLocalDate())) {
			return formatDate(start) + ", " + start.format(GERMAN_TIME_FORMATTER) + " - "
					+ end.format(GERMAN_TIME_FORMATTER) + " Uhr";
		}

		// Case 3: Start and end are on different days
		return formatDateTime(start) + " Uhr - " + formatDateTime(end) + " Uhr";
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import java.lang.reflect.Type;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

/**
 * A custom serializer for the Gson library. It converts java.time.LocalDate
 * objects into the standard YYYY-MM-DD string format, which is ideal for JSON
 * data exchange and compatibility with HTML date input fields.
 */
public class LocalDateAdapter implements JsonSerializer<LocalDate> {

	@Override
	public JsonElement serialize(LocalDate date, Type typeOfSrc, JsonSerializationContext context) {
		// We convert the LocalDate to its standard ISO_LOCAL_DATE string format
		// ("YYYY-MM-DD").
		// This also gracefully handles the case where the date object might be null.
		return date == null ? null : new JsonPrimitive(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\config\LocalDateTimeAdapter.java
========================================================================

package de.technikteam.config;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A custom TypeAdapter for the Gson library to correctly handle
 * java.time.LocalDateTime. This handles both serialization (Java to JSON)
 * and deserialization (JSON to Java), preventing reflection issues with
 * the Java Module System (JPMS).
 */
public class LocalDateTimeAdapter extends TypeAdapter<LocalDateTime> {

    // Use the standard ISO format, which is ideal for JSON
    private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    @Override
    public void write(JsonWriter out, LocalDateTime value) throws IOException {
        if (value == null) {
            out.nullValue();
        } else {
            out.value(value.format(FORMATTER));
        }
    }

    @Override
    public LocalDateTime read(JsonReader in) throws IOException {
        if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
            in.nextNull();
            return null;
        }
        String value = in.nextString();
        return LocalDateTime.parse(value, FORMATTER);
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\AdminLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * A Data Access Object (DAO) responsible for all database interactions with the
 * `admin_logs` table. It provides methods to create new log entries, which are
 * used for auditing administrative actions, and to retrieve all existing logs
 * for display in the admin panel.
 */
public class AdminLogDAO {
	private static final Logger logger = LogManager.getLogger(AdminLogDAO.class);

	/**
	 * Creates a new log entry in the database. This is the primary method for
	 * recording an administrative action.
	 * 
	 * @param log The AdminLog object to persist.
	 */
	public void createLog(AdminLog log) {
		String sql = "INSERT INTO admin_logs (admin_username, action_type, details) VALUES (?, ?, ?)";
		logger.debug("Attempting to create admin log: [User: {}, Action: {}]", log.getAdminUsername(),
				log.getActionType());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, log.getAdminUsername());
			pstmt.setString(2, log.getActionType());
			pstmt.setString(3, log.getDetails());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created admin log for user '{}'.", log.getAdminUsername());
			}
		} catch (SQLException e) {
			logger.error("Failed to create admin log for user '{}'. Details: {}", log.getAdminUsername(),
					log.getDetails(), e);
		}
	}

	/**
	 * Fetches all log entries from the database, ordered with the newest first.
	 * 
	 * @return A list of AdminLog objects.
	 */
	public List<AdminLog> getAllLogs() {
		List<AdminLog> logs = new ArrayList<>();
		String sql = "SELECT id, admin_username, action_type, details, action_timestamp FROM admin_logs ORDER BY action_timestamp DESC";
		logger.debug("Executing query to fetch all admin logs.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				AdminLog logEntry = new AdminLog();
				logEntry.setId(rs.getInt("id"));
				logEntry.setAdminUsername(rs.getString("admin_username"));
				logEntry.setActionType(rs.getString("action_type"));
				logEntry.setDetails(rs.getString("details"));
				logEntry.setActionTimestamp(rs.getTimestamp("action_timestamp").toLocalDateTime());
				logs.add(logEntry);
			}
			logger.info("Fetched {} admin log entries from the database.", logs.size());
		} catch (SQLException e) {
			logger.error("Failed to fetch admin logs from the database.", e);
		}
		return logs;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\CourseDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Course;

/**
 * Data Access Object for managing `Course` templates in the `courses` table.
 * This DAO handles CRUD operations for the parent course definitions (e.g.,
 * "Grundlehrgang Tontechnik"), which serve as blueprints for individual,
 * schedulable `Meeting` instances.
 */
public class CourseDAO {
	private static final Logger logger = LogManager.getLogger(CourseDAO.class);

	/**
	 * Creates a new parent course template in the database.
	 * 
	 * @param course The Course object to create (containing name, abbreviation, and
	 *               description).
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createCourse(Course course) {
		String sql = "INSERT INTO courses (name, abbreviation, description) VALUES (?, ?, ?)";
		logger.debug("Attempting to create parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully created parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error creating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Fetches a single parent course by its ID.
	 * 
	 * @param courseId The ID of the course.
	 * @return A Course object, or null if not found.
	 */
	public Course getCourseById(int courseId) {
		String sql = "SELECT * FROM courses WHERE id = ?";
		logger.debug("Attempting to fetch course by ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found course with ID: {}", courseId);
					return mapResultSetToCourse(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching course by ID: {}", courseId, e);
		}
		logger.warn("No course found with ID: {}", courseId);
		return null;
	}

	/**
	 * Fetches all parent courses from the database, sorted alphabetically by name.
	 * 
	 * @return A list of all Course objects.
	 */
	public List<Course> getAllCourses() {
		List<Course> courses = new ArrayList<>();
		String sql = "SELECT * FROM courses ORDER BY name ASC";
		logger.debug("Attempting to fetch all parent courses.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				courses.add(mapResultSetToCourse(rs));
			}
			logger.info("Fetched {} total parent courses.", courses.size());
		} catch (SQLException e) {
			logger.error("SQL error while fetching all courses.", e);
		}
		return courses;
	}

	/**
	 * Helper method to map a ResultSet row to a Course object.
	 * 
	 * @param rs The ResultSet to map from.
	 * @return A populated Course object.
	 * @throws SQLException If a database access error occurs.
	 */
	private Course mapResultSetToCourse(ResultSet rs) throws SQLException {
		Course course = new Course();
		course.setId(rs.getInt("id"));
		course.setName(rs.getString("name"));
		course.setAbbreviation(rs.getString("abbreviation"));
		course.setDescription(rs.getString("description"));
		return course;
	}

	/**
	 * Updates an existing parent course's name, abbreviation, and description.
	 * 
	 * @param course The Course object with the updated data.
	 * @return true if the update was successful, false otherwise.
	 */
	public boolean updateCourse(Course course) {
		String sql = "UPDATE courses SET name = ?, abbreviation = ?, description = ? WHERE id = ?";
		logger.debug("Attempting to update parent course: {}", course.getName());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, course.getName());
			pstmt.setString(2, course.getAbbreviation());
			pstmt.setString(3, course.getDescription());
			pstmt.setInt(4, course.getId());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.info("Successfully updated parent course: {}", course.getName());
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error updating course: {}", course.getName(), e);
			return false;
		}
	}

	/**
	 * Deletes a parent course from the database. NOTE: This relies on `ON DELETE
	 * CASCADE` in the database schema to also delete all associated meetings and
	 * qualifications.
	 * 
	 * @param courseId The ID of the course to delete.
	 * @return true if the deletion was successful, false otherwise.
	 */
	public boolean deleteCourse(int courseId) {
		String sql = "DELETE FROM courses WHERE id = ?";
		logger.debug("Attempting to delete parent course with ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				logger.warn("Successfully deleted parent course with ID: {}", courseId);
				return true;
			}
			return false;

		} catch (SQLException e) {
			logger.error("SQL error deleting course with ID: {}", courseId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\DatabaseManager.java
========================================================================

package de.technikteam.dao;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import java.sql.Connection;
import java.sql.SQLException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class DatabaseManager {

	private static final Logger logger = LogManager.getLogger(DatabaseManager.class);
	private static HikariDataSource dataSource;

	static {
		try {
			logger.info("Initializing database connection pool...");

			HikariConfig hikariConfiguration = new HikariConfig();

			// DEFINITIVE FIX: The serverTimezone=UTC parameter has been removed.
			// This prevents the JDBC driver from applying an incorrect timezone conversion
			// when reading timestamps from the database.
			hikariConfiguration.setJdbcUrl(
					"jdbc:mysql://localhost:3306/technik_team_db?useUnicode=true&characterEncoding=UTF-8&useSSL=false&useLegacyDatetimeCode=false");

			hikariConfiguration.setUsername("technik");
			hikariConfiguration.setPassword("X32MYaaD");

			hikariConfiguration.setMaximumPoolSize(10);
			hikariConfiguration.setMinimumIdle(5);
			hikariConfiguration.setConnectionTimeout(30000);
			hikariConfiguration.setIdleTimeout(600000);
			hikariConfiguration.setMaxLifetime(1800000);

			dataSource = new HikariDataSource(hikariConfiguration);

			logger.info("================================================================");
			logger.info("DATABASE CONNECTION POOL INITIALIZED SUCCESSFULLY.");
			logger.info("================================================================");

		} catch (Exception exception) {
			logger.fatal(
					"Failed to initialize database connection pool! The application cannot function without a database.",
					exception);
			throw new RuntimeException("Could not initialize database pool", exception);
		}
	}

	public static Connection getConnection() throws SQLException {
		if (dataSource == null) {
			logger.error("Datasource is null. The database manager was not initialized correctly.");
			throw new SQLException("Database connection pool is not available.");
		}
		return dataSource.getConnection();
	}

	public static void closeDataSource() {
		if (dataSource != null && !dataSource.isClosed()) {
			logger.info("Closing database connection pool...");
			dataSource.close();
			logger.info("Database connection pool closed successfully.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventAttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventAttachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing file attachments for events, interacting with the
 * `event_attachments` table.
 */
public class EventAttachmentDAO {
	private static final Logger logger = LogManager.getLogger(EventAttachmentDAO.class);

	public boolean addAttachment(EventAttachment attachment) {
		String sql = "INSERT INTO event_attachments (event_id, filename, filepath, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to event ID {}", attachment.getFilename(), attachment.getEventId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachment.getEventId());
			pstmt.setString(2, attachment.getFilename());
			pstmt.setString(3, attachment.getFilepath());
			pstmt.setString(4, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to event {}", attachment.getEventId(), e);
			return false;
		}
	}

	public List<EventAttachment> getAttachmentsForEvent(int eventId, String userRole) {
		List<EventAttachment> attachments = new ArrayList<>();
		String sql = "SELECT * FROM event_attachments WHERE event_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
		}
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventAttachment att = new EventAttachment();
					att.setId(rs.getInt("id"));
					att.setEventId(rs.getInt("event_id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
					att.setRequiredRole(rs.getString("required_role"));
					attachments.add(att);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for event {}", eventId, e);
		}
		return attachments;
	}

	public EventAttachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM event_attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					EventAttachment att = new EventAttachment();
					att.setId(rs.getInt("id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setEventId(rs.getInt("event_id"));
					return att;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		return null;
	}

	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM event_attachments WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventChatDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventChatMessage;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

public class EventChatDAO {
	private static final Logger logger = LogManager.getLogger(EventChatDAO.class);

	public EventChatMessage postMessage(EventChatMessage message) {
		String sql = "INSERT INTO event_chat_messages (event_id, user_id, username, message_text) VALUES (?, ?, ?, ?)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {

			preparedStatement.setInt(1, message.getEventId());
			preparedStatement.setInt(2, message.getUserId());
			preparedStatement.setString(3, message.getUsername());
			preparedStatement.setString(4, message.getMessageText());

			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						return getMessageById(newId, connection);
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("Error posting chat message for event {}", message.getEventId(), exception);
		}
		return null;
	}

	public List<EventChatMessage> getMessagesForEvent(int eventId) {
		List<EventChatMessage> messages = new ArrayList<>();
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color "
				+ "FROM event_chat_messages m " + "LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id "
				+ "JOIN users u_orig ON m.user_id = u_orig.id " + // Join to get original sender's color
				"WHERE m.event_id = ? ORDER BY m.sent_at ASC";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					messages.add(mapRowToMessage(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching chat messages for event {}", eventId, exception);
		}
		return messages;
	}

	private EventChatMessage getMessageById(int messageId, Connection connection) throws SQLException {
		String sql = "SELECT m.*, u_del.username as deleted_by_username, u_orig.chat_color "
				+ "FROM event_chat_messages m " + "LEFT JOIN users u_del ON m.deleted_by_user_id = u_del.id "
				+ "JOIN users u_orig ON m.user_id = u_orig.id " + "WHERE m.id = ?";
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, messageId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					return mapRowToMessage(resultSet);
				}
			}
		}
		return null;
	}

	private EventChatMessage mapRowToMessage(ResultSet resultSet) throws SQLException {
		EventChatMessage message = new EventChatMessage();
		message.setId(resultSet.getInt("id"));
		message.setEventId(resultSet.getInt("event_id"));
		message.setUserId(resultSet.getInt("user_id"));
		message.setUsername(resultSet.getString("username"));
		message.setMessageText(resultSet.getString("message_text"));
		message.setEdited(resultSet.getBoolean("edited"));
		message.setDeleted(resultSet.getBoolean("is_deleted"));
		message.setDeletedByUserId(resultSet.getInt("deleted_by_user_id"));
		message.setDeletedByUsername(resultSet.getString("deleted_by_username"));
		message.setChatColor(resultSet.getString("chat_color")); // Get sender's color

		if (resultSet.getTimestamp("deleted_at") != null) {
			message.setDeletedAt(resultSet.getTimestamp("deleted_at").toLocalDateTime());
		}
		message.setSentAt(resultSet.getTimestamp("sent_at").toLocalDateTime());
		return message;
	}

	public boolean updateMessage(int messageId, int userId, String newText) {
		String sql = "UPDATE event_chat_messages SET message_text = ?, edited = TRUE WHERE id = ? AND user_id = ? AND is_deleted = FALSE";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newText);
			preparedStatement.setInt(2, messageId);
			preparedStatement.setInt(3, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating message ID {}", messageId, exception);
			return false;
		}
	}

	public boolean deleteMessage(int messageId, int deletersUserId, boolean isAdmin) {
		String sql;
		if (isAdmin) {
			sql = "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ?";
		} else {
			sql = "UPDATE event_chat_messages SET is_deleted = TRUE, deleted_by_user_id = ? WHERE id = ? AND user_id = ?";
		}

		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, deletersUserId);
			preparedStatement.setInt(2, messageId);
			if (!isAdmin) {
				preparedStatement.setInt(3, deletersUserId);
			}
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error soft-deleting message ID {}:", messageId, exception);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventCustomFieldDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class EventCustomFieldDAO {
	private static final Logger logger = LogManager.getLogger(EventCustomFieldDAO.class);

	public void saveCustomFieldsForEvent(int eventId, List<EventCustomField> fields) {
		String deleteSql = "DELETE FROM event_custom_fields WHERE event_id = ?";
		String insertSql = "INSERT INTO event_custom_fields (event_id, field_name, field_type, is_required, field_options) VALUES (?, ?, ?, ?, ?)";
		Connection connection = null;
		try {
			connection = DatabaseManager.getConnection();
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (fields != null && !fields.isEmpty()) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (EventCustomField field : fields) {
						insertStatement.setInt(1, eventId);
						insertStatement.setString(2, field.getFieldName());
						insertStatement.setString(3, field.getFieldType());
						insertStatement.setBoolean(4, field.isRequired());
						insertStatement.setString(5, field.getFieldOptions());
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}
			connection.commit();
			logger.info("Successfully saved {} custom fields for event ID {}", fields != null ? fields.size() : 0,
					eventId);
		} catch (SQLException e) {
			logger.error("Error saving custom fields for event ID {}. Rolling back.", eventId, e);
			if (connection != null)
				try {
					connection.rollback();
				} catch (SQLException ex) {
					logger.error("Rollback failed.", ex);
				}
		} finally {
			if (connection != null)
				try {
					connection.setAutoCommit(true);
					connection.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection.", ex);
				}
		}
	}

	public List<EventCustomField> getCustomFieldsForEvent(int eventId) {
		List<EventCustomField> fields = new ArrayList<>();
		String sql = "SELECT * FROM event_custom_fields WHERE event_id = ? ORDER BY id";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					EventCustomField field = new EventCustomField();
					field.setId(resultSet.getInt("id"));
					field.setEventId(resultSet.getInt("event_id"));
					field.setFieldName(resultSet.getString("field_name"));
					field.setFieldType(resultSet.getString("field_type"));
					field.setRequired(resultSet.getBoolean("is_required"));
					field.setFieldOptions(resultSet.getString("field_options"));
					fields.add(field);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching custom fields for event ID {}", eventId, e);
		}
		return fields;
	}

	public void saveResponse(EventCustomFieldResponse response) {
		String sql = "INSERT INTO event_custom_field_responses (field_id, user_id, response_value) VALUES (?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE response_value = VALUES(response_value)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFieldId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setString(3, response.getResponseValue());
			preparedStatement.executeUpdate();
		} catch (SQLException e) {
			logger.error("Error saving custom field response for field {} and user {}", response.getFieldId(),
					response.getUserId(), e);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Event;
import de.technikteam.model.EventAttendance;
import de.technikteam.model.SkillRequirement;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EventDAO {
	private static final Logger logger = LogManager.getLogger(EventDAO.class);

	private Event mapResultSetToEvent(ResultSet resultSet) throws SQLException {
		Event event = new Event();
		event.setId(resultSet.getInt("id"));
		event.setName(resultSet.getString("name"));

		// DEFINITIVE FIX: Read the timestamp without conversion
		Timestamp eventTimestamp = resultSet.getTimestamp("event_datetime");
		if (eventTimestamp != null) {
			event.setEventDateTime(eventTimestamp.toLocalDateTime());
		}
		Timestamp endTimestamp = resultSet.getTimestamp("end_datetime");
		if (endTimestamp != null) {
			event.setEndDateTime(endTimestamp.toLocalDateTime());
		}

		event.setDescription(resultSet.getString("description"));
		event.setLocation(resultSet.getString("location"));
		event.setStatus(resultSet.getString("status"));

		if (DaoUtils.hasColumn(resultSet, "leader_user_id")) {
			event.setLeaderUserId(resultSet.getInt("leader_user_id"));
		}
		if (DaoUtils.hasColumn(resultSet, "leader_username")) {
			event.setLeaderUsername(resultSet.getString("leader_username"));
		}
		return event;
	}

	public void setAttendanceCommitment(int eventId, int userId, String commitment) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Setting attendance commitment for user {} event {} to '{}'", userId, eventId, commitment);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, commitment);
			preparedStatement.setInt(2, eventId);
			preparedStatement.setInt(3, userId);
			preparedStatement.executeUpdate();
		} catch (SQLException exception) {
			logger.error("SQL error setting attendance commitment for user {} event {}", userId, eventId, exception);
		}
	}

	private User mapResultSetToSimpleUser(ResultSet resultSet) throws SQLException {
		return new User(resultSet.getInt("id"), resultSet.getString("username"), resultSet.getString("role"));
	}

	public List<Event> getEventHistoryForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.*, ea.signup_status FROM events e "
				+ "JOIN event_attendance ea ON e.id = ea.event_id WHERE ea.user_id = ? ORDER BY e.event_datetime DESC";
		logger.debug("Fetching event history for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			ResultSet resultSet = preparedStatement.executeQuery();
			while (resultSet.next()) {
				Event event = mapResultSetToEvent(resultSet);
				event.setUserAttendanceStatus(resultSet.getString("signup_status"));
				history.add(event);
			}
			logger.info("Found {} events in history for user ID: {}", history.size(), userId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching event history for user {}", userId, exception);
		}
		return history;
	}

	public Event getEventById(int eventId) {
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "WHERE e.id = ?";
		logger.debug("Fetching event by ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found event '{}' with ID: {}", resultSet.getString("name"), eventId);
					return mapResultSetToEvent(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching event by ID: {}", eventId, exception);
		}
		logger.warn("No event found with ID: {}", eventId);
		return null;
	}

	public List<Event> getAllEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, u.username as leader_username " + "FROM events e "
				+ "LEFT JOIN users u ON e.leader_user_id = u.id " + "ORDER BY e.event_datetime DESC";
		logger.debug("Fetching all events.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
			logger.info("Fetched a total of {} events.", events.size());
		} catch (SQLException exception) {
			logger.error("SQL error fetching all events.", exception);
		}
		return events;
	}

	public List<Event> getActiveEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status IN ('GEPLANT', 'KOMPLETT', 'LAUFEND') ORDER BY event_datetime ASC";
		logger.debug("Fetching active events.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active events.", exception);
		}
		return events;
	}

	public int createEvent(Event event) {
		String sql = "INSERT INTO events (name, event_datetime, end_datetime, description, location, status, leader_user_id) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create new event: {}", event.getName());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				preparedStatement.setNull(3, Types.TIMESTAMP);
			}
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			preparedStatement.setString(6, "GEPLANT");
			if (event.getLeaderUserId() > 0) {
				preparedStatement.setInt(7, event.getLeaderUserId());
			} else {
				preparedStatement.setNull(7, Types.INTEGER);
			}

			if (preparedStatement.executeUpdate() > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newId = generatedKeys.getInt(1);
						logger.info("Successfully created event '{}' with ID {}", event.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error creating event '{}'.", event.getName(), exception);
		}
		return 0;
	}

	public boolean updateEvent(Event event) {
		String sql = "UPDATE events SET name = ?, event_datetime = ?, end_datetime = ?, description = ?, location = ?, status = ?, leader_user_id = ? WHERE id = ?";
		logger.debug("Attempting to update event with ID: {}", event.getId());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, event.getName());
			preparedStatement.setTimestamp(2, Timestamp.valueOf(event.getEventDateTime()));
			if (event.getEndDateTime() != null) {
				preparedStatement.setTimestamp(3, Timestamp.valueOf(event.getEndDateTime()));
			} else {
				preparedStatement.setNull(3, Types.TIMESTAMP);
			}
			preparedStatement.setString(4, event.getDescription());
			preparedStatement.setString(5, event.getLocation());
			preparedStatement.setString(6, event.getStatus());
			if (event.getLeaderUserId() > 0) {
				preparedStatement.setInt(7, event.getLeaderUserId());
			} else {
				preparedStatement.setNull(7, Types.INTEGER);
			}
			preparedStatement.setInt(8, event.getId());

			boolean success = preparedStatement.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated event with ID: {}", event.getId());
			return success;
		} catch (SQLException exception) {
			logger.error("SQL error updating event with ID: {}", event.getId(), exception);
		}
		return false;
	}

	public boolean deleteEvent(int eventId) {
		String sql = "DELETE FROM events WHERE id = ?";
		logger.debug("Attempting to delete event with ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			boolean success = preparedStatement.executeUpdate() > 0;
			if (success)
				logger.warn("Successfully deleted event with ID: {}", eventId);
			return success;
		} catch (SQLException exception) {
			logger.error("SQL error deleting event with ID: {}", eventId, exception);
		}
		return false;
	}

	public boolean updateEventStatus(int eventId, String newStatus) {
		String sql = "UPDATE events SET status = ? WHERE id = ?";
		logger.debug("Attempting to update status for event {} to '{}'", eventId, newStatus);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newStatus);
			preparedStatement.setInt(2, eventId);
			boolean success = preparedStatement.executeUpdate() > 0;
			if (success)
				logger.info("Updating status for event {} to '{}' was successful.", eventId, newStatus);
			else
				logger.warn("Updating status for event {} to '{}' failed (0 rows affected).", eventId, newStatus);
			return success;
		} catch (SQLException exception) {
			logger.error("SQL error updating status for event ID: {}", eventId, exception);
			return false;
		}
	}

	public void signUpForEvent(int userId, int eventId) {
		String sql = "INSERT INTO event_attendance (user_id, event_id, signup_status, commitment_status) VALUES (?, ?, 'ANGEMELDET', 'OFFEN') ON DUPLICATE KEY UPDATE signup_status = 'ANGEMELDET'";
		logger.debug("Signing up user {} for event {}", userId, eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
			logger.info("User {} successfully signed up for event {}", userId, eventId);
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-up for user {} and event {}", userId, eventId, exception);
		}
	}

	public void signOffFromEvent(int userId, int eventId) {
		String sql = "UPDATE event_attendance SET signup_status = 'ABGEMELDET', commitment_status = 'OFFEN' WHERE user_id = ? AND event_id = ?";
		logger.debug("Signing off user {} from event {}", userId, eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			preparedStatement.setInt(2, eventId);
			preparedStatement.executeUpdate();
			logger.info("User {} successfully signed off from event {}", userId, eventId);
		} catch (SQLException exception) {
			logger.error("SQL error during event sign-off for user {} and event {}", userId, eventId, exception);
		}
	}

	public List<User> getSignedUpUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name as role FROM users u "
				+ "JOIN event_attendance ea ON u.id = ea.user_id " + "LEFT JOIN roles r on u.role_id = r.id "
				+ "WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching signed up users for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next())
					users.add(mapResultSetToSimpleUser(resultSet));
			}
			logger.info("Found {} signed-up users for event ID: {}", users.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching signed-up users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public List<EventAttendance> getAttendanceDetailsForEvent(int eventId) {
		List<EventAttendance> attendances = new ArrayList<>();
		String sql = "SELECT u.id, u.username, ea.signup_status, ea.commitment_status FROM event_attendance ea JOIN users u ON ea.user_id = u.id WHERE ea.event_id = ? AND ea.signup_status = 'ANGEMELDET'";
		logger.debug("Fetching attendance details for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					EventAttendance attendance = new EventAttendance();
					attendance.setUserId(resultSet.getInt("id"));
					attendance.setUsername(resultSet.getString("username"));
					attendance.setSignupStatus(resultSet.getString("signup_status"));
					attendance.setCommitmentStatus(resultSet.getString("commitment_status"));
					attendances.add(attendance);
				}
			}
			logger.info("Found {} attendance detail records for event ID: {}", attendances.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching attendance details for event ID: {}", eventId, exception);
		}
		return attendances;
	}

	public boolean updateCommitmentStatus(int eventId, int userId, String status) {
		String sql = "UPDATE event_attendance SET commitment_status = ? WHERE event_id = ? AND user_id = ?";
		logger.debug("Updating commitment status for event {}, user {} to '{}'", eventId, userId, status);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, status);
			preparedStatement.setInt(2, eventId);
			preparedStatement.setInt(3, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error while updating commitment status for event {}, user {}", eventId, userId,
					exception);
		}
		return false;
	}

	public List<SkillRequirement> getSkillRequirementsForEvent(int eventId) {
		List<SkillRequirement> requirements = new ArrayList<>();
		String sql = "SELECT esr.required_course_id, c.name as course_name, esr.required_persons FROM event_skill_requirements esr JOIN courses c ON esr.required_course_id = c.id WHERE esr.event_id = ?";
		logger.debug("Fetching skill requirements for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					SkillRequirement requirement = new SkillRequirement();
					requirement.setRequiredCourseId(resultSet.getInt("required_course_id"));
					requirement.setCourseName(resultSet.getString("course_name"));
					requirement.setRequiredPersons(resultSet.getInt("required_persons"));
					requirements.add(requirement);
				}
			}
			logger.info("Found {} skill requirements for event ID: {}", requirements.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching skill requirements for event ID: {}", eventId, exception);
		}
		return requirements;
	}

	public void saveSkillRequirements(int eventId, String[] requiredCourseIds, String[] requiredPersons) {
		String deleteSql = "DELETE FROM event_skill_requirements WHERE event_id = ?";
		String insertSql = "INSERT INTO event_skill_requirements (event_id, required_course_id, required_persons) VALUES (?, ?, ?)";
		logger.debug("Saving skill requirements for event ID: {}", eventId);
		Connection connection = null;
		try {
			connection = DatabaseManager.getConnection();
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (requiredCourseIds != null && requiredPersons != null
					&& requiredCourseIds.length == requiredPersons.length) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (int i = 0; i < requiredCourseIds.length; i++) {
						if (requiredCourseIds[i] == null || requiredCourseIds[i].isEmpty()
								|| "0".equals(requiredPersons[i]))
							continue;
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(requiredCourseIds[i]));
						insertStatement.setInt(3, Integer.parseInt(requiredPersons[i]));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}

			connection.commit();
			logger.info("Successfully saved skill requirements for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException exception) {
			logger.error("Transaction error during saving skill requirements for event ID: {}. Rolling back.", eventId,
					exception);
			if (connection != null) {
				try {
					connection.rollback();
				} catch (SQLException rollbackException) {
					logger.error("Failed to rollback transaction.", rollbackException);
				}
			}
		} finally {
			if (connection != null) {
				try {
					connection.setAutoCommit(true);
					connection.close();
				} catch (SQLException closeException) {
					logger.error("Failed to close connection.", closeException);
				}
			}
		}
	}

	public List<User> getAssignedUsersForEvent(int eventId) {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.id, u.username, r.role_name AS role FROM users u "
				+ "JOIN event_assignments ea ON u.id = ea.user_id " + "LEFT JOIN roles r ON u.role_id = r.id "
				+ "WHERE ea.event_id = ?";
		logger.debug("Fetching assigned users for event ID: {}", eventId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					users.add(mapResultSetToSimpleUser(resultSet));
				}
			}
			logger.info("Found {} assigned users for event ID: {}", users.size(), eventId);
		} catch (SQLException exception) {
			logger.error("SQL error fetching assigned users for event ID: {}", eventId, exception);
		}
		return users;
	}

	public void assignUsersToEvent(int eventId, String[] userIds) {
		String deleteSql = "DELETE FROM event_assignments WHERE event_id = ?";
		String insertSql = "INSERT INTO event_assignments (event_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning users to event ID: {}", eventId);
		Connection connection = null;
		try {
			connection = DatabaseManager.getConnection();
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (String userId : userIds) {
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(userId));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}

			connection.commit();
			logger.info("Successfully assigned {} users to event ID {}", (userIds != null ? userIds.length : 0),
					eventId);

		} catch (SQLException | NumberFormatException exception) {
			logger.error("SQL transaction error during user assignment for event ID: {}. Rolling back.", eventId,
					exception);
			if (connection != null) {
				try {
					connection.rollback();
				} catch (SQLException rollbackException) {
					logger.error("Failed to rollback transaction.", rollbackException);
				}
			}
		} finally {
			if (connection != null) {
				try {
					connection.setAutoCommit(true);
					connection.close();
				} catch (SQLException closeException) {
					logger.error("Failed to close connection.", closeException);
				}
			}
		}
	}

	public List<Event> getUpcomingEventsForUser(User user, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.*, " + "CASE " + "    WHEN eas.user_id IS NOT NULL THEN 'ZUGEWIESEN' "
				+ "    WHEN ea.signup_status IS NOT NULL THEN ea.signup_status " + "    ELSE 'OFFEN' "
				+ "END AS calculated_user_status " + "FROM events e "
				+ "LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.user_id = ? "
				+ "LEFT JOIN event_assignments eas ON e.id = eas.event_id AND eas.user_id = ? "
				+ "WHERE e.event_datetime >= NOW() " + "AND ("
				+ "  NOT EXISTS (SELECT 1 FROM event_skill_requirements esr WHERE esr.event_id = e.id) OR "
				+ "  EXISTS (SELECT 1 FROM event_skill_requirements esr JOIN user_qualifications uq ON esr.required_course_id = uq.course_id WHERE esr.event_id = e.id AND uq.user_id = ?)"
				+ ") " + "ORDER BY e.event_datetime ASC" + (limit > 0 ? " LIMIT ?" : "");

		logger.debug("Fetching upcoming events for user ID: {} with limit: {}", user.getId(), limit);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {

			preparedStatement.setInt(1, user.getId());
			preparedStatement.setInt(2, user.getId());
			preparedStatement.setInt(3, user.getId());
			if (limit > 0) {
				preparedStatement.setInt(4, limit);
			}

			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Event event = mapResultSetToEvent(resultSet);
					String finalStatus = resultSet.getString("calculated_user_status");
					event.setUserAttendanceStatus(finalStatus);
					events.add(event);
				}
				logger.info("Found {} qualified upcoming events for user ID {}", events.size(), user.getId());
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching qualified upcoming events for user {}", user.getId(), exception);
		}
		return events;
	}

	public List<Event> getAllActiveAndUpcomingEvents() {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT * FROM events WHERE status != 'ABGESCHLOSSEN' AND status != 'ABGESAGT' AND event_datetime >= NOW() - INTERVAL 1 DAY ORDER BY event_datetime ASC";
		logger.debug("Fetching all active and upcoming events for calendar feed.");
		try (Connection connection = DatabaseManager.getConnection();
				Statement statement = connection.createStatement();
				ResultSet resultSet = statement.executeQuery(sql)) {
			while (resultSet.next()) {
				events.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching active/upcoming events for calendar.", exception);
		}
		return events;
	}

	public void saveReservations(int eventId, String[] itemIds, String[] quantities) {
		String deleteSql = "DELETE FROM event_storage_reservations WHERE event_id = ?";
		String insertSql = "INSERT INTO event_storage_reservations (event_id, item_id, reserved_quantity) VALUES (?, ?, ?)";

		Connection connection = null;
		try {
			connection = DatabaseManager.getConnection();
			connection.setAutoCommit(false);

			try (PreparedStatement deleteStatement = connection.prepareStatement(deleteSql)) {
				deleteStatement.setInt(1, eventId);
				deleteStatement.executeUpdate();
			}

			if (itemIds != null && quantities != null && itemIds.length == quantities.length) {
				try (PreparedStatement insertStatement = connection.prepareStatement(insertSql)) {
					for (int i = 0; i < itemIds.length; i++) {
						if (itemIds[i] == null || itemIds[i].isEmpty())
							continue;
						insertStatement.setInt(1, eventId);
						insertStatement.setInt(2, Integer.parseInt(itemIds[i]));
						insertStatement.setInt(3, Integer.parseInt(quantities[i]));
						insertStatement.addBatch();
					}
					insertStatement.executeBatch();
				}
			}
			connection.commit();
			logger.info("Successfully saved storage reservations for event ID: {}", eventId);
		} catch (SQLException | NumberFormatException exception) {
			logger.error("Error saving storage reservations for event {}. Rolling back.", eventId, exception);
			if (connection != null)
				try {
					connection.rollback();
				} catch (SQLException rollbackException) {
					logger.error("Failed to rollback transaction.", rollbackException);
				}
		} finally {
			if (connection != null)
				try {
					connection.setAutoCommit(true);
					connection.close();
				} catch (SQLException closeException) {
					logger.error("Failed to close connection.", closeException);
				}
		}
	}

	public List<StorageItem> getReservedItemsForEvent(int eventId) {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.id, si.name, esr.reserved_quantity FROM event_storage_reservations esr "
				+ "JOIN storage_items si ON esr.item_id = si.id WHERE esr.event_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					StorageItem item = new StorageItem();
					item.setId(resultSet.getInt("id"));
					item.setName(resultSet.getString("name"));
					item.setQuantity(resultSet.getInt("reserved_quantity"));
					items.add(item);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching reserved items for event ID: {}", eventId, exception);
		}
		return items;
	}

	public List<Event> getCompletedEventsForUser(int userId) {
		List<Event> history = new ArrayList<>();
		String sql = "SELECT e.* FROM events e " + "JOIN event_assignments ea ON e.id = ea.event_id "
				+ "WHERE ea.user_id = ? AND e.status = 'ABGESCHLOSSEN' " + "ORDER BY e.event_datetime DESC";
		logger.debug("Fetching completed event history for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			ResultSet resultSet = preparedStatement.executeQuery();
			while (resultSet.next()) {
				history.add(mapResultSetToEvent(resultSet));
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching completed event history for user {}", userId, exception);
		}
		return history;
	}

	public List<Event> getAssignedEventsForUser(int userId, int limit) {
		List<Event> events = new ArrayList<>();
		String sql = "SELECT e.* FROM events e " + "JOIN event_assignments ea ON e.id = ea.event_id "
				+ "WHERE ea.user_id = ? AND e.event_datetime >= NOW() " + "ORDER BY e.event_datetime ASC";
		if (limit > 0) {
			sql += " LIMIT ?";
		}
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			if (limit > 0) {
				preparedStatement.setInt(2, limit);
			}
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					events.add(mapResultSetToEvent(resultSet));
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching assigned events for user {}", userId, exception);
		}
		return events;
	}

	public List<Map<String, Object>> getReservationsForCalendar(LocalDate start, LocalDate end) {
		List<Map<String, Object>> reservations = new ArrayList<>();
		String sql = "SELECT si.id as item_id, si.name as item_name, e.id as event_id, e.name as event_name, e.event_datetime, e.end_datetime "
				+ "FROM event_storage_reservations esr " + "JOIN storage_items si ON esr.item_id = si.id "
				+ "JOIN events e ON esr.event_id = e.id "
				+ "WHERE e.event_datetime <= ? AND (e.end_datetime IS NULL OR e.end_datetime >= ?)";

		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setTimestamp(1, Timestamp.valueOf(end.atStartOfDay()));
			preparedStatement.setTimestamp(2, Timestamp.valueOf(start.atStartOfDay()));

			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("item_id", resultSet.getInt("item_id"));
					row.put("item_name", resultSet.getString("item_name"));
					row.put("event_id", resultSet.getInt("event_id"));
					row.put("event_name", resultSet.getString("event_name"));
					row.put("event_datetime", resultSet.getTimestamp("event_datetime").toLocalDateTime());
					Timestamp endTimestamp = resultSet.getTimestamp("end_datetime");
					if (endTimestamp != null) {
						row.put("end_datetime", endTimestamp.toLocalDateTime());
					} else {
						row.put("end_datetime",
								resultSet.getTimestamp("event_datetime").toLocalDateTime().plusHours(2));
					}
					reservations.add(row);
				}
			}
		} catch (SQLException exception) {
			logger.error("Error fetching reservations for resource calendar.", exception);
		}
		return reservations;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\EventTaskDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.EventTask;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for managing event-specific tasks in the `event_tasks`
 * table. It handles creating, assigning, updating status, and deleting tasks
 * associated with a "running" event.
 */
public class EventTaskDAO {
	private static final Logger logger = LogManager.getLogger(EventTaskDAO.class);

	/**
	 * Creates a new task for an event.
	 * 
	 * @param task The EventTask object to create.
	 * @return The ID of the newly created task, or 0 on failure.
	 */
	public int createTask(EventTask task) {
		String sql = "INSERT INTO event_tasks (event_id, description, status) VALUES (?, ?, 'OFFEN')";
		logger.debug("Creating new task '{}' for event ID {}", task.getDescription(), task.getEventId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setInt(1, task.getEventId());
			pstmt.setString(2, task.getDescription());
			if (pstmt.executeUpdate() > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int taskId = rs.getInt(1);
						logger.info("Created task '{}' with ID {} for event {}", task.getDescription(), taskId,
								task.getEventId());
						return taskId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating task for event {}", task.getEventId(), e);
		}
		return 0;
	}

	/**
	 * Assigns a task to one or more users. This is a transactional operation that
	 * first clears all existing assignments for the task and then adds the new
	 * ones.
	 * 
	 * @param taskId  The ID of the task.
	 * @param userIds The array of user IDs to assign to the task.
	 */
	public void assignTaskToUsers(int taskId, int[] userIds) {
		String deleteSql = "DELETE FROM event_task_assignments WHERE task_id = ?";
		String insertSql = "INSERT INTO event_task_assignments (task_id, user_id) VALUES (?, ?)";
		logger.debug("Assigning task ID {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		Connection conn = null;
		try {
			conn = DatabaseManager.getConnection();
			conn.setAutoCommit(false); // Start transaction

			// 1. Delete old assignments
			try (PreparedStatement deleteStmt = conn.prepareStatement(deleteSql)) {
				deleteStmt.setInt(1, taskId);
				deleteStmt.executeUpdate();
			}

			// 2. Insert new assignments
			if (userIds != null && userIds.length > 0) {
				try (PreparedStatement insertStmt = conn.prepareStatement(insertSql)) {
					for (int userId : userIds) {
						insertStmt.setInt(1, taskId);
						insertStmt.setInt(2, userId);
						insertStmt.addBatch();
					}
					insertStmt.executeBatch();
				}
			}

			conn.commit(); // Commit transaction
			logger.info("Successfully assigned task {} to {} users.", taskId, userIds != null ? userIds.length : 0);
		} catch (SQLException e) {
			logger.error("Error during transaction for assigning task {}. Rolling back.", taskId, e);
			if (conn != null) {
				try {
					conn.rollback();
				} catch (SQLException ex) {
					logger.error("Failed to rollback transaction for task assignment.", ex);
				}
			}
		} finally {
			if (conn != null) {
				try {
					conn.setAutoCommit(true);
					conn.close();
				} catch (SQLException ex) {
					logger.error("Failed to close connection after task assignment transaction.", ex);
				}
			}
		}
	}

	/**
	 * Updates the status of a task (e.g., from "OFFEN" to "ERLEDIGT").
	 * 
	 * @param taskId The ID of the task.
	 * @param status The new status string.
	 * @return true if the update was successful.
	 */
	public boolean updateTaskStatus(int taskId, String status) {
		String sql = "UPDATE event_tasks SET status = ? WHERE id = ?";
		logger.debug("Updating status for task ID {} to '{}'", taskId, status);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating status for task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Deletes a task and its assignments (due to database foreign key constraints).
	 * 
	 * @param taskId The ID of the task to delete.
	 * @return true if successful.
	 */
	public boolean deleteTask(int taskId) {
		String sql = "DELETE FROM event_tasks WHERE id = ?";
		logger.warn("Attempting to delete task with ID: {}", taskId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, taskId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting task {}", taskId, e);
			return false;
		}
	}

	/**
	 * Fetches all tasks for a given event, including a comma-separated list of
	 * usernames of assigned users for easy display.
	 * 
	 * @param eventId The event's ID.
	 * @return A list of EventTask objects.
	 */
	public List<EventTask> getTasksForEvent(int eventId) {
		List<EventTask> tasks = new ArrayList<>();
		// This query uses GROUP_CONCAT to aggregate assigned usernames into a single
		// string
		String sql = "SELECT t.id, t.event_id, t.description, t.status, "
				+ "GROUP_CONCAT(u.username SEPARATOR ', ') as assigned_usernames " + "FROM event_tasks t "
				+ "LEFT JOIN event_task_assignments ta ON t.id = ta.task_id "
				+ "LEFT JOIN users u ON ta.user_id = u.id " + "WHERE t.event_id = ? "
				+ "GROUP BY t.id, t.event_id, t.description, t.status " + "ORDER BY t.id";
		logger.debug("Fetching all tasks for event ID: {}", eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, eventId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setAssignedUsernames(rs.getString("assigned_usernames"));
					tasks.add(task);
				}
				logger.info("Found {} tasks for event ID: {}", tasks.size(), eventId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching tasks for event {}", eventId, e);
		}
		return tasks;
	}

	public List<EventTask> getOpenTasksForUser(int userId) {
		List<EventTask> tasks = new ArrayList<>();
		String sql = "SELECT t.*, e.name as event_name " + "FROM event_tasks t "
				+ "JOIN event_task_assignments ta ON t.id = ta.task_id " + "JOIN events e ON t.event_id = e.id "
				+ "WHERE ta.user_id = ? AND t.status = 'OFFEN' " + "ORDER BY e.event_datetime ASC";
		logger.debug("Fetching open tasks for user ID {}", userId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					EventTask task = new EventTask();
					task.setId(rs.getInt("id"));
					task.setEventId(rs.getInt("event_id"));
					task.setDescription(rs.getString("description"));
					task.setStatus(rs.getString("status"));
					task.setEventName(rs.getString("event_name"));
					tasks.add(task);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching open tasks for user {}", userId, e);
		}
		return tasks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FeedbackDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.FeedbackForm;
import de.technikteam.model.FeedbackResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class FeedbackDAO {
	private static final Logger logger = LogManager.getLogger(FeedbackDAO.class);

	public int createFeedbackForm(FeedbackForm form) {
		String sql = "INSERT INTO feedback_forms (event_id, title) VALUES (?, ?)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {
			preparedStatement.setInt(1, form.getEventId());
			preparedStatement.setString(2, form.getTitle());
			int affectedRows = preparedStatement.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {
					if (resultSet.next()) {
						return resultSet.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating feedback form for event {}", form.getEventId(), e);
		}
		return 0;
	}

	public boolean saveFeedbackResponse(FeedbackResponse response) {
		String sql = "INSERT INTO feedback_responses (form_id, user_id, rating, comments) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE rating = VALUES(rating), comments = VALUES(comments)";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, response.getFormId());
			preparedStatement.setInt(2, response.getUserId());
			preparedStatement.setInt(3, response.getRating());
			preparedStatement.setString(4, response.getComments());
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error saving feedback response for form_id {}", response.getFormId(), e);
		}
		return false;
	}

	public FeedbackForm getFeedbackFormForEvent(int eventId) {
		String sql = "SELECT * FROM feedback_forms WHERE event_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, eventId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					FeedbackForm form = new FeedbackForm();
					form.setId(resultSet.getInt("id"));
					form.setEventId(resultSet.getInt("event_id"));
					form.setTitle(resultSet.getString("title"));
					form.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
					return form;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching feedback form for event ID {}", eventId, e);
		}
		return null;
	}

	public List<FeedbackResponse> getResponsesForForm(int formId) {
		List<FeedbackResponse> responses = new ArrayList<>();
		String sql = "SELECT fr.*, u.username FROM feedback_responses fr JOIN users u ON fr.user_id = u.id WHERE fr.form_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					FeedbackResponse response = new FeedbackResponse();
					response.setId(resultSet.getInt("id"));
					response.setFormId(resultSet.getInt("form_id"));
					response.setUserId(resultSet.getInt("user_id"));
					response.setUsername(resultSet.getString("username")); // Corrected call
					response.setRating(resultSet.getInt("rating"));
					response.setComments(resultSet.getString("comments"));
					response.setSubmittedAt(resultSet.getTimestamp("submitted_at").toLocalDateTime());
					responses.add(response);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching responses for form ID {}", formId, e);
		}
		return responses;
	}

	public boolean hasUserSubmittedFeedback(int formId, int userId) {
		String sql = "SELECT 1 FROM feedback_responses WHERE form_id = ? AND user_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, formId);
			preparedStatement.setInt(2, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				return resultSet.next();
			}
		} catch (SQLException e) {
			logger.error("Error checking user feedback submission status.", e);
		}
		return false;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\FileDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * This DAO manages metadata of uploaded files stored in the `files` and
 * `file_categories` tables. It handles creating, reading, and deleting file
 * records and categories. It includes role-based filtering to control file
 * visibility and logic to group files by category for display in the UI. It
 * also provides methods to manage a simple key-value content store in the
 * `shared_documents` table.
 */
public class FileDAO {
	private static final Logger logger = LogManager.getLogger(FileDAO.class);

	/**
	 * Helper method to map a row from a ResultSet to a File object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated File object.
	 * @throws SQLException If a database error occurs.
	 */
	private File mapResultSetToFile(ResultSet rs) throws SQLException {
		File file = new File();
		file.setId(rs.getInt("id"));
		file.setFilename(rs.getString("filename"));
		file.setFilepath(rs.getString("filepath"));
		file.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
		file.setCategoryId(rs.getInt("category_id"));

		if (DaoUtils.hasColumn(rs, "required_role")) {
			file.setRequiredRole(rs.getString("required_role"));
		}

		String categoryName = rs.getString("category_name");
		file.setCategoryName(categoryName == null ? "Ohne Kategorie" : categoryName);

		return file;
	}

	/**
	 * Fetches all file records, applying role-based filtering, and groups them by
	 * category name.
	 * 
	 * @param user The current user, used to determine their role.
	 * @return A Map where keys are category names and values are lists of files.
	 */
	public Map<String, List<File>> getAllFilesGroupedByCategory(User user) {
		logger.debug("Fetching all files grouped by category for user role: {}", user.getRoleName());
		List<File> files = new ArrayList<>();

		String sql = "SELECT f.*, fc.name as category_name FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id ";

		if (!"ADMIN".equalsIgnoreCase(user.getRoleName())) {
			sql += "WHERE f.required_role = 'NUTZER' ";
			logger.debug("Applying 'NUTZER' role filter for file query.");
		}

		sql += "ORDER BY fc.name, f.filename";

		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				files.add(mapResultSetToFile(rs));
			}
			logger.info("Fetched {} files visible to user role '{}'.", files.size(), user.getRoleName());
		} catch (SQLException e) {
			logger.error("SQL error while fetching files.", e);
		}

		return files.stream().collect(Collectors.groupingBy(File::getCategoryName));
	}

	/**
	 * Creates a new file metadata record in the database.
	 * 
	 * @param file The File object to persist.
	 * @return true if creation was successful, false otherwise.
	 */
	public boolean createFile(File file) {
		String sql = "INSERT INTO files (filename, filepath, category_id, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Creating file record for '{}' with role '{}'", file.getFilename(), file.getRequiredRole());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, file.getFilename());
			pstmt.setString(2, file.getFilepath());
			if (file.getCategoryId() > 0) {
				pstmt.setInt(3, file.getCategoryId());
			} else {
				pstmt.setNull(3, Types.INTEGER);
			}
			pstmt.setString(4, file.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file record for '{}'", file.getFilename(), e);
			return false;
		}
	}

	/**
	 * Fetches all file categories from the database, sorted by name.
	 * 
	 * @return A list of FileCategory objects.
	 */
	public List<FileCategory> getAllCategories() {
		List<FileCategory> categories = new ArrayList<>();
		String sql = "SELECT * FROM file_categories ORDER BY name";
		logger.debug("Fetching all file categories.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				FileCategory cat = new FileCategory();
				cat.setId(rs.getInt("id"));
				cat.setName(rs.getString("name"));
				categories.add(cat);
			}
			logger.info("Fetched {} file categories.", categories.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching file categories.", e);
		}
		return categories;
	}

	/**
	 * Retrieves a single file's metadata by its ID.
	 *
	 * @param fileId The ID of the file to retrieve.
	 * @return A File object populated with data, or null if not found.
	 */
	public File getFileById(int fileId) {
		logger.debug("Fetching file by ID: {}", fileId);
		String sql = "SELECT f.*, fc.name as category_name " + "FROM files f "
				+ "LEFT JOIN file_categories fc ON f.category_id = fc.id " + "WHERE f.id = ?";

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found file with ID: {}", fileId);
					return mapResultSetToFile(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching file with ID: {}", fileId, e);
		}

		logger.warn("No file found with ID: {}", fileId);
		return null;
	}

	/**
	 * Deletes a file record from the 'files' table in the database. Note: This
	 * method ONLY deletes the database record. The physical file must be deleted
	 * separately by the calling servlet.
	 *
	 * @param fileId The ID of the file record to delete.
	 * @return true if the database record was successfully deleted, false
	 *         otherwise.
	 */
	public boolean deleteFile(int fileId) {
		logger.warn("Attempting to delete file record from database with ID: {}", fileId);
		String sql = "DELETE FROM files WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, fileId);
			int rowsAffected = pstmt.executeUpdate();
			if (rowsAffected > 0) {
				logger.info("Successfully deleted file record with ID: {}", fileId);
				return true;
			} else {
				logger.warn("Could not delete file record with ID: {}. It might not exist.", fileId);
				return false;
			}
		} catch (SQLException e) {
			logger.error("SQL error while deleting file record with ID: {}", fileId, e);
			return false;
		}
	}

	/**
	 * Creates a new file category.
	 * 
	 * @param categoryName The name of the new category.
	 * @return true if successful.
	 */
	public boolean createCategory(String categoryName) {
		logger.info("Creating new file category: {}", categoryName);
		String sql = "INSERT INTO file_categories (name) VALUES (?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, categoryName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating file category '{}'", categoryName, e);
			return false;
		}
	}

	/**
	 * Updates the name of an existing file category.
	 * 
	 * @param categoryId The ID of the category to update.
	 * @param newName    The new name for the category.
	 * @return true if successful.
	 */
	public boolean updateCategory(int categoryId, String newName) {
		String sql = "UPDATE file_categories SET name = ? WHERE id = ?";
		logger.debug("Updating category ID {} to new name '{}'", categoryId, newName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, newName);
			pstmt.setInt(2, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Deletes a file category. Due to "ON DELETE SET NULL" constraint in the DB,
	 * files in this category will have their category_id set to NULL.
	 * 
	 * @param categoryId The ID of the category to delete.
	 * @return true if successful.
	 */
	public boolean deleteCategory(int categoryId) {
		logger.warn("Attempting to delete category ID: {}", categoryId);
		String sql = "DELETE FROM file_categories WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting category ID {}", categoryId, e);
			return false;
		}
	}

	/**
	 * Retrieves the name of a category by its ID.
	 * 
	 * @param categoryId The ID of the category.
	 * @return The category name, or null if not found.
	 */
	public String getCategoryNameById(int categoryId) {
		String sql = "SELECT name FROM file_categories WHERE id = ?";
		logger.debug("Fetching category name for ID: {}", categoryId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, categoryId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("name");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching category name for ID: {}", categoryId, e);
		}
		return null;
	}

	/**
	 * Retrieves the content of a shared document (e.g., for the collaborative
	 * editor).
	 * 
	 * @param documentName The unique name/key of the document.
	 * @return The document's content as a string, or an empty string if not found.
	 */
	public String getDocumentContent(String documentName) {
		String sql = "SELECT content FROM shared_documents WHERE document_name = ?";
		logger.trace("Fetching document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, documentName);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					return rs.getString("content");
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching document content for name: {}", documentName, e);
		}
		return "";
	}

	/**
	 * Updates the content of a shared document.
	 * 
	 * @param documentName The unique name/key of the document to update.
	 * @param content      The new content to save.
	 * @return true if the update was successful.
	 */
	public boolean updateDocumentContent(String documentName, String content) {
		String sql = "UPDATE shared_documents SET content = ? WHERE document_name = ?";
		logger.trace("Updating document content for name: {}", documentName);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, content);
			pstmt.setString(2, documentName);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating document content for name: {}", documentName, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\InventoryKitDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing inventory kits and their contents.
 */
public class InventoryKitDAO {
	private static final Logger logger = LogManager.getLogger(InventoryKitDAO.class);

	public int createKit(InventoryKit kit) {
		String sql = "INSERT INTO inventory_kits (name, description) VALUES (?, ?)";
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						return rs.getInt(1);
					}
				}
			}
		} catch (SQLException e) {
			logger.error("Error creating inventory kit '{}'", kit.getName(), e);
		}
		return 0;
	}

	public boolean updateKit(InventoryKit kit) {
		String sql = "UPDATE inventory_kits SET name = ?, description = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, kit.getName());
			pstmt.setString(2, kit.getDescription());
			pstmt.setInt(3, kit.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error updating inventory kit ID {}", kit.getId(), e);
			return false;
		}
	}

	public InventoryKit getKitById(int kitId) {
		String sql = "SELECT * FROM inventory_kits WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					InventoryKit kit = new InventoryKit();
					kit.setId(rs.getInt("id"));
					kit.setName(rs.getString("name"));
					kit.setDescription(rs.getString("description"));
					return kit;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching kit by ID {}", kitId, e);
		}
		return null;
	}

	public boolean deleteKit(int kitId) {
		String sql = "DELETE FROM inventory_kits WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting inventory kit ID {}", kitId, e);
			return false;
		}
	}

	public List<InventoryKit> getAllKits() {
		List<InventoryKit> kits = new ArrayList<>();
		String sql = "SELECT * FROM inventory_kits ORDER BY name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				InventoryKit kit = new InventoryKit();
				kit.setId(rs.getInt("id"));
				kit.setName(rs.getString("name"));
				kit.setDescription(rs.getString("description"));
				kits.add(kit);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all inventory kits", e);
		}
		return kits;
	}

	public List<InventoryKitItem> getItemsForKit(int kitId) {
		List<InventoryKitItem> items = new ArrayList<>();
		String sql = "SELECT iki.*, si.name as item_name FROM inventory_kit_items iki "
				+ "JOIN storage_items si ON iki.item_id = si.id " + "WHERE iki.kit_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					InventoryKitItem item = new InventoryKitItem();
					item.setKitId(rs.getInt("kit_id"));
					item.setItemId(rs.getInt("item_id"));
					item.setQuantity(rs.getInt("quantity"));
					item.setItemName(rs.getString("item_name"));
					items.add(item);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching items for kit ID {}", kitId, e);
		}
		return items;
	}

	public boolean addItemToKit(int kitId, int itemId, int quantity) {
		String sql = "INSERT INTO inventory_kit_items (kit_id, item_id, quantity) VALUES (?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			pstmt.setInt(2, itemId);
			pstmt.setInt(3, quantity);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding item {} to kit {}", itemId, kitId, e);
			return false;
		}
	}

	public boolean removeItemFromKit(int kitId, int itemId) {
		String sql = "DELETE FROM inventory_kit_items WHERE kit_id = ? AND item_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, kitId);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error removing item {} from kit {}", itemId, kitId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MaintenanceLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MaintenanceLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing maintenance log entries in the `maintenance_log` table.
 */
public class MaintenanceLogDAO {
	private static final Logger logger = LogManager.getLogger(MaintenanceLogDAO.class);

	public boolean createLog(MaintenanceLogEntry log) {
		String sql = "INSERT INTO maintenance_log (item_id, user_id, action, notes, cost) VALUES (?, ?, ?, ?, ?)";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, log.getItemId());
			pstmt.setInt(2, log.getUserId());
			pstmt.setString(3, log.getAction());
			pstmt.setString(4, log.getNotes());
			pstmt.setDouble(5, log.getCost());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error creating maintenance log for item {}", log.getItemId(), e);
			return false;
		}
	}

	public List<MaintenanceLogEntry> getHistoryForItem(int itemId) {
		List<MaintenanceLogEntry> history = new ArrayList<>();
		String sql = "SELECT ml.*, u.username FROM maintenance_log ml " + "JOIN users u ON ml.user_id = u.id "
				+ "WHERE ml.item_id = ? ORDER BY ml.log_date DESC";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MaintenanceLogEntry entry = new MaintenanceLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setLogDate(rs.getTimestamp("log_date").toLocalDateTime());
					entry.setAction(rs.getString("action"));
					entry.setNotes(rs.getString("notes"));
					entry.setCost(rs.getDouble("cost"));
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching maintenance history for item {}", itemId, e);
		}
		return history;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttachmentDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.dao.DatabaseManager;
import de.technikteam.model.MeetingAttachment;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * DAO for managing file attachments for meetings, interacting with the
 * `meeting_attachments` table. It handles adding, retrieving (with role-based
 * filtering), and deleting file attachments associated with a specific meeting.
 */
public class MeetingAttachmentDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttachmentDAO.class);

	/**
	 * Attaches a file to a meeting by creating a record in the database.
	 * 
	 * @param attachment The MeetingAttachment object to persist.
	 * @return true if the record was successfully created.
	 */
	public boolean addAttachment(MeetingAttachment attachment) {
		String sql = "INSERT INTO meeting_attachments (meeting_id, filename, filepath, required_role) VALUES (?, ?, ?, ?)";
		logger.debug("Adding attachment '{}' to meeting ID {}", attachment.getFilename(), attachment.getMeetingId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachment.getMeetingId());
			pstmt.setString(2, attachment.getFilename());
			pstmt.setString(3, attachment.getFilepath());
			pstmt.setString(4, attachment.getRequiredRole());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error adding attachment to meeting {}", attachment.getMeetingId(), e);
			return false;
		}
	}

	/**
	 * Gets all attachments for a specific meeting, optionally filtering by user
	 * role. Admins see all files, while regular users only see files marked as
	 * 'NUTZER'.
	 * 
	 * @param meetingId The ID of the meeting.
	 * @param userRole  The role of the current user ("ADMIN" or "NUTZER").
	 * @return A list of MeetingAttachment objects.
	 */
	public List<MeetingAttachment> getAttachmentsForMeeting(int meetingId, String userRole) {
		List<MeetingAttachment> attachments = new ArrayList<>();

		String sql = "SELECT * FROM meeting_attachments WHERE meeting_id = ?";
		if (!"ADMIN".equalsIgnoreCase(userRole)) {
			sql += " AND required_role = 'NUTZER'";
			logger.debug("Fetching attachments for meeting {} with NUTZER role filter.", meetingId);
		} else {
			logger.debug("Fetching attachments for meeting {} with ADMIN role (no filter).", meetingId);
		}

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setMeetingId(rs.getInt("meeting_id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setUploadedAt(rs.getTimestamp("uploaded_at").toLocalDateTime());
					att.setRequiredRole(rs.getString("required_role"));
					attachments.add(att);
				}
				logger.info("Found {} attachments for meeting ID {}.", attachments.size(), meetingId);
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachments for meeting {}", meetingId, e);
		}
		return attachments;
	}

	/**
	 * Gets a single attachment by its ID, without any role check. This is typically
	 * used internally by admin functions like deletion.
	 * 
	 * @param attachmentId The ID of the attachment.
	 * @return A MeetingAttachment object or null if not found.
	 */
	public MeetingAttachment getAttachmentById(int attachmentId) {
		String sql = "SELECT * FROM meeting_attachments WHERE id = ?";
		logger.debug("Fetching attachment by ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					MeetingAttachment att = new MeetingAttachment();
					att.setId(rs.getInt("id"));
					att.setFilename(rs.getString("filename"));
					att.setFilepath(rs.getString("filepath"));
					att.setMeetingId(rs.getInt("meeting_id"));
					return att;
				}
			}
		} catch (SQLException e) {
			logger.error("Error fetching attachment by ID {}", attachmentId, e);
		}
		logger.warn("No attachment found for ID: {}", attachmentId);
		return null;
	}

	/**
	 * Deletes an attachment record from the database. The physical file must be
	 * deleted separately.
	 * 
	 * @param attachmentId The ID of the attachment to delete.
	 * @return true if successful.
	 */
	public boolean deleteAttachment(int attachmentId) {
		String sql = "DELETE FROM meeting_attachments WHERE id = ?";
		logger.warn("Attempting to delete attachment with ID: {}", attachmentId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, attachmentId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Error deleting attachment ID {}", attachmentId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingAttendanceDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.MeetingAttendance;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for handling user attendance at specific course meetings.
 * It interacts with the `meeting_attendance` table to record whether a user
 * attended a meeting, along with any relevant remarks.
 */
public class MeetingAttendanceDAO {
	private static final Logger logger = LogManager.getLogger(MeetingAttendanceDAO.class.getName());

	/**
	 * Sets or updates a user's attendance status for a specific meeting. Uses an
	 * efficient "INSERT ... ON DUPLICATE KEY UPDATE" (upsert) operation. This
	 * single method handles both signing up (attended=true) and signing off
	 * (attended=false).
	 *
	 * @param userId    The user's ID.
	 * @param meetingId The meeting's ID.
	 * @param attended  true if the user attended, false otherwise.
	 * @param remarks   Any notes about the attendance (e.g., "excused absence").
	 * @return true if the operation was successful.
	 */
	public boolean setAttendance(int userId, int meetingId, boolean attended, String remarks) {
		String sql = "INSERT INTO meeting_attendance (user_id, meeting_id, attended, remarks) VALUES (?, ?, ?, ?) "
				+ "ON DUPLICATE KEY UPDATE attended = VALUES(attended), remarks = VALUES(remarks)";

		logger.debug("Setting attendance for user {} at meeting {} to attended={}", userId, meetingId, attended);

		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			pstmt.setInt(2, meetingId);
			pstmt.setBoolean(3, attended);
			pstmt.setString(4, remarks);

			pstmt.executeUpdate();
			logger.info("Successfully set attendance for user {} at meeting {} to attended={}", userId, meetingId,
					attended);
			return true;

		} catch (SQLException e) {
			logger.error("SQL error setting attendance for user {} at meeting {}", userId, meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all attendance records from the database. This is highly efficient
	 * for building the data map used by the qualification matrix view.
	 * 
	 * @return A list of all MeetingAttendance objects in the database.
	 */
	public List<MeetingAttendance> getAllAttendance() {
		List<MeetingAttendance> allAttendance = new ArrayList<>();
		String sql = "SELECT * FROM meeting_attendance";
		logger.debug("Fetching all meeting attendance records for matrix.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				allAttendance.add(mapResultSetToAttendance(rs));
			}
			logger.info("Fetched {} total attendance records.", allAttendance.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all attendance records.", e);
		}
		return allAttendance;
	}

	/**
	 * Helper method to map a ResultSet row to a MeetingAttendance object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated MeetingAttendance object.
	 * @throws SQLException If a database error occurs.
	 */
	private MeetingAttendance mapResultSetToAttendance(ResultSet rs) throws SQLException {
		MeetingAttendance attendance = new MeetingAttendance();
		attendance.setUserId(rs.getInt("user_id"));
		attendance.setMeetingId(rs.getInt("meeting_id"));
		attendance.setAttended(rs.getBoolean("attended"));
		attendance.setRemarks(rs.getString("remarks"));
		return attendance;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\MeetingDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.Meeting;
import de.technikteam.model.User;

/**
 * Data Access Object for all Meeting-related database operations. It handles
 * CRUD for individual, schedulable course meetings stored in the `meetings`
 * table. It's distinct from CourseDAO, which manages the parent course
 * templates.
 */
public class MeetingDAO {
	private static final Logger logger = LogManager.getLogger(MeetingDAO.class);

	/**
	 * Creates a new meeting in the database, linked to a parent course.
	 * 
	 * @param meeting The Meeting object to create.
	 * @return The ID of the newly created meeting, or 0 on failure.
	 */
	public int createMeeting(Meeting meeting) {
		String sql = "INSERT INTO meetings (course_id, name, meeting_datetime, end_datetime, leader_user_id, description, location) VALUES (?, ?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create meeting '{}' for course ID {}", meeting.getName(), meeting.getCourseId());
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

			pstmt.setInt(1, meeting.getCourseId());
			pstmt.setString(2, meeting.getName());
			pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(4, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(4, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(5, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			pstmt.setString(6, meeting.getDescription());
			pstmt.setString(7, meeting.getLocation());

			int affectedRows = pstmt.executeUpdate();
			if (affectedRows > 0) {
				try (ResultSet rs = pstmt.getGeneratedKeys()) {
					if (rs.next()) {
						int newId = rs.getInt(1);
						logger.info("Successfully created meeting '{}' with new ID {}", meeting.getName(), newId);
						return newId;
					}
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error creating meeting: {}", meeting.getName(), e);
		}
		return 0; // Return 0 on failure
	}

	/**
	 * Fetches a single meeting by its ID, joining with the courses and users tables
	 * to get the parent course name and leader's username.
	 * 
	 * @param meetingId The ID of the meeting to retrieve.
	 * @return A Meeting object, or null if not found.
	 */
	public Meeting getMeetingById(int meetingId) {
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id WHERE m.id = ?";
		logger.debug("Fetching meeting by ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			try (ResultSet rs = pstmt.executeQuery()) {
				if (rs.next()) {
					logger.info("Found meeting with ID: {}", meetingId);
					return mapResultSetToMeeting(rs);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meeting by ID: {}", meetingId, e);
		}
		logger.warn("No meeting found with ID: {}", meetingId);
		return null;
	}

	/**
	 * Fetches all scheduled meetings that belong to a specific parent course.
	 * Crucial for building the qualification matrix view.
	 * 
	 * @param courseId The ID of the parent course.
	 * @return A list of Meeting objects, sorted by date.
	 */
	public List<Meeting> getMeetingsForCourse(int courseId) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username "
				+ "FROM meetings m JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "WHERE m.course_id = ? ORDER BY meeting_datetime ASC";
		logger.debug("Fetching all meetings for course ID: {}", courseId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, courseId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					meetings.add(mapResultSetToMeeting(rs));
				}
				logger.info("Found {} meetings for course ID: {}", meetings.size(), courseId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching meetings for course ID: {}", courseId, e);
		}
		return meetings;
	}

	/**
	 * Fetches all meetings from the database, typically for an admin list view.
	 * Includes the parent course name and leader's username.
	 * 
	 * @return A list of all Meeting objects.
	 */
	public List<Meeting> getAllMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id " + "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "ORDER BY m.meeting_datetime DESC";
		logger.debug("Fetching all meetings from the database.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {

			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
			logger.info("Fetched a total of {} meetings.", meetings.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all meetings.", e);
		}
		return meetings;
	}

	/**
	 * Helper method to map a row from a ResultSet to a Meeting object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated Meeting object.
	 * @throws SQLException If a database error occurs.
	 */
	private Meeting mapResultSetToMeeting(ResultSet rs) throws SQLException {
		Meeting meeting = new Meeting();
		meeting.setId(rs.getInt("id"));
		meeting.setCourseId(rs.getInt("course_id"));
		meeting.setName(rs.getString("name"));
		// REVERTED: Use the original, compatible method
		meeting.setMeetingDateTime(rs.getTimestamp("meeting_datetime").toLocalDateTime());
		if (rs.getTimestamp("end_datetime") != null) {
			// REVERTED: Use the original, compatible method
			meeting.setEndDateTime(rs.getTimestamp("end_datetime").toLocalDateTime());
		}
		meeting.setLeaderUserId(rs.getInt("leader_user_id"));
		meeting.setDescription(rs.getString("description"));
		meeting.setLocation(rs.getString("location"));
		meeting.setParentCourseName(rs.getString("parent_course_name"));
		meeting.setLeaderUsername(rs.getString("leader_username"));

		return meeting;
	}

	/**
	 * Updates an existing meeting in the database.
	 * 
	 * @param meeting The Meeting object with updated data.
	 * @return true if the update was successful.
	 */
	public boolean updateMeeting(Meeting meeting) {
		String sql = "UPDATE meetings SET name = ?, meeting_datetime = ?, end_datetime = ?, leader_user_id = ?, description = ?, location = ? WHERE id = ?";
		logger.debug("Attempting to update meeting ID: {}", meeting.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setString(1, meeting.getName());
			pstmt.setTimestamp(2, Timestamp.valueOf(meeting.getMeetingDateTime()));
			if (meeting.getEndDateTime() != null) {
				pstmt.setTimestamp(3, Timestamp.valueOf(meeting.getEndDateTime()));
			} else {
				pstmt.setNull(3, Types.TIMESTAMP);
			}
			if (meeting.getLeaderUserId() > 0) {
				pstmt.setInt(4, meeting.getLeaderUserId());
			} else {
				pstmt.setNull(4, Types.INTEGER);
			}
			pstmt.setString(5, meeting.getDescription());
			pstmt.setString(6, meeting.getLocation());
			pstmt.setInt(7, meeting.getId());

			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully updated meeting with ID: {}", meeting.getId());
			return success;

		} catch (SQLException e) {
			logger.error("SQL error updating meeting ID: {}", meeting.getId(), e);
			return false;
		}
	}

	/**
	 * Deletes a meeting from the database.
	 * 
	 * @param meetingId The ID of the meeting to delete.
	 * @return true if deletion was successful.
	 */
	public boolean deleteMeeting(int meetingId) {
		String sql = "DELETE FROM meetings WHERE id = ?";
		logger.warn("Attempting to delete meeting with ID: {}", meetingId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, meetingId);
			boolean success = pstmt.executeUpdate() > 0;
			if (success)
				logger.info("Successfully deleted meeting with ID: {}", meetingId);
			return success;
		} catch (SQLException e) {
			logger.error("SQL error deleting meeting ID: {}", meetingId, e);
			return false;
		}
	}

	/**
	 * Fetches all upcoming meetings, enriched with the attendance status for a
	 * specific user (ANGEMELDET, ABGEMELDET, OFFEN).
	 * 
	 * @param user The currently logged-in user.
	 * @return A list of upcoming Meeting objects with user-specific status.
	 */
	public List<Meeting> getUpcomingMeetingsForUser(User user) {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username, ma.attended "
				+ "FROM meetings m " + "JOIN courses c ON m.course_id = c.id "
				+ "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "LEFT JOIN meeting_attendance ma ON m.id = ma.meeting_id AND ma.user_id = ? "
				+ "WHERE m.meeting_datetime >= NOW() ORDER BY m.meeting_datetime ASC";

		logger.debug("Fetching upcoming meetings for user ID: {}", user.getId());
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, user.getId());
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Meeting meeting = mapResultSetToMeeting(rs);

					// Set the user-specific status based on the 'attended' flag from the join
					if (rs.getObject("attended") != null) {
						meeting.setUserAttendanceStatus(rs.getBoolean("attended") ? "ANGEMELDET" : "ABGEMELDET");
					} else {
						meeting.setUserAttendanceStatus("OFFEN");
					}
					meetings.add(meeting);
				}
				logger.info("Found {} upcoming meetings for user ID: {}", meetings.size(), user.getId());
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for user {}", user.getId(), e);
		}
		return meetings;
	}

	/**
	 * Fetches all upcoming meetings. This is a simplified query for use in the
	 * calendar/iCal feeds.
	 * 
	 * @return A list of all relevant Meeting objects.
	 */
	public List<Meeting> getAllUpcomingMeetings() {
		List<Meeting> meetings = new ArrayList<>();
		String sql = "SELECT m.*, c.name as parent_course_name, u.username as leader_username " + "FROM meetings m "
				+ "JOIN courses c ON m.course_id = c.id " + "LEFT JOIN users u ON m.leader_user_id = u.id "
				+ "WHERE m.meeting_datetime >= NOW() - INTERVAL 1 DAY ORDER BY m.meeting_datetime ASC";
		logger.debug("Fetching all upcoming meetings for calendar feed.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				meetings.add(mapResultSetToMeeting(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching upcoming meetings for calendar.", e);
		}
		return meetings;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\ReportDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.ParticipationHistory;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ReportDAO {
	private static final Logger logger = LogManager.getLogger(ReportDAO.class);

	public List<Map<String, Object>> getEventParticipationSummary() {
		List<Map<String, Object>> summary = new ArrayList<>();
		String sql = "SELECT e.name AS event_name, COUNT(ea.user_id) AS participant_count " + "FROM events e "
				+ "LEFT JOIN event_attendance ea ON e.id = ea.event_id AND ea.signup_status = 'ANGEMELDET' "
				+ "GROUP BY e.id, e.name " + "ORDER BY participant_count DESC, e.event_datetime DESC";
		logger.debug("Executing event participation summary query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("event_name", rs.getString("event_name"));
				row.put("participant_count", rs.getInt("participant_count"));
				summary.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating event participation summary.", e);
		}
		return summary;
	}

	public List<Map<String, Object>> getUserActivityStats() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT u.username, " + "COUNT(DISTINCT ea.event_id) AS events_signed_up, "
				+ "COUNT(DISTINCT ma.meeting_id) AS meetings_attended " + "FROM users u "
				+ "LEFT JOIN event_attendance ea ON u.id = ea.user_id AND ea.signup_status = 'ANGEMELDET' "
				+ "LEFT JOIN meeting_attendance ma ON u.id = ma.user_id AND ma.attended = 1 "
				+ "GROUP BY u.id, u.username " + "ORDER BY events_signed_up DESC, meetings_attended DESC";
		logger.debug("Executing user activity stats query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("username", rs.getString("username"));
				row.put("events_signed_up", rs.getInt("events_signed_up"));
				row.put("meetings_attended", rs.getInt("meetings_attended"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating user activity stats.", e);
		}
		return stats;
	}

	public List<Map<String, Object>> getInventoryUsageFrequency() {
		List<Map<String, Object>> stats = new ArrayList<>();
		String sql = "SELECT si.name, COUNT(sl.id) AS transaction_count " + "FROM storage_items si "
				+ "JOIN storage_log sl ON si.id = sl.item_id " + "WHERE sl.quantity_change < 0 " + // Count only
																									// check-outs
				"GROUP BY si.id, si.name " + "ORDER BY transaction_count DESC";
		logger.debug("Executing inventory usage frequency query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				Map<String, Object> row = new HashMap<>();
				row.put("item_name", rs.getString("name"));
				row.put("checkout_count", rs.getInt("transaction_count"));
				stats.add(row);
			}
		} catch (SQLException e) {
			logger.error("Error generating inventory usage frequency report.", e);
		}
		return stats;
	}

	public double getTotalInventoryValue() {
		String sql = "SELECT SUM(quantity * price_eur) AS total_value FROM storage_items";
		logger.debug("Executing total inventory value query.");
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			if (rs.next()) {
				return rs.getDouble("total_value");
			}
		} catch (SQLException e) {
			logger.error("Error calculating total inventory value.", e);
		}
		return 0.0;
	}

	public List<Map<String, Object>> getEventCountByMonth(int months) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT CONCAT(YEAR(event_datetime), '-', LPAD(MONTH(event_datetime), 2, '0')) AS month, COUNT(*) AS count "
				+ "FROM events " + "WHERE event_datetime >= DATE_SUB(NOW(), INTERVAL ? MONTH) "
				+ "GROUP BY YEAR(event_datetime), MONTH(event_datetime) " + "ORDER BY month ASC";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, months);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("month", rs.getString("month"));
					row.put("count", rs.getInt("count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating event count by month report.", e);
		}
		return data;
	}

	public List<Map<String, Object>> getUserParticipationStats(int limit) {
		List<Map<String, Object>> data = new ArrayList<>();
		String sql = "SELECT u.username, COUNT(ea.user_id) as participation_count " + "FROM event_assignments ea "
				+ "JOIN users u ON ea.user_id = u.id " + "GROUP BY u.id, u.username "
				+ "ORDER BY participation_count DESC " + "LIMIT ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, limit);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					Map<String, Object> row = new HashMap<>();
					row.put("username", rs.getString("username"));
					row.put("participation_count", rs.getInt("participation_count"));
					data.add(row);
				}
			}
		} catch (SQLException e) {
			logger.error("Error generating user participation stats.", e);
		}
		return data;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\RoleDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.Role; // Assuming a simple Role model
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

public class RoleDAO {
	private static final Logger logger = LogManager.getLogger(RoleDAO.class);

	public List<Role> getAllRoles() {
		List<Role> roles = new ArrayList<>();
		String sql = "SELECT id, role_name FROM roles ORDER BY role_name";
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {

			while (rs.next()) {
				Role role = new Role();
				role.setId(rs.getInt("id"));
				role.setRoleName(rs.getString("role_name"));
				roles.add(role);
			}
		} catch (SQLException e) {
			logger.error("Error fetching all roles", e);
		}
		return roles;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StatisticsDAO.java
========================================================================

package de.technikteam.dao;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * A simple Data Access Object used to retrieve basic aggregate numbers from the
 * database, such as the total count of users and the number of active, upcoming
 * events. This is primarily used for the administrative dashboard.
 */

public class StatisticsDAO {
	private static final Logger logger = LogManager.getLogger(StatisticsDAO.class);

	/**
	 * Gets the total count of all users in the `users` table.
	 * 
	 * @return The total number of users.
	 */
	public int getUserCount() {
		logger.debug("Getting user count.");
		return getCount("SELECT COUNT(*) FROM users");
	}

	/**
	 * Gets the count of all events that are not yet in the past.
	 * 
	 * @return The number of active/upcoming events.
	 */
	public int getActiveEventCount() {
		logger.debug("Getting active event count.");
		return getCount("SELECT COUNT(*) FROM events WHERE event_datetime >= NOW()");
	}

	/**
	 * A generic helper method to execute a `SELECT COUNT(*)` query.
	 * 
	 * @param sql The SQL query to execute.
	 * @return The count, or 0 if an error occurs.
	 */
	private int getCount(String sql) {
		try (Connection conn = DatabaseManager.getConnection();
				PreparedStatement pstmt = conn.prepareStatement(sql);
				ResultSet rs = pstmt.executeQuery()) {
			if (rs.next()) {
				int count = rs.getInt(1);
				logger.info("Count query '{}' returned {}.", sql, count);
				return count;
			}
		} catch (SQLException e) {
			logger.error("SQL error executing count query: {}", sql, e);
		}
		return 0;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageItem;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * DAO for managing inventory in the `storage_items` table.
 */
public class StorageDAO {
	private static final Logger logger = LogManager.getLogger(StorageDAO.class.getName());

	public Map<String, List<StorageItem>> getAllItemsGroupedByLocation() {
		return getAllItems().stream().collect(Collectors.groupingBy(item -> item.getLocation().trim()));
	}

	public List<StorageItem> getAllItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT si.*, u.username as holder_username " + "FROM storage_items si "
				+ "LEFT JOIN users u ON si.current_holder_user_id = u.id " + "ORDER BY si.name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching all storage items.", e);
		}
		return items;
	}

	public List<StorageItem> getDefectiveItems() {
		List<StorageItem> items = new ArrayList<>();
		String sql = "SELECT * FROM storage_items WHERE defective_quantity > 0 ORDER BY location, name";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				items.add(mapResultSetToStorageItem(rs));
			}
		} catch (SQLException e) {
			logger.error("SQL error while fetching defective items.", e);
		}
		return items;
	}

	private StorageItem mapResultSetToStorageItem(ResultSet rs) throws SQLException {
		StorageItem item = new StorageItem();
		item.setId(rs.getInt("id"));
		item.setName(rs.getString("name"));
		item.setLocation(rs.getString("location"));
		item.setCabinet(rs.getString("cabinet"));
		item.setCompartment(rs.getString("compartment"));
		item.setQuantity(rs.getInt("quantity"));
		item.setMaxQuantity(rs.getInt("max_quantity"));
		item.setDefectiveQuantity(rs.getInt("defective_quantity"));
		item.setDefectReason(rs.getString("defect_reason"));
		item.setWeightKg(rs.getDouble("weight_kg"));
		item.setPriceEur(rs.getDouble("price_eur"));
		item.setImagePath(rs.getString("image_path"));
		item.setStatus(rs.getString("status"));
		item.setCurrentHolderUserId(rs.getInt("current_holder_user_id"));
		item.setAssignedEventId(rs.getInt("assigned_event_id"));
		if (DaoUtils.hasColumn(rs, "holder_username")) {
			item.setCurrentHolderUsername(rs.getString("holder_username"));
		}
		return item;
	}

	public StorageItem getItemById(int itemId) {
		String sql = "SELECT si.*, u.username as holder_username " + "FROM storage_items si "
				+ "LEFT JOIN users u ON si.current_holder_user_id = u.id " + "WHERE si.id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			ResultSet rs = pstmt.executeQuery();
			if (rs.next()) {
				return mapResultSetToStorageItem(rs);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage item by ID: {}", itemId, e);
		}
		return null;
	}

	public boolean createItem(StorageItem item) {
		String sql = "INSERT INTO storage_items (name, location, cabinet, compartment, quantity, max_quantity, weight_kg, price_eur, image_path, status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, 'IN_STORAGE')";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setDouble(7, item.getWeightKg());
			pstmt.setDouble(8, item.getPriceEur());
			pstmt.setString(9, item.getImagePath());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error creating storage item: {}", item.getName(), e);
			return false;
		}
	}

	public boolean updateItem(StorageItem item) {
		String sql = "UPDATE storage_items SET name=?, location=?, cabinet=?, compartment=?, quantity=?, max_quantity=?, defective_quantity=?, defect_reason=?, weight_kg=?, price_eur=?, image_path=?, status=?, current_holder_user_id=?, assigned_event_id=? WHERE id=?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, item.getName());
			pstmt.setString(2, item.getLocation());
			pstmt.setString(3, item.getCabinet());
			pstmt.setString(4, item.getCompartment());
			pstmt.setInt(5, item.getQuantity());
			pstmt.setInt(6, item.getMaxQuantity());
			pstmt.setInt(7, item.getDefectiveQuantity());
			pstmt.setString(8, item.getDefectReason());
			pstmt.setDouble(9, item.getWeightKg());
			pstmt.setDouble(10, item.getPriceEur());
			pstmt.setString(11, item.getImagePath());
			pstmt.setString(12, item.getStatus());
			if (item.getCurrentHolderUserId() > 0)
				pstmt.setInt(13, item.getCurrentHolderUserId());
			else
				pstmt.setNull(13, Types.INTEGER);
			if (item.getAssignedEventId() > 0)
				pstmt.setInt(14, item.getAssignedEventId());
			else
				pstmt.setNull(14, Types.INTEGER);
			pstmt.setInt(15, item.getId());
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating storage item with ID: {}", item.getId(), e);
			return false;
		}
	}

	public boolean updateItemHolderAndStatus(int itemId, String status, Integer userId, Integer eventId)
			throws SQLException {
		String sql = "UPDATE storage_items SET status = ?, current_holder_user_id = ?, assigned_event_id = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			if (userId != null)
				pstmt.setInt(2, userId);
			else
				pstmt.setNull(2, Types.INTEGER);
			if (eventId != null)
				pstmt.setInt(3, eventId);
			else
				pstmt.setNull(3, Types.INTEGER);
			pstmt.setInt(4, itemId);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean updateItemQuantity(int itemId, int quantityChange) throws SQLException {
		String sql = "UPDATE storage_items SET quantity = quantity + ? WHERE id = ? AND quantity + ? >= defective_quantity";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, quantityChange);
			pstmt.setInt(2, itemId);
			pstmt.setInt(3, quantityChange);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean updateDefectiveStatus(int itemId, int defectiveQty, String reason) throws SQLException {
		String sql = "UPDATE storage_items SET defective_quantity = ?, defect_reason = ? WHERE id = ? AND ? <= quantity";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, defectiveQty);
			pstmt.setString(2, reason);
			pstmt.setInt(3, itemId);
			pstmt.setInt(4, defectiveQty);
			return pstmt.executeUpdate() > 0;
		}
	}

	public boolean deleteItem(int itemId) {
		String sql = "DELETE FROM storage_items WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error deleting storage item with ID: {}", itemId, e);
			return false;
		}
	}

	public boolean updateItemStatus(int itemId, String status) {
		String sql = "UPDATE storage_items SET status = ? WHERE id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setString(1, status);
			pstmt.setInt(2, itemId);
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("SQL error updating status for item ID: {}", itemId, e);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\StorageLogDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.StorageLogEntry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;

/**
 * Data Access Object for logging storage item transactions (check-ins and
 * check-outs) into the `storage_log` table. This provides a history of
 * inventory movements.
 */
public class StorageLogDAO {
	private static final Logger logger = LogManager.getLogger(StorageLogDAO.class);

	/**
	 * Logs a single transaction (check-in or check-out) to the database.
	 * 
	 * @param itemId         The ID of the item involved in the transaction.
	 * @param userId         The ID of the user performing the transaction.
	 * @param quantityChange The number of items moved (positive for check-in,
	 *                       negative for check-out).
	 * @param notes          Optional notes for the transaction (e.g., purpose,
	 *                       event).
	 * @param eventId        Optional ID of the event this transaction is for.
	 * @return true if the log entry was created successfully.
	 */
	public boolean logTransaction(int itemId, int userId, int quantityChange, String notes, int eventId) {
		String sql = "INSERT INTO storage_log (item_id, user_id, quantity_change, notes, event_id) VALUES (?, ?, ?, ?, ?)";
		logger.debug("Logging storage transaction for item {}, user {}, change {}, event {}", itemId, userId,
				quantityChange, eventId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			pstmt.setInt(2, userId);
			pstmt.setInt(3, quantityChange);
			pstmt.setString(4, notes);
			if (eventId > 0) {
				pstmt.setInt(5, eventId);
			} else {
				pstmt.setNull(5, Types.INTEGER);
			}
			return pstmt.executeUpdate() > 0;
		} catch (SQLException e) {
			logger.error("Failed to log storage transaction for item {}", itemId, e);
			return false;
		}
	}

	/**
	 * Fetches the transaction history for a specific storage item.
	 * 
	 * @param itemId The ID of the item.
	 * @return A list of storage log entries.
	 */
	public List<StorageLogEntry> getHistoryForItem(int itemId) {
		List<StorageLogEntry> history = new ArrayList<>();
		String sql = "SELECT sl.*, u.username FROM storage_log sl " + "JOIN users u ON sl.user_id = u.id "
				+ "WHERE sl.item_id = ? ORDER BY sl.transaction_timestamp DESC";
		logger.debug("Fetching storage history for item ID: {}", itemId);
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
			pstmt.setInt(1, itemId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					StorageLogEntry entry = new StorageLogEntry();
					entry.setId(rs.getInt("id"));
					entry.setItemId(rs.getInt("item_id"));
					entry.setUserId(rs.getInt("user_id"));
					entry.setUsername(rs.getString("username"));
					entry.setQuantityChange(rs.getInt("quantity_change"));
					entry.setNotes(rs.getString("notes"));
					entry.setEventId(rs.getInt("event_id"));
					entry.setTransactionTimestamp(rs.getTimestamp("transaction_timestamp").toLocalDateTime());
					history.add(entry);
				}
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching storage history for item ID {}", itemId, e);
		}
		return history;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserDAO.java
========================================================================

package de.technikteam.dao;

import de.technikteam.model.User;
import de.technikteam.util.DaoUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.sql.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class UserDAO {
	private static final Logger logger = LogManager.getLogger(UserDAO.class);

	private User mapResultSetToUser(ResultSet resultSet) throws SQLException {
		User user = new User();
		user.setId(resultSet.getInt("id"));
		user.setUsername(resultSet.getString("username"));
		user.setRoleId(resultSet.getInt("role_id"));
		user.setChatColor(resultSet.getString("chat_color"));
		if (DaoUtils.hasColumn(resultSet, "role_name")) {
			user.setRoleName(resultSet.getString("role_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "created_at") && resultSet.getTimestamp("created_at") != null) {
			user.setCreatedAt(resultSet.getTimestamp("created_at").toLocalDateTime());
		}
		if (DaoUtils.hasColumn(resultSet, "class_year")) {
			user.setClassYear(resultSet.getInt("class_year"));
		}
		if (DaoUtils.hasColumn(resultSet, "class_name")) {
			user.setClassName(resultSet.getString("class_name"));
		}
		if (DaoUtils.hasColumn(resultSet, "email")) {
			user.setEmail(resultSet.getString("email"));
		}
		return user;
	}

	public User validateUser(String username, String password) {
		String sql = "SELECT u.*, r.role_name FROM users u " + "LEFT JOIN roles r ON u.role_id = r.id "
				+ "WHERE u.username = ? AND u.password_hash = ?";
		logger.debug("Validating user credentials for username: {}", username);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, username);
			preparedStatement.setString(2, password);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("User validation successful for username: {}", username);
					User user = mapResultSetToUser(resultSet);
					user.setPermissions(getPermissionsForRole(user.getRoleId()));
					return user;
				} else {
					logger.warn("User validation failed for username: {}", username);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error during user validation for username: {}", username, exception);
		}
		return null;
	}

	public Set<String> getPermissionsForRole(int roleId) {
		Set<String> permissions = new HashSet<>();
		String sql = "SELECT p.permission_key FROM permissions p "
				+ "JOIN role_permissions rp ON p.id = rp.permission_id " + "WHERE rp.role_id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, roleId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				while (resultSet.next()) {
					permissions.add(resultSet.getString("permission_key"));
				}
			}
		} catch (SQLException exception) {
			logger.error("Could not fetch permissions for role ID: {}", roleId, exception);
		}
		logger.debug("Fetched {} permissions for role ID {}", permissions.size(), roleId);
		return permissions;
	}

	public List<User> getAllUsers() {
		List<User> users = new ArrayList<>();
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id ORDER BY u.username";
		logger.debug("Fetching all users.");
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql);
				ResultSet resultSet = preparedStatement.executeQuery()) {
			while (resultSet.next()) {
				users.add(mapResultSetToUser(resultSet));
			}
			logger.info("Fetched {} total users.", users.size());
		} catch (SQLException exception) {
			logger.error("SQL error fetching all users", exception);
		}
		return users;
	}

	public User getUserById(int userId) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.id = ?";
		logger.debug("Fetching user by ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found user '{}' with ID: {}", resultSet.getString("username"), userId);
					return mapResultSetToUser(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by ID: {}", userId, exception);
		}
		logger.warn("No user found with ID: {}", userId);
		return null;
	}

	public User getUserByUsername(String username) {
		String sql = "SELECT u.*, r.role_name FROM users u LEFT JOIN roles r ON u.role_id = r.id WHERE u.username = ?";
		logger.debug("Fetching user by username: {}", username);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, username);
			try (ResultSet resultSet = preparedStatement.executeQuery()) {
				if (resultSet.next()) {
					logger.info("Found user with username: {}", username);
					return mapResultSetToUser(resultSet);
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error fetching user by username: {}", username, exception);
		}
		logger.warn("No user found with username: {}", username);
		return null;
	}

	public int createUser(User user, String password) {
		String sql = "INSERT INTO users (username, password_hash, role_id, class_year, class_name, email) VALUES (?, ?, ?, ?, ?, ?)";
		logger.debug("Attempting to create user: {}", user.getUsername());
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql,
						Statement.RETURN_GENERATED_KEYS)) {

			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setString(2, password);
			preparedStatement.setInt(3, user.getRoleId());
			preparedStatement.setInt(4, user.getClassYear());
			preparedStatement.setString(5, user.getClassName());
			preparedStatement.setString(6, user.getEmail());

			int affectedRows = preparedStatement.executeUpdate();

			if (affectedRows > 0) {
				try (ResultSet generatedKeys = preparedStatement.getGeneratedKeys()) {
					if (generatedKeys.next()) {
						int newUserId = generatedKeys.getInt(1);
						logger.info("Successfully created user '{}' with ID: {}", user.getUsername(), newUserId);
						return newUserId;
					}
				}
			}
		} catch (SQLException exception) {
			logger.error("SQL error creating user '{}'. Username or email might already exist.", user.getUsername(),
					exception);
		}
		return 0;
	}

	public boolean updateUser(User user) {
		logger.debug("Updating user with ID: {}", user.getId());
		String sql = "UPDATE users SET username = ?, role_id = ?, class_year = ?, class_name = ?, email = ? WHERE id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, user.getUsername());
			preparedStatement.setInt(2, user.getRoleId());
			preparedStatement.setInt(3, user.getClassYear());
			preparedStatement.setString(4, user.getClassName());
			preparedStatement.setString(5, user.getEmail());
			preparedStatement.setInt(6, user.getId());
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error updating user with ID: {}", user.getId(), exception);
			return false;
		}
	}

	public boolean updateUserChatColor(int userId, String chatColor) {
		String sql = "UPDATE users SET chat_color = ? WHERE id = ?";
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, chatColor);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("Error updating chat color for user ID {}", userId, exception);
			return false;
		}
	}

	public boolean deleteUser(int userId) {
		String sql = "DELETE FROM users WHERE id = ?";
		logger.warn("Attempting to delete user with ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setInt(1, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error deleting user with ID: {}", userId, exception);
			return false;
		}
	}

	public boolean changePassword(int userId, String newPassword) {
		String sql = "UPDATE users SET password_hash = ? WHERE id = ?";
		logger.debug("Changing password for user ID: {}", userId);
		try (Connection connection = DatabaseManager.getConnection();
				PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			preparedStatement.setString(1, newPassword);
			preparedStatement.setInt(2, userId);
			return preparedStatement.executeUpdate() > 0;
		} catch (SQLException exception) {
			logger.error("SQL error changing password for user ID: {}", userId, exception);
			return false;
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\dao\UserQualificationsDAO.java
========================================================================

package de.technikteam.dao;

import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.UserQualification;

/**
 * This DAO manages the `user_qualifications` table, which links users to the
 * courses they have completed. It's used to track which skills a user
 * possesses. Its key functions are fetching qualifications for a single user or
 * all users, and updating a user's qualification status for a specific course.
 */
public class UserQualificationsDAO {
	private static final Logger logger = LogManager.getLogger(UserQualificationsDAO.class);

	/**
	 * Fetches all qualifications for a single user. This is typically used for a
	 * user's profile or details page.
	 * 
	 * @param userId The ID of the user.
	 * @return A list of UserQualification objects.
	 */
	public List<UserQualification> getQualificationsForUser(int userId) {
		logger.debug("Fetching qualifications for user ID: {}", userId);
		List<UserQualification> qualifications = new ArrayList<>();
		String sql = "SELECT uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id " + "WHERE uq.user_id = ?";
		try (Connection conn = DatabaseManager.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {

			pstmt.setInt(1, userId);
			try (ResultSet rs = pstmt.executeQuery()) {
				while (rs.next()) {
					qualifications.add(mapResultSetToUserQualification(rs));
				}
				logger.info("Found {} qualifications for user ID: {}", qualifications.size(), userId);
			}
		} catch (SQLException e) {
			logger.error("SQL error fetching qualifications for user ID: {}", userId, e);
		}
		return qualifications;
	}

	/**
	 * Fetches all qualification records for all users. This is used to build the
	 * data for an overview or matrix page.
	 * 
	 * @return A list of all UserQualification objects in the database.
	 */
	public List<UserQualification> getAllQualifications() {
		logger.debug("Fetching all user qualifications.");
		List<UserQualification> qualifications = new ArrayList<>();
		// This query needs the user_id to build a lookup map later.
		String sql = "SELECT uq.user_id, uq.course_id, c.name, uq.status, uq.completion_date, uq.remarks "
				+ "FROM user_qualifications uq " + "JOIN courses c ON uq.course_id = c.id";
		try (Connection conn = DatabaseManager.getConnection();
				Statement stmt = conn.createStatement();
				ResultSet rs = stmt.executeQuery(sql)) {
			while (rs.next()) {
				qualifications.add(mapResultSetToUserQualification(rs));
			}
			logger.info("Fetched a total of {} qualification entries.", qualifications.size());
		} catch (SQLException e) {
			logger.error("SQL error fetching all qualifications.", e);
		}
		return qualifications;
	}

	/**
	 * Updates or creates a qualification status for a user and a course. If the
	 * status is set to "NICHT BESUCHT", the corresponding record is deleted.
	 * Otherwise, it performs an "upsert" (INSERT ... ON DUPLICATE KEY UPDATE) to
	 * create or modify the record. This is a key method for admin management of
	 * user skills.
	 * 
	 * @param userId         The ID of the user.
	 * @param courseId       The ID of the course.
	 * @param status         The new status ('BESUCHT', 'ABSOLVIERT', or 'NICHT
	 *                       BESUCHT').
	 * @param completionDate The date of completion (can be null).
	 * @param remarks        Additional remarks (can be null).
	 * @return true if the operation was successful, false otherwise.
	 */
	public boolean updateQualificationStatus(int userId, int courseId, String status, LocalDate completionDate,
			String remarks) {
		logger.debug("DAO: Updating qualification for user {}, course {}. New status: {}, Date: {}, Remarks: '{}'",
				userId, courseId, status, completionDate, remarks);

		if ("NICHT BESUCHT".equals(status)) {
			// If status is "Not Attended", we delete the record from the database.
			String deleteSql = "DELETE FROM user_qualifications WHERE user_id = ? AND course_id = ?";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(deleteSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				int affectedRows = pstmt.executeUpdate();
				logger.info("Deleted qualification entry for user {} and course {}. Rows affected: {}", userId,
						courseId, affectedRows);
				return true; // The desired state is achieved, so return true.
			} catch (SQLException e) {
				logger.error("DAO Error deleting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		} else {
			// Otherwise, we insert a new record or update an existing one.
			String upsertSql = "INSERT INTO user_qualifications (user_id, course_id, status, completion_date, remarks) VALUES (?, ?, ?, ?, ?) "
					+ "ON DUPLICATE KEY UPDATE status = VALUES(status), completion_date = VALUES(completion_date), remarks = VALUES(remarks)";
			try (Connection conn = DatabaseManager.getConnection();
					PreparedStatement pstmt = conn.prepareStatement(upsertSql)) {
				pstmt.setInt(1, userId);
				pstmt.setInt(2, courseId);
				pstmt.setString(3, status);

				if (completionDate != null) {
					pstmt.setDate(4, Date.valueOf(completionDate));
				} else {
					pstmt.setNull(4, Types.DATE);
				}

				pstmt.setString(5, remarks);

				int affectedRows = pstmt.executeUpdate();
				logger.info("Upserted qualification for user {} and course {}. Rows affected: {}", userId, courseId,
						affectedRows);
				// Can return 0 (no change), 1 (insert), or 2 (update), so >= 0 is a good check
				// for success.
				return affectedRows >= 0;
			} catch (SQLException e) {
				logger.error("DAO Error upserting qualification for user {} course {}", userId, courseId, e);
				return false;
			}
		}
	}

	// --- Helper Methods ---

	/**
	 * Maps a row from a ResultSet to a UserQualification object.
	 * 
	 * @param rs The ResultSet to map.
	 * @return A populated UserQualification object.
	 * @throws SQLException If a database error occurs.
	 */
	private UserQualification mapResultSetToUserQualification(ResultSet rs) throws SQLException {
		UserQualification uq = new UserQualification();
		// user_id is only present in the getAllQualifications query
		if (hasColumn(rs, "user_id")) {
			uq.setUserId(rs.getInt("user_id"));
		}
		uq.setCourseId(rs.getInt("course_id"));
		uq.setCourseName(rs.getString("name"));
		uq.setStatus(rs.getString("status"));
		uq.setRemarks(rs.getString("remarks"));
		Date dbDate = rs.getDate("completion_date");
		if (dbDate != null) {
			uq.setCompletionDate(dbDate.toLocalDate());
		}
		return uq;
	}

	/**
	 * Checks if a ResultSet contains a column with the given name
	 * (case-insensitive).
	 * 
	 * @param rs         The ResultSet to check.
	 * @param columnName The name of the column.
	 * @return true if the column exists, false otherwise.
	 * @throws SQLException If a database error occurs.
	 */
	private boolean hasColumn(ResultSet rs, String columnName) throws SQLException {
		ResultSetMetaData rsmd = rs.getMetaData();
		int columns = rsmd.getColumnCount();
		for (int x = 1; x <= columns; x++) {
			if (columnName.equalsIgnoreCase(rsmd.getColumnName(x))) {
				return true;
			}
		}
		return false;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AdminFilter.java
========================================================================

package de.technikteam.filter;

import de.technikteam.model.User;
import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.Set;

@WebFilter(urlPatterns = "/admin/*", asyncSupported = true)
public class AdminFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AdminFilter.class);

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);
		String path = request.getRequestURI().substring(request.getContextPath().length());
		logger.trace("AdminFilter is processing request for path: '{}'", path);

		// 1. Check if user is logged in at all.
		if (session == null || session.getAttribute("user") == null) {
			logger.warn("Admin access DENIED to path '{}'. No active session found. Redirecting to login.", path);
			// Redirect to the /login servlet, not a direct JSP.
			response.sendRedirect(request.getContextPath() + "/login");
			return;
		}

		User user = (User) session.getAttribute("user");
		Set<String> permissions = user.getPermissions();

		// 2. Check if the user's permissions were loaded correctly.
		if (permissions == null) {
			logger.error("Permissions set is NULL on user object in session for user '{}'. Denying access.",
					user.getUsername());
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Berechtigungen nicht geladen.");
			return;
		}

		// 3. Check for the master "ACCESS_ADMIN_PANEL" permission. This grants access
		// to everything under /admin/*.
		if (permissions.contains("ACCESS_ADMIN_PANEL")) {
			logger.debug("ADMIN access GRANTED for user '{}' to path '{}' via master permission.", user.getUsername(),
					path);
			chain.doFilter(request, response);
			return;
		}

		// 4. If the user is NOT a full admin, check for specific, limited permissions.
		boolean hasSpecificPermission = false;
		// CORRECTED: The path for the storage servlet is /admin/lager, not
		// /admin/storage.
		if (path.startsWith("/admin/lager") && permissions.contains("STORAGE_MANAGE")) {
			hasSpecificPermission = true;
		} else if (path.startsWith("/admin/defekte") && permissions.contains("DEFECTS_MANAGE")) {
			hasSpecificPermission = true;
		}
		// Add other 'else if' blocks here for any other specific, limited admin roles.

		if (hasSpecificPermission) {
			logger.debug("Specific admin access GRANTED for user '{}' (Role: '{}') to path '{}'.", user.getUsername(),
					user.getRoleName(), path);
			chain.doFilter(request, response);
			return;
		}

		// 5. If the user is not a full admin and has no specific permissions for the
		// requested page, deny access.
		logger.warn("ADMIN access DENIED for user '{}' (Role: '{}') to path '{}'. Redirecting to user home.",
				user.getUsername(), user.getRoleName(), path);
		request.getSession().setAttribute("accessErrorMessage",
				"Sie haben keine Berechtigung, auf diese Seite zuzugreifen.");
		response.sendRedirect(request.getContextPath() + "/home");
	}

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AdminFilter initialized and protecting /admin/* paths with dynamic permissions.");
	}

	@Override
	public void destroy() {
		logger.info("AdminFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\AuthenticationFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

@WebFilter(value = "/*", asyncSupported = true)
public class AuthenticationFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(AuthenticationFilter.class.getName());

	// CORRECTION: This set should only contain the servlet paths, not JSP paths.
	private static final Set<String> PUBLIC_PATHS = new HashSet<>(Arrays.asList("/login", "/logout"));

	// CORRECTION: The /error directory prefix is correct for allowing error pages.
	// ADDED: /public to allow access to public APIs like the iCal feed.
	private static final Set<String> PUBLIC_RESOURCE_PREFIXES = new HashSet<>(
			Arrays.asList("/css", "/js", "/images", "/error", "/public"));

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("AuthenticationFilter initialized. Public paths: {}, Public prefixes: {}", PUBLIC_PATHS,
				PUBLIC_RESOURCE_PREFIXES);
	}

	@Override
	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
			throws IOException, ServletException {

		HttpServletRequest request = (HttpServletRequest) req;
		HttpServletResponse response = (HttpServletResponse) res;
		HttpSession session = request.getSession(false);

		String contextPath = request.getContextPath();
		String path = request.getRequestURI().substring(contextPath.length());

		logger.trace("AuthenticationFilter processing request for path: '{}'", path);

		boolean isLoggedIn = (session != null && session.getAttribute("user") != null);

		boolean isPublicResource = PUBLIC_PATHS.contains(path)
				|| PUBLIC_RESOURCE_PREFIXES.stream().anyMatch(path::startsWith);

		if (isLoggedIn || isPublicResource) {
			logger.trace("Access granted for path '{}'. LoggedIn: {}, IsPublic: {}", path, isLoggedIn,
					isPublicResource);
			chain.doFilter(request, response);
		} else {
			logger.warn("Unauthorized access attempt by a guest to protected path: '{}'. Redirecting to login page.",
					path);
			// CORRECTION: Redirect to the /login servlet URL, not the JSP file path.
			response.sendRedirect(contextPath + "/login");
		}
	}

	@Override
	public void destroy() {
		logger.info("AuthenticationFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\filter\CharacterEncodingFilter.java
========================================================================

package de.technikteam.filter;

import java.io.IOException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.Filter;
import jakarta.servlet.FilterChain;
import jakarta.servlet.FilterConfig;
import jakarta.servlet.ServletException;
import jakarta.servlet.ServletRequest;
import jakarta.servlet.ServletResponse;
import jakarta.servlet.annotation.WebFilter;

/**
 * A crucial utility filter that intercepts all incoming requests (`/*`) to set
 * the character encoding to UTF-8. This ensures that any data submitted in
 * requests (e.g., form fields with special characters like German umlauts) and
 * any content sent in responses is correctly interpreted and rendered by the
 * browser. It should be the first filter in the chain.
 */
@WebFilter(value = "/*", asyncSupported = true)
public class CharacterEncodingFilter implements Filter {

	private static final Logger logger = LogManager.getLogger(CharacterEncodingFilter.class);

	@Override
	public void init(FilterConfig filterConfig) throws ServletException {
		logger.info("CharacterEncodingFilter initialized and set to enforce UTF-8.");
	}

	/**
	 * Sets the character encoding for both the request and response to UTF-8.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
			throws IOException, ServletException {

		logger.trace("Applying UTF-8 character encoding to request and response.");

		// Set the character encoding for the request to correctly interpret incoming
		// data
		request.setCharacterEncoding("UTF-8");

		// Set the character encoding for the response to ensure the browser renders it
		// correctly
		response.setCharacterEncoding("UTF-8");

		// Pass the request along the filter chain
		chain.doFilter(request, response);
	}

	@Override
	public void destroy() {
		logger.info("CharacterEncodingFilter destroyed.");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\AppContextListener.java
========================================================================

package de.technikteam.listener;

import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * This is an application lifecycle listener that performs crucial cleanup tasks
 * when the web application is shut down or undeployed from the server. Its
 * primary purpose is to manually deregister the JDBC driver that was loaded by
 * this application's classloader. This prevents potential memory leaks in
 * application servers like Tomcat.
 */
@WebListener
public class AppContextListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(AppContextListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Initialized <<<<<<<<<<");
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info(">>>>>>>>>> TechnikTeam Application Context Being Destroyed. Cleaning up resources... <<<<<<<<<<");

		// This is the officially supported way to prevent memory leaks caused by JDBC
		// drivers
		// when a web application is shut down. We iterate through all loaded drivers
		// and deregister any that were loaded by this application's classloader.
		Enumeration<java.sql.Driver> drivers = DriverManager.getDrivers();
		while (drivers.hasMoreElements()) {
			java.sql.Driver driver = drivers.nextElement();
			if (driver.getClass().getClassLoader() == getClass().getClassLoader()) {
				try {
					DriverManager.deregisterDriver(driver);
					logger.info("Deregistering JDBC driver: {}", driver);
				} catch (SQLException e) {
					logger.error("Error deregistering JDBC driver: {}", driver, e);
				}
			} else {
				logger.trace("Not deregistering JDBC driver {} as it does not belong to this webapp's classloader.",
						driver);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\listener\ApplicationInitializerListener.java
========================================================================

package de.technikteam.listener;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import de.technikteam.dao.DatabaseManager;
import jakarta.servlet.ServletContextEvent;
import jakarta.servlet.ServletContextListener;
import jakarta.servlet.annotation.WebListener;

/**
 * An application lifecycle listener that runs when the application starts. It
 * performs two critical initialization tasks: 1. Manually loads the MySQL JDBC
 * driver to ensure it's available for the application. This is a robust
 * practice that prevents connectivity issues if the server's automatic service
 * discovery fails. 2. Explicitly triggers the initialization of the
 * `DatabaseManager` and its connection pool, and ensures the pool is closed on
 * application shutdown.
 */
@WebListener
public class ApplicationInitializerListener implements ServletContextListener {

	private static final Logger logger = LogManager.getLogger(ApplicationInitializerListener.class);

	@Override
	public void contextInitialized(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being initialized...");

		try {
			// Manually load the MySQL JDBC driver.
			logger.info("Attempting to manually load MySQL JDBC driver...");
			Class.forName("com.mysql.cj.jdbc.Driver");
			logger.info("MySQL JDBC driver loaded successfully.");

			// Eagerly initialize the database connection pool on startup
			logger.info("Triggering database connection pool initialization...");
			Class.forName("de.technikteam.dao.DatabaseManager");

		} catch (ClassNotFoundException e) {
			logger.fatal("FATAL: MySQL JDBC driver or DatabaseManager not found in classpath. Application will fail.",
					e);
		}
	}

	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		logger.info("Application Initializer: Context is being destroyed.");
		// Properly shut down the database connection pool.
		DatabaseManager.closeDataSource();
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\AdminLog.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single audit log entry from the `admin_logs` table. It captures
 * who performed an action, what type of action it was, detailed information
 * about the action, and when it occurred.
 */
public class AdminLog {
	private int id;
	private String adminUsername;
	private String actionType;
	private String details;
	private LocalDateTime actionTimestamp;

	public AdminLog() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getAdminUsername() {
		return adminUsername;
	}

	public void setAdminUsername(String adminUsername) {
		this.adminUsername = adminUsername;
	}

	public String getActionType() {
		return actionType;
	}

	public void setActionType(String actionType) {
		this.actionType = actionType;
	}

	public String getDetails() {
		return details;
	}

	public void setDetails(String details) {
		this.details = details;
	}

	public LocalDateTime getActionTimestamp() {
		return actionTimestamp;
	}

	public void setActionTimestamp(LocalDateTime actionTimestamp) {
		this.actionTimestamp = actionTimestamp;
	}

	// --- Formatted Helper ---

	/**
	 * A convenience method to get the action timestamp as a formatted string,
	 * suitable for display in the user interface.
	 * 
	 * @return A German-style date-time string (e.g., "10.06.2025 17:45").
	 */
	public String getFormattedActionTimestamp() {
		return DateFormatter.formatDateTime(this.actionTimestamp);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Course.java
========================================================================

package de.technikteam.model;

/**
 * Represents a parent course template from the `courses` table. This is not a
 * schedulable event itself, but a blueprint for a type of training (e.g.,
 * "Grundlehrgang Tontechnik"). Individual dates/sessions for a course are
 * handled by the 'Meeting' model.
 */
public class Course {
	private int id;
	private String name;
	private String abbreviation;
	private String description;

	public Course() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getAbbreviation() {
		return abbreviation;
	}

	public void setAbbreviation(String abbreviation) {
		this.abbreviation = abbreviation;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Event.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Represents a single event from the `events` table. It holds the event's core
 * data (name, date, description, status) and also contains transient lists to
 * store related information like skill requirements, assigned attendees, tasks,
 * and chat messages for use in detailed views.
 */
public class Event {
	private int id;
	private String name;
	private LocalDateTime eventDateTime;
	private LocalDateTime endDateTime;
	private String description;
	private String location;
	private String status;
	private int leaderUserId;
	private String userAttendanceStatus; // Specific to the logged-in user (e.g., ANGEMELDET, ZUGEWIESEN)

	// These fields are populated on-demand for detailed views and are not direct
	// table columns.
	private List<SkillRequirement> skillRequirements;
	private List<User> assignedAttendees;
	private List<EventTask> eventTasks;
	private List<EventChatMessage> chatMessages;
	private List<EventAttachment> attachments;
	private List<StorageItem> reservedItems;
	private String leaderUsername;
	private List<EventCustomField> customFields; // NEW: For advanced sign-up forms

	public Event() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getEventDateTime() {
		return eventDateTime;
	}

	public void setEventDateTime(LocalDateTime eventDateTime) {
		this.eventDateTime = eventDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public List<SkillRequirement> getSkillRequirements() {
		return skillRequirements;
	}

	public void setSkillRequirements(List<SkillRequirement> skillRequirements) {
		this.skillRequirements = skillRequirements;
	}

	public List<User> getAssignedAttendees() {
		return assignedAttendees;
	}

	public void setAssignedAttendees(List<User> assignedAttendees) {
		this.assignedAttendees = assignedAttendees;
	}

	public List<EventTask> getEventTasks() {
		return eventTasks;
	}

	public void setEventTasks(List<EventTask> eventTasks) {
		this.eventTasks = eventTasks;
	}

	public List<EventChatMessage> getChatMessages() {
		return chatMessages;
	}

	public void setChatMessages(List<EventChatMessage> chatMessages) {
		this.chatMessages = chatMessages;
	}

	public List<EventAttachment> getAttachments() {
		return attachments;
	}

	public void setAttachments(List<EventAttachment> attachments) {
		this.attachments = attachments;
	}

	public List<StorageItem> getReservedItems() {
		return reservedItems;
	}

	public void setReservedItems(List<StorageItem> reservedItems) {
		this.reservedItems = reservedItems;
	}

	public List<EventCustomField> getCustomFields() {
		return customFields;
	}

	public void setCustomFields(List<EventCustomField> customFields) {
		this.customFields = customFields;
	}

	// --- Formatted Helpers ---

	public String getFormattedEventDateTime() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.eventDateTime);
	}

	public String getFormattedEventDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.eventDateTime, this.endDateTime);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the `event_attachments` table. It links a
 * file (with its path and name) to a specific event and includes a
 * `requiredRole` to control its visibility to different types of users.
 */
public class EventAttachment {
	private int id;
	private int eventId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventAttendance.java
========================================================================

package de.technikteam.model;

/**
 * A model that represents a record from the `event_attendance` table. It links
 * a user to an event, capturing their sign-up status (e.g.,
 * ANGEMELDET/ABGEMELDET) and their commitment level (e.g., BESTÄTIGT/OFFEN),
 * which can be updated by an admin.
 */
public class EventAttendance {
	private int eventId;
	private int userId;
	private String username; // To display the user's name in lists
	private String signupStatus; // e.g., ANGEMELDET, ABGEMELDET
	private String commitmentStatus; // e.g., BESTÄTIGT, OFFEN

	public EventAttendance() {
	}

	// --- Getters and Setters ---

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getSignupStatus() {
		return signupStatus;
	}

	public void setSignupStatus(String signupStatus) {
		this.signupStatus = signupStatus;
	}

	public String getCommitmentStatus() {
		return commitmentStatus;
	}

	public void setCommitmentStatus(String commitmentStatus) {
		this.commitmentStatus = commitmentStatus;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventChatMessage.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class EventChatMessage {
	private int id;
	private int eventId;
	private int userId;
	private String username;
	private String messageText;
	private boolean edited;
	private boolean isDeleted;
	private int deletedByUserId;
	private String deletedByUsername;
	private LocalDateTime deletedAt;
	private LocalDateTime sentAt;
	private String chatColor; // To carry the user's color preference

	private static final DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern("HH:mm");
	private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("dd.MM.yy, HH:mm");

	public String getFormattedSentAt() {
		return sentAt != null ? sentAt.format(TIME_FORMATTER) : "";
	}

	public String getFormattedDeletedAt() {
		return deletedAt != null ? deletedAt.format(DATE_TIME_FORMATTER) : "";
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getMessageText() {
		return messageText;
	}

	public void setMessageText(String messageText) {
		this.messageText = messageText;
	}

	public boolean isEdited() {
		return edited;
	}

	public void setEdited(boolean edited) {
		this.edited = edited;
	}

	public boolean isDeleted() {
		return isDeleted;
	}

	public void setDeleted(boolean isDeleted) {
		this.isDeleted = isDeleted;
	}

	public int getDeletedByUserId() {
		return deletedByUserId;
	}

	public void setDeletedByUserId(int deletedByUserId) {
		this.deletedByUserId = deletedByUserId;
	}

	public String getDeletedByUsername() {
		return deletedByUsername;
	}

	public void setDeletedByUsername(String deletedByUsername) {
		this.deletedByUsername = deletedByUsername;
	}

	public LocalDateTime getDeletedAt() {
		return deletedAt;
	}

	public void setDeletedAt(LocalDateTime deletedAt) {
		this.deletedAt = deletedAt;
	}

	public LocalDateTime getSentAt() {
		return sentAt;
	}

	public void setSentAt(LocalDateTime sentAt) {
		this.sentAt = sentAt;
	}

	public String getChatColor() {
		return chatColor;
	}

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomField.java
========================================================================

package de.technikteam.model;

/**
 * Represents a custom field that can be added to an event sign-up form.
 */
public class EventCustomField {
	private int id;
	private int eventId;
	private String fieldName;
	private String fieldType;
	private boolean isRequired;
	private String fieldOptions;

	// --- Getters and Setters ---
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getFieldName() {
		return fieldName;
	}

	public void setFieldName(String fieldName) {
		this.fieldName = fieldName;
	}

	public String getFieldType() {
		return fieldType;
	}

	public void setFieldType(String fieldType) {
		this.fieldType = fieldType;
	}

	public boolean isRequired() {
		return isRequired;
	}

	public void setRequired(boolean required) {
		isRequired = required;
	}
	
	public String getFieldOptions() {
		return fieldOptions; 
	}
	
	public void setFieldOptions(String fieldOptions) {
		this.fieldOptions = fieldOptions; 
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventCustomFieldResponse.java
========================================================================

package de.technikteam.model;

/**
 * Represents a user's response to a specific EventCustomField.
 */
public class EventCustomFieldResponse {
    private int id;
    private int fieldId;
    private int userId;
    private String responseValue;
    
    // --- Getters and Setters ---
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    public int getFieldId() { return fieldId; }
    public void setFieldId(int fieldId) { this.fieldId = fieldId; }
    public int getUserId() { return userId; }
    public void setUserId(int userId) { this.userId = userId; }
    public String getResponseValue() { return responseValue; }
    public void setResponseValue(String responseValue) { this.responseValue = responseValue; }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\EventTask.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single task from the `event_tasks` table, associated with a
 * specific "running" event. It includes the task description, its status
 * ("OFFEN" or "ERLEDIGT"), and a transient field for displaying assigned users.
 */
public class EventTask {
	private int id;
	private int eventId;
	private String description;
	private String status; // e.g., "OFFEN" or "ERLEDIGT"
	private String assignedUsernames; // Comma-separated list for display, not a direct table column
	private String eventName; // For dashboard display

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getAssignedUsernames() {
		return assignedUsernames;
	}

	public void setAssignedUsernames(String assignedUsernames) {
		this.assignedUsernames = assignedUsernames;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackForm.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackForm {
	private int id;
	private int eventId; 
	private String title; 
	private LocalDateTime createdAt; 

	public int getId () {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getEventId() {
		return eventId;
	}
	
	public void setEventId(int eventId) {
		this.eventId = eventId; 
	}
	
	public String getTitle() {
		return title; 
	}
	
	public void setTitle(String title) {
		this.title = title; 
	}
	
	public LocalDateTime getCreatedAt() {
		return createdAt; 
	}
	
	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FeedbackResponse.java
========================================================================

package de.technikteam.model; 

import java.time.LocalDateTime; 

public class FeedbackResponse {
	private int id; 
	private int formId; 
	private int userId; 
	private int rating; 
	private String comments; 
	private LocalDateTime submittedAt; 
	private String username; 
	
	public int getId() {
		return id; 
	}
	
	public void setId(int id) {
		this.id = id; 
	}
	
	public int getFormId() {
		return formId; 
	}
	
	public void setFormId(int formId) {
		this.formId = formId; 
	}
	
	public int getUserId() {
		return userId; 
	}
	
	public void setUserId(int userId) {
		this.userId = userId; 
	}
	
	public int getRating() {
		return rating; 
	}
	
	public void setRating(int rating) {
		this.rating = rating; 
	}
	
	public String getComments() {
		return comments; 
	}
	
	public void setComments(String comments) {
		this.comments = comments; 
	}
	
	public LocalDateTime getSubmittedAt() {
		return submittedAt; 
	}
	
	public void setSubmittedAt(LocalDateTime submittedAt) {
		this.submittedAt = submittedAt; 
	}
	
	public String getUsername() {
		return username; 
	}
	
	public void setUsername(String username) {
		this.username = username; 
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\File.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents the metadata for a single uploaded file from the `files` table. It
 * includes the file's name, its path on the server, its associated category,
 * and the required role ("NUTZER" or "ADMIN") needed to view or download it.
 */
public class File {
	private int id;
	private String filename;
	private String filepath;
	private int categoryId;
	private String categoryName; // For display purposes, joined from file_categories
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public int getCategoryId() {
		return categoryId;
	}

	public void setCategoryId(int categoryId) {
		this.categoryId = categoryId;
	}

	public String getCategoryName() {
		return categoryName;
	}

	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\FileCategory.java
========================================================================

package de.technikteam.model;

/**
 * A simple model representing a category from the `file_categories` table, used
 * to organize uploaded files. It contains just a unique ID and a name.
 */
public class FileCategory {
	private int id;
	private String name;

	public FileCategory() {
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKit.java
========================================================================

package de.technikteam.model;

import java.util.List;

/**
 * Represents a "kit" or "case" from the `inventory_kits` table. A kit is a
 * container for a predefined collection of StorageItems.
 */
public class InventoryKit {
	private int id;
	private String name;
	private String description;

	// Transient field for holding items when needed
	private List<InventoryKitItem> items;

	// --- Getters and Setters ---
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public List<InventoryKitItem> getItems() {
		return items;
	}

	public void setItems(List<InventoryKitItem> items) {
		this.items = items;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\InventoryKitItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents the junction table record from `inventory_kit_items`, linking a
 * StorageItem to an InventoryKit with a specific quantity.
 */
public class InventoryKitItem {
	private int kitId;
	private int itemId;
	private int quantity;

	// Transient field for display
	private String itemName;

	// --- Getters and Setters ---
	public int getKitId() {
		return kitId;
	}

	public void setKitId(int kitId) {
		this.kitId = kitId;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public String getItemName() {
		return itemName;
	}

	public void setItemName(String itemName) {
		this.itemName = itemName;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MaintenanceLogEntry.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a single entry from the `maintenance_log` table, tracking the
 * maintenance history of a storage item.
 */
public class MaintenanceLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private LocalDateTime logDate;
	private String action;
	private String notes;
	private double cost;

	// Transient field for display
	private String username;

	// --- Getters and Setters ---
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public LocalDateTime getLogDate() {
		return logDate;
	}

	public void setLogDate(LocalDateTime logDate) {
		this.logDate = logDate;
	}

	public String getAction() {
		return action;
	}

	public void setAction(String action) {
		this.action = action;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public double getCost() {
		return cost;
	}

	public void setCost(double cost) {
		this.cost = cost;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getFormattedLogDate() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.logDate);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Meeting.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;

/**
 * Represents a single, schedulable meeting from the `meetings` table. Each
 * meeting is a specific instance of a parent `Course` and has its own date,
 * time, leader, and description. It also holds transient user-specific data for
 * the UI.
 */
public class Meeting {
	private int id;
	private int courseId;
	private String name;
	private LocalDateTime meetingDateTime;
	private LocalDateTime endDateTime;
	private int leaderUserId;
	private String description;
	private String location;

	// Transient fields populated by DAO joins for UI display
	private String parentCourseName;
	private String leaderUsername; // For displaying the leader's name
	private String userAttendanceStatus; // User-specific status (ANGEMELDET, ABGEMELDET, OFFEN)

	// --- Formatted Helpers ---

	public String getFormattedMeetingDateTime() {
		return DateFormatter.formatDateTime(this.meetingDateTime);
	}

	public String getFormattedMeetingDateTimeRange() {
		return DateFormatter.formatDateTimeRange(this.meetingDateTime, this.endDateTime);
	}

	// --- Getters and Setters ---

	public int getLeaderUserId() {
		return leaderUserId;
	}

	public void setLeaderUserId(int leaderUserId) {
		this.leaderUserId = leaderUserId;
	}

	public String getLeaderUsername() {
		return leaderUsername;
	}

	public void setLeaderUsername(String leaderUsername) {
		this.leaderUsername = leaderUsername;
	}

	public String getUserAttendanceStatus() {
		return userAttendanceStatus;
	}

	public void setUserAttendanceStatus(String userAttendanceStatus) {
		this.userAttendanceStatus = userAttendanceStatus;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LocalDateTime getMeetingDateTime() {
		return meetingDateTime;
	}

	public void setMeetingDateTime(LocalDateTime meetingDateTime) {
		this.meetingDateTime = meetingDateTime;
	}

	public LocalDateTime getEndDateTime() {
		return endDateTime;
	}

	public void setEndDateTime(LocalDateTime endDateTime) {
		this.endDateTime = endDateTime;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getParentCourseName() {
		return parentCourseName;
	}

	public void setParentCourseName(String parentCourseName) {
		this.parentCourseName = parentCourseName;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttachment.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * Represents a file attachment from the `meeting_attachments` table. It links a
 * file (with its path and name) to a specific meeting and includes a
 * `requiredRole` to control its visibility to different types of users.
 */
public class MeetingAttachment {
	private int id;
	private int meetingId;
	private String filename;
	private String filepath;
	private LocalDateTime uploadedAt;
	private String requiredRole; // "NUTZER" or "ADMIN"

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public String getFilename() {
		return filename;
	}

	public void setFilename(String filename) {
		this.filename = filename;
	}

	public String getFilepath() {
		return filepath;
	}

	public void setFilepath(String filepath) {
		this.filepath = filepath;
	}

	public LocalDateTime getUploadedAt() {
		return uploadedAt;
	}

	public void setUploadedAt(LocalDateTime uploadedAt) {
		this.uploadedAt = uploadedAt;
	}

	public String getRequiredRole() {
		return requiredRole;
	}

	public void setRequiredRole(String requiredRole) {
		this.requiredRole = requiredRole;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\MeetingAttendance.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `meeting_attendance` table, linking a user to a
 * specific meeting. It tracks whether the user attended the meeting and allows
 * for optional remarks (e.g., "excused absence").
 */
public class MeetingAttendance {
	private int userId;
	private int meetingId;
	private boolean attended;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getMeetingId() {
		return meetingId;
	}

	public void setMeetingId(int meetingId) {
		this.meetingId = meetingId;
	}

	public boolean getAttended() {
		return attended;
	}

	public void setAttended(boolean attended) {
		this.attended = attended;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\NavigationItem.java
========================================================================

package de.technikteam.model;

public class NavigationItem {
    private final String label;
    private final String url;
    private final String icon;
    private final String requiredPermission;

    public NavigationItem(String label, String url, String icon, String requiredPermission) {
        this.label = label;
        this.url = url;
        this.icon = icon;
        this.requiredPermission = requiredPermission;
    }

    public String getLabel() {
        return label;
    }

    public String getUrl() {
        return url;
    }

    public String getIcon() {
        return icon;
    }

    public String getRequiredPermission() {
        return requiredPermission;
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\ParticipationHistory.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;

/**
 * A Data Transfer Object (DTO) specifically designed for creating reports. It
 * combines data from users and events to create a historical record of
 * participation, showing who participated in which event, when, and with what
 * status. This class does not map to a single database table.
 */
public class ParticipationHistory {
	private String username;
	private String eventName;
	private LocalDateTime eventDate;
	private String status;

	public ParticipationHistory() {
	}

	// --- Getters and Setters ---

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getEventName() {
		return eventName;
	}

	public void setEventName(String eventName) {
		this.eventName = eventName;
	}

	public LocalDateTime getEventDate() {
		return eventDate;
	}

	public void setEventDate(LocalDateTime eventDate) {
		this.eventDate = eventDate;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\Role.java
========================================================================

package de.technikteam.model;

public class Role {
    private int id;
    private String roleName;

    // Getters and Setters
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getRoleName() {
        return roleName;
    }
    public void setRoleName(String roleName) {
        this.roleName = roleName;
    }
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SkillRequirement.java
========================================================================

package de.technikteam.model;

/**
 * Represents a record from the `event_skill_requirements` table. It defines a
 * specific skill (by referencing a `Course`) and the number of people with that
 * skill required for a particular event.
 */
public class SkillRequirement {
	private int requiredCourseId;
	private int requiredPersons;

	// Transient field for UI display, populated by a DAO join
	private String courseName;

	// --- Getters and Setters ---

	public int getRequiredCourseId() {
		return requiredCourseId;
	}

	public void setRequiredCourseId(int requiredCourseId) {
		this.requiredCourseId = requiredCourseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public int getRequiredPersons() {
		return requiredPersons;
	}

	public void setRequiredPersons(int requiredPersons) {
		this.requiredPersons = requiredPersons;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageItem.java
========================================================================

package de.technikteam.model;

/**
 * Represents a single item from the `storage_items` (inventory) table.
 */
public class StorageItem {
	private int id;
	private String name;
	private String location;
	private String cabinet;
	private String compartment;
	private int quantity;
	private int maxQuantity;
	private int defectiveQuantity;
	private String defectReason;
	private double weightKg;
	private double priceEur;
	private String imagePath;

	// NEW FIELDS for enhanced tracking
	private String status; // ENUM: 'IN_STORAGE', 'CHECKED_OUT', 'ASSIGNED_TO_EVENT', 'MAINTENANCE'
	private int currentHolderUserId;
	private int assignedEventId;

	// TRANSIENT FIELD for displaying the holder's name
	private String currentHolderUsername;

	public StorageItem() {
	}

	public int getAvailableQuantity() {
		return this.quantity - this.defectiveQuantity;
	}

	public String getAvailabilityStatus() {
		if (this.getAvailableQuantity() <= 0) {
			return "Vergriffen";
		}
		if (this.maxQuantity > 0 && this.getAvailableQuantity() >= this.maxQuantity) {
			return "Vollständig";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "Niedriger Bestand";
		}
		return "Auf Lager";
	}

	public String getAvailabilityStatusCssClass() {
		if (this.getAvailableQuantity() <= 0) {
			return "status-danger";
		}
		if (this.maxQuantity > 0 && (double) this.getAvailableQuantity() / this.maxQuantity <= 0.25) {
			return "status-warn";
		}
		return "status-ok";
	}

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getLocation() {
		return location;
	}

	public void setLocation(String location) {
		this.location = location;
	}

	public String getCabinet() {
		return cabinet;
	}

	public void setCabinet(String cabinet) {
		this.cabinet = cabinet;
	}

	public String getCompartment() {
		return compartment;
	}

	public void setCompartment(String compartment) {
		this.compartment = compartment;
	}

	public int getQuantity() {
		return quantity;
	}

	public void setQuantity(int quantity) {
		this.quantity = quantity;
	}

	public int getMaxQuantity() {
		return maxQuantity;
	}

	public void setMaxQuantity(int maxQuantity) {
		this.maxQuantity = maxQuantity;
	}

	public int getDefectiveQuantity() {
		return defectiveQuantity;
	}

	public void setDefectiveQuantity(int defectiveQuantity) {
		this.defectiveQuantity = defectiveQuantity;
	}

	public String getDefectReason() {
		return defectReason;
	}

	public void setDefectReason(String defectReason) {
		this.defectReason = defectReason;
	}

	public double getWeightKg() {
		return weightKg;
	}

	public void setWeightKg(double weightKg) {
		this.weightKg = weightKg;
	}

	public double getPriceEur() {
		return priceEur;
	}

	public void setPriceEur(double priceEur) {
		this.priceEur = priceEur;
	}

	public String getImagePath() {
		return imagePath;
	}

	public void setImagePath(String imagePath) {
		this.imagePath = imagePath;
	}

	// --- Getters and Setters for NEW fields ---
	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public int getCurrentHolderUserId() {
		return currentHolderUserId;
	}

	public void setCurrentHolderUserId(int currentHolderUserId) {
		this.currentHolderUserId = currentHolderUserId;
	}

	public int getAssignedEventId() {
		return assignedEventId;
	}

	public void setAssignedEventId(int assignedEventId) {
		this.assignedEventId = assignedEventId;
	}

	public String getCurrentHolderUsername() {
		return currentHolderUsername;
	}

	public void setCurrentHolderUsername(String currentHolderUsername) {
		this.currentHolderUsername = currentHolderUsername;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\StorageLogEntry.java
========================================================================

package de.technikteam.model;

import de.technikteam.config.DateFormatter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A Data Transfer Object (DTO) to represent a single entry from the storage_log
 * table, enriched with the username of the person who performed the
 * transaction.
 */
public class StorageLogEntry {
	private int id;
	private int itemId;
	private int userId;
	private String username;
	private int quantityChange;
	private String notes;
	private int eventId; // Can be 0 if not linked
	private LocalDateTime transactionTimestamp;

	// Define the formatter here
	private static final DateTimeFormatter GERMAN_LOCALE_FORMATTER = DateTimeFormatter
			.ofPattern("dd.MM.yyyy, HH:mm:ss");

	// --- Getters and Setters ---

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getItemId() {
		return itemId;
	}

	public void setItemId(int itemId) {
		this.itemId = itemId;
	}

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getQuantityChange() {
		return quantityChange;
	}

	public void setQuantityChange(int quantityChange) {
		this.quantityChange = quantityChange;
	}

	public String getNotes() {
		return notes;
	}

	public void setNotes(String notes) {
		this.notes = notes;
	}

	public int getEventId() {
		return eventId;
	}

	public void setEventId(int eventId) {
		this.eventId = eventId;
	}

	public LocalDateTime getTransactionTimestamp() {
		return transactionTimestamp;
	}

	public void setTransactionTimestamp(LocalDateTime transactionTimestamp) {
		this.transactionTimestamp = transactionTimestamp;
	}

	// OLD METHOD - uses a different formatter
	public String getFormattedTimestamp() {
		return DateFormatter.formatDateTime(this.transactionTimestamp);
	}

	// NEW GETTER for the specific locale string required by the JSP
	public String getTransactionTimestampLocaleString() {
		if (this.transactionTimestamp == null) {
			return "";
		}
		return this.transactionTimestamp.format(GERMAN_LOCALE_FORMATTER);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\SystemStatsDTO.java
========================================================================

package de.technikteam.model;

/**
 * A Data Transfer Object (DTO) for holding system statistics.
 */
public class SystemStatsDTO {
	private double cpuLoad;
	private long totalMemory;
	private long usedMemory;
	private long totalDiskSpace;
	private long usedDiskSpace;
	private String uptime;
	private int batteryPercentage;

	// --- Getters and Setters ---

	public double getCpuLoad() {
		return cpuLoad;
	}

	public void setCpuLoad(double cpuLoad) {
		this.cpuLoad = cpuLoad;
	}

	public long getTotalMemory() {
		return totalMemory;
	}

	public void setTotalMemory(long totalMemory) {
		this.totalMemory = totalMemory;
	}

	public long getUsedMemory() {
		return usedMemory;
	}

	public void setUsedMemory(long usedMemory) {
		this.usedMemory = usedMemory;
	}

	public long getTotalDiskSpace() {
		return totalDiskSpace;
	}

	public void setTotalDiskSpace(long totalDiskSpace) {
		this.totalDiskSpace = totalDiskSpace;
	}

	public long getUsedDiskSpace() {
		return usedDiskSpace;
	}

	public void setUsedDiskSpace(long usedDiskSpace) {
		this.usedDiskSpace = usedDiskSpace;
	}

	public String getUptime() {
		return uptime;
	}

	public void setUptime(String uptime) {
		this.uptime = uptime;
	}

	public int getBatteryPercentage() {
		return batteryPercentage;
	}

	public void setBatteryPercentage(int batteryPercentage) {
		this.batteryPercentage = batteryPercentage;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\User.java
========================================================================

package de.technikteam.model;

import java.time.LocalDateTime;
import java.util.Set;

public class User {
	private int id;
	private String username;
	private int roleId;
	private String roleName;
	private Set<String> permissions;
	private LocalDateTime createdAt;
	private int classYear;
	private String className;
	private String email;
	private String chatColor; // NEW: To store the user's preferred chat bubble color

	public User() {
	}

	public User(int id, String username, String roleName) {
		this.id = id;
		this.username = username;
		this.roleName = roleName;
	}

	// Getters and Setters
	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public int getRoleId() {
		return roleId;
	}

	public void setRoleId(int roleId) {
		this.roleId = roleId;
	}

	public String getRoleName() {
		return roleName;
	}

	public void setRoleName(String roleName) {
		this.roleName = roleName;
	}

	public Set<String> getPermissions() {
		return permissions;
	}

	public void setPermissions(Set<String> permissions) {
		this.permissions = permissions;
	}

	public LocalDateTime getCreatedAt() {
		return createdAt;
	}

	public void setCreatedAt(LocalDateTime createdAt) {
		this.createdAt = createdAt;
	}

	public int getClassYear() {
		return classYear;
	}

	public void setClassYear(int classYear) {
		this.classYear = classYear;
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	public String getChatColor() {
		return chatColor;
	} // NEW

	public void setChatColor(String chatColor) {
		this.chatColor = chatColor;
	} // NEW

	public String getFormattedCreatedAt() {
		return de.technikteam.config.DateFormatter.formatDateTime(this.createdAt);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\model\UserQualification.java
========================================================================

package de.technikteam.model;

import java.time.LocalDate;

/**
 * Represents the link between a user and a course they have attended or
 * completed, acting as a record of their qualification or skill. This model
 * corresponds to a record in the `user_qualifications` table.
 */
public class UserQualification {
	private int userId;
	private int courseId;
	private String courseName; // For display, joined from 'courses' table
	private String status; // e.g., "BESUCHT", "ABSOLVIERT"
	private LocalDate completionDate;
	private String remarks;

	// --- Getters and Setters ---

	public int getUserId() {
		return userId;
	}

	public void setUserId(int userId) {
		this.userId = userId;
	}

	public int getCourseId() {
		return courseId;
	}

	public void setCourseId(int courseId) {
		this.courseId = courseId;
	}

	public String getCourseName() {
		return courseName;
	}

	public void setCourseName(String courseName) {
		this.courseName = courseName;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public LocalDate getCompletionDate() {
		return completionDate;
	}

	public void setCompletionDate(LocalDate completionDate) {
		this.completionDate = completionDate;
	}

	public String getRemarks() {
		return remarks;
	}

	public void setRemarks(String remarks) {
		this.remarks = remarks;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\AdminLogService.java
========================================================================

package de.technikteam.service;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * A simple service layer that acts as a middleman for logging administrative
 * actions. It provides a static `log` method that other parts of the
 * application can call to create an audit log entry. This decouples the
 * application logic from the direct use of the AdminLogDAO.
 */
public class AdminLogService {
	private static final Logger logger = LogManager.getLogger(AdminLogService.class);
	private static final AdminLogDAO logDAO = new AdminLogDAO();

	/**
	 * Creates and persists an administrative audit log entry. This is the central
	 * point for all audit logging.
	 * 
	 * @param adminUsername The username of the admin performing the action.
	 * @param actionType    A high-level category for the action (e.g.,
	 *                      "UPDATE_USER", "DELETE_EVENT").
	 * @param details       A detailed, human-readable description of the action and
	 *                      its context.
	 */
	public static void log(String adminUsername, String actionType, String details) {
		try {
			AdminLog log = new AdminLog();
			log.setAdminUsername(adminUsername);
			log.setActionType(actionType);
			log.setDetails(details);

			// Log the same info to the file/console for debugging purposes before DB write
			logger.info("[AUDIT] User: '{}', Action: '{}', Details: {}", adminUsername, actionType, details);

			logDAO.createLog(log);
		} catch (Exception e) {
			// Log the failure to write to the audit log itself
			logger.error("CRITICAL: Failed to write to admin audit log! Data: [User: {}, Action: {}, Details: {}]",
					adminUsername, actionType, details, e);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\NotificationService.java
========================================================================

package de.technikteam.service;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.model.User;
import jakarta.servlet.AsyncContext;
import jakarta.servlet.http.HttpServletRequest;

public class NotificationService {
	private static final Logger logger = LogManager.getLogger(NotificationService.class);
	private static final NotificationService INSTANCE = new NotificationService();

	// CORRECTION: Change from a simple list to a map keyed by userId
	private final Map<Integer, List<AsyncContext>> contextsByUser = new ConcurrentHashMap<>();

	private NotificationService() {
	}

	public static NotificationService getInstance() {
		return INSTANCE;
	}

	public void register(HttpServletRequest request) {
		User user = (User) request.getSession().getAttribute("user");
		if (user == null) {
			logger.warn("Attempt to register for notifications from a non-authenticated session.");
			return;
		}

		AsyncContext asyncContext = request.startAsync();
		asyncContext.setTimeout(0); // No timeout for SSE connections

		// Register the context under the user's ID
		contextsByUser.computeIfAbsent(user.getId(), k -> new CopyOnWriteArrayList<>()).add(asyncContext);
		logger.info("New client registered for SSE notifications for user ID {}. Total clients for user: {}",
				user.getId(), contextsByUser.get(user.getId()).size());
	}

	public void sendNotification(String message) {
		logger.info("Broadcasting notification to all clients: {}", message);
		// Iterate through all user lists and all their contexts
		contextsByUser.values().forEach(contextList -> {
			contextList.forEach(context -> sendMessageToContext(context, message, contextList));
		});
	}

	public void sendNotificationToUser(int userId, String message) {
		List<AsyncContext> userContexts = contextsByUser.get(userId);
		if (userContexts != null && !userContexts.isEmpty()) {
			logger.info("Sending targeted notification to user ID {}: {}", userId, message);
			userContexts.forEach(context -> sendMessageToContext(context, message, userContexts));
		} else {
			logger.debug("No active SSE clients found for user ID {} to send notification.", userId);
		}
	}

	private void sendMessageToContext(AsyncContext context, String message, List<AsyncContext> contextList) {
		try {
			PrintWriter writer = context.getResponse().getWriter();
			writer.write("data: " + message + "\n\n");
			writer.flush();
		} catch (IOException e) {
			logger.warn("Failed to send notification to a client (likely disconnected), removing it.");
			contextList.remove(context); // Remove from the specific user's list
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\service\SystemInfoService.java
========================================================================

package de.technikteam.service;

import com.sun.management.OperatingSystemMXBean;
import de.technikteam.model.SystemStatsDTO;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.concurrent.TimeUnit;

/**
 * A service to gather system statistics from the underlying OS. This version is
 * made more platform-independent and robust for Windows environments.
 */
public class SystemInfoService {
	private static final Logger logger = LogManager.getLogger(SystemInfoService.class);
	private static final long GIGA_BYTE = 1024L * 1024L * 1024L;

	public SystemStatsDTO getSystemStats() {
		SystemStatsDTO stats = new SystemStatsDTO();
		OperatingSystemMXBean osBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean.class);
		File root = new File("/");

		// CPU Load (cross-platform)
		stats.setCpuLoad(osBean.getSystemCpuLoad() * 100.0);

		// Physical Memory (cross-platform)
		long totalMemoryBytes = osBean.getTotalPhysicalMemorySize();
		long freeMemoryBytes = osBean.getFreePhysicalMemorySize();
		stats.setTotalMemory(totalMemoryBytes / GIGA_BYTE);
		stats.setUsedMemory((totalMemoryBytes - freeMemoryBytes) / GIGA_BYTE);

		// Disk Space (cross-platform)
		long totalDiskBytes = root.getTotalSpace();
		long usableDiskBytes = root.getUsableSpace();
		stats.setTotalDiskSpace(totalDiskBytes / GIGA_BYTE);
		stats.setUsedDiskSpace((totalDiskBytes - usableDiskBytes) / GIGA_BYTE);

		// Uptime (Linux-specific with fallback)
		stats.setUptime(getSystemUptime());

		// Battery (Linux-specific with fallback)
		stats.setBatteryPercentage(getBatteryPercentage());

		return stats;
	}

	private String getSystemUptime() {
		// This part is Linux-specific, so we wrap it in a try-catch.
		try {
			// On Linux, this file contains the system uptime in seconds.
			String content = new String(Files.readAllBytes(Paths.get("/proc/uptime")));
			double uptimeSeconds = Double.parseDouble(content.split(" ")[0]);
			long days = TimeUnit.SECONDS.toDays((long) uptimeSeconds);
			long hours = TimeUnit.SECONDS.toHours((long) uptimeSeconds) % 24;
			long minutes = TimeUnit.SECONDS.toMinutes((long) uptimeSeconds) % 60;
			return String.format("%d Tage, %d Stunden, %d Minuten", days, hours, minutes);
		} catch (IOException | NumberFormatException e) {
			// This will be caught on Windows or if the file is unreadable.
			logger.warn("Could not read /proc/uptime. Uptime not available. OS might not be Linux.");
			return "Nicht verfügbar";
		}
	}

	private int getBatteryPercentage() {
		// This part is also Linux-specific.
		try {
			// Common path for laptop batteries on Linux.
			String content = new String(Files.readAllBytes(Paths.get("/sys/class/power_supply/BAT0/capacity")));
			return Integer.parseInt(content.trim());
		} catch (IOException | NumberFormatException e) {
			// This will fail on systems without a battery or non-Linux OS.
			logger.trace("Could not read battery status. System might not have a battery or is not Linux.");
			return -1; // Indicates no battery or not available
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminAttendanceServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Meeting;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;

/**
 * Mapped to `/admin/attendance`, this servlet handles all actions related to
 * updating meeting attendance records, primarily called from the modal window
 * on the administrative qualifications matrix (`admin_matrix.jsp`).
 */
@WebServlet("/admin/teilnahme")
public class AdminAttendanceServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminAttendanceServlet.class);
	private MeetingAttendanceDAO attendanceDAO;
	private UserDAO userDAO;
	private MeetingDAO meetingDAO;

	@Override
	public void init() {
		attendanceDAO = new MeetingAttendanceDAO();
		userDAO = new UserDAO();
		meetingDAO = new MeetingDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		request.setCharacterEncoding("UTF-8");
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo"); // e.g., "matrix"

		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			int meetingId = Integer.parseInt(request.getParameter("meetingId"));

			// A checkbox sends "true" if checked, and null if not. This is a standard way
			// to check it.
			boolean attended = "true".equals(request.getParameter("attended"));

			String remarks = request.getParameter("remarks");
			logger.debug("Processing attendance update for user ID {}, meeting ID {}. Attended: {}, Remarks: '{}'",
					userId, meetingId, attended, remarks);

			if (attendanceDAO.setAttendance(userId, meetingId, attended, remarks)) {
				// Fetch details for rich logging
				User targetUser = userDAO.getUserById(userId);
				Meeting meeting = meetingDAO.getMeetingById(meetingId);

				String status = attended ? "TEILGENOMMEN" : "NICHT TEILGENOMMEN";
				String logDetails = String.format(
						"Teilnahme für Nutzer '%s' (ID: %d) bei Meeting '%s' (ID: %d) auf '%s' gesetzt. Bemerkungen: '%s'.",
						(targetUser != null ? targetUser.getUsername() : "N/A"), userId,
						(meeting != null ? meeting.getName() : "N/A"), meetingId, status, remarks);

				AdminLogService.log(adminUser.getUsername(), "UPDATE_ATTENDANCE", logDetails);

				request.getSession().setAttribute("successMessage", "Teilnahmestatus erfolgreich aktualisiert.");
				logger.info("Attendance update successful for user ID {} / meeting ID {}.", userId, meetingId);
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Teilnahmestatus konnte nicht aktualisiert werden.");
				logger.error("Attendance update failed for user ID {} / meeting ID {}.", userId, meetingId);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid ID received in AdminAttendanceServlet.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: Ungültige ID empfangen.");
		}

		// Redirect back to the matrix or a default page
		String redirectUrl = request.getContextPath()
				+ ("/matrix".equals(returnTo) ? "/admin/matrix" : "/admin/dashboard");
		logger.debug("Redirecting to {}", redirectUrl);
		response.sendRedirect(redirectUrl);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminCourseServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.CourseDAO;
import de.technikteam.model.Course;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import java.io.IOException;
import java.util.List;
import java.util.Objects;

/**
 * 
 * Mapped to /admin/lehrgaenge, this servlet manages the parent course
 * templates.
 * 
 * It handles listing all course templates, and processing the creation, update,
 * 
 * and deletion of these templates, which are now managed via modal dialogs on
 * 
 * the list page.
 */
@WebServlet("/admin/lehrgaenge")
public class AdminCourseServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminCourseServlet.class);
	private CourseDAO courseDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		courseDAO = new CourseDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getCourseData".equals(action)) {
			getCourseDataAsJson(req, resp);
			return;
		}

		logger.info("Listing all course templates for admin view.");
		List<Course> courseList = courseDAO.getAllCourses();
		req.setAttribute("courseList", courseList);
		req.getRequestDispatcher("/views/admin/admin_course_list.jsp").forward(req, resp);
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getParameter("action");
		logger.debug("AdminCourseServlet received POST request with action: {}", action);
		if ("delete".equals(action)) {
			handleDelete(req, resp);
		} else if ("create".equals(action) || "update".equals(action)) {
			handleCreateOrUpdate(req, resp);
		} else {
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
		}
	}

	private void getCourseDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			Course course = courseDAO.getCourseById(courseId);
			if (course != null) {
				String courseJson = gson.toJson(course);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(courseJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Course not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid course ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = request.getParameter("id");
		Course course = new Course();
		course.setName(request.getParameter("name"));
		course.setAbbreviation(request.getParameter("abbreviation"));
		course.setDescription(request.getParameter("description"));

		boolean success;
		if (idParam != null && !idParam.isEmpty()) { // UPDATE
			course.setId(Integer.parseInt(idParam));
			logger.info("Attempting to update course: {}", course.getName());
			Course originalCourse = courseDAO.getCourseById(course.getId());
			success = courseDAO.updateCourse(course);
			if (success && originalCourse != null) {
				StringBuilder changes = new StringBuilder();
				if (!Objects.equals(originalCourse.getName(), course.getName())) {
					changes.append(String.format("Name: '%s' -> '%s'. ", originalCourse.getName(), course.getName()));
				}
				if (!Objects.equals(originalCourse.getAbbreviation(), course.getAbbreviation())) {
					changes.append(String.format("Abk.: '%s' -> '%s'. ", originalCourse.getAbbreviation(),
							course.getAbbreviation()));
				}
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (ID: %d) aktualisiert. %s",
						originalCourse.getName(), course.getId(), changes.toString());
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else if (success) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_COURSE",
						"Lehrgangs-Vorlage (ID: " + course.getId() + ") aktualisiert.");
				request.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren der Vorlage.");
			}
		} else { // CREATE
			logger.info("Attempting to create new course: {}", course.getName());
			success = courseDAO.createCourse(course);
			if (success) {
				String logDetails = String.format("Lehrgangs-Vorlage '%s' (Abk.: %s) erstellt.", course.getName(),
						course.getAbbreviation());
				AdminLogService.log(adminUser.getUsername(), "CREATE_COURSE", logDetails);
				request.getSession().setAttribute("successMessage", "Neue Lehrgangs-Vorlage erfolgreich erstellt.");
			} else {
				request.getSession().setAttribute("errorMessage", "Fehler beim Erstellen der Vorlage.");
			}
		}
		response.sendRedirect(request.getContextPath() + "/admin/lehrgaenge");
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int courseId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete course with ID: {}", courseId);
			// Fetch course details before deleting for detailed logging
			Course courseToDelete = courseDAO.getCourseById(courseId);
			String courseName = (courseToDelete != null) ? courseToDelete.getName() : "N/A";

			if (courseDAO.deleteCourse(courseId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_COURSE",
						"Lehrgangs-Vorlage '" + courseName + "' (ID: " + courseId
								+ ") und alle zugehörigen Meetings, Anhänge und Qualifikationen gelöscht.");
				req.getSession().setAttribute("successMessage", "Lehrgangs-Vorlage erfolgreich gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Vorlage konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid course ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Löschvorgang.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/lehrgaenge");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDashboardServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.StatisticsDAO;
import de.technikteam.dao.StorageDAO; // Import StorageDAO
import de.technikteam.model.StorageItem; // Import StorageItem model
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/dashboard`, this servlet serves as the entry point for the
 * main administrative dashboard. It uses the `StatisticsDAO` to fetch key
 * metrics like the total user count and the number of active events. It then
 * forwards this data to `admin_dashboard.jsp` for display.
 */
@WebServlet("/admin/dashboard")
public class AdminDashboardServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminDashboardServlet.class);
	private StatisticsDAO statisticsDAO;
	private StorageDAO storageDAO; // NEW: DAO for storage items

	@Override
	public void init() {
		statisticsDAO = new StatisticsDAO();
		storageDAO = new StorageDAO(); // NEW: Initialize the DAO
	}

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Admin dashboard requested. Fetching statistics.");

		int userCount = statisticsDAO.getUserCount();
		int activeEventCount = statisticsDAO.getActiveEventCount();
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems(); // NEW: Fetch defective items

		request.setAttribute("userCount", userCount);
		request.setAttribute("activeEventCount", activeEventCount);
		request.setAttribute("defectiveItems", defectiveItems); // NEW: Set the attribute for the JSP

		logger.debug("Forwarding to admin_dashboard.jsp with userCount={}, activeEventCount={}, defectiveItems={}",
				userCount, activeEventCount, defectiveItems.size());
		// CORRECTED: Forward to the actual JSP file path.
		request.getRequestDispatcher("/views/admin/admin_dashboard.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminDefectServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.StorageDAO;
import de.technikteam.model.StorageItem;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.List;

/**
 * Servlet to display a list of all defective items.
 */
@WebServlet("/admin/defekte")
public class AdminDefectServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private StorageDAO storageDAO;

	@Override
	public void init() {
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<StorageItem> defectiveItems = storageDAO.getDefectiveItems();
		request.setAttribute("defectiveItems", defectiveItems);
		// CORRECTED: Forward to the actual JSP file path.
		request.getRequestDispatcher("/views/admin/admin_defect_list.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminEventServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.EventAttachmentDAO;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Event;
import de.technikteam.model.EventAttachment;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

@WebServlet("/admin/veranstaltungen")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 40, maxRequestSize = 1024 * 1024 * 80)
public class AdminEventServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminEventServlet.class);

	private EventDAO eventDAO;
	private CourseDAO courseDAO;
	private StorageDAO storageDAO;
	private UserDAO userDAO;
	private EventAttachmentDAO attachmentDAO;
	private EventCustomFieldDAO customFieldDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		courseDAO = new CourseDAO();
		storageDAO = new StorageDAO();
		userDAO = new UserDAO();
		attachmentDAO = new EventAttachmentDAO();
		customFieldDAO = new EventCustomFieldDAO(); // Correct initialization
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).setPrettyPrinting().create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action") == null ? "list" : req.getParameter("action");
		logger.debug("AdminEventServlet received GET request with action: {}", action);
		try {
			switch (action) {
			case "getEventData":
				getEventDataAsJson(req, resp);
				break;
			case "getAssignmentData":
				getAssignmentDataAsJson(req, resp);
				break;
			default:
				listEvents(req, resp);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminEventServlet doGet", e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action;

		if (req.getContentType() != null && req.getContentType().toLowerCase().startsWith("multipart/")) {
			action = ServletUtils.getPartValue(req.getPart("action"));
		} else {
			action = req.getParameter("action");
		}
		logger.debug("AdminEventServlet received POST request with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "assignUsers":
			handleAssignUsers(req, resp);
			break;
		case "updateStatus":
			handleStatusUpdate(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
			break;
		}
	}

	private void listEvents(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		logger.info("Listing all events for admin view.");
		List<Event> eventList = eventDAO.getAllEvents();
		List<Course> allCourses = courseDAO.getAllCourses();
		List<StorageItem> allItems = storageDAO.getAllItems(); // CORRECTION: Use the simpler DAO method
		List<User> allUsers = userDAO.getAllUsers();

		req.setAttribute("eventList", eventList);
		req.setAttribute("allCourses", allCourses);
		req.setAttribute("allItems", allItems);
		req.setAttribute("allUsers", allUsers);
		// CORRECTED: Forward to the actual JSP file path.
		req.getRequestDispatcher("/views/admin/admin_events_list.jsp").forward(req, resp);
	}

	private void getEventDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			Event event = eventDAO.getEventById(eventId);
			if (event != null) {
				event.setSkillRequirements(eventDAO.getSkillRequirementsForEvent(eventId));
				event.setReservedItems(eventDAO.getReservedItemsForEvent(eventId));
				event.setAttachments(attachmentDAO.getAttachmentsForEvent(eventId, "ADMIN"));
				event.setCustomFields(customFieldDAO.getCustomFieldsForEvent(eventId));
				String eventJson = gson.toJson(event);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(eventJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND);
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST);
		}
	}

	private void getAssignmentDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			List<User> signedUpUsers = eventDAO.getSignedUpUsersForEvent(eventId);
			Set<Integer> assignedUserIds = eventDAO.getAssignedUsersForEvent(eventId).stream().map(User::getId)
					.collect(Collectors.toSet());

			Map<String, Object> responseData = new HashMap<>();
			responseData.put("signedUpUsers", signedUpUsers);
			responseData.put("assignedUserIds", assignedUserIds);

			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(gson.toJson(responseData));

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID for assignment data.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Event-ID.");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String idParam = ServletUtils.getPartValue(request.getPart("id"));
		boolean isUpdate = idParam != null && !idParam.isEmpty();
		Event event = new Event();

		try {
			event.setName(ServletUtils.getPartValue(request.getPart("name")));
			event.setDescription(ServletUtils.getPartValue(request.getPart("description")));
			event.setLocation(ServletUtils.getPartValue(request.getPart("location")));
			event.setEventDateTime(LocalDateTime.parse(ServletUtils.getPartValue(request.getPart("eventDateTime"))));

			String endDateTimeParam = ServletUtils.getPartValue(request.getPart("endDateTime"));
			if (endDateTimeParam != null && !endDateTimeParam.isEmpty()) {
				event.setEndDateTime(LocalDateTime.parse(endDateTimeParam));
			}

			String leaderIdStr = ServletUtils.getPartValue(request.getPart("leaderUserId"));
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				event.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			int eventId = 0;
			if (isUpdate) {
				eventId = Integer.parseInt(idParam);
				Event originalEvent = eventDAO.getEventById(eventId);
				event.setId(eventId);
				event.setStatus(originalEvent.getStatus()); // Status is updated via its own action
				if (eventDAO.updateEvent(event)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") aktualisiert.");
				}
			} else { // CREATE
				eventId = eventDAO.createEvent(event);
				if (eventId > 0) {
					event.setId(eventId);
					AdminLogService.log(adminUser.getUsername(), "CREATE_EVENT",
							"Event '" + event.getName() + "' (ID: " + eventId + ") erstellt.");
				}
			}

			if (eventId > 0) {
				// Handle skill requirements
				String[] requiredCourseIds = request.getParameterValues("requiredCourseId");
				String[] requiredPersons = request.getParameterValues("requiredPersons");
				eventDAO.saveSkillRequirements(eventId, requiredCourseIds, requiredPersons);

				// Handle storage reservations
				String[] itemIds = request.getParameterValues("itemId");
				String[] quantities = request.getParameterValues("itemQuantity");
				eventDAO.saveReservations(eventId, itemIds, quantities);

				// Handle custom sign-up fields
				String[] customFieldNames = request.getParameterValues("customFieldName");
				String[] customFieldTypes = request.getParameterValues("customFieldType");
				if (customFieldNames != null) {
					List<EventCustomField> customFields = new ArrayList<>();
					for (int i = 0; i < customFieldNames.length; i++) {
						if (customFieldNames[i] != null && !customFieldNames[i].trim().isEmpty()) {
							EventCustomField cf = new EventCustomField();
							cf.setFieldName(customFieldNames[i]);
							cf.setFieldType(customFieldTypes[i]);
							cf.setRequired(true); // Simplified for this implementation
							customFields.add(cf);
						}
					}
					customFieldDAO.saveCustomFieldsForEvent(eventId, customFields);
				}

				// Handle file upload
				Part filePart = request.getPart("attachment");
				if (filePart != null && filePart.getSize() > 0) {
					String requiredRole = ServletUtils.getPartValue(request.getPart("requiredRole"));
					handleAttachmentUpload(filePart, eventId, requiredRole, adminUser, request);
				}
				request.getSession().setAttribute("successMessage", "Event erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Event konnte nicht gespeichert werden.");
			}

		} catch (DateTimeParseException e) {
			logger.error("Invalid date format submitted for event.", e);
			request.getSession().setAttribute("errorMessage",
					"Ungültiges Datumsformat. Bitte das Format 'YYYY-MM-DDTHH:MM' verwenden.");
		} catch (Exception e) {
			logger.error("Error during event creation/update.", e);
			request.getSession().setAttribute("errorMessage",
					"Ein unerwarteter Fehler ist aufgetreten: " + e.getMessage());
		}

		response.sendRedirect(request.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleAttachmentUpload(Part filePart, int eventId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "events";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		EventAttachment attachment = new EventAttachment();
		attachment.setEventId(eventId);
		attachment.setFilename(fileName);
		attachment.setFilepath("events/" + fileName); // Use forward slashes for URL
		attachment.setRequiredRole(requiredRole);

		if (attachmentDAO.addAttachment(attachment)) {
			AdminLogService.log(adminUser.getUsername(), "ADD_EVENT_ATTACHMENT",
					"Anhang '" + fileName + "' zu Event ID " + eventId + " hinzugefügt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("id"));
		logger.warn("Attempting to delete event attachment ID {}", attachmentId);

		EventAttachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());
			if (physicalFile.exists())
				physicalFile.delete();

			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT_ATTACHMENT", "Anhang '"
						+ attachment.getFilename() + "' von Event ID " + attachment.getEventId() + " gelöscht.");
				resp.setContentType("application/json");
				resp.getWriter().write("{\"message\":\"Anhang gelöscht\"}");
			} else {
				resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
						"Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Anhang nicht gefunden.");
		}
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			logger.warn("Attempting to delete event with ID: {}", eventId);
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.deleteEvent(eventId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_EVENT",
						"Event '" + event.getName() + "' (ID: " + eventId + ") endgültig gelöscht.");
				req.getSession().setAttribute("successMessage", "Event wurde gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Event konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for deletion.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleAssignUsers(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("eventId"));
			String[] userIds = req.getParameterValues("userIds");
			logger.info("Assigning {} users to event ID {}", (userIds != null ? userIds.length : 0), eventId);
			Event event = eventDAO.getEventById(eventId);
			eventDAO.assignUsersToEvent(eventId, userIds);

			String assignedUserCount = (userIds != null) ? String.valueOf(userIds.length) : "0";
			String logDetails = String.format("Team für Event '%s' (ID: %d) finalisiert. %s Benutzer zugewiesen.",
					event.getName(), eventId, assignedUserCount);
			AdminLogService.log(adminUser.getUsername(), "ASSIGN_TEAM", logDetails);

			req.getSession().setAttribute("successMessage", "Team für das Event wurde erfolgreich zugewiesen.");
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for user assignment.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}

	private void handleStatusUpdate(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int eventId = Integer.parseInt(req.getParameter("id"));
			String newStatus = req.getParameter("newStatus");
			logger.info("Updating status for event ID {} to '{}'", eventId, newStatus);
			Event event = eventDAO.getEventById(eventId);
			if (event != null && eventDAO.updateEventStatus(eventId, newStatus)) {
				String logDetails = String.format("Status für Event '%s' (ID: %d) von '%s' auf '%s' geändert.",
						event.getName(), eventId, event.getStatus(), newStatus);
				AdminLogService.log(adminUser.getUsername(), "UPDATE_EVENT_STATUS", logDetails);
				req.getSession().setAttribute("successMessage", "Event-Status erfolgreich aktualisiert.");
			} else {
				req.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Event-Status.");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format for status update.", e);
			req.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/veranstaltungen");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileCategoryServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;

import de.technikteam.dao.FileDAO;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * This servlet is uniquely mapped to multiple URL patterns
 * (`/admin/categories/*`) to handle specific CRUD actions for file categories.
 * It processes POST requests to create, update, or delete a category based on
 * the servlet path, logs the action, and then redirects back to the main admin
 * file management page.
 */
@WebServlet({ "/admin/dateien/kategorien/erstellen", "/admin/dateien/kategorien/aktualisieren", "/admin/dateien/kategorien/loeschen" })
public class AdminFileCategoryServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileCategoryServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action = req.getServletPath();
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.debug("AdminFileCategoryServlet processing POST for action path: {}", action);

		try {
			if (action.endsWith("/erstellen")) {
				String categoryName = req.getParameter("categoryName");
				if (fileDAO.createCategory(categoryName)) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' erstellt.");
					req.getSession().setAttribute("successMessage",
							"Kategorie '" + categoryName + "' erfolgreich erstellt.");
				}
			} else if (action.endsWith("/aktualisieren")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String newName = req.getParameter("categoryName");
				String oldName = fileDAO.getCategoryNameById(categoryId); // Get old name for logging
				if (fileDAO.updateCategory(categoryId, newName)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_FILE_CATEGORY", "Dateikategorie '" + oldName
							+ "' (ID: " + categoryId + ") umbenannt in '" + newName + "'.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich umbenannt.");
				}
			} else if (action.endsWith("/löschen")) {
				int categoryId = Integer.parseInt(req.getParameter("categoryId"));
				String categoryName = fileDAO.getCategoryNameById(categoryId); // Get name for logging
				if (fileDAO.deleteCategory(categoryId)) {
					AdminLogService.log(adminUser.getUsername(), "DELETE_FILE_CATEGORY",
							"Dateikategorie '" + categoryName + "' (ID: " + categoryId + ") gelöscht.");
					req.getSession().setAttribute("successMessage", "Kategorie erfolgreich gelöscht.");
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID format in AdminFileCategoryServlet for action {}", action, e);
			req.getSession().setAttribute("errorMessage", "Ungültige ID für Kategorie-Aktion.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/dateien");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminFileServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.dao.FileDAO;
import de.technikteam.model.File;
import de.technikteam.model.FileCategory;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;

@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
@WebServlet("/admin/dateien")
public class AdminFileServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminFileServlet.class);
	private FileDAO fileDAO;

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		logger.info("Admin file page requested by user '{}'.", user.getUsername());

		Map<String, List<File>> groupedFiles = fileDAO.getAllFilesGroupedByCategory(user);
		List<FileCategory> allCategories = fileDAO.getAllCategories();

		request.setAttribute("groupedFiles", groupedFiles);
		request.setAttribute("allCategories", allCategories);

		logger.debug("Forwarding to admin_files.jsp with {} file groups and {} categories.", groupedFiles.size(),
				allCategories.size());
		request.getRequestDispatcher("/views/admin/admin_files.jsp").forward(request, response);
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();

		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			handleUpload(request, response);
		} else {
			String action = request.getParameter("action");
			if ("delete".equals(action)) {
				handleDelete(request, response);
			} else {
				logger.warn("Received non-multipart POST with unknown or missing action: '{}'", action);
				request.getSession().setAttribute("errorMessage", "Unbekannte Aktion empfangen.");
				response.sendRedirect(request.getContextPath() + "/admin/dateien");
			}
		}
	}

	private void handleUpload(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			String uploadFilePath = AppConfig.UPLOAD_DIRECTORY;
			java.io.File uploadDir = new java.io.File(uploadFilePath);
			if (!uploadDir.exists())
				uploadDir.mkdirs();

			Part filePart = request.getPart("file");
			String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();

			String requiredRole = ServletUtils.getPartValue(request.getPart("requiredRole"));
			String categoryIdStr = ServletUtils.getPartValue(request.getPart("categoryId"));

			int categoryId = 0;
			try {
				if (categoryIdStr != null && !categoryIdStr.isEmpty()) {
					categoryId = Integer.parseInt(categoryIdStr);
				}
			} catch (NumberFormatException e) {
				logger.warn("No valid category ID provided during upload.");
			}

			if (fileName == null || fileName.isEmpty()) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Datei zum Hochladen aus.");
			} else if (categoryId == 0) {
				request.getSession().setAttribute("errorMessage", "Bitte wählen Sie eine Kategorie aus.");
			} else {
				java.io.File targetFile = new java.io.File(uploadDir, fileName);
				filePart.write(targetFile.getAbsolutePath());
				logger.info("File '{}' uploaded by '{}' to: {}", fileName, adminUser.getUsername(),
						targetFile.getAbsolutePath());

				File newDbFile = new File();
				newDbFile.setFilename(fileName);
				newDbFile.setFilepath(fileName);
				newDbFile.setCategoryId(categoryId);
				newDbFile.setRequiredRole(requiredRole);

				if (fileDAO.createFile(newDbFile)) {
					String categoryName = fileDAO.getCategoryNameById(categoryId);
					String logDetails = String.format("Datei '%s' in Kategorie '%s' hochgeladen. Sichtbar für: %s.",
							fileName, categoryName, requiredRole);
					AdminLogService.log(adminUser.getUsername(), "FILE_UPLOAD", logDetails);
					request.getSession().setAttribute("successMessage",
							"Datei '" + fileName + "' erfolgreich hochgeladen.");
				} else {
					request.getSession().setAttribute("errorMessage",
							"DB-Fehler: Datei konnte nicht gespeichert werden (ggf. existiert der Name bereits).");
					targetFile.delete();
				}
			}
		} catch (Exception e) {
			logger.error("File upload failed.", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Upload: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int fileId = Integer.parseInt(request.getParameter("fileId"));
			logger.warn("Attempting to delete file with ID: {} by user '{}'", fileId, adminUser.getUsername());
			File dbFile = fileDAO.getFileById(fileId);

			if (dbFile != null) {
				java.io.File physicalFile = new java.io.File(AppConfig.UPLOAD_DIRECTORY, dbFile.getFilepath());
				boolean physicalDeleted = true;

				if (physicalFile.exists()) {
					physicalDeleted = physicalFile.delete();
				} else {
					logger.warn("Physical file not found at [{}], but proceeding with DB record deletion.",
							physicalFile.getAbsolutePath());
				}

				if (physicalDeleted) {
					if (fileDAO.deleteFile(fileId)) {
						String categoryName = fileDAO.getCategoryNameById(dbFile.getCategoryId());
						String logDetails = String.format("Datei '%s' (ID: %d) aus Kategorie '%s' gelöscht.",
								dbFile.getFilename(), fileId, categoryName != null ? categoryName : "N/A");
						AdminLogService.log(adminUser.getUsername(), "FILE_DELETE", logDetails);
						request.getSession().setAttribute("successMessage",
								"Datei '" + dbFile.getFilename() + "' wurde erfolgreich gelöscht.");
					} else {
						request.getSession().setAttribute("errorMessage",
								"FEHLER: Die Datei konnte aus der Datenbank nicht gelöscht werden.");
					}
				} else {
					request.getSession().setAttribute("errorMessage",
							"FEHLER: Die physische Datei konnte nicht gelöscht werden. Bitte Berechtigungen prüfen.");
				}
			} else {
				request.getSession().setAttribute("errorMessage", "Datei in der Datenbank nicht gefunden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Datei-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/dateien");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminKitServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.InventoryKitDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.InventoryKit;
import de.technikteam.model.InventoryKitItem;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.List;

@WebServlet("/admin/kits")
public class AdminKitServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminKitServlet.class);
	private InventoryKitDAO kitDAO;
	private StorageDAO storageDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		kitDAO = new InventoryKitDAO();
		storageDAO = new StorageDAO();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");

		if ("getKitItems".equals(action)) {
			getKitItemsAsJson(req, resp);
			return;
		}

		List<InventoryKit> kits = kitDAO.getAllKits();
		List<StorageItem> allItems = storageDAO.getAllItems();
		req.setAttribute("kits", kits);
		req.setAttribute("allItems", allItems);
		req.getRequestDispatcher("/views/admin/admin_kits.jsp").forward(req, resp);
	}

	private void getKitItemsAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int kitId = Integer.parseInt(req.getParameter("id"));
			List<InventoryKitItem> items = kitDAO.getItemsForKit(kitId);
			String jsonResponse = gson.toJson(items);
			resp.setContentType("application/json");
			resp.setCharacterEncoding("UTF-8");
			resp.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid kit ID.");
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		req.setCharacterEncoding("UTF-8");
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = req.getParameter("action");
		logger.debug("AdminKitServlet received POST with action: {}", action);

		try {
			switch (action) {
			case "create":
				handleCreateKit(req, adminUser);
				break;
			case "update":
				handleUpdateKit(req, adminUser);
				break;
			case "delete":
				handleDeleteKit(req, adminUser);
				break;
			case "addItem":
				handleAddItemToKit(req, adminUser);
				break;
			case "removeItem":
				handleRemoveItemFromKit(req, adminUser);
				break;
			default:
				logger.warn("Unknown kit action: {}", action);
				break;
			}
		} catch (Exception e) {
			logger.error("Error processing kit action '{}'", action, e);
			req.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
		}

		resp.sendRedirect(req.getContextPath() + "/admin/kits");
	}

	private void handleCreateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		int newId = kitDAO.createKit(kit);
		if (newId > 0) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + newId + ") erstellt.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich erstellt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht erstellt werden.");
		}
	}

	private void handleUpdateKit(HttpServletRequest req, User adminUser) {
		InventoryKit kit = new InventoryKit();
		kit.setId(Integer.parseInt(req.getParameter("id")));
		kit.setName(req.getParameter("name"));
		kit.setDescription(req.getParameter("description"));
		if (kitDAO.updateKit(kit)) {
			AdminLogService.log(adminUser.getUsername(), "UPDATE_KIT",
					"Kit '" + kit.getName() + "' (ID: " + kit.getId() + ") aktualisiert.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich aktualisiert.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht aktualisiert werden.");
		}
	}

	private void handleDeleteKit(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("id"));
		InventoryKit kit = kitDAO.getKitById(kitId);
		if (kitDAO.deleteKit(kitId)) {
			AdminLogService.log(adminUser.getUsername(), "DELETE_KIT",
					"Kit '" + (kit != null ? kit.getName() : "N/A") + "' (ID: " + kitId + ") gelöscht.");
			req.getSession().setAttribute("successMessage", "Kit erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Kit konnte nicht gelöscht werden.");
		}
	}

	private void handleAddItemToKit(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("kitId"));
		int itemId = Integer.parseInt(req.getParameter("itemId"));
		int quantity = Integer.parseInt(req.getParameter("quantity"));
		if (kitDAO.addItemToKit(kitId, itemId, quantity)) {
			AdminLogService.log(adminUser.getUsername(), "ADD_ITEM_TO_KIT",
					quantity + "x Item ID " + itemId + " zu Kit ID " + kitId + " hinzugefügt.");
			req.getSession().setAttribute("successMessage", "Artikel zum Kit hinzugefügt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Artikel konnte nicht zum Kit hinzugefügt werden.");
		}
	}

	private void handleRemoveItemFromKit(HttpServletRequest req, User adminUser) {
		int kitId = Integer.parseInt(req.getParameter("kitId"));
		int itemId = Integer.parseInt(req.getParameter("itemId"));
		if (kitDAO.removeItemFromKit(kitId, itemId)) {
			AdminLogService.log(adminUser.getUsername(), "REMOVE_ITEM_FROM_KIT",
					"Item ID " + itemId + " aus Kit ID " + kitId + " entfernt.");
			req.getSession().setAttribute("successMessage", "Artikel aus Kit entfernt.");
		} else {
			req.getSession().setAttribute("errorMessage", "Artikel konnte nicht aus Kit entfernt werden.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminLogServlet.java
========================================================================

package de.technikteam.servlet.admin;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.AdminLogDAO;
import de.technikteam.model.AdminLog;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/admin/log`, this servlet retrieves all entries from the
 * administrative action log using the `AdminLogDAO`. It then passes the
 * complete list of logs to `admin_log.jsp` for display and filtering on the
 * client side.
 */
@WebServlet("/admin/log")
public class AdminLogServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminLogServlet.class);
	private AdminLogDAO adminLogDAO;

	@Override
	public void init() {
		adminLogDAO = new AdminLogDAO();
		logger.info("AdminLogServlet has been initialized.");
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		logger.info("Admin log page requested by user '{}'.", adminUser.getUsername());
		try {
			List<AdminLog> logs = adminLogDAO.getAllLogs();
			request.setAttribute("logs", logs);
			logger.info("Fetched {} log entries. Forwarding to JSP.", logs.size());
			// CORRECTED: Forward to the actual JSP file path.
			request.getRequestDispatcher("/views/admin/admin_log.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("A critical error occurred in AdminLogServlet doGet()", e);
			// Redirect to a generic error page to avoid exposing stack traces to the user
			response.sendRedirect(request.getContextPath() + "/error500");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminMeetingServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.config.AppConfig;
import de.technikteam.config.LocalDateAdapter;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttachmentDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttachment;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.List;

@WebServlet("/admin/meetings")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 20, maxRequestSize = 1024 * 1024 * 50)
public class AdminMeetingServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminMeetingServlet.class);
	private MeetingDAO meetingDAO;
	private CourseDAO courseDAO;
	private MeetingAttachmentDAO attachmentDAO;
	private UserDAO userDAO;
	private Gson gson;

	@Override
	public void init() {
		meetingDAO = new MeetingDAO();
		courseDAO = new CourseDAO();
		attachmentDAO = new MeetingAttachmentDAO();
		userDAO = new UserDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.registerTypeAdapter(java.time.LocalDate.class, new LocalDateAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String action = req.getParameter("action");
		if ("getMeetingData".equals(action)) {
			getMeetingDataAsJson(req, resp);
		} else {
			listMeetings(req, resp);
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException, ServletException {
		req.setCharacterEncoding("UTF-8");
		String action;

		if (req.getContentType() != null && req.getContentType().toLowerCase().startsWith("multipart/")) {
			action = ServletUtils.getPartValue(req.getPart("action"));
		} else {
			action = req.getParameter("action");
		}

		logger.debug("AdminMeetingServlet received POST with action: {}", action);

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(req, resp);
			break;
		case "delete":
			handleDelete(req, resp);
			break;
		case "deleteAttachment":
			handleDeleteAttachment(req, resp);
			break;
		default:
			logger.warn("Unknown action received in doPost: {}", action);
			resp.sendRedirect(req.getContextPath() + "/admin/meetings");
			break;
		}
	}

	private void listMeetings(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.info("Listing all meetings for course ID: {}", courseId);
		Course parentCourse = courseDAO.getCourseById(courseId);
		List<Meeting> meetings = meetingDAO.getMeetingsForCourse(courseId);
		List<User> allUsers = userDAO.getAllUsers();

		req.setAttribute("parentCourse", parentCourse);
		req.setAttribute("meetings", meetings);
		req.setAttribute("allUsers", allUsers);

		// CORRECTED: Forward to the actual JSP file path.
		req.getRequestDispatcher("/views/admin/admin_meeting_list.jsp").forward(req, resp);
	}

	private void getMeetingDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int meetingId = Integer.parseInt(req.getParameter("id"));
			Meeting meeting = meetingDAO.getMeetingById(meetingId);
			if (meeting != null) {
				List<MeetingAttachment> attachments = attachmentDAO.getAttachmentsForMeeting(meetingId, "ADMIN");
				// Create a wrapper object to send both meeting and attachments
				var responseData = new Object() {
					final Meeting meetingData = meeting;
					final List<MeetingAttachment> attachmentsData = attachments;
				};
				String jsonResponse = gson.toJson(responseData);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(jsonResponse);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Meeting nicht gefunden");
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid ID for getting meeting data as JSON", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Ungültige Meeting-ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest req, HttpServletResponse resp)
			throws IOException, ServletException {
		User adminUser = (User) req.getSession().getAttribute("user");
		String action = ServletUtils.getPartValue(req.getPart("action"));
		boolean isUpdate = "update".equals(action);
		int courseId = Integer.parseInt(ServletUtils.getPartValue(req.getPart("courseId")));
		int meetingId = 0;

		try {
			Meeting meeting = new Meeting();
			meeting.setCourseId(courseId);
			meeting.setName(ServletUtils.getPartValue(req.getPart("name")));
			meeting.setDescription(ServletUtils.getPartValue(req.getPart("description")));
			meeting.setLocation(ServletUtils.getPartValue(req.getPart("location")));

			String leaderIdStr = ServletUtils.getPartValue(req.getPart("leaderUserId"));
			if (leaderIdStr != null && !leaderIdStr.isEmpty()) {
				meeting.setLeaderUserId(Integer.parseInt(leaderIdStr));
			}

			String startDateTimeStr = ServletUtils.getPartValue(req.getPart("meetingDateTime"));
			if (startDateTimeStr != null && !startDateTimeStr.isEmpty()) {
				meeting.setMeetingDateTime(LocalDateTime.parse(startDateTimeStr));
			}
			String endDateTimeStr = ServletUtils.getPartValue(req.getPart("endDateTime"));
			if (endDateTimeStr != null && !endDateTimeStr.isEmpty()) {
				meeting.setEndDateTime(LocalDateTime.parse(endDateTimeStr));
			}

			Course parentCourse = courseDAO.getCourseById(courseId);
			String parentCourseName = (parentCourse != null) ? parentCourse.getName() : "N/A";

			if (isUpdate) {
				meetingId = Integer.parseInt(ServletUtils.getPartValue(req.getPart("id")));
				meeting.setId(meetingId);
				if (meetingDAO.updateMeeting(meeting)) {
					AdminLogService.log(adminUser.getUsername(), "UPDATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' aktualisiert.");
					req.getSession().setAttribute("successMessage", "Meeting erfolgreich aktualisiert.");
				}
			} else { // CREATE
				meetingId = meetingDAO.createMeeting(meeting);
				if (meetingId > 0) {
					AdminLogService.log(adminUser.getUsername(), "CREATE_MEETING", "Meeting '" + meeting.getName()
							+ "' (ID: " + meetingId + ") für Lehrgang '" + parentCourseName + "' geplant.");
					req.getSession().setAttribute("successMessage", "Neues Meeting erfolgreich geplant.");
				}
			}

			Part filePart = req.getPart("attachment");
			if (filePart != null && filePart.getSize() > 0 && meetingId > 0) {
				String requiredRole = ServletUtils.getPartValue(req.getPart("requiredRole"));
				handleAttachmentUpload(filePart, meetingId, requiredRole, adminUser, req);
			}

		} catch (DateTimeParseException | NumberFormatException e) {
			logger.error("Invalid data format in meeting form.", e);
			req.getSession().setAttribute("errorMessage", "Ungültiges Datenformat.");
		} catch (Exception e) {
			logger.error("Error creating/updating meeting.", e);
			req.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		int meetingId = Integer.parseInt(req.getParameter("meetingId"));
		User adminUser = (User) req.getSession().getAttribute("user");
		logger.warn("Attempting to delete meeting ID {} from course ID {}", meetingId, courseId);

		Meeting meeting = meetingDAO.getMeetingById(meetingId);
		if (meetingDAO.deleteMeeting(meetingId)) {
			String meetingName = (meeting != null) ? meeting.getName() : "N/A";
			String courseName = (meeting != null && meeting.getParentCourseName() != null)
					? meeting.getParentCourseName()
					: "N/A";
			String logDetails = String.format("Meeting '%s' (ID: %d) vom Lehrgang '%s' (Kurs-ID: %d) wurde gelöscht.",
					meetingName, meetingId, courseName, courseId);
			AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING", logDetails);
			req.getSession().setAttribute("successMessage", "Meeting erfolgreich gelöscht.");
		} else {
			req.getSession().setAttribute("errorMessage", "Meeting konnte nicht gelöscht werden.");
		}

		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleDeleteAttachment(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		int attachmentId = Integer.parseInt(req.getParameter("attachmentId"));
		int courseId = Integer.parseInt(req.getParameter("courseId"));
		logger.warn("Attempting to delete attachment ID {}", attachmentId);

		MeetingAttachment attachment = attachmentDAO.getAttachmentById(attachmentId);
		if (attachment != null) {
			File physicalFile = new File(AppConfig.UPLOAD_DIRECTORY, attachment.getFilepath());

			if (physicalFile.exists()) {
				physicalFile.delete();
			}

			if (attachmentDAO.deleteAttachment(attachmentId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_MEETING_ATTACHMENT", "Anhang '"
						+ attachment.getFilename() + "' von Meeting ID " + attachment.getMeetingId() + " gelöscht.");
				req.getSession().setAttribute("successMessage", "Anhang gelöscht.");
			} else {
				req.getSession().setAttribute("errorMessage", "Anhang konnte nicht aus DB gelöscht werden.");
			}
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang nicht gefunden.");
		}
		resp.sendRedirect(req.getContextPath() + "/admin/meetings?courseId=" + courseId);
	}

	private void handleAttachmentUpload(Part filePart, int meetingId, String requiredRole, User adminUser,
			HttpServletRequest req) throws IOException {
		String uploadDir = AppConfig.UPLOAD_DIRECTORY + File.separator + "meetings";
		new File(uploadDir).mkdirs();

		String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
		File targetFile = new File(uploadDir, fileName);
		filePart.write(targetFile.getAbsolutePath());

		MeetingAttachment attachment = new MeetingAttachment();
		attachment.setMeetingId(meetingId);
		attachment.setFilename(fileName);
		// Always use forward slashes for URL paths
		attachment.setFilepath("meetings/" + fileName);
		attachment.setRequiredRole(requiredRole);
		if (attachmentDAO.addAttachment(attachment)) {
			logger.info("Attachment '{}' uploaded for meeting ID {} by '{}'", fileName, meetingId,
					adminUser.getUsername());
			String logDetails = String.format("Anhang '%s' zu Meeting ID %d hinzugefügt. Sichtbar für: %s.", fileName,
					meetingId, requiredRole);
			AdminLogService.log(adminUser.getUsername(), "ADD_MEETING_ATTACHMENT", logDetails);
		} else {
			req.getSession().setAttribute("errorMessage", "Anhang konnte nicht in DB gespeichert werden.");
		}
	}

}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminReportServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.dao.ReportDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@WebServlet("/admin/berichte")
public class AdminReportServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminReportServlet.class);
	private ReportDAO reportDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		reportDAO = new ReportDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String reportType = request.getParameter("report");
		String exportType = request.getParameter("export");

		if (reportType != null && !reportType.isEmpty()) {
			handleSpecificReport(request, response, reportType, exportType);
			return;
		}

		logger.debug("Serving main reports dashboard.");

		// Fetch data for dashboard charts
		List<Map<String, Object>> eventTrendData = reportDAO.getEventCountByMonth(12);
		List<Map<String, Object>> userActivityData = reportDAO.getUserParticipationStats(10);

		request.setAttribute("eventTrendDataJson", gson.toJson(eventTrendData));
		request.setAttribute("userActivityDataJson", gson.toJson(userActivityData));

		request.setAttribute("totalInventoryValue", reportDAO.getTotalInventoryValue());
		request.getRequestDispatcher("/views/admin/admin_reports.jsp").forward(request, response);
	}

	private void handleSpecificReport(HttpServletRequest request, HttpServletResponse response, String reportType,
			String exportType) throws IOException, ServletException {
		List<Map<String, Object>> reportData = null;
		String reportTitle = "";
		String jspPath = "/views/admin/report_display.jsp";

		switch (reportType) {
		case "user_activity":
			reportData = reportDAO.getUserActivityStats();
			reportTitle = "Benutzeraktivitäts-Bericht";
			break;
		case "event_participation":
			reportData = reportDAO.getEventParticipationSummary();
			reportTitle = "Event-Teilnahme-Bericht";
			break;
		case "inventory_usage":
			reportData = reportDAO.getInventoryUsageFrequency();
			reportTitle = "Lagernutzungs-Bericht";
			break;
		default:
			logger.warn("Unknown report type requested: {}", reportType);
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Unbekannter Berichtstyp.");
			return;
		}

		if ("csv".equalsIgnoreCase(exportType)) {
			logger.info("Exporting report '{}' to CSV.", reportType);
			exportToCsv(response, reportData, reportType + "_report.csv");
		} else {
			logger.debug("Forwarding data for report '{}' to JSP.", reportType);
			request.setAttribute("reportData", reportData);
			request.setAttribute("reportTitle", reportTitle);
			request.getRequestDispatcher(jspPath).forward(request, response);
		}
	}

	private void exportToCsv(HttpServletResponse response, List<Map<String, Object>> data, String filename)
			throws IOException {
		response.setContentType("text/csv");
		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Disposition", "attachment; filename=\"" + filename + "\"");

		if (data == null || data.isEmpty()) {
			response.getWriter().write("No data available to export.");
			return;
		}

		try (PrintWriter writer = response.getWriter()) {
			// Write header
			String header = String.join(",", data.get(0).keySet());
			writer.println(header);

			// Write data rows
			for (Map<String, Object> row : data) {
				String line = row.values().stream().map(this::escapeCsvField).collect(Collectors.joining(","));
				writer.println(line);
			}
		}
	}

	private String escapeCsvField(Object field) {
		if (field == null) {
			return "";
		}
		String fieldStr = field.toString();
		if (fieldStr.contains(",") || fieldStr.contains("\"") || fieldStr.contains("\n")) {
			return "\"" + fieldStr.replace("\"", "\"\"") + "\"";
		}
		return fieldStr;
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminStorageServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import de.technikteam.config.AppConfig;
import de.technikteam.dao.MaintenanceLogDAO;
import de.technikteam.dao.StorageDAO;
import de.technikteam.model.MaintenanceLogEntry;
import de.technikteam.model.StorageItem;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import de.technikteam.util.ServletUtils;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.MultipartConfig;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.Part;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

@WebServlet("/admin/lager")
@MultipartConfig(fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 10)
public class AdminStorageServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminStorageServlet.class.getName());
	private StorageDAO storageDAO;
	private MaintenanceLogDAO maintenanceLogDAO;
	private Gson gson = new Gson();

	@Override
	public void init() {
		storageDAO = new StorageDAO();
		maintenanceLogDAO = new MaintenanceLogDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action");
		if ("getItemData".equals(action)) {
			getItemDataAsJson(request, response);
			return;
		}

		try {
			logger.info("Listing all storage items for admin view.");
			List<StorageItem> storageList = storageDAO.getAllItems();
			request.setAttribute("storageList", storageList);
			request.getRequestDispatcher("/views/admin/admin_storage_list.jsp").forward(request, response);
		} catch (Exception e) {
			logger.error("Error in doGet of AdminStorageServlet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		request.setCharacterEncoding("UTF-8");
		String contentType = request.getContentType();
		String action;

		if (contentType != null && contentType.toLowerCase().startsWith("multipart/")) {
			action = ServletUtils.getPartValue(request.getPart("action"));
		} else {
			action = request.getParameter("action");
		}

		switch (action) {
		case "create":
		case "update":
			handleCreateOrUpdate(request, response);
			break;
		case "delete":
			handleDelete(request, response);
			break;
		case "updateDefect":
			handleDefectUpdate(request, response);
			break;
		case "updateStatus":
			handleStatusUpdate(request, response);
			break;
		default:
			response.sendRedirect(request.getContextPath() + "/admin/lager");
			break;
		}
	}

	private void handleStatusUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			String newStatus = request.getParameter("status");
			String notes = request.getParameter("notes");

			storageDAO.updateItemStatus(itemId, newStatus);

			MaintenanceLogEntry log = new MaintenanceLogEntry();
			log.setItemId(itemId);
			log.setUserId(adminUser.getId());
			log.setNotes(notes);

			String logAction;
			if ("MAINTENANCE".equals(newStatus)) {
				logAction = "Marked for Maintenance";
			} else {
				logAction = "Returned to Service";
			}
			log.setAction(logAction);

			maintenanceLogDAO.createLog(log);
			AdminLogService.log(adminUser.getUsername(), "UPDATE_ITEM_STATUS",
					"Status für Artikel-ID " + itemId + " auf '" + newStatus + "' gesetzt. Notiz: " + notes);
			request.getSession().setAttribute("successMessage", "Artikelstatus erfolgreich aktualisiert.");
		} catch (Exception e) {
			logger.error("Error updating item status", e);
			request.getSession().setAttribute("errorMessage", "Fehler beim Aktualisieren des Status.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void getItemDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int itemId = Integer.parseInt(req.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null) {
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(gson.toJson(item));
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "Item not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid item ID");
		}
	}

	private void handleCreateOrUpdate(HttpServletRequest request, HttpServletResponse response)
			throws IOException, ServletException {
		User adminUser = (User) request.getSession().getAttribute("user");
		boolean isCreate = "create".equals(ServletUtils.getPartValue(request.getPart("action")));

		try {
			StorageItem item = new StorageItem();
			item.setName(ServletUtils.getPartValue(request.getPart("name")));
			item.setLocation(ServletUtils.getPartValue(request.getPart("location")));
			item.setCabinet(ServletUtils.getPartValue(request.getPart("cabinet")));
			item.setCompartment(ServletUtils.getPartValue(request.getPart("compartment")));
			item.setQuantity(Integer.parseInt(ServletUtils.getPartValue(request.getPart("quantity"))));
			item.setMaxQuantity(Integer.parseInt(ServletUtils.getPartValue(request.getPart("maxQuantity"))));

			String weightStr = ServletUtils.getPartValue(request.getPart("weight_kg"));
			item.setWeightKg(
					weightStr == null || weightStr.isEmpty() ? 0.0 : Double.parseDouble(weightStr.replace(',', '.')));
			String priceStr = ServletUtils.getPartValue(request.getPart("price_eur"));
			item.setPriceEur(
					priceStr == null || priceStr.isEmpty() ? 0.0 : Double.parseDouble(priceStr.replace(',', '.')));

			Part filePart = request.getPart("imageFile");
			String imagePath = null;

			if (!isCreate) {
				int itemId = Integer.parseInt(ServletUtils.getPartValue(request.getPart("id")));
				item.setId(itemId);
				StorageItem originalItem = storageDAO.getItemById(itemId);
				if (originalItem != null) {
					imagePath = originalItem.getImagePath();
					item.setDefectiveQuantity(originalItem.getDefectiveQuantity());
					item.setDefectReason(originalItem.getDefectReason());
					item.setStatus(originalItem.getStatus());
				}
			}

			if (filePart != null && filePart.getSize() > 0) {
				String fileName = Paths.get(filePart.getSubmittedFileName()).getFileName().toString();
				if (!fileName.isEmpty()) {
					File imageUploadDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
					if (!imageUploadDir.exists())
						imageUploadDir.mkdirs();
					File targetFile = new File(imageUploadDir, fileName);
					filePart.write(targetFile.getAbsolutePath());
					imagePath = fileName;
				}
			}
			item.setImagePath(imagePath);

			boolean success = isCreate ? storageDAO.createItem(item) : storageDAO.updateItem(item);

			if (success) {
				String logDetails = String.format("Lagerartikel '%s' %s.", item.getName(),
						isCreate ? "erstellt" : "aktualisiert");
				AdminLogService.log(adminUser.getUsername(), isCreate ? "CREATE_STORAGE_ITEM" : "UPDATE_STORAGE_ITEM",
						logDetails);
				request.getSession().setAttribute("successMessage",
						"Artikel '" + item.getName() + "' erfolgreich gespeichert.");
			} else {
				request.getSession().setAttribute("errorMessage", "Operation am Artikel fehlgeschlagen.");
			}
		} catch (Exception e) {
			logger.error("Error creating/updating storage item.", e);
			request.getSession().setAttribute("errorMessage", "Fehler: " + e.getMessage());
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}

	private void handleDefectUpdate(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		String returnTo = request.getParameter("returnTo");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			int defectiveQty = Integer.parseInt(request.getParameter("defective_quantity"));
			String reason = request.getParameter("defect_reason");

			if (storageDAO.updateDefectiveStatus(itemId, defectiveQty, reason)) {
				AdminLogService.log(adminUser.getUsername(), "UPDATE_DEFECT_STATUS",
						String.format("Defekt-Status für Artikel-ID %d aktualisiert: %d defekt. Grund: %s", itemId,
								defectiveQty, reason));
				request.getSession().setAttribute("successMessage", "Defekt-Status aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Defekt-Status konnte nicht aktualisiert werden (vielleicht nicht genug Bestand?).");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID oder Anzahl.");
		} catch (SQLException e) {
			request.getSession().setAttribute("errorMessage", "Datenbankfehler: " + e.getMessage());
		}

		String redirectUrl = request.getContextPath()
				+ ("/defekte".equals(returnTo) ? "/admin/defekte" : "/admin/lager");
		response.sendRedirect(redirectUrl);
	}

	private void handleDelete(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int itemId = Integer.parseInt(request.getParameter("id"));
			StorageItem item = storageDAO.getItemById(itemId);
			if (item != null && item.getImagePath() != null && !item.getImagePath().isEmpty()) {
				File imageDir = new File(AppConfig.UPLOAD_DIRECTORY, "images");
				File imageFile = new File(imageDir, item.getImagePath());
				if (imageFile.exists() && !imageFile.delete()) {
					logger.warn("Could not delete physical image file: {}", imageFile.getAbsolutePath());
				}
			}
			if (storageDAO.deleteItem(itemId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_STORAGE_ITEM", String.format(
						"Lagerartikel '%s' (ID: %d) gelöscht.", (item != null ? item.getName() : "N/A"), itemId));
				request.getSession().setAttribute("successMessage", "Artikel erfolgreich gelöscht.");
			} else {
				request.getSession().setAttribute("errorMessage", "Artikel konnte nicht gelöscht werden.");
			}
		} catch (NumberFormatException e) {
			request.getSession().setAttribute("errorMessage", "Ungültige Artikel-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/lager");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminSystemServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Forwards to the system status dashboard page.
 */
@WebServlet("/admin/system")
public class AdminSystemServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// CORRECTED: Forward to the actual JSP file path.
		request.getRequestDispatcher("/views/admin/admin_system.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminTaskServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.EventTaskDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.EventTask;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/tasks`, this servlet manages administrative actions for
 * event tasks. It handles POST requests for creating and assigning tasks, and
 * DELETE requests for removing them. All actions are logged to the admin audit
 * trail. It's designed to be called via forms or AJAX from the event details
 * page.
 */
@WebServlet("/admin/tasks")
public class AdminTaskServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminTaskServlet.class);
	private EventTaskDAO taskDAO;
	private UserDAO userDAO;

	@Override
	public void init() {
		taskDAO = new EventTaskDAO();
		userDAO = new UserDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		logger.debug("AdminTaskServlet received POST with action: {}", action);

		switch (action) {
		case "create":
			handleCreateTask(request, response);
			break;
		case "assign":
			handleAssignTask(request, response);
			break;
		default:
			logger.warn("Unknown POST action received: {}", action);
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Unknown action");
			break;
		}
	}

	private void handleCreateTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		String description = request.getParameter("description");
		logger.info("Creating new task '{}' for event ID {}", description, eventId);

		EventTask newTask = new EventTask();
		newTask.setEventId(eventId);
		newTask.setDescription(description);

		int newTaskId = taskDAO.createTask(newTask);
		if (newTaskId > 0) {
			AdminLogService.log(adminUser.getUsername(), "CREATE_TASK",
					"Aufgabe '" + description + "' (ID: " + newTaskId + ") für Event-ID " + eventId + " erstellt.");
		}
		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	private void handleAssignTask(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		int eventId = Integer.parseInt(request.getParameter("eventId"));
		int taskId = Integer.parseInt(request.getParameter("taskId"));
		String[] userIdsStr = request.getParameterValues("userIds");
		int[] userIds = userIdsStr == null ? new int[0]
				: Arrays.stream(userIdsStr).mapToInt(Integer::parseInt).toArray();

		logger.info("Assigning task ID {} to {} users for event ID {}", taskId, userIds.length, eventId);
		taskDAO.assignTaskToUsers(taskId, userIds);

		String assignedUsersString;
		if (userIds.length > 0) {
			List<String> usernames = new ArrayList<>();
			for (int userId : userIds) {
				User u = userDAO.getUserById(userId);
				if (u != null) {
					usernames.add(u.getUsername());
				} else {
					usernames.add("ID:" + userId);
				}
			}
			assignedUsersString = String.join(", ", usernames);
		} else {
			assignedUsersString = "niemandem";
		}

		AdminLogService.log(adminUser.getUsername(), "ASSIGN_TASK",
				"Aufgabe (ID: " + taskId + ") für Event-ID " + eventId + " an " + assignedUsersString + " zugewiesen.");

		response.sendRedirect(request.getContextPath() + "/veranstaltungen/details?id=" + eventId);
	}

	@Override
	protected void doDelete(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		User adminUser = (User) req.getSession().getAttribute("user");
		try {
			int taskId = Integer.parseInt(req.getParameter("taskId"));
			logger.warn("Attempting to delete task ID {} by user '{}'", taskId, adminUser.getUsername());
			if (taskDAO.deleteTask(taskId)) {
				AdminLogService.log(adminUser.getUsername(), "DELETE_TASK", "Aufgabe mit ID " + taskId + " gelöscht.");
				resp.setStatus(HttpServletResponse.SC_OK);
			} else {
				resp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid task ID format for deletion.", e);
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid task ID.");
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\AdminUserServlet.java
========================================================================

package de.technikteam.servlet.admin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.RoleDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Role;
import de.technikteam.model.User;
import de.technikteam.service.AdminLogService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

// CORRECTED: The servlet is now mapped to /admin/mitglieder as requested.
@WebServlet("/admin/mitglieder")
public class AdminUserServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(AdminUserServlet.class);

	private UserDAO userDAO;
	private EventDAO eventDAO;
	private RoleDAO roleDAO;
	private Gson gson;

	@Override
	public void init() {
		userDAO = new UserDAO();
		eventDAO = new EventDAO();
		roleDAO = new RoleDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		String action = request.getParameter("action") == null ? "list" : request.getParameter("action");
		logger.debug("AdminUserServlet received GET with action: {}", action);
		try {
			switch (action) {
			case "details":
				showUserDetails(request, response);
				break;
			case "getUserData":
				getUserDataAsJson(request, response);
				break;
			default:
				listUsers(request, response);
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doGet", e);
			request.getSession().setAttribute("errorMessage", "Ein Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/dashboard");
		}
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException {
		request.setCharacterEncoding("UTF-8");
		String action = request.getParameter("action");
		if (action == null) {
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		try {
			switch (action) {
			case "create":
				handleCreateUser(request, response);
				break;
			case "update":
				handleUpdateUser(request, response);
				break;
			case "delete":
				handleDeleteUser(request, response);
				break;
			case "resetPassword":
				handleResetPassword(request, response);
				break;
			default:
				logger.warn("Unknown POST action received: {}", action);
				response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
				break;
			}
		} catch (Exception e) {
			logger.error("Error in AdminUserServlet doPost", e);
			request.getSession().setAttribute("errorMessage",
					"Ein schwerwiegender Fehler ist aufgetreten: " + e.getMessage());
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
		}
	}

	private void listUsers(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.info("Executing listUsers method.");
		List<User> userList = userDAO.getAllUsers();
		List<Role> allRoles = roleDAO.getAllRoles();
		logger.debug("Fetched {} users and {} roles from DAOs.", userList.size(), allRoles.size());
		request.setAttribute("userList", userList);
		request.setAttribute("allRoles", allRoles);
		request.getRequestDispatcher("/views/admin/admin_users.jsp").forward(request, response);
	}

	private void getUserDataAsJson(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		try {
			int userId = Integer.parseInt(req.getParameter("id"));
			User user = userDAO.getUserById(userId);
			if (user != null) {
				String userJson = gson.toJson(user);
				resp.setContentType("application/json");
				resp.setCharacterEncoding("UTF-8");
				resp.getWriter().write(userJson);
			} else {
				resp.sendError(HttpServletResponse.SC_NOT_FOUND, "User not found");
			}
		} catch (NumberFormatException e) {
			resp.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid User ID");
		}
	}

	private void showUserDetails(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		int userId = Integer.parseInt(request.getParameter("id"));
		User user = userDAO.getUserById(userId);
		if (user == null) {
			request.getSession().setAttribute("errorMessage", "Benutzer nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		List<Event> eventHistory = eventDAO.getEventHistoryForUser(userId);
		request.setAttribute("userToView", user);
		request.setAttribute("eventHistory", eventHistory);
		request.getRequestDispatcher("/views/admin/admin_user_details.jsp").forward(request, response);
	}

	private void handleCreateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		String username = request.getParameter("username");
		String pass = request.getParameter("password");
		if (username == null || username.trim().isEmpty() || pass == null || pass.trim().isEmpty()) {
			request.getSession().setAttribute("errorMessage", "Benutzername und Passwort dürfen nicht leer sein.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		int roleId = Integer.parseInt(request.getParameter("roleId"));

		User newUser = new User();
		newUser.setUsername(username.trim());
		newUser.setRoleId(roleId);
		try {
			newUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			newUser.setClassYear(0);
		}
		newUser.setClassName(request.getParameter("className"));
		newUser.setEmail(request.getParameter("email"));

		int newUserId = userDAO.createUser(newUser, pass);
		if (newUserId > 0) {
			User adminUser = (User) request.getSession().getAttribute("user");
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle-ID: %d, Klasse: %d %s) erstellt.",
					newUser.getUsername(), newUserId, newUser.getRoleId(), newUser.getClassYear(),
					newUser.getClassName());
			AdminLogService.log(adminUser.getUsername(), "CREATE_USER", logDetails);
			request.getSession().setAttribute("successMessage",
					"Benutzer '" + newUser.getUsername() + "' erfolgreich erstellt.");
		} else {
			request.getSession().setAttribute("errorMessage",
					"Benutzer konnte nicht erstellt werden (ggf. existiert der Name oder die E-Mail bereits).");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleUpdateUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userId = Integer.parseInt(request.getParameter("userId"));
		HttpSession session = request.getSession();
		User adminUser = (User) session.getAttribute("user");
		User originalUser = userDAO.getUserById(userId);

		if (originalUser == null) {
			logger.error("Attempted to update non-existent user with ID: {}", userId);
			request.getSession().setAttribute("errorMessage", "Fehler: Benutzer mit ID " + userId + " nicht gefunden.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		int roleId = Integer.parseInt(request.getParameter("roleId"));

		User updatedUser = new User();
		updatedUser.setId(userId);
		updatedUser.setUsername(request.getParameter("username").trim());
		updatedUser.setRoleId(roleId);
		updatedUser.setClassName(request.getParameter("className"));
		updatedUser.setEmail(request.getParameter("email"));
		try {
			updatedUser.setClassYear(Integer.parseInt(request.getParameter("classYear")));
		} catch (NumberFormatException e) {
			updatedUser.setClassYear(0);
		}

		List<String> changes = new ArrayList<>();
		if (!Objects.equals(originalUser.getUsername(), updatedUser.getUsername()))
			changes.add("Benutzername von '" + originalUser.getUsername() + "' zu '" + updatedUser.getUsername() + "'");
		if (originalUser.getRoleId() != updatedUser.getRoleId())
			changes.add("Rolle-ID von '" + originalUser.getRoleId() + "' zu '" + updatedUser.getRoleId() + "'");
		if (originalUser.getClassYear() != updatedUser.getClassYear())
			changes.add("Jahrgang von '" + originalUser.getClassYear() + "' zu '" + updatedUser.getClassYear() + "'");
		if (!Objects.equals(originalUser.getClassName(), updatedUser.getClassName()))
			changes.add("Klasse von '" + originalUser.getClassName() + "' zu '" + updatedUser.getClassName() + "'");
		if (!Objects.equals(originalUser.getEmail(), updatedUser.getEmail()))
			changes.add("E-Mail geändert");

		if (!changes.isEmpty()) {
			if (userDAO.updateUser(updatedUser)) {
				if (adminUser.getId() == userId) {
					User refreshedUserInSession = userDAO.getUserById(userId);
					Set<String> newPermissions = userDAO.getPermissionsForRole(refreshedUserInSession.getRoleId());
					refreshedUserInSession.setPermissions(newPermissions);
					session.setAttribute("user", refreshedUserInSession);
				}
				String logDetails = String.format("Benutzer '%s' (ID: %d) aktualisiert. Änderungen: %s.",
						originalUser.getUsername(), userId, String.join(", ", changes));
				AdminLogService.log(adminUser.getUsername(), "UPDATE_USER", logDetails);
				request.getSession().setAttribute("successMessage", "Benutzerdaten erfolgreich aktualisiert.");
			} else {
				request.getSession().setAttribute("errorMessage",
						"Fehler: Benutzerdaten konnten nicht in der DB aktualisiert werden.");
			}
		} else {
			request.getSession().setAttribute("infoMessage", "Keine Änderungen an den Benutzerdaten vorgenommen.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleDeleteUser(HttpServletRequest request, HttpServletResponse response) throws IOException {
		int userIdToDelete = Integer.parseInt(request.getParameter("userId"));
		User loggedInAdmin = (User) request.getSession().getAttribute("user");
		if (loggedInAdmin.getId() == userIdToDelete) {
			request.getSession().setAttribute("errorMessage", "Sie können sich nicht selbst löschen.");
			response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
			return;
		}
		User userToDelete = userDAO.getUserById(userIdToDelete);
		if (userDAO.deleteUser(userIdToDelete)) {
			String logDetails = String.format("Benutzer '%s' (ID: %d, Rolle: %s) wurde gelöscht.",
					(userToDelete != null ? userToDelete.getUsername() : "N/A"), userIdToDelete,
					(userToDelete != null ? userToDelete.getRoleName() : "N/A"));
			AdminLogService.log(loggedInAdmin.getUsername(), "DELETE_USER", logDetails);
			request.getSession().setAttribute("successMessage", "Benutzer erfolgreich gelöscht.");
		} else {
			request.getSession().setAttribute("errorMessage", "Benutzer konnte nicht gelöscht werden.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private void handleResetPassword(HttpServletRequest request, HttpServletResponse response) throws IOException {
		User adminUser = (User) request.getSession().getAttribute("user");
		try {
			int userId = Integer.parseInt(request.getParameter("userId"));
			User userToReset = userDAO.getUserById(userId);

			if (userToReset == null) {
				request.getSession().setAttribute("errorMessage", "Benutzer zum Zurücksetzen nicht gefunden.");
			} else {
				String newPassword = generateRandomPassword(8);
				if (userDAO.changePassword(userId, newPassword)) {
					String logDetails = String.format("Passwort für Benutzer '%s' (ID: %d) zurückgesetzt.",
							userToReset.getUsername(), userId);
					AdminLogService.log(adminUser.getUsername(), "RESET_PASSWORD", logDetails);
					String successMessage = String.format(
							"Passwort für '%s' wurde zurückgesetzt auf: <strong class=\"copyable-password\">%s</strong> (wurde in die Zwischenablage kopiert).",
							userToReset.getUsername(), newPassword);
					request.getSession().setAttribute("passwordResetInfo", successMessage);
				} else {
					request.getSession().setAttribute("errorMessage", "Passwort konnte nicht zurückgesetzt werden.");
				}
			}
		} catch (NumberFormatException e) {
			logger.error("Invalid user ID for password reset.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Benutzer-ID.");
		}
		response.sendRedirect(request.getContextPath() + "/admin/mitglieder");
	}

	private String generateRandomPassword(int length) {
		final String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		SecureRandom random = new SecureRandom();
		StringBuilder sb = new StringBuilder(length);
		for (int i = 0; i < length; i++) {
			sb.append(chars.charAt(random.nextInt(chars.length())));
		}
		return sb.toString();
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\MatrixServlet.java
========================================================================

package de.technikteam.servlet.admin;

import de.technikteam.dao.CourseDAO;
import de.technikteam.dao.MeetingAttendanceDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.dao.UserDAO;
import de.technikteam.model.Course;
import de.technikteam.model.Meeting;
import de.technikteam.model.MeetingAttendance;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Mapped to `/admin/matrix`, this servlet constructs the data for the
 * comprehensive qualification and attendance matrix. It fetches all users, all
 * course templates, all meetings for each course, and all attendance records.
 * It then organizes this data and forwards it to `admin_matrix.jsp` for
 * rendering a grid view that shows which users have attended which course
 * meetings.
 */
@WebServlet("/admin/matrix")
public class MatrixServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(MatrixServlet.class);
	private UserDAO userDAO;
	private CourseDAO courseDAO;
	private MeetingDAO meetingDAO;
	private MeetingAttendanceDAO meetingAttendanceDAO;

	@Override
	public void init() {
		userDAO = new UserDAO();
		courseDAO = new CourseDAO();
		meetingDAO = new MeetingDAO();
		meetingAttendanceDAO = new MeetingAttendanceDAO();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		logger.info("Matrix data requested. Fetching all necessary data from DAOs.");

		// 1. Fetch all users who will be rows in the matrix
		List<User> allUsers = userDAO.getAllUsers();
		logger.debug("Fetched {} users.", allUsers.size());

		// 2. Fetch all parent courses which define the top-level columns
		List<Course> allCourses = courseDAO.getAllCourses();
		logger.debug("Fetched {} parent courses.", allCourses.size());

		// 3. For each course, fetch its scheduled meetings to create sub-columns
		Map<Integer, List<Meeting>> meetingsByCourse = new HashMap<>();
		for (Course course : allCourses) {
			List<Meeting> meetings = meetingDAO.getMeetingsForCourse(course.getId());
			meetingsByCourse.put(course.getId(), meetings);
			logger.trace("Fetched {} meetings for course '{}' (ID: {}).", meetings.size(), course.getName(),
					course.getId());
		}

		// 4. Fetch all attendance records and put them in a map for quick lookup.
		// The key is a "userId-meetingId" string.
		Map<String, MeetingAttendance> attendanceMap = meetingAttendanceDAO.getAllAttendance().stream()
				.collect(Collectors.toMap(a -> a.getUserId() + "-" + a.getMeetingId(), Function.identity()));
		logger.debug("Fetched and mapped {} total attendance records.", attendanceMap.size());

		// 5. Set all data as request attributes for the JSP
		request.setAttribute("allUsers", allUsers);
		request.setAttribute("allCourses", allCourses);
		request.setAttribute("meetingsByCourse", meetingsByCourse);
		request.setAttribute("attendanceMap", attendanceMap);

		logger.info("Data generation for matrix complete. Forwarding to admin_matrix.jsp.");
		// CORRECTED: Forward to the actual JSP file path.
		request.getRequestDispatcher("/views/admin/admin_matrix.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\admin\ResourceCalendarServlet.java
========================================================================

package de.technikteam.servlet.admin;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Mapped to /admin/resource-calendar, this servlet's sole purpose is to forward
 * the request to the JSP page that will render the resource timeline view. The
 * actual event data is fetched by the calendar's JavaScript from the
 * ResourceCalendarApiServlet.
 */
@WebServlet("/admin/resource-calendar")
public class ResourceCalendarServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.getRequestDispatcher("/views/admin/resource_calendar.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\ResourceCalendarApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

@WebServlet("/api/admin/resource-calendar")
public class ResourceCalendarApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
				.setPrettyPrinting().create();
	}

	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		// FullCalendar sends start and end parameters
		String startParam = req.getParameter("start");
		String endParam = req.getParameter("end");

		// We can parse them to optimize the DB query
		LocalDate start = LocalDate.parse(startParam.substring(0, 10));
		LocalDate end = LocalDate.parse(endParam.substring(0, 10));

		List<Map<String, Object>> reservations = eventDAO.getReservationsForCalendar(start, end);

		Set<Map<String, Object>> resources = new HashSet<>();
		List<Map<String, Object>> events = new ArrayList<>();

		for (Map<String, Object> res : reservations) {
			// Add unique items to the resources set
			Map<String, Object> resource = new HashMap<>();
			resource.put("id", res.get("item_id").toString());
			resource.put("title", res.get("item_name").toString());
			resources.add(resource);

			// Create the calendar event
			Map<String, Object> event = new HashMap<>();
			event.put("resourceId", res.get("item_id").toString());
			event.put("title", res.get("event_name").toString());
			event.put("start", res.get("event_datetime").toString());
			event.put("end", res.get("end_datetime").toString());
			event.put("url", req.getContextPath() + "/veranstaltungen/details?id=" + res.get("event_id"));
			events.add(event);
		}

		Map<String, Object> responseData = new HashMap<>();
		responseData.put("resources", new ArrayList<>(resources));
		responseData.put("events", events);

		resp.setContentType("application/json");
		resp.setCharacterEncoding("UTF-8");
		resp.getWriter().write(gson.toJson(responseData));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\api\SystemStatsApiServlet.java
========================================================================

package de.technikteam.servlet.api;

import com.google.gson.Gson;
import de.technikteam.model.SystemStatsDTO;
import de.technikteam.service.SystemInfoService;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Provides system statistics as a JSON API endpoint. This servlet is protected
 * by the AdminFilter.
 */
@WebServlet("/api/admin/system-stats")
public class SystemStatsApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private SystemInfoService systemInfoService;
	private Gson gson;

	@Override
	public void init() throws ServletException {
		systemInfoService = new SystemInfoService();
		gson = new Gson();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		SystemStatsDTO stats = systemInfoService.getSystemStats();
		String jsonResponse = gson.toJson(stats);

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(jsonResponse);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventDAO;
import de.technikteam.dao.MeetingDAO;
import de.technikteam.model.Event;
import de.technikteam.model.Meeting;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@WebServlet("/api/calendar/entries")
public class CalendarApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private EventDAO eventDAO;
	private MeetingDAO meetingDAO;
	private Gson gson;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		meetingDAO = new MeetingDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		List<Map<String, String>> calendarEntries = new ArrayList<>();

		// Fetch events
		List<Event> events = eventDAO.getAllActiveAndUpcomingEvents();
		for (Event event : events) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", event.getName());
			entry.put("start", event.getEventDateTime().toString());
			if (event.getEndDateTime() != null) {
				entry.put("end", event.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/veranstaltungen/details?id=" + event.getId());
			entry.put("backgroundColor", "#dc3545"); // Danger color for events
			entry.put("borderColor", "#c82333");
			calendarEntries.add(entry);
		}

		// Fetch meetings
		List<Meeting> meetings = meetingDAO.getAllUpcomingMeetings();
		for (Meeting meeting : meetings) {
			Map<String, String> entry = new HashMap<>();
			entry.put("title", meeting.getParentCourseName() + ": " + meeting.getName());
			entry.put("start", meeting.getMeetingDateTime().toString());
			if (meeting.getEndDateTime() != null) {
				entry.put("end", meeting.getEndDateTime().toString());
			}
			entry.put("url", request.getContextPath() + "/meetingDetails?id=" + meeting.getId());
			entry.put("backgroundColor", "#007bff"); // Primary color for meetings
			entry.put("borderColor", "#0056b3");
			calendarEntries.add(entry);
		}

		response.setContentType("application/json");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(gson.toJson(calendarEntries));
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CalendarServlet.java
========================================================================

package de.technikteam.servlet;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * This servlet handles the request for the main calendar page. Its sole purpose
 * is to forward the user to the calendar.jsp page, which then uses JavaScript
 * to fetch data from the CalendarApiServlet.
 */
@WebServlet("/kalender")
public class CalendarServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * Forwards the request to the calendar display page.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// CORRECTED: Forward to the actual JSP file path.
		request.getRequestDispatcher("/views/public/calendar.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\CollaborativeEditorServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/editor-page`, this is a very simple servlet whose only purpose is
 * to forward the user to the `collaborative_editor.jsp` page. All the dynamic
 * functionality for the editor is handled client-side by JavaScript and the
 * `DocumentApiServlet`.
 */
@WebServlet("/editor-page")
public class CollaborativeEditorServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		// CORRECTED: Forward to the actual JSP file path. Note the original servlet
		// mapping was `/dateien/texte` but the JSP link uses `/editor-page`. I'll map
		// this to the JSP link.
		request.getRequestDispatcher("/views/public/collaborative_editor.jsp").forward(request, response);
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DocumentApiServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.stream.Collectors;

import de.technikteam.dao.FileDAO;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Mapped to `/api/document`, this servlet provides a simple REST-like API for
 * the collaborative text editor. A GET request fetches the latest document
 * content, while a POST request (with the new content in its raw body) updates
 * the document in the database. It interacts with `FileDAO` to persist the
 * content.
 */
@WebServlet("/api/document")
public class DocumentApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DocumentApiServlet.class);
	private FileDAO fileDAO;
	private static final String DOCUMENT_NAME = "realtime_notes";

	@Override
	public void init() {
		fileDAO = new FileDAO();
	}

	/**
	 * Handles GET requests to fetch the latest content of the shared document.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		logger.trace("GET request for document content '{}'", DOCUMENT_NAME);
		String content = fileDAO.getDocumentContent(DOCUMENT_NAME);

		response.setContentType("text/plain");
		response.setCharacterEncoding("UTF-8");
		response.getWriter().write(content);
	}

	/**
	 * Handles POST requests to update the document content. It reads the raw text
	 * from the request body.
	 */
	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		String content = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));
		logger.trace("POST request to update document content for '{}'. Content length: {}", DOCUMENT_NAME,
				content.length());

		boolean success = fileDAO.updateDocumentContent(DOCUMENT_NAME, content);

		if (success) {
			response.setStatus(HttpServletResponse.SC_OK);
		} else {
			logger.error("Failed to update document content for '{}'", DOCUMENT_NAME);
			response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\DownloadServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.config.AppConfig;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Mapped to `/download`, this servlet handles file download requests for both
 * general files and meeting attachments. It takes a `file` parameter which
 * corresponds to a path relative to the application's upload directory. It
 * performs basic security checks, constructs the full file path, and streams
 * the file from the server's filesystem to the user's browser, setting the
 * correct headers to trigger a download dialog.
 */
@WebServlet("/download")
public class DownloadServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(DownloadServlet.class);

	@Override
	public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		String relativePath = request.getParameter("file");
		if (relativePath == null || relativePath.isEmpty()) {
			logger.warn("Download request rejected: missing 'file' parameter.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Fehlender 'file' Parameter.");
			return;
		}

		User user = (User) request.getSession().getAttribute("user");

		// Basic security measure to prevent path traversal attacks (e.g., ../../)
		if (relativePath.contains("..")) {
			logger.warn("Potential path traversal attack from user '{}' for file '{}'. Access denied.",
					(user != null ? user.getUsername() : "GUEST"), relativePath);
			response.sendError(HttpServletResponse.SC_FORBIDDEN, "Zugriff verweigert.");
			return;
		}

		// Normalize path separators to be OS-independent, crucial for deployment
		String sanitizedPath = relativePath.replace("/", File.separator).replace("\\", File.separator);

		File file = new File(AppConfig.UPLOAD_DIRECTORY, sanitizedPath);
		if (!file.exists() || !file.isFile()) {
			logger.error("Download failed: File not found at resolved path {}", file.getAbsolutePath());
			response.sendError(HttpServletResponse.SC_NOT_FOUND, "Datei nicht gefunden.");
			return;
		}

		response.setContentType("application/octet-stream");
		response.setContentLengthLong(file.length());

		String headerKey = "Content-Disposition";
		// URL-encode the filename to handle special characters and spaces correctly.
		String headerValue = String.format("attachment; filename=\"%s\"",
				URLEncoder.encode(file.getName(), StandardCharsets.UTF_8.toString()));
		response.setHeader(headerKey, headerValue);

		logger.info("User '{}' is downloading file: {}. Size: {} bytes.", (user != null ? user.getUsername() : "GUEST"),
				file.getAbsolutePath(), file.length());

		try (FileInputStream inStream = new FileInputStream(file);
				OutputStream outStream = response.getOutputStream()) {

			byte[] buffer = new byte[4096];
			int bytesRead;
			while ((bytesRead = inStream.read(buffer)) != -1) {
				outStream.write(buffer, 0, bytesRead);
			}
		}
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventActionServlet.java
========================================================================

package de.technikteam.servlet;

import java.io.IOException;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.dao.EventDAO;
import de.technikteam.model.EventCustomField;
import de.technikteam.model.EventCustomFieldResponse;
import de.technikteam.model.User;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@WebServlet("/event-action")
public class EventActionServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventActionServlet.class);
	private EventDAO eventDAO;
	private EventCustomFieldDAO customFieldDAO;

	@Override
	public void init() {
		eventDAO = new EventDAO();
		customFieldDAO = new EventCustomFieldDAO();
	}

	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {

		User user = (User) request.getSession().getAttribute("user");
		String action = request.getParameter("action");
		String eventIdParam = request.getParameter("eventId");

		if (user == null || action == null || eventIdParam == null) {
			logger.warn("Invalid request to EventActionServlet. Missing user, action, or eventId parameter.");
			response.sendRedirect(request.getContextPath() + "/veranstaltungen");
			return;
		}

		try {
			int eventId = Integer.parseInt(eventIdParam);
			logger.info("User '{}' (ID: {}) is performing action '{}' on event ID {}", user.getUsername(), user.getId(),
					action, eventId);

			if ("signup".equals(action)) {
				eventDAO.signUpForEvent(user.getId(), eventId);

				// Handle custom field responses
				List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
				for (EventCustomField field : fields) {
					String paramName = "customfield_" + field.getId();
					String paramValue = request.getParameter(paramName);

					if (paramValue != null) {
						EventCustomFieldResponse customResponse = new EventCustomFieldResponse();
						customResponse.setFieldId(field.getId());
						customResponse.setUserId(user.getId());
						customResponse.setResponseValue(paramValue);
						customFieldDAO.saveResponse(customResponse);
						logger.debug("Saved custom response for field ID {} and user ID {}.", field.getId(),
								user.getId());
					}
				}

				request.getSession().setAttribute("successMessage", "Erfolgreich zum Event angemeldet.");
			} else if ("signoff".equals(action)) {
				eventDAO.signOffFromEvent(user.getId(), eventId);
				request.getSession().setAttribute("successMessage", "Erfolgreich vom Event abgemeldet.");
			} else {
				logger.warn("Unknown action received in EventActionServlet: {}", action);
			}

		} catch (NumberFormatException e) {
			logger.error("Invalid event ID format in EventActionServlet.", e);
			request.getSession().setAttribute("errorMessage", "Ungültige Event-ID.");
		}

		response.sendRedirect(request.getContextPath() + "/veranstaltungen");
	}
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventChatApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventChatDAO;
import de.technikteam.model.EventChatMessage;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * Provides a JSON API to fetch the historical messages for a given event chat.
 * New messages are handled by the EventChatSocket WebSocket.
 */
@WebServlet("/api/event-chat")
public class EventChatApiServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;
	private static final Logger logger = LogManager.getLogger(EventChatApiServlet.class);
	private EventChatDAO chatDAO;
	private Gson gson;

	@Override
	public void init() {
		chatDAO = new EventChatDAO();
		gson = new GsonBuilder().registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter()).create();
	}

	/**
	 * Handles GET requests to fetch the message history for an event.
	 */
	@Override
	protected void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		try {
			int eventId = Integer.parseInt(request.getParameter("eventId"));
			logger.trace("GET request for chat history for event ID: {}", eventId);
			List<EventChatMessage> messages = chatDAO.getMessagesForEvent(eventId);
			String jsonResponse = gson.toJson(messages);

			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(jsonResponse);
		} catch (NumberFormatException e) {
			logger.warn("Bad request to event chat history API: Invalid or missing eventId.");
			response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid or missing eventId.");
		}
	}
	// The doPost method has been removed as new messages are now sent via
	// WebSocket.
}

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\java\de\technikteam\servlet\EventCustomFieldsApiServlet.java
========================================================================

package de.technikteam.servlet;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import de.technikteam.config.LocalDateTimeAdapter;
import de.technikteam.dao.EventCustomFieldDAO;
import de.technikteam.model.EventCustomField;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.List;

/**
 * A public API endpoint that securely provides the list of custom sign-up
 * fields for a specific event. This is called by the JavaScript on the main
 * events page to populate the sign-up modal window.
 */
@WebServlet("/api/public/event-custom-fields")
public class EventCustomFieldsApiServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LogManager.getLogger(EventCustomFieldsApiServlet.class);
    private EventCustomFieldDAO customFieldDAO;
    private Gson gson;

    @Override
    public void init() {
        customFieldDAO = new EventCustomFieldDAO();
        gson = new GsonBuilder()
                .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeAdapter())
                .create();
    }

    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String eventIdParam = request.getParameter("eventId");
        if (eventIdParam == null || eventIdParam.trim().isEmpty()) {
            logger.warn("API call rejected: eventId parameter is missing.");
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Missing required 'eventId' parameter.");
            return;
        }

        try {
            int eventId = Integer.parseInt(eventIdParam);
            logger.debug("API request for custom fields for event ID: {}", eventId);

            List<EventCustomField> fields = customFieldDAO.getCustomFieldsForEvent(eventId);
            String jsonResponse = gson.toJson(fields);

            response.setContentType("application/json");
            response.setCharacterEncoding("UTF-8");
            response.getWriter().write(jsonResponse);

        } catch (NumberFormatException e) {
            logger.warn("API call rejected: Invalid eventId format '{}'.", eventIdParam);
            response.sendError(HttpServletResponse.SC_BAD_REQUEST, "Invalid 'eventId' format. It must be a number.");
        }
    }
}
