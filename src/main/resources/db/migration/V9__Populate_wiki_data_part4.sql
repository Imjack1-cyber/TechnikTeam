-- Flyway migration V9, Part 4

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/service/AdminLogService.java', '1.  **File Overview & Purpose**\n\n    This service provides a centralized and safe way to create audit log entries. It acts as an abstraction layer over the `AdminLogDAO`, adding input sanitization and structured logging to ensure that all administrative actions are reliably recorded in both the database and the application logs.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting concern that belongs to the **Service Tier**. It is injected into and used by numerous other services and servlets throughout the administrative side of the application whenever a state-changing action is performed.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AdminLogDAO`.\n    *   `AdminLogDAO`: The DAO used to persist the log entries.\n    *   `Log4j`: Used to write the audit message to the main application log file in addition to the database.\n\n4.  **In-Depth Breakdown**\n\n    *   **`log(String adminUsername, String actionType, String details)`**\n        *   **Method Signature:** `public void log(String adminUsername, String actionType, String details)`\n        *   **Purpose:** Creates and persists a new audit log entry.\n        *   **Parameters:**\n            *   `adminUsername` (String): The username of the admin performing the action.\n            *   `actionType` (String): A short, standardized key for the action (e.g., \"CREATE_USER\").\n            *   `details` (String): A human-readable description of the action.\n        *   **Returns:** void.\n        *   **Side Effects:**\n            1.  **Sanitization:** It first sanitizes all input strings to remove newlines, preventing log injection or formatting issues.\n            2.  **Application Logging:** It logs the audit event to the application''s main log file at the `INFO` level with a clear `[AUDIT]` prefix.\n            3.  **Database Logging:** It creates an `AdminLog` model object and passes it to the `AdminLogDAO` to be written to the database.\n            4.  **Error Handling:** It wraps the entire process in a `try-catch` block to ensure that a failure in the logging mechanism (e.g., a database connection issue) does not crash the primary operation that was being logged. A critical error is logged if this happens.'),
('src/main/java/de/technikteam/service/AuthorizationService.java', '1.  **File Overview & Purpose**\n\n    This service provides a centralized mechanism for performing permission checks. It encapsulates the logic for determining whether a given user has the authority to perform a specific action, based on the set of permissions associated with their user object.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting concern that belongs to the **Service Tier**. It is used by servlets and action classes in the **Web/Controller Tier** to enforce fine-grained access control before executing sensitive operations.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `User` (Model): The object containing the user''s set of permissions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`checkPermission(User user, String permissionKey)`**\n        *   **Method Signature:** `public boolean checkPermission(User user, String permissionKey)`\n        *   **Purpose:** Determines if a user has a specific permission.\n        *   **Parameters:**\n            *   `user` (User): The user object to check.\n            *   `permissionKey` (String): The string key of the permission to verify (e.g., \"USER_CREATE\").\n        *   **Returns:** `true` if the user has the permission, `false` otherwise.\n        *   **Logic:**\n            1.  It first performs null checks on the user and their permissions set.\n            2.  It implements a \"superuser\" check: if the user has the `ACCESS_ADMIN_PANEL` permission, the method immediately returns `true`, granting access to any action.\n            3.  Otherwise, it checks if the user''s `permissions` set contains the requested `permissionKey`.'),
('src/main/java/de/technikteam/service/ConfigurationService.java', '1.  **File Overview & Purpose**\n\n    This service is responsible for loading and providing access to the application''s configuration settings from the `config.properties` file. As a Guice Singleton, it ensures that the properties file is read only once at application startup, and the settings are then available globally.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure/Configuration** component that supports all other tiers. It is injected into any class that needs access to configuration parameters, such as the `DatabaseManager` (for DB credentials) and file handling servlets (for the upload directory path).\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.Properties`: The standard Java class used to load and store the key-value pairs from the `.properties` file.\n\n4.  **In-Depth Breakdown**\n\n    *   **`ConfigurationService()` (Constructor)**\n        *   **Purpose:** Loads the `config.properties` file from the classpath when the application starts.\n        *   **Side Effects:** Reads the properties file and populates the internal `Properties` object. If the file cannot be found or read, it logs a fatal error and throws a `RuntimeException`, preventing the application from starting in a misconfigured state.\n\n    *   **`getProperty(String key)`**\n        *   **Method Signature:** `public String getProperty(String key)`\n        *   **Purpose:** Retrieves the value for a given configuration key.\n        *   **Parameters:**\n            *   `key` (String): The name of the property to retrieve.\n        *   **Returns:** The property value as a `String`, or `null` if the key is not found.\n\n    *   **`getProperty(String key, String defaultValue)`**\n        *   **Method Signature:** `public String getProperty(String key, String defaultValue)`\n        *   **Purpose:** Retrieves the value for a given configuration key, returning a default value if the key is not found.\n        *   **Parameters:**\n            *   `key` (String): The name of the property to retrieve.\n            *   `defaultValue` (String): The value to return if the key is not present in the properties file.\n        *   **Returns:** The property value or the default value.'),
('src/main/java/de/technikteam/service/EventService.java', '1.  **File Overview & Purpose**\n\n    This service class orchestrates the complex business logic for creating and updating events. It manages the transactional saving of an event and all its related data (skill requirements, material reservations, custom fields, attachments) in a single, atomic operation.\n\n2.  **Architectural Role**\n\n    This class is a key component of the **Service Tier**. It is called by the `AdminEventServlet` to handle form submissions for creating or editing events. It coordinates multiple DAOs (`EventDAO`, `AttachmentDAO`, `EventCustomFieldDAO`) within a single database transaction to ensure data integrity.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the various DAOs, `DatabaseManager`, `ConfigurationService`, and `AdminLogService`.\n    *   `EventDAO`: For managing the core event record and its direct relationships.\n    *   `AttachmentDAO`: For saving new file attachment records.\n    *   `EventCustomFieldDAO`: For saving custom field definitions.\n    *   `DatabaseManager`: Used to get a connection and manage the transaction (`setAutoCommit`, `commit`, `rollback`).\n\n4.  **In-Depth Breakdown**\n\n    *   **`createOrUpdateEvent(Event event, boolean isUpdate, User adminUser, HttpServletRequest request)`**\n        *   **Method Signature:** `public int createOrUpdateEvent(...)`\n        *   **Purpose:** The main method of the service. It handles the entire process of saving an event and its associated data within a single database transaction.\n        *   **Parameters:**\n            *   `event` (Event): The core event object to save.\n            *   `isUpdate` (boolean): A flag to determine if this is a new event (`INSERT`) or an existing one (`UPDATE`).\n            *   `adminUser` (User): The administrator performing the action, for logging purposes.\n            *   `request` (HttpServletRequest): The request object, used to retrieve arrays of related data like skill requirements, item reservations, and uploaded files.\n        *   **Returns:** The ID of the created or updated event, or `0` on failure.\n        *   **Side Effects:**\n            1.  **Transaction Management:** It gets a connection from the `DatabaseManager` and sets `autoCommit` to `false`.\n            2.  **Core Event Save:** It calls either `eventDAO.createEvent` or `eventDAO.updateEvent`.\n            3.  **Associated Data Save:** It calls the respective DAOs to save skill requirements, reservations, and custom fields, all using the same `Connection` object.\n            4.  **File Upload:** It handles any uploaded file (`Part`) by saving it to disk and creating a corresponding record in the `attachments` table.\n            5.  **Commit/Rollback:** If all operations succeed, it calls `conn.commit()`. If any exception occurs, it calls `conn.rollback()` to undo all changes, ensuring the database remains in a consistent state.\n\n    *   **`signOffUserFromRunningEvent(...)`**: Contains the logic to sign a user off and send a notification to the event leader.'),
('src/main/java/de/technikteam/service/NotificationService.java', '1.  **File Overview & Purpose**\n\n    This service implements a server-side push notification system using Server-Sent Events (SSE). It manages persistent HTTP connections with clients, allowing the server to push real-time updates to the frontend. It is implemented as a thread-safe Singleton to provide a single, global point for broadcasting messages.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Infrastructure/Service Tier** component. It is called by various other services and servlets (e.g., `EventService`, `AdminUserServlet`, `EventChatSocket`) whenever a state change occurs that needs to be reflected in real-time on other users'' browsers. The `NotificationServlet` is the client-facing entry point that registers clients with this service.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.AsyncContext`)**: Used to manage the long-lived asynchronous connections required for SSE.\n    *   **Gson**: Used to serialize notification payloads into JSON strings before sending them to the client.\n\n4.  **In-Depth Breakdown**\n\n    *   **Singleton Implementation**: The service uses a private constructor and a static `INSTANCE` field with a `getInstance()` method to ensure only one instance exists for the entire application.\n    *   **`contextsByUser` (Map<Integer, List<AsyncContext>>)**: A thread-safe `ConcurrentHashMap` that is the core of the service. It maps a `userId` to a list of all active SSE connections for that user (a user can have multiple browser tabs open).\n    *   **`register(HttpServletRequest request)`**: Called by the `NotificationServlet` when a client connects. It starts an `AsyncContext`, sets its timeout to infinite, and adds it to the `contextsByUser` map.\n    *   **`broadcastGenericMessage(String message)`**: Sends a simple text message to *all* connected clients.\n    *   **`broadcastUIUpdate(String type, Object payload)`**: Sends a structured update message to *all* connected clients, indicating a specific type of UI change (e.g., \"user_updated\") and providing the relevant data.\n    *   **`sendNotificationToUser(int userId, Map<String, Object> payload)`**: Sends a targeted notification to all active sessions for a *single* user. This is used for user-specific alerts like mentions or invitations.\n    *   **`sendEventInvitation(...)`**: A specialized convenience method that constructs and sends an event invitation notification.\n    *   **`sendMessageToContext(...)`**: A private helper method that handles the actual writing of the SSE-formatted data (`data: ...\\n\\n`) to a client''s response stream. It includes robust error handling to detect and remove disconnected clients, preventing memory leaks.'),
('src/main/java/de/technikteam/service/PasskeyService.java', '1.  **File Overview & Purpose**\n\n    This service class encapsulates the server-side business logic for WebAuthn/Passkey authentication. It handles the start and finish of both the registration and authentication ceremonies. **Note: The current implementation is a placeholder/simulation** and does not perform the actual cryptographic operations required for a secure WebAuthn flow. It demonstrates the API structure and interaction with the DAO layer.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by the Passkey API servlets (`RegistrationStartServlet`, `AuthenticationFinishServlet`, etc.) to process passkey-related requests. It coordinates between the client-side WebAuthn API and the `PasskeyDAO` for credential storage.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `PasskeyDAO` and `UserDAO`.\n    *   `PasskeyDAO`: Used to store and retrieve passkey credential data.\n    *   `UserDAO`: Used to retrieve user information during the ceremonies.\n\n4.  **In-Depth Breakdown**\n\n    *   **`startRegistration(User user)`**\n        *   **Purpose:** Generates the initial challenge and options required by the browser to start the passkey creation process.\n        *   **Logic (Simulated):** Generates a random challenge string and constructs a JSON object containing the Relying Party (RP) information, user details, and public key parameters. In a real implementation, this would use a library like `webauthn-server-core` to generate a cryptographically secure challenge and store it in the session.\n        *   **Returns:** A JSON string with the `PublicKeyCredentialCreationOptions`.\n\n    *   **`finishRegistration(int userId, String credentialData, String deviceName)`**\n        *   **Purpose:** Receives the response from the browser''s `navigator.credentials.create()` call and saves the new credential.\n        *   **Logic (Simulated):** It does not validate the `credentialData`. Instead, it creates a new `PasskeyCredential` object with simulated data (random user handle, credential ID, and a placeholder public key) and saves it via the `PasskeyDAO`.\n        *   **Returns:** `true` on successful save.\n\n    *   **`startAuthentication(String username)`**\n        *   **Purpose:** Generates the challenge and options for the browser to start the passkey authentication process.\n        *   **Logic (Simulated):** Generates a random challenge. In a real implementation, it would also fetch the `credentialId`s for the given username from the DAO to include in the `allowCredentials` list.\n        *   **Returns:** A JSON string with the `PublicKeyCredentialRequestOptions`.\n\n    *   **`finishAuthentication(String credentialData)`**\n        *   **Purpose:** Receives the response from the browser''s `navigator.credentials.get()` call, verifies it, and logs the user in.\n        *   **Logic (Simulated):** This is the most significant simulation. It **does not perform any cryptographic verification**. It simply fetches a hardcoded user (admin user with ID 1) from the `UserDAO` and returns it, effectively logging them in. In a real implementation, this method would be the most complex, involving fetching the stored public key, verifying the signature against the challenge, and updating the signature counter.'),
('src/main/java/de/technikteam/service/StorageService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for all inventory-related state changes. It provides transactional methods for processing check-ins/check-outs and for managing the status of defective items, ensuring that all related database updates and logging occur as a single, atomic operation.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by the `StorageTransactionServlet` and `AdminStorageServlet` to execute inventory operations. It coordinates multiple DAOs (`StorageDAO`, `StorageLogDAO`, `EventDAO`) and the `AdminLogService` within a database transaction.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the DAOs, `DatabaseManager`, and `AdminLogService`.\n    *   `DatabaseManager`: Used to manage database connections and transactions.\n    *   `StorageDAO`: For updating the `storage_items` table.\n    *   `StorageLogDAO`: For creating entries in the `storage_log` table.\n    *   `AdminLogService`: For creating entries in the `admin_logs` table.\n\n4.  **In-Depth Breakdown**\n\n    *   **`processTransaction(int itemId, int quantity, String type, User user, Integer eventId, String notes)`**\n        *   **Method Signature:** `public boolean processTransaction(...)`\n        *   **Purpose:** Handles the check-out and check-in of inventory items within a database transaction.\n        *   **Logic:**\n            1.  Opens a database connection and disables auto-commit.\n            2.  Retrieves the `StorageItem` to perform validation checks (e.g., sufficient stock for checkout).\n            3.  Calls the appropriate method on `StorageDAO` (`performCheckout` or `performCheckin`).\n            4.  If the DAO operation is successful, it calls `StorageLogDAO.logTransaction` to record the event.\n            5.  It then calls `AdminLogService.log` to create an audit trail.\n            6.  If all steps succeed, it calls `conn.commit()`.\n            7.  If any step fails, it calls `conn.rollback()` and logs the error, ensuring the database remains in a consistent state.\n        *   **Returns:** `true` if the entire transaction was successful, `false` otherwise.\n\n    *   **`updateDefectiveItemStatus(int itemId, String status, int quantity, String reason, User adminUser)`**\n        *   **Method Signature:** `public boolean updateDefectiveItemStatus(...)`\n        *   **Purpose:** Manages the process of marking items as defective or unrepairable within a transaction.\n        *   **Logic:** Similar to `processTransaction`, it wraps the database operations in a transaction.\n            *   If `status` is `\"UNREPAIRABLE\"`, it calls `storageDAO.permanentlyReduceQuantities`, which decreases both the total and defective counts.\n            *   If `status` is `\"DEFECT\"`, it calls `storageDAO.updateDefectiveStatus`, which increases the defective count.\n            *   It logs the action to the `admin_logs` table.\n        *   **Returns:** `true` on success, `false` on failure.'),
('src/main/java/de/technikteam/service/SystemInfoService.java', '1.  **File Overview & Purpose**\n\n    This service is responsible for gathering and formatting live system statistics from the host operating system. It uses Java''s Management Extensions (JMX) and, for Linux-specific data like uptime and battery, reads directly from the `/proc` and `/sys` filesystems to provide a snapshot of the server''s health.\n\n2.  **Architectural Role**\n\n    This is a specialized **Service Tier** component. It is called by the `SystemStatsApiServlet` to provide real-time data for the admin system status page. It is designed to be platform-aware, providing graceful fallbacks for metrics that are not available on non-Linux systems.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **JMX (`com.sun.management.OperatingSystemMXBean`)**: The core Java API for accessing operating system-level metrics like CPU load and memory usage.\n    *   `java.nio.file.Files`: Used to read system files for Linux-specific stats.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getSystemStats()`**\n        *   **Method Signature:** `public SystemStatsDTO getSystemStats()`\n        *   **Purpose:** The main public method that collects all system metrics.\n        *   **Logic:**\n            1.  Gets an instance of `OperatingSystemMXBean`.\n            2.  Retrieves CPU load (`getSystemCpuLoad`), total and free physical memory.\n            3.  Retrieves total and usable disk space for the root partition (`/`).\n            4.  Calls the private helper methods `getSystemUptime()` and `getBatteryPercentage()`.\n            5.  Populates and returns a `SystemStatsDTO` with the collected data, converting byte values to Gigabytes where appropriate.\n        *   **Returns:** A `SystemStatsDTO` object.\n\n    *   **`getSystemUptime()`**: A private helper that reads the uptime in seconds from `/proc/uptime` on Linux and formats it into a human-readable \"days, hours, minutes\" string. It returns \"Nicht verfügbar\" on non-Linux systems or if the file cannot be read.\n\n    *   **`getBatteryPercentage()`**: A private helper that reads the battery capacity from `/sys/class/power_supply/BAT0/capacity` on Linux. It returns `-1` if the file doesn''t exist (e.g., on a desktop or non-Linux system), which signals the UI to hide the battery widget.'),
('src/main/java/de/technikteam/service/TodoService.java', '1.  **File Overview & Purpose**\n\n    This service class encapsulates the business logic for the administrative To-Do list feature. It provides transactional methods for creating, updating, reordering, and deleting To-Do categories and tasks, ensuring that both the database operations and the corresponding audit logs are handled correctly.\n\n2.  **Architectural Role**\n\n    This class is part of the **Service Tier**. It is used exclusively by the `AdminTodoApiServlet` to perform all state-changing operations on the To-Do list. It coordinates the `TodoDAO` and `AdminLogService`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`, `TodoDAO`, and `AdminLogService`.\n    *   `DatabaseManager`: Used for managing database transactions.\n    *   `TodoDAO`: The DAO for all To-Do list database operations.\n    *   `AdminLogService`: Used to create an audit trail for every action performed.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllTodos()`**: A simple pass-through method to retrieve all categories and their tasks from the DAO.\n    *   **`createCategory(String name, User admin)`**: Creates a new To-Do category and logs the action.\n    *   **`createTask(int categoryId, String content, User admin)`**: Creates a new task within a category and logs the action.\n    *   **`updateTask(int taskId, String content, Boolean isCompleted, User admin)`**: A transactional method to update a task''s content and/or completion status. It logs the specific action performed.\n    *   **`deleteTask(int taskId, User admin)`**: Deletes a task and logs the action.\n    *   **`deleteCategory(int categoryId, User admin)`**: Deletes a category (which cascades to its tasks) and logs the action.\n    *   **`reorder(Map<String, List<Integer>> reorderData, User admin)`**\n        *   **Method Signature:** `public boolean reorder(Map<String, List<Integer>> reorderData, User admin)`\n        *   **Purpose:** A transactional method to handle complex reordering operations from the drag-and-drop UI.\n        *   **Logic:** It opens a transaction and calls the DAO''s batch update methods to persist the new order of categories and the new order/category assignment of tasks. It commits the transaction if successful and logs a single \"reorder\" event.\n        *   **Returns:** `true` on success, `false` on failure.'),
('src/main/java/de/technikteam/service/UserService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for user management operations that require database transactions. It orchestrates the creation and updating of users and their associated permissions as a single, atomic operation to ensure data integrity.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is used by the `Action` classes (`CreateUserAction`, `UpdateUserAction`) which are invoked by the `FrontControllerServlet`. It provides a higher-level abstraction over the `UserDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`, `UserDAO`, and `AdminLogService`.\n    *   `DatabaseManager`: Used to obtain a connection and manage transactions.\n    *   `UserDAO`: The DAO for performing the actual user and permission database operations.\n    *   `AdminLogService`: Used to create an audit log entry for the actions.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createUserWithPermissions(User user, String password, String[] permissionIds, String adminUsername)`**\n        *   **Method Signature:** `public int createUserWithPermissions(...)`\n        *   **Purpose:** Creates a new user and assigns their initial permissions within a single database transaction.\n        *   **Logic:**\n            1.  Begins a transaction by disabling auto-commit.\n            2.  Calls `userDAO.createUser()` to insert the new user record.\n            3.  If the user is created successfully (returns a new ID), it calls `userDAO.updateUserPermissions()` to set their permissions.\n            4.  If both operations succeed, it commits the transaction.\n            5.  It then logs the successful creation event to the admin log.\n            6.  If any step fails, it rolls back the transaction.\n        *   **Returns:** The ID of the newly created user, or `0` on failure.\n\n    *   **`updateUserWithPermissions(User user, String[] permissionIds)`**\n        *   **Method Signature:** `public boolean updateUserWithPermissions(...)`\n        *   **Purpose:** Updates a user''s profile information and their set of permissions within a single database transaction.\n        *   **Logic:**\n            1.  Begins a transaction.\n            2.  Calls `userDAO.updateUser()` to save changes to the user''s profile.\n            3.  Calls `userDAO.updateUserPermissions()` to overwrite the user''s existing permissions with the new set.\n            4.  Commits the transaction if both operations succeed, otherwise rolls back.\n        *   **Returns:** `true` if the transaction was successful, `false` otherwise.'),
('src/main/java/de/technikteam/filter/AdminFilter.java', '1.  **File Overview & Purpose**\n\n    This servlet filter acts as a security gate for all administrative sections of the application. It intercepts every request to URLs matching `/admin/*` and `/api/admin/*` to ensure that only authenticated users with appropriate administrative permissions can access them.\n\n2.  **Architectural Role**\n\n    This class is a core component of the **Web/Controller Tier**. It enforces access control at the entry point of the application, before any admin servlet or API endpoint is executed. It relies on the `User` object stored in the session, which is populated by the `AuthenticationFilter`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.Filter`)**: The core interface for implementing a web filter.\n    *   `User` (Model): The object representing the logged-in user, retrieved from the `HttpSession`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`init(FilterConfig filterConfig)`**: Called once by the servlet container on startup. It logs a confirmation message that the filter has been initialized.\n\n    *   **`doFilter(ServletRequest req, ServletResponse res, FilterChain chain)`**\n        *   **Method Signature:** `public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException`\n        *   **Purpose:** This is the main logic of the filter, executed for every matching request.\n        *   **Parameters:**\n            *   `req` (ServletRequest): The incoming request.\n            *   `res` (ServletResponse): The outgoing response.\n            *   `chain` (FilterChain): An object that allows the filter to pass the request along to the next entity in the chain (another filter or the target servlet).\n        *   **Logic:**\n            1.  It first checks if a user session exists and if a `User` object is present. If not, it redirects the user to the `/login` page.\n            2.  If a user is logged in, it calls the `user.hasAdminAccess()` method. This method centrally determines if the user has any permission that qualifies them for admin access.\n            3.  If `hasAdminAccess()` returns `true`, it calls `chain.doFilter()`, allowing the request to proceed to the requested admin page or API.\n            4.  If `hasAdminAccess()` returns `false`, it logs a warning, sets a user-facing error message in the session, and sends an HTTP 403 (Forbidden) error back to the client.\n\n    *   **`destroy()`**: Called when the application is shut down. Logs a confirmation message.'),
('src/main/java/de/technikteam/filter/AuthenticationFilter.java', '1.  **File Overview & Purpose**\n\n    This is the primary authentication filter for the entire application. It intercepts every single request (`/*`) to determine if the user is authenticated. It protects all resources except for a defined set of public paths and resource prefixes.\n\n2.  **Architectural Role**\n\n    This class is a fundamental component of the **Web/Controller Tier**. It acts as the first line of defense, ensuring that unauthenticated users cannot access any protected part of the application.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta Servlet API (`jakarta.servlet.Filter`)**: The interface it implements.\n    *   `User` (Model): The object it looks for in the `HttpSession` to verify authentication.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Fields:**\n        *   `PUBLIC_PATHS`: A `Set` containing specific URL paths that do not require authentication (e.g., `/login`, `/logout`).\n        *   `PUBLIC_RESOURCE_PREFIXES`: A `Set` containing URL prefixes for static resources (like CSS, JS, images) and the passkey authentication API (`/api/auth`) that must be publicly accessible.\n    *   **`doFilter(ServletRequest req, ServletResponse res, FilterChain chain)`**:\n        *   **Purpose:** The core filter logic.\n        *   **Logic:**\n            1.  It retrieves the current `HttpSession` (without creating one if it doesn''t exist).\n            2.  It extracts the request path and sanitizes it by removing any `jsessionid` path parameters.\n            3.  It checks if a `User` object exists in the session to determine the `isLoggedIn` status.\n            4.  It checks if the requested path is in the `PUBLIC_PATHS` set or starts with any of the `PUBLIC_RESOURCE_PREFIXES`.\n            5.  If the user is logged in OR the resource is public, it calls `chain.doFilter()` to allow the request to proceed.\n            6.  If the user is not logged in AND the resource is not public, it logs a warning and redirects the user to the `/login` page.');
COMMIT;