-- Flyway migration V20, Part 15: Populate the wiki with the final set of documentation.

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/util/DaoUtils.java', '1.  **File Overview & Purpose**\n\n    This is a small utility class that provides common helper methods for DAO classes. Its purpose is to encapsulate reusable database-related logic, reducing code duplication across the DAO layer.\n\n2.  **Architectural Role**\n\n    This is a utility class for the **DAO (Data Access) Tier**.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.sql.ResultSet`: The JDBC class it operates on.\n\n4.  **In-Depth Breakdown**\n\n    *   **`hasColumn(ResultSet rs, String columnName)`**\n        *   **Method Signature:** `public static boolean hasColumn(ResultSet rs, String columnName) throws SQLException`\n        *   **Purpose:** Safely checks if a given `ResultSet` contains a column with a specific name, ignoring case.\n        *   **Logic:** It retrieves the `ResultSetMetaData`, iterates through all columns, and compares the provided `columnName` with each column''s name in a case-insensitive manner.\n        *   **Use Case:** This is extremely useful in DAOs that perform complex JOINs where a column might be present in some results but not others (e.g., `holder_username` in `StorageDAO`). Using this check before calling `rs.getString(\"columnName\")` prevents a `SQLException` if the column doesn''t exist for a particular row.'),
('src/main/java/de/util/MarkdownUtil.java', '1.  **File Overview & Purpose**\n\n    This is a security utility class designed to sanitize user-provided Markdown content. It strips out potentially dangerous HTML tags and attributes (like `<script>` tags and `onclick` handlers) to prevent Cross-Site Scripting (XSS) vulnerabilities before the content is stored or rendered.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Security/Utility** component. It is used in the **Web/Controller Tier** (specifically in WebSocket endpoints like `DocumentEditorSocket` and `EventChatSocket`) to clean user input before it is broadcast to other clients or saved.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.regex.Pattern`: The core Java class for regular expressions, used to define the sanitization rules.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Patterns:**\n        *   `SCRIPT_PATTERN`: Matches and removes entire `<script>...</script>` blocks.\n        *   `ON_ATTRIBUTE_PATTERN`: Matches and removes any HTML attribute that starts with \"on\" (e.g., `onclick`, `onmouseover`).\n        *   `JAVASCRIPT_URI_PATTERN`: Matches and neutralizes `href` or `src` attributes that use the `javascript:` pseudo-protocol.\n    *   **`sanitize(String markdown)`**\n        *   **Method Signature:** `public static String sanitize(String markdown)`\n        *   **Purpose:** Applies a series of regular expression replacements to remove malicious content from a string.\n        *   **Parameters:**\n            *   `markdown` (String): The raw, potentially unsafe, user-submitted string.\n        *   **Returns:** A sanitized version of the string, safe for rendering in an HTML context (after being processed by a Markdown parser).\n        *   **Side Effects:** None.'),
('src/main/java/de/util/NavigationRegistry.java', '1.  **File Overview & Purpose**\n\n    This class serves as a centralized, static registry for all navigation links in the application''s sidebar. It defines the complete set of possible navigation items and provides a single method to generate a user-specific list of links based on their assigned permissions. This approach ensures a single source of truth for the site''s navigation structure and access control.\n\n2.  **Architectural Role**\n\n    This is a **Configuration/Utility** class that primarily supports the **Web/Controller Tier**. It is called by the `LoginServlet` to populate the user''s session with their authorized navigation menu, which is then rendered by `main_header.jspf` on every page.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `Permissions`: The class containing all permission key constants.\n    *   `NavigationItem` (Model): The object used to represent each link.\n    *   `User` (Model): The user object, which contains the permissions used for filtering.\n\n4.  **In-Depth Breakdown**\n\n    *   **`ALL_ITEMS` (static List)**: A static list that is initialized once with `NavigationItem` objects for every possible link in the application, for both the user and admin sections. Each item is defined with its label, URL, icon, and the required permission key. Links available to all authenticated users have a `null` permission.\n    *   **`getNavigationItemsForUser(User user)`**\n        *   **Method Signature:** `public static List<NavigationItem> getNavigationItemsForUser(User user)`\n        *   **Purpose:** To filter the master `ALL_ITEMS` list down to only those items the provided user is authorized to see.\n        *   **Parameters:**\n            *   `user` (User): The currently logged-in user.\n        *   **Returns:** A `List` of `NavigationItem` objects that should be rendered in the sidebar for that user.\n        *   **Logic:** It uses a Java Stream to filter `ALL_ITEMS`. An item is included if:\n            1.  Its required permission is `null` (it''s a public link for logged-in users).\n            2.  The user has the master `ACCESS_ADMIN_PANEL` permission.\n            3.  The user has the specific permission required by the item.\n            4.  It handles special cases like `ADMIN_DASHBOARD_ACCESS` and `ACHIEVEMENT_VIEW`, which are meta-permissions that depend on the user having *any* other relevant admin permission.'),
('src/main/java/de/util/PasswordPolicyValidator.java', '1.  **File Overview & Purpose**\n\n    This is a utility class for enforcing a strong password policy. It provides a single static method to validate a given password against a set of predefined complexity rules (minimum length, character types). This ensures that all new passwords set in the application, whether during user creation or a password change, meet the required security standards.\n\n2.  **Architectural Role**\n\n    This is a cross-cutting **Security/Utility** component. It is used in the **Web/Controller Tier** by the `PasswordServlet` and in the **Service Tier** via the `CreateUserAction` to validate passwords before they are hashed and stored.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `java.util.regex.Pattern`: Used to define the regular expressions for checking character types.\n\n4.  **In-Depth Breakdown**\n\n    *   **Static Patterns & Constants**:\n        *   `MIN_LENGTH`: Defines the minimum required password length.\n        *   `HAS_UPPERCASE`, `HAS_LOWERCASE`, `HAS_DIGIT`, `HAS_SPECIAL_CHAR`: Pre-compiled `Pattern` objects for efficient checking of required character types.\n    *   **`ValidationResult` (Inner Class)**: A simple record-like class to return both a boolean `isValid` status and a user-friendly `message` explaining the result.\n    *   **`validate(String password)`**\n        *   **Method Signature:** `public static ValidationResult validate(String password)`\n        *   **Purpose:** The main validation logic.\n        *   **Logic:**\n            1.  It checks for null or empty passwords.\n            2.  It creates a list of error messages.\n            3.  It checks the password against each rule (`MIN_LENGTH`, `HAS_UPPERCASE`, etc.) and adds a descriptive error string to the list for each rule that fails.\n            4.  If the `errors` list is empty, it returns a successful `ValidationResult`.\n            5.  If there are errors, it joins them into a single, comprehensive error message (e.g., \"Das Passwort muss mindestens 10 Zeichen lang sein, mindestens einen Gro√übuchstaben enthalten.\") and returns a failed `ValidationResult`.'),
('src/main/java/de/websocket/ChatSessionManager.java', '1.  **File Overview & Purpose**\n\n    This class is a thread-safe singleton manager for WebSocket sessions related to event chats. It maintains a map of active chat rooms, where each room (keyed by an event ID) contains a set of connected user sessions. This allows for targeted message broadcasting to all participants in a specific event''s chat.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure** component for the real-time communication feature, operating within the **Web/Controller Tier**. It is exclusively used by the `EventChatSocket` WebSocket endpoint to manage session lifecycle and broadcast messages.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`jakarta.websocket.Session`)**: The object representing a single client connection.\n    *   `java.util.concurrent.ConcurrentHashMap` & `CopyOnWriteArraySet`: Thread-safe collection classes are used to safely manage sessions from multiple concurrent WebSocket threads.\n\n4.  **In-Depth Breakdown**\n\n    *   **Singleton Implementation**: Uses a private constructor and a static `INSTANCE` field to ensure only one manager exists per application.\n    *   **`sessionsByEvent` (Map)**: The central data structure. The key is the `eventId` as a string, and the value is a `CopyOnWriteArraySet` of `Session` objects. `CopyOnWriteArraySet` is chosen for its thread-safety, being particularly efficient when reads and iterations are more common than writes (add/remove).\n    *   **`addSession(String eventId, Session session)`**: Adds a new user''s session to the set for the corresponding event room.\n    *   **`removeSession(String eventId, Session session)`**: Removes a user''s session when they disconnect. If a room becomes empty, it is removed from the main map to conserve memory.\n    *   **`broadcast(String eventId, String message)`**: Sends a message to *every* active and open session in a specific event room.\n    *   **`broadcastExcept(String eventId, String message, Session excludeSession)`**: Sends a message to every active session in a room *except* the one that originated the message. This is used to prevent a user from receiving an echo of their own message.'),
('src/main/java/de/websocket/DocumentEditorSocket.java', '1.  **File Overview & Purpose**\n\n    This class is a WebSocket endpoint that enables real-time, collaborative editing of Markdown files. It manages WebSocket connections for specific document editing sessions, receives content updates from one client, sanitizes them, saves them to the file system, and broadcasts the changes to all other clients editing the same document.\n\n2.  **Architectural Role**\n\n    This class is part of the **Web/Controller Tier**. It provides the server-side logic for the real-time editor feature. It interacts with the `DocumentSessionManager` for session handling, the `FileDAO` for persistence, and the `MarkdownUtil` for security.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Uses static injection to receive a `FileDAO` instance from Guice.\n    *   **Jakarta WebSocket API (`@ServerEndpoint`, `@OnOpen`, etc.)**: The core annotations for defining a WebSocket endpoint.\n    *   `DocumentSessionManager`: The singleton used to manage sessions for different document rooms.\n    *   `FileDAO`: To read the file path and write updated content to the disk.\n    *   `MarkdownUtil`: For sanitizing user-provided content to prevent XSS.\n    *   **Gson**: For parsing incoming JSON messages.\n\n4.  **In-Depth Breakdown**\n\n    *   **`onOpen(...)`**:\n        *   **Purpose:** Handles a new client connection.\n        *   **Logic:** It retrieves the `User` object from the `EndpointConfig` (placed there by the `GuiceAwareServerEndpointConfigurator`). It performs an authorization check to ensure the user has `FILE_UPDATE` permission. If authorized, it adds the session to the `DocumentSessionManager` for the given `fileId`. If not, it closes the connection.\n    *   **`onMessage(...)`**:\n        *   **Purpose:** Receives a message from a client.\n        *   **Logic:** It parses the incoming JSON message. If the message `type` is `\"content_update\"`, it calls `handleContentUpdate`.\n    *   **`handleContentUpdate(...)`**:\n        *   **Purpose:** The core logic for processing a content change.\n        *   **Logic:**\n            1.  It retrieves the `File` metadata from the `FileDAO` to get the physical `filepath`.\n            2.  It sanitizes the received `content` using `MarkdownUtil.sanitize()`.\n            3.  It calls `fileDAO.updateFileContent()` to write the new content to the physical file.\n            4.  It calls `fileDAO.touchFileRecord()` to update the file''s modification timestamp.\n            5.  It constructs a broadcast message and uses `DocumentSessionManager.broadcastExcept()` to send the updated content to all other clients in the same editing session.\n    *   **`onClose(...)`** and **`onError(...)`**: Standard methods to handle session disconnection and errors by removing the session from the manager and logging the error.'),
('src/main/java/de/websocket/DocumentSessionManager.java', '1.  **File Overview & Purpose**\n\n    This class is a thread-safe singleton manager for WebSocket sessions related to the collaborative document editor. It mirrors the functionality of `ChatSessionManager` but is specifically for document editing rooms, mapping file IDs to sets of connected editor sessions.\n\n2.  **Architectural Role**\n\n    This is an **Infrastructure** component within the **Web/Controller Tier**. It is used exclusively by the `DocumentEditorSocket` to manage session lifecycle and broadcast document updates.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`jakarta.websocket.Session`)**: The object representing a single client connection.\n    *   `java.util.concurrent.ConcurrentHashMap` & `CopyOnWriteArraySet`: Thread-safe collections for managing sessions.\n\n4.  **In-Depth Breakdown**\n\n    This class''s implementation is nearly identical to `ChatSessionManager`, but for a different domain.\n    *   **Singleton Implementation**: Standard private constructor and `getInstance()` method.\n    *   **`sessionsByFile` (Map)**: The central map where the key is the `fileId` (as a string) and the value is a `CopyOnWriteArraySet` of `Session` objects.\n    *   **`addSession(String fileId, Session session)`**: Adds a session to the room for a given file.\n    *   **`removeSession(String fileId, Session session)`**: Removes a session and cleans up the room if it becomes empty.\n    *   **`broadcastExcept(String fileId, String message, Session excludeSession)`**: Broadcasts a message (the new document content) to all clients editing the file *except* the client who sent the update.'),
('src/main/java/de/websocket/EventChatSocket.java', '1.  **File Overview & Purpose**\n\n    This class is the WebSocket endpoint that powers the real-time chat feature for events. It manages client connections for specific event chat rooms, processes incoming messages (new, edit, delete), persists them to the database, and broadcasts them to all participants in the room. It also handles advanced features like user mentions.\n\n2.  **Architectural Role**\n\n    This is a key component of the **Web/Controller Tier**. It provides the real-time communication layer for events. It interacts with the `ChatSessionManager` for session management and various DAOs (`EventChatDAO`, `EventDAO`, `UserDAO`) for data persistence and validation.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Uses static injection to receive DAO and service instances from Guice.\n    *   **Jakarta WebSocket API (`@ServerEndpoint`, etc.)**: The core WebSocket annotations.\n    *   `ChatSessionManager`: To manage sessions and broadcast messages.\n    *   `EventChatDAO`: To save, update, and delete messages in the database.\n    *   `EventDAO`: To verify user association with the event.\n    *   `UserDAO`: To look up users for mentions.\n    *   `NotificationService`: To send out-of-app notifications for mentions.\n    *   `MarkdownUtil`: For sanitizing message content.\n\n4.  **In-Depth Breakdown**\n\n    *   **`onOpen(...)`**: Handles new connections. It authorizes the user by checking if they are associated with the event (`eventDAO.isUserAssociatedWithEvent`). If so, it adds their session to the `ChatSessionManager`.\n    *   **`onMessage(...)`**: The main message router. It parses the incoming JSON message and delegates to a specific handler based on the message `type`.\n    *   **`handleNewMessage(...)`**: Sanitizes the message content, saves it to the database via `chatDAO.postMessage()`, broadcasts the saved message (now with an ID and timestamp) to all clients in the room, and calls `handleMentions()`.\n    *   **`handleUpdateMessage(...)`**: Handles a message edit request. It calls `chatDAO.updateMessage()`, which verifies that the user is the original author, and then broadcasts the update to all clients.\n    *   **`handleDeleteMessage(...)`**: Handles a message delete request. It calls `chatDAO.deleteMessage()`, which performs a soft delete and checks if the user is the author or an admin/leader. It then broadcasts a special `message_soft_deleted` event to clients.\n    *   **`handleMentions(...)`**: Parses the message text for `@username` patterns. For each valid mention of a user who is not the sender, it sends a targeted, out-of-app notification via the `NotificationService`.'),
('src/main/java/de/websocket/GetHttpSessionConfigurator.java', '1.  **File Overview & Purpose**\n\n    This is a custom WebSocket `ServerEndpointConfig.Configurator`. Its purpose is to intercept the WebSocket handshake process to extract the `HttpSession` from the initial HTTP upgrade request. It then retrieves the authenticated `User` object from the session and places it into the WebSocket session''s user properties map, making it accessible to the WebSocket endpoint''s methods (`@OnOpen`, `@OnMessage`, etc.).\n\n2.  **Architectural Role**\n\n    This is a critical **Infrastructure/Configuration** component for the WebSocket layer. It bridges the gap between the standard HTTP session-based authentication and the WebSocket protocol, enabling secure, authenticated WebSocket communication.\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Jakarta WebSocket API (`ServerEndpointConfig.Configurator`)**: The base class it extends.\n    *   `User` (Model): The object it retrieves from the `HttpSession`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`USER_PROPERTY_KEY`**: A static constant defining the key used to store the `User` object in the WebSocket session''s user properties.\n    *   **`servletContext`**: A static volatile field to hold a reference to the `ServletContext`, which is needed by the `GuiceAwareServerEndpointConfigurator`.\n    *   **`modifyHandshake(...)`**:\n        *   **Purpose:** This method is called by the WebSocket container during the handshake.\n        *   **Logic:**\n            1.  It accesses the `HttpSession` from the `HandshakeRequest`.\n            2.  If a session exists, it retrieves the `User` object stored under the attribute key `\"user\"`.\n            3.  If a `User` object is found, it adds it to the `ServerEndpointConfig`''s user properties map using the `USER_PROPERTY_KEY`. This makes the user object available within the WebSocket endpoint instance.\n            4.  It also caches a reference to the `ServletContext` for Guice integration.'),
('src/main/java/de/websocket/GuiceAwareServerEndpointConfigurator.java', '1.  **File Overview & Purpose**\n\n    This is a custom WebSocket `ServerEndpointConfig.Configurator` that integrates Google Guice with the Jakarta WebSocket lifecycle. Its primary function is to ensure that WebSocket endpoint instances (like `EventChatSocket`) are created by the Guice `Injector` instead of the container''s default mechanism. This allows for dependency injection into the WebSocket classes.\n\n2.  **Architectural Role**\n\n    This is a core **Infrastructure/Configuration** component that enables dependency injection for the WebSocket layer. It is declared on each `@ServerEndpoint` annotation (e.g., `@ServerEndpoint(value = \"/ws/chat/{eventId}\", configurator = GuiceAwareServerEndpointConfigurator.class)`).\n\n3.  **Key Dependencies & Libraries**\n\n    *   **Guice (`com.google.inject.Injector`)**: The dependency injection container.\n    *   **Jakarta WebSocket API (`ServerEndpointConfig.Configurator`)**: The base class it extends.\n    *   `GetHttpSessionConfigurator`: It composes this configurator to also handle session extraction during the handshake.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getEndpointInstance(Class<T> endpointClass)`**:\n        *   **Purpose:** This method is called by the WebSocket container when it needs a new instance of an endpoint class. This override intercepts that call.\n        *   **Logic:**\n            1.  It retrieves the `ServletContext` (which was cached by `GetHttpSessionConfigurator`).\n            2.  It retrieves the Guice `Injector` from the `ServletContext` attributes (where it was placed by the `GuiceConfig` listener).\n            3.  It calls `injector.getInstance(endpointClass)` to have Guice create the endpoint instance. This handles constructor injection.\n            4.  It then calls `injector.injectMembers(instance)`. This crucial step performs member injection, including `@Inject` on static fields, which is the pattern used by the WebSocket endpoints in this project.\n        *   **Returns:** A fully dependency-injected instance of the WebSocket endpoint.\n\n    *   **`modifyHandshake(...)`**: This method is also overridden to ensure that the logic from `GetHttpSessionConfigurator` (extracting the user from the session) is also executed during the handshake process.');
COMMIT;