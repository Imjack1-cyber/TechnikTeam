-- This script populates the wiki_documentation table with the remaining entries.
-- This content should be appended to the existing V8__Populate_wiki_data.sql file.

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/dao/CourseDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all CRUD (Create, Read, Update, Delete) operations on the `courses` table. It manages the lifecycle of course templates, which act as blueprints for schedulable meetings.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It directly interacts with the database to manage course data and is primarily called by the `AdminCourseServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `Course` (Model): The data model object this DAO works with.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createCourse(Course course)`**: Inserts a new course template into the database.\n    *   **`getCourseById(int courseId)`**: Retrieves a single course template by its primary key.\n    *   **`getAllCourses()`**: Fetches a list of all course templates, ordered by name.\n    *   **`updateCourse(Course course)`**: Updates the details of an existing course template.\n    *   **`deleteCourse(int courseId)`**: Deletes a course template. Due to `ON DELETE CASCADE` constraints in the database, this will also delete all associated meetings and attendance records.\n    *   **`mapResultSetToCourse(ResultSet rs)`**: A private helper method to convert a database row into a `Course` object.'),
('src/main/java/de/technikteam/dao/DatabaseManager.java', '1.  **File Overview & Purpose**\n\n    This class manages the application''s database connection pool. It uses the high-performance HikariCP library to create and manage a pool of database connections, which is significantly more efficient than opening a new connection for every database query. It is configured as a Guice Singleton to ensure only one connection pool exists for the entire application.\n\n2.  **Architectural Role**\n\n    This is a critical **Infrastructure** component supporting the **DAO (Data Access) Tier**. It is injected into every DAO class, providing them with a standardized way to obtain database connections.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `ConfigurationService`.\n    *   **HikariCP (`com.zaxxer.hikari.HikariDataSource`)**: The underlying connection pooling library.\n    *   `ConfigurationService`: Used to get the database URL, username, and password from `config.properties`.\n\n4.  **In-Depth Breakdown**\n\n    *   **`DatabaseManager(ConfigurationService configService)` (Constructor)**: This is where the connection pool is initialized. It reads the database credentials, sets various pool parameters (like pool size and timeouts), and creates the `HikariDataSource` instance. It throws a `RuntimeException` if initialization fails, preventing the application from starting without a valid database connection.\n    *   **`getConnection()`**: The primary method called by DAOs. It borrows a connection from the pool. If the pool is exhausted or unavailable, it will wait for a connection to become free or throw a `SQLException`.\n    *   **`closeDataSource()`**: A cleanup method (not currently called but good practice to have) that would shut down the entire connection pool.'),
('src/main/java/de/technikteam/dao/EventChatDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database interactions for the real-time event chat feature. It handles posting new messages, retrieving the chat history for an event, and performing updates (edits) and soft deletes on messages in the `event_chat_messages` table.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used exclusively by the `EventChatSocket` WebSocket endpoint to persist and retrieve chat data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `EventChatMessage` (Model): The data model for a chat message.\n\n4.  **In-Depth Breakdown**\n\n    *   **`postMessage(EventChatMessage message)`**: Inserts a new chat message and returns the fully populated object (including the new ID and timestamp) by calling `getMessageById` immediately after insertion.\n    *   **`getMessagesForEvent(int eventId)`**: Retrieves the entire chat history for an event, ordered by time. It performs a `LEFT JOIN` on the `users` table to get the `chat_color` for the sender and the username of the person who deleted a message.\n    *   **`updateMessage(int messageId, int userId, String newText)`**: Updates the text of a message. It includes a `WHERE` clause to ensure a user can only edit their own messages and that the message has not been deleted.\n    *   **`deleteMessage(int messageId, int deletersUserId, boolean isAdmin)`**: Performs a soft delete by setting the `is_deleted` flag and recording who deleted the message. The SQL query is conditional: if `isAdmin` is true, any message can be deleted; otherwise, the `WHERE` clause ensures a user can only delete their own messages.'),
('src/main/java/de/technikteam/dao/EventCustomFieldDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages the database operations for custom event sign-up fields. It handles saving the definitions of custom fields for an event (`event_custom_fields` table) and saving user responses to those fields (`event_custom_field_responses` table).\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `EventService` to save field definitions and by the `EventActionServlet` to save user responses during sign-up.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `EventCustomField`, `EventCustomFieldResponse` (Models): The data models this DAO works with.\n\n4.  **In-Depth Breakdown**\n\n    *   **`saveCustomFieldsForEvent(...)`**: A transactional method that first deletes all existing custom fields for an event and then uses a batch insert to add the new list of fields. This ensures the set of fields is always in sync with what was submitted in the admin form.\n    *   **`getCustomFieldsForEvent(int eventId)`**: Retrieves all custom field definitions for a given event, used to build the sign-up modal.\n    *   **`saveResponse(EventCustomFieldResponse response)`**: Saves a single user''s answer to a custom field. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` statement so a user can change their response without causing a database error.'),
('src/main/java/de/technikteam/dao/EventDAO.java', '1.  **File Overview & Purpose**\n\n    This is one of the most complex and central DAOs in the application. It manages all database operations for the `events` table and its many related tables, including `event_attendance`, `event_assignments`, `event_skill_requirements`, and `event_storage_reservations`. It provides a wide range of methods for CRUD operations, user interactions (sign-up/off), and complex queries for reporting and the UI.\n\n2.  **Architectural Role**\n\n    This class is a cornerstone of the **DAO (Data Access) Tier**. It is used by numerous services and servlets, including `EventService`, `AdminEventServlet`, `HomeServlet`, `EventDetailsServlet`, and `ReportDAO`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `Event`, `User`, `SkillRequirement`, `StorageItem` (Models): The various data models this DAO creates and populates.\n\n4.  **In-Depth Breakdown**\n\n    *   **Transactional Methods (`createEvent`, `updateEvent`, `saveSkillRequirements`, `saveReservations`)**: These methods are designed to be called within a transaction managed by the `EventService`. They take a `Connection` object as a parameter to ensure all operations are part of the same atomic unit.\n    *   **User Interaction Methods (`signUpForEvent`, `signOffFromEvent`)**: Handle user sign-ups and sign-offs by inserting or updating records in the `event_attendance` table.\n    *   **Complex Queries**:\n        *   `getUpcomingEventsForUser(...)`: A complex query that finds events a user is qualified for by checking their qualifications against the event''s skill requirements.\n        *   `getQualifiedAndAvailableUsersForEvent(...)`: The most complex query in this DAO. It finds users who meet all skill requirements for an event AND are not assigned to another event with an overlapping time frame. This is the core of the \"Crew Finder\" feature.\n    *   **Data Aggregation**: Methods like `getEventById` and `getAllEvents` perform `LEFT JOIN`s to enrich the `Event` object with related data like the leader''s username.\n    *   **`mapResultSetToEvent` / `mapResultSetToSimpleUser`**: Private helper methods to reduce code duplication when creating model objects from query results.'),
('src/main/java/de/technikteam/dao/EventFeedbackDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database interactions related to event-specific feedback. It handles the creation of feedback forms (`feedback_forms` table) and the storage of user responses (`feedback_responses` table), including ratings and comments.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `FeedbackServlet` to facilitate the event feedback workflow after an event has concluded.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `FeedbackForm`, `FeedbackResponse` (Models): The data models this DAO works with.\n\n4.  **In-Depth Breakdown**\n\n    *   **`createFeedbackForm(FeedbackForm form)`**: Inserts a new feedback form record, typically when the first user attempts to give feedback for an event that doesn''t yet have a form.\n    *   **`saveFeedbackResponse(FeedbackResponse response)`**: Saves a user''s rating and comments. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` statement to prevent a user from submitting feedback multiple times for the same event.\n    *   **`getFeedbackFormForEvent(int eventId)`**: Retrieves the feedback form associated with a specific event.\n    *   **`getResponsesForForm(int formId)`**: Fetches all submitted responses for a given form, used for administrative review.\n    *   **`hasUserSubmittedFeedback(int formId, int userId)`**: A quick check to see if a user has already provided feedback, used to prevent the form from being displayed to them again.'),
('src/main/java/de/technikteam/dao/EventTaskDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations for event tasks and their complex relationships. It handles the transactional creation and updating of tasks (`event_tasks` table) along with their associated user assignments (`event_task_assignments`), required items (`event_task_storage_items`), and required kits (`event_task_kits`).\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is a critical component used by the `TaskActionServlet` to manage tasks and by the `EventDetailsServlet` and `HomeServlet` to display task information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides connections for its transactional methods.\n    *   `EventTask`, `User`, `StorageItem`, `InventoryKit` (Models).\n\n4.  **In-Depth Breakdown**\n\n    *   **`saveTask(...)`**: This is the core method. It wraps the entire process of saving a task and its associations in a single, manual database transaction to ensure data integrity. It first saves the main task record, then clears all existing associations, and finally batch-inserts the new user, item, and kit associations.\n    *   **`getTasksForEvent(int eventId)`**: A complex query that retrieves all tasks for an event and, using `LEFT JOIN`s, aggregates all assigned users, required items, and required kits into their respective lists within each `EventTask` object. It uses a `LinkedHashMap` to correctly group the joined data.\n    *   **User Action Methods (`claimTask`, `unclaimTask`)**: Handle a user volunteering for or leaving a task in an \"open pool\". The `claimTask` method includes a subquery to ensure the `required_persons` limit is not exceeded.\n    *   **`getOpenTasksForUser(int userId)`**: A specific query to fetch only the tasks assigned to a user that are still open, for display on their home dashboard.'),
('src/main/java/de/technikteam/dao/FeedbackSubmissionDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database interactions for general user feedback submissions, which are displayed on the administrative Kanban board. It handles creating new submissions, retrieving them for display, and updating their status and display order as they are moved through the workflow.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `FeedbackServlet` to create submissions and by the `AdminFeedbackServlet` and its associated `Action` classes to manage them.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `FeedbackSubmission` (Model).\n\n4.  **In-Depth Breakdown**\n\n    *   **`createSubmission(...)`**: Inserts a new feedback record with a default status of `\"NEW\"`.\n    *   **`getAllSubmissions()`**: Retrieves all submissions, ordered first by a custom status order (to match the Kanban columns) and then by their display order within that status.\n    *   **`updateStatus(int submissionId, String newStatus, Connection conn)`**: Updates the status of a single submission. It is designed to be called within a transaction.\n    *   **`updateOrderForStatus(List<Integer> orderedIds, Connection conn)`**: A key method for the Kanban board. It takes a list of submission IDs in their new order and performs a batch `UPDATE` to set their `display_order` accordingly. This is also designed to be called within a transaction.\n    *   **`updateStatusAndTitle(...)`**: A combined update method used by the feedback details modal.'),
('src/main/java/de/technikteam/dao/FileDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for managing both the metadata of files in the `files` and `file_categories` tables and the interaction with the physical files on the server''s filesystem. It provides a complete abstraction layer for file management.\n\n2.  **Architectural Role**\n\n    This is a hybrid **DAO (Data Access) Tier** class. It performs standard database operations but also contains logic that interacts with the filesystem, an external resource. It is used by servlets that manage or serve files, such as `FileServlet`, `AdminFileServlet`, and `MarkdownEditorServlet`.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects `DatabaseManager` and `ConfigurationService`.\n    *   `DatabaseManager`: For database connections.\n    *   `ConfigurationService`: To get the base path of the `upload.directory`.\n    *   `java.nio.file.Files`: For reading and writing physical files.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllFilesGroupedByCategory(User user)`**: Retrieves all files and organizes them into a `Map` where the key is the category name. It includes logic to filter files based on the user''s role (`required_role`).\n    *   **Filesystem Interaction (`getDocumentContentByPath`, `updateFileContent`, `deleteFile`)**: These methods bridge the gap between the database and the filesystem.\n        *   `updateFileContent` writes a string directly to a physical file.\n        *   The `deleteFile` method is transactional in nature: it first deletes the database record, and only if that is successful, it proceeds to delete the physical file from the disk.\n    *   **Category Management (`getAllCategories`, `createCategory`, etc.)**: Provides full CRUD functionality for the `file_categories` table.'),
('src/main/java/de/technikteam/dao/InventoryKitDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations related to inventory kits. It handles the CRUD lifecycle for the kits themselves (`inventory_kits` table) and manages their contents through the `inventory_kit_items` junction table.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is primarily used by the `AdminKitServlet` for management, the `PackKitServlet` for displaying packing lists, and `EventTaskDAO` when kits are associated with tasks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `InventoryKit`, `InventoryKitItem` (Models).\n\n4.  **In-Depth Breakdown**\n\n    *   **CRUD Operations (`createKit`, `getKitById`, `updateKit`, `deleteKit`)**: Standard methods for managing the main kit records.\n    *   **`getAllKitsWithItems()`**: A key method that retrieves all kits and, using a `LEFT JOIN` and a `Map`-based aggregation strategy, populates each kit object with a list of its contained items and their quantities.\n    *   **`getItemsForKit(int kitId)`**: Retrieves the contents for a single, specific kit.\n    *   **`updateKitItems(...)`**: A transactional method that handles updating the contents of a kit. It first deletes all existing item associations for the kit and then performs a batch insert of the new list of items and quantities, ensuring the kit''s contents are always in sync with the last submitted form.'),
('src/main/java/de/technikteam/dao/StorageLogDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all interactions with the `storage_log` table. Its purpose is to create transaction records when inventory items are checked in or out, and to retrieve the history of these transactions for a specific item.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `StorageService` to log transactions and by the `StorageItemDetailsServlet` to display an item''s history.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `StorageLogEntry` (Model): The data model for a log entry.\n\n4.  **In-Depth Breakdown**\n\n    *   **`logTransaction(...)`**: Inserts a new transaction record into the `storage_log` table. This method takes a `Connection` object as a parameter because it is designed to be called from within a larger transaction managed by the `StorageService`.\n    *   **`getHistoryForItem(int itemId)`**: Retrieves the complete transaction history for a single item, ordered from newest to oldest. It joins with the `users` table to include the username of the person who performed each transaction.'),
('src/main/java/de/technikteam/dao/TodoDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations for the administrative To-Do list feature. It handles CRUD for both categories (`todo_categories`) and tasks (`todo_tasks`), and includes methods for batch-updating their display order to support drag-and-drop functionality.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used exclusively by the `TodoService` to persist and retrieve all To-Do list data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `TodoCategory`, `TodoTask` (Models).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllCategoriesWithTasks()`**: The main retrieval method. It fetches all categories and, using a `LEFT JOIN`, also fetches all their associated tasks in a single query. It then uses a `LinkedHashMap` to aggregate the flat result set into a structured list of `TodoCategory` objects, each containing its list of `TodoTask` objects.\n    *   **`createCategory(...)` / `createTask(...)`**: These methods use a subquery (`SELECT COALESCE(MAX(display_order), -1) + 1 FROM ...`) to automatically assign the new item the next available display order index, ensuring it appears at the bottom of the list.\n    *   **`updateCategoryOrder(...)` / `updateTaskOrders(...)`**: These methods are crucial for the drag-and-drop feature. They accept a list of IDs in their new order and perform a batch `UPDATE` to efficiently persist the new sorting to the database within a single transaction.'),
('src/main/java/de/technikteam/dao/UserDAO.java', '1.  **File Overview & Purpose**\n\n    This is the central DAO for managing user accounts. It handles all database operations for the `users` table, including credential validation, CRUD operations, password changes, and managing the user-permission relationship in the `user_permissions` table.\n\n2.  **Architectural Role**\n\n    This is a critical class in the **DAO (Data Access) Tier**. It is used by the `LoginServlet` for authentication, by the `UserService` for transactional updates, and by numerous other servlets and DAOs to retrieve user information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   **Spring Security Crypto (`BCryptPasswordEncoder`)**: The library used for securely hashing and verifying passwords.\n    *   `PermissionDAO`: Used to fetch the permissions for a user.\n\n4.  **In-Depth Breakdown**\n\n    *   **`validateUser(String username, String password)`**: The core authentication method. It fetches the user''s `password_hash` from the database and uses `passwordEncoder.matches()` to securely compare it with the provided password. If validation is successful, it fetches the user''s permissions and returns a fully populated `User` object.\n    *   **`getPermissionsForUser(int userId)`**: Retrieves all permission keys for a given user.\n    *   **`updateUserPermissions(int userId, String[] permissionIds, Connection conn)`**: A transactional method that first deletes all of a user''s existing permissions and then batch-inserts the new set.\n    *   **`createUser(...)` / `updateUser(...)`**: Standard CRUD methods. `createUser` hashes the provided password before storing it.\n    *   **`changePassword(...)`**: Securely updates a user''s password by hashing the new password before saving it.'),
('src/main/java/de/technikteam/dao/UserQualificationsDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages the `user_qualifications` table, which links users to the courses they have attended or completed. It is the persistence layer for tracking user skills and qualifications.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `MatrixServlet` and `AdminAttendanceServlet` to update qualifications based on meeting attendance, and by the `ProfileServlet` to display a user''s qualifications.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `UserQualification` (Model).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getQualificationsForUser(int userId)`**: Retrieves all qualifications for a single user.\n    *   **`getAllQualifications()`**: Fetches all qualification records for all users, primarily for building the data structures needed by the Qualification Matrix.\n    *   **`updateQualificationStatus(...)`**: The core update method. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` statement (an \"upsert\") to create or update a qualification record. It also contains special logic: if the new status is `\"NICHT BESUCHT\"`, it deletes the record entirely instead of updating it.'),
('src/main/java/de/technikteam/dao/WikiDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all database interactions with the `wiki_documentation` table. It provides simple CRUD (Create, Read, Update, Delete) operations for managing the content of the technical documentation wiki pages.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `WikiService` to load the documentation into its cache at startup, and by the `AdminWikiDetailsServlet` and `UpdateWikiAction` to display and save changes to the wiki content.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `WikiEntry` (Model): The data model object that this DAO creates and populates.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getWikiEntryById(int id)`**: Retrieves a single wiki page by its primary key.\n    *   **`getAllWikiEntries()`**: Fetches all wiki pages from the database, ordered by their file path. This is used by the `WikiService` to populate its initial cache.\n    *   **`updateWikiContent(int id, String content)`**: Updates the `content` field for a specific wiki entry. This is the main method used for saving changes from the admin editor.'),
('src/main/java/de/technikteam/model/WikiEntry.java', '1.  **File Overview & Purpose**\n\n    This is a simple Plain Old Java Object (POJO) that serves as the data model for a single wiki documentation page. It represents a record from the `wiki_documentation` table.\n\n2.  **Architectural Role**\n\n    This class is part of the **Model Tier**. It is used to transfer wiki data between the `WikiDAO`, the `WikiService`, and the administrative servlets that manage the wiki.\n\n3.  **Key Dependencies & Libraries**\n\n    *   None. This is a self-contained POJO.\n\n4.  **In-Depth Breakdown**\n\n    *   **Fields:**\n        *   `id`: The primary key of the wiki entry.\n        *   `filePath`: A unique string representing the path of the documented file within the project (e.g., \"src/main/java/de/technikteam/service/UserService.java\"). This is the key used for lookups.\n        *   `content`: A `longtext` field containing the Markdown documentation for the file.\n    *   **Getters and Setters**: Standard boilerplate methods for accessing and modifying the object''s properties.'),
('src/main/java/de/technikteam/service/WikiService.java', '1.  **File Overview & Purpose**\n\n    This service class acts as the business logic and presentation layer for the technical documentation wiki. It is responsible for reading the project structure from the `Wiki.md` file, fetching the corresponding documentation from the `WikiDAO`, and dynamically generating the HTML for the navigation tree that is displayed on the wiki index page.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is a singleton that is initialized once at application startup. It serves as a facade for the `AdminWikiServlet`, providing the fully rendered HTML tree. It caches the wiki entries in memory to reduce database lookups.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `WikiDAO`.\n    *   `WikiDAO`: Used to fetch all wiki entries from the database during initialization.\n    *   `java.util.regex.Pattern`: Used to parse the Markdown links from the `Wiki.md` file.\n\n4.  **In-Depth Breakdown**\n\n    *   **`initialize()`**: Called by the constructor. It fetches all `WikiEntry` objects from the DAO and stores them in a `Map` (`wikiEntriesByPath`) for fast lookups. It then calls `parseProjectTree()` to generate and cache the final HTML.\n    *   **`parseProjectTree()`**: The core logic of the service.\n        1.  It reads the `Wiki.md` file from the classpath.\n        2.  It iterates through each line of the file, keeping track of the indentation level to correctly open and close `<ul>` and `<li>` tags, thus building the nested list structure.\n        3.  For each line that contains a Markdown link (e.g., `[`FileName.java`](path/to/File.java)`), it extracts the file name and the file path.\n        4.  It uses the extracted `filePath` to look up the corresponding `WikiEntry` in its internal `wikiEntriesByPath` map.\n        5.  If an entry is found, it generates an `<a>` tag with an `href` pointing to `/admin/wiki/details?id=...`, using the ID from the database entry.\n        6.  If no database entry is found for a path in the `Wiki.md` file, it renders the link as plain text with a \"(No Doc)\" warning.\n    *   **`getProjectTreeHtml()`**: A simple getter that returns the pre-generated HTML string to the `AdminWikiServlet`.'),
('src/main/java/de/technikteam/servlet/admin/action/UpdateWikiAction.java', '1.  **File Overview & Purpose**\n\n    This `Action` class encapsulates the logic for saving updated content for a wiki documentation page. It is triggered by an AJAX request from the admin wiki editor. It sanitizes the incoming content and persists it to the database.\n\n2.  **Architectural Role**\n\n    This is a command object in the **Web/Controller Tier**, executed by the `FrontControllerServlet`. It is the server-side endpoint for the \"Save\" button in the wiki editor UI.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `WikiDAO` and `AdminLogService`.\n    *   `WikiDAO`: The DAO used to update the content in the `wiki_documentation` table.\n    *   `AdminLogService`: To create an audit trail of the documentation update.\n    *   `MarkdownUtil`: A security utility used to sanitize the user-provided Markdown content before saving it.\n\n4.  **In-Depth Breakdown**\n\n    *   **`execute(...)`**:\n        *   **Purpose:** The main execution method for the update wiki action.\n        *   **Logic:**\n            1.  **Authorization:** Checks if the user is a full admin with `ACCESS_ADMIN_PANEL` permission.\n            2.  **Parameter Parsing:** Retrieves the `wikiId` and `content` from the request.\n            3.  **Sanitization:** It calls `MarkdownUtil.sanitize()` on the received content to strip any potentially malicious HTML or script tags.\n            4.  **Data Retrieval:** It fetches the original `WikiEntry` from the database to ensure it exists and to get its file path for logging.\n            5.  **Database Update:** It calls `wikiDAO.updateWikiContent()` with the sanitized content.\n            6.  **Logging & Response:** If the update is successful, it logs the action and returns an `ApiResponse.success`. Otherwise, it returns an `ApiResponse.error`.');