-- Flyway migration V8, Part 3

INSERT INTO `wiki_documentation` (`file_path`, `content`) VALUES
('src/main/java/de/technikteam/dao/RoleDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO provides read-only access to the user roles defined in the `roles` table. It features a simple caching mechanism using Caffeine to avoid repeatedly querying the database for the list of roles, which changes very infrequently.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `AdminUserServlet` to populate the roles dropdown in the user editing modal.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   **Caffeine (`com.github.benmanes.caffeine.cache.LoadingCache`)**: A high-performance caching library used to cache the list of roles in memory.\n\n4.  **In-Depth Breakdown**\n\n    *   **`RoleDAO(DatabaseManager dbManager)` (Constructor)**: Initializes the Caffeine `LoadingCache`. The cache is configured to expire after one hour and to hold only one entry (the list of all roles). The `build` method provides the loader function (`fetchAllRolesFromDb`) that is called automatically on a cache miss.\n    *   **`getAllRoles()`**: The main public method. It retrieves the list of all roles from the cache using `roleCache.get(ALL_ROLES_KEY)`. If the cache is empty or expired, the loader function is automatically triggered.\n    *   **`fetchAllRolesFromDb()`**: A private method that performs the actual database query to get all roles. This method is only called when the cache needs to be populated.'),
('src/main/java/de/technikteam/dao/StatisticsDAO.java', '1.  **File Overview & Purpose**\n\n    This is a specialized, read-only DAO for retrieving simple statistical counts from the database. It is used to quickly fetch aggregate numbers for display on the admin dashboard without the overhead of more complex reporting queries.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `AdminDashboardServlet` to gather high-level metrics about the system''s state.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getUserCount()`**: Executes a `SELECT COUNT(*)` query on the `users` table to get the total number of registered users.\n    *   **`getActiveEventCount()`**: Executes a `SELECT COUNT(*)` query on the `events` table to count events that have not yet finished.\n    *   **`getCount(String sql)`**: A private helper method that takes a SQL `COUNT` query as a string, executes it, and returns the integer result, reducing code duplication.'),
('src/main/java/de/technikteam/dao/StorageDAO.java', '1.  **File Overview & Purpose**\n\n    This is the primary DAO for managing the inventory, handling all database operations for the `storage_items` table. It provides comprehensive CRUD functionality, methods for handling defective and repaired items, and transactional logic for checking items in and out.\n\n2.  **Architectural Role**\n\n    This class is a cornerstone of the **DAO (Data Access) Tier**. It is used extensively by the `StorageService` to perform transactional operations and by various servlets (`StorageServlet`, `AdminStorageServlet`, `AdminDefectServlet`) to display and manage inventory data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `StorageItem` (Model): The data model for an inventory item.\n\n4.  **In-Depth Breakdown**\n\n    *   **Listing Methods (`getAllItemsGroupedByLocation`, `getAllItems`, `getDefectiveItems`, `getLowStockItems`)**: Provide different views of the inventory data, tailored for specific pages like the public lager view or admin dashboard widgets.\n    *   **CRUD Operations (`createItem`, `getItemById`, `updateItem`, `deleteItem`)**: Standard methods for managing the lifecycle of `StorageItem` records. The `updateItem` method is particularly comprehensive, updating nearly every column.\n    *   **Transactional Methods (`performCheckout`, `performCheckin`)**: These methods are designed to be called within a transaction managed by the `StorageService`. They update an item''s `quantity`, `status`, and `current_holder_user_id` atomically. The `performCheckout` query includes a `WHERE` clause to prevent checking out more items than are available.\n    *   **Defect & Repair Management (`updateDefectiveStatus`, `permanentlyReduceQuantities`, `repairItems`)**:\n        *   `updateDefectiveStatus`: Increases the `defective_quantity` for an item.\n        *   `permanentlyReduceQuantities`: Decreases both `quantity` and `defective_quantity`, effectively removing an unrepairable item from the total stock.\n        *   `repairItems`: Decreases the `defective_quantity`, moving an item back into the available pool.\n    *   **`mapResultSetToStorageItem(ResultSet rs)`**: A private helper method to construct a `StorageItem` object from a database query result.'),
('src/main/java/de/technikteam/dao/StorageLogDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all interactions with the `storage_log` table. Its purpose is to create transaction records when inventory items are checked in or out, and to retrieve the history of these transactions for a specific item.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `StorageService` to log transactions and by the `StorageItemDetailsServlet` to display an item''s history.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `StorageLogEntry` (Model): The data model for a log entry.\n\n4.  **In-Depth Breakdown**\n\n    *   **`logTransaction(...)`**: Inserts a new transaction record into the `storage_log` table. This method takes a `Connection` object as a parameter because it is designed to be called from within a larger transaction managed by the `StorageService`.\n    *   **`getHistoryForItem(int itemId)`**: Retrieves the complete transaction history for a single item, ordered from newest to oldest. It joins with the `users` table to include the username of the person who performed each transaction.'),
('src/main/java/de/technikteam/dao/TodoDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages all database operations for the administrative To-Do list feature. It handles CRUD for both categories (`todo_categories`) and tasks (`todo_tasks`), and includes methods for batch-updating their display order to support drag-and-drop functionality.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used exclusively by the `TodoService` to persist and retrieve all To-Do list data.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `TodoCategory`, `TodoTask` (Models).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getAllCategoriesWithTasks()`**: The main retrieval method. It fetches all categories and, using a `LEFT JOIN`, also fetches all their associated tasks in a single query. It then uses a `LinkedHashMap` to aggregate the flat result set into a structured list of `TodoCategory` objects, each containing its list of `TodoTask` objects.\n    *   **`createCategory(...)` / `createTask(...)`**: These methods use a subquery (`SELECT COALESCE(MAX(display_order), -1) + 1 FROM ...`) to automatically assign the new item the next available display order index, ensuring it appears at the bottom of the list.\n    *   **`updateCategoryOrder(...)` / `updateTaskOrders(...)`**: These methods are crucial for the drag-and-drop feature. They accept a list of IDs in their new order and perform a batch `UPDATE` to efficiently persist the new sorting to the database within a single transaction.'),
('src/main/java/de/technikteam/dao/UserDAO.java', '1.  **File Overview & Purpose**\n\n    This is the central DAO for managing user accounts. It handles all database operations for the `users` table, including credential validation, CRUD operations, password changes, and managing the user-permission relationship in the `user_permissions` table.\n\n2.  **Architectural Role**\n\n    This is a critical class in the **DAO (Data Access) Tier**. It is used by the `LoginServlet` for authentication, by the `UserService` for transactional updates, and by numerous other servlets and DAOs to retrieve user information.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   **Spring Security Crypto (`BCryptPasswordEncoder`)**: The library used for securely hashing and verifying passwords.\n    *   `PermissionDAO`: Used to fetch the permissions for a user.\n\n4.  **In-Depth Breakdown**\n\n    *   **`validateUser(String username, String password)`**: The core authentication method. It fetches the user''s `password_hash` from the database and uses `passwordEncoder.matches()` to securely compare it with the provided password. If validation is successful, it fetches the user''s permissions and returns a fully populated `User` object.\n    *   **`getPermissionsForUser(int userId)`**: Retrieves all permission keys for a given user.\n    *   **`updateUserPermissions(int userId, String[] permissionIds, Connection conn)`**: A transactional method that first deletes all of a user''s existing permissions and then batch-inserts the new set.\n    *   **`createUser(...)` / `updateUser(...)`**: Standard CRUD methods. `createUser` hashes the provided password before storing it.\n    *   **`changePassword(...)`**: Securely updates a user''s password by hashing the new password before saving it.'),
('src/main/java/de/technikteam/dao/UserQualificationsDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO manages the `user_qualifications` table, which links users to the courses they have attended or completed. It is the persistence layer for tracking user skills and qualifications.\n\n2.  **Architectural Role**\n\n    This class belongs to the **DAO (Data Access) Tier**. It is used by the `MatrixServlet` and `AdminAttendanceServlet` to update qualifications based on meeting attendance, and by the `ProfileServlet` to display a user''s qualifications.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `UserQualification` (Model).\n\n4.  **In-Depth Breakdown**\n\n    *   **`getQualificationsForUser(int userId)`**: Retrieves all qualifications for a single user.\n    *   **`getAllQualifications()`**: Fetches all qualification records for all users, primarily for building the data structures needed by the Qualification Matrix.\n    *   **`updateQualificationStatus(...)`**: The core update method. It uses an `INSERT ... ON DUPLICATE KEY UPDATE` statement (an \"upsert\") to create or update a qualification record. It also contains special logic: if the new status is `\"NICHT BESUCHT\"`, it deletes the record entirely instead of updating it.'),
('src/main/java/de/technikteam/dao/WikiDAO.java', '1.  **File Overview & Purpose**\n\n    This DAO is responsible for all database interactions with the `wiki_documentation` table. It provides full CRUD (Create, Read, Update, Delete) operations for managing the content of the technical documentation wiki pages.\n\n2.  **Architectural Role**\n\n    This class is part of the **DAO (Data Access) Tier**. It is used by the `WikiService` to load the documentation into its cache at startup, and by the various `Wiki` action classes to display and save changes to the wiki content.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `DatabaseManager`.\n    *   `DatabaseManager`: Provides database connections.\n    *   `WikiEntry` (Model): The data model object that this DAO creates and populates.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getWikiEntryById(int id)`**: Retrieves a single wiki page by its primary key.\n    *   **`getAllWikiEntries()`**: Fetches all wiki pages from the database, ordered by their file path. This is used by the `WikiService` to populate its initial cache.\n    *   **`updateWikiContent(int id, String content)`**: Updates the `content` field for a specific wiki entry.\n    *   **`createWikiEntry(WikiEntry entry)`**: Inserts a new documentation record into the database and returns the created object with its new ID.\n    *   **`deleteWikiEntry(int id)`**: Deletes a wiki documentation record from the database by its primary key.'),
('src/main/java/de/technikteam/service/AchievementService.java', '1.  **File Overview & Purpose**\n\n    This service class contains the business logic for checking and granting achievements to users based on specific trigger events. It decouples the achievement logic from the DAOs and the servlets where the triggering actions occur.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It is called by other components (like `AdminEventServlet` after an event is marked as ''ABGESCHLOSSEN'') to evaluate a user''s progress and potentially award new achievements. It coordinates between the `AchievementDAO` and other DAOs (`EventDAO`) to gather the necessary data for its checks.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `AchievementDAO` and `EventDAO`.\n    *   `AchievementDAO`: Used to check if a user already has an achievement and to grant new ones.\n    *   `EventDAO`: Used to fetch data about a user''s event history (participation count, leadership count).\n\n4.  **In-Depth Breakdown**\n\n    *   **`checkAndGrantAchievements(User user, String triggerType)`**\n        *   **Method Signature:** `public void checkAndGrantAchievements(User user, String triggerType)`\n        *   **Purpose:** The main entry point for the service. It acts as a router, calling specific check methods based on the `triggerType`.\n        *   **Parameters:**\n            *   `user` (User): The user whose achievements should be checked.\n            *   `triggerType` (String): A string identifying the event that triggered the check (e.g., \"EVENT_COMPLETED\").\n        *   **Side Effects:** Can lead to database writes via the `achievementDAO.grantAchievementToUser` method.\n\n    *   **`checkEventParticipationAchievements(User user)`**\n        *   **Method Signature:** `private void checkEventParticipationAchievements(User user)`\n        *   **Purpose:** Checks if the user has met the criteria for event participation achievements (e.g., 1, 5, or 10 completed events).\n        *   **Logic:** It fetches the number of completed events for the user from the `EventDAO` and then calls `achievementDAO.grantAchievementToUser` for each milestone the user has reached.\n        *   **Side Effects:** Database writes.\n\n    *   **`checkEventLeaderAchievements(User user)`**\n        *   **Method Signature:** `private void checkEventLeaderAchievements(User user)`\n        *   **Purpose:** Checks if the user has met the criteria for event leadership achievements.\n        *   **Logic:** It calculates the number of completed events where the user was the leader and grants the corresponding achievement if the criteria are met.\n        *   **Side Effects:** Database writes.'),
('src/main/java/de/technikteam/service/AdminDashboardService.java', '1.  **File Overview & Purpose**\n\n    This service class is responsible for aggregating all the data required for the administrative dashboard. It acts as a facade, coordinating calls to various DAOs to collect information for the different dashboard widgets (Upcoming Events, Low Stock, Recent Logs, Event Trend) and assembling it into a single `DashboardDataDTO`.\n\n2.  **Architectural Role**\n\n    This class belongs to the **Service Tier**. It encapsulates the business logic for what data should be displayed on the admin dashboard. It is called by the `AdminDashboardApiServlet` to provide the data needed for the dynamic, client-side rendering of the dashboard.\n\n3.  **Key Dependencies & Libraries**\n\n    *   `@Inject`: Injects the `EventDAO`, `StorageDAO`, `AdminLogDAO`, and `ReportDAO`.\n    *   `EventDAO`: Used to fetch upcoming events.\n    *   `StorageDAO`: Used to fetch items with low stock levels.\n    *   `AdminLogDAO`: Used to fetch the most recent log entries.\n    *   `ReportDAO`: Used to fetch the time-series data for the event trend chart.\n    *   `DashboardDataDTO` (Model): The Data Transfer Object this service populates and returns.\n\n4.  **In-Depth Breakdown**\n\n    *   **`getDashboardData()`**\n        *   **Method Signature:** `public DashboardDataDTO getDashboardData()`\n        *   **Purpose:** The single public method of this service. It orchestrates the data retrieval for the entire admin dashboard.\n        *   **Parameters:** None.\n        *   **Returns:** A fully populated `DashboardDataDTO` object containing all the data required by the dashboard''s widgets.\n        *   **Side Effects:** Performs multiple read operations on the database via the injected DAOs. It uses a `WIDGET_LIMIT` constant to control the number of items fetched for list-based widgets.');
COMMIT;