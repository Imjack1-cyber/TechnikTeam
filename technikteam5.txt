
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\OdfNodeFilter.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, NodeFilter, odf*/

/**
 * Class that filters runtime specific nodes from the DOM.
 * @constructor
 * @implements {xmldom.LSSerializerFilter}
 */
odf.OdfNodeFilter = function OdfNodeFilter() {
    "use strict";

    /**
     * @param {!Node} node
     * @return {!number}
     */
    this.acceptNode = function (node) {
        var result;
        if (node.namespaceURI === "http://www.w3.org/1999/xhtml") {
            result = NodeFilter.FILTER_SKIP;
        } else if (node.namespaceURI && node.namespaceURI.match(/^urn:webodf:/)) {
            // skip all webodf nodes incl. child nodes
            result = NodeFilter.FILTER_REJECT;
        } else {
            result = NodeFilter.FILTER_ACCEPT;
        }
        return result;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\OdfSchema.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, runtime*/

(function() {
    "use strict";

    /**
     * A collection of query interfaces to determine attributes about a node such as whether it
     * can contain text content, or is a field. This should be accessed via the singleton
     * instance "odf.OdfSchema".
     *
     * @constructor
     */
    odf.OdfSchemaImpl = function () {
        var TEXT = "text", // Editable & selectable text
            FIELD = "field", // Non-editable or selectable text
            OBJECT = "object", // Non-text object
            STYLE = "style", // Used only within document style definitions
            DEPRECATED = "deprecated", // Deprecated entity
            UNKNOWN = "uncategorized", // Uncategorized element
            // Basic list of containers originally created using tools/odfRng2Config.js
            // List has been hand-updated however, and should not simply be discarded!
            /**@type{!Array.<!Array.<!string, !string>>}*/
            containers = [
                ["config:config-item"                    , UNKNOWN],
                ["form:item"                             , OBJECT],
                ["form:option"                           , UNKNOWN],
                ["math:math"                             , FIELD],
                ["meta:user-defined"                     , UNKNOWN],
                ["number:currency-symbol"                , UNKNOWN],
                ["number:embedded-text"                  , UNKNOWN],
                ["number:text"                           , UNKNOWN],
                ["presentation:date-time-decl"           , UNKNOWN],
                ["presentation:footer-decl"              , UNKNOWN],
                ["presentation:header-decl"              , UNKNOWN],
                ["svg:desc"                              , TEXT],
                ["svg:title"                             , TEXT],
                ["table:desc"                            , UNKNOWN],
                ["table:title"                           , UNKNOWN],
                ["text:a"                                , TEXT],
                ["text:author-initials"                  , FIELD],
                ["text:author-name"                      , FIELD],
                ["text:bibliography-mark"                , FIELD],
                ["text:bookmark-ref"                     , FIELD],
                ["text:chapter"                          , FIELD],
                ["text:character-count"                  , FIELD],
                ["text:conditional-text"                 , FIELD],
                ["text:creation-date"                    , FIELD],
                ["text:creation-time"                    , FIELD],
                ["text:creator"                          , FIELD],
                ["text:database-display"                 , FIELD],
                ["text:database-name"                    , FIELD],
                ["text:database-row-number"              , FIELD],
                ["text:date"                             , FIELD],
                ["text:dde-connection"                   , FIELD],
                ["text:description"                      , FIELD],
                ["text:editing-cycles"                   , FIELD],
                ["text:editing-duration"                 , FIELD],
                ["text:execute-macro"                    , UNKNOWN],
                ["text:expression"                       , UNKNOWN],
                ["text:file-name"                        , FIELD],
                ["text:h"                                , TEXT],
                ["text:hidden-paragraph"                 , TEXT],
                ["text:hidden-text"                      , TEXT],
                ["text:image-count"                      , FIELD],
                ["text:index-entry-span"                 , UNKNOWN],
                ["text:index-title-template"             , UNKNOWN],
                ["text:initial-creator"                  , FIELD],
                ["text:keywords"                         , FIELD],
                ["text:linenumbering-separator"          , STYLE],
                ["text:measure"                          , UNKNOWN],
                ["text:meta"                             , UNKNOWN],
                ["text:meta-field"                       , UNKNOWN],
                ["text:modification-date"                , FIELD],
                ["text:modification-time"                , FIELD],
                ["text:note-citation"                    , FIELD],
                ["text:note-continuation-notice-backward", STYLE],
                ["text:note-continuation-notice-forward" , STYLE],
                ["text:note-ref"                         , FIELD],
                ["text:object-count"                     , FIELD],
                ["text:p"                                , TEXT],
                ["text:page-continuation"                , UNKNOWN],
                ["text:page-count"                       , FIELD],
                ["text:page-number"                      , FIELD],
                ["text:page-variable-get"                , FIELD],
                ["text:page-variable-set"                , FIELD],
                ["text:paragraph-count"                  , FIELD],
                ["text:placeholder"                      , FIELD],
                ["text:print-date"                       , FIELD],
                ["text:print-time"                       , FIELD],
                ["text:printed-by"                       , FIELD],
                ["text:reference-ref"                    , FIELD],
                ["text:ruby-base"                        , TEXT],
                ["text:ruby-text"                        , TEXT],
                ["text:script"                           , TEXT],
                ["text:sender-city"                      , FIELD],
                ["text:sender-company"                   , FIELD],
                ["text:sender-country"                   , FIELD],
                ["text:sender-email"                     , FIELD],
                ["text:sender-fax"                       , FIELD],
                ["text:sender-firstname"                 , FIELD],
                ["text:sender-initials"                  , FIELD],
                ["text:sender-lastname"                  , FIELD],
                ["text:sender-phone-private"             , FIELD],
                ["text:sender-phone-work"                , FIELD],
                ["text:sender-position"                  , FIELD],
                ["text:sender-postal-code"               , FIELD],
                ["text:sender-state-or-province"         , FIELD],
                ["text:sender-street"                    , FIELD],
                ["text:sender-title"                     , FIELD],
                ["text:sequence"                         , UNKNOWN],
                ["text:sequence-ref"                     , UNKNOWN],
                ["text:sheet-name"                       , UNKNOWN],
                ["text:span"                             , TEXT],
                ["text:subject"                          , FIELD],
                ["text:table-count"                      , FIELD],
                ["text:table-formula"                    , DEPRECATED],
                ["text:template-name"                    , UNKNOWN],
                ["text:text-input"                       , FIELD],
                ["text:time"                             , FIELD],
                ["text:title"                            , FIELD],
                ["text:user-defined"                     , FIELD],
                ["text:user-field-get"                   , FIELD],
                ["text:user-field-input"                 , FIELD],
                ["text:variable-get"                     , FIELD],
                ["text:variable-input"                   , FIELD],
                ["text:variable-set"                     , FIELD],
                ["text:word-count"                       , FIELD],
                ["xforms:model"                          , UNKNOWN]
            ],
            cache = {};

        /**
         * Returns true if the supplied namespace + localName can contain selectable/editable text
         * content.
         *
         * @param {!string} namespaceURI
         * @param {!string} localName
         * @return {!boolean}
         */
        this.isTextContainer = function (namespaceURI, localName) {
            return cache[namespaceURI + ":" + localName] === TEXT;
        };

        /**
         * Returns true if the supplied namespace + localName is an ODT field.
         *
         * @param {!string} namespaceURI
         * @param {!string} localName
         * @return {!boolean}
         */
        this.isField = function (namespaceURI, localName) {
            return cache[namespaceURI + ":" + localName] === FIELD;
        };

        /**
         * Return a list of all known ODF fields. These are prefixed with the standard prefixes.
         * E.g., ["text:author-name"]
         *
         * @return {!Array.<!string>}
         */
        this.getFields = function() {
            return containers.filter(function(containerInfo) { return containerInfo[1] === FIELD; })
                .map(function(containerInfo) { return containerInfo[0]; });
        };

        function init() {
            containers.forEach(function(containerInfo) {
                var name = containerInfo[0],
                    type = containerInfo[1],
                    nameParts = name.split(":"),
                    prefix = nameParts[0],
                    localName = nameParts[1],
                    namespaceURI = odf.Namespaces.lookupNamespaceURI(prefix);

                if (namespaceURI) {
                    cache[namespaceURI + ":" + localName] = type;
                } else {
                    runtime.log("DEBUG: OdfSchema - unknown prefix '" + prefix + "'");
                }
            });
        }
        init();
    };

    /**
     * @type {!odf.OdfSchemaImpl}
     */
    odf.OdfSchema = new odf.OdfSchemaImpl();
}());


========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\OdfUtils.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, runtime, odf, NodeFilter, core*/

/**
 * @constructor
 */
odf.OdfUtilsImpl = function OdfUtilsImpl() {
    "use strict";

    var /**@const
           @type{!string}*/
        textns = odf.Namespaces.textns,
        /**@const
           @type{!string}*/
        drawns = odf.Namespaces.drawns,
        /**@const
           @type{!string}*/
        xlinkns = odf.Namespaces.xlinkns,
        domUtils = core.DomUtils,
        // only add odf element namespaces here.
        // Namespaces solely used for attributes are excluded. eg. fo, xlink & xml
        odfNodeNamespaceMap = [
            odf.Namespaces.dbns,
            odf.Namespaces.dcns,
            odf.Namespaces.dr3dns,
            odf.Namespaces.drawns,
            odf.Namespaces.chartns,
            odf.Namespaces.formns,
            odf.Namespaces.numberns,
            odf.Namespaces.officens,
            odf.Namespaces.presentationns,
            odf.Namespaces.stylens,
            odf.Namespaces.svgns,
            odf.Namespaces.tablens,
            odf.Namespaces.textns
        ],
        odfSchema = odf.OdfSchema;

    /**
     * Determine if the node is a draw:image element.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isImage(e) {
        var name = e && e.localName;
        return name === "image" && e.namespaceURI === drawns;
    }
    this.isImage = isImage;

    /**
     * Determine if the node is a draw:frame element and has its text:anchor-type attribute set to 'as-char'.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isCharacterFrame(e) {
        // TODO the anchor-type can be defined on any style associated with the frame
        return e !== null && e.nodeType === Node.ELEMENT_NODE
            && e.localName === "frame" && e.namespaceURI === drawns
            && /**@type{!Element}*/(e).getAttributeNS(textns, "anchor-type")
                === "as-char";
    }
    this.isCharacterFrame = isCharacterFrame;

    /**
     * Determine if the node is an office:annotation element.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isAnnotation(e) {
        var name = e && e.localName;
        return name === "annotation" && e.namespaceURI === odf.Namespaces.officens;
    }

    /**
     * Determine if the node is an annotation wrapper element.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isAnnotationWrapper(e) {
        var name = e && e.localName;
        return name === "div" && /**@type{!HTMLDivElement}*/(e).className === "annotationWrapper";
    }

    /**
     * Determine if the node is an inline 'root' type,
     * i.e. an office:annotation or a wrapper for an annotaiton.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isInlineRoot(e) {
        return isAnnotation(e)
            || isAnnotationWrapper(e);
    }
    this.isInlineRoot = isInlineRoot;

    /**
     * Determine if the node is a text:span element.
     * @param {?Node} e
     * @return {!boolean}
     */
    this.isTextSpan = function (e) {
        var name = e && e.localName;
        return name === "span" && e.namespaceURI === textns;
    };

    /**
     * Determine if the node is a text:a element.
     * @param {?Node} node
     * @return {!boolean}
     */
    function isHyperlink(node) {
        var name = node && node.localName;
        return name === "a" && node.namespaceURI === textns;
    }
    this.isHyperlink = isHyperlink;

    /**
     * Gets the href attribute of text:a element
     * @param {!Element} element
     * @return {!string}
     */
    this.getHyperlinkTarget = function (element) {
        return element.getAttributeNS(xlinkns, 'href') || "";
    };

    /**
     * Determine if the node is a text:p or a text:h element.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isParagraph(e) {
        var name = e && e.localName;
        return (name === "p" || name === "h") && e.namespaceURI === textns;
    }
    this.isParagraph = isParagraph;

    /**
     * Find the paragraph containing the specified node. If an offset is provided and
     * the node has a child at the specified offset, this will be included in the search
     * as well if the supplied node is not a paragraph itself.
     * @param {?Node} node
     * @param {!number=} offset
     * @return {?Element}
     */
    function getParagraphElement(node, offset) {
        if (node && offset !== undefined && !isParagraph(node) && node.childNodes.item(offset)) {
            node = node.childNodes.item(offset);
        }
        while (node && !isParagraph(node)) {
            node = node.parentNode;
        }
        return /**@type{?Element}*/(node);
    }
    this.getParagraphElement = getParagraphElement;

    /**
     * @param {?Node} node  Node to start searching with
     * @param {!Element} container  Root container to stop searching at.
     * @return {?Element}
     */
    function getParentAnnotation(node, container) {
         while (node && node !== container) {
            if (node.namespaceURI === odf.Namespaces.officens && node.localName === 'annotation') {
                return /**@type{!Element}*/(node);
            }
            node = node.parentNode;
        }
        return null;
    }
    this.getParentAnnotation = getParentAnnotation;

    /**
     * @param {?Node} node  Node to start searching with
     * @param {!Element} container  Root container to stop searching at.
     * @return {!boolean}
     */
    this.isWithinAnnotation = function (node, container) {
        return Boolean(getParentAnnotation(node, container));
    };

    /**
     * Gets the creator of an annotation.
     * @param {!Element} annotationElement
     * @return {!string}
     */
    this.getAnnotationCreator = function (annotationElement) {
        var creatorElement = /**@type{!Element}*/(annotationElement.getElementsByTagNameNS(odf.Namespaces.dcns, "creator")[0]);
        return creatorElement.textContent;
    };

    /**
     * Determine if the node is a text:list-item element.
     * @param {?Node} e
     * @return {!boolean}
     */
    this.isListItem = function (e) {
        var name = e && e.localName;
        return name === "list-item" && e.namespaceURI === textns;
    };

    /**
     * Determine if the node is a text:line-break element.
     * @param {?Node} e
     * @return {!boolean}
     */
    this.isLineBreak = function (e) {
        var name = e && e.localName;
        return name === "line-break" && e.namespaceURI === textns;
    };

    /**
     * Determine if the text consists entirely of whitespace characters.
     * At least one whitespace is required.
     * @param {!string} text
     * @return {!boolean}
     */
    function isODFWhitespace(text) {
        return (/^[ \t\r\n]+$/).test(text);
    }
    this.isODFWhitespace = isODFWhitespace;

    /**
     * Determine if the node is a grouping element.
     * @param {?Node} n
     * @return {!boolean}
     */
    function isGroupingElement(n) {
        if (n === null || n.nodeType !== Node.ELEMENT_NODE) {
            return false;
        }
        var e = /**@type{!Element}*/(n),
            localName = e.localName;
        return odfSchema.isTextContainer(e.namespaceURI, localName)
               || (localName === "span" && e.className === "webodf-annotationHighlight");
    }
    this.isGroupingElement = isGroupingElement;

    /**
     * @param {?Node} n
     * @return {!boolean}
     */
    function isFieldElement(n) {
        if (n === null || n.nodeType !== Node.ELEMENT_NODE) {
            return false;
        }
        var e = /**@type{!Element}*/(n),
            localName = e.localName;
        return odfSchema.isField(e.namespaceURI, localName);
    }
    this.isFieldElement = isFieldElement;

    /**
     * Determine if the node is a character element,
     * namely "s", "tab", or "line-break".
     * @param {?Node} e
     * @return {!boolean}
     */
    function isCharacterElement(e) {
        var n = e && e.localName,
            ns,
            r = false;
        if (n) {
            ns = e.namespaceURI;
            if (ns === textns) {
                r = n === "s" || n === "tab" || n === "line-break";
            }
        }
        return r;
    }
    this.isCharacterElement = isCharacterElement;
    /**
     * Determine if the node is an 'as char' type of element,
     * i.e. any element which behaves like a character with
     * respect to it's surrounding positions, such as the
     * space/tab/line-break elements, draw:frames with
     * anchor type being 'as-char', or inline root elements
     * such as annotations.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isAnchoredAsCharacterElement(e) {
        return isCharacterElement(e) || isFieldElement(e) || isCharacterFrame(e) || isInlineRoot(e);
    }
    this.isAnchoredAsCharacterElement = isAnchoredAsCharacterElement;
    /**
     * Determine if the node is a <text:s/> character element.
     * @param {?Node} e
     * @return {!boolean}
     */
    function isSpaceElement(e) {
        var n = e && e.localName,
            ns,
            r = false;
        if (n) {
            ns = e.namespaceURI;
            if (ns === textns) {
                r = n === "s";
            }
        }
        return r;
    }
    this.isSpaceElement = isSpaceElement;

    /**
     * Returns true if the given node is an odf node
     * @param {!Node} node
     * @return {!boolean}
     */
    function isODFNode(node) {
        return odfNodeNamespaceMap.indexOf(node.namespaceURI) !== -1;
    }
    this.isODFNode = isODFNode;

    /**
     * Returns true if the supplied node contains no text-in-ODF, or ODF elements
     * @param {!Node} node
     * @return {!boolean}
     */
    function hasNoODFContent(node) {
        var childNode;
        if (isCharacterElement(node) || isFieldElement(node)) {
            return false;
        }
        if (isGroupingElement(/**@type{!Node}*/(node.parentNode)) && node.nodeType === Node.TEXT_NODE) {
            return node.textContent.length === 0;
        }
        childNode = node.firstChild;
        while (childNode) {
            if (isODFNode(childNode) || !hasNoODFContent(childNode)) {
                return false;
            }
            childNode = childNode.nextSibling;
        }
        return true;
    }
    this.hasNoODFContent= hasNoODFContent;

    /**
     * @param {!Node} node
     * @return {!Node}
     */
    function firstChild(node) {
        while (node.firstChild !== null && isGroupingElement(node)) {
            node = node.firstChild;
        }
        return node;
    }
    this.firstChild = firstChild;
    /**
     * @param {!Node} node
     * @return {!Node}
     */
    function lastChild(node) {
        while (node.lastChild !== null && isGroupingElement(node)) {
            node = node.lastChild;
        }
        return node;
    }
    this.lastChild = lastChild;
    /**
     * @param {!Node} node
     * @return {?Node}
     */
    function previousNode(node) {
        while (!isParagraph(node) && node.previousSibling === null) {
            node = /**@type{!Node}*/(node.parentNode);
        }
        return isParagraph(node) ? null : lastChild(/**@type{!Node}*/(node.previousSibling));
    }
    this.previousNode = previousNode;
    /**
     * @param {!Node} node
     * @return {?Node}
     */
    function nextNode(node) {
        while (!isParagraph(node) && node.nextSibling === null) {
            node = /**@type{!Node}*/(node.parentNode);
        }
        return isParagraph(node) ? null : firstChild(/**@type{!Node}*/(node.nextSibling));
    }
    this.nextNode = nextNode;

    /**
     * Walk to the left along the DOM and return true if the first thing
     * encountered is either a non-whitespace text character or a non-space
     * character element (i.e., any character element other than <text:s/>).
     * Walking goes through grouping elements.
     * @param {?Node} node the first node to scan
     * @return {!boolean}
     */
    function scanLeftForNonSpace(node) {
        var r = false,
            text;
        while (node) {
            if (node.nodeType === Node.TEXT_NODE) {
                text = /**@type{!Text}*/(node);
                if (text.length === 0) {
                    node = previousNode(text);
                } else {
                    return !isODFWhitespace(
                        text.data.substr(text.length - 1, 1)
                    );
                }
            } else if (isAnchoredAsCharacterElement(node)) {
                r = isSpaceElement(node) === false;
                node = null;
            } else {
                node = previousNode(node);
            }
        }
        return r;
    }
    this.scanLeftForNonSpace = scanLeftForNonSpace;
    /**
     * Walk to the left along the DOM and return the type of the first
     * thing encountered.
     * 0 none of the below
     * 1 non-whitespace character or a character element
     * 2 whitespace character that is preceded by a non-whitespace character
     *   or a character element
     *
     * @param {!Node} node the first node to scan
     * @return {!number}
     */
    function lookLeftForCharacter(node) {
        var text, r = 0, tl = 0;
        if (node.nodeType === Node.TEXT_NODE) {
            tl = /**@type{!Text}*/(node).length;
        }
        if (tl > 0) {
            text = /**@type{!Text}*/(node).data;
            if (!isODFWhitespace(text.substr(tl - 1, 1))) {
                r = 1; // character found
            } else if (tl === 1) {
                r = scanLeftForNonSpace(previousNode(node)) ? 2 : 0;
            } else {
                r = isODFWhitespace(text.substr(tl - 2, 1)) ? 0 : 2;
            }
        } else if (isAnchoredAsCharacterElement(node)) {
            r = 1;
        }
        return r;
    }
    this.lookLeftForCharacter = lookLeftForCharacter;
    /**
     * Look to the right along the DOM and return true if the first thing
     * encountered is either a non-whitespace character or a character
     * element.
     *
     * @param {?Node} node the first node to scan
     * @return {!boolean}
     */
    function lookRightForCharacter(node) {
        var r = false,
            l = 0;
        if (node && node.nodeType === Node.TEXT_NODE) {
            l = /**@type{!Text}*/(node).length;
        }
        if (l > 0) {
            r = !isODFWhitespace(/**@type{!Text}*/(node).data.substr(0, 1));
        } else if (isAnchoredAsCharacterElement(node)) {
            r = true;
        }
        return r;
    }
    this.lookRightForCharacter = lookRightForCharacter;
    /**
     * Walk to the left along the DOM and return true if either a
     * non-whitespace character or a character element is encountered.
     *
     * @param {?Node} node the first node to scan
     * @return {!boolean}
     */
    function scanLeftForAnyCharacter(node) {
        var r = false, l;
        node = node && lastChild(node);
        while (node) {
            if (node.nodeType === Node.TEXT_NODE) {
                l = /**@type{!Text}*/(node).length;
            } else {
                l = 0;
            }
            if (l > 0 && !isODFWhitespace(/**@type{!Text}*/(node).data)) {
                r = true;
                break;
            }
            if (isAnchoredAsCharacterElement(node)) {
                r = true;
                break;
            }
            node = previousNode(node);
        }
        return r;
    }
    this.scanLeftForAnyCharacter = scanLeftForAnyCharacter;
    /**
     * Walk to the right along the DOM and return true if either a
     * non-whitespace character or a character element is encountered.
     *
     * @param {?Node} node the first node to scan
     * @return {!boolean}
     */
    function scanRightForAnyCharacter(node) {
        var r = false, l;
        node = node && firstChild(node);
        while (node) {
            if (node.nodeType === Node.TEXT_NODE) {
                l = /**@type{!Text}*/(node).length;
            } else {
                l = 0;
            }
            if (l > 0 && !isODFWhitespace(/**@type{!Text}*/(node).data)) {
                r = true;
                break;
            }
            if (isAnchoredAsCharacterElement(node)) {
                r = true;
                break;
            }
            node = nextNode(node);
        }
        return r;
    }
    this.scanRightForAnyCharacter = scanRightForAnyCharacter;

    /**
     * check if the node is part of the trailing whitespace
     * @param {!Text} textnode
     * @param {!number} offset
     * @return {!boolean}
     */
    function isTrailingWhitespace(textnode, offset) {
        if (!isODFWhitespace(textnode.data.substr(offset))) {
            return false;
        }
        return !scanRightForAnyCharacter(nextNode(textnode));
    }
    this.isTrailingWhitespace = isTrailingWhitespace;

    /**
     * Takes a textNode and an offset, and returns true if the character
     * at that offset is a significant whitespace.
     *
     * Significant whitespace is defined as:
     * - Not part of the leading whitespace block in a paragraph
     * - Not part of the trailing whitespace block in a paragraph
     * - The first whitespace character after a text node or character
     *
     * All other whitespace elements are considered insignificant
     * @param {!Text} textNode
     * @param {!number} offset
     * @return {!boolean}
     */
    function isSignificantWhitespace(textNode, offset) {
        var text = textNode.data,
            result;

        if (!isODFWhitespace(text[offset])) {
            // Character is not whitespace
            return false;
        }

        if (isAnchoredAsCharacterElement(textNode.parentNode)) {
            // Parent is a character element, and therefore does not actually contain text
            // This prevents a space element from being upgraded again
            return false;
        }

        if (offset > 0) {
            if (!isODFWhitespace(text[offset - 1])) {
                // First whitespace after a character is significant
                result = true;
            }
        } else if (scanLeftForNonSpace(previousNode(textNode))) {
            // If the first character found scanning to the left is non-whitespace, this might still be significant
            result = true;
        }

        if (result === true) {
            return isTrailingWhitespace(textNode, offset)
                ? false : true;
        }
        return false;
    }
    this.isSignificantWhitespace = isSignificantWhitespace;

    /**
     * Returns true if the supplied node is a downgradeable space element.
     * As per http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#element-text_s
     * a downgradeable whitespace element is a space element that is immediately preceded by something other than a space
     * and has at least one non-space character after it
     * @param {!Node} node
     * @return {!boolean}
     */
    this.isDowngradableSpaceElement = function(node) {
        if (isSpaceElement(node)) {
            return scanLeftForNonSpace(previousNode(node)) && scanRightForAnyCharacter(nextNode(node));
        }
        return false;
    };

    /**
     * Returns the length split as value and unit, from an ODF attribute
     * @param {?string|undefined} length
     * @return {?{value:!number,unit:!string}}
     */
    function parseLength(length) {
        var re = /(-?[0-9]*[0-9][0-9]*(\.[0-9]*)?|0+\.[0-9]*[1-9][0-9]*|\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px)|(%))/,
            m = re.exec(length);
        if (!m) {
            return null;
        }
        return {value: parseFloat(m[1]), unit: m[3]};
    }
    this.parseLength = parseLength;

    /**
     * Returns the value and unit of the length, if it is positive ( > 0)
     * @param {?string|undefined} length
     * @return {?{value:!number,unit:!string}}
     */
    function parsePositiveLength(length) {
        var result = parseLength(length);
        if (result && (result.value <= 0 || result.unit === '%')) {
            return null;
        }
        return result;
    }

    /**
     * Returns the value and unit of the length, if it is non-negative ( >= 0)
     * @param {?string|undefined} length
     * @return {?{value:!number,unit:!string}}
     */
    function parseNonNegativeLength(length) {
        var result = parseLength(length);
        if (result && (result.value < 0 || result.unit === '%')) {
            return null;
        }
        return result;
    }
    this.parseNonNegativeLength = parseNonNegativeLength;

    /**
     * Returns the value and unit(%) of the length, if it is specified in %age
     * @param {?string|undefined} length
     * @return {?{value:!number,unit:!string}}
     */
    function parsePercentage(length) {
        var result = parseLength(length);
        if (result && (result.unit !== '%')) {
            return null;
        }
        return result;
    }

    /**
     * Returns the value and unit of the font size, in conformance with fo:font-size
     * constraints
     * @param {?string|undefined} fontSize
     * @return {?{value:!number,unit:!string}}
     */
    function parseFoFontSize(fontSize) {
        return parsePositiveLength(fontSize) || parsePercentage(fontSize);
    }
    this.parseFoFontSize = parseFoFontSize;

    /**
     * Returns the value and unit of the line height, in conformance with fo:line-height
     * constraints
     * @param {?string|undefined} lineHeight
     * @return {?{value:!number,unit:!string}}
     */
    function parseFoLineHeight(lineHeight) {
        return parseNonNegativeLength(lineHeight) || parsePercentage(lineHeight);
    }
    this.parseFoLineHeight = parseFoLineHeight;

    /**
     * Adapted from instructions on how to generate plain text from an ODT document.
     * See algorithm at http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1415196_253892949
     * @param {!Node} node
     * @return {boolean}
     */
    function isTextContentContainingNode(node) {
        switch (node.namespaceURI) {
            // Namespace skips
        case odf.Namespaces.drawns:
        case odf.Namespaces.svgns:
        case odf.Namespaces.dr3dns:
            return false;
        case odf.Namespaces.textns:
            // Specific node type skips
            //noinspection FallthroughInSwitchStatementJS
            switch (node.localName) {
            case 'note-body':
            case 'ruby-text':
                return false;
            }
            break;
        case odf.Namespaces.officens:
            // Specific node type skips
            //noinspection FallthroughInSwitchStatementJS
            switch (node.localName) {
            case 'annotation':
            case 'binary-data':
            case 'event-listeners':
                return false;
            }
            break;
        default:
            // Skip webodf edit markers or cursor information
            switch (node.localName) {
            case 'cursor':
            case 'editinfo':
                return false;
            }
            break;
        }
        return true;
    }
    this.isTextContentContainingNode = isTextContentContainingNode;

    /**
     * Returns true if the text node is within a paragraph and contains either non-whitespace characters, or
     * significant whitespace characters (as defined by the ODF standards).
     * WARNING this method is likely to be quite slow, so should be used as little as possible
     * @param {!Text} textNode
     * @return {!boolean}
     */
    function isSignificantTextContent(textNode) {
        return Boolean(getParagraphElement(textNode)
            && (!isODFWhitespace(textNode.textContent) || isSignificantWhitespace(textNode, 0)));
    }

    /**
     * Remove any nodes that aren't fully contained within the supplied range. This function assumes
     * the nodes appear in document order.
     * @param {!Range} range
     * @param {!Array.<!Node>} nodes
     * @return {undefined}
     */
    function removePartiallyContainedNodes(range, nodes) {
        while (nodes.length > 0 && !domUtils.rangeContainsNode(range, /**@type{!Node}*/(nodes[0]))) {
            nodes.shift();
        }
        while (nodes.length > 0 && !domUtils.rangeContainsNode(range, /**@type{!Node}*/(nodes[nodes.length - 1]))) {
            nodes.pop();
        }
    }

    /**
     * Returns a array of text nodes considered to be part of the supplied range.
     * This will exclude elements that are not part of the ODT main text body,
     * as well as insignificant whitespace text nodes.
     * @param {!Range} range    Range to search for nodes within
     * @param {boolean} includePartial Include partially intersecting text nodes
     *                                 in the result.
     * @return {!Array.<!Node>}
     */
    function getTextNodes(range, includePartial) {
        var textNodes;

        /**
         * @param {!Node} node
         * @return {number}
         */
        function nodeFilter(node) {
            var result = NodeFilter.FILTER_REJECT;
            if (node.nodeType === Node.TEXT_NODE) {
                if (isSignificantTextContent(/**@type{!Text}*/(node))) {
                    result = NodeFilter.FILTER_ACCEPT;
                }
            } else if (isTextContentContainingNode(node)) {
                result = NodeFilter.FILTER_SKIP;
            }
            return result;
        }

        /*jslint bitwise:true*/
        textNodes = domUtils.getNodesInRange(range, nodeFilter, NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_TEXT);
        /*jslint bitwise:false*/
        if (!includePartial) {
            removePartiallyContainedNodes(range, textNodes);
        }

        return textNodes;
    }
    this.getTextNodes = getTextNodes;

    /**
     * Get all character elements and text nodes fully contained within the
     * supplied range in document order.
     *
     * For example, given the following fragment, with the range starting at b,
     * and ending at c:
     *      <text:p>ab<text:s/>cd</text:p>
     * this function would return the following array:
     *      ["b", text:s, "c"]
     * @param {!Range} range
     * @param {!boolean} includePartial Include partially intersecting text &
     *                         character nodes in the result.
     * @param {!boolean} includeInsignificantWhitespace Include whitespace only
     *                         nodes that are not considered significant text
     *                         content. This includes whitespace only elements
     *                         used in pretty-formatted xml as LibreOffice
     *                         produces in flat ODT files.
     * @return {!Array.<!Element|!Text>}
     */
    function getTextElements(range, includePartial, includeInsignificantWhitespace) {
        var elements;

        /**
         * @param {!Node} node
         * @return {number}
         */
        function nodeFilter(node) {
            var result = NodeFilter.FILTER_REJECT;
            // do not return anything inside an character element or an inline root such as an annotation
            if (isCharacterElement(node.parentNode) || isFieldElement(node.parentNode) || isInlineRoot(node)) {
                result = NodeFilter.FILTER_REJECT;
            } else if (node.nodeType === Node.TEXT_NODE) {
                if (includeInsignificantWhitespace || isSignificantTextContent(/**@type{!Text}*/(node))) {
                        // Text nodes should only be returned if they are
                        // fully contained within the range.
                    result = NodeFilter.FILTER_ACCEPT;
                }
            } else if (isAnchoredAsCharacterElement(node)) {
                // Character elements should only be returned if they are
                // fully contained within the range.
                result =  NodeFilter.FILTER_ACCEPT;
            } else if (isTextContentContainingNode(node) || isGroupingElement(node)) {
                result =  NodeFilter.FILTER_SKIP;
            }
            return result;
        }

        /*jslint bitwise:true*/
        elements = domUtils.getNodesInRange(range, nodeFilter, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);
        /*jslint bitwise:false*/
        if (!includePartial) {
            removePartiallyContainedNodes(range, elements);
        }

        return elements;
    }
    this.getTextElements = getTextElements;

    /**
     * Crawl parent nodes starting at the startContainer until a matching node is found,
     * or the first inline root is met. If a node is accepted by the supplied filter, and is
     * not already the first element in the elements array, this node is prepended to the start
     * of the elements array.
     *
     * @param {!Node} startContainer Container to start search from (inclusive)
     * @param {!Array.<!Node>} elements Existing elements already discovered
     * @param {!function(!Node):!boolean} filter
     */
    function prependParentContainers(startContainer, elements, filter) {
        var container = startContainer;
        while (container) {
            if (filter(container)) {
                if (elements[0] !== container) {
                    elements.unshift(container);
                }
                break;
            }
            if (isInlineRoot(container)) {
                break;
            }
            container = container.parentNode;
        }
    }

    /**
     * Get all paragraph elements that intersect the supplied range in document
     * order.
     *
     * For example, given the following fragment, with the range starting at b,
     * and ending at c:
     *      <text:p id="A">ab</text:p><text:p id="B"><text:s/>cd</text:p>
     * this function would return the following array:
     *      [text:p{id="A"}, text:p{id="B"}]
     * @param {!Range} range
     * @return {!Array.<!Element>}
     */
    this.getParagraphElements = function (range) {
        var elements;
        /**
         * @param {!Node} node
         * @return {number}
         */
        function nodeFilter(node) {
            var result = NodeFilter.FILTER_REJECT;
            if (isParagraph(node)) {
                result = NodeFilter.FILTER_ACCEPT;
            } else if (isTextContentContainingNode(node) || isGroupingElement(node)) {
                result = NodeFilter.FILTER_SKIP;
            }
            return result;
        }

        elements = domUtils.getNodesInRange(range, nodeFilter, NodeFilter.SHOW_ELEMENT);
        // getNodesInRange will only return nodes it enters during the iteration.
        // However, we desire all paragraph nodes either contained OR containing this range,
        // so we crawl the parentNodes of the start container until a root is found.

        // Note, this isn't necessary for the end container because iteration crosses the
        // node boundary when entering towards the end container, meaning all paragraphs in
        // the end container's parentNodes will be reported by getNodesInRange.
        prependParentContainers(/**@type{!Node}*/(range.startContainer), elements, isParagraph);
        return elements;
    };

    /**
     * Get all image elements that fully contained within the supplied range in
     * document order.
     * @param {!Range} range
     * @return {!Array.<Node>}
     */
    this.getImageElements = function (range) {
        var elements;

        /**
         * @param {!Node} node
         * @return {number}
         */
        function nodeFilter(node) {
            var result = NodeFilter.FILTER_SKIP;
            if (isImage(node)) {
                result = NodeFilter.FILTER_ACCEPT;
            }
            return result;
        }

        elements = domUtils.getNodesInRange(range, nodeFilter, NodeFilter.SHOW_ELEMENT);
        // See description in getParagraphElements as to why this is necessary
        // Short summary: want to include images that completely contain this range
        prependParentContainers(/**@type{!Node}*/(range.startContainer), elements, isImage);
        return elements;
    };

    /**
     * Returns the node right after the given point.
     * @param {!Node} container
     * @param {!number} offset
     * @return {!Node}
     */
    function getRightNode(container, offset) {
        var node = container;
        if (offset < node.childNodes.length - 1) {
            node = /** @type {!Node} */(node.childNodes[offset + 1]);
        } else {
            while (!node.nextSibling) {
                node = node.parentNode;
            }
            node = node.nextSibling;
        }
        while (node.firstChild) {
            node = node.firstChild;
        }
        return node;
    }

    /**
     * Get all hyperlink elements that intersect the supplied range in document order
     *
     * For example, given the following fragment, with the range starting at b, and ending at c:
     *      <text:a xlink:href="google">ab</text:a><text:a xlink:href="apple">cd</text:a>
     * this function would return the following array:
     *      [text:a{xlink:href="google"}, text:a{xlink:href="apple"}]
     * @param {!Range} range
     * @return {!Array.<Node>}
     */
    this.getHyperlinkElements = function (range) {
        var links = [],
            newRange = /** @type {!Range}*/(range.cloneRange()),
            node,
            textNodes;

        if (range.collapsed && range.endContainer.nodeType === Node.ELEMENT_NODE) {
            node = getRightNode(range.endContainer, range.endOffset);
            if (node.nodeType === Node.TEXT_NODE) {
                newRange.setEnd(node, 1);
            }
        }

        textNodes = getTextElements(newRange, true, false);
        textNodes.forEach(function (node) {
            var parent = node.parentNode;
            while (!isParagraph(parent)) {
                if (isHyperlink(parent) && links.indexOf(parent) === -1) {
                    links.push(parent);
                    break;
                }
                parent = parent.parentNode;
            }
        });
        newRange.detach();
        return links;
    };

    /**
     * Normalize the font-family name as defined in
     * http://www.w3.org/TR/2008/REC-CSS2-20080411/fonts.html#propdef-font-family
     * (see there text behind: "There are two types of font family names: <family-name>")
     * @param {!string} fontFamilyName
     * @return {!string}
     */
    /*jslint regexp: true*/
    this.getNormalizedFontFamilyName = function(fontFamilyName) {
        // not quoted with either single- or double-quotes?
        // (\n & \r are syntactically okay as whitespaces, so need to be accepted as well)
        //     ^(["'])        -> match either " or ' at begin (and store match)
        //     (?:.|[\n\r])*? -> match non-greedy any number of any char or \r and \n
        //     \1$            -> match content of first match at end
        if (!(/^(["'])(?:.|[\n\r])*?\1$/).test(fontFamilyName)) {
            // remove any whitespaces at begin and end of full name (ignore internal yet)
            //     ^[ \t\r\n\f]*    -> match whitespace at begin
            //     ((?:.|[\n\r])*?) -> match non-greedy any number of any char or \r and \n (and store match)
            //     [ \t\r\n\f]*$    -> match whitespace at end
            fontFamilyName = fontFamilyName.replace(/^[ \t\r\n\f]*((?:.|[\n\r])*?)[ \t\r\n\f]*$/, "$1");
            // if there is any internal whitespace, reduce it to just one normal whitespace per group
            // and add quotes around the full name
            // (quotes should be only added if there is whitespace inside, as the passed fontFamilyName could
            // be a generic-family one, which must not be quoted)
            if ((/[ \t\r\n\f]/).test(fontFamilyName)) {
                fontFamilyName = "'" + fontFamilyName.replace(/[ \t\r\n\f]+/g, " ") + "'";
            }
        }
        return fontFamilyName;
    };
    /*jslint regexp: false*/
};

/**
 * @type {!odf.OdfUtilsImpl}
 */
odf.OdfUtils = new odf.OdfUtilsImpl();
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\PageLayoutProperties.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/

/**
 * @constructor
 * @param {?Element} element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.PageLayoutProperties|undefined} parent
 */
odf.PageLayoutProperties = function (element, styleParseUtils, parent) {
    "use strict";
    var self = this,
        fons = odf.Namespaces.fons,
        getter;
    getter = {
        pageHeight: function () {
            var a, value;
            if (element) {
                a = element.getAttributeNS(fons, "page-height");
                value = styleParseUtils.parseLength(a);
            }
            return value;
        },
        pageWidth: function () {
            var a, value;
            if (element) {
                a = element.getAttributeNS(fons, "page-width");
                value = styleParseUtils.parseLength(a);
            }
            return value;
        }
    };
    /**
     * @return {!number}
     */
    this.pageHeight = function () {
        return /**@type{!number|undefined}*/(self.data.value("pageHeight"))
                || 1123; // A4 height
    };
    /**
     * @return {!number}
     */
    this.pageWidth = function () {
        return /**@type{!number|undefined}*/(self.data.value("pageWidth"))
                || 794; // A4 width
    };
    /**
     * @type {!odf.LazyStyleProperties|undefined}
     */
    this.data;
    function init() {
        var p = parent === undefined ? undefined : parent.data;
        self.data = new odf.LazyStyleProperties(p, getter);
    }
    init();
};
/**
 * @constructor
 * @param {?Element} element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.PageLayout=} parent
 */
odf.PageLayout = function (element, styleParseUtils, parent) {
    "use strict";
    var self = this;
    /**
     * @type {!odf.PageLayoutProperties}
     */
    this.pageLayout;
    function init() {
        var e = null;
        if (element) {
            e = styleParseUtils.getPropertiesElement("page-layout-properties",
                 element);
        }
        self.pageLayout = new odf.PageLayoutProperties(e, styleParseUtils,
                (parent && parent.pageLayout));
    }
    init();
};
/*jslint emptyblock: true, unparam: true*/
/**
 * @interface
 */
odf.PageLayoutCache = function () {"use strict"; };
/**
 * @param {!string} name
 * @return {!odf.PageLayout}
 */
odf.PageLayoutCache.prototype.getPageLayout = function (name) {"use strict"; };
/**
 * @return {!odf.PageLayout}
 */
odf.PageLayoutCache.prototype.getDefaultPageLayout = function () {"use strict"; };
/*jslint emptyblock: false, unparam: false*/

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\ParagraphProperties.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/

/**
 * @constructor
 * @param {!Element} element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.ParagraphProperties|undefined} parent
 */
odf.ParagraphProperties = function (element, styleParseUtils, parent) {
    "use strict";
    var self = this,
        fons = odf.Namespaces.fons,
        getter;
    getter = {
        marginTop: function () {
            var a = element.getAttributeNS(fons, "margin-top"),
                value = styleParseUtils.parsePositiveLengthOrPercent(a,
                    "marginTop", parent && parent.data);
            return value;
        }
    };
    /**
     * @return {!number|undefined}
     */
    this.marginTop = function () {
        return /**@type{!number|undefined}*/(self.data.value("marginTop"));
    };
    /**
     * @type {!odf.LazyStyleProperties}
     */
    this.data;
    function init() {
        var p = parent === undefined ? undefined : parent.data;
        self.data = new odf.LazyStyleProperties(p, getter);
    }
    init();
};
/**
 * @constructor
 */
odf.ComputedParagraphProperties = function () {
    "use strict";
    var /**@type{!Object.<!string,*>}*/
        data = {},
        /**@type{!Array.<!odf.ParagraphProperties>}*/
        styleChain = [];
    /**
     * @param {!string} name
     * @return {*}
     */
    function value(name) {
        var v, i;
        if (data.hasOwnProperty(name)) {
            v = data[name];
        } else {
            for (i = 0; v === undefined && i < styleChain.length; i += 1) {
                v = /**@type{!function():*}*/(styleChain[i][name])();
            }
            data[name] = v;
        }
        return v;
    }
    /**
     * @param {!Array.<!odf.ParagraphProperties>} newStyleChain
     * @return {undefined}
     */
    this.setStyleChain = function setStyleChain(newStyleChain) {
        styleChain = newStyleChain;
        data = {};
    };
    /**
     * @return {!number}
     */
    this.marginTop = function () {
        return /**@type{!number}*/(value("marginTop")) || 0;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\StepUtils.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf, Node*/

/**
 * Helper functions to retrieve information about an ODF document using a step iterator
 * @constructor
 */
odf.StepUtils = function StepUtils() {
    "use strict";

    /**
     * Fetch the content bounds related to the step iterator's current position. This will return the text element, or
     * the content element immediately to the left of the step. Will return undefined if there is no content to the left
     * of the step.
     *
     * @param {!core.StepIterator} stepIterator
     * @return {!{container: !Node, startOffset: !number, endOffset: !number}|undefined}
     */
    function getContentBounds(stepIterator) {
        var container = stepIterator.container(),
            offset,
            contentBounds;

        runtime.assert(stepIterator.isStep(), "Step iterator must be on a step");
        // A step is to the left of the corresponding text content according to the TextPositionFilter.
        if (container.nodeType === Node.TEXT_NODE && stepIterator.offset() > 0) {
            offset = stepIterator.offset();
        } else {
            // If the container is not a text node, the content is expected to be found in the node to the left of the
            // current position.
            container = stepIterator.leftNode();
            if (container && container.nodeType === Node.TEXT_NODE) {
                offset = /**@type{!Text}*/(container).length;
            }
        }

        if (container) {
            if (container.nodeType === Node.TEXT_NODE) {
                // Based on the above logic, if the text offset is 0, the container to the left should have been
                // used instead.
                runtime.assert(offset > 0, "Empty text node found");
                contentBounds = {
                    container: container,
                    startOffset: /**@type{!number}*/(offset) - 1,
                    endOffset: /**@type{!number}*/(offset)
                };
            } else {
                contentBounds = {
                    container: container,
                    startOffset: 0,
                    endOffset: container.childNodes.length
                };
            }
        }

        return contentBounds;
    }
    this.getContentBounds = getContentBounds;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\Style2CSS.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, runtime, xmldom, core, document*/

/**
 * @constructor
 */
odf.Style2CSS = function Style2CSS() {
    "use strict";
    var // helper constants
        /**@const
           @type{!string}*/
        drawns = odf.Namespaces.drawns,
        /**@const
           @type{!string}*/
        fons = odf.Namespaces.fons,
        /**@const
           @type{!string}*/
        officens = odf.Namespaces.officens,
        /**@const
           @type{!string}*/
        stylens = odf.Namespaces.stylens,
        /**@const
           @type{!string}*/
        svgns = odf.Namespaces.svgns,
        /**@const
           @type{!string}*/
        tablens = odf.Namespaces.tablens,
        /**@const
           @type{!string}*/
        xlinkns = odf.Namespaces.xlinkns,
        /**@const
           @type{!string}*/
        presentationns = odf.Namespaces.presentationns,
        /**@const
         * @type {!string}*/
        webodfhelperns = "urn:webodf:names:helper",
        domUtils = core.DomUtils,
        styleParseUtils = new odf.StyleParseUtils(),

        /**@const
           @type{!Object.<string,string>}*/
        familynamespaceprefixes = {
            'graphic': 'draw',
            'drawing-page': 'draw',
            'paragraph': 'text',
            'presentation': 'presentation',
            'ruby': 'text',
            'section': 'text',
            'table': 'table',
            'table-cell': 'table',
            'table-column': 'table',
            'table-row': 'table',
            'text': 'text',
            'list': 'text',
            'page': 'office'
        },

        /**@const
           @type{!Object.<string,!Array.<!string>>}*/
        familytagnames = {
            'graphic': ['circle', 'connected', 'control', 'custom-shape',
                'ellipse', 'frame', 'g', 'line', 'measure', 'page',
                'page-thumbnail', 'path', 'polygon', 'polyline', 'rect',
                'regular-polygon' ],
            'paragraph': ['alphabetical-index-entry-template', 'h',
                'illustration-index-entry-template', 'index-source-style',
                'object-index-entry-template', 'p',
                'table-index-entry-template', 'table-of-content-entry-template',
                'user-index-entry-template'],
            'presentation': ['caption', 'circle', 'connector', 'control',
                'custom-shape', 'ellipse', 'frame', 'g', 'line', 'measure',
                'page-thumbnail', 'path', 'polygon', 'polyline', 'rect',
                'regular-polygon'],
            'drawing-page': ['caption', 'circle', 'connector', 'control', 'page',
                'custom-shape', 'ellipse', 'frame', 'g', 'line', 'measure',
                'page-thumbnail', 'path', 'polygon', 'polyline', 'rect',
                'regular-polygon'],
            'ruby': ['ruby', 'ruby-text'],
            'section': ['alphabetical-index', 'bibliography',
                'illustration-index', 'index-title', 'object-index', 'section',
                'table-of-content', 'table-index', 'user-index'],
            'table': ['background', 'table'],
            'table-cell': ['body', 'covered-table-cell', 'even-columns',
                'even-rows', 'first-column', 'first-row', 'last-column',
                'last-row', 'odd-columns', 'odd-rows', 'table-cell'],
            'table-column': ['table-column'],
            'table-row': ['table-row'],
            'text': ['a', 'index-entry-chapter', 'index-entry-link-end',
                'index-entry-link-start', 'index-entry-page-number',
                'index-entry-span', 'index-entry-tab-stop', 'index-entry-text',
                'index-title-template', 'linenumbering-configuration',
                'list-level-style-number', 'list-level-style-bullet',
                'outline-level-style', 'span'],
            'list': ['list-item']
        },

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        textPropertySimpleMapping = [
            [ fons, 'color', 'color' ],
            // this sets the element background, not just the text background
            [ fons, 'background-color', 'background-color' ],
            [ fons, 'font-weight', 'font-weight' ],
            [ fons, 'font-style', 'font-style' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        bgImageSimpleMapping = [
            [ stylens, 'repeat', 'background-repeat' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        paragraphPropertySimpleMapping = [
            [ fons, 'background-color', 'background-color' ],
            [ fons, 'text-align', 'text-align' ],
            [ fons, 'text-indent', 'text-indent' ],
            [ fons, 'padding', 'padding' ],
            [ fons, 'padding-left', 'padding-left' ],
            [ fons, 'padding-right', 'padding-right' ],
            [ fons, 'padding-top', 'padding-top' ],
            [ fons, 'padding-bottom', 'padding-bottom' ],
            [ fons, 'border-left', 'border-left' ],
            [ fons, 'border-right', 'border-right' ],
            [ fons, 'border-top', 'border-top' ],
            [ fons, 'border-bottom', 'border-bottom' ],
            [ fons, 'margin', 'margin' ],
            [ fons, 'margin-left', 'margin-left' ],
            [ fons, 'margin-right', 'margin-right' ],
            [ fons, 'margin-top', 'margin-top' ],
            [ fons, 'margin-bottom', 'margin-bottom' ],
            [ fons, 'border', 'border' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        graphicPropertySimpleMapping = [
            [ fons, 'background-color', 'background-color'],
            [ fons, 'min-height', 'min-height' ],
            [ drawns, 'stroke', 'border' ],
            [ svgns, 'stroke-color', 'border-color' ],
            [ svgns, 'stroke-width', 'border-width' ],
            [ fons, 'border', 'border' ],
            [ fons, 'border-left', 'border-left' ],
            [ fons, 'border-right', 'border-right' ],
            [ fons, 'border-top', 'border-top' ],
            [ fons, 'border-bottom', 'border-bottom' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        tablecellPropertySimpleMapping = [
            [ fons, 'background-color', 'background-color' ],
            [ fons, 'border-left', 'border-left' ],
            [ fons, 'border-right', 'border-right' ],
            [ fons, 'border-top', 'border-top' ],
            [ fons, 'border-bottom', 'border-bottom' ],
            [ fons, 'border', 'border' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        tablecolumnPropertySimpleMapping = [
            [ stylens, 'column-width', 'width' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        tablerowPropertySimpleMapping = [
            [ stylens, 'row-height', 'height' ],
            [ fons, 'keep-together', null ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        tablePropertySimpleMapping = [
            [ stylens, 'width', 'width' ],
            [ fons, 'margin-left', 'margin-left' ],
            [ fons, 'margin-right', 'margin-right' ],
            [ fons, 'margin-top', 'margin-top' ],
            [ fons, 'margin-bottom', 'margin-bottom' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        pageContentPropertySimpleMapping = [
            [ fons, 'background-color', 'background-color' ],
            [ fons, 'padding', 'padding' ],
            [ fons, 'padding-left', 'padding-left' ],
            [ fons, 'padding-right', 'padding-right' ],
            [ fons, 'padding-top', 'padding-top' ],
            [ fons, 'padding-bottom', 'padding-bottom' ],
            [ fons, 'border', 'border' ],
            [ fons, 'border-left', 'border-left' ],
            [ fons, 'border-right', 'border-right' ],
            [ fons, 'border-top', 'border-top' ],
            [ fons, 'border-bottom', 'border-bottom' ],
            [ fons, 'margin', 'margin' ],
            [ fons, 'margin-left', 'margin-left' ],
            [ fons, 'margin-right', 'margin-right' ],
            [ fons, 'margin-top', 'margin-top' ],
            [ fons, 'margin-bottom', 'margin-bottom' ]
        ],

        /**@const
           @type{!Array.<!Array.<!string>>}*/
        pageSizePropertySimpleMapping = [
            [ fons, 'page-width', 'width' ],
            [ fons, 'page-height', 'height' ]
        ],

        /**@const
           @type{!Object.<!boolean>}*/
        borderPropertyMap = {
            'border': true,
            'border-left': true,
            'border-right': true,
            'border-top': true,
            'border-bottom': true,
            'stroke-width': true
        },

        /**@const
           @type{!Object.<!boolean>}*/
        marginPropertyMap = {
            'margin': true,
            'margin-left': true,
            'margin-right': true,
            'margin-top': true,
            'margin-bottom': true
        },

        // A font-face declaration map, to be populated once style2css is called.
        /**@type{!Object.<string,string>}*/
        fontFaceDeclsMap = {},
        utils = odf.OdfUtils,
        documentType,
        odfRoot,
        defaultFontSize,
        xpath = xmldom.XPath,
        cssUnits = new core.CSSUnits();

    /**
     * @param {!string} family
     * @param {!string} name
     * @return {?string}
     */
    function createSelector(family, name) {
        var prefix = familynamespaceprefixes[family],
            namepart,
            selector;
        if (prefix === undefined) {
            return null;
        }

        // If there is no name, it is a default style, in which case style-name shall be used without a value
        if (name) {
            namepart = '[' + prefix + '|style-name="' + name + '"]';
        } else {
            namepart = '';
        }
        if (prefix === 'presentation') {
            prefix = 'draw';
            if (name) {
                namepart = '[presentation|style-name="' + name + '"]';
            } else {
                namepart = '';
            }
        }
        selector = prefix + '|' + familytagnames[family].join(
            namepart + ',' + prefix + '|'
        ) + namepart;
        return selector;
    }
    /**
     * @param {!string} family
     * @param {!string} name
     * @param {!odf.StyleTreeNode} node
     * @return {!Array.<string>}
     */
    function getSelectors(family, name, node) {
        var selectors = [], ss,
            derivedStyles = node.derivedStyles,
            /**@type{string}*/
            n;
        ss = createSelector(family, name);
        if (ss !== null) {
            selectors.push(ss);
        }
        for (n in derivedStyles) {
            if (derivedStyles.hasOwnProperty(n)) {
                ss = getSelectors(family, n, derivedStyles[n]);
                selectors = selectors.concat(ss);
            }
        }
        return selectors;
    }
    /**
     * Make sure border width is no less than 1px wide; otherwise border is not rendered.
     * Only have problems with point unit at the moment. Please add more rule if needed.
     * @param {!string} value a string contains border attributes eg. 1pt solid black or 1px
     * @return {!string}
     */
    function fixBorderWidth(value) {
        var index = value.indexOf(' '),
            width, theRestOfBorderAttributes;

        if (index !== -1) {
            width = value.substring(0, index);
            theRestOfBorderAttributes = value.substring(index); // everything after the width attribute
        } else {
            width = value;
            theRestOfBorderAttributes = '';
        }

        width = utils.parseLength(width);
        // According to CSS 2.1, 1px is equal to 0.75pt http://www.w3.org/TR/CSS2/syndata.html#length-units
        if (width && width.unit === 'pt' && width.value < 0.75) {
            value = '0.75pt' + theRestOfBorderAttributes;
        }
        return value;
    }

    /**
     * Returns the parent style node of a given style node
     * @param {!Element} styleNode
     * @return {Element}
     */
    function getParentStyleNode(styleNode) {
        var parentStyleName = '',
            parentStyleFamily = '',
            parentStyleNode = null,
            xp;

        if (styleNode.localName === 'default-style') {
            return null;
        }

        parentStyleName = styleNode.getAttributeNS(stylens, 'parent-style-name');
        parentStyleFamily = styleNode.getAttributeNS(stylens, 'family');

        if (parentStyleName) {
            xp = "//style:*[@style:name='" + parentStyleName + "'][@style:family='" + parentStyleFamily + "']";
        } else {
            xp = "//style:default-style[@style:family='" + parentStyleFamily + "']";
        }
        parentStyleNode = xpath.getODFElementsWithXPath(/**@type{!Element}*/(odfRoot), xp, odf.Namespaces.lookupNamespaceURI)[0];
        return parentStyleNode;
    }

    /**
     * Margins can be a percentage of the parent style. Resolve to
     * absolute value.
     *
     * See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1419838_253892949
     * for further information.
     *
     * @param {!Element} props
     * @param {!string} namespace to use when looking up attributes in parents
     * @param {!string} name of attribute to lookup in parents
     * @param {!string} value a string contains margin attributes eg. 1px
     * @return {!string}
     */
    function fixMargin(props, namespace, name, value) {
        var length = utils.parseLength(value),
            multiplier,
            parentStyle,
            parentLength,
            result,
            properties;
        if (!length || length.unit !== '%') {
            return value;
        }

        // margin is defined as percentage, traverse up until we find a
        // non-percentage value. If no parent has a non-percentage value,
        // no margin will be used.
        multiplier = (length.value / 100);
        parentStyle = getParentStyleNode(/**@type{!Element}*/(props.parentNode));
        result = "0";
        while (parentStyle) {
            properties = domUtils.getDirectChild(parentStyle, stylens, 'paragraph-properties');
            if (properties) {
                parentLength = utils.parseLength(properties.getAttributeNS(namespace, name));
                if (parentLength) {
                    if (parentLength.unit !== '%') {
                        result = (parentLength.value * multiplier) + parentLength.unit;
                        break;
                    }
                    multiplier *= (parentLength.value / 100);
                }
            }
            parentStyle = getParentStyleNode(parentStyle);
        }
        return result;
    }

    /**
     * @param {!Element} props
     * @param {!Array.<!Array.<!string>>} mapping
     * @return {!string}
     */
    function applySimpleMapping(props, mapping) {
        var rule = '', i, r, value;
        for (i = 0; i < mapping.length; i += 1) {
            r = mapping[i];
            value = props.getAttributeNS(r[0], r[1]);

            if (value) {
                value = value.trim();

                if (borderPropertyMap.hasOwnProperty(r[1])) {
                    value = fixBorderWidth(value);
                } else if (marginPropertyMap.hasOwnProperty(r[1])) {
                    value = fixMargin(props, r[0], r[1], value);
                }
                if (r[2]) {
                    rule += r[2] + ':' + value + ';';
                }
            }
        }
        return rule;
    }

    /**
     * Returns the font size attribute value from the text properties of a style node
     * @param {?Element} styleNode
     * @return {?{value: !number, unit: !string}}
     */
    function getFontSize(styleNode) {
        var props = domUtils.getDirectChild(styleNode, stylens, 'text-properties');
        if (props) {
            return utils.parseFoFontSize(props.getAttributeNS(fons, 'font-size'));
        }
        return null;
    }

    /**
     * Parse the style:text-position property
     * http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1420212_253892949
     *
     * Examples:
     * "sub"
     * "super 20%"
     * "10% 20%"
     * "-15% 50%"
     *
     * @param {!string} position
     * @return {!{verticalTextPosition: !string, fontHeight: (!string|undefined)}}
     */
    function parseTextPosition(position) {
        var parts = styleParseUtils.parseAttributeList(position);
        return {
            verticalTextPosition: parts[0],
            fontHeight: parts[1]
        };
    }
    /**
     * @param {!Element} props
     * @return {!string}
     */
    function getTextProperties(props) {
        var rule = '',
            fontName,
            fontSize,
            value,
            textDecorationLine = '',
            textDecorationStyle = '',
            textPosition,
            fontSizeRule = '',
            sizeMultiplier = 1,
            textFamilyStyleNode;

        rule += applySimpleMapping(props, textPropertySimpleMapping);

        value = props.getAttributeNS(stylens, 'text-underline-style');
        if (value === 'solid') {
            textDecorationLine += ' underline';
        }
        value = props.getAttributeNS(stylens, 'text-line-through-style');
        if (value === 'solid') {
            textDecorationLine += ' line-through';
        }

        if (textDecorationLine.length) {
            // CSS2
            rule += 'text-decoration:' + textDecorationLine + ';\n';
            // CSS3 text-decoration shorthand
            rule += 'text-decoration-line:' + textDecorationLine + ';\n';
            // CSS3 text-decoration shorthand - FF
            rule += '-moz-text-decoration-line:' + textDecorationLine + ';\n';
        }

        value = props.getAttributeNS(stylens, 'text-line-through-type');
        switch (value) {
            case 'double':
                textDecorationStyle += ' double';
                break;
            case 'single':
                textDecorationStyle += ' single';
                break;
        }
        if (textDecorationStyle) {
            // CSS3
            rule += 'text-decoration-style:' + textDecorationStyle + ';\n';
            // CSS3 text-decoration shorthand - FF
            rule += '-moz-text-decoration-style:' + textDecorationStyle + ';\n';
        }

        fontName = props.getAttributeNS(stylens, 'font-name')
            || props.getAttributeNS(fons, 'font-family');
        if (fontName) {
            value = fontFaceDeclsMap[fontName];
            // TODO: use other information from style:font-face, like style:font-family-generic
            rule += 'font-family: ' + (value || fontName) + ';';
        }

        value = props.getAttributeNS(stylens, 'text-position');
        if (value) {
            textPosition = parseTextPosition(value);
            rule += 'vertical-align: ' + textPosition.verticalTextPosition + '\n; ';
            if (textPosition.fontHeight) {
                sizeMultiplier = parseFloat(textPosition.fontHeight) / 100;
            }
        }

        if (props.hasAttributeNS(fons, "font-size") || sizeMultiplier !== 1) {
            // This is actually the font size of the current style.
            textFamilyStyleNode = /**@type{!Element}*/(props.parentNode);
            while (textFamilyStyleNode) {
                fontSize = getFontSize(textFamilyStyleNode);
                if (fontSize) {
                    // If the current style's font size is a non-% value, then apply the multiplier to get the child style (with the %)'s
                    // actual font size. And now we can stop crawling up the style ancestry since we have a concrete font size.
                    if (fontSize.unit !== '%') {
                        fontSizeRule = 'font-size: ' + (fontSize.value * sizeMultiplier) + fontSize.unit + ';';
                        break;
                    }
                    // If we got a % font size for the current style, then update the multiplier with it's 'normalized' multiplier
                    sizeMultiplier *= (fontSize.value / 100);
                }
                // Crawl up the style ancestry
                textFamilyStyleNode = getParentStyleNode(textFamilyStyleNode);
            }
            // If there was nothing in the ancestry that specified a concrete font size, just apply the multiplier onto the page's default font size.
            if (!fontSizeRule) {
                fontSizeRule = 'font-size: ' + parseFloat(defaultFontSize) * sizeMultiplier + cssUnits.getUnits(defaultFontSize) + ';';
            }
        }

        rule += fontSizeRule;

        return rule;
    }
    /**
     * @param {!Element} props <style:paragraph-properties/>
     * @return {!string}
     */
    function getParagraphProperties(props) {
        var rule = '', bgimage, url, lineHeight;
        rule += applySimpleMapping(props, paragraphPropertySimpleMapping);
        bgimage = domUtils.getDirectChild(props, stylens, 'background-image');
        if (bgimage) {
            url = bgimage.getAttributeNS(xlinkns, 'href');
            if (url) {
                rule += "background-image: url('odfkit:" + url + "');";
                //rule += "background-repeat: repeat;"; //FIXME test
                rule += applySimpleMapping(bgimage, bgImageSimpleMapping);
            }
        }

        lineHeight = props.getAttributeNS(fons, 'line-height');
        if (lineHeight && lineHeight !== 'normal') {
            lineHeight = utils.parseFoLineHeight(lineHeight);
            if (lineHeight.unit !== '%') {
                rule += 'line-height: ' + lineHeight.value + lineHeight.unit + ';';
            } else {
                rule += 'line-height: ' + lineHeight.value / 100 + ';';
            }
        }

        return rule;
    }

/*jslint unparam: true*/
    /**
     * @param {*} m
     * @param {string} r
     * @param {string} g
     * @param {string} b
     * @return {string}
     */
    function matchToRgb(m, r, g, b) {
        return r + r + g + g + b + b;
    }
/*jslint unparam: false*/

    /**
     * @param {!string} hex
     * @return {?{ r: number, g: number, b: number}}
     */
    function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var result,
            shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, matchToRgb);

        result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    /**
     * @param {string} n
     * @return {boolean}
     */
    function isNumber(n) {
        return !isNaN(parseFloat(n));
    }

   /**
     * @param {!Element} props
     * @return {string}
     */
    function getGraphicProperties(props) {
        var rule = '', alpha, bgcolor, fill;

        rule += applySimpleMapping(props, graphicPropertySimpleMapping);
        alpha = props.getAttributeNS(drawns, 'opacity');
        fill = props.getAttributeNS(drawns, 'fill');
        bgcolor = props.getAttributeNS(drawns, 'fill-color');

        if (fill === 'solid' || fill === 'hatch') {
            if (bgcolor && bgcolor !== 'none') {
                alpha = isNumber(alpha) ? parseFloat(alpha) / 100 : 1;
                bgcolor = hexToRgb(bgcolor);
                if (bgcolor) {
                    rule += "background-color: rgba("
                        + bgcolor.r + ","
                        + bgcolor.g + ","
                        + bgcolor.b + ","
                        + alpha + ");";
                }
            } else {
                rule += "background: none;";
            }
        } else if (fill === "none") {
            rule += "background: none;";
        }

        return rule;
    }
   /**
     * @param {!Element} props
     * @return {string}
     */
    function getDrawingPageProperties(props) {
        var rule = '';

        rule += applySimpleMapping(props, graphicPropertySimpleMapping);
        if (props.getAttributeNS(presentationns, 'background-visible') === 'true') {
            rule += "background: none;";
        }
        return rule;
    }
    /**
     * @param {!Element} props
     * @return {string}
     */
    function getTableCellProperties(props) {
        var rule = '';
        rule += applySimpleMapping(props, tablecellPropertySimpleMapping);
        return rule;
    }
    /**
     * @param {!Element} props
     * @return {string}
     */
    function getTableRowProperties(props) {
        var rule = '';
        rule += applySimpleMapping(props, tablerowPropertySimpleMapping);
        return rule;
    }
    /**
     * @param {!Element} props
     * @return {string}
     */
    function getTableColumnProperties(props) {
        var rule = '';
        rule += applySimpleMapping(props, tablecolumnPropertySimpleMapping);
        return rule;
    }
    /**
     * @param {!Element} props
     * @return {string}
     */
    function getTableProperties(props) {
        var rule = '', borderModel;
        rule += applySimpleMapping(props, tablePropertySimpleMapping);
        borderModel = props.getAttributeNS(tablens, 'border-model');

        if (borderModel === 'collapsing') {
            rule += 'border-collapse:collapse;';
        } else if (borderModel === 'separating') {
            rule += 'border-collapse:separate;';
        }

        return rule;
    }

    /**
     * Gets a list with the names of all styles derived from the given style,
     * including the name of the style itself.
     * @param {!string} styleName
     * @param {!odf.StyleTreeNode} node
     * @return {!Array.<!string>}
     */
    function getDerivedStyleNames(styleName, node) {
        var /** @type{!Array.<!string>} */
            styleNames = [styleName],
            derivedStyles = node.derivedStyles;

        Object.keys(derivedStyles).forEach(function(styleName) {
            var dsn = getDerivedStyleNames(styleName, derivedStyles[styleName]);
            styleNames = styleNames.concat(dsn);
        });

        return styleNames;
    }

    /**
     * Adds rules to control the display of certain frame classes in master pages
     * when shown in page using the master page.
     * @param {!CSSStyleSheet} sheet
     * @param {!string} styleName
     * @param {!Element} properties
     * @param {!odf.StyleTreeNode} node
     * @return {undefined}
     */
    function addDrawPageFrameDisplayRules(sheet, styleName, properties, node) {
        var /**@const
               @type {!Array.<!string>}*/
            frameClasses = ["page-number", "date-time", "header", "footer"],
            styleNames = getDerivedStyleNames(styleName, node),
            /**@type {!Array.<!string>}*/
            visibleFrameClasses = [],
            /**@type {!Array.<!string>}*/
            invisibleFrameClasses = [];

        /**
         * @param {!Array.<!string>} controlledFrameClasses
         * @param {!string} visibility
         * @return {undefined}
         */
        function insertFrameVisibilityRule(controlledFrameClasses, visibility) {
            var selectors = [],
                rule;
            controlledFrameClasses.forEach(function(frameClass) {
                styleNames.forEach(function(styleName) {
                    selectors.push('draw|page[webodfhelper|page-style-name="'+styleName+'"] draw|frame[presentation|class="'+frameClass+'"]');
                });
            });
            if (selectors.length > 0) {
                rule = selectors.join(",") + "{visibility:"+visibility+";}";
                sheet.insertRule(rule, sheet.cssRules.length);
            }
        }

        frameClasses.forEach(function(frameClass) {
            var displayValue;

            displayValue = properties.getAttributeNS(presentationns, 'display-'+frameClass);
            if (displayValue === 'true') {
                visibleFrameClasses.push(frameClass);
            } else if (displayValue === 'false') {
                invisibleFrameClasses.push(frameClass);
            } // else the attribute does not exist (returned as ""/null) or has a bad value

        });

        insertFrameVisibilityRule(visibleFrameClasses, "visible");
        insertFrameVisibilityRule(invisibleFrameClasses, "hidden");
    }

    /**
     * @param {!CSSStyleSheet} sheet
     * @param {string} family
     * @param {string} name
     * @param {!odf.StyleTreeNode} node
     * @return {undefined}
     */
    function addStyleRule(sheet, family, name, node) {
        var selectors = getSelectors(family, name, node),
            selector = selectors.join(','),
            rule = '',
            properties;

        properties = domUtils.getDirectChild(node.element, stylens, 'text-properties');
        if (properties) {
            rule += getTextProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                stylens, 'paragraph-properties');
        if (properties) {
            rule += getParagraphProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'graphic-properties');
        if (properties) {
            rule += getGraphicProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'drawing-page-properties');
        if (properties) {
            rule += getDrawingPageProperties(properties);
            addDrawPageFrameDisplayRules(sheet, name, /**@type{!Element}*/(properties), node);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'table-cell-properties');
        if (properties) {
            rule += getTableCellProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'table-row-properties');
        if (properties) {
            rule += getTableRowProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'table-column-properties');
        if (properties) {
            rule += getTableColumnProperties(properties);
        }
        properties = domUtils.getDirectChild(node.element,
                 stylens, 'table-properties');
        if (properties) {
            rule += getTableProperties(properties);
        }
        if (rule.length === 0) {
            return;
        }
        rule = selector + '{' + rule + '}';
        sheet.insertRule(rule, sheet.cssRules.length);
    }

    /**
     * @param {!CSSStyleSheet} sheet
     * @param {!Element} node <style:page-layout/>/<style:default-page-layout/>
     * @return {undefined}
     */
    function addPageStyleRules(sheet, node) {
        var rule = '', imageProps, url,
            contentLayoutRule = '',
            pageSizeRule = '',
            props = domUtils.getDirectChild(node, stylens, 'page-layout-properties'),
            stylename,
            masterStyles,
            e,
            masterStyleName;
        if (!props) {
            return;
        }
        stylename = node.getAttributeNS(stylens, 'name');

        rule += applySimpleMapping(props, pageContentPropertySimpleMapping);
        imageProps = domUtils.getDirectChild(props, stylens, 'background-image');
        if (imageProps) {
            url = imageProps.getAttributeNS(xlinkns, 'href');
            if (url) {
                rule += "background-image: url('odfkit:" + url + "');";
                //rule += "background-repeat: repeat;"; //FIXME test
                rule += applySimpleMapping(imageProps, bgImageSimpleMapping);
            }
        }

        if (documentType === 'presentation') {
            masterStyles = domUtils.getDirectChild(/**@type{!Element}*/(node.parentNode.parentNode), officens, 'master-styles');
            e = masterStyles && masterStyles.firstElementChild;
            while (e) {
                // Generate CSS for all the pages that use the master page that use this page-layout
                if (e.namespaceURI === stylens && e.localName === "master-page"
                        && e.getAttributeNS(stylens, 'page-layout-name')
                            === stylename) {
                    masterStyleName = e.getAttributeNS(stylens, 'name');

                    contentLayoutRule = 'draw|page[draw|master-page-name="' + masterStyleName + '"] {' + rule + '}';
                    pageSizeRule = 'office|body, draw|page[draw|master-page-name="' + masterStyleName + '"] {'
                            + applySimpleMapping(props, pageSizePropertySimpleMapping)
                            + ' }';

                    sheet.insertRule(contentLayoutRule, sheet.cssRules.length);
                    sheet.insertRule(pageSizeRule, sheet.cssRules.length);
                }
                e = e.nextElementSibling;
            }

        } else if (documentType === 'text') {
            contentLayoutRule = 'office|text {' + rule + '}';
            rule = '';

            // TODO: We want to use the simpleMapping for ODTs, but not until we have pagination.
            // So till then, set only the width.
            //rule += applySimpleMapping(props, pageSizePropertySimpleMapping);
            pageSizeRule = 'office|body {'
                + 'width: ' + props.getAttributeNS(fons, 'page-width') + ';'
                + '}';

            sheet.insertRule(contentLayoutRule, sheet.cssRules.length);
            sheet.insertRule(pageSizeRule, sheet.cssRules.length);
        }

    }

    /**
     * @param {!CSSStyleSheet} sheet
     * @param {string} family
     * @param {string} name
     * @param {!odf.StyleTreeNode} node
     * @return {undefined}
     */
    function addRule(sheet, family, name, node) {
        if (family === "page") {
            addPageStyleRules(sheet, node.element);
        } else {
            addStyleRule(sheet, family, name, node);
        }
    }
    /**
     * @param {!CSSStyleSheet} sheet
     * @param {string} family
     * @param {string} name
     * @param {!odf.StyleTreeNode} node
     * @return {undefined}
     */
    function addRules(sheet, family, name, node) {
        addRule(sheet, family, name, node);
        var /**@type{string}*/
            n;
        for (n in node.derivedStyles) {
            if (node.derivedStyles.hasOwnProperty(n)) {
                addRules(sheet, family, n, node.derivedStyles[n]);
            }
        }
    }

    // css vs odf styles
    // ODF styles occur in families. A family is a group of odf elements to
    // which an element applies. ODF families can be mapped to a group of css
    // elements

    /**
     * @param {!string} doctype
     * @param {!Element} rootNode
     * @param {!CSSStyleSheet} stylesheet
     * @param {!Object.<string,string>} fontFaceMap
     * @param {!Object.<string,!Object.<string,!odf.StyleTreeNode>>} styleTree
     * @return {undefined}
     */
    this.style2css = function (doctype, rootNode, stylesheet, fontFaceMap, styleTree) {
        var tree, rule,
            /**@type{string}*/
            name,
            /**@type{string}*/
            family;

        /**
         * @param {!string} prefix
         * @param {!string} ns
         * @return {undefined}
         */
        function insertCSSNamespace(prefix, ns) {
            rule = '@namespace ' + prefix + ' url(' + ns + ');';
            try {
                stylesheet.insertRule(rule, stylesheet.cssRules.length);
            } catch (/**@type{!DOMException}*/ignore) {
                // WebKit can throw an exception here, but it will have
                // retained the namespace declarations anyway.
            }
        }

        odfRoot = rootNode;

        // make stylesheet empty
        while (stylesheet.cssRules.length) {
            stylesheet.deleteRule(stylesheet.cssRules.length - 1);
        }

        // add @odfRoot namespace rules
        odf.Namespaces.forEachPrefix(insertCSSNamespace);
        insertCSSNamespace("webodfhelper", webodfhelperns);

        fontFaceDeclsMap = fontFaceMap;
        documentType = doctype;
        defaultFontSize = runtime.getWindow().getComputedStyle(document.body, null).getPropertyValue('font-size') || '12pt';

        // add the various styles
        for (family in familynamespaceprefixes) {
            if (familynamespaceprefixes.hasOwnProperty(family)) {
                tree = styleTree[family];
                for (name in tree) {
                    if (tree.hasOwnProperty(name)) {
                        addRules(stylesheet, family, name, tree[name]);
                    }
                }
            }
        }
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\StyleCache.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/
/*jslint emptyblock: false, unparam: false*/

/**
 * @constructor
 * @param {?Element} element
 * @param {!odf.PageLayoutCache} pageLayoutCache
 */
odf.MasterPage = function (element, pageLayoutCache) {
    "use strict";
    var self = this;
    /**
     * @type {!odf.PageLayout}
     */
    this.pageLayout;
    function init() {
        var pageLayoutName;
        if (element) {
            pageLayoutName = element.getAttributeNS(odf.Namespaces.stylens,
                    "page-layout-name");
            self.pageLayout = pageLayoutCache.getPageLayout(pageLayoutName);
        } else {
            self.pageLayout = pageLayoutCache.getDefaultPageLayout();
        }
    }
    init();
};
/*jslint emptyblock: true, unparam: true*/
/**
 * @interface
 */
odf.MasterPageCache = function () {"use strict"; };
/**
 * @param {!string} name
 * @return {?odf.MasterPage}
 */
odf.MasterPageCache.prototype.getMasterPage = function (name) {"use strict"; };
/*jslint emptyblock: false, unparam: false*/
/**
 * @constructor
 * @param {!Element} element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.MasterPageCache} masterPageCache
 * @param {!odf.StylePileEntry=} parent
 */
odf.StylePileEntry = function (element, styleParseUtils, masterPageCache, parent) {
    "use strict";
    /**
     * @type {!odf.TextProperties|undefined}
     */
    this.text;
    /**
     * @type {!odf.ParagraphProperties|undefined}
     */
    this.paragraph;
    /**
     * @type {!odf.GraphicProperties|undefined}
     */
    this.graphic;
    /**
     * @return {?odf.MasterPage}
     */
    this.masterPage = function () {
        var masterPageName = element.getAttributeNS(odf.Namespaces.stylens,
                    "master-page-name"),
            masterPage = null;
        if (masterPageName) {
            masterPage = masterPageCache.getMasterPage(masterPageName);
        }
        return masterPage;
    };
    /**
     * @param {!odf.StylePileEntry} self
     * @return {undefined}
     */
    function init(self) {
        var stylens = odf.Namespaces.stylens,
            family = element.getAttributeNS(stylens, "family"),
            e = null;
        if (family === "graphic" || family === "chart") {
            self.graphic = parent === undefined ? undefined : parent.graphic;
            e = styleParseUtils.getPropertiesElement("graphic-properties", element, e);
            if (e !== null) {
                self.graphic = new odf.GraphicProperties(e, styleParseUtils,
                    self.graphic);
            }
        }
        if (family === "paragraph" || family === "table-cell"
                || family === "graphic" || family === "presentation"
                || family === "chart") {
            self.paragraph = parent === undefined ? undefined : parent.paragraph;
            e = styleParseUtils.getPropertiesElement("paragraph-properties", element, e);
            if (e !== null) {
                self.paragraph = new odf.ParagraphProperties(e, styleParseUtils,
                    self.paragraph);
            }
        }
        if (family === "text" || family === "paragraph"
                || family === "table-cell" || family === "graphic"
                || family === "presentation" || family === "chart") {
            self.text = parent === undefined ? undefined : parent.text;
            e = styleParseUtils.getPropertiesElement("text-properties", element, e);
            if (e !== null) {
                self.text = new odf.TextProperties(e, styleParseUtils, self.text);
            }
        }
    }
    init(this);
};
/**
 * Collection of all the styles in the document for one style family.
 * There are separate style piles for family 'text', 'paragraph', 'graphic' etc.
 * @constructor
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.MasterPageCache} masterPageCache
 */
odf.StylePile = function (styleParseUtils, masterPageCache) {
    "use strict";
    var stylens = odf.Namespaces.stylens,
        /**@type{!Object.<!string,!Element>}*/
        commonStyles = {},
        /**@type{!Object.<!string,!Element>}*/
        automaticStyles = {},
        /**@type{!odf.StylePileEntry|undefined}*/
        defaultStyle,
        /**@type{!Object.<!string,!odf.StylePileEntry>}*/
        parsedCommonStyles = {},
        /**@type{!Object.<!string,!odf.StylePileEntry>}*/
        parsedAutomaticStyles = {},
        /**@type{!function(!string,!Array.<!string>):(!odf.StylePileEntry|undefined)}*/
        getCommonStyle;
    /**
     * @param {!Element} element
     * @param {!Array.<!string>} visitedStyles track visited styles to avoid loops
     * @return {!odf.StylePileEntry}
     */
    function parseStyle(element, visitedStyles) {
        var parent,
            parentName,
            style;
        if (element.hasAttributeNS(stylens, "parent-style-name")) {
            parentName = element.getAttributeNS(stylens, "parent-style-name");
            if (visitedStyles.indexOf(parentName) === -1) {
                parent = getCommonStyle(parentName, visitedStyles);
            }
        }
        style = new odf.StylePileEntry(element, styleParseUtils, masterPageCache, parent);
        return style;
    }
    /**
     * @param {!string} styleName
     * @param {!Array.<!string>} visitedStyles track visited styles to avoid loops
     * @return {!odf.StylePileEntry|undefined}
     */
    getCommonStyle = function (styleName, visitedStyles) {
        var style = parsedCommonStyles[styleName],
            element;
        if (!style) {
            element = commonStyles[styleName];
            if (element) {
                visitedStyles.push(styleName);
                style = parseStyle(element, visitedStyles);
                parsedCommonStyles[styleName] = style;
            }
        }
        return style;
    };
    /**
     * @param {!string} styleName
     * @return {!odf.StylePileEntry|undefined}
     */
    function getStyle(styleName) {
        var style = parsedAutomaticStyles[styleName]
                || parsedCommonStyles[styleName],
            element,
            visitedStyles = [];
        if (!style) {
            element = automaticStyles[styleName];
            if (!element) {
                element = commonStyles[styleName];
                if (element) {
                    visitedStyles.push(styleName);
                }
            }
            if (element) {
                style = parseStyle(element, visitedStyles);
            }
        }
        return style;
    }
    this.getStyle = getStyle;
    /**
     * @param {!Element} style
     * @return {undefined}
     */
    this.addCommonStyle = function (style) {
        var name;
        if (style.hasAttributeNS(stylens, "name")) {
            name = style.getAttributeNS(stylens, "name");
            if (!commonStyles.hasOwnProperty(name)) {
                commonStyles[name] = style;
            }
        }
    };
    /**
     * @param {!Element} style
     * @return {undefined}
     */
    this.addAutomaticStyle = function (style) {
        var name;
        if (style.hasAttributeNS(stylens, "name")) {
            name = style.getAttributeNS(stylens, "name");
            if (!automaticStyles.hasOwnProperty(name)) {
                automaticStyles[name] = style;
            }
        }
    };
    /**
     * @param {!Element} style
     * @return {undefined}
     */
    this.setDefaultStyle = function (style) {
        if (defaultStyle === undefined) {
            defaultStyle = parseStyle(style, []);
        }
    };
    /**
     * @return {!odf.StylePileEntry|undefined}
     */
    this.getDefaultStyle = function () {
        return defaultStyle;
    };
};
/**
 * @constructor
 */
odf.ComputedGraphicStyle = function () {
    "use strict";
    /**
     * @type {!odf.ComputedTextProperties}
     */
    this.text = new odf.ComputedTextProperties();
    /**
     * @type {!odf.ComputedParagraphProperties}
     */
    this.paragraph = new odf.ComputedParagraphProperties();
    /**
     * @type {!odf.ComputedGraphicProperties}
     */
    this.graphic = new odf.ComputedGraphicProperties();
};
/**
 * @constructor
 */
odf.ComputedParagraphStyle = function () {
    "use strict";
    /**
     * @type {!odf.ComputedTextProperties}
     */
    this.text = new odf.ComputedTextProperties();
    /**
     * @type {!odf.ComputedParagraphProperties}
     */
    this.paragraph = new odf.ComputedParagraphProperties();
};
/**
 * @constructor
 */
odf.ComputedTextStyle = function () {
    "use strict";
    /**
     * @type {!odf.ComputedTextProperties}
     */
    this.text = new odf.ComputedTextProperties();
};
/**
 * Fast and type-safe access to styling properties of an ODF document.
 * When the document changes, update() has to be called to update the
 * information.
 *
 * This class gives access to computed styles. The term 'computed' is used
 * similarly to its use in the DOM function window.getComputedStyle().
 * In ODF, as in CSS but differently, the evaluation of styles is influenced by
 * the position of an element in a document. Specifically, the types and styles
 * of the ancestor elements determine properties of a style. This is explained
 * in chapter 16 of the ODF 1.2 specification.
 *   http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1416272_253892949
 *
 * Here is an example. Consider the following style and content:
   <s:styles>
     <s:default-style s:family="text">...</s:default-style>
     <s:default-style s:family="paragraph">...</s:default-style>
     <s:style s:name="Standard" s:family="text">...</s:style>
     <s:style s:name="Bold" s:parent-style-name="Standard" s:family="text">...</s:style>
     <s:style s:name="Standard" s:family="paragraph">...</s:style>
   </s:styles>
   <s:automatic-styles>
     <s:style s:name="T1" s:parent-style-name="Standard" s:family="text">...</s:style>
     <s:style s:name="T2" s:parent-style-name="Bold" s:family="text">...</s:style>
     <s:style s:name="C1" s:parent-style-name="Standard" s:family="text">...</s:style>
     <s:style s:name="C2" s:parent-style-name="Standard" s:family="text">...</s:style>
     <s:style s:name="P1" s:parent-style-name="Standard" s:family="paragraph">...</s:style>
   </s:automatic-styles>
   ...
   <text:p text:style-name="P1">
     <text:span text:style-name="T1" text:class-names="C1 C2">
       <text:span text:style-name="T2">
         hello
       </text:span>
     </text:span>
   </text:p>

 * The style properties for the word 'hello' are looked for, in order, in this
 * list of styles:
 *   text:T2
 *     text:Bold
 *       text:Standard
 *   text:T1
 *     text:Standard
 *   text:C1
 *     text:Standard
 *   text:C2
 *     text:Standard
 *   paragraph:P1
 *     paragraph:Standard
 *       paragraph-document-default
 *         paragraph-implementation-default
 *
 * The style names can be concatenated into a key. The parent styles are not
 * needed in the key. For the above example, the key is:
 *   text/T2/text/T1/text/C1/text/C2/paragraph/P1
 * StyleCache creates computed style objects on demand and caches them.
 *
 * StyleCache also provides convenient access to page layout and master page
 * information.
 * Each property of the style objects has a valid value even if the underlying
 * XML element or attribute is missing or invalid.
 *
 * @constructor
 * @implements {odf.MasterPageCache}
 * @implements {odf.PageLayoutCache}
 * @param {!odf.ODFDocumentElement} odfroot
 */
odf.StyleCache = function (odfroot) {
    "use strict";
    var self = this,
        /**@type{!{text:!odf.StylePile,paragraph:!odf.StylePile}}*/
        stylePiles,
        /**@type{!Object.<!string,!odf.ComputedTextStyle>}*/
        textStyleCache,
        /**@type{!Object.<!string,!odf.ComputedParagraphStyle>}*/
        paragraphStyleCache,
        /**@type{!Object.<!string,!odf.ComputedGraphicStyle>}*/
        graphicStyleCache,
        /**@type{!odf.StylePile}*/
        textStylePile,
        /**@type{!odf.StylePile}*/
        paragraphStylePile,
        /**@type{!odf.StylePile}*/
        graphicStylePile,
        textns = odf.Namespaces.textns,
        stylens = odf.Namespaces.stylens,
        styleInfo = new odf.StyleInfo(),
        styleParseUtils = new odf.StyleParseUtils(),
        /**@type{!Object.<!string,!Element>}*/
        masterPages,
        /**@type{!Object.<!string,!odf.MasterPage>}*/
        parsedMasterPages,
        /**@type{!odf.MasterPage}*/
        defaultMasterPage,
        /**@type{!odf.PageLayout}*/
        defaultPageLayout,
        /**@type{!Object.<!string,!Element>}*/
        pageLayouts,
        /**@type{!Object.<!string,!odf.PageLayout>}*/
        parsedPageLayouts;
    /**
     * @param {!string} family
     * @param {!string} ns
     * @param {!Element} element
     * @param {!Array.<!string>} chain
     * @return {undefined}
     */
    function appendClassNames(family, ns, element, chain) {
        var names = element.getAttributeNS(ns, "class-names"),
            stylename,
            i;
        if (names) {
            names = names.split(" ");
            for (i = 0; i < names.length; i += 1) {
                stylename = names[i];
                if (stylename) {
                    chain.push(family);
                    chain.push(stylename);
                }
            }
        }
    }
    /**
     * @param {!Element} element
     * @param {!Array.<!string>} chain
     * @return {!Array.<!string>}
     */
    function getGraphicStyleChain(element, chain) {
        var stylename = styleInfo.getStyleName("graphic", element);
        if (stylename !== undefined) {
            chain.push("graphic");
            chain.push(stylename);
        }
        return chain;
    }
    /**
     * @param {!Element} element
     * @param {!Array.<!string>} chain
     * @return {!Array.<!string>}
     */
    function getParagraphStyleChain(element, chain) {
        var stylename = styleInfo.getStyleName("paragraph", element);
        if (stylename !== undefined) {
            chain.push("paragraph");
            chain.push(stylename);
        }
        // text:p and text:h can have text:class-names
        if (element.namespaceURI === textns &&
                (element.localName === "h" || element.localName === "p")) {
            appendClassNames("paragraph", textns, element, chain);
        }
        return chain;
    }
    /**
     * @param {!Array.<!string>} styleChain
     * @param {!string} propertiesName
     * @param {!string} defaultFamily
     * @return {!Array.<!Object>}
     */
    function createPropertiesChain(styleChain, propertiesName, defaultFamily) {
        var chain = [], i, lastProperties, family, styleName, pile, style,
            properties;
        for (i = 0; i < styleChain.length; i += 2) {
            family =  styleChain[i];
            styleName = styleChain[i + 1];
            pile = /**@type{!odf.StylePile}*/(stylePiles[family]);
            style = pile.getStyle(styleName);
            if (style !== undefined) {
                properties = /**@type{!Object|undefined}*/(style[propertiesName]);
                if (properties !== undefined && properties !== lastProperties) {
                    chain.push(properties);
                    lastProperties = properties;
                }
            }
        }
        pile = /**@type{!odf.StylePile}*/(stylePiles[defaultFamily]);
        style = pile.getDefaultStyle();
        if (style) {
            properties = /**@type{!Object|undefined}*/(style[propertiesName]);
            if (properties !== undefined && properties !== lastProperties) {
                chain.push(properties);
            }
        }
        return chain;
    }
    /**
     * Return the paragraph style for the given content element.
     * @param {!Element} element
     * @return {!odf.ComputedGraphicStyle}
     */
    this.getComputedGraphicStyle = function (element) {
        var styleChain = getGraphicStyleChain(element, []),
            key = styleChain.join("/"),
            computedStyle = graphicStyleCache[key];
        runtime.assert(styleChain.length % 2 === 0, "Invalid style chain.");
        if (computedStyle === undefined) {
            computedStyle = new odf.ComputedGraphicStyle();
            computedStyle.graphic.setGraphicProperties(/**@type{!odf.GraphicProperties|undefined}*/(
                createPropertiesChain(styleChain, "graphic", "graphic")[0]
            ));
            computedStyle.text.setStyleChain(/**@type{!Array.<!odf.TextProperties>}*/(
                createPropertiesChain(styleChain, "text", "graphic")
            ));
            computedStyle.paragraph.setStyleChain(/**@type{!Array.<!odf.ParagraphProperties>}*/(
                createPropertiesChain(styleChain, "paragraph", "graphic")
            ));
            graphicStyleCache[key] = computedStyle;
        }
        return computedStyle;
    };
    /**
     * Return the paragraph style for the given content element.
     * @param {!Element} element
     * @return {!odf.ComputedParagraphStyle}
     */
    this.getComputedParagraphStyle = function (element) {
        var styleChain = getParagraphStyleChain(element, []),
            key = styleChain.join("/"),
            computedStyle = paragraphStyleCache[key];
        runtime.assert(styleChain.length % 2 === 0, "Invalid style chain.");
        if (computedStyle === undefined) {
            computedStyle = new odf.ComputedParagraphStyle();
            computedStyle.text.setStyleChain(/**@type{!Array.<!odf.TextProperties>}*/(
                createPropertiesChain(styleChain, "text", "paragraph")
            ));
            computedStyle.paragraph.setStyleChain(/**@type{!Array.<!odf.ParagraphProperties>}*/(
                createPropertiesChain(styleChain, "paragraph", "paragraph")
            ));
            paragraphStyleCache[key] = computedStyle;
        }
        return computedStyle;
    };
    /**
     * @param {!Element} element
     * @param {!Array.<!string>} chain
     * @return {!Array.<!string>}
     */
    function getTextStyleChain(element, chain) {
        var stylename = styleInfo.getStyleName("text", element),
            parent = /**@type{!Element}*/(element.parentNode);
        if (stylename !== undefined) {
            chain.push("text");
            chain.push(stylename);
        }
        // a text:span can have text:class-names
        if (element.localName === "span" && element.namespaceURI === textns) {
            appendClassNames("text", textns, element, chain);
        }
        if (!parent || parent === odfroot) {
            return chain;
        }
        if (parent.namespaceURI === textns &&
                (parent.localName === "p" || parent.localName === "h")) {
            getParagraphStyleChain(parent, chain);
        } else {
            getTextStyleChain(parent, chain);
        }
        return chain;
    }
    /**
     * Return the text style for the given content element.
     * @param {!Element} element
     * @return {!odf.ComputedTextStyle}
     */
    this.getComputedTextStyle = function (element) {
        var styleChain = getTextStyleChain(element, []),
            key = styleChain.join("/"),
            computedStyle = textStyleCache[key];
        runtime.assert(styleChain.length % 2 === 0, "Invalid style chain.");
        if (computedStyle === undefined) {
            computedStyle = new odf.ComputedTextStyle();
            computedStyle.text.setStyleChain(/**@type{!Array.<!odf.TextProperties>}*/(
                createPropertiesChain(styleChain, "text", "text")
            ));
            textStyleCache[key] = computedStyle;
        }
        return computedStyle;
    };
    /**
     * @param {!Element} element
     * @return {!odf.StylePile|undefined}
     */
    function getPileFromElement(element) {
        var family = element.getAttributeNS(stylens, "family");
        return stylePiles[family];
    }
    /**
     * @param {!Element} element
     * @return {undefined}
     */
    function addMasterPage(element) {
        var name = element.getAttributeNS(stylens, "name");
        if (name.length > 0 && !masterPages.hasOwnProperty(name)) {
            masterPages[name] = element;
        }
    }
    /**
     * @param {!string} name
     * @return {!odf.PageLayout}
     */
    function getPageLayout(name) {
        var pageLayout = parsedPageLayouts[name], e;
        if (!pageLayout) {
            e = pageLayouts[name];
            if (e) {
                pageLayout = new odf.PageLayout(e, styleParseUtils, defaultPageLayout);
                parsedPageLayouts[name] = pageLayout;
            } else {
                pageLayout = defaultPageLayout;
            }
        }
        return pageLayout;
    }
    this.getPageLayout = getPageLayout;
    /**
     * @return {!odf.PageLayout}
     */
    this.getDefaultPageLayout = function () {
        return defaultPageLayout;
    };
    /**
     * @param {!string} name
     * @return {?odf.MasterPage}
     */
    function getMasterPage(name) {
        var masterPage = parsedMasterPages[name],
            element;
        if (masterPage === undefined) {
            element = masterPages[name];
            if (element) {
                masterPage = new odf.MasterPage(element, self);
                parsedMasterPages[name] = masterPage;
            } else {
                masterPage = null;
            }
        }
        return masterPage;
    }
    this.getMasterPage = getMasterPage;
    /**
     * @return {!odf.MasterPage}
     */
    this.getDefaultMasterPage = function () {
        return defaultMasterPage;
    };
    /**
     * @return {undefined}
     */
    function update() {
        var e,
            pile,
            defaultPageLayoutElement = null,
            defaultMasterPageElement = null;
        textStyleCache = {};
        paragraphStyleCache = {};
        graphicStyleCache = {};
        masterPages = {};
        parsedMasterPages = {};
        parsedPageLayouts = {};
        pageLayouts = {};
        textStylePile = new odf.StylePile(styleParseUtils, self);
        paragraphStylePile = new odf.StylePile(styleParseUtils, self);
        graphicStylePile = new odf.StylePile(styleParseUtils, self);
        stylePiles = {
            text: textStylePile,
            paragraph: paragraphStylePile,
            graphic: graphicStylePile
        };
        // go through <office:styles/>
        e = odfroot.styles.firstElementChild;
        while (e) {
            if (e.namespaceURI === stylens) {
                pile = getPileFromElement(e);
                if (pile) {
                    if (e.localName === "style") {
                        pile.addCommonStyle(e);
                    } else if (e.localName === "default-style") {
                        pile.setDefaultStyle(e);
                    }
                } else if (e.localName === "default-page-layout") {
                    defaultPageLayoutElement = e;
                }
            }
            e = e.nextElementSibling;
        }
        defaultPageLayout = new odf.PageLayout(defaultPageLayoutElement,
                styleParseUtils);
        // go through <office:automatic-styles/>
        e = odfroot.automaticStyles.firstElementChild;
        while (e) {
            if (e.namespaceURI === stylens) {
                pile = getPileFromElement(e);
                if (pile && e.localName === "style") {
                    pile.addAutomaticStyle(e);
                } else if (e.localName === "page-layout") {
                    pageLayouts[e.getAttributeNS(stylens, "name")] = e;
                }
            }
            e = e.nextElementSibling;
        }
        // go through <office:master-styles/>
        e = odfroot.masterStyles.firstElementChild;
        while (e) {
            if (e.namespaceURI === stylens && e.localName === "master-page") {
                defaultMasterPageElement = defaultMasterPageElement || e;
                addMasterPage(e);
            }
            e = e.nextElementSibling;
        }
        defaultMasterPage = new odf.MasterPage(defaultMasterPageElement, self);
    }
    this.update = update;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\StyleInfo.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, odf, runtime, xmldom*/

/**
 * @constructor
 */
odf.StyleInfo = function StyleInfo() {
    "use strict";
    // helper constants
    var /**@const
           @type{!string}*/
        chartns = odf.Namespaces.chartns,
        /**@const
           @type{!string}*/
        dbns = odf.Namespaces.dbns,
        /**@const
           @type{!string}*/
        dr3dns = odf.Namespaces.dr3dns,
        /**@const
           @type{!string}*/
        drawns = odf.Namespaces.drawns,
        /**@const
           @type{!string}*/
        formns = odf.Namespaces.formns,
        /**@const
           @type{!string}*/
        numberns = odf.Namespaces.numberns,
        /**@const
           @type{!string}*/
        officens = odf.Namespaces.officens,
        /**@const
           @type{!string}*/
        presentationns = odf.Namespaces.presentationns,
        /**@const
           @type{!string}*/
        stylens = odf.Namespaces.stylens,
        /**@const
           @type{!string}*/
        tablens = odf.Namespaces.tablens,
        /**@const
           @type{!string}*/
        textns = odf.Namespaces.textns,
        /**@const
           @type{!Object.<string,string>}*/
        nsprefixes = {
            "urn:oasis:names:tc:opendocument:xmlns:chart:1.0": "chart:",
            "urn:oasis:names:tc:opendocument:xmlns:database:1.0": "db:",
            "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0": "dr3d:",
            "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0": "draw:",
            "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0": "fo:",
            "urn:oasis:names:tc:opendocument:xmlns:form:1.0": "form:",
            "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0": "number:",
            "urn:oasis:names:tc:opendocument:xmlns:office:1.0": "office:",
            "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0": "presentation:",
            "urn:oasis:names:tc:opendocument:xmlns:style:1.0": "style:",
            "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0": "svg:",
            "urn:oasis:names:tc:opendocument:xmlns:table:1.0": "table:",
            "urn:oasis:names:tc:opendocument:xmlns:text:1.0": "chart:",
            "http://www.w3.org/XML/1998/namespace": "xml:"
        },
        /**
         * Data about the styles.
         *   ens: element namespace,
         *   en:  element name,
         *   ans: attribute namespace,
         *   a: attribute
         * @type{!Object.<string,!Array.<!{ens:string,en:string,ans:string,a:string}>>}
         */
        elementstyles = {
            "text": [
                { ens: stylens, en: 'tab-stop', ans: stylens, a: 'leader-text-style'},
                { ens: stylens, en: 'drop-cap', ans: stylens, a: 'style-name'},
                { ens: textns, en: 'notes-configuration', ans: textns, a: 'citation-body-style-name'},
                { ens: textns, en: 'notes-configuration', ans: textns, a: 'citation-style-name'},
                { ens: textns, en: 'a', ans: textns, a: 'style-name'},
                { ens: textns, en: 'alphabetical-index', ans: textns, a: 'style-name'},
                { ens: textns, en: 'linenumbering-configuration', ans: textns, a: 'style-name'},
                { ens: textns, en: 'list-level-style-number', ans: textns, a: 'style-name'},
                { ens: textns, en: 'ruby-text', ans: textns, a: 'style-name'},
                { ens: textns, en: 'span', ans: textns, a: 'style-name'},
                { ens: textns, en: 'a', ans: textns, a: 'visited-style-name'},
                { ens: stylens, en: 'text-properties', ans: stylens, a: 'text-line-through-text-style'},
                { ens: textns, en: 'alphabetical-index-source', ans: textns, a: 'main-entry-style-name'},
                { ens: textns, en: 'index-entry-bibliography', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-chapter', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-link-end', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-link-start', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-page-number', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-span', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-tab-stop', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-entry-text', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-title-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'list-level-style-bullet', ans: textns, a: 'style-name'},
                { ens: textns, en: 'outline-level-style', ans: textns, a: 'style-name'}
            ],
            "paragraph": [
                { ens: drawns, en: 'caption', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'circle', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'connector', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'control', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'custom-shape', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'ellipse', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'frame', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'line', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'measure', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'path', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'polygon', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'polyline', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'rect', ans: drawns, a: 'text-style-name'},
                { ens: drawns, en: 'regular-polygon', ans: drawns, a: 'text-style-name'},
                { ens: officens, en: 'annotation', ans: drawns, a: 'text-style-name'},
                { ens: formns, en: 'column', ans: formns, a: 'text-style-name'},
                { ens: stylens, en: 'style', ans: stylens, a: 'next-style-name'},
                { ens: tablens, en: 'body', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'even-columns', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'even-rows', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'first-column', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'first-row', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'last-column', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'last-row', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'odd-columns', ans: tablens, a: 'paragraph-style-name'},
                { ens: tablens, en: 'odd-rows', ans: tablens, a: 'paragraph-style-name'},
                { ens: textns, en: 'notes-configuration', ans: textns, a: 'default-style-name'},
                { ens: textns, en: 'alphabetical-index-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'bibliography-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'h', ans: textns, a: 'style-name'},
                { ens: textns, en: 'illustration-index-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-source-style', ans: textns, a: 'style-name'},
                { ens: textns, en: 'object-index-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'p', ans: textns, a: 'style-name'},
                { ens: textns, en: 'table-index-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'table-of-content-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'table-index-entry-template', ans: textns, a: 'style-name'},
                { ens: textns, en: 'user-index-entry-template', ans: textns, a: 'style-name'},
                { ens: stylens, en: 'page-layout-properties', ans: stylens, a: 'register-truth-ref-style-name'}
            ],
            "chart": [
                { ens: chartns, en: 'axis', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'chart', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'data-label', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'data-point', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'equation', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'error-indicator', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'floor', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'footer', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'grid', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'legend', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'mean-value', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'plot-area', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'regression-curve', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'series', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'stock-gain-marker', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'stock-loss-marker', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'stock-range-line', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'subtitle', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'title', ans: chartns, a: 'style-name'},
                { ens: chartns, en: 'wall', ans: chartns, a: 'style-name'}
            ],
            "section": [
                { ens: textns, en: 'alphabetical-index', ans: textns, a: 'style-name'},
                { ens: textns, en: 'bibliography', ans: textns, a: 'style-name'},
                { ens: textns, en: 'illustration-index', ans: textns, a: 'style-name'},
                { ens: textns, en: 'index-title', ans: textns, a: 'style-name'},
                { ens: textns, en: 'object-index', ans: textns, a: 'style-name'},
                { ens: textns, en: 'section', ans: textns, a: 'style-name'},
                { ens: textns, en: 'table-of-content', ans: textns, a: 'style-name'},
                { ens: textns, en: 'table-index', ans: textns, a: 'style-name'},
                { ens: textns, en: 'user-index', ans: textns, a: 'style-name'}
            ],
            "ruby": [
                { ens: textns, en: 'ruby', ans: textns, a: 'style-name'}
            ],
            "table": [
                { ens: dbns, en: 'query', ans: dbns, a: 'style-name'},
                { ens: dbns, en: 'table-representation', ans: dbns, a: 'style-name'},
                { ens: tablens, en: 'background', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'table', ans: tablens, a: 'style-name'}
            ],
            "table-column": [
                { ens: dbns, en: 'column', ans: dbns, a: 'style-name'},
                { ens: tablens, en: 'table-column', ans: tablens, a: 'style-name'}
            ],
            "table-row": [
                { ens: dbns, en: 'query', ans: dbns, a: 'default-row-style-name'},
                { ens: dbns, en: 'table-representation', ans: dbns, a: 'default-row-style-name'},
                { ens: tablens, en: 'table-row', ans: tablens, a: 'style-name'}
            ],
            "table-cell": [
                { ens: dbns, en: 'column', ans: dbns, a: 'default-cell-style-name'},
                { ens: tablens, en: 'table-column', ans: tablens, a: 'default-cell-style-name'},
                { ens: tablens, en: 'table-row', ans: tablens, a: 'default-cell-style-name'},
                { ens: tablens, en: 'body', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'covered-table-cell', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'even-columns', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'covered-table-cell', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'even-columns', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'even-rows', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'first-column', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'first-row', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'last-column', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'last-row', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'odd-columns', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'odd-rows', ans: tablens, a: 'style-name'},
                { ens: tablens, en: 'table-cell', ans: tablens, a: 'style-name'}
            ],
            "graphic": [
                { ens: dr3dns, en: 'cube', ans: drawns, a: 'style-name'},
                { ens: dr3dns, en: 'extrude', ans: drawns, a: 'style-name'},
                { ens: dr3dns, en: 'rotate', ans: drawns, a: 'style-name'},
                { ens: dr3dns, en: 'scene', ans: drawns, a: 'style-name'},
                { ens: dr3dns, en: 'sphere', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'caption', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'circle', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'connector', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'control', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'custom-shape', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'ellipse', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'frame', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'g', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'line', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'measure', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'page-thumbnail', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'path', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'polygon', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'polyline', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'rect', ans: drawns, a: 'style-name'},
                { ens: drawns, en: 'regular-polygon', ans: drawns, a: 'style-name'},
                { ens: officens, en: 'annotation', ans: drawns, a: 'style-name'}
            ],
            "presentation": [
                { ens: dr3dns, en: 'cube', ans: presentationns, a: 'style-name'},
                { ens: dr3dns, en: 'extrude', ans: presentationns, a: 'style-name'},
                { ens: dr3dns, en: 'rotate', ans: presentationns, a: 'style-name'},
                { ens: dr3dns, en: 'scene', ans: presentationns, a: 'style-name'},
                { ens: dr3dns, en: 'sphere', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'caption', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'circle', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'connector', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'control', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'custom-shape', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'ellipse', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'frame', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'g', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'line', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'measure', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'page-thumbnail', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'path', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'polygon', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'polyline', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'rect', ans: presentationns, a: 'style-name'},
                { ens: drawns, en: 'regular-polygon', ans: presentationns, a: 'style-name'},
                { ens: officens, en: 'annotation', ans: presentationns, a: 'style-name'}
            ],
            "drawing-page": [
                { ens: drawns, en: 'page', ans: drawns, a: 'style-name'},
                { ens: presentationns, en: 'notes', ans: drawns, a: 'style-name'},
                { ens: stylens, en: 'handout-master', ans: drawns, a: 'style-name'},
                { ens: stylens, en: 'master-page', ans: drawns, a: 'style-name'}
            ],
            "list-style": [
                { ens: textns, en: 'list', ans: textns, a: 'style-name'},
                { ens: textns, en: 'numbered-paragraph', ans: textns, a: 'style-name'},
                { ens: textns, en: 'list-item', ans: textns, a: 'style-override'},
                { ens: stylens, en: 'style', ans: stylens, a: 'list-style-name'}
            ],
            // See http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#__RefHeading__1416346_253892949
            "data": [
                { ens: stylens, en: 'style', ans: stylens, a: 'data-style-name'},
                { ens: stylens, en: 'style', ans: stylens, a: 'percentage-data-style-name'},
                { ens: presentationns, en: 'date-time-decl', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'creation-date', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'creation-time', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'database-display', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'date', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'editing-duration', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'expression', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'meta-field', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'modification-date', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'modification-time', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'print-date', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'print-time', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'table-formula', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'time', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'user-defined', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'user-field-get', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'user-field-input', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'variable-get', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'variable-input', ans: stylens, a: 'data-style-name'},
                { ens: textns, en: 'variable-set', ans: stylens, a: 'data-style-name'}
            ],
            "page-layout": [
                { ens: presentationns, en: 'notes', ans: stylens, a: 'page-layout-name'},
                { ens: stylens, en: 'handout-master', ans: stylens, a: 'page-layout-name'},
                { ens: stylens, en: 'master-page', ans: stylens, a: 'page-layout-name'}
            ]
        },
        /**
         * Inversion of elementstyles, created with "inverse(elementstyles);" in
         * init section
         * Map with element name as primary key, element namespace as secondary
         * key, then an array of {
         *     ns: namespace of attribute,
         *     localname: name of attribute,
         *     keyname: keyname
         * }
         * @type {!Object.<!string,!Object.<!string,!Array.<!{keyname:!string,ns:!string,localname:!string}>>>}
         */
        elements,
        xpath = xmldom.XPath;

    /**
     * Return if a particular element is the parent style for any other style of
     * the same family.
     * @param {!Element} odfbody
     * @param {!function(string):?string} nsResolver
     * @param {!Element} styleElement
     * @return {!boolean}
     */
    function hasDerivedStyles(odfbody, nsResolver, styleElement) {
        var nodes,
            xp,
            styleName = styleElement.getAttributeNS(stylens, 'name'),
            styleFamily = styleElement.getAttributeNS(stylens, 'family');

        xp = '//style:*[@style:parent-style-name="' + styleName
            + '"][@style:family="' + styleFamily + '"]';
        nodes = xpath.getODFElementsWithXPath(odfbody, xp, nsResolver);
        if (nodes.length) {
            return true;
        }
        return false;
    }

    /**
     * Prefixes all style ids used to refer to styles in the given DOM element
     * tree with the given prefix.
     * @param {!Element} element  root element of tree of elements using styles
     * @param {!string} prefix
     * @return {undefined}
     */
    function prefixUsedStyleNames(element, prefix) {
        var i, stylename, a, e, ns, elname, elns,
            /**@type{string}*/
            localName,
            length = 0;
        elname = elements[element.localName];
        if (elname) {
            elns = elname[element.namespaceURI];
            if (elns) {
                length = elns.length;
            }
        }
        // prefix any used style ids
        for (i = 0; i < length; i += 1) {
            a = /**@type{!{ns:string,localname:string}}*/(elns[i]);
            ns = a.ns;
            localName = a.localname;
            stylename = element.getAttributeNS(ns, localName);
            if (stylename) { // a style reference has been found!
                element.setAttributeNS(ns, nsprefixes[ns] + localName,
                                       prefix + stylename);
            }
        }
        // continue prefixing with all child elements
        e = element.firstElementChild;
        while (e) {
            prefixUsedStyleNames(e, prefix);
            e = e.nextElementSibling;
        }
    }
    /**
     * Prefixes the id of the style defined in the given DOM element with the
     * given prefix.
     * @param {!Element} styleElement
     * @param {!string} prefix
     * @return {undefined}
     */
    function prefixStyleName(styleElement, prefix) {
        var stylename = styleElement.getAttributeNS(drawns, "name"),
            ns;
        if (stylename) {
            ns = drawns;
        } else {
            stylename = styleElement.getAttributeNS(stylens, "name");
            if (stylename) {
                ns = stylens;
            }
        }

        if (ns) {
            styleElement.setAttributeNS(ns, nsprefixes[ns] + "name",
                prefix + stylename);
        }
    }

    /**
     * Prefixes all style ids with the given prefix. This will affect all style
     * ids as set in the style definitions by the child elements of
     * styleElementsRoot and all style ids used to refer to styles, both in
     * these style definitions and in the given DOM element tree
     * styleUsingElementsRoot.
     * @param {?Element} styleElementsRoot  root element with styles nodes as childs
     * @param {!string} prefix
     * @param {?Element} styleUsingElementsRoot  root element of tree of elements using styles
     * @return {undefined}
     */
    function prefixStyleNames(styleElementsRoot, prefix, styleUsingElementsRoot) {
        var s;
        if (styleElementsRoot) {
            // prefix all set style ids
            s = styleElementsRoot.firstChild;
            while (s) {
                if (s.nodeType === Node.ELEMENT_NODE) {
                    prefixStyleName(/**@type{!Element}*/(s), prefix);
                }
                s = s.nextSibling;
            }
            // prefix all ids in style references
            prefixUsedStyleNames(styleElementsRoot, prefix);
            if (styleUsingElementsRoot) {
                prefixUsedStyleNames(styleUsingElementsRoot, prefix);
            }
        }
    }

    /**
     * @param {!Element} element  root element of tree of elements using styles
     * @param {!RegExp} regExp
     * @return {undefined}
     */
    function removeRegExpFromUsedStyleNames(element, regExp) {
        var i, stylename, e, elname, elns, a, ns, localName,
            length = 0;
        elname = elements[element.localName];
        if (elname) {
            elns = elname[element.namespaceURI];
            if (elns) {
                length = elns.length;
            }
        }
        // remove prefix from any used style id
        for (i = 0; i < length; i += 1) {
            a = /**@type{!{ns:string,localname:string}}*/(elns[i]);
            ns = a.ns;
            localName = a.localname;
            stylename = element.getAttributeNS(ns, localName);
            if (stylename) { // a style reference has been found!
                stylename = stylename.replace(regExp, '');
                element.setAttributeNS(ns, nsprefixes[ns] + localName,
                      stylename);
            }
        }
        // continue removal with all child elements
        e = element.firstElementChild;
        while (e) {
            removeRegExpFromUsedStyleNames(e, regExp);
            e = e.nextElementSibling;
        }
    }
    /**
     * Remove the given regular expression from the id of the style defined in
     * the given DOM element.
     * @param {!Element} styleElement
     * @param {!RegExp} regExp
     * @return {undefined}
     */
    function removeRegExpFromStyleName(styleElement, regExp) {
        var stylename = styleElement.getAttributeNS(drawns, "name"),
            ns;
        if (stylename) {
            ns = drawns;
        } else {
            stylename = styleElement.getAttributeNS(stylens, "name");
            if (stylename) {
                ns = stylens;
            }
        }

        if (ns) {
            stylename = stylename.replace(regExp, '');
            styleElement.setAttributeNS(ns, nsprefixes[ns] + "name", stylename);
        }
    }

    /**
     * Removes the given prefix from all style ids. This will affect all style
     * ids as set in the style definitions by the child elements of
     * styleElementsRoot and all style ids used to refer to styles, both in
     * these style definitions and in the given DOM element tree
     * styleUsingElementsRoot.
     * @param {?Element} styleElementsRoot root element with styles nodes as childs
     * @param {!string} prefix
     * @param {?Element} styleUsingElementsRoot  root element of tree of elements using styles
     */
    function removePrefixFromStyleNames(styleElementsRoot, prefix, styleUsingElementsRoot) {
        var s,
            regExp = new RegExp("^" + prefix);

        if (styleElementsRoot) {
            // remove prefix from all set style ids
            s = styleElementsRoot.firstChild;
            while (s) {
                if (s.nodeType === Node.ELEMENT_NODE) {
                    removeRegExpFromStyleName(/**@type{!Element}*/(s), regExp);
                }
                s = s.nextSibling;
            }
            // remove prefix from all ids in style references
            removeRegExpFromUsedStyleNames(styleElementsRoot, regExp);
            if (styleUsingElementsRoot) {
                removeRegExpFromUsedStyleNames(styleUsingElementsRoot, regExp);
            }
        }
    }

    /**
     * Determines all stylenames that are referenced in the passed element
     * @param {!Element} element  element to check for styles
     * @param {!Object.<string,!Object.<string,number>>=} usedStyles  map of used styles names, grouped by style family
     * @return {!Object.<string,!Object.<string,number>>|undefined} Returns either map of used styles, or undefined if none
     *      have been found an usedStyles was not passed in
     */
    function determineStylesForNode(element, usedStyles) {
        var i, stylename, elname, elns, a, ns, localName, keyname,
            length = 0, map;
        elname = elements[element.localName];
        if (elname) {
            elns = elname[element.namespaceURI];
            if (elns) {
                length = elns.length;
            }
        }
        // check if any styles are referenced
        for (i = 0; i < length; i += 1) {
            a = /**@type{!{ns:string,localname:string,keyname:string}}*/(elns[i]);
            ns = a.ns;
            localName = a.localname;
            stylename = element.getAttributeNS(ns, localName);
            if (stylename) { // a style has been found!
                usedStyles = usedStyles || {};
                keyname = a.keyname;
                if (usedStyles.hasOwnProperty(keyname)) {
                    usedStyles[keyname][stylename] = 1;
                } else {
                    map = {};
                    map[stylename] = 1;
                    usedStyles[keyname] = map;
                }
            }
        }
        return usedStyles;
    }

    /**
     * Determines all stylenames that are referenced in the passed element tree
     * @param {!Element} styleUsingElementsRoot  root element of tree of elements using styles
     * @param {!Object.<string,Object.<string,number>>} usedStyles  map of used styles names, grouped by style family
     * @return {undefined}
     */
    function determineUsedStyles(styleUsingElementsRoot, usedStyles) {
        var i, e;
        determineStylesForNode(styleUsingElementsRoot, usedStyles);
        // continue determination with all child elements
        i = styleUsingElementsRoot.firstChild;
        while (i) {
            if (i.nodeType === Node.ELEMENT_NODE) {
                e = /**@type{!Element}*/(i);
                determineUsedStyles(e, usedStyles);
            }
            i = i.nextSibling;
        }
    }

    /**
     * Node defining a style, with references to all required styles necessary to construct it
     * @param {!string} key Style key
     * @param {!string} name Style name
     * @param {!string} family Style family
     * @constructor
     */
    function StyleDefinition(key, name, family) {
        /**
         * Unique style definition key
         * @type {string}
         */
        this.key = key;

        /**
         * Style name
         * @type {string}
         */
        this.name = name;

        /**
         * Style family (e.g., paragraph, table-cell, text)
         * @type {string}
         */
        this.family = family;

        /**
         * Styles directly required by this style
         * @type {Object.<string, StyleDefinition>}
         */
        this.requires = {};
    }

    /**
     * @param {!string} stylename
     * @param {!string} stylefamily
     * @param {!Object.<string,StyleDefinition>} knownStyles  map of used stylesnames, grouped by keyname
     * @return {!StyleDefinition}
     */
    function getStyleDefinition(stylename, stylefamily, knownStyles) {
        var styleKey = stylename + '"' + stylefamily,
            styleDefinition = knownStyles[styleKey];
        if (!styleDefinition) {
            styleDefinition = knownStyles[styleKey] = new StyleDefinition(styleKey, stylename, stylefamily);
        }
        return styleDefinition;
    }

    /**
     * Builds a style dependency map for the supplied style tree
     * @param {!Element} element  root element of tree of elements using styles
     * @param {?StyleDefinition} styleScope parent style the specified style element is part of
     * @param {!Object.<string,StyleDefinition>} knownStyles  map of used stylesnames, grouped by keyname
     * @return {!Object.<string,StyleDefinition>}
     */
    function determineDependentStyles(element, styleScope, knownStyles) {
        var i, stylename, elname, elns, a, ns, localName, e,
            referencedStyleFamily, referencedStyleDef,
            length = 0,
            newScopeName = element.getAttributeNS(stylens, 'name'),
            newScopeFamily = element.getAttributeNS(stylens, 'family');
        if (newScopeName && newScopeFamily) {
            styleScope = getStyleDefinition(newScopeName, newScopeFamily,
                   knownStyles);
        }
        if (styleScope) {
            elname = elements[element.localName];
            if (elname) {
                elns = elname[element.namespaceURI];
                if (elns) {
                    length = elns.length;
                }
            }
            // check if any styles are referenced
            for (i = 0; i < length; i += 1) {
                a = /**@type{!{ns:string,localname:string,keyname:string}}*/(elns[i]);
                ns = a.ns;
                localName = a.localname;
                stylename = element.getAttributeNS(ns, localName);
                if (stylename) { // a style has been found!
                    referencedStyleFamily = a.keyname;
                    referencedStyleDef = getStyleDefinition(stylename, referencedStyleFamily, knownStyles);
                    styleScope.requires[referencedStyleDef.key] = referencedStyleDef;
                }
            }
        }

        // continue determination with all child elements
        e = element.firstElementChild;
        while (e) {
            determineDependentStyles(e, styleScope, knownStyles);
            e = e.nextElementSibling;
        }
        return knownStyles;
    }

    /**
     * Creates the elements data from the elementstyles data.
     * @return {!Object.<string,Object.<string,Array.<Object.<string,string>>>>}
     */
    function inverse() {
        var i, l,
            /**@type{string}*/
            keyname,
            /**@type{!Array.<!{ens:string,en:string,ans:string,a:string}>}*/
            list,
            /**@type{!{en:string,ens:string}}*/
            item,
            /**@type{!Object.<string,Object.<string,Array.<Object.<string,string>>>>}*/
            e = {},
            map, array, en, ens;
        for (keyname in elementstyles) {
            if (elementstyles.hasOwnProperty(keyname)) {
                list = elementstyles[keyname];
                l = list.length;
                for (i = 0; i < l; i += 1) {
                    item = list[i];
                    en = item.en;
                    ens = item.ens;
                    if (e.hasOwnProperty(en)) {
                        map = e[en];
                    } else {
                        e[en] = map = {};
                    }
                    if (map.hasOwnProperty(ens)) {
                        array = map[ens];
                    } else {
                        map[ens] = array = [];
                    }
                    array.push({
                        ns: item.ans,
                        localname: item.a,
                        keyname: keyname
                    });
                }
            }
        }
        return e;
    }

    /**
     * Merges the specified style, and style required to complete it into the usedStyles map
     * @param {!StyleDefinition} styleDependency Style to merge
     * @param {!Object.<string,Object.<string,number>>} usedStyles Styles map to merge data into
     * @return {undefined}
     */
    function mergeRequiredStyles(styleDependency, usedStyles) {
        var family = usedStyles[styleDependency.family];
        if (!family) {
            family = usedStyles[styleDependency.family] = {};
        }
        family[styleDependency.name] = 1;
        Object.keys(/**@type {!Object}*/(styleDependency.requires)).forEach(function(requiredStyleKey) {
            mergeRequiredStyles(/**@type {!StyleDefinition}*/(styleDependency.requires[requiredStyleKey]) , usedStyles);
        });
    }

    /**
     * Marks all required styles as used for any automatic styles referenced within the existing usedStyles map
     * @param {!Element} automaticStylesRoot Automatic styles tree root
     * @param {!Object.<string,Object.<string,number>>} usedStyles Styles already referenced
     * @return {undefined}
     */
    function mergeUsedAutomaticStyles(automaticStylesRoot, usedStyles) {
        var automaticStyles = determineDependentStyles(automaticStylesRoot, null, {});
        // Merge into usedStyles
        Object.keys(automaticStyles).forEach(function(styleKey) {
            var automaticStyleDefinition = automaticStyles[styleKey],
                usedFamily = usedStyles[automaticStyleDefinition.family];

            // For each style referenced by the main root, mark all required automatic styles as used as well
            if (usedFamily && usedFamily.hasOwnProperty(automaticStyleDefinition.name)) {
                mergeRequiredStyles(automaticStyleDefinition, usedStyles);
            }
        });
    }

    /**
     * Collects all names of font-face declarations which are referenced in the
     * children elements of the given root element.
     * @param {!Object.<!string,!boolean>} usedFontFaceDeclMap
     * @param {?Element} styleElement  root element with style elements as childs
     * @return {undefined}
     */
    function collectUsedFontFaces(usedFontFaceDeclMap, styleElement) {
        var localNames = ["font-name", "font-name-asian", "font-name-complex"],
            e,
            /**@type{!Element}*/
            currentElement;

        /**
         * @param {string} localName
         */
        function collectByAttribute(localName) {
            var fontFaceName = currentElement.getAttributeNS(stylens,
                    localName);
            if (fontFaceName) {
                usedFontFaceDeclMap[fontFaceName] = true;
            }
        }

        e = styleElement && styleElement.firstElementChild;
        while (e) {
            // TODO: only check elements which have those attributes defined
            currentElement = e;
            localNames.forEach(collectByAttribute);
            collectUsedFontFaces(usedFontFaceDeclMap, currentElement);
            e = e.nextElementSibling;
        }
    }
    this.collectUsedFontFaces = collectUsedFontFaces;

    /**
     * Changes all names of font-face declarations which are referenced in the
     * children elements of the given root element.
     * @param {?Element} styleElement  root element with style elements as childs
     * @param {!Object.<!string,!string>} fontFaceNameChangeMap
     * @return {undefined}
     */
    function changeFontFaceNames(styleElement, fontFaceNameChangeMap) {
        var localNames = ["font-name", "font-name-asian", "font-name-complex"],
            e,
            /**@type{!Element}*/
            currentElement;

        /**
         * @param {string} localName
         */
        function changeFontFaceNameByAttribute(localName) {
            var fontFaceName = currentElement.getAttributeNS(stylens, localName);
            if (fontFaceName && fontFaceNameChangeMap.hasOwnProperty(fontFaceName)) {
                currentElement.setAttributeNS(stylens, "style:" + localName, fontFaceNameChangeMap[fontFaceName]);
            }
        }

        e = styleElement && styleElement.firstElementChild;
        while (e) {
            // TODO: only check elements which have those attributes defined
            currentElement = e;
            localNames.forEach(changeFontFaceNameByAttribute);
            changeFontFaceNames(currentElement, fontFaceNameChangeMap);
            e = e.nextElementSibling;
        }
    }
    this.changeFontFaceNames = changeFontFaceNames;

    /**
     * Object which collects all style names that are used in the passed element tree
     * @constructor
     * @param {!Element} styleUsingElementsRoot  root element of tree of elements using styles
     * @param {?Element=} automaticStylesRoot  Additional style information. Styles in this tree are only important
     *              when used as part of a chain of styles referenced from within the stylesUsingElementsRoot node
     */
    this.UsedStyleList = function (styleUsingElementsRoot, automaticStylesRoot) {
        // usedStyles stores all style names used in the passed element tree.
        // As styles from different types can have the same names,
        // all styles are grouped by:
        // * family attribute for style:style
        // * "data" for all number:* (boolean-style,currency-style,date-style,
        //   number-style,percentage-style,text-style,time-style)
        // * localName for text:list-style, style:page-layout
        var /** @type !Object.<string,Object.<string,number>> */usedStyles = {};

        /**
         * Checks whether the passed style is referenced by anything
         * @param {!Element} element  odf style describing element
         * @return {!boolean}
         */
        this.uses = function (element) {
            var localName = element.localName,
                name = element.getAttributeNS(drawns, "name") ||
                        element.getAttributeNS(stylens, "name"),
                keyName, map;
            if (localName === "style") {
                keyName = element.getAttributeNS(stylens, "family");
            } else if (element.namespaceURI === numberns) {
                keyName = "data";
            } else {
                keyName = localName; // list-style or page-layout
            }
            map = usedStyles[keyName];
            return map ? (map[name] > 0) : false;
        };

        determineUsedStyles(styleUsingElementsRoot, usedStyles);
        if (automaticStylesRoot) {
            mergeUsedAutomaticStyles(automaticStylesRoot, usedStyles);
        }
    };

    /**
     * Return the name of the style for the given family if it is associated
     * with the element.
     * @param {!string} family
     * @param {!Element} element
     * @return {!string|undefined}
     */
    function getStyleName(family, element) {
        var stylename, i,
            map = elements[element.localName];
        if (map) {
            map = map[element.namespaceURI];
            if (map) {
                for (i = 0; i < map.length; i += 1) {
                    if (map[i].keyname === family) {
                        map = map[i];
                        if (element.hasAttributeNS(map.ns, map.localname)) {
                            stylename = element.getAttributeNS(map.ns, map.localname);
                            break;
                        }
                    }
                }
            }
        }
        return stylename;
    }
    this.getStyleName = getStyleName;

    this.hasDerivedStyles = hasDerivedStyles;
    this.prefixStyleNames = prefixStyleNames;
    this.removePrefixFromStyleNames = removePrefixFromStyleNames;
    this.determineStylesForNode = determineStylesForNode;


    // init
    elements = inverse();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\StyleParseUtils.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/

/**
 * Object that retrieves properties lazily and caches them.
 * If the element does not define the property it is retrieved from a parent
 * LazyStyleProperties object.
 * An object with getters functions is passed into the constructor. There must
 * be a getter function for each property.
 * @constructor
 * @param {!odf.LazyStyleProperties|undefined} parent
 * @param {!Object.<!string,function():*>} getters
 */
odf.LazyStyleProperties = function (parent, getters) {
    "use strict";
    var /**@type{!Object.<!string,*>}*/
        data = {};
    /**
     * Retrieve a value by name.
     * The getter for the value must be defined in the getters object.
     * If the getter returns undefined and a parent object is provided, the
     * value is gotten from the parent object.
     * @param {!string} name
     * @return {*}
     */
    this.value = function (name) {
        var /**@type{*}*/
            v;
        if (data.hasOwnProperty(name)) {
            v = data[name];
        } else {
            v = getters[name]();
            if (v === undefined && parent) {
                v = parent.value(name);
            }
            data[name] = v;
        }
        return v;
    };
    /**
     * Give a new parent to the LazyStyleProperties.
     * The cache is invalidated when this is done.
     * @param {!odf.LazyStyleProperties|undefined} p
     * @return {undefined}
     */
    this.reset = function (p) {
        parent = p;
        data = {};
    };
};
/**
 * A collection of helper functions for parsing style attributes.
 * @constructor
 */
odf.StyleParseUtils = function () {
    "use strict";
    var stylens = odf.Namespaces.stylens;
    /**
     * Returns the length split as value and unit, from an ODF attribute.
     * If the length does not match the regular expression, null is returned.
     * @param {?string|undefined} length
     * @return {?{value:!number,unit:!string}}
     */
    function splitLength(length) {
        var re = /(-?[0-9]*[0-9][0-9]*(\.[0-9]*)?|0+\.[0-9]*[1-9][0-9]*|\.[0-9]*[1-9][0-9]*)((cm)|(mm)|(in)|(pt)|(pc)|(px))/,
            m = re.exec(length);
        if (!m) {
            return null;
        }
        return {value: parseFloat(m[1]), unit: m[3]};
    }
    /**
     * Convert a unit in a string to number of pixels at 96 dpi.
     * If the input value has unit 'px' or is a number, the number is taken as
     * is. Other allowed unit: cm, mm, pt, pc.
     * If the value cannot be parsed, the value undefined is returned.
     * @param {?string|undefined} val
     * @return {!number|undefined}
     */
    function parseLength(val) {
        var n, length, unit;
        length = splitLength(val);
        unit = length && length.unit;
        if (unit === "px") {
            n = length.value;
        } else if (unit === "cm") {
            n = length.value / 2.54 * 96;
        } else if (unit === "mm") {
            n = length.value / 25.4 * 96;
        } else if (unit === "in") {
            n = length.value * 96;
        } else if (unit === "pt") {
            n = length.value / 0.75;
        } else if (unit === "pc") {
            n = length.value * 16;
        }
        return n;
    }
    this.parseLength = parseLength;
    /**
     * Parse a percentage of the form -?([0-9]+(\.[0-9]*)?|\.[0-9]+)%.
     * If parsing fails undefined is returned.
     * @param {?string|undefined} value
     * @return {!number|undefined}
     */
    function parsePercent(value) {
        var v;
        if (value) {
            v = parseFloat(value.substr(0, value.indexOf("%")));
            if (isNaN(v)) {
                v = undefined;
            }
        }
        return v;
    }
    /**
     * Parse a value that is a positive length or a percentage.
     * If parsing fails undefined is returned.
     * @param {?string|undefined} value
     * @param {!string} name
     * @param {!odf.LazyStyleProperties|undefined} parent
     * @return {!number|undefined}
     */
    function parsePositiveLengthOrPercent(value, name, parent) {
        var v = parsePercent(value),
            parentValue;
        if (v !== undefined) {
            if (parent) {
                parentValue = parent.value(name);
            }
            if (parentValue === undefined) {
                v = undefined;
            } else {
                v *= /**@type{!number}*/(parentValue) / 100;
            }
        } else {
            v = parseLength(value);
        }
        return v;
    }
    this.parsePositiveLengthOrPercent = parsePositiveLengthOrPercent;
    /**
     * Find a child element from the ODF style namespace with the given local
     * name.
     * The search is started after the given previousPropertyElement or, if
     * previousPropertyElement is not given, from the first child element.
     * @param {!string} name
     * @param {!Element} styleElement
     * @param {?Element=} previousPropertyElement
     * @return {?Element}
     */
    function getPropertiesElement(name, styleElement, previousPropertyElement) {
        var e = previousPropertyElement
                ? previousPropertyElement.nextElementSibling
                : styleElement.firstElementChild;
        while (e !== null && (e.localName !== name || e.namespaceURI !== stylens)) {
            e = e.nextElementSibling;
        }
        return e;
    }
    this.getPropertiesElement = getPropertiesElement;


    /**
     * Split a space-separated attribute list into it's list items. Ignores leading & trailing
     * whitespace, and collapses excessive internal whitespace. If the input text is null, undefined
     * or pure whitespace, an empty array will be returned.
     *
     * @param {?string|undefined} text
     * @return {!Array.<!string>}
     */
    /*jslint regexp: true*/
    function parseAttributeList(text) {
        if (text) {
            text = text.replace(/^\s*(.*?)\s*$/g, "$1"); // Trim leading + trailing whitespace
        }
        // Calling split on an empty string returns a [""]. Avoid this by only attempting to split if the
        // string is non-zero-length
        return text && text.length > 0 ? text.split(/\s+/) : [];
    }
    /*jslint regexp: false*/
    this.parseAttributeList = parseAttributeList;
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\StyleTree.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf*/

(function () {
    "use strict";

    var /**@const
           @type{!string}*/
        stylens = odf.Namespaces.stylens,
        /**@const
           @type{!string}*/
        textns = odf.Namespaces.textns,
        /**
         * This dictionary maps between ODF style family names and the
         * tag prefixes they use. This is currently a duplicate of the same
         * dictionary in Styles2CSS. Here only the style family names are used
         * as keys in the StyleTree that is generated.
         * @const
           @type{!Object.<string,string>}*/
        familyNamespacePrefixes = {
            'graphic': 'draw',
            'drawing-page': 'draw',
            'paragraph': 'text',
            'presentation': 'presentation',
            'ruby': 'text',
            'section': 'text',
            'table': 'table',
            'table-cell': 'table',
            'table-column': 'table',
            'table-row': 'table',
            'text': 'text',
            'list': 'text',
            'page': 'office'
        };

    /**
     * StyleTreeNode encapsulates an ODF style element and its derived styles
     * This class is used within the StyleTree where it is associated with a key
     * that is the style name for this node.
     * @constructor
     * @param {!Element} element
     */
    odf.StyleTreeNode = function StyleTreeNode(element) {
        /**@type{!Object.<string,!odf.StyleTreeNode>}*/
        this.derivedStyles = {};

        /**@type{!Element}*/
        this.element = element;
    };

    /**
     * StyleTree creates a nested dictionary of the styles in an ODF document
     * This is to allow the lookup of all styles for a given family by using the family name as the key
     * and then the specific style in that family by using the style name as the key.
     * @constructor
     * @param {!Element} styles
     * @param {!Element} autoStyles
     */
    odf.StyleTree = function StyleTree(styles, autoStyles) {

        var tree = {};

        /**
         * @param {!Element} stylesNode
         * @return {!Object.<string,!Object.<string,?Element>>}
         */
        function getStyleMap(stylesNode) {
            // put all style elements in a hash map by family and name
            var node, name, family, style,
                /**@type{!Object.<string,!Object.<string,?Element>>}*/
                styleMap = {};
            if (!stylesNode) {
                return styleMap;
            }
            node = stylesNode.firstElementChild;
            while (node) {
                if (node.namespaceURI === stylens &&
                    ((node.localName === 'style') ||
                        (node.localName === 'default-style'))) {
                    family = node.getAttributeNS(stylens, 'family');
                } else if (node.namespaceURI === textns &&
                    node.localName === 'list-style') {
                    family = "list";
                } else if (node.namespaceURI === stylens &&
                    (node.localName === 'page-layout' || node.localName === 'default-page-layout')) {
                    family = "page";
                } else {
                    // Skip insignificant white-space only nodes in the style tree
                    family = undefined;
                }

                if (family) {
                    // get style name
                    name = node.getAttributeNS(stylens, 'name');
                    if (!name) {
                        // For a default style, there is no name
                        name = '';
                    }

                    // get style (and create, if not yet existing)
                    if (styleMap.hasOwnProperty(family)) {
                        style = styleMap[family];
                    } else {
                        styleMap[family] = style = {};
                    }

                    // then store style node in map
                    style[name] = node;
                }

                node = node.nextElementSibling;
            }

            return styleMap;
        }

        /**
         * @param {!Object.<string,!odf.StyleTreeNode>} stylesTree
         * @param {string} name
         * @return {odf.StyleTreeNode}
         */
        function findStyleTreeNode(stylesTree, name) {
            if (stylesTree.hasOwnProperty(name)) {
                return stylesTree[name];
            }
            var style = null,
                styleNames = Object.keys(stylesTree),
                i;

            for (i = 0; i < styleNames.length; i += 1) {
                style = findStyleTreeNode(stylesTree[styleNames[i]].derivedStyles, name);
                if (style) {
                    break;
                }
            }
            return style;
        }

        /**
         * Creates the StyleTreeNode from the style element
         * and inserts it into the given StyleTree
         * @param {string} styleName
         * @param {!Object.<string,!Element>} stylesMap
         * @param {!Object.<string,!odf.StyleTreeNode>} stylesTree
         * @return {?odf.StyleTreeNode}
         */
        function createStyleTreeNode(styleName, stylesMap, stylesTree) {
            var style, parentname, parentstyle;
            if (!stylesMap.hasOwnProperty(styleName)) {
                return null;
            }
            style = new odf.StyleTreeNode(stylesMap[styleName]);
            parentname = style.element.getAttributeNS(stylens, 'parent-style-name');
            parentstyle = null;
            if (parentname) {
                parentstyle = findStyleTreeNode(stylesTree, parentname)
                    || createStyleTreeNode(parentname, stylesMap, stylesTree);
            }
            if (parentstyle) {
                parentstyle.derivedStyles[styleName] = style;
            } else {
                // no parent so add the root
                stylesTree[styleName] = style;
            }
            delete stylesMap[styleName];
            return style;
        }

        /**
         * @param {!Object.<string,!Element>} stylesMap
         * @param {!Object.<string,!odf.StyleTreeNode>} stylesTree
         * @return {undefined}
         */
        function addStyleMapToStyleTree(stylesMap, stylesTree) {
            if (stylesMap) {
                Object.keys(stylesMap).forEach(function (styleName) {
                    createStyleTreeNode(styleName, stylesMap, stylesTree);
                });
            }
        }

        /**
         * @return {!odf.StyleTree.Tree}
         */
        this.getStyleTree = function () {
            return tree;
        };

        function init() {
            var subTree,
                styleNodes,
                autoStyleNodes;

            styleNodes = getStyleMap(styles);
            autoStyleNodes = getStyleMap(autoStyles);

            Object.keys(familyNamespacePrefixes).forEach(function (family) {
                subTree = tree[family] = {};
                addStyleMapToStyleTree(styleNodes[family], subTree);
                addStyleMapToStyleTree(autoStyleNodes[family], subTree);
            });
        }

        init();
    };
}());

/**
 * @typedef{!Object.<string,!Object.<string,!odf.StyleTreeNode>>}
 */
odf.StyleTree.Tree;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\TextProperties.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf*/

/**
 * @constructor
 * @param {!Element} element
 * @param {!odf.StyleParseUtils} styleParseUtils
 * @param {!odf.TextProperties|undefined} parent
 */
odf.TextProperties = function (element, styleParseUtils, parent) {
    "use strict";
    var self = this,
        fons = odf.Namespaces.fons,
        getter;
    getter = {
        fontSize: function () {
            var a = element.getAttributeNS(fons, "font-size"),
                value = styleParseUtils.parsePositiveLengthOrPercent(a,
                    "fontSize", parent && parent.data);
            return value;
        }
    };
    /**
     * @return {!number|undefined}
     */
    this.fontSize = function () {
        return /**@type{!number|undefined}*/(self.data.value("fontSize"));
    };
    /**
     * @type {!odf.LazyStyleProperties|undefined}
     */
    this.data;
    function init() {
        var p = parent === undefined ? undefined : parent.data;
        self.data = new odf.LazyStyleProperties(p, getter);
    }
    init();
};
/**
 * @constructor
 */
odf.ComputedTextProperties = function () {
    "use strict";
    var /**@type{!Object.<!string,*>}*/
        data = {},
        /**@type{!Array.<!odf.TextProperties>}*/
        styleChain = [];
    /**
     * @param {!string} name
     * @return {*}
     */
    function value(name) {
        var v, i;
        if (data.hasOwnProperty(name)) {
            v = data[name];
        } else {
            for (i = 0; v === undefined && i < styleChain.length; i += 1) {
                v = /**@type{!function():*}*/(styleChain[i][name])();
            }
            data[name] = v;
        }
        return v;
    }
    /**
     * @param {!Array.<!odf.TextProperties>} newStyleChain
     * @return {undefined}
     */
    this.setStyleChain = function setStyleChain(newStyleChain) {
        styleChain = newStyleChain;
        data = {};
    };
    /**
     * @return {!number}
     */
    this.fontSize = function () {
        return /**@type{!number}*/(value("fontSize")) || 12;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\TextSerializer.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global odf, xmldom, Node, NodeFilter, runtime*/

/**
 * Serializes a provided node structure into plain text, eliminating everything
 * specified by the optional filter element.
 * This will attempt to generate reasonable plain text output including line-breaks
 * at new paragraphs
 * @constructor
 */
odf.TextSerializer = function TextSerializer() {
    "use strict";
    var self = this,
        odfUtils = odf.OdfUtils;

    /**
     * @param {!Node} node
     * @return {!string}
     */
    function serializeNode(node) {
        var s = "",
            accept = (self.filter) ? self.filter.acceptNode(node) : NodeFilter.FILTER_ACCEPT,
            nodeType = node.nodeType,
            child;

        if ((accept === NodeFilter.FILTER_ACCEPT || accept === NodeFilter.FILTER_SKIP) &&
            odfUtils.isTextContentContainingNode(node)) {
            child = node.firstChild;
            while (child) {
                s += serializeNode(child);
                child = child.nextSibling;
            }
        }
        if (accept === NodeFilter.FILTER_ACCEPT) {
            if (nodeType === Node.ELEMENT_NODE && odfUtils.isParagraph(node)) {
                s += "\n";
            } else if (nodeType === Node.TEXT_NODE && node.textContent) {
                s += node.textContent;
            }
        }
        return s;
    }
    /**
     * @type {xmldom.LSSerializerFilter}
     */
    this.filter = null;

    /**
     * @param {?Node} node
     * @return {!string}
     */
    this.writeToString = function (node) {
        var plainText;
        if (!node) {
            return "";
        }
        plainText = serializeNode(node);
        if (plainText[plainText.length - 1] === "\n") {
            // By the serializing logic, the selection  <p>text</p> would generate "text\n"
            // This is slightly unexpected though, as partially selecting two paragraphs (<p>p1</p><p>p2</p>)
            // the user would expect the text to be "p1\np2"
            // Easiest way to meet this expectation is to throw away the last new line (if present)
            plainText = plainText.substr(0, plainText.length - 1);
        }
        return plainText;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\TextStyleApplicator.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, odf, runtime, core*/

/**
 * Class for applying a supplied text style to the given text nodes.
 * @constructor
 * @param {!odf.ObjectNameGenerator} objectNameGenerator Source for generating unique automatic style names
 * @param {!odf.Formatting} formatting Formatting retrieval and computation store
 * @param {!Node} automaticStyles Root element for automatic styles
 */
odf.TextStyleApplicator = function TextStyleApplicator(objectNameGenerator, formatting, automaticStyles) {
    "use strict";
    var domUtils = core.DomUtils,
        /**@const*/
        textns = odf.Namespaces.textns,
        /**@const*/
        stylens = odf.Namespaces.stylens,
        /**@const*/
        textProperties = "style:text-properties",
        /**@const*/
        webodfns = "urn:webodf:names:scope";

    /**
     * @constructor
     * @param {!Object} info Style information
     */
    function StyleLookup(info) {
        var cachedAppliedStyles = {};

        /**
         * @param {!Object} expected
         * @param {Object|undefined} actual
         * @return {boolean}
         */
        function compare(expected, actual) {
            if (typeof expected === "object" && typeof actual === "object") {
                return Object.keys(expected).every(function (key) {
                    return compare(expected[key], actual[key]);
                });
            }
            return expected === actual;
        }

        /**
         * @param {!CharacterData} textNode
         * @return {boolean}
         */
        this.isStyleApplied = function (textNode) {
            // TODO can direct style to element just be removed somewhere to end up with desired style?
            var appliedStyle = formatting.getAppliedStylesForElement(textNode, cachedAppliedStyles).styleProperties;
            return compare(info, appliedStyle);
        };
    }

    /**
     * Responsible for maintaining a collection of creates auto-styles for
     * re-use on styling new containers.
     * @constructor
     * @param {!Object} info Style information
     */
    function StyleManager(info) {
        var /**@type{!Object.<string,!Element>}*/
            createdStyles = {};

        /**
         * @param {string} existingStyleName
         * @param {Document} document
         * @return {!Element}
         */
        function createDirectFormat(existingStyleName, document) {
            var derivedStyleInfo, derivedStyleNode;

            derivedStyleInfo = existingStyleName ? formatting.createDerivedStyleObject(existingStyleName, "text", info) : info;
            derivedStyleNode = document.createElementNS(stylens, "style:style");
            formatting.updateStyle(derivedStyleNode, derivedStyleInfo);
            derivedStyleNode.setAttributeNS(stylens, "style:name", objectNameGenerator.generateStyleName());
            derivedStyleNode.setAttributeNS(stylens, "style:family", "text"); // The family will not have been specified if just using info
            derivedStyleNode.setAttributeNS(webodfns, "scope", "document-content");
            automaticStyles.appendChild(derivedStyleNode);
            return derivedStyleNode;
        }

        /**
         * @param {string} existingStyleName
         * @param {Document} document
         * @return {string}
         */
        function getDirectStyle(existingStyleName, document) {
            existingStyleName = existingStyleName || "";
            if (!createdStyles.hasOwnProperty(existingStyleName)) {
                createdStyles[existingStyleName] = createDirectFormat(existingStyleName, document);
            }
            return createdStyles[existingStyleName].getAttributeNS(stylens, "name");
        }

        /**
         * Applies the required styling changes to the supplied container.
         * @param {!Element} container
         */
        this.applyStyleToContainer = function (container) {
            // container will be a span by this point, and the style-name can only appear in one place
            var name = getDirectStyle(container.getAttributeNS(textns, "style-name"), container.ownerDocument);
            container.setAttributeNS(textns, "text:style-name", name);
        };
    }

    /**
     * Returns true if the passed in node is an ODT text span
     * @param {!Node} node
     * @return {!boolean}
     */
    function isTextSpan(node) {
        return node.localName === "span" && node.namespaceURI === textns;
    }

    /**
     * Moves the specified node and all further siblings within the outer range into a new standalone container
     * @param {!CharacterData} startNode Node to start movement to new container
     * @param {!Range} range style application bounds
     * @return {!Element}  Returns the container node that is to be restyled
     */
    function moveToNewSpan(startNode, range) {
        var document = startNode.ownerDocument,
            originalContainer = /**@type{!Element}*/(startNode.parentNode),
            /**@type{!Element}*/
            styledContainer,
            trailingContainer,
            moveTrailing,
            node,
            nextNode,
            loopGuard = new core.LoopWatchDog(10000),
            /**@type{!Array.<!Node>}*/
            styledNodes = [];

        // Starting at the startNode, iterate forward until leaving the affected range
        styledNodes.push(startNode);
        node = startNode.nextSibling;
        // Need to fetch all nodes to move before starting to move any, in case
        // the range actually reference one of the nodes this loop is about to relocate
        while (node && domUtils.rangeContainsNode(range, node)) {
            loopGuard.check();
            styledNodes.push(node);
            node = node.nextSibling;
        }

        // Do we need a new style container?
        if (!isTextSpan(originalContainer)) {
            // Yes, text node has no wrapping span
            styledContainer = document.createElementNS(textns, "text:span");
            originalContainer.insertBefore(styledContainer, startNode);
            moveTrailing = false;
        } else if (startNode.previousSibling
                && !domUtils.rangeContainsNode(range, /**@type{!Element}*/(originalContainer.firstChild))) {
            // Yes, text node has prior siblings that are not styled
            // TODO what elements should be stripped when the clone occurs?
            styledContainer = originalContainer.cloneNode(false);
            originalContainer.parentNode.insertBefore(styledContainer, originalContainer.nextSibling);
            moveTrailing = true;
        } else {
            // No, repossess the current container
            styledContainer = originalContainer;
            moveTrailing = true;
        }

        styledNodes.forEach(function (n) {
            if (n.parentNode !== styledContainer) {
                styledContainer.appendChild(n);
            }
        });

        // Any trailing nodes?
        if (node && moveTrailing) {
            // Yes, create a trailing container
            trailingContainer = styledContainer.cloneNode(false);
            styledContainer.parentNode.insertBefore(trailingContainer, styledContainer.nextSibling);

            // Starting at the first node outside the affected range, move each node across
            while (node) {
                loopGuard.check();
                nextNode = node.nextSibling;
                trailingContainer.appendChild(node);
                node = nextNode;
            }
        }

        // TODO clean up empty spans that are left behind
        return /**@type {!Element}*/ (styledContainer);
    }

    /**
     * Apply the specified text style to the given text nodes
     * @param {!Array.<!CharacterData>} textNodes
     * @param {!Range} range style application bounds
     * @param {!Object} info Style information. Only data within "style:text-properties" will be considered and applied
     * @return {undefined}
     */
    this.applyStyle = function (textNodes, range, info) {
        var textPropsOnly = {},
            isStyled,
            container,
            /**@type{!StyleManager}*/
            styleCache,
            /**@type{!StyleLookup}*/
            styleLookup;
        runtime.assert(info && info.hasOwnProperty(textProperties), "applyStyle without any text properties");
        textPropsOnly[textProperties] = info[textProperties];
        styleCache = new StyleManager(textPropsOnly);
        styleLookup = new StyleLookup(textPropsOnly);

        /**
         * @param {!CharacterData} n
         */
        function apply(n) {
            isStyled = styleLookup.isStyleApplied(n);
            if (isStyled === false) {
                container = moveToNewSpan(n, range);
                styleCache.applyStyleToContainer(container);
            }
        }
        textNodes.forEach(apply);
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\odf\WordBoundaryFilter.js
========================================================================

/**
 * Copyright (C) 2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, NodeFilter, core, runtime, odf*/

/**
 * A filter that allows a position if it is in front of a word, picture etc.
 *
 * Word boundaries are detected by the presence of punctuation as defined in the unicode standard.
 * The included UTF categories are:
 * - Pc (connector punctuation)
 * - Pd (dash punctuation)
 * - Pe (close punctuation)
 * - Pf (final punctuation)
 * - Pi (initial punctuation)
 * - Po (other punctuation)
 * - Ps (Open punctuation)
 *
 * In addition, the following ranges are also included as boundaries:
 * - 2000-206F (general punctuation)
 * - 2E00-2E7F (supplemental punctuation)
 * - 3000-303F (CJK symbols and punctuation)
 * - 12400-1247F (cuneiform numbers and punctuation)
 *
 * Some libraries and sites exist for assisting in creation of the regex. The one
 * used for this particular expression was http://apps.timwhitlock.info/js/regex
 * which is based on the cset javascript library
 * (http://inimino.org/~inimino/blog/javascript_cset).
 *
 *
 * @constructor
 * @implements {core.PositionFilter}
 * @param {!ops.OdtDocument} odtDocument
 * @param {!odf.WordBoundaryFilter.IncludeWhitespace} includeWhitespace Specify the type of whitespace to include within
 *  the word boundary. TRAILING causes the accepted position to be after the whitespace trailing a word, while LEADING
 *  causes the accepted position to be just after the word boundary (but before the trailing whitespace).
 */
odf.WordBoundaryFilter = function WordBoundaryFilter(odtDocument, includeWhitespace) {
    "use strict";
    var TEXT_NODE = Node.TEXT_NODE,
        ELEMENT_NODE = Node.ELEMENT_NODE,
        odfUtils = odf.OdfUtils,
        // Sourced from http://apps.timwhitlock.info/js/regex, including all punctuation components
        punctuation = /[!-#%-*,-\/:-;?-@\[-\]_{}¡«·»¿;·՚-՟։-֊־׀׃׆׳-״؉-؊،-؍؛؞-؟٪-٭۔܀-܍߷-߹।-॥॰෴๏๚-๛༄-༒༺-༽྅࿐-࿔၊-၏჻፡-፨᙭-᙮᚛-᚜᛫-᛭᜵-᜶។-៖៘-៚᠀-᠊᥄-᥅᧞-᧟᨞-᨟᭚-᭠᰻-᰿᱾-᱿\u2000-\u206e⁽-⁾₍-₎〈-〉❨-❵⟅-⟆⟦-⟯⦃-⦘⧘-⧛⧼-⧽⳹-⳼⳾-⳿⸀-\u2e7e\u3000-\u303f゠・꘍-꘏꙳꙾꡴-꡷꣎-꣏꤮-꤯꥟꩜-꩟﴾-﴿︐-︙︰-﹒﹔-﹡﹣﹨﹪-﹫！-＃％-＊，-／：-；？-＠［-］＿｛｝｟-･]|\ud800[\udd00-\udd01\udf9f\udfd0]|\ud802[\udd1f\udd3f\ude50-\ude58]|\ud809[\udc00-\udc7e]/,
        spacing = /\s/,
        /**@const*/
        FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT,
        /**@const*/
        FILTER_REJECT = core.PositionFilter.FilterResult.FILTER_REJECT,
        /**@const*/
        TRAILING = odf.WordBoundaryFilter.IncludeWhitespace.TRAILING,
        /**@const*/
        LEADING = odf.WordBoundaryFilter.IncludeWhitespace.LEADING,
        /**
         * @enum {number}
         */
        NeighborType = {
            NO_NEIGHBOUR:       0,
            SPACE_CHAR:         1,
            PUNCTUATION_CHAR:   2,
            WORD_CHAR:          3,
            OTHER:              4
        };

    /**
     * Returns the first filtered sibling ecountered while travelling up the dom from node until
     * before the documentRoot - or null if none is found.
     * @param {?Node} node
     * @param {!number} direction look for a left sibling when negative - for a right sibling otherwise
     * @param {!function(?Node):!number} nodeFilter
     * @return {?Node}
     */
    function findHigherNeighborNode(node, direction, nodeFilter) {
        var neighboringNode = null,
            rootNode = odtDocument.getRootNode(),
            unfilteredCandidate;

        while (node !== rootNode && node !== null && neighboringNode === null) {
            unfilteredCandidate = (direction < 0) ? node.previousSibling : node.nextSibling;
            if (nodeFilter(unfilteredCandidate) === NodeFilter.FILTER_ACCEPT) {
                neighboringNode = unfilteredCandidate;
            }
            node = node.parentNode;
        }

        return neighboringNode;
    }

    /**
     * @param {?Node} node
     * @param {!function():!number} getOffset returns the offset inside the node
     * @return {!NeighborType}
     */
    function typeOfNeighbor(node, getOffset) {
        var neighboringChar;

        if (node === null) {
            return NeighborType.NO_NEIGHBOUR;
        }
        if (odfUtils.isCharacterElement(node)) {
            return NeighborType.SPACE_CHAR;
        }
        if (node.nodeType === TEXT_NODE || odfUtils.isTextSpan(node) || odfUtils.isHyperlink(node)) {
            neighboringChar = node.textContent.charAt(getOffset());

            if (spacing.test(neighboringChar)) {
                return NeighborType.SPACE_CHAR;
            }
            if (punctuation.test(neighboringChar)) {
                return NeighborType.PUNCTUATION_CHAR;
            }
            return NeighborType.WORD_CHAR;
        }
        return NeighborType.OTHER;
    }

    /**
     * @param {!core.PositionIterator} iterator
     * @return {!core.PositionFilter.FilterResult}
     */
    this.acceptPosition = function (iterator) {
        var container = iterator.container(),
            /**@type{Node}*/
            leftNode = iterator.leftNode(),
            rightNode = iterator.rightNode(),
            // For performance reasons, do not calculate the offset inside the dom until it is necessary
            getRightCharOffset = iterator.unfilteredDomOffset,
            getLeftCharOffset = function() {return iterator.unfilteredDomOffset() - 1;},
            leftNeighborType,
            rightNeighborType;

        // If this could be the end of an element node, look for the neighboring node higher in the dom
        if (container.nodeType === ELEMENT_NODE) {
            if (rightNode === null) {
                rightNode = findHigherNeighborNode(container, 1, iterator.getNodeFilter());
            }
            if (leftNode === null) {
                leftNode = findHigherNeighborNode(container, -1, iterator.getNodeFilter());
            }
        }

        // If we dont stay inside the container node, the getOffset function needs to be modified so as to
        // return the offset of the characters just at the beginning/end of the respective neighboring node.
        if (container !== rightNode) {
            getRightCharOffset = function() {return 0;};
        }
        if (container !== leftNode && leftNode !== null) {
            getLeftCharOffset = function() {return leftNode.textContent.length - 1;};
        }

        leftNeighborType = typeOfNeighbor(leftNode, getLeftCharOffset);
        rightNeighborType = typeOfNeighbor(rightNode, getRightCharOffset);

        // Reject if: is between two usual characters (inside word) OR
        //            is between two punctuation marks OR
        //            (if including trailing space) is before a spacing and not behind the edge (word ending)
        //            (if excluding trailing space) is before an edge (word start) and not behind the spacing
        if ((leftNeighborType === NeighborType.WORD_CHAR    && rightNeighborType === NeighborType.WORD_CHAR) ||
            (leftNeighborType === NeighborType.PUNCTUATION_CHAR && rightNeighborType === NeighborType.PUNCTUATION_CHAR) ||
            (includeWhitespace === TRAILING &&
                leftNeighborType !== NeighborType.NO_NEIGHBOUR && rightNeighborType === NeighborType.SPACE_CHAR) ||
            (includeWhitespace === LEADING &&
                leftNeighborType === NeighborType.SPACE_CHAR && rightNeighborType !== NeighborType.NO_NEIGHBOUR)) {
            return FILTER_REJECT;
        }
        return FILTER_ACCEPT;
    };
};

/**
 * Type of whitespace to include within the word boundary
 * @enum {!number}
 */
odf.WordBoundaryFilter.IncludeWhitespace = {
    /**@const*/None: 0,
    /**@const*/TRAILING: 1,
    /**@const*/LEADING: 2
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\Canvas.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops */
/*jslint emptyblock: true, unparam: true */

/**
 * @interface
 */
ops.Canvas = function Canvas() { "use strict"; };
/**
 * @return {number}
 */
ops.Canvas.prototype.getZoomLevel = function () { "use strict"; };
/**
 * @return {!Element}
 */
ops.Canvas.prototype.getElement = function () { "use strict"; };
/**
 * @return {!HTMLElement}
 */
ops.Canvas.prototype.getSizer = function () { "use strict"; };
/**
 * @return {!gui.ZoomHelper}
 */
ops.Canvas.prototype.getZoomHelper = function () { "use strict"; };

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\Document.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops */
/*jslint emptyblock: true, unparam: true */

/**
 * A document that keeps all data related to the mapped document.
 * @interface
 */
ops.Document = function Document() { "use strict"; };
/**
 * @return {!Array.<string>}
 */
ops.Document.prototype.getMemberIds = function () { "use strict"; };
/**
 * @param {!string} memberid
 * @return {!boolean}
 */
ops.Document.prototype.removeCursor = function (memberid) { "use strict"; };
/**
 * @return {!Element}
 */
ops.Document.prototype.getDocumentElement = function () { "use strict"; };
/**
 * Return the element where the document content begins.
 * Document content means the body of the document. In the case of ODF this is
 * office:text, office:spreadsheet, office:presentation. For most XML documents
 * getRootNode() will return the same node as getDocumentElement().
 * @return {!Element}
 */
ops.Document.prototype.getRootNode = function () { "use strict"; };
/**
 * @return {!Document}
 */
ops.Document.prototype.getDOMDocument = function () { "use strict"; };
/**
 * @return {!Element}
 */
ops.Document.prototype.cloneDocumentElement = function () { "use strict"; };
/**
 * @param {!Element} element
 * @return {undefined}
 */
ops.Document.prototype.setDocumentElement = function (element) { "use strict"; };
/**
 * @param {!string} eventid
 * @param {!Function} cb
 * @return {undefined}
 */
ops.Document.prototype.subscribe = function (eventid, cb) { "use strict"; };
/**
 * @param {!string} eventid
 * @param {!Function} cb
 * @return {undefined}
 */
ops.Document.prototype.unsubscribe = function (eventid, cb) { "use strict"; };
// vim:expandtab
/**
 * @return {!ops.Canvas}
 */
ops.Document.prototype.getCanvas = function () { "use strict"; };
/**
 * @param {string|!Node} inputMemberId
 * @return {!core.PositionFilter}
 */
ops.Document.prototype.createRootFilter = function (inputMemberId) { "use strict"; };
/**
 * @param {!Node} rootNode
 * @return {!core.PositionIterator}
 */
ops.Document.prototype.createPositionIterator = function (rootNode) { "use strict"; };
/**
 * @param {!string} memberid
 * @return {!boolean}
 */
ops.Document.prototype.hasCursor = function (memberid) { "use strict"; };

/**@const*/
ops.Document.signalCursorAdded =   "cursor/added";
/**@const*/
ops.Document.signalCursorRemoved = "cursor/removed";
/**@const*/
ops.Document.signalCursorMoved =   "cursor/moved";
/**@const*/
ops.Document.signalMemberAdded =   "member/added";
/**@const*/
ops.Document.signalMemberUpdated = "member/updated";
/**@const*/
ops.Document.signalMemberRemoved = "member/removed";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\EditInfo.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <aditya.bhatt@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, ops, runtime*/

/**
 * @constructor
 * @implements {core.Destroyable}
 * @param {!Element} container
 * @param {!ops.OdtDocument} odtDocument
 */
ops.EditInfo = function EditInfo(container, odtDocument) {
    "use strict";
    var /**@type {!Element}*/
        editInfoNode,
        /**@type {!Object.<!string,{time:!Date}>}*/
        editHistory = {};

    /**
     * @return {!Array.<{memberid:!string,time:!Date}>}
     */
    function sortEdits() {
        var /**@type {!Array.<{memberid:!string,time:!Date}>}*/
            arr = [],
            /**@type{string}*/
            memberid;
        for (memberid in editHistory) {
            if (editHistory.hasOwnProperty(memberid)) {
                arr.push({
                    'memberid': memberid,
                    'time': editHistory[memberid].time
                });
            }
        }

        arr.sort(function (a, b) {
            return a.time - b.time;
        });

        return arr;
    }

    /**
     * @return {!Element}
     */
    this.getNode = function () {
        return editInfoNode;
    };

    /**
     * @return {!ops.OdtDocument}
     */
    this.getOdtDocument = function () {
        return odtDocument;
    };

    /**
     * @return {!Object.<!string,{time:!Date}>}
     */
    this.getEdits = function () {
        return editHistory;
    };

    /**
     * Returns the sorted list of memberid/time pairs, with oldest first.
     * @return {!Array.<{memberid:!string,time:!Date}>}
     */
    this.getSortedEdits = function () {
        return sortEdits();
    };

    /**
     * @param {!string} memberid
     * @param {!Date} timestamp
     * @return {undefined}
     */
    this.addEdit = function (memberid, timestamp) {
        // log the edit time for this memberid
        editHistory[memberid] = {
            time: timestamp
        };
    };

    /**
     * @return {undefined}
     */
    this.clearEdits = function () {
        editHistory = {};
    };

    /**
     * @param {!function(!Error=)} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function (callback) {
        // TODO: have EditInfo cleaned up if the paragraph is deleted, not happening right now
        // workaround: check if the container is still in the DOM
        if (container.parentNode) {
            container.removeChild(editInfoNode);
        }
        callback();
    };

    function init() {
        var editInfons = 'urn:webodf:names:editinfo',
            dom = odtDocument.getDOMDocument();

        editInfoNode = dom.createElementNS(editInfons, 'editinfo');
        container.insertBefore(editInfoNode, container.firstChild);
    }

    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\Member.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime*/

/**
 * @constructor
 */
ops.MemberProperties = function () {
    "use strict";
    /**@type{string}*/
    this.fullName;
    /**@type{string}*/
    this.color;
    /**@type{string}*/
    this.imageUrl;
};

/**
 * Class to represent a member in WebODF.
 * A member is uniquely identified by it's memberId,
 * and this class encapsulates various things like
 * the full name and also custom properties that can represent
 * information like the avatar image, color, etc.
 * Custom properties that may contain some reserved keys such as fullName
 * (string), imageUrl (string representing a URL) and color (string
 * representing CSS color value) can be passed.
 * @constructor
 * @param {!string} memberId The unique identifier of this member.
 * @param {!ops.MemberProperties} properties
 */
ops.Member = function Member(memberId, properties) {
    "use strict";

    var /**@type{!ops.MemberProperties}*/
        props = new ops.MemberProperties();

    /**
     * Returns the member ID of the member
     * @return {!string}
     */
    function getMemberId() {
        return memberId;
    }
    /**
     * Returns the properties of the member
     * (including fullName, color, and imageUrl)
     * @return {!ops.MemberProperties}
     */
    function getProperties() {
        return props;
    }
    /**
     * Sets some properties on the member
     * @param {!Object.<!string, !string>} newProperties
     * @return {undefined}
     */
    function setProperties(newProperties) {
        Object.keys(newProperties).forEach(function (key) {
            props[key] = newProperties[key];
        });
    }

    /**
     * Removes the properties specified in the object.
     * 'fullName', 'color', and 'imageUrl' are not
     * removable, they will be filtered out of 
     * removedProperties if found.
     * @param {!Object.<string,string>} removedProperties
     * @return {undefined}
     */
    function removeProperties(removedProperties) {
        Object.keys(removedProperties).forEach(function (key) {
            if (key !== "fullName" && key !== "color" && key !== "imageUrl"
                    && props.hasOwnProperty(key)) {
                delete props[key];
            }
        });
    }

    this.getMemberId = getMemberId;
    this.getProperties = getProperties;
    this.setProperties = setProperties;
    this.removeProperties = removeProperties;

    function init() {
        runtime.assert(Boolean(memberId), "No memberId was supplied!");

        if (!properties.fullName) {
            properties.fullName = runtime.tr("Unknown Author");
        }
        if (!properties.color) {
            properties.color = "black";
        }
        if (!properties.imageUrl) {
            properties.imageUrl = "avatar-joe.png";
        }

        props = properties;
    }
    init();
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OdtCursor.js
========================================================================

/**
 * Copyright (C) 2012 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global core, ops, gui, runtime*/

/**
 * @class
 * A cursor is a dom node that visually represents a cursor in a DOM tree.
 * It should stay synchronized with the selection in the document. When
 * there is only one collapsed selection range, a cursor should be shown at
 * that point.
 *
 * Putting the cursor in the DOM tree modifies the DOM, so care should be taken
 * to keep the selection consistent. If e.g. a selection is drawn over the
 * cursor, and the cursor is updated to the selection, the cursor is removed
 * from the DOM because the selection is not collapsed. This means that the
 * offsets of the selection may have to be changed.
 *
 * When the selection is collapsed, the cursor is placed after the point of the
 * selection and the selection will stay valid. However, if the cursor was
 * placed in the DOM tree and was counted in the offset, the offset in the
 * selection should be decreased by one.
 *
 * Even when the selection allows for a cursor, it might be desireable to hide
 * the cursor by not letting it be part of the DOM.
 *
 * @constructor
 * @param {!string} memberId The memberid this cursor is assigned to
 * @param {!ops.Document} document The document in which the cursor is placed
 */
ops.OdtCursor = function OdtCursor(memberId, document) {
    "use strict";
    var self = this,
        validSelectionTypes = {},
        selectionType,
        /**@type{!core.Cursor}*/
        cursor,
        events = new core.EventNotifier([ops.OdtCursor.signalCursorUpdated]);

    /**
     * Remove the cursor from the document
     * @return {undefined}
     */
    this.removeFromDocument = function () {
        // TODO: find out if nodeAfterCursor, textNodeIncrease need to be dealt with in any way
        cursor.remove();
    };

    /**
     * Subscribe to cursor update events.
     *
     * The update event called whenever the cursor is moved around manually.
     * @param {!string} eventid
     * @param {!Function} cb
     */
    this.subscribe = function (eventid, cb) {
        events.subscribe(eventid, cb);
    };

    /**
     * Unsubscribe from cursor events
     * @param {!string} eventid
     * @param {!Function} cb
     */
    this.unsubscribe = function (eventid, cb) {
        events.unsubscribe(eventid, cb);
    };

    /**
     * Obtain the memberid the cursor is assigned to.
     * @return {string}
     */
    this.getMemberId = function () {
        return memberId;
    };
    /**
     * Obtain the node representing the cursor.
     * @return {!Element}
     */
    this.getNode = function () {
        return cursor.getNode();
    };
    /**
     * Obtain the node representing the selection start point.
     * If a 0-length range is selected (e.g., by clicking without
     * dragging),, this will return the exact same node as getNode
     * @return {!Element}
     */
    this.getAnchorNode = function () {
        return cursor.getAnchorNode();
    };
    /**
     * Obtain the currently selected range to which the cursor corresponds.
     * @return {!Range}
     */
    this.getSelectedRange = function () {
        return cursor.getSelectedRange();
    };
    /** Set the given range as the selected range for this cursor
     * @param {!Range} range,
     * @param {boolean} isForwardSelection
     * @return {undefined}
     */
    this.setSelectedRange = function (range, isForwardSelection) {
        cursor.setSelectedRange(range, isForwardSelection);
        events.emit(ops.OdtCursor.signalCursorUpdated, self);
    };
    /**
     * Returns if the selection of this cursor has the
     * same direction as the direction of the range
     * @return {boolean}
     */
    this.hasForwardSelection = function () {
        return cursor.hasForwardSelection();
    };
    /**
     * Obtain the document to which the cursor corresponds.
     * @return {!ops.Document}
     */
    this.getDocument = function () {
        return document;
    };

    /**
     * Gets the current selection type.
     * @return {!string}
     */
    this.getSelectionType = function () {
        return selectionType;
    };

    /**
     * Sets the current selection type to the given value.
     * @param {!string} value
     * @return {undefined}
     */
    this.setSelectionType = function (value) {
        if (validSelectionTypes.hasOwnProperty(value)) {
            selectionType = value;
        } else {
            runtime.log("Invalid selection type: " + value);
        }
    };

    /**
     * Reset selection type to default.
     * @return {undefined}
     */
    this.resetSelectionType = function () {
        self.setSelectionType(ops.OdtCursor.RangeSelection);
    };

    function init() {
        cursor = new core.Cursor(document.getDOMDocument(), memberId);

        validSelectionTypes[ops.OdtCursor.RangeSelection] = true;
        validSelectionTypes[ops.OdtCursor.RegionSelection] = true;
        self.resetSelectionType();
    }

    init();
};

/**@const
   @type {!string} */
ops.OdtCursor.RangeSelection = 'Range';
/**@const
   @type {!string} */
ops.OdtCursor.RegionSelection = 'Region';
/**@const
 @type {!string} */
ops.OdtCursor.signalCursorUpdated = "cursorUpdated";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OdtDocument.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global Node, runtime, core, gui, ops, odf, NodeFilter*/

    /**
     * A filter that allows a position if it has the same closest
     * whitelisted root as the specified 'anchor', which can be the cursor
     * of the given memberid, or a given node
     * @constructor
     * @implements {core.PositionFilter}
     * @param {!string|!Node} anchor
     * @param {Object.<!ops.OdtCursor>} cursors
     * @param {function(!Node):!Node} getRoot
     */
    function RootFilter(anchor, cursors, getRoot) {
        "use strict";
        var /**@const*/
        FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT,
        /**@const*/
        FILTER_REJECT = core.PositionFilter.FilterResult.FILTER_REJECT;

        /**
         * @param {!core.PositionIterator} iterator
         * @return {!core.PositionFilter.FilterResult}
         */
        this.acceptPosition = function (iterator) {
            var node = iterator.container(),
                anchorNode;

            if (typeof anchor === "string") {
                anchorNode = cursors[anchor].getNode();
            } else {
                anchorNode = anchor;
            }

            if (getRoot(node) === getRoot(anchorNode)) {
                return FILTER_ACCEPT;
            }
            return FILTER_REJECT;
        };
    }

/**
 * A document that keeps all data related to the mapped document.
 * @constructor
 * @implements {ops.Document}
 * @implements {core.Destroyable}
 * @param {!odf.OdfCanvas} odfCanvas
 */
ops.OdtDocument = function OdtDocument(odfCanvas) {
    "use strict";

    var self = this,
        /**@type{!odf.StepUtils}*/
        stepUtils,
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils,
        /**!Object.<!ops.OdtCursor>*/
        cursors = {},
        /**!Object.<!ops.Member>*/
        members = {},
        eventNotifier = new core.EventNotifier([
            ops.Document.signalMemberAdded,
            ops.Document.signalMemberUpdated,
            ops.Document.signalMemberRemoved,
            ops.Document.signalCursorAdded,
            ops.Document.signalCursorRemoved,
            ops.Document.signalCursorMoved,
            ops.OdtDocument.signalParagraphChanged,
            ops.OdtDocument.signalParagraphStyleModified,
            ops.OdtDocument.signalCommonStyleCreated,
            ops.OdtDocument.signalCommonStyleDeleted,
            ops.OdtDocument.signalTableAdded,
            ops.OdtDocument.signalOperationStart,
            ops.OdtDocument.signalOperationEnd,
            ops.OdtDocument.signalProcessingBatchStart,
            ops.OdtDocument.signalProcessingBatchEnd,
            ops.OdtDocument.signalUndoStackChanged,
            ops.OdtDocument.signalStepsInserted,
            ops.OdtDocument.signalStepsRemoved,
            ops.OdtDocument.signalMetadataUpdated,
            ops.OdtDocument.signalAnnotationAdded
        ]),
        /**@const*/
        NEXT = core.StepDirection.NEXT,
        filter,
        /**@type{!ops.OdtStepsTranslator}*/
        stepsTranslator,
        lastEditingOp,
        unsupportedMetadataRemoved = false,
        /**@const*/ SHOW_ALL = NodeFilter.SHOW_ALL,
        blacklistedNodes = new gui.BlacklistNamespaceNodeFilter(["urn:webodf:names:cursor", "urn:webodf:names:editinfo"]),
        odfTextBodyFilter = new gui.OdfTextBodyNodeFilter(),
        defaultNodeFilter = new core.NodeFilterChain([blacklistedNodes, odfTextBodyFilter]);

    /**
     *
     * @param {!Node} rootNode
     * @return {!core.PositionIterator}
     */
    function createPositionIterator(rootNode) {
        return new core.PositionIterator(rootNode, SHOW_ALL, defaultNodeFilter, false);
    }
    this.createPositionIterator = createPositionIterator;

    /**
     * Return the office:text element of this document.
     * @return {!Element}
     */
    function getRootNode() {
        var element = odfCanvas.odfContainer().getContentElement(),
            localName = element && element.localName;
        runtime.assert(localName === "text", "Unsupported content element type '" + localName + "' for OdtDocument");
        return element;
    }
    /**
     * Return the office:document element of this document.
     * @return {!Element}
     */
    this.getDocumentElement = function () {
        return odfCanvas.odfContainer().rootElement;
    };

    this.cloneDocumentElement = function () {
        var rootElement = self.getDocumentElement(),
            annotationViewManager = odfCanvas.getAnnotationViewManager(),
            initialDoc;

        if (annotationViewManager) {
            annotationViewManager.forgetAnnotations();
        }
        initialDoc = rootElement.cloneNode(true);
        odfCanvas.refreshAnnotations();
        // workaround AnnotationViewManager not fixing up cursor positions after creating the highlighting
        self.fixCursorPositions();
        return initialDoc;
    };

    /**
     * @param {!Element} documentElement
     */
    this.setDocumentElement = function (documentElement) {
        var odfContainer = odfCanvas.odfContainer(),
            rootNode;

        eventNotifier.unsubscribe(ops.OdtDocument.signalStepsInserted, stepsTranslator.handleStepsInserted);
        eventNotifier.unsubscribe(ops.OdtDocument.signalStepsRemoved, stepsTranslator.handleStepsRemoved);

        // TODO Replace with a neater hack for reloading the Odt tree
        // Once this is fixed, SelectionView.addOverlays can be removed
        odfContainer.setRootElement(documentElement);
        odfCanvas.setOdfContainer(odfContainer, true);
        odfCanvas.refreshCSS();
        rootNode = getRootNode();
        stepsTranslator = new ops.OdtStepsTranslator(rootNode, createPositionIterator(rootNode), filter, 500);
        eventNotifier.subscribe(ops.OdtDocument.signalStepsInserted, stepsTranslator.handleStepsInserted);
        eventNotifier.subscribe(ops.OdtDocument.signalStepsRemoved, stepsTranslator.handleStepsRemoved);
    };

    /**
     * @return {!Document}
     */
    function getDOMDocument() {
        return /**@type{!Document}*/(self.getDocumentElement().ownerDocument);
    }
    this.getDOMDocument = getDOMDocument;

    /**
     * @param {!Node} node
     * @return {!boolean}
     */
    function isRoot(node) {
        if ((node.namespaceURI === odf.Namespaces.officens
             && node.localName === 'text'
            ) || (node.namespaceURI === odf.Namespaces.officens
                  && node.localName === 'annotation')) {
            return true;
        }
        return false;
    }

    /**
     * @param {!Node} node
     * @return {!Node}
     */
    function getRoot(node) {
        while (node && !isRoot(node)) {
            node = /**@type{!Node}*/(node.parentNode);
        }
        return node;
    }
    this.getRootElement = getRoot;

    /**
     * Create a new StepIterator instance set to the defined position
     *
     * @param {!Node} container
     * @param {!number} offset
     * @param {!Array.<!core.PositionFilter>} filters Filter to apply to the iterator positions. If multiple
     *  iterators are provided, they will be combined in order using a PositionFilterChain.
     * @param {!Node} subTree Subtree to search for step within. Generally a paragraph or document root. Choosing
     *  a smaller subtree allows iteration to end quickly if there are no walkable steps remaining in a particular
     *  direction. This can vastly improve performance.
     *
     * @return {!core.StepIterator}
     */
    function createStepIterator(container, offset, filters, subTree) {
        var positionIterator = createPositionIterator(subTree),
            filterOrChain,
            stepIterator;

        if (filters.length === 1) {
            filterOrChain = filters[0];
        } else {
            filterOrChain = new core.PositionFilterChain();
            filters.forEach(filterOrChain.addFilter);
        }

        stepIterator = new core.StepIterator(filterOrChain, positionIterator);
        stepIterator.setPosition(container, offset);
        return stepIterator;
    }
    this.createStepIterator = createStepIterator;

    /**
     * Returns a PositionIterator instance at the
     * specified starting position
     * @param {!number} position
     * @return {!core.PositionIterator}
     */
    function getIteratorAtPosition(position) {
        var iterator = createPositionIterator(getRootNode()),
            point = stepsTranslator.convertStepsToDomPoint(position);

        iterator.setUnfilteredPosition(point.node, point.offset);
        return iterator;
    }
    this.getIteratorAtPosition = getIteratorAtPosition;

    /**
     * Converts the requested step number from root into the equivalent DOM node & offset
     * pair. If the step is outside the bounds of the document, a RangeError will be thrown.
     * @param {!number} step
     * @return {!{node: !Node, offset: !number}}
     */
    this.convertCursorStepToDomPoint = function (step) {
        return stepsTranslator.convertStepsToDomPoint(step);
    };

    /**
     * Rounds to the first step within the paragraph
     * @param {!core.StepDirection} step
     * @return {!boolean}
     */
    function roundUp(step) {
        return step === NEXT;
    }

    /**
     * Converts a DOM node and offset pair to a cursor step. If a rounding direction is not supplied then
     * the default is to round down to the previous step.
     * @param {!Node} node
     * @param {!number} offset
     * @param {core.StepDirection=} roundDirection Whether to round down to the previous step or round up
     * to the next step. The default value if unspecified is core.StepDirection.PREVIOUS
     * @return {!number}
     */
    this.convertDomPointToCursorStep = function (node, offset, roundDirection) {
        var roundingFunc;
        if(roundDirection === NEXT) {
            roundingFunc = roundUp;
        }

        return stepsTranslator.convertDomPointToSteps(node, offset, roundingFunc);
    };

    /**
     * @param {!{anchorNode: !Node, anchorOffset: !number, focusNode: !Node, focusOffset: !number}} selection
     * @return {!{position: !number, length: number}}
     */
    this.convertDomToCursorRange = function (selection) {
        var point1,
            point2;

        point1 = stepsTranslator.convertDomPointToSteps(selection.anchorNode, selection.anchorOffset);
        if (selection.anchorNode === selection.focusNode && selection.anchorOffset === selection.focusOffset) {
            point2 = point1;
        } else {
            point2 = stepsTranslator.convertDomPointToSteps(selection.focusNode, selection.focusOffset);
        }

        return {
            position: point1,
            length: point2 - point1
        };
    };

    /**
     * Convert a cursor range to a DOM range
     * @param {!number} position
     * @param {!number} length
     * @return {!Range}
     */
    this.convertCursorToDomRange = function (position, length) {
        var range = getDOMDocument().createRange(),
            point1,
            point2;

        point1 = stepsTranslator.convertStepsToDomPoint(position);
        if (length) {
            point2 = stepsTranslator.convertStepsToDomPoint(position + length);
            if (length > 0) {
                range.setStart(point1.node, point1.offset);
                range.setEnd(point2.node, point2.offset);
            } else {
                range.setStart(point2.node, point2.offset);
                range.setEnd(point1.node, point1.offset);
            }
        } else {
            range.setStart(point1.node, point1.offset);
        }
        return range;
    };

    /**
     * This function will iterate through positions allowed by the position
     * iterator and count only the text positions. When the amount defined by
     * offset has been counted, the Text node that that position is returned
     * as well as the offset in that text node.
     * Optionally takes a memberid of a cursor, to specifically return the
     * text node positioned just behind that cursor.
     * @param {!number} steps
     * @param {!string=} memberid
     * @return {?{textNode: !Text, offset: !number}}
     */
    function getTextNodeAtStep(steps, memberid) {
        var iterator = getIteratorAtPosition(steps),
            node = iterator.container(),
            lastTextNode,
            nodeOffset = 0,
            cursorNode = null,
            text;

        if (node.nodeType === Node.TEXT_NODE) {
            // Iterator has stopped within an existing text node, to put that up as a possible target node
            lastTextNode = /**@type{!Text}*/(node);
            nodeOffset = /**@type{!number}*/(iterator.unfilteredDomOffset());
            // Always cut in a new empty text node at the requested position.
            // If this proves to be unnecessary, it will be cleaned up just before the return
            // after all necessary cursor rearrangements have been performed
            if (lastTextNode.length > 0) {
                // The node + offset returned make up the boundary just to the right of the requested step
                if (nodeOffset > 0) {
                    // In this case, after the split, the right of the requested step is just after the new node
                    lastTextNode = lastTextNode.splitText(nodeOffset);
                }
                lastTextNode.parentNode.insertBefore(getDOMDocument().createTextNode(""), lastTextNode);
                lastTextNode = /**@type{!Text}*/(lastTextNode.previousSibling);
                nodeOffset = 0;
            }
        } else {
            // There is no text node at the current position, so insert a new one at the current position
            lastTextNode = getDOMDocument().createTextNode("");
            nodeOffset = 0;
            node.insertBefore(lastTextNode, iterator.rightNode());
        }

        if (memberid) {
            // DEPRECATED: This branch is no longer the recommended way of handling cursor movements DO NOT USE
            // If the member cursor is as the requested position
            if (cursors[memberid] && self.getCursorPosition(memberid) === steps) {
                cursorNode = cursors[memberid].getNode();
                // Then move the member's cursor after all adjacent cursors
                while (cursorNode.nextSibling && cursorNode.nextSibling.localName === "cursor") {
                    // TODO this re-arrange logic will break if there are non-cursor elements in the way
                    // E.g., cursors occupy the same "step", but are on different sides of a span boundary
                    // This is currently avoided by calling fixCursorPositions after (almost) every op
                    // to re-arrange cursors together again
                    cursorNode.parentNode.insertBefore(cursorNode.nextSibling, cursorNode);
                }
                if (lastTextNode.length > 0 && lastTextNode.nextSibling !== cursorNode) {
                    // The last text node contains content but is not adjacent to the cursor
                    // This can't be moved, as moving it would move the text content around as well. Yikes!
                    // So, create a new text node to insert data into
                    lastTextNode = getDOMDocument().createTextNode('');
                    nodeOffset = 0;
                }
                // Keep the destination text node right next to the member's cursor, so inserted text pushes the cursor over
                cursorNode.parentNode.insertBefore(lastTextNode, cursorNode);
            }
        } else {
            // Move all cursors BEFORE the new text node. Any cursors occupying the requested position should not
            // move when new text is added in the position
            while (lastTextNode.nextSibling && lastTextNode.nextSibling.localName === "cursor") {
                // TODO this re-arrange logic will break if there are non-cursor elements in the way
                // E.g., cursors occupy the same "step", but are on different sides of a span boundary
                // This is currently avoided by calling fixCursorPositions after (almost) every op
                // to re-arrange cursors together again
                lastTextNode.parentNode.insertBefore(lastTextNode.nextSibling, lastTextNode);
            }
        }

        // After the above cursor adjustments, if the lastTextNode
        // has a text node previousSibling, merge them and make the result the lastTextNode
        while (lastTextNode.previousSibling && lastTextNode.previousSibling.nodeType === Node.TEXT_NODE) {
            text = /**@type{!Text}*/(lastTextNode.previousSibling);
            text.appendData(lastTextNode.data);
            nodeOffset = text.length;
            lastTextNode = text;
            lastTextNode.parentNode.removeChild(lastTextNode.nextSibling);
        }

        // Empty text nodes can be left on either side of the split operations that have occurred
        while (lastTextNode.nextSibling && lastTextNode.nextSibling.nodeType === Node.TEXT_NODE) {
            text = /**@type{!Text}*/(lastTextNode.nextSibling);
            lastTextNode.appendData(text.data);
            lastTextNode.parentNode.removeChild(text);
        }

        return {textNode: lastTextNode, offset: nodeOffset };
    }

    /**
     * Called after an operation is executed, this
     * function will check if the operation is an
     * 'edit', and in that case will update the
     * document's metadata, such as dc:creator,
     * meta:editing-cycles, and dc:creator.
     * @param {!ops.Operation} op
     */
    function handleOperationExecuted(op) {
        var opspec = op.spec(),
            memberId = opspec.memberid,
            date = new Date(opspec.timestamp).toISOString(),
            odfContainer = odfCanvas.odfContainer(),
            /**@type{!{setProperties: !Object, removedProperties: ?Array.<!string>}}*/
            changedMetadata,
            fullName;

        // If the operation is an edit (that changes the
        // ODF that will be saved), then update metadata.
        if (op.isEdit) {
            fullName = self.getMember(memberId).getProperties().fullName;
            odfContainer.setMetadata({
                "dc:creator": fullName,
                "dc:date": date
            }, null);

            changedMetadata = {
                setProperties: {
                    "dc:creator": fullName,
                    "dc:date": date
                },
                removedProperties: []
            };

            // If no previous op was found in this session,
            // then increment meta:editing-cycles by 1.
            if (!lastEditingOp) {
                changedMetadata.setProperties["meta:editing-cycles"] = odfContainer.incrementEditingCycles();
                // Remove certain metadata fields that
                // should be updated as soon as edits happen,
                // but cannot be because we don't support those yet.
                if (!unsupportedMetadataRemoved) {
                    odfContainer.setMetadata(null, [
                        "meta:editing-duration",
                        "meta:document-statistic"
                    ]);
                }
            }

            lastEditingOp = op;
            self.emit(ops.OdtDocument.signalMetadataUpdated, changedMetadata);
        }
    }

    /**
     * Upgrades literal whitespaces (' ') to <text:s> </text:s>,
     * when given a textNode containing the whitespace and an offset
     * indicating the location of the whitespace in it.
     * @param {!Text} textNode
     * @param {!number} offset
     * @return {!Element}
     */
    function upgradeWhitespaceToElement(textNode, offset) {
        runtime.assert(textNode.data[offset] === ' ', "upgradeWhitespaceToElement: textNode.data[offset] should be a literal space");

        var space = textNode.ownerDocument.createElementNS(odf.Namespaces.textns, 'text:s'),
            container = textNode.parentNode,
            adjacentNode = textNode;

        space.appendChild(textNode.ownerDocument.createTextNode(' '));

        if (textNode.length === 1) {
            // The space is the only element in this node. Can simply replace it
            container.replaceChild(space, textNode);
        } else {
            textNode.deleteData(offset, 1);
            if (offset > 0) { // Don't create an empty text node if the offset is 0...
                if (offset < textNode.length) {
                    // Don't split if offset === textNode.length as this would add an empty text node after
                    textNode.splitText(offset);
                }
                adjacentNode = textNode.nextSibling;
            }
            container.insertBefore(space, adjacentNode);
        }
        return space;
    }

    /**
     * @param {!number} step
     * @return {undefined}
     */
    function upgradeWhitespacesAtPosition(step) {
        var positionIterator = getIteratorAtPosition(step),
            stepIterator = new core.StepIterator(filter, positionIterator),
            contentBounds,
            /**@type{?Node}*/
            container,
            offset,
            stepsToUpgrade = 2;

        // The step passed into this function is the point of change. Need to
        // upgrade whitespace to the left of the current step, and to the left of the next step
        runtime.assert(stepIterator.isStep(), "positionIterator is not at a step (requested step: " + step + ")");

        do {
            contentBounds = stepUtils.getContentBounds(stepIterator);
            if (contentBounds) {
                container = contentBounds.container;
                offset = contentBounds.startOffset;
                if (container.nodeType === Node.TEXT_NODE
                    && odfUtils.isSignificantWhitespace(/**@type{!Text}*/(container), offset)) {
                    container = upgradeWhitespaceToElement(/**@type{!Text}*/(container), offset);
                    // Reset the iterator position to the same step it was just on, which was just to
                    // the right of a space
                    stepIterator.setPosition(container, container.childNodes.length);
                    stepIterator.roundToPreviousStep();
                }
            }
            stepsToUpgrade -= 1;
        } while (stepsToUpgrade > 0 && stepIterator.nextStep());
    }

    /**
     * Upgrades any significant whitespace at the requested step, and one step right of the given
     * position to space elements.
     * @param {!number} step
     * @return {undefined}
     */
    this.upgradeWhitespacesAtPosition = upgradeWhitespacesAtPosition;

    /**
     * Returns the maximum available offset for the specified node.
     * @param {!Node} node
     * @return {!number}
     */
    function maxOffset(node) {
        return node.nodeType === Node.TEXT_NODE ? /**@type{!Text}*/(node).length : node.childNodes.length;
    }

    /**
     * Downgrades white space elements to normal spaces at the step iterators current step, and one step
     * to the right.
     *
     * @param {!core.StepIterator} stepIterator
     * @return {undefined}
     */
    function downgradeWhitespaces(stepIterator) {
        var contentBounds,
            /**@type{!Node}*/
            container,
            modifiedNodes = [],
            lastChild,
            stepsToUpgrade = 2;

        // The step passed into this function is the point of change. Need to
        // downgrade whitespace to the left of the current step, and to the left of the next step
        runtime.assert(stepIterator.isStep(), "positionIterator is not at a step");

        do {
            contentBounds = stepUtils.getContentBounds(stepIterator);
            if (contentBounds) {
                container = contentBounds.container;
                if (odfUtils.isDowngradableSpaceElement(container)) {
                    lastChild = /**@type{!Node}*/(container.lastChild);
                    while(container.firstChild) {
                        // Merge contained space text node up to replace container
                        modifiedNodes.push(container.firstChild);
                        container.parentNode.insertBefore(container.firstChild, container);
                    }
                    container.parentNode.removeChild(container);
                    // Reset the iterator position to the same step it was just on, which was just to
                    // the right of a space
                    stepIterator.setPosition(lastChild, maxOffset(lastChild));
                    stepIterator.roundToPreviousStep();
                }
            }
            stepsToUpgrade -= 1;
        } while (stepsToUpgrade > 0 && stepIterator.nextStep());

        modifiedNodes.forEach(domUtils.normalizeTextNodes);
    }
    this.downgradeWhitespaces = downgradeWhitespaces;

    /**
     * Downgrades white space elements to normal spaces at the specified step, and one step
     * to the right.
     *
     * @param {!number} step
     * @return {undefined}
     */
    this.downgradeWhitespacesAtPosition = function (step) {
        var positionIterator = getIteratorAtPosition(step),
            stepIterator = new core.StepIterator(filter, positionIterator);

        downgradeWhitespaces(stepIterator);
    };

    /**
     * This function will return the Text node as well as the offset in that text node
     * of the cursor.
     * @param {!number} position
     * @param {!string=} memberid
     * @return {?{textNode: !Text, offset: !number}}
     */
    this.getTextNodeAtStep = getTextNodeAtStep;

    /**
     * Returns the closest parent paragraph or root to the supplied container and offset
     * @param {!Node} container
     * @param {!number} offset
     * @param {!Node} root
     *
     * @return {!Node}
     */
    function paragraphOrRoot(container, offset, root) {
        var node = container.childNodes.item(offset) || container,
            paragraph = odfUtils.getParagraphElement(node);
        if (paragraph && domUtils.containsNode(root, paragraph)) {
            // Only return the paragraph if it is contained within the destination root
            return /**@type{!Node}*/(paragraph);
        }
        // Otherwise the step filter should be contained within the supplied root
        return root;
    }

    /**
     * Iterates through all cursors and checks if they are in
     * walkable positions; if not, move the cursor 1 filtered step backward
     * which guarantees walkable state for all cursors,
     * while keeping them inside the same root. An event will be raised for this cursor if it is moved
     */
    this.fixCursorPositions = function () {
        Object.keys(cursors).forEach(function (memberId) {
            var cursor = cursors[memberId],
                root = getRoot(cursor.getNode()),
                rootFilter = self.createRootFilter(root),
                subTree,
                startPoint,
                endPoint,
                selectedRange,
                cursorMoved = false;

            selectedRange = cursor.getSelectedRange();
            subTree = paragraphOrRoot(/**@type{!Node}*/(selectedRange.startContainer), selectedRange.startOffset, root);
            startPoint = createStepIterator(/**@type{!Node}*/(selectedRange.startContainer), selectedRange.startOffset,
                [filter, rootFilter], subTree);

            if (!selectedRange.collapsed) {
                subTree = paragraphOrRoot(/**@type{!Node}*/(selectedRange.endContainer), selectedRange.endOffset, root);
                endPoint = createStepIterator(/**@type{!Node}*/(selectedRange.endContainer), selectedRange.endOffset,
                    [filter, rootFilter], subTree);
            } else {
                endPoint = startPoint;
            }

            if (!startPoint.isStep() || !endPoint.isStep()) {
                cursorMoved = true;
                runtime.assert(startPoint.roundToClosestStep(), "No walkable step found for cursor owned by " + memberId);
                selectedRange.setStart(startPoint.container(), startPoint.offset());
                runtime.assert(endPoint.roundToClosestStep(), "No walkable step found for cursor owned by " + memberId);
                selectedRange.setEnd(endPoint.container(), endPoint.offset());
            } else if (startPoint.container() === endPoint.container() && startPoint.offset() === endPoint.offset()) {
                // The range *should* be collapsed
                if (!selectedRange.collapsed || cursor.getAnchorNode() !== cursor.getNode()) {
                    // It might not be collapsed if there are other unwalkable nodes (e.g., cursors)
                    // between the cursor and anchor nodes. In this case, force the cursor to collapse
                    cursorMoved = true;
                    selectedRange.setStart(startPoint.container(), startPoint.offset());
                    selectedRange.collapse(true);
                }
            }

            if (cursorMoved) {
                cursor.setSelectedRange(selectedRange, cursor.hasForwardSelection());
                self.emit(ops.Document.signalCursorMoved, cursor);
            }
        });
    };

    /**
     * This function returns the position in ODF world of the cursor of the member.
     * @param {!string} memberid
     * @return {!number}
     */
    this.getCursorPosition = function (memberid) {
        var cursor = cursors[memberid];
        return cursor ? stepsTranslator.convertDomPointToSteps(cursor.getNode(), 0) : 0;
    };

    /**
     * This function returns the position and selection length in ODF world of
     * the cursor of the member.
     * position is always the number of steps from root node to the anchor node
     * length is the number of steps from anchor node to focus node
     * !IMPORTANT! length is a vector, and may be negative if the cursor selection
     * is reversed (i.e., user clicked and dragged the cursor backwards)
     * @param {!string} memberid
     * @return {{position: !number, length: !number}}
     */
    this.getCursorSelection = function (memberid) {
        var cursor = cursors[memberid],
            focusPosition = 0,
            anchorPosition = 0;
        if (cursor) {
            focusPosition = stepsTranslator.convertDomPointToSteps(cursor.getNode(), 0);
            anchorPosition = stepsTranslator.convertDomPointToSteps(cursor.getAnchorNode(), 0);
        }
        return {
            position: anchorPosition,
            length: focusPosition - anchorPosition
        };
    };
    /**
     * @return {!core.PositionFilter}
     */
    this.getPositionFilter = function () {
        return filter;
    };

    /**
     * @return {!odf.OdfCanvas}
     */
    this.getOdfCanvas = function () {
        return odfCanvas;
    };

    /**
     * @return {!ops.Canvas}
     */
    this.getCanvas = function () {
        return odfCanvas;
    };

    /**
     * @return {!Element}
     */
    this.getRootNode = getRootNode;

    /**
     * @param {!ops.Member} member
     * @return {undefined}
     */
    this.addMember = function (member) {
        runtime.assert(members[member.getMemberId()] === undefined, "This member already exists");
        members[member.getMemberId()] = member;
    };

    /**
     * @param {!string} memberId
     * @return {?ops.Member}
     */
    this.getMember = function (memberId) {
        return members.hasOwnProperty(memberId) ? members[memberId] : null;
    };

    /**
     * @param {!string} memberId
     * @return {undefined}
     */
    this.removeMember = function (memberId) {
        delete members[memberId];
    };

    /**
     * @param {!string} memberid
     * @return {ops.OdtCursor}
     */
    this.getCursor = function (memberid) {
        return cursors[memberid];
    };

    /**
     * @param {!string} memberid
     * @return {!boolean}
     */
    this.hasCursor = function (memberid) {
        return cursors.hasOwnProperty(memberid);
    };
    /**
     * @return {!Array.<string>}
     */
    this.getMemberIds = function () {
        return Object.keys(members);
    };

    /**
     * Adds the specified cursor to the ODT document. The cursor will be collapsed
     * to the first available cursor position in the document.
     * @param {!ops.OdtCursor} cursor
     * @return {undefined}
     */
    this.addCursor = function (cursor) {
        runtime.assert(Boolean(cursor), "OdtDocument::addCursor without cursor");
        var memberid = cursor.getMemberId(),
            initialSelection = self.convertCursorToDomRange(0, 0);

        runtime.assert(typeof memberid === "string", "OdtDocument::addCursor has cursor without memberid");
        runtime.assert(!cursors[memberid], "OdtDocument::addCursor is adding a duplicate cursor with memberid " + memberid);
        cursor.setSelectedRange(initialSelection, true);

        cursors[memberid] = cursor;
    };

    /**
     * @param {!string} memberid
     * @return {!boolean}
     */
    this.removeCursor = function (memberid) {
        var cursor = cursors[memberid];
        if (cursor) {
            cursor.removeFromDocument();
            delete cursors[memberid];
            self.emit(ops.Document.signalCursorRemoved, memberid);
            return true;
        }
        return false;
    };

    /**
     * Moves the cursor/selection of a given memberid to the
     * given position+length combination and adopts the given
     * selectionType.
     * It is the caller's responsibility to decide if and when
     * to subsequently fire signalCursorMoved.
     * @param {!string} memberid
     * @param {!number} position
     * @param {!number} length
     * @param {!string=} selectionType
     * @return {undefined}
     */
    this.moveCursor = function (memberid, position, length, selectionType) {
        var cursor = cursors[memberid],
            selectionRange = self.convertCursorToDomRange(position, length);
        if (cursor) {
            cursor.setSelectedRange(selectionRange, length >= 0);
            cursor.setSelectionType(selectionType || ops.OdtCursor.RangeSelection);
        }
    };

    /**
     * @return {!odf.Formatting}
     */
    this.getFormatting = function () {
        return odfCanvas.getFormatting();
    };

    /**
     * @param {!string} eventid
     * @param {*} args
     * @return {undefined}
     */
    this.emit = function (eventid, args) {
        eventNotifier.emit(eventid, args);
    };

    /**
     * @param {!string} eventid
     * @param {!Function} cb
     * @return {undefined}
     */
    this.subscribe = function (eventid, cb) {
        eventNotifier.subscribe(eventid, cb);
    };

    /**
     * @param {!string} eventid
     * @param {!Function} cb
     * @return {undefined}
     */
    this.unsubscribe = function (eventid, cb) {
        eventNotifier.unsubscribe(eventid, cb);
    };

    /**
     * @param {string|!Node} inputMemberId
     * @return {!RootFilter}
     */
    this.createRootFilter = function (inputMemberId) {
        return new RootFilter(inputMemberId, cursors, getRoot);
    };

    /**
     * @param {!function(!Object=)} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.close = function (callback) {
        // TODO: check if anything needs to be cleaned up
        callback();
    };

    /**
     * @param {!function(!Error=)} callback, passing an error object in case of error
     * @return {undefined}
     */
    this.destroy = function (callback) {
        callback();
    };

    /**
     * @return {undefined}
     */
    function init() {
        var rootNode = getRootNode();

        filter = new ops.TextPositionFilter();
        stepUtils = new odf.StepUtils();
        stepsTranslator = new ops.OdtStepsTranslator(rootNode, createPositionIterator(rootNode), filter, 500);
        eventNotifier.subscribe(ops.OdtDocument.signalStepsInserted, stepsTranslator.handleStepsInserted);
        eventNotifier.subscribe(ops.OdtDocument.signalStepsRemoved, stepsTranslator.handleStepsRemoved);
        eventNotifier.subscribe(ops.OdtDocument.signalOperationEnd, handleOperationExecuted);
        eventNotifier.subscribe(ops.OdtDocument.signalProcessingBatchEnd, core.Task.processTasks);
    }
    init();
};

/**@const*/ops.OdtDocument.signalParagraphChanged = "paragraph/changed";
/**@const*/ops.OdtDocument.signalTableAdded = "table/added";
/**@const*/ops.OdtDocument.signalCommonStyleCreated = "style/created";
/**@const*/ops.OdtDocument.signalCommonStyleDeleted = "style/deleted";
/**@const*/ops.OdtDocument.signalParagraphStyleModified = "paragraphstyle/modified";
/**@const*/ops.OdtDocument.signalOperationStart = "operation/start";
/**@const*/ops.OdtDocument.signalOperationEnd = "operation/end";
/**@const*/ops.OdtDocument.signalProcessingBatchStart = "router/batchstart";
/**@const*/ops.OdtDocument.signalProcessingBatchEnd = "router/batchend";
/**@const*/ops.OdtDocument.signalUndoStackChanged = "undo/changed";
/**@const*/ops.OdtDocument.signalStepsInserted = "steps/inserted";
/**@const*/ops.OdtDocument.signalStepsRemoved = "steps/removed";
/**@const*/ops.OdtDocument.signalMetadataUpdated = "metadata/updated";
/**@const*/ops.OdtDocument.signalAnnotationAdded = "annotation/added";

// vim:expandtab

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OdtStepsTranslator.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, core, ops, odf*/

(function () {
    "use strict";

    /**
     *
     * @constructor
     * @param {!Element} rootNode
     * @param {!core.PositionIterator} iterator
     * @param {!core.PositionFilter} filter
     * @param {!number} bucketSize  Minimum number of steps between cache points
     */
    ops.OdtStepsTranslator = function OdtStepsTranslator(rootNode, iterator, filter, bucketSize) {
        var /**@type{!ops.StepsCache}*/
            stepsCache,
            odfUtils = odf.OdfUtils,
            domUtils = core.DomUtils,
            /**@const*/
            FILTER_ACCEPT = core.PositionFilter.FilterResult.FILTER_ACCEPT,
            /**@const*/
            PREVIOUS = core.StepDirection.PREVIOUS,
            /**@const*/
            NEXT = core.StepDirection.NEXT;

        /**
         * Update the steps cache based on the current iterator position. This can either add new
         * bookmarks or update existing references and repair damaged regions of the cache.
         *
         * @param {!number} steps
         * @param {!core.PositionIterator} iterator
         * @param {!boolean} isStep
         * @return {undefined}
         */
        function updateCache(steps, iterator, isStep) {
            var node = iterator.getCurrentNode();

            if (iterator.isBeforeNode() && odfUtils.isParagraph(node)) {
                if (!isStep) {
                    // Paragraph bookmarks indicate "first position in the paragraph"
                    // If the current stable point is before the first walkable position (as often happens)
                    // simply increase the step number by 1 to move to within the paragraph node
                    steps += 1;
                }
                stepsCache.updateBookmark(steps, node);
            }
        }

        /**
         * Saved bookmarks always represent the first step inside the corresponding paragraph or node. Based on the
         * current TextPositionFilter impl, this means rounding up if the current iterator position is not on a step.
         * @param {!number} steps
         * @param {!core.PositionIterator} iterator
         * @return {undefined}
         */
        function roundUpToStep(steps, iterator) {
            do {
                if (filter.acceptPosition(iterator) === FILTER_ACCEPT) {
                    // Have reached the step represented by the paragraph bookmark
                    updateCache(steps, iterator, true);
                    break;
                }
                // This logic inverts the +1 logic in updateCache. Conceptually speaking, the stored
                // bookmark represents the first step in the paragraph. Until the first step is found,
                // the iterator is still technically on steps-1.
                updateCache(steps - 1, iterator, false);
            } while (iterator.nextPosition());
        }

        /**
         * Convert the requested steps from root into the equivalent DOM node & offset pair. If the
         * requested step is before the start or past the end of the document, a RangeError will be thrown.
         * @param {!number} steps
         * @return {!{node: !Node, offset: !number}}
         */
        this.convertStepsToDomPoint = function (steps) {
            var /**@type{!number}*/
                stepsFromRoot,
                isStep;

            if (isNaN(steps)) {
                throw new TypeError("Requested steps is not numeric (" + steps + ")");
            }
            if (steps < 0) {
                throw new RangeError("Requested steps is negative (" + steps + ")");
            }
            stepsFromRoot = stepsCache.setToClosestStep(steps, iterator);

            while (stepsFromRoot < steps && iterator.nextPosition()) {
                isStep = filter.acceptPosition(iterator) === FILTER_ACCEPT;
                if (isStep) {
                    stepsFromRoot += 1;
                }
                updateCache(stepsFromRoot, iterator, isStep);
            }
            if (stepsFromRoot !== steps) {
                throw new RangeError("Requested steps (" + steps + ") exceeds available steps (" + stepsFromRoot + ")");
            }
            return {
                node: iterator.container(),
                offset: iterator.unfilteredDomOffset()
            };
        };

        /**
         * Uses the provided delegate to choose between rounding up or rounding down to the nearest step.
         * @param {!core.PositionIterator} iterator
         * @param {function(!core.StepDirection, !Node, !number):boolean=} roundDirection
         * @return {!boolean} Returns true if an accepted position is found, otherwise returns false.
         */
        function roundToPreferredStep(iterator, roundDirection) {
            if (!roundDirection || filter.acceptPosition(iterator) === FILTER_ACCEPT) {
                return true;
            }

            while (iterator.previousPosition()) {
                if (filter.acceptPosition(iterator) === FILTER_ACCEPT) {
                    if (roundDirection(PREVIOUS, iterator.container(), iterator.unfilteredDomOffset())) {
                        return true;
                    }
                    break;
                }
            }

            while (iterator.nextPosition()) {
                if (filter.acceptPosition(iterator) === FILTER_ACCEPT) {
                    if (roundDirection(NEXT, iterator.container(), iterator.unfilteredDomOffset())) {
                        return true;
                    }
                    break;
                }
            }

            return false;
        }

        /**
         * Convert the supplied DOM node & offset pair into it's equivalent steps from root
         * If the node & offset is not in an accepted location, the
         * roundDirection delegate is used to choose between rounding up or
         * rounding down to the nearest step. If not provided, the default
         * behaviour is to round down.
         * @param {!Node} node
         * @param {!number} offset
         * @param {function(!core.StepDirection, !Node, !number):!boolean=} roundDirection
         * @return {!number}
         */
        this.convertDomPointToSteps = function (node, offset, roundDirection) {
            var stepsFromRoot,
                beforeRoot,
                destinationNode,
                destinationOffset,
                rounding = 0,
                isStep;

            if (!domUtils.containsNode(rootNode, node)) {
                beforeRoot = domUtils.comparePoints(rootNode, 0, node, offset) < 0;
                node = /**@type{!Node}*/(rootNode);
                offset = beforeRoot ? 0 : /**@type{!Element}*/(rootNode).childNodes.length;
            }

            iterator.setUnfilteredPosition(node, offset);
            // if the user has set provided a rounding selection delegate, use that to select the previous or next
            // step if the (node, offset) position is not accepted by the filter
            if (!roundToPreferredStep(iterator, roundDirection)) {
                // The rounding selection delegate rejected both. Revert back to the previous step
                iterator.setUnfilteredPosition(node, offset);
            }

            // Get the iterator equivalent position of the current node & offset
            // This ensures the while loop will match the exact container and offset during iteration
            destinationNode = iterator.container();
            destinationOffset = iterator.unfilteredDomOffset();

            stepsFromRoot = stepsCache.setToClosestDomPoint(destinationNode, destinationOffset, iterator);
            if (domUtils.comparePoints(iterator.container(), iterator.unfilteredDomOffset(), destinationNode, destinationOffset) < 0) {
                // Special case: the requested DOM point is between the bookmark node and walkable step it represents
                return stepsFromRoot > 0 ? stepsFromRoot - 1 : stepsFromRoot;
            }

            while (!(iterator.container() === destinationNode && iterator.unfilteredDomOffset() === destinationOffset)
                    && iterator.nextPosition()) {
                isStep = filter.acceptPosition(iterator) === FILTER_ACCEPT;
                if (isStep) {
                    stepsFromRoot += 1;
                }
                updateCache(stepsFromRoot, iterator, isStep);
            }
            return stepsFromRoot + rounding;
        };

        /**
         * Iterates over all available positions starting at the root node and primes the cache
         * @return {undefined}
         */
        this.prime = function () {
            var stepsFromRoot,
                isStep;

            stepsFromRoot = stepsCache.setToClosestStep(0, iterator);
            while (iterator.nextPosition()) {
                isStep = filter.acceptPosition(iterator) === FILTER_ACCEPT;
                if (isStep) {
                    stepsFromRoot += 1;
                }
                updateCache(stepsFromRoot, iterator, isStep);
            }
        };

        /**
         * @param {!{position: !number}} eventArgs
         * @return {undefined}
         */
        this.handleStepsInserted = function (eventArgs) {
            // Old position = position
            // New position = position + length
            // E.g., {position: 10, length: 1} indicates 10 => 10, New => 11, 11 => 12, 12 => 13
            stepsCache.damageCacheAfterStep(eventArgs.position);
        };

        /**
         * @param {!{position: !number}} eventArgs
         * @return {undefined}
         */
        this.handleStepsRemoved = function (eventArgs) {
            // Old position = position + length
            // New position = position
            // E.g., {position: 10, length: 1} indicates 10 => 10, 11 => 10, 12 => 11

            // TODO OpRemoveText inaccurately reports the position making it necessary subtract 1
            // Paragraph merge behaviours might result in the paragraph exactly at the reported position being
            // replaced by a later paragraph. Conceptually, this means the last unmodified position is
            // actually 1 step prior to the replace paragraph.
            stepsCache.damageCacheAfterStep(eventArgs.position - 1);
        };

        function init() {
            stepsCache = new ops.StepsCache(rootNode, bucketSize, roundUpToStep);
        }
        init();
    };
}());

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpAddAnnotation.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, core, odf, runtime*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpAddAnnotation = function OpAddAnnotation() {
    "use strict";

    var memberid, timestamp,
        /**@type{number}*/
        position,
        /**@type{!number|undefined}*/
        length,
        /**@type{string}*/
        name,
        /**@type{!Document}*/
        doc;

    /**
     * @param {!ops.OpAddAnnotation.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = parseInt(data.timestamp, 10);
        position = parseInt(data.position, 10);
        length = (data.length !== undefined) ? (parseInt(data.length, 10) || 0) : undefined;
        name = data.name;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * Creates an office:annotation node with a dc:creator, dc:date, and a paragraph wrapped within
     * a list, inside it; and with the given annotation name
     * @param {!ops.OdtDocument} odtDocument
     * @param {!Date} date
     * @return {!odf.AnnotationElement}
     */
    function createAnnotationNode(odtDocument, date) {
        var annotationNode, creatorNode, dateNode,
            listNode, listItemNode, paragraphNode;

        // Create an office:annotation node with the calculated name, and an attribute with the memberid
        // for SessionView styling
        annotationNode = /**@type{!odf.AnnotationElement}*/(doc.createElementNS(odf.Namespaces.officens, 'office:annotation'));
        annotationNode.setAttributeNS(odf.Namespaces.officens, 'office:name', name);

        creatorNode = doc.createElementNS(odf.Namespaces.dcns, 'dc:creator');
        creatorNode.setAttributeNS('urn:webodf:names:editinfo', 'editinfo:memberid', memberid);
        creatorNode.textContent = odtDocument.getMember(memberid).getProperties().fullName;

        // Date.toISOString return the current Dublin Core representation
        dateNode = doc.createElementNS(odf.Namespaces.dcns, 'dc:date');
        dateNode.appendChild(doc.createTextNode(date.toISOString()));

        // Add a text:list > text:list-item > text:p hierarchy as a child of the annotation node
        listNode = doc.createElementNS(odf.Namespaces.textns, 'text:list');
        listItemNode = doc.createElementNS(odf.Namespaces.textns, 'text:list-item');
        paragraphNode = doc.createElementNS(odf.Namespaces.textns, 'text:p');
        listItemNode.appendChild(paragraphNode);
        listNode.appendChild(listItemNode);

        annotationNode.appendChild(creatorNode);
        annotationNode.appendChild(dateNode);
        annotationNode.appendChild(listNode);

        return annotationNode;
    }

    /**
     * Creates an office:annotation-end node with the given annotation name
     * @return {!Element}
     */
    function createAnnotationEnd() {
        var annotationEnd;

        // Create an office:annotation-end node with the calculated name
        annotationEnd = doc.createElementNS(odf.Namespaces.officens, 'office:annotation-end');
        annotationEnd.setAttributeNS(odf.Namespaces.officens, 'office:name', name);

        return annotationEnd;
    }

    /**
     * Inserts the element at a given position
     * @param {!ops.OdtDocument} odtDocument
     * @param {!Element} node
     * @param {!number} insertPosition
     * @return {undefined}
     */
    function insertNodeAtPosition(odtDocument, node, insertPosition) {
        var previousNode,
            parentNode,
            domPosition = odtDocument.getTextNodeAtStep(insertPosition, memberid);

        if (domPosition) {
            previousNode = domPosition.textNode;
            parentNode = previousNode.parentNode;

            if (domPosition.offset !== previousNode.length) {
                previousNode.splitText(domPosition.offset);
            }

            parentNode.insertBefore(node, previousNode.nextSibling);
            // clean up any empty text node which was created by odtDocument.getTextNodeAtStep or previousNode.splitText
            if (previousNode.length === 0) {
                parentNode.removeChild(previousNode);
            }
        }
    }

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            annotation, annotationEnd,
            cursor = odtDocument.getCursor(memberid),
            selectedRange,
            paragraphElement;

        doc = odtDocument.getDOMDocument();

        annotation = createAnnotationNode(odtDocument, new Date(timestamp));

        if (length !== undefined) {
            annotationEnd = createAnnotationEnd();
            // link annotation end to start
            annotation.annotationEndElement = annotationEnd;
            // Insert the end node before inserting the annotation node, so we don't
            // affect the addressing, and length is always positive
            insertNodeAtPosition(odtDocument, annotationEnd, position + length);
        }
        insertNodeAtPosition(odtDocument, annotation, position);
        odtDocument.emit(ops.OdtDocument.signalStepsInserted, {position: position});

        // Move the cursor inside the new annotation,
        // by selecting the paragraph's range.
        if (cursor) {
            selectedRange = doc.createRange();
            paragraphElement = /**@type{!Element}*/(annotation.getElementsByTagNameNS(odf.Namespaces.textns, "p")[0]);
            selectedRange.selectNodeContents(paragraphElement);
            cursor.setSelectedRange(selectedRange, false);
            cursor.setSelectionType(ops.OdtCursor.RangeSelection);
            odtDocument.emit(ops.Document.signalCursorMoved, cursor);
        }
        // Track this annotation
        odtDocument.getOdfCanvas().addAnnotation(annotation);
        odtDocument.fixCursorPositions();
        odtDocument.emit(ops.OdtDocument.signalAnnotationAdded, { memberId: memberid, annotation: annotation });

        return true;
    };

    /**
     * @return {!ops.OpAddAnnotation.Spec}
     */
    this.spec = function () {
        return {
            optype: "AddAnnotation",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length,
            name: name
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:(!number|undefined),
    name:string
}}*/
ops.OpAddAnnotation.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:(!number|undefined),
    name:string
}}*/
ops.OpAddAnnotation.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpAddCursor.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpAddCursor = function OpAddCursor() {
    "use strict";

    var memberid, timestamp;

    /**
     * @param {!ops.OpAddCursor.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
    };

    this.isEdit = false;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            cursor = odtDocument.getCursor(memberid);

        // there should be none
        if (cursor) {
            return false;
        }

        cursor = new ops.OdtCursor(memberid, odtDocument);
        odtDocument.addCursor(cursor);
        odtDocument.emit(ops.Document.signalCursorAdded, cursor);
        return true;
    };

    /**
     * @return {!ops.OpAddCursor.Spec}
     */
    this.spec = function () {
        return {
            optype: "AddCursor",
            memberid: memberid,
            timestamp: timestamp
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number
}}*/
ops.OpAddCursor.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined)
}}*/
ops.OpAddCursor.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpAddMember.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime*/

/**
 * OpAddMember has 3 required properties:
 * fullName, color, and imageUrl. Because the
 * spec does not expose those explicitly right now,
 * internally these properties are set as
 * runtime.tr("Unknown Author"), 'black', and "avatar-joe.png"
 * respectively, if unspecified.
 * @constructor
 * @implements ops.Operation
 */
ops.OpAddMember = function OpAddMember() {
    "use strict";

    var memberid, timestamp, setProperties;
    /**
     * @param {!ops.OpAddMember.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = parseInt(data.timestamp, 10);
        setProperties = data.setProperties;
    };

    this.isEdit = false;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            member;
        if (odtDocument.getMember(memberid)) {
            return false;
        }

        member = new ops.Member(memberid, setProperties);
        odtDocument.addMember(member);
        odtDocument.emit(ops.Document.signalMemberAdded, member);

        return true;
    };

    /**
     * @return {!ops.OpAddMember.Spec}
     */
    this.spec = function () {
        return {
            optype: "AddMember",
            memberid: memberid,
            timestamp: timestamp,
            setProperties: setProperties
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    setProperties:!ops.MemberProperties
}}*/
ops.OpAddMember.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    setProperties:!ops.MemberProperties
}}*/
ops.OpAddMember.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpAddStyle.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf, ops*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpAddStyle = function OpAddStyle() {
    "use strict";

    var memberid, timestamp,
        styleName, styleFamily, isAutomaticStyle,
        /**@type{!odf.Formatting.StyleData}*/setProperties,
        /** @const */stylens = odf.Namespaces.stylens;

    /**
     * @param {!ops.OpAddStyle.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        styleName = data.styleName;
        styleFamily = data.styleFamily;
        // Input is either from an xml doc or potentially a manually created op
        // This means isAutomaticStyles is either a raw string of 'true', or a a native bool
        // Can't use Boolean(...) as Boolean('false') === true
        isAutomaticStyle = data.isAutomaticStyle === 'true' || data.isAutomaticStyle === true;
        setProperties = data.setProperties;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            odfContainer = odtDocument.getOdfCanvas().odfContainer(),
            formatting = odtDocument.getFormatting(),
            dom = odtDocument.getDOMDocument(),
            styleNode = dom.createElementNS(stylens, 'style:style');

        if (!styleNode) {
            return false;
        }

        if (setProperties) {
            formatting.updateStyle(styleNode, setProperties);
        }

        styleNode.setAttributeNS(stylens, 'style:family', styleFamily);
        styleNode.setAttributeNS(stylens, 'style:name', styleName);

        if (isAutomaticStyle) {
            odfContainer.rootElement.automaticStyles.appendChild(styleNode);
        } else {
            odfContainer.rootElement.styles.appendChild(styleNode);
        }

        odtDocument.getOdfCanvas().refreshCSS();
        if (!isAutomaticStyle) {
            odtDocument.emit(ops.OdtDocument.signalCommonStyleCreated, {name: styleName, family: styleFamily});
        }
        return true;
    };

    /**
     * @return {!ops.OpAddStyle.Spec}
     */
    this.spec = function () {
        return {
            optype: "AddStyle",
            memberid: memberid,
            timestamp: timestamp,
            styleName: styleName,
            styleFamily: styleFamily,
            isAutomaticStyle: isAutomaticStyle,
            setProperties: setProperties
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    styleName:string,
    styleFamily:string,
    isAutomaticStyle:boolean,
    setProperties:odf.Formatting.StyleData
}}*/
ops.OpAddStyle.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    styleName:string,
    styleFamily:string,
    isAutomaticStyle:(boolean|string),
    setProperties:odf.Formatting.StyleData
}}*/
ops.OpAddStyle.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpApplyDirectStyling.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime, gui, odf, Node, core*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpApplyDirectStyling = function OpApplyDirectStyling() {
    "use strict";

    var memberid, timestamp,
        /**@type {number}*/
        position,
        /**@type {number}*/
        length,
        /**@type{!odf.Formatting.StyleData}*/
        setProperties,
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils;

    /**
     * @param {!ops.OpApplyDirectStyling.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = parseInt(data.position, 10);
        length = parseInt(data.length, 10);
        setProperties = data.setProperties;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * Apply the specified style properties to all elements within the given range.
     * Currently, only text styles are applied.
     * @param {!ops.OdtDocument} odtDocument
     * @param {!Range} range Range to apply text style to
     * @param {!Object} info Style information. Only data within "style:text-properties" will be considered and applied
     */
    function applyStyle(odtDocument, range, info) {
        var odfCanvas = odtDocument.getOdfCanvas(),
            odfContainer = odfCanvas.odfContainer(),
            nextTextNodes = domUtils.splitBoundaries(range),
            textNodes = odfUtils.getTextNodes(range, false),
            textStyles;

        textStyles = new odf.TextStyleApplicator(
            new odf.ObjectNameGenerator(/**@type{!odf.OdfContainer}*/(odfContainer), memberid), // TODO: use the instance in SessionController
            odtDocument.getFormatting(),
            odfContainer.rootElement.automaticStyles
        );
        textStyles.applyStyle(textNodes, range, info);
        nextTextNodes.forEach(domUtils.normalizeTextNodes);
    }

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            range = odtDocument.convertCursorToDomRange(position, length),
            impactedParagraphs = odfUtils.getParagraphElements(range);

        applyStyle(odtDocument, range, setProperties);

        range.detach();
        odtDocument.getOdfCanvas().refreshCSS();
        odtDocument.fixCursorPositions(); // The container splits may leave the cursor in an invalid spot

        impactedParagraphs.forEach(function (n) {
            odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
                paragraphElement: n,
                memberId: memberid,
                timeStamp: timestamp
            });
        });

        odtDocument.getOdfCanvas().rerenderAnnotations();
        return true;
    };

    /**
     * @return {!ops.OpApplyDirectStyling.Spec}
     */
    this.spec = function () {
        return {
            optype: "ApplyDirectStyling",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length,
            setProperties: setProperties
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number,
    setProperties:!odf.Formatting.StyleData
}}*/
ops.OpApplyDirectStyling.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number,
    setProperties:!odf.Formatting.StyleData
}}*/
ops.OpApplyDirectStyling.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpApplyHyperlink.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, odf, core, runtime, Node */

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpApplyHyperlink = function OpApplyHyperlink() {
    "use strict";

    var memberid, timestamp, position, length, hyperlink,
        domUtils = core.DomUtils,
        odfUtils = odf.OdfUtils;

    /**
     * @param {!ops.OpApplyHyperlink.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        length = data.length;
        hyperlink = data.hyperlink;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!Document} document
     * @param {string} hyperlink
     * @return {!Element}
     */
    function createHyperlink(document, hyperlink) {
        var node = document.createElementNS(odf.Namespaces.textns, 'text:a');
        node.setAttributeNS(odf.Namespaces.xlinkns, 'xlink:type', 'simple');
        node.setAttributeNS(odf.Namespaces.xlinkns, 'xlink:href', hyperlink);
        return node;
    }

    /**
     * @param {?Node} node
     * @return {boolean}
     */
    function isPartOfLink(node) {
        while (node) {
            if (odfUtils.isHyperlink(node)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }

    /**
     * TODO: support adding image link
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            ownerDocument = odtDocument.getDOMDocument(),
            range = odtDocument.convertCursorToDomRange(position, length),
            boundaryNodes = domUtils.splitBoundaries(range),
            /**@type{!Array.<!Element>}*/
            modifiedParagraphs = [],
            textNodes = odfUtils.getTextNodes(range, false);

        if (textNodes.length === 0) {
            return false;
        }

        textNodes.forEach(function (node) {
            var linkNode,
                paragraph = odfUtils.getParagraphElement(node);
            runtime.assert(isPartOfLink(node) === false, "The given range should not contain any link.");
            // TODO there could be a small efficiency gain by merging adjacent text nodes into a single hyperlink parent.
            // This is probably only a corner case however and there are not likely to be major repercussions for not doing it
            linkNode = createHyperlink(ownerDocument, hyperlink);
            node.parentNode.insertBefore(linkNode, node);
            linkNode.appendChild(node);
            if (modifiedParagraphs.indexOf(paragraph) === -1) {
                modifiedParagraphs.push(paragraph);
            }
        });


        boundaryNodes.forEach(domUtils.normalizeTextNodes);
        range.detach();

        odtDocument.fixCursorPositions();
        odtDocument.getOdfCanvas().refreshSize();
        odtDocument.getOdfCanvas().rerenderAnnotations();
        modifiedParagraphs.forEach(function (paragraph) {
            odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
                paragraphElement: paragraph,
                memberId: memberid,
                timeStamp: timestamp
            });
        });

        return true;
    };

    /**
     * @return {!ops.OpApplyHyperlink.Spec}
     */
    this.spec = function () {
        return {
            optype: "ApplyHyperlink",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length,
            hyperlink: hyperlink
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number,
    hyperlink:string
}}*/
ops.OpApplyHyperlink.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number,
    hyperlink:string
}}*/
ops.OpApplyHyperlink.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\Operation.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops*/
/*jslint emptyblock: true, unparam: true*/

/**
 * An operation that can be performed on a document.
 * @interface
 */
ops.Operation = function Operation() {
    "use strict";
};

/**
 * @param {?} data
 * @return {undefined}
 */
ops.Operation.prototype.init = function (data) {"use strict"; };

/**
 * This is meant to indicate whether
 * the operation is an 'edit', i.e.
 * causes any changes that would make
 * it into the saved ODF.
 * @type {!boolean}
 */
ops.Operation.prototype.isEdit;

/**
 * @type {string}
 */
ops.Operation.prototype.group;

/**
 * @param {!ops.Document} document
 * @return {!boolean} true if the operation was executed
 */
ops.Operation.prototype.execute = function (document) {"use strict"; };

/**
 * @return {!{optype:string,memberid:string,timestamp:number}}
 */
ops.Operation.prototype.spec = function () {"use strict"; };

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OperationFactory.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, ops */

/*
 * create specific operation instances.
 */


/**
 * @constructor
 */
ops.OperationFactory = function OperationFactory() {
    "use strict";
    var /**@type{!Object.<!string, !ops.OperationFactory.SpecConstructor>}*/
        specs;

    /**
     * @param {!function(new:ops.Operation)} Constructor
     * @return {!ops.OperationFactory.SpecConstructor}
     */
    /*jslint unparam:true*/
    function construct(Constructor) {
        return function(spec) {
            return new Constructor();
        };
    }
    /*jslint unparam:false*/

    /**
     * Registers an operation constructor with this operation factory
     * @param {!string} specName
     * @param {!ops.OperationFactory.SpecConstructor} specConstructor
     * @return {undefined}
     */
    this.register = function (specName, specConstructor) {
        specs[specName] = specConstructor;
    };

    /**
     * Create an instance of an operation based on the provided spec
     * @param {!{optype:string}} spec
     * @return {ops.Operation}
     */
    this.create = function (spec) {
        var /**@type{ops.Operation}*/
            op = null,
            constructor = specs[spec.optype];
        if (constructor) {
            op = constructor(spec);
            op.init(spec);
        }
        return op;
    };

    function init() {
        specs = {
            AddMember: construct(ops.OpAddMember),
            UpdateMember: construct(ops.OpUpdateMember),
            RemoveMember: construct(ops.OpRemoveMember),
            AddCursor: construct(ops.OpAddCursor),
            ApplyDirectStyling: construct(ops.OpApplyDirectStyling),
            SetBlob: construct(ops.OpSetBlob),
            RemoveBlob: construct(ops.OpRemoveBlob),
            InsertImage: construct(ops.OpInsertImage),
            InsertTable: construct(ops.OpInsertTable),
            InsertText: construct(ops.OpInsertText),
            RemoveText: construct(ops.OpRemoveText),
            MergeParagraph: construct(ops.OpMergeParagraph),
            SplitParagraph: construct(ops.OpSplitParagraph),
            SetParagraphStyle: construct(ops.OpSetParagraphStyle),
            UpdateParagraphStyle: construct(ops.OpUpdateParagraphStyle),
            AddStyle: construct(ops.OpAddStyle),
            RemoveStyle: construct(ops.OpRemoveStyle),
            MoveCursor: construct(ops.OpMoveCursor),
            RemoveCursor: construct(ops.OpRemoveCursor),
            AddAnnotation: construct(ops.OpAddAnnotation),
            RemoveAnnotation: construct(ops.OpRemoveAnnotation),
            UpdateMetadata: construct(ops.OpUpdateMetadata),
            ApplyHyperlink: construct(ops.OpApplyHyperlink),
            RemoveHyperlink: construct(ops.OpRemoveHyperlink)
        };
    }

    init();
};


/**
 * @typedef {!function(!{optype:!string}):!ops.Operation}
 */
ops.OperationFactory.SpecConstructor;
========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OperationRouter.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops*/
/*jslint emptyblock: true, unparam: true*/

/**
 * @interface
 */
ops.OperationRouter = function OperationRouter() {"use strict"; };

/**
 * Sets the factory to use to create operation instances from operation specs.
 *
 * @param {!ops.OperationFactory} f
 * @return {undefined}
 */
ops.OperationRouter.prototype.setOperationFactory = function (f) {"use strict"; };

/**
 * Sets the method which should be called to apply operations.
 *
 * @param {!function(!ops.Operation):boolean} playback_func
 * @return {undefined}
 */
ops.OperationRouter.prototype.setPlaybackFunction = function (playback_func) {"use strict"; };

/**
 * Brings the locally created operations into the game.
 * The ops are guaranteed to be executed directly after each other, in the given order
 * (first will be executed first).
 * TODO: currently all known implementations only use the specs of the operations,
 * so it might make sense to not create any operations outside of the operation router at all
 * and instead just create specs and pass them to this push method?
 *
 * @param {!Array.<!ops.Operation>} operations
 * @return {undefined}
 */
ops.OperationRouter.prototype.push = function (operations) {"use strict"; };

/**
 * Requests a gracefull shutdown of the Operation Router.
 * Buffered operations shall be sent to the master session (if any).
 * A callback is called, getting passed an error object in case of error.
 *
 * @param {!function(!Object=)} callback
 * @return {undefined}
 */
ops.OperationRouter.prototype.close = function (callback) {"use strict"; };

/**
 * The passed cb will be called on every event of type eventId.
 *
 * @param {!string} eventId
 * @param {!Function} cb
 * @return {undefined}
 */
ops.OperationRouter.prototype.subscribe = function (eventId, cb) {"use strict"; };

/**
 * Undoes the subscription done with subscribe(...).
 *
 * @param {!string} eventId
 * @param {!Function} cb
 * @return {undefined}
 */
ops.OperationRouter.prototype.unsubscribe = function (eventId, cb) {"use strict"; };

/**
 * Returns if there are operations done locally that have not yet been
 * synchronized with the host of the session.
 *
 * @return {!boolean}
 */
ops.OperationRouter.prototype.hasLocalUnsyncedOps = function () {"use strict"; };

/**
 * Returns if the connection to the host of the session is currently existing.
 *
 * @return {!boolean}
 */
ops.OperationRouter.prototype.hasSessionHostConnection = function () {"use strict"; };

/**
 * Signal that the operation router is about to process a batch of operations.
 * @const
 * @type {string}
 */
ops.OperationRouter.signalProcessingBatchStart = "router/batchstart";

/**
 * Signal that the operation router has just completed processing a batch of operations.
 * @const
 * @type {string}
 */
ops.OperationRouter.signalProcessingBatchEnd = "router/batchend";

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OperationTransformer.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, ops */

/*
 * create specific operation instances.
 */


/**
 * @constructor
 */
ops.OperationTransformer = function OperationTransformer() {
    "use strict";

    var operationTransformMatrix = new ops.OperationTransformMatrix();

    /**
     * @param {!{optype:string}} opSpecA op with lower priority in case of tie breaking
     * @param {!{optype:string}} opSpecB op with higher priority in case of tie breaking
     * @return {?{opSpecsA:!Array.<!{optype:string}>,
     *            opSpecsB:!Array.<!{optype:string}>}}
     */
    function transformOpVsOp(opSpecA, opSpecB) {
        return operationTransformMatrix.transformOpspecVsOpspec(opSpecA, opSpecB);
    }

    /**
     * @param {!Array.<!{optype:string}>} opSpecsA   sequence of ops with lower priority in case of tie breaking
     * @param {?{optype:string}} opSpecB   op with higher priority in case of tie breaking
     * @return {?{opSpecsA:!Array.<!{optype:string}>,
     *            opSpecsB:!Array.<!Object>}}
     */
    function transformOpListVsOp(opSpecsA, opSpecB) {
        var transformResult, transformListResult,
            transformedOpspecsA = [],
            transformedOpspecsB = [];

        while (opSpecsA.length > 0 && opSpecB) {
            transformResult = transformOpVsOp(opSpecsA.shift(), opSpecB);
            // unresolvable operation conflicts?
            if (!transformResult) {
                return null;
            }

            // take transformed ops of the list A
            transformedOpspecsA = transformedOpspecsA.concat(transformResult.opSpecsA);

            // handle transformed ops of the single op B
            // opB became a noop?
            if (transformResult.opSpecsB.length === 0) {
                // so rest of opsAs stay unchanged, nothing else to do
                transformedOpspecsA = transformedOpspecsA.concat(opSpecsA);
                opSpecB = null;
                break;
            }
            // in case of opspecB transformed into multiple ops,
            // transform the remaining opsAs against any additional opsBs
            // so we can continue as if there is only one opB
            while (transformResult.opSpecsB.length > 1) {
                transformListResult = transformOpListVsOp(opSpecsA, transformResult.opSpecsB.shift());
                // unresolvable operation conflicts?
                if (!transformListResult) {
                    return null;
                }
                // take transformed ops of the single b
                transformedOpspecsB = transformedOpspecsB.concat(transformListResult.opSpecsB);
                opSpecsA = transformListResult.opSpecsA;
            }
            // continue with last of transformed opsB
            opSpecB = transformResult.opSpecsB.pop();
        }

        if (opSpecB) {
            transformedOpspecsB.push(opSpecB);
        }
        return {
            opSpecsA:  transformedOpspecsA,
            opSpecsB:  transformedOpspecsB
        };
    }

    /**
     * @return {!ops.OperationTransformMatrix}
     */
    this.getOperationTransformMatrix = function () {
        return operationTransformMatrix;
    };

    /**
     * Currently the priority of ops for tie breaking is defined by how they
     * are passed to this method. Which usually reflects the origin of the ops,
     * being created locally or coming from the master session.
     * E. g. the pullbox backend gives this way higher priority to the ops from
     * the master session.
     * That is just a randomly chosen rule, because there are no cases known
     * yet where priority needs to be derived from something non-random.
     * @param {!Array.<!Object>} opSpecsA   sequence of opspecs with lower priority in case of tie breaking
     * @param {!Array.<!{optype:string}>} opSpecsB   opspecs with higher priority in case of tie breaking
     * @return {?{opSpecsA:!Array.<!Object>,
     *            opSpecsB:!Array.<!Object>}}
     */
    this.transform = function (opSpecsA, opSpecsB) {
        var transformResult,
            transformedOpspecsB = [];

        // transform all opSpecsB vs. all unsent client ops
        while (opSpecsB.length > 0) {
            transformResult = transformOpListVsOp(opSpecsA, opSpecsB.shift());
            // unresolvable operation conflicts?
            if (!transformResult) {
                return null;
            }

            opSpecsA = transformResult.opSpecsA;
            transformedOpspecsB = transformedOpspecsB.concat(transformResult.opSpecsB);
        }

        return {
            opSpecsA: /**@type{!Array.<!Object>}*/(opSpecsA),
            opSpecsB: /**@type{!Array.<!Object>}*/(transformedOpspecsB)
        };
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OperationTransformMatrix.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, ops */

/**
 * @constructor
 */
ops.OperationTransformMatrix = function OperationTransformMatrix() {
    "use strict";

    /* Utility methods */

    /**
     * Inverts the range spanned up by the spec's parameter position and length,
     * so that position is at the other end of the range and length relative to that.
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @return {undefined}
     */
    function invertMoveCursorSpecRange(moveCursorSpec) {
        moveCursorSpec.position = moveCursorSpec.position + moveCursorSpec.length;
        moveCursorSpec.length *= -1;
    }

    /**
     * Inverts the range spanned up by position and length if the length is negative.
     * Returns true if an inversion was done, false otherwise.
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @return {!boolean}
     */
    function invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec) {
        var isBackwards = (moveCursorSpec.length < 0);

        if (isBackwards) {
            invertMoveCursorSpecRange(moveCursorSpec);
        }
        return isBackwards;
    }

    /**
     * Returns a list with all attributes in setProperties that refer to styleName
     * @param {?odf.Formatting.StyleData} setProperties
     * @param {!string} styleName
     * @return {!Array.<!string>}
     */
    function getStyleReferencingAttributes(setProperties, styleName) {
        var attributes = [];
        /**
         * @param {string} attributeName
         */
        function check(attributeName) {
            if (setProperties[attributeName] === styleName) {
                attributes.push(attributeName);
            }
        }
        if (setProperties) {
            ['style:parent-style-name', 'style:next-style-name'].forEach(check);
        }
        return attributes;
    }
    /**
     * @param {?odf.Formatting.StyleData} setProperties
     * @param {!string} deletedStyleName
     * @return {undefined}
     */
    function dropStyleReferencingAttributes(setProperties, deletedStyleName) {
        /**
         * @param {string} attributeName
         */
        function del(attributeName) {
            if (setProperties[attributeName] === deletedStyleName) {
                delete setProperties[attributeName];
            }
        }
        if (setProperties) {
            ['style:parent-style-name', 'style:next-style-name'].forEach(del);
        }
    }

    /**
     * Creates a deep copy of the opspec
     * @param {!Object} opspec
     * @return {!Object}
     */
    function cloneOpspec(opspec) {
        var result = {};

        Object.keys(opspec).forEach(function (key) {
            if (typeof opspec[key] === 'object') {
                result[key] = cloneOpspec(opspec[key]);
            } else {
                result[key] = opspec[key];
            }
        });

        return result;
    }

    /**
     * @param {?Object.<string,*>} minorSetProperties
     * @param {?{attributes:string}} minorRemovedProperties
     * @param {?Object.<string,*>} majorSetProperties
     * @param {?{attributes:string}} majorRemovedProperties
     * @return {!{majorChanged:boolean,minorChanged:boolean}}
     */
    function dropOverruledAndUnneededAttributes(minorSetProperties, minorRemovedProperties, majorSetProperties, majorRemovedProperties) {
        var i, name,
            majorChanged = false, minorChanged = false,
            removedPropertyNames,
            /**@type{!Array.<string>}*/
            majorRemovedPropertyNames = [];
        if (majorRemovedProperties && majorRemovedProperties.attributes) {
            majorRemovedPropertyNames = majorRemovedProperties.attributes.split(',');
        }

        // iterate over all properties and see which get overwritten or deleted
        // by the overruling, so they have to be dropped
        if (minorSetProperties && (majorSetProperties || majorRemovedPropertyNames.length > 0)) {
            Object.keys(minorSetProperties).forEach(function (key) {
                var value = minorSetProperties[key],
                    overrulingPropertyValue;
                // TODO: support more than one level
                if (typeof value !== "object") {
                    if (majorSetProperties) {
                        overrulingPropertyValue = majorSetProperties[key];
                    }
                    if (overrulingPropertyValue !== undefined) {
                        // drop overruled
                        delete minorSetProperties[key];
                        minorChanged = true;

                        // major sets to same value?
                        if (overrulingPropertyValue === value) {
                            // drop major as well
                            delete majorSetProperties[key];
                            majorChanged = true;
                        }
                    } else if (majorRemovedPropertyNames.indexOf(key) !== -1) {
                        // drop overruled
                        delete minorSetProperties[key];
                        minorChanged = true;
                    }
                }
            });
        }

        // iterate over all overruling removed properties and drop any duplicates from
        // the removed property names
        if (minorRemovedProperties && minorRemovedProperties.attributes && (majorSetProperties || majorRemovedPropertyNames.length > 0)) {
            removedPropertyNames = minorRemovedProperties.attributes.split(',');
            for (i = 0; i < removedPropertyNames.length; i += 1) {
                name = removedPropertyNames[i];
                if ((majorSetProperties && majorSetProperties[name] !== undefined) ||
                        (majorRemovedPropertyNames && majorRemovedPropertyNames.indexOf(name) !== -1)) {
                    // drop
                    removedPropertyNames.splice(i, 1);
                    i -= 1;
                    minorChanged = true;
                }
            }
            // set back
            if (removedPropertyNames.length > 0) {
                minorRemovedProperties.attributes = removedPropertyNames.join(',');
            } else {
                delete minorRemovedProperties.attributes;
            }
        }

        return {
            majorChanged: majorChanged,
            minorChanged: minorChanged
        };
    }

    /**
     * Estimates if there are any properties set in the given properties object.
     * @param {!odf.Formatting.StyleData} properties
     * @return {!boolean}
     */
    function hasProperties(properties) {
        var /**@type{string}*/
            key;

        for (key in properties) {
            if (properties.hasOwnProperty(key)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Estimates if there are any properties set in the given properties object.
     * @param {!{attributes:string}} properties
     * @return {!boolean}
     */
    function hasRemovedProperties(properties) {
        var /**@type{string}*/
            key;

        for (key in properties) {
            if (properties.hasOwnProperty(key)) {
                // handle empty 'attribute' as not existing
                if (key !== 'attributes' || properties.attributes.length > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * @param {?odf.Formatting.StyleData} minorSet
     * @param {?Object.<string,{attributes:string}>} minorRem
     * @param {?odf.Formatting.StyleData} majorSet
     * @param {?Object.<string,{attributes:string}>} majorRem
     * @param {!string} propertiesName
     * @return {?{majorChanged:boolean,minorChanged:boolean}}
     */
    function dropOverruledAndUnneededProperties(minorSet, minorRem, majorSet, majorRem, propertiesName) {
        var minorSP = /**@type{?odf.Formatting.StyleData}*/(minorSet ? minorSet[propertiesName] : null),
            minorRP = minorRem ? minorRem[propertiesName] : null,
            majorSP = /**@type{?odf.Formatting.StyleData}*/(majorSet ? majorSet[propertiesName] : null),
            majorRP = majorRem ? majorRem[propertiesName] : null,
            result;

        // TODO: also care for nested properties, like there can be e.g. with text:paragraph-properties
        result = dropOverruledAndUnneededAttributes(minorSP, minorRP, majorSP, majorRP);

        // remove empty setProperties
        if (minorSP && !hasProperties(minorSP)) {
            delete minorSet[propertiesName];
        }
        // remove empty removedProperties
        if (minorRP && !hasRemovedProperties(minorRP)) {
            delete minorRem[propertiesName];
        }

        // remove empty setProperties
        if (majorSP && !hasProperties(majorSP)) {
            delete majorSet[propertiesName];
        }
        // remove empty removedProperties
        if (majorRP && !hasRemovedProperties(majorRP)) {
            delete majorRem[propertiesName];
        }

        return result;
    }



    /* Transformation methods */

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpecA
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationAddAnnotation(addAnnotationSpecA, addAnnotationSpecB, hasAPriority) {
        var firstAnnotationSpec, secondAnnotationSpec;

        if (addAnnotationSpecA.position < addAnnotationSpecB.position) {
            firstAnnotationSpec = addAnnotationSpecA;
            secondAnnotationSpec = addAnnotationSpecB;
        } else if (addAnnotationSpecB.position < addAnnotationSpecA.position) {
            firstAnnotationSpec = addAnnotationSpecB;
            secondAnnotationSpec = addAnnotationSpecA;
        } else {
            firstAnnotationSpec = hasAPriority ? addAnnotationSpecA : addAnnotationSpecB;
            secondAnnotationSpec = hasAPriority ? addAnnotationSpecB : addAnnotationSpecA;
        }

        if (secondAnnotationSpec.position < firstAnnotationSpec.position + firstAnnotationSpec.length) {
            firstAnnotationSpec.length += 2;
        }
        secondAnnotationSpec.position += 2;

        return {
            opSpecsA:  [addAnnotationSpecA],
            opSpecsB:  [addAnnotationSpecB]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationApplyDirectStyling(addAnnotationSpec, applyDirectStylingSpec) {
        if (addAnnotationSpec.position <= applyDirectStylingSpec.position) {
            applyDirectStylingSpec.position += 2;
        } else if (addAnnotationSpec.position <= applyDirectStylingSpec.position + applyDirectStylingSpec.length) {
            applyDirectStylingSpec.length += 2;
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [applyDirectStylingSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationInsertText(addAnnotationSpec, insertTextSpec) {
        if (insertTextSpec.position <= addAnnotationSpec.position) {
            addAnnotationSpec.position += insertTextSpec.text.length;
        } else {
            if (addAnnotationSpec.length !== undefined) {
                if (insertTextSpec.position <= addAnnotationSpec.position + addAnnotationSpec.length) {
                    addAnnotationSpec.length += insertTextSpec.text.length;
                }
            }
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            insertTextSpec.position += 2;
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [insertTextSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationMergeParagraph(addAnnotationSpec, mergeParagraphSpec) {
        if (mergeParagraphSpec.sourceStartPosition <= addAnnotationSpec.position) {
            addAnnotationSpec.position -= 1;
        } else {
            if (addAnnotationSpec.length !== undefined) {
                if (mergeParagraphSpec.sourceStartPosition <= addAnnotationSpec.position + addAnnotationSpec.length) {
                    addAnnotationSpec.length -= 1;
                }
            }

            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            mergeParagraphSpec.sourceStartPosition += 2;

            if (addAnnotationSpec.position < mergeParagraphSpec.destinationStartPosition) {
                mergeParagraphSpec.destinationStartPosition += 2;
            }
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [mergeParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationMoveCursor(addAnnotationSpec, moveCursorSpec) {
        var isMoveCursorSpecRangeInverted = invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec);

        // adapt movecursor spec to inserted positions
        if (addAnnotationSpec.position < moveCursorSpec.position) {
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            moveCursorSpec.position += 2;
        } else if (addAnnotationSpec.position < moveCursorSpec.position + moveCursorSpec.length) {
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            moveCursorSpec.length += 2;
        }

        if (isMoveCursorSpecRangeInverted) {
            invertMoveCursorSpecRange(moveCursorSpec);
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [moveCursorSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationRemoveAnnotation(addAnnotationSpec, removeAnnotationSpec) {
        // adapt movecursor spec to inserted positions
        if (addAnnotationSpec.position < removeAnnotationSpec.position) {
            if (removeAnnotationSpec.position < addAnnotationSpec.position + addAnnotationSpec.length) {
                addAnnotationSpec.length -= removeAnnotationSpec.length + 2;
            }
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            removeAnnotationSpec.position += 2;
        } else {
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            addAnnotationSpec.position -= removeAnnotationSpec.length + 2;
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [removeAnnotationSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationRemoveText(addAnnotationSpec, removeTextSpec) {
        var removeTextSpecPosition = removeTextSpec.position,
            removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length,
            annotationSpecEnd,
            helperOpspec,
            addAnnotationSpecResult = [addAnnotationSpec],
            removeTextSpecResult = [removeTextSpec];

        // adapt removeTextSpec
        if (addAnnotationSpec.position <= removeTextSpec.position) {
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            removeTextSpec.position += 2;
        } else if (addAnnotationSpec.position < removeTextSpecEnd) {
            // we have to split the removal into two ops, before and after the annotation start
            removeTextSpec.length = addAnnotationSpec.position - removeTextSpec.position;
            helperOpspec = {
                optype: "RemoveText",
                memberid: removeTextSpec.memberid,
                timestamp: removeTextSpec.timestamp,
                position: addAnnotationSpec.position + 2,
                length: removeTextSpecEnd - addAnnotationSpec.position
            };
            removeTextSpecResult.unshift(helperOpspec); // helperOp first, so its position is not affected by the real op
        }

        // adapt addAnnotationSpec (using already changed removeTextSpec and new helperOpspec, be aware)
        if (removeTextSpec.position + removeTextSpec.length <= addAnnotationSpec.position) {
            addAnnotationSpec.position -= removeTextSpec.length;
            if ((addAnnotationSpec.length !== undefined) && helperOpspec) {
                if (helperOpspec.length >= addAnnotationSpec.length) {
                    addAnnotationSpec.length = 0;
                } else {
                    addAnnotationSpec.length -= helperOpspec.length;
                }
            }
        } else if (addAnnotationSpec.length !== undefined) {
            annotationSpecEnd = addAnnotationSpec.position + addAnnotationSpec.length;
            if (removeTextSpecEnd <= annotationSpecEnd) {
                addAnnotationSpec.length -= removeTextSpec.length;
            } else if (removeTextSpecPosition < annotationSpecEnd) {
                addAnnotationSpec.length = removeTextSpecPosition - addAnnotationSpec.position;
            }
        }

        return {
            opSpecsA:  addAnnotationSpecResult,
            opSpecsB:  removeTextSpecResult
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationSetParagraphStyle(addAnnotationSpec, setParagraphStyleSpec) {
        if (addAnnotationSpec.position < setParagraphStyleSpec.position) {
            setParagraphStyleSpec.position += 2;
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [setParagraphStyleSpec]
        };
    }

    /**
     * @param {!ops.OpAddAnnotation.Spec} addAnnotationSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddAnnotationSplitParagraph(addAnnotationSpec, splitParagraphSpec) {
        if (addAnnotationSpec.position < splitParagraphSpec.sourceParagraphPosition) {
            splitParagraphSpec.sourceParagraphPosition += 2;
        }

        if (splitParagraphSpec.position <= addAnnotationSpec.position) {
            addAnnotationSpec.position += 1;
        } else {
            if (addAnnotationSpec.length !== undefined) {
                if (splitParagraphSpec.position <= addAnnotationSpec.position + addAnnotationSpec.length) {
                    addAnnotationSpec.length += 1;
                }
            }
            // 2, because 1 for pos inside annotation comment, 1 for new pos before annotated range
            splitParagraphSpec.position += 2;
        }

        return {
            opSpecsA:  [addAnnotationSpec],
            opSpecsB:  [splitParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpAddStyle.Spec} addStyleSpec
     * @param {!ops.OpRemoveStyle.Spec} removeStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformAddStyleRemoveStyle(addStyleSpec, removeStyleSpec) {
        var setAttributes,
            helperOpspec,
            addStyleSpecResult = [addStyleSpec],
            removeStyleSpecResult = [removeStyleSpec];

        if (addStyleSpec.styleFamily === removeStyleSpec.styleFamily) {
            // deleted style brought into use by addstyle op?
            setAttributes = getStyleReferencingAttributes(addStyleSpec.setProperties, removeStyleSpec.styleName);
            if (setAttributes.length > 0) {
                // just create a updateparagraph style op preceding to us which removes any set style from the paragraph
                helperOpspec = {
                    optype: "UpdateParagraphStyle",
                    memberid: removeStyleSpec.memberid,
                    timestamp: removeStyleSpec.timestamp,
                    styleName: addStyleSpec.styleName,
                    removedProperties: { attributes: setAttributes.join(',') }
                };
                removeStyleSpecResult.unshift(helperOpspec);
            }
            // in the addstyle op drop any attributes referencing the style deleted
            dropStyleReferencingAttributes(addStyleSpec.setProperties, removeStyleSpec.styleName);
        }

        return {
            opSpecsA:  addStyleSpecResult,
            opSpecsB:  removeStyleSpecResult
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpecA
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingApplyDirectStyling(applyDirectStylingSpecA, applyDirectStylingSpecB, hasAPriority) {
        var majorSpec, minorSpec, majorSpecResult, minorSpecResult,
            majorSpecEnd, minorSpecEnd, dropResult,
            originalMajorSpec, originalMinorSpec,
            helperOpspecBefore, helperOpspecAfter,
            applyDirectStylingSpecAResult = [applyDirectStylingSpecA],
            applyDirectStylingSpecBResult = [applyDirectStylingSpecB];

        // overlapping and any conflicting attributes?
        if (!(applyDirectStylingSpecA.position + applyDirectStylingSpecA.length <= applyDirectStylingSpecB.position ||
              applyDirectStylingSpecA.position >= applyDirectStylingSpecB.position + applyDirectStylingSpecB.length)) {
            // adapt to priority
            majorSpec = hasAPriority ? applyDirectStylingSpecA : applyDirectStylingSpecB;
            minorSpec = hasAPriority ? applyDirectStylingSpecB : applyDirectStylingSpecA;

            // might need original opspecs?
            if (applyDirectStylingSpecA.position !== applyDirectStylingSpecB.position ||
                    applyDirectStylingSpecA.length !== applyDirectStylingSpecB.length) {
                originalMajorSpec = cloneOpspec(majorSpec);
                originalMinorSpec = cloneOpspec(minorSpec);
            }

            // for the part that is overlapping reduce setProperties by the overruled properties
            dropResult = dropOverruledAndUnneededProperties(
                minorSpec.setProperties,
                null,
                majorSpec.setProperties,
                null,
                'style:text-properties'
            );

            if (dropResult.majorChanged || dropResult.minorChanged) {
                // split the less-priority op into several ops for the overlapping and non-overlapping ranges
                majorSpecResult = [];
                minorSpecResult = [];

                majorSpecEnd = majorSpec.position + majorSpec.length;
                minorSpecEnd = minorSpec.position + minorSpec.length;

                // find if there is a part before and if there is a part behind,
                // create range-adapted copies of the original opspec, if the spec has changed
                if (minorSpec.position < majorSpec.position) {
                    if (dropResult.minorChanged) {
                        helperOpspecBefore = cloneOpspec(/**@type{!Object}*/(originalMinorSpec));
                        helperOpspecBefore.length = majorSpec.position - minorSpec.position;
                        minorSpecResult.push(helperOpspecBefore);

                        minorSpec.position = majorSpec.position;
                        minorSpec.length = minorSpecEnd - minorSpec.position;
                    }
                } else if (majorSpec.position < minorSpec.position) {
                    if (dropResult.majorChanged) {
                        helperOpspecBefore = cloneOpspec(/**@type{!Object}*/(originalMajorSpec));
                        helperOpspecBefore.length = minorSpec.position - majorSpec.position;
                        majorSpecResult.push(helperOpspecBefore);

                        majorSpec.position = minorSpec.position;
                        majorSpec.length = majorSpecEnd - majorSpec.position;
                    }
                }
                if (minorSpecEnd > majorSpecEnd) {
                    if (dropResult.minorChanged) {
                        helperOpspecAfter = originalMinorSpec;
                        helperOpspecAfter.position = majorSpecEnd;
                        helperOpspecAfter.length = minorSpecEnd - majorSpecEnd;
                        minorSpecResult.push(helperOpspecAfter);

                        minorSpec.length = majorSpecEnd - minorSpec.position;
                    }
                } else if (majorSpecEnd > minorSpecEnd) {
                    if (dropResult.majorChanged) {
                        helperOpspecAfter = originalMajorSpec;
                        helperOpspecAfter.position = minorSpecEnd;
                        helperOpspecAfter.length = majorSpecEnd - minorSpecEnd;
                        majorSpecResult.push(helperOpspecAfter);

                        majorSpec.length = minorSpecEnd - majorSpec.position;
                    }
                }

                // check if there are any changes left and this op has not become a noop
                if (majorSpec.setProperties && hasProperties(majorSpec.setProperties)) {
                    majorSpecResult.push(majorSpec);
                }
                // check if there are any changes left and this op has not become a noop
                if (minorSpec.setProperties && hasProperties(minorSpec.setProperties)) {
                    minorSpecResult.push(minorSpec);
                }

                if (hasAPriority) {
                    applyDirectStylingSpecAResult = majorSpecResult;
                    applyDirectStylingSpecBResult = minorSpecResult;
                } else {
                    applyDirectStylingSpecAResult = minorSpecResult;
                    applyDirectStylingSpecBResult = majorSpecResult;
                }
            }
        }

        return {
            opSpecsA:  applyDirectStylingSpecAResult,
            opSpecsB:  applyDirectStylingSpecBResult
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingInsertText(applyDirectStylingSpec, insertTextSpec) {
        // adapt applyDirectStyling spec to inserted positions
        if (insertTextSpec.position <= applyDirectStylingSpec.position) {
            applyDirectStylingSpec.position += insertTextSpec.text.length;
        } else if (insertTextSpec.position <= applyDirectStylingSpec.position + applyDirectStylingSpec.length) {
            applyDirectStylingSpec.length += insertTextSpec.text.length;
        }

        return {
            opSpecsA:  [applyDirectStylingSpec],
            opSpecsB:  [insertTextSpec]
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingMergeParagraph(applyDirectStylingSpec, mergeParagraphSpec) {
        var pointA = applyDirectStylingSpec.position,
            pointB = applyDirectStylingSpec.position + applyDirectStylingSpec.length;

        // adapt applyDirectStyling spec to merged paragraph
        if (pointA >= mergeParagraphSpec.sourceStartPosition) {
            pointA -= 1;
        }
        if (pointB >= mergeParagraphSpec.sourceStartPosition) {
            pointB -= 1;
        }
        applyDirectStylingSpec.position = pointA;
        applyDirectStylingSpec.length = pointB - pointA;

        return {
            opSpecsA:  [applyDirectStylingSpec],
            opSpecsB:  [mergeParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingRemoveAnnotation(applyDirectStylingSpec, removeAnnotationSpec) {
        var pointA = applyDirectStylingSpec.position,
            pointB = applyDirectStylingSpec.position + applyDirectStylingSpec.length,
            removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            applyDirectStylingSpecResult = [applyDirectStylingSpec],
            removeAnnotationSpecResult = [removeAnnotationSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= pointA && pointB <= removeAnnotationEnd) {
            applyDirectStylingSpecResult = [];
        } else {
            // adapt applyDirectStyling spec to removed annotation content
            if (removeAnnotationEnd < pointA) {
                pointA -= removeAnnotationSpec.length + 2;
            }
            if (removeAnnotationEnd < pointB) {
                pointB -= removeAnnotationSpec.length + 2;
            }
            applyDirectStylingSpec.position = pointA;
            applyDirectStylingSpec.length = pointB - pointA;
        }

        return {
            opSpecsA:  applyDirectStylingSpecResult,
            opSpecsB:  removeAnnotationSpecResult
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingRemoveText(applyDirectStylingSpec, removeTextSpec) {
        var applyDirectStylingSpecEnd = applyDirectStylingSpec.position + applyDirectStylingSpec.length,
            removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length,
            applyDirectStylingSpecResult = [applyDirectStylingSpec],
            removeTextSpecResult = [removeTextSpec];

        // transform applyDirectStylingSpec
        // removed positions by object up to move cursor position?
        if (removeTextSpecEnd <= applyDirectStylingSpec.position) {
            // adapt by removed position
            applyDirectStylingSpec.position -= removeTextSpec.length;
        // overlapping?
        } else if (removeTextSpec.position < applyDirectStylingSpecEnd) {
            // still to select range starting at cursor position?
            if (applyDirectStylingSpec.position < removeTextSpec.position) {
                // still to select range ending at selection?
                if (removeTextSpecEnd < applyDirectStylingSpecEnd) {
                    applyDirectStylingSpec.length -= removeTextSpec.length;
                } else {
                    applyDirectStylingSpec.length = removeTextSpec.position - applyDirectStylingSpec.position;
                }
            // remove overlapping section
            } else {
                // fall at start of removed section
                applyDirectStylingSpec.position = removeTextSpec.position;
                // still to select range at selection end?
                if (removeTextSpecEnd < applyDirectStylingSpecEnd) {
                    applyDirectStylingSpec.length = applyDirectStylingSpecEnd - removeTextSpecEnd;
                } else {
                    // completely overlapped by other, so becomes no-op
                    // TODO: once we can address spans, removeTextSpec would need to get a helper op
                    // to remove the empty span left over
                    applyDirectStylingSpecResult = [];
                }
            }
        }

        return {
            opSpecsA:  applyDirectStylingSpecResult,
            opSpecsB:  removeTextSpecResult
        };
    }

    /**
     * @param {!ops.OpApplyDirectStyling.Spec} applyDirectStylingSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformApplyDirectStylingSplitParagraph(applyDirectStylingSpec, splitParagraphSpec) {
        // transform applyDirectStylingSpec
        if (splitParagraphSpec.position < applyDirectStylingSpec.position) {
            applyDirectStylingSpec.position += 1;
        } else if (splitParagraphSpec.position < applyDirectStylingSpec.position + applyDirectStylingSpec.length) {
            applyDirectStylingSpec.length += 1;
        }

        return {
            opSpecsA:  [applyDirectStylingSpec],
            opSpecsB:  [splitParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpecA
     * @param {!ops.OpInsertText.Spec} insertTextSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextInsertText(insertTextSpecA, insertTextSpecB, hasAPriority) {
        if (insertTextSpecA.position < insertTextSpecB.position) {
            insertTextSpecB.position += insertTextSpecA.text.length;
        } else if (insertTextSpecA.position > insertTextSpecB.position) {
            insertTextSpecA.position += insertTextSpecB.text.length;
        } else {
            if (hasAPriority) {
                insertTextSpecB.position += insertTextSpecA.text.length;
            } else {
                insertTextSpecA.position += insertTextSpecB.text.length;
            }
        }

        return {
            opSpecsA:  [insertTextSpecA],
            opSpecsB:  [insertTextSpecB]
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextMergeParagraph(insertTextSpec, mergeParagraphSpec) {
        if (insertTextSpec.position >= mergeParagraphSpec.sourceStartPosition) {
            insertTextSpec.position -= 1;
        } else {
            if (insertTextSpec.position < mergeParagraphSpec.sourceStartPosition) {
                mergeParagraphSpec.sourceStartPosition += insertTextSpec.text.length;
            }
            if (insertTextSpec.position < mergeParagraphSpec.destinationStartPosition) {
                mergeParagraphSpec.destinationStartPosition += insertTextSpec.text.length;
            }
        }

        return {
            opSpecsA:  [insertTextSpec],
            opSpecsB:  [mergeParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextMoveCursor(insertTextSpec, moveCursorSpec) {
        var isMoveCursorSpecRangeInverted = invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec);

        // adapt movecursor spec to inserted positions
        if (insertTextSpec.position < moveCursorSpec.position) {
            moveCursorSpec.position += insertTextSpec.text.length;
        } else if (insertTextSpec.position < moveCursorSpec.position + moveCursorSpec.length) {
            moveCursorSpec.length += insertTextSpec.text.length;
        }

        if (isMoveCursorSpecRangeInverted) {
            invertMoveCursorSpecRange(moveCursorSpec);
        }

        return {
            opSpecsA:  [insertTextSpec],
            opSpecsB:  [moveCursorSpec]
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextRemoveAnnotation(insertTextSpec, removeAnnotationSpec) {
        var insertTextSpecPosition = insertTextSpec.position,
            removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            insertTextSpecResult = [insertTextSpec],
            removeAnnotationSpecResult = [removeAnnotationSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= insertTextSpecPosition && insertTextSpecPosition <= removeAnnotationEnd) {
            insertTextSpecResult = [];
            removeAnnotationSpec.length += insertTextSpec.text.length;
        } else {
            // adapt insertText spec to removed annotation content
            if (removeAnnotationEnd < insertTextSpec.position) {
                insertTextSpec.position -= removeAnnotationSpec.length + 2;
            } else {
                removeAnnotationSpec.position += insertTextSpec.text.length;
            }
        }

        return {
            opSpecsA:  insertTextSpecResult,
            opSpecsB:  removeAnnotationSpecResult
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextRemoveText(insertTextSpec, removeTextSpec) {
        var helperOpspec,
            removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length,
            insertTextSpecResult = [insertTextSpec],
            removeTextSpecResult = [removeTextSpec];

        // update insertTextSpec
        // removed before/up to insertion point?
        if (removeTextSpecEnd <= insertTextSpec.position) {
            insertTextSpec.position -= removeTextSpec.length;
        // removed at/behind insertion point
        } else if (insertTextSpec.position <= removeTextSpec.position) {
            removeTextSpec.position += insertTextSpec.text.length;
        // insertion in middle of removed range
        } else {
            // we have to split the removal into two ops, before and after the insertion point
            removeTextSpec.length = insertTextSpec.position - removeTextSpec.position;
            helperOpspec = {
                optype: "RemoveText",
                memberid: removeTextSpec.memberid,
                timestamp: removeTextSpec.timestamp,
                position: insertTextSpec.position + insertTextSpec.text.length,
                length: removeTextSpecEnd - insertTextSpec.position
            };
            removeTextSpecResult.unshift(helperOpspec); // helperOp first, so its position is not affected by the real op
            // drop insertion point to begin of removed range
            // original insertTextSpec.position is used for removeTextSpec changes, so only change now
            insertTextSpec.position = removeTextSpec.position;
        }

        return {
            opSpecsA:  insertTextSpecResult,
            opSpecsB:  removeTextSpecResult
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextSetParagraphStyle(insertTextSpec, setParagraphStyleSpec) {
        if (setParagraphStyleSpec.position > insertTextSpec.position) {
            setParagraphStyleSpec.position += insertTextSpec.text.length;
        }

        return {
            opSpecsA:  [insertTextSpec],
            opSpecsB:  [setParagraphStyleSpec]
        };
    }

    /**
     * @param {!ops.OpInsertText.Spec} insertTextSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformInsertTextSplitParagraph(insertTextSpec, splitParagraphSpec) {
        if (insertTextSpec.position < splitParagraphSpec.sourceParagraphPosition) {
            splitParagraphSpec.sourceParagraphPosition += insertTextSpec.text.length;
        }

        if (insertTextSpec.position <= splitParagraphSpec.position) {
            splitParagraphSpec.position += insertTextSpec.text.length;
        } else {
            insertTextSpec.position += 1;
        }

        return {
            opSpecsA:  [insertTextSpec],
            opSpecsB:  [splitParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpecA
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphMergeParagraph(mergeParagraphSpecA, mergeParagraphSpecB, hasAPriority) {
        var specsForB = [mergeParagraphSpecA],
            specsForA = [mergeParagraphSpecB],
            priorityOp,
            styleParagraphFixup,
            moveCursorA,
            moveCursorB;

        if (mergeParagraphSpecA.destinationStartPosition === mergeParagraphSpecB.destinationStartPosition) {
            // Two merge commands for the same paragraph result in a noop to both sides, as the same
            // paragraph can only be merged once.
            specsForB = [];
            specsForA = [];
            // If the moveCursor flag is set, the cursor will still need to be adjusted to the right location
            if (mergeParagraphSpecA.moveCursor) {
                moveCursorA = /**@type{!ops.OpMoveCursor.Spec}*/({
                    optype: "MoveCursor",
                    memberid: mergeParagraphSpecA.memberid,
                    timestamp: mergeParagraphSpecA.timestamp,
                    position: mergeParagraphSpecA.sourceStartPosition - 1
                });
                specsForB.push(moveCursorA);
            }
            if (mergeParagraphSpecB.moveCursor) {
                moveCursorB = /**@type{!ops.OpMoveCursor.Spec}*/({
                    optype: "MoveCursor",
                    memberid: mergeParagraphSpecB.memberid,
                    timestamp: mergeParagraphSpecB.timestamp,
                    position: mergeParagraphSpecB.sourceStartPosition - 1
                });
                specsForA.push(moveCursorB);
            }

            // Determine which merge style wins
            priorityOp = hasAPriority ? mergeParagraphSpecA : mergeParagraphSpecB;
            styleParagraphFixup = /**@type{!ops.OpSetParagraphStyle.Spec}*/({
                optype: "SetParagraphStyle",
                memberid: priorityOp.memberid,
                timestamp: priorityOp.timestamp,
                position: priorityOp.destinationStartPosition,
                styleName: priorityOp.paragraphStyleName
            });
            if (hasAPriority) {
                specsForB.push(styleParagraphFixup);
            } else {
                specsForA.push(styleParagraphFixup);
            }
        } else if (mergeParagraphSpecB.sourceStartPosition === mergeParagraphSpecA.destinationStartPosition) {
            // Two consecutive paragraphs are being merged. E.g., A <- B <- C.
            // Use the styleName of the lowest destination paragraph to set the paragraph style (A <- B)
            mergeParagraphSpecA.destinationStartPosition = mergeParagraphSpecB.destinationStartPosition;
            mergeParagraphSpecA.sourceStartPosition -= 1;
            mergeParagraphSpecA.paragraphStyleName = mergeParagraphSpecB.paragraphStyleName;
        } else if (mergeParagraphSpecA.sourceStartPosition === mergeParagraphSpecB.destinationStartPosition) {
            // Two consecutive paragraphs are being merged. E.g., A <- B <- C.
            // Use the styleName of the lowest destination paragraph to set the paragraph style (A <- B)
            mergeParagraphSpecB.destinationStartPosition = mergeParagraphSpecA.destinationStartPosition;
            mergeParagraphSpecB.sourceStartPosition -= 1;
            mergeParagraphSpecB.paragraphStyleName = mergeParagraphSpecA.paragraphStyleName;
        } else if (mergeParagraphSpecA.destinationStartPosition < mergeParagraphSpecB.destinationStartPosition) {
            mergeParagraphSpecB.destinationStartPosition -= 1;
            mergeParagraphSpecB.sourceStartPosition -= 1;
        } else { // mergeParagraphSpecB.destinationStartPosition < mergeParagraphSpecA.destinationStartPosition
            mergeParagraphSpecA.destinationStartPosition -= 1;
            mergeParagraphSpecA.sourceStartPosition -= 1;
        }

        return {
            opSpecsA:  specsForB,
            opSpecsB:  specsForA
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphMoveCursor(mergeParagraphSpec, moveCursorSpec) {
        var pointA = moveCursorSpec.position,
            pointB = moveCursorSpec.position + moveCursorSpec.length,
            start = Math.min(pointA, pointB),
            end = Math.max(pointA, pointB);

        if (start >= mergeParagraphSpec.sourceStartPosition) {
            start -= 1;
        }
        if (end >= mergeParagraphSpec.sourceStartPosition) {
            end -= 1;
        }

        // When updating the cursor spec, ensure the selection direction is preserved.
        // If the length was previously positive, it should remain positive.
        if (moveCursorSpec.length >= 0) {
            moveCursorSpec.position = start;
            moveCursorSpec.length = end - start;
        } else {
            moveCursorSpec.position = end;
            moveCursorSpec.length = start - end;
        }

        return {
            opSpecsA:  [mergeParagraphSpec],
            opSpecsB:  [moveCursorSpec]
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphRemoveAnnotation(mergeParagraphSpec, removeAnnotationSpec) {
        var removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            mergeParagraphSpecResult = [mergeParagraphSpec],
            removeAnnotationSpecResult = [removeAnnotationSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= mergeParagraphSpec.destinationStartPosition && mergeParagraphSpec.sourceStartPosition <= removeAnnotationEnd) {
            mergeParagraphSpecResult = [];
            removeAnnotationSpec.length -= 1;
        } else {
            if (mergeParagraphSpec.sourceStartPosition < removeAnnotationSpec.position) {
                removeAnnotationSpec.position -= 1;
            } else {
                if (removeAnnotationEnd < mergeParagraphSpec.destinationStartPosition) {
                    mergeParagraphSpec.destinationStartPosition -= removeAnnotationSpec.length + 2;
                }
                if (removeAnnotationEnd < mergeParagraphSpec.sourceStartPosition) {
                    mergeParagraphSpec.sourceStartPosition -= removeAnnotationSpec.length + 2;
                }
            }
        }

        return {
            opSpecsA:  mergeParagraphSpecResult,
            opSpecsB:  removeAnnotationSpecResult
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphRemoveText(mergeParagraphSpec, removeTextSpec) {
        // RemoveText ops can't cross paragraph boundaries, so only the position needs to be checked
        if (removeTextSpec.position >= mergeParagraphSpec.sourceStartPosition) {
            removeTextSpec.position -= 1;
        } else {
            if (removeTextSpec.position < mergeParagraphSpec.destinationStartPosition) {
                mergeParagraphSpec.destinationStartPosition -= removeTextSpec.length;
            }
            if (removeTextSpec.position < mergeParagraphSpec.sourceStartPosition) {
                mergeParagraphSpec.sourceStartPosition -= removeTextSpec.length;
            }
        }

        return {
            opSpecsA:  [mergeParagraphSpec],
            opSpecsB:  [removeTextSpec]
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphSetParagraphStyle(mergeParagraphSpec, setParagraphStyleSpec) {
        var opSpecsA = [mergeParagraphSpec],
            opSpecsB = [setParagraphStyleSpec];

        // SetParagraphStyle ops can't cross paragraph boundaries
        if (setParagraphStyleSpec.position > mergeParagraphSpec.sourceStartPosition) {
            // Paragraph beyond the ones region affected by the merge
            setParagraphStyleSpec.position -= 1;
        } else if (setParagraphStyleSpec.position === mergeParagraphSpec.destinationStartPosition
                    || setParagraphStyleSpec.position === mergeParagraphSpec.sourceStartPosition) {
            // Attempting to style a merging paragraph
            setParagraphStyleSpec.position = mergeParagraphSpec.destinationStartPosition;
            mergeParagraphSpec.paragraphStyleName = setParagraphStyleSpec.styleName;
        }

        return {
            opSpecsA:  opSpecsA,
            opSpecsB:  opSpecsB
        };
    }

    /**
     * @param {!ops.OpMergeParagraph.Spec} mergeParagraphSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMergeParagraphSplitParagraph(mergeParagraphSpec, splitParagraphSpec) {
        var styleSplitParagraph,
            moveCursorOp,
            opSpecsA = [mergeParagraphSpec],
            opSpecsB = [splitParagraphSpec];

        if (splitParagraphSpec.position < mergeParagraphSpec.destinationStartPosition) {
            // Split occurs before the merge destination
            // Splitting a paragraph inserts one step, moving the merge along
            mergeParagraphSpec.destinationStartPosition += 1;
            mergeParagraphSpec.sourceStartPosition += 1;
        } else if (splitParagraphSpec.position >= mergeParagraphSpec.destinationStartPosition
            && splitParagraphSpec.position < mergeParagraphSpec.sourceStartPosition) {
            // split occurs within the paragraphs being merged
            splitParagraphSpec.paragraphStyleName = mergeParagraphSpec.paragraphStyleName;
            styleSplitParagraph = /**@type{!ops.OpSetParagraphStyle.Spec}*/({
                optype: "SetParagraphStyle",
                memberid: mergeParagraphSpec.memberid,
                timestamp: mergeParagraphSpec.timestamp,
                position: mergeParagraphSpec.destinationStartPosition,
                styleName: mergeParagraphSpec.paragraphStyleName
            });
            opSpecsA.push(styleSplitParagraph);
            if (splitParagraphSpec.position === mergeParagraphSpec.sourceStartPosition - 1
                    && mergeParagraphSpec.moveCursor) {
                // OdtDocument.getTextNodeAtStep + Spec.moveCursor make it very difficult to control cursor placement
                // When a split + merge combines, there is a tricky situation because the split will leave other cursors
                // on the last step in the new paragraph.
                // When the merge is relocated to attach to the front of the newly inserted paragraph below, the cursor
                // will end up at the start of the new paragraph. Workaround this by manually setting the cursor back
                // to the appropriate location after the merge completes
                moveCursorOp = /**@type{!ops.OpMoveCursor.Spec}*/({
                    optype: "MoveCursor",
                    memberid: mergeParagraphSpec.memberid,
                    timestamp: mergeParagraphSpec.timestamp,
                    position: splitParagraphSpec.position,
                    length: 0
                });
                opSpecsA.push(moveCursorOp);
            }

            // SplitParagraph ops effectively create new paragraph boundaries. The user intent
            // is for the source paragraph to be joined to the END of the dest paragraph. If the
            // split occurs in the dest paragraph, the source should be joined to the newly created
            // paragraph instead
            mergeParagraphSpec.destinationStartPosition = splitParagraphSpec.position + 1;
            mergeParagraphSpec.sourceStartPosition += 1;
        } else if (splitParagraphSpec.position >= mergeParagraphSpec.sourceStartPosition) {
            // Split occurs after the merge source
            // Merging paragraphs remove one step
            splitParagraphSpec.position -= 1;
            splitParagraphSpec.sourceParagraphPosition -= 1;
        }

        return {
            opSpecsA:  opSpecsA,
            opSpecsB:  opSpecsB
        };
    }

    /**
     * @param {!ops.OpUpdateParagraphStyle.Spec} updateParagraphStyleSpecA
     * @param {!ops.OpUpdateParagraphStyle.Spec} updateParagraphStyleSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformUpdateParagraphStyleUpdateParagraphStyle(updateParagraphStyleSpecA, updateParagraphStyleSpecB, hasAPriority) {
        var majorSpec, minorSpec,
            updateParagraphStyleSpecAResult = [updateParagraphStyleSpecA],
            updateParagraphStyleSpecBResult = [updateParagraphStyleSpecB];

        // same style updated by other op?
        if (updateParagraphStyleSpecA.styleName === updateParagraphStyleSpecB.styleName) {
            majorSpec = hasAPriority ? updateParagraphStyleSpecA : updateParagraphStyleSpecB;
            minorSpec = hasAPriority ? updateParagraphStyleSpecB : updateParagraphStyleSpecA;

            // any properties which are set by other update op need to be dropped
            dropOverruledAndUnneededProperties(minorSpec.setProperties,
                minorSpec.removedProperties, majorSpec.setProperties,
                majorSpec.removedProperties, 'style:paragraph-properties');
            dropOverruledAndUnneededProperties(minorSpec.setProperties,
                minorSpec.removedProperties, majorSpec.setProperties,
                majorSpec.removedProperties, 'style:text-properties');
            dropOverruledAndUnneededAttributes(minorSpec.setProperties || null,
                /**@type{{attributes: string}}*/(minorSpec.removedProperties) || null,
                majorSpec.setProperties || null,
                /**@type{{attributes: string}}*/(majorSpec.removedProperties) || null);

            // check if there are any changes left and the major op has not become a noop
            if (!(majorSpec.setProperties && hasProperties(majorSpec.setProperties)) &&
                    !(majorSpec.removedProperties && hasRemovedProperties(majorSpec.removedProperties))) {
                // set major spec to noop
                if (hasAPriority) {
                    updateParagraphStyleSpecAResult = [];
                } else {
                    updateParagraphStyleSpecBResult = [];
                }
            }
            // check if there are any changes left and the minor op has not become a noop
            if (!(minorSpec.setProperties && hasProperties(minorSpec.setProperties)) &&
                    !(minorSpec.removedProperties && hasRemovedProperties(minorSpec.removedProperties))) {
                // set minor spec to noop 
                if (hasAPriority) {
                    updateParagraphStyleSpecBResult = [];
                } else {
                    updateParagraphStyleSpecAResult = [];
                }
            }
        }

        return {
            opSpecsA:  updateParagraphStyleSpecAResult,
            opSpecsB:  updateParagraphStyleSpecBResult
        };
    }

    /**
     * @param {!ops.OpUpdateMetadata.Spec} updateMetadataSpecA
     * @param {!ops.OpUpdateMetadata.Spec} updateMetadataSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformUpdateMetadataUpdateMetadata(updateMetadataSpecA, updateMetadataSpecB, hasAPriority) {
        var majorSpec, minorSpec,
            updateMetadataSpecAResult = [updateMetadataSpecA],
            updateMetadataSpecBResult = [updateMetadataSpecB];

        majorSpec = hasAPriority ? updateMetadataSpecA : updateMetadataSpecB;
        minorSpec = hasAPriority ? updateMetadataSpecB : updateMetadataSpecA;

        // any properties which are set by other update op need to be dropped
        dropOverruledAndUnneededAttributes(minorSpec.setProperties || null,
                            minorSpec.removedProperties || null,
                            majorSpec.setProperties || null,
                            majorSpec.removedProperties || null);

        // check if there are any changes left and the major op has not become a noop
        if (!(majorSpec.setProperties && hasProperties(majorSpec.setProperties)) &&
                !(majorSpec.removedProperties && hasRemovedProperties(majorSpec.removedProperties))) {
            // set major spec to noop
            if (hasAPriority) {
                updateMetadataSpecAResult = [];
            } else {
                updateMetadataSpecBResult = [];
            }
        }
        // check if there are any changes left and the minor op has not become a noop
        if (!(minorSpec.setProperties && hasProperties(minorSpec.setProperties)) &&
                !(minorSpec.removedProperties && hasRemovedProperties(minorSpec.removedProperties))) {
            // set minor spec to noop 
            if (hasAPriority) {
                updateMetadataSpecBResult = [];
            } else {
                updateMetadataSpecAResult = [];
            }
        }

        return {
            opSpecsA:  updateMetadataSpecAResult,
            opSpecsB:  updateMetadataSpecBResult
        };
    }

    /**
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpecA
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformSetParagraphStyleSetParagraphStyle(setParagraphStyleSpecA, setParagraphStyleSpecB, hasAPriority) {
        if (setParagraphStyleSpecA.position === setParagraphStyleSpecB.position) {
            if (hasAPriority) {
                setParagraphStyleSpecB.styleName = setParagraphStyleSpecA.styleName;
            } else {
                setParagraphStyleSpecA.styleName = setParagraphStyleSpecB.styleName;
            }
        }

        return {
            opSpecsA:  [setParagraphStyleSpecA],
            opSpecsB:  [setParagraphStyleSpecB]
        };
    }

    /**
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformSetParagraphStyleSplitParagraph(setParagraphStyleSpec, splitParagraphSpec) {
        var opSpecsA = [setParagraphStyleSpec],
            opSpecsB = [splitParagraphSpec],
            setParagraphClone;

        if (setParagraphStyleSpec.position > splitParagraphSpec.position) {
            setParagraphStyleSpec.position += 1;
        } else if (setParagraphStyleSpec.position === splitParagraphSpec.sourceParagraphPosition) {
            // When a set paragraph style & split conflict, the set paragraph style always wins

            splitParagraphSpec.paragraphStyleName = setParagraphStyleSpec.styleName;
            // The new paragraph that resulted from the already executed split op should be styled with
            // the original paragraph style.
            setParagraphClone = cloneOpspec(setParagraphStyleSpec);
            // A split paragraph op introduces a new paragraph boundary just passed the point where the split occurs
            setParagraphClone.position = splitParagraphSpec.position + 1;
            opSpecsA.push(setParagraphClone);
        }

        return {
            opSpecsA:  opSpecsA,
            opSpecsB:  opSpecsB
        };
    }

    /**
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpecA
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpecB
     * @param {!boolean} hasAPriority
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformSplitParagraphSplitParagraph(splitParagraphSpecA, splitParagraphSpecB, hasAPriority) {
        var specABeforeB,
            specBBeforeA;

        if (splitParagraphSpecA.position < splitParagraphSpecB.position) {
            specABeforeB =  true;
        } else if (splitParagraphSpecB.position < splitParagraphSpecA.position) {
            specBBeforeA = true;
        } else if (splitParagraphSpecA.position === splitParagraphSpecB.position) {
            if (hasAPriority) {
                specABeforeB =  true;
            } else {
                specBBeforeA = true;
            }
        }

        if (specABeforeB) {
            splitParagraphSpecB.position += 1;
            if (splitParagraphSpecA.position < splitParagraphSpecB.sourceParagraphPosition) {
                splitParagraphSpecB.sourceParagraphPosition += 1;
            } else {
                // Split occurs between specB's split position & it's source paragraph position
                // This means specA introduces a NEW paragraph boundary
                splitParagraphSpecB.sourceParagraphPosition = splitParagraphSpecA.position + 1;
            }
        } else if (specBBeforeA) {
            splitParagraphSpecA.position += 1;
            if (splitParagraphSpecB.position < splitParagraphSpecB.sourceParagraphPosition) {
                splitParagraphSpecA.sourceParagraphPosition += 1;
            } else {
                // Split occurs between specA's split position & it's source paragraph position
                // This means specB introduces a NEW paragraph boundary
                splitParagraphSpecA.sourceParagraphPosition = splitParagraphSpecB.position + 1;
            }
        }

        return {
            opSpecsA:  [splitParagraphSpecA],
            opSpecsB:  [splitParagraphSpecB]
        };
    }

    /**
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMoveCursorRemoveAnnotation(moveCursorSpec, removeAnnotationSpec) {
        var isMoveCursorSpecRangeInverted = invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec),
            moveCursorSpecEnd = moveCursorSpec.position + moveCursorSpec.length,
            removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length;

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= moveCursorSpec.position && moveCursorSpecEnd <= removeAnnotationEnd) {
            moveCursorSpec.position = removeAnnotationSpec.position - 1;
            moveCursorSpec.length = 0;
        } else {
            if (removeAnnotationEnd < moveCursorSpec.position) {
                moveCursorSpec.position -= removeAnnotationSpec.length + 2;
            } else if (removeAnnotationEnd < moveCursorSpecEnd) {
                moveCursorSpec.length -= removeAnnotationSpec.length + 2;
            }
            if (isMoveCursorSpecRangeInverted) {
                invertMoveCursorSpecRange(moveCursorSpec);
            }
        }

        return {
            opSpecsA:  [moveCursorSpec],
            opSpecsB:  [removeAnnotationSpec]
        };
    }

    /**
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @param {!ops.OpRemoveCursor.Spec} removeCursorSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMoveCursorRemoveCursor(moveCursorSpec, removeCursorSpec) {
        var isSameCursorRemoved = (moveCursorSpec.memberid === removeCursorSpec.memberid);

        return {
            opSpecsA:  isSameCursorRemoved ? [] : [moveCursorSpec],
            opSpecsB:  [removeCursorSpec]
        };
    }

    /**
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMoveCursorRemoveText(moveCursorSpec, removeTextSpec) {
        var isMoveCursorSpecRangeInverted = invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec),
            moveCursorSpecEnd = moveCursorSpec.position + moveCursorSpec.length,
            removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length;

        // transform moveCursorSpec
        // removed positions by object up to move cursor position?
        if (removeTextSpecEnd <= moveCursorSpec.position) {
            // adapt by removed position
            moveCursorSpec.position -= removeTextSpec.length;
        // overlapping?
        } else if (removeTextSpec.position < moveCursorSpecEnd) {
            // still to select range starting at cursor position?
            if (moveCursorSpec.position < removeTextSpec.position) {
                // still to select range ending at selection?
                if (removeTextSpecEnd < moveCursorSpecEnd) {
                    moveCursorSpec.length -= removeTextSpec.length;
                } else {
                    moveCursorSpec.length = removeTextSpec.position - moveCursorSpec.position;
                }
            // remove overlapping section
            } else {
                // fall at start of removed section
                moveCursorSpec.position = removeTextSpec.position;
                // still to select range at selection end?
                if (removeTextSpecEnd < moveCursorSpecEnd) {
                    moveCursorSpec.length = moveCursorSpecEnd - removeTextSpecEnd;
                } else {
                    // completely overlapped by other, so selection gets void
                    moveCursorSpec.length = 0;
                }
            }
        }

        if (isMoveCursorSpecRangeInverted) {
            invertMoveCursorSpecRange(moveCursorSpec);
        }

        return {
            opSpecsA:  [moveCursorSpec],
            opSpecsB:  [removeTextSpec]
        };
    }

    /**
     * @param {!ops.OpMoveCursor.Spec} moveCursorSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformMoveCursorSplitParagraph(moveCursorSpec, splitParagraphSpec) {
        var isMoveCursorSpecRangeInverted = invertMoveCursorSpecRangeOnNegativeLength(moveCursorSpec);

        // transform moveCursorSpec
        if (splitParagraphSpec.position < moveCursorSpec.position) {
            moveCursorSpec.position += 1;
        } else if (splitParagraphSpec.position < moveCursorSpec.position + moveCursorSpec.length) {
            moveCursorSpec.length += 1;
        }

        if (isMoveCursorSpecRangeInverted) {
            invertMoveCursorSpecRange(moveCursorSpec);
        }

        return {
            opSpecsA:  [moveCursorSpec],
            opSpecsB:  [splitParagraphSpec]
        };
    }

    /**
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpecA
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpecB
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveAnnotationRemoveAnnotation(removeAnnotationSpecA, removeAnnotationSpecB) {
        var removeAnnotationSpecAResult = [removeAnnotationSpecA],
            removeAnnotationSpecBResult = [removeAnnotationSpecB];

        // check if removing the same annotation
        if (removeAnnotationSpecA.position === removeAnnotationSpecB.position && removeAnnotationSpecA.length === removeAnnotationSpecB.length) {
            removeAnnotationSpecAResult = [];
            removeAnnotationSpecBResult = [];
        } else {
            if (removeAnnotationSpecA.position < removeAnnotationSpecB.position) {
                removeAnnotationSpecB.position -= removeAnnotationSpecA.length + 2;
            } else {
                removeAnnotationSpecA.position -= removeAnnotationSpecB.length + 2;
            }
        }

        return {
            opSpecsA:  removeAnnotationSpecAResult,
            opSpecsB:  removeAnnotationSpecBResult
        };
    }

    /**
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveAnnotationRemoveText(removeAnnotationSpec, removeTextSpec) {
        var removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length,
            removeAnnotationSpecResult = [removeAnnotationSpec],
            removeTextSpecResult = [removeTextSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= removeTextSpec.position && removeTextSpecEnd <= removeAnnotationEnd) {
            removeTextSpecResult = [];
            removeAnnotationSpec.length -= removeTextSpec.length;
        } else {
            if (removeTextSpecEnd < removeAnnotationSpec.position) {
                removeAnnotationSpec.position -= removeTextSpec.length;
            } else if (removeTextSpec.position < removeAnnotationSpec.position) {
                removeAnnotationSpec.position = removeTextSpec.position + 1;
                removeTextSpec.length -= removeAnnotationSpec.length + 2;
            } else {
                removeTextSpec.position -= removeAnnotationSpec.length + 2;
            }
        }

        return {
            opSpecsA:  removeAnnotationSpecResult,
            opSpecsB:  removeTextSpecResult
        };
    }

    /**
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveAnnotationSetParagraphStyle(removeAnnotationSpec, setParagraphStyleSpec) {
        var setParagraphStyleSpecPosition = setParagraphStyleSpec.position,
            removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            removeAnnotationSpecResult = [removeAnnotationSpec],
            setParagraphStyleSpecResult = [setParagraphStyleSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= setParagraphStyleSpecPosition && setParagraphStyleSpecPosition <= removeAnnotationEnd) {
            setParagraphStyleSpecResult = [];
        } else {
            if (removeAnnotationEnd < setParagraphStyleSpecPosition) {
                setParagraphStyleSpec.position -= removeAnnotationSpec.length + 2;
            }
        }

        return {
            opSpecsA:  removeAnnotationSpecResult,
            opSpecsB:  setParagraphStyleSpecResult
        };
    }

    /**
     * @param {!ops.OpRemoveAnnotation.Spec} removeAnnotationSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveAnnotationSplitParagraph(removeAnnotationSpec, splitParagraphSpec) {
        var splitParagraphSpecPosition = splitParagraphSpec.position,
            removeAnnotationEnd = removeAnnotationSpec.position + removeAnnotationSpec.length,
            removeAnnotationSpecResult = [removeAnnotationSpec],
            splitParagraphSpecResult = [splitParagraphSpec];

        // check if inside removed annotation
        if (removeAnnotationSpec.position <= splitParagraphSpecPosition && splitParagraphSpecPosition <= removeAnnotationEnd) {
            splitParagraphSpecResult = [];
            removeAnnotationSpec.length += 1;
        } else {
            if (removeAnnotationEnd < splitParagraphSpec.sourceParagraphPosition) {
                splitParagraphSpec.sourceParagraphPosition -= removeAnnotationSpec.length + 2;
            }
            if (removeAnnotationEnd < splitParagraphSpecPosition) {
                splitParagraphSpec.position -= removeAnnotationSpec.length + 2;
            } else {
                removeAnnotationSpec.position += 1;
            }
        }

        return {
            opSpecsA:  removeAnnotationSpecResult,
            opSpecsB:  splitParagraphSpecResult
        };
    }

    /**
     * @param {!ops.OpRemoveCursor.Spec} removeCursorSpecA
     * @param {!ops.OpRemoveCursor.Spec} removeCursorSpecB
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveCursorRemoveCursor(removeCursorSpecA, removeCursorSpecB) {
        var isSameMemberid = (removeCursorSpecA.memberid === removeCursorSpecB.memberid);

        // if both are removing the same cursor, their transformed counter-ops become noops
        return {
            opSpecsA:  isSameMemberid ? [] : [removeCursorSpecA],
            opSpecsB:  isSameMemberid ? [] : [removeCursorSpecB]
        };
    }

    /**
     * @param {!ops.OpRemoveStyle.Spec} removeStyleSpecA
     * @param {!ops.OpRemoveStyle.Spec} removeStyleSpecB
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveStyleRemoveStyle(removeStyleSpecA, removeStyleSpecB) {
        var isSameStyle = (removeStyleSpecA.styleName === removeStyleSpecB.styleName && removeStyleSpecA.styleFamily === removeStyleSpecB.styleFamily);

        // if both are removing the same style, their transformed counter-ops become noops
        return {
            opSpecsA:  isSameStyle ? [] : [removeStyleSpecA],
            opSpecsB:  isSameStyle ? [] : [removeStyleSpecB]
        };
    }

    /**
     * @param {!ops.OpRemoveStyle.Spec} removeStyleSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveStyleSetParagraphStyle(removeStyleSpec, setParagraphStyleSpec) {
        var helperOpspec,
            removeStyleSpecResult = [removeStyleSpec],
            setParagraphStyleSpecResult = [setParagraphStyleSpec];

        if (removeStyleSpec.styleFamily === "paragraph" && removeStyleSpec.styleName === setParagraphStyleSpec.styleName) {
            // transform removeStyleSpec
            // just create a setstyle op preceding to us which removes any set style from the paragraph
            helperOpspec = {
                optype: "SetParagraphStyle",
                memberid: removeStyleSpec.memberid,
                timestamp: removeStyleSpec.timestamp,
                position: setParagraphStyleSpec.position,
                styleName: ""
            };
            removeStyleSpecResult.unshift(helperOpspec);

            // transform setParagraphStyleSpec
            // instead of setting now remove any existing style from the paragraph
            setParagraphStyleSpec.styleName = "";
        }

        return {
            opSpecsA:  removeStyleSpecResult,
            opSpecsB:  setParagraphStyleSpecResult
        };
    }

    /**
     * @param {!ops.OpRemoveStyle.Spec} removeStyleSpec
     * @param {!ops.OpUpdateParagraphStyle.Spec} updateParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveStyleUpdateParagraphStyle(removeStyleSpec, updateParagraphStyleSpec) {
        var setAttributes, helperOpspec,
            removeStyleSpecResult = [removeStyleSpec],
            updateParagraphStyleSpecResult = [updateParagraphStyleSpec];

        if (removeStyleSpec.styleFamily === "paragraph") {
            // transform removeStyleSpec
            // style brought into use by other op?
            setAttributes = getStyleReferencingAttributes(updateParagraphStyleSpec.setProperties, removeStyleSpec.styleName);
            if (setAttributes.length > 0) {
                // just create a updateparagraph style op preceding to us which removes any set style from the paragraph
                helperOpspec = {
                    optype: "UpdateParagraphStyle",
                    memberid: removeStyleSpec.memberid,
                    timestamp: removeStyleSpec.timestamp,
                    styleName: updateParagraphStyleSpec.styleName,
                    removedProperties: { attributes: setAttributes.join(',') }
                };
                removeStyleSpecResult.unshift(helperOpspec);
            }

            // transform updateParagraphStyleSpec
            // target style to update deleted by removeStyle?
            if (removeStyleSpec.styleName === updateParagraphStyleSpec.styleName) {
                // don't touch the dead
                updateParagraphStyleSpecResult = [];
            } else {
                // otherwise drop any attributes referencing the style deleted
                dropStyleReferencingAttributes(updateParagraphStyleSpec.setProperties, removeStyleSpec.styleName);
            }
        }

        return {
            opSpecsA:  removeStyleSpecResult,
            opSpecsB:  updateParagraphStyleSpecResult
        };
    }

    /**
     * @param {!ops.OpRemoveText.Spec} removeTextSpecA
     * @param {!ops.OpRemoveText.Spec} removeTextSpecB
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveTextRemoveText(removeTextSpecA, removeTextSpecB) {
        var removeTextSpecAEnd = removeTextSpecA.position + removeTextSpecA.length,
            removeTextSpecBEnd = removeTextSpecB.position + removeTextSpecB.length,
            removeTextSpecAResult = [removeTextSpecA],
            removeTextSpecBResult = [removeTextSpecB];

        // B removed positions by object up to As start position?
        if (removeTextSpecBEnd <= removeTextSpecA.position) {
            // adapt A by removed position
            removeTextSpecA.position -= removeTextSpecB.length;
        // A removed positions by object up to Bs start position?
        } else if (removeTextSpecAEnd <= removeTextSpecB.position) {
            // adapt B by removed position
            removeTextSpecB.position -= removeTextSpecA.length;
        // overlapping?
        // (removeTextSpecBEnd <= removeTextSpecA.position above catches non-overlapping from this condition)
        } else if (removeTextSpecB.position < removeTextSpecAEnd) {
            // A removes in front of B?
            if (removeTextSpecA.position < removeTextSpecB.position) {
                // A still to remove range at its end?
                if (removeTextSpecBEnd < removeTextSpecAEnd) {
                    removeTextSpecA.length = removeTextSpecA.length - removeTextSpecB.length;
                } else {
                    removeTextSpecA.length = removeTextSpecB.position - removeTextSpecA.position;
                }
                // B still to remove range at its end?
                if (removeTextSpecAEnd < removeTextSpecBEnd) {
                    removeTextSpecB.position = removeTextSpecA.position;
                    removeTextSpecB.length = removeTextSpecBEnd - removeTextSpecAEnd;
                } else {
                    // B completely overlapped by other, so it becomes a noop
                    removeTextSpecBResult = [];
                }
            // B removes in front of or starting at same like A
            } else {
                // B still to remove range at its end?
                if (removeTextSpecAEnd < removeTextSpecBEnd) {
                    removeTextSpecB.length = removeTextSpecB.length - removeTextSpecA.length;
                } else {
                    // B still to remove range at its start?
                    if (removeTextSpecB.position < removeTextSpecA.position) {
                        removeTextSpecB.length = removeTextSpecA.position - removeTextSpecB.position;
                    } else {
                        // B completely overlapped by other, so it becomes a noop
                        removeTextSpecBResult = [];
                    }
                }
                // A still to remove range at its end?
                if (removeTextSpecBEnd < removeTextSpecAEnd) {
                    removeTextSpecA.position = removeTextSpecB.position;
                    removeTextSpecA.length = removeTextSpecAEnd - removeTextSpecBEnd;
                } else {
                    // A completely overlapped by other, so it becomes a noop
                    removeTextSpecAResult = [];
                }
            }
        }
        return {
            opSpecsA:  removeTextSpecAResult,
            opSpecsB:  removeTextSpecBResult
        };
    }

    /**
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @param {!ops.OpSetParagraphStyle.Spec} setParagraphStyleSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveTextSetParagraphStyle(removeTextSpec, setParagraphStyleSpec) {
        // Removal is done entirely in some preceding paragraph
        if (removeTextSpec.position < setParagraphStyleSpec.position) {
            setParagraphStyleSpec.position -= removeTextSpec.length;
        }

        return {
            opSpecsA:  [removeTextSpec],
            opSpecsB:  [setParagraphStyleSpec]
        };
    }

    /**
     * @param {!ops.OpRemoveText.Spec} removeTextSpec
     * @param {!ops.OpSplitParagraph.Spec} splitParagraphSpec
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function transformRemoveTextSplitParagraph(removeTextSpec, splitParagraphSpec) {
        var removeTextSpecEnd = removeTextSpec.position + removeTextSpec.length,
            helperOpspec,
            removeTextSpecResult = [removeTextSpec],
            splitParagraphSpecResult = [splitParagraphSpec];

        // adapt removeTextSpec
        if (splitParagraphSpec.position <= removeTextSpec.position) {
            removeTextSpec.position += 1;
        } else if (splitParagraphSpec.position < removeTextSpecEnd) {
            // we have to split the removal into two ops, before and after the insertion
            removeTextSpec.length = splitParagraphSpec.position - removeTextSpec.position;
            helperOpspec = {
                optype: "RemoveText",
                memberid: removeTextSpec.memberid,
                timestamp: removeTextSpec.timestamp,
                position: splitParagraphSpec.position + 1,
                length: removeTextSpecEnd - splitParagraphSpec.position
            };
            removeTextSpecResult.unshift(helperOpspec); // helperOp first, so its position is not affected by the real op
        }

        // adapt splitParagraphSpec
        if (removeTextSpec.position + removeTextSpec.length <= splitParagraphSpec.position) {
            splitParagraphSpec.position -= removeTextSpec.length;
        } else if (removeTextSpec.position < splitParagraphSpec.position) {
            splitParagraphSpec.position = removeTextSpec.position;
        }

        if (removeTextSpec.position + removeTextSpec.length < splitParagraphSpec.sourceParagraphPosition) {
            // Removed text is before the source paragraph
            splitParagraphSpec.sourceParagraphPosition -= removeTextSpec.length;
        }
        // removeText ops can't cross over paragraph boundaries, so don't check this case

        return {
            opSpecsA:  removeTextSpecResult,
            opSpecsB:  splitParagraphSpecResult
        };
    }

    /**
     * Does an OT on the two passed opspecs, where they are not modified at all,
     * and so simply returns them in the result arrays.
     * @param {!Object} opSpecA
     * @param {!Object} opSpecB
     * @return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
     */
    function passUnchanged(opSpecA, opSpecB) {
        return {
            opSpecsA:  [opSpecA],
            opSpecsB:  [opSpecB]
        };
    }


    var /**
         * This is the lower-left half of the sparse NxN matrix with all the
         * transformation methods on the possible pairs of ops. As the matrix
         * is symmetric, only that half is used. So the user of this matrix has
         * to ensure the proper order of opspecs on lookup and on calling the
         * picked transformation method.
         *
         * Each transformation method takes the two opspecs (and optionally
         * a flag if the first has a higher priority, in case of tie breaking
         * having to be done). The method returns a record with the two
         * resulting arrays of ops, with key names "opSpecsA" and "opSpecsB".
         * Those arrays could have more than the initial respective opspec
         * inside, in case some additional helper opspecs are needed, or be
         * empty if the opspec turned into a no-op in the transformation.
         * If a transformation is not doable, the method returns "null".
         *
         * Some operations are added onto the stack only by the master session,
         * for example AddMember, RemoveMember, and UpdateMember. These therefore need
         * not be transformed against each other, since the master session is the
         * only originator of these ops. Therefore, their pairing entries in the
         * matrix are missing. They do however require a passUnchanged entry
         * with the other ops.
         *
         * Here the CC signature of each transformation method:
         * param {!Object} opspecA
         * param {!Object} opspecB
         * (param {!boolean} hasAPriorityOverB)  can be left out
         * return {?{opSpecsA:!Array.<!Object>, opSpecsB:!Array.<!Object>}}
         *
         * Empty cells in this matrix mean there is no such transformation
         * possible, and should be handled as if the method returns "null".
         *
         * @type {!Object.<string,!Object.<string,function(!Object,!Object,boolean=):?{opSpecsA:!Array.<!{optype:string}>, opSpecsB:!Array.<!{optype:string}>}>>}
         */
        transformations;
    transformations = {
        "AddAnnotation": {
            "AddAnnotation":        transformAddAnnotationAddAnnotation,
            "AddCursor":            passUnchanged,
            "AddMember":            passUnchanged,
            "AddStyle":             passUnchanged,
            "ApplyDirectStyling":   transformAddAnnotationApplyDirectStyling,
            "InsertText":           transformAddAnnotationInsertText,
            "MergeParagraph":       transformAddAnnotationMergeParagraph,
            "MoveCursor":           transformAddAnnotationMoveCursor,
            "RemoveAnnotation":     transformAddAnnotationRemoveAnnotation,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformAddAnnotationRemoveText,
            "SetParagraphStyle":    transformAddAnnotationSetParagraphStyle,
            "SplitParagraph":       transformAddAnnotationSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "AddCursor": {
            "AddCursor":            passUnchanged,
            "AddMember":            passUnchanged,
            "AddStyle":             passUnchanged,
            "ApplyDirectStyling":   passUnchanged,
            "InsertText":           passUnchanged,
            "MergeParagraph":       passUnchanged,
            "MoveCursor":           passUnchanged,
            "RemoveAnnotation":     passUnchanged,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       passUnchanged,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "AddMember": {
            "AddStyle":             passUnchanged,
            "ApplyDirectStyling":   passUnchanged,
            "InsertText":           passUnchanged,
            "MergeParagraph":       passUnchanged,
            "MoveCursor":           passUnchanged,
            "RemoveAnnotation":     passUnchanged,
            "RemoveCursor":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "AddStyle": {
            "AddStyle":             passUnchanged,
            "ApplyDirectStyling":   passUnchanged,
            "InsertText":           passUnchanged,
            "MergeParagraph":       passUnchanged,
            "MoveCursor":           passUnchanged,
            "RemoveAnnotation":     passUnchanged,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          transformAddStyleRemoveStyle,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       passUnchanged,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "ApplyDirectStyling": {
            "ApplyDirectStyling":   transformApplyDirectStylingApplyDirectStyling,
            "InsertText":           transformApplyDirectStylingInsertText,
            "MergeParagraph":       transformApplyDirectStylingMergeParagraph,
            "MoveCursor":           passUnchanged,
            "RemoveAnnotation":     transformApplyDirectStylingRemoveAnnotation,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformApplyDirectStylingRemoveText,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       transformApplyDirectStylingSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "InsertText": {
            "InsertText":           transformInsertTextInsertText,
            "MergeParagraph":       transformInsertTextMergeParagraph,
            "MoveCursor":           transformInsertTextMoveCursor,
            "RemoveAnnotation":     transformInsertTextRemoveAnnotation,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformInsertTextRemoveText,
            "SetParagraphStyle":    transformInsertTextSetParagraphStyle,
            "SplitParagraph":       transformInsertTextSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "MergeParagraph": {
            "MergeParagraph":       transformMergeParagraphMergeParagraph,
            "MoveCursor":           transformMergeParagraphMoveCursor,
            "RemoveAnnotation":     transformMergeParagraphRemoveAnnotation,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformMergeParagraphRemoveText,
            "SetParagraphStyle":    transformMergeParagraphSetParagraphStyle,
            "SplitParagraph":       transformMergeParagraphSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "MoveCursor": {
            "MoveCursor":           passUnchanged,
            "RemoveAnnotation":     transformMoveCursorRemoveAnnotation,
            "RemoveCursor":         transformMoveCursorRemoveCursor,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformMoveCursorRemoveText,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       transformMoveCursorSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "RemoveAnnotation": {
            "RemoveAnnotation":     transformRemoveAnnotationRemoveAnnotation,
            "RemoveCursor":         passUnchanged,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           transformRemoveAnnotationRemoveText,
            "SetParagraphStyle":    transformRemoveAnnotationSetParagraphStyle,
            "SplitParagraph":       transformRemoveAnnotationSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "RemoveCursor": {
            "RemoveCursor":         transformRemoveCursorRemoveCursor,
            "RemoveMember":         passUnchanged,
            "RemoveStyle":          passUnchanged,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       passUnchanged,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "RemoveMember": {
            "RemoveStyle":          passUnchanged,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    passUnchanged,
            "SplitParagraph":       passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "RemoveStyle": {
            "RemoveStyle":          transformRemoveStyleRemoveStyle,
            "RemoveText":           passUnchanged,
            "SetParagraphStyle":    transformRemoveStyleSetParagraphStyle,
            "SplitParagraph":       passUnchanged,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": transformRemoveStyleUpdateParagraphStyle
        },
        "RemoveText": {
            "RemoveText":           transformRemoveTextRemoveText,
            "SetParagraphStyle":    transformRemoveTextSetParagraphStyle,
            "SplitParagraph":       transformRemoveTextSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "SetParagraphStyle": {
            "SetParagraphStyle":    transformSetParagraphStyleSetParagraphStyle,
            "SplitParagraph":       transformSetParagraphStyleSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "SplitParagraph": {
            "SplitParagraph":       transformSplitParagraphSplitParagraph,
            "UpdateMember":         passUnchanged,
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "UpdateMember": {
            "UpdateMetadata":       passUnchanged,
            "UpdateParagraphStyle": passUnchanged
        },
        "UpdateMetadata": {
            "UpdateMetadata":       transformUpdateMetadataUpdateMetadata,
            "UpdateParagraphStyle": passUnchanged
        },
        "UpdateParagraphStyle": {
            "UpdateParagraphStyle": transformUpdateParagraphStyleUpdateParagraphStyle
        }
    };

    this.passUnchanged = passUnchanged;

    /**
     * @param {!Object.<!string,!Object.<!string,!Function>>}  moreTransformations
     * @return {undefined}
     */
    this.extendTransformations = function (moreTransformations) {
        Object.keys(moreTransformations).forEach(function (optypeA) {
            var moreTransformationsOptypeAMap = moreTransformations[optypeA],
                /**@type{!Object.<string,!Function>}*/
                optypeAMap,
                isExtendingOptypeAMap = transformations.hasOwnProperty(optypeA);

            runtime.log((isExtendingOptypeAMap ? "Extending" : "Adding") + " map for optypeA: " + optypeA);
            if (!isExtendingOptypeAMap) {
                transformations[optypeA] = {};
            }
            optypeAMap = transformations[optypeA];

            Object.keys(moreTransformationsOptypeAMap).forEach(function (optypeB) {
                var isOverwritingOptypeBEntry = optypeAMap.hasOwnProperty(optypeB);
                runtime.assert(optypeA <= optypeB, "Wrong order:" + optypeA + ", " + optypeB);
                runtime.log("  " + (isOverwritingOptypeBEntry ? "Overwriting" : "Adding") + " entry for optypeB: " + optypeB);
                optypeAMap[optypeB] = moreTransformationsOptypeAMap[optypeB];
            });
        });
    };

    /**
     * @param {!{optype:string}} opSpecA op with lower priority in case of tie breaking
     * @param {!{optype:string}} opSpecB op with higher priority in case of tie breaking
     * @return {?{opSpecsA:!Array.<!{optype:string}>,
     *            opSpecsB:!Array.<!{optype:string}>}}
     */
    this.transformOpspecVsOpspec = function (opSpecA, opSpecB) {
        var isOptypeAAlphaNumericSmaller = (opSpecA.optype <= opSpecB.optype),
            helper, transformationFunctionMap, transformationFunction, result;

runtime.log("Crosstransforming:");
runtime.log(runtime.toJson(opSpecA));
runtime.log(runtime.toJson(opSpecB));

        // switch order if needed, to match the mirrored part of the matrix
        if (!isOptypeAAlphaNumericSmaller) {
            helper = opSpecA;
            opSpecA = opSpecB;
            opSpecB = helper;
        }
        // look up transformation method
        transformationFunctionMap = transformations[opSpecA.optype];
        transformationFunction = transformationFunctionMap && transformationFunctionMap[opSpecB.optype];

        // transform
        if (transformationFunction) {
            result = transformationFunction(opSpecA, opSpecB, !isOptypeAAlphaNumericSmaller);
            if (!isOptypeAAlphaNumericSmaller && result !== null) {
                // switch result back
                result = {
                    opSpecsA:  result.opSpecsB,
                    opSpecsB:  result.opSpecsA
                };
            }
        } else {
            result = null;
        }
runtime.log("result:");
if (result) {
runtime.log(runtime.toJson(result.opSpecsA));
runtime.log(runtime.toJson(result.opSpecsB));
} else {
runtime.log("null");
}
        return result;
    };
};

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpInsertImage.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, odf, ops */

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpInsertImage = function OpInsertImage() {
    "use strict";

    var memberid, timestamp, position, filename, frameWidth, frameHeight, frameStyleName, frameName,
        drawns = odf.Namespaces.drawns,
        svgns = odf.Namespaces.svgns,
        textns = odf.Namespaces.textns,
        xlinkns = odf.Namespaces.xlinkns,
        odfUtils = odf.OdfUtils;

    /**
     * @param {!ops.OpInsertImage.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        filename = data.filename;
        frameWidth = data.frameWidth;
        frameHeight = data.frameHeight;
        frameStyleName = data.frameStyleName;
        frameName = data.frameName;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!Document} document
     * @return {!Element}
     */
    function createFrameElement(document) {
        var imageNode = document.createElementNS(drawns, 'draw:image'),
            frameNode = document.createElementNS(drawns, 'draw:frame');

        imageNode.setAttributeNS(xlinkns, 'xlink:href', filename);
        imageNode.setAttributeNS(xlinkns, 'xlink:type', 'simple');
        imageNode.setAttributeNS(xlinkns, 'xlink:show', 'embed');
        imageNode.setAttributeNS(xlinkns, 'xlink:actuate', 'onLoad');

        frameNode.setAttributeNS(drawns, 'draw:style-name', frameStyleName);
        frameNode.setAttributeNS(drawns, 'draw:name', frameName);
        frameNode.setAttributeNS(textns, 'text:anchor-type', 'as-char');
        frameNode.setAttributeNS(svgns, 'svg:width', frameWidth);
        frameNode.setAttributeNS(svgns, 'svg:height', frameHeight);
        frameNode.appendChild(imageNode);

        return frameNode;
    }

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            odfCanvas = odtDocument.getOdfCanvas(),
            domPosition = odtDocument.getTextNodeAtStep(position, memberid),
            textNode, refNode, paragraphElement, frameElement;

        if (!domPosition) {
            return false;
        }

        textNode = domPosition.textNode;
        paragraphElement = odfUtils.getParagraphElement(textNode);
        refNode = domPosition.offset !== textNode.length ?
            textNode.splitText(domPosition.offset) : textNode.nextSibling;
        frameElement = createFrameElement(odtDocument.getDOMDocument());
        textNode.parentNode.insertBefore(frameElement, refNode);
        odtDocument.emit(ops.OdtDocument.signalStepsInserted, {position: position});

        // clean up any empty text node which was created by odtDocument.getTextNodeAtStep
        if (textNode.length === 0) {
            textNode.parentNode.removeChild(textNode);
        }

        odfCanvas.addCssForFrameWithImage(frameElement);
        odfCanvas.refreshCSS();
        odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
            paragraphElement: paragraphElement,
            memberId: memberid,
            timeStamp: timestamp
        });
        odfCanvas.rerenderAnnotations();
        return true;
    };

    /**
     * @return {!ops.OpInsertImage.Spec}
     */
    this.spec = function () {
        return {
            optype: "InsertImage",
            memberid: memberid,
            timestamp: timestamp,
            filename: filename,
            position: position,
            frameWidth: frameWidth,
            frameHeight: frameHeight,
            frameStyleName: frameStyleName,
            frameName: frameName
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    filename:string,
    position:number,
    frameWidth:string,
    frameHeight:string,
    frameStyleName:string,
    frameName:string
}}*/
ops.OpInsertImage.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    filename:string,
    position:number,
    frameWidth:string,
    frameHeight:string,
    frameStyleName:string,
    frameName:string
}}*/
ops.OpInsertImage.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpInsertTable.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, odf, runtime*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpInsertTable = function OpInsertTable() {
    "use strict";

    var memberid, timestamp, initialRows, initialColumns, position, tableName, tableStyleName,
        tableColumnStyleName,
        /**@type{!Array.<!Array.<string>>}*/
        tableCellStyleMatrix,
        /**@const*/
        tablens = "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
        /**@const*/
        textns = "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
        odfUtils = odf.OdfUtils;

    /**
     * @param {!ops.OpInsertTable.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        initialRows = data.initialRows;
        initialColumns = data.initialColumns;
        tableName = data.tableName;
        tableStyleName = data.tableStyleName;
        tableColumnStyleName = data.tableColumnStyleName;
        tableCellStyleMatrix = data.tableCellStyleMatrix;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!number} row
     * @param {!number} column
     * @return {!string|undefined}
     */
    function getCellStyleName(row, column) {
        var rowStyles;
        if (tableCellStyleMatrix.length === 1) {
            rowStyles = tableCellStyleMatrix[0];
        } else if (tableCellStyleMatrix.length === 3) {
            switch (row) {
            case 0:
                rowStyles = tableCellStyleMatrix[0];
                break;
            case initialRows - 1:
                rowStyles = tableCellStyleMatrix[2];
                break;
            default:
                rowStyles = tableCellStyleMatrix[1];
                break;
            }
        } else {
            rowStyles = tableCellStyleMatrix[row];
        }

        if (rowStyles.length === 1) {
            return rowStyles[0];
        }
        if (rowStyles.length === 3) {
            switch (column) {
            case 0:
                return rowStyles[0];
            case initialColumns - 1:
                return rowStyles[2];
            default:
                return rowStyles[1];
            }
        }
        return rowStyles[column];
    }

    /**
     * @param {!Document} document
     * @return {!Element}
     */
    function createTableNode(document) {
        var tableNode = document.createElementNS(tablens, "table:table"),
            columns = document.createElementNS(tablens, "table:table-column"),
            row, cell, paragraph,
            rowCounter, columnCounter, cellStyleName;

        if (tableStyleName) {
            tableNode.setAttributeNS(tablens, "table:style-name", tableStyleName);
        }
        if (tableName) {
            tableNode.setAttributeNS(tablens, "table:name", tableName);
        }

        columns.setAttributeNS(tablens, "table:number-columns-repeated", initialColumns);
        if (tableColumnStyleName) {
            columns.setAttributeNS(tablens, "table:style-name", tableColumnStyleName);
        }

        tableNode.appendChild(columns);
        for (rowCounter = 0; rowCounter < initialRows; rowCounter += 1) {
            row = document.createElementNS(tablens, "table:table-row");
            for (columnCounter = 0; columnCounter < initialColumns; columnCounter += 1) {
                cell = document.createElementNS(tablens, "table:table-cell");
                cellStyleName = getCellStyleName(rowCounter, columnCounter);
                if (cellStyleName) {
                    cell.setAttributeNS(tablens, "table:style-name", cellStyleName);
                }
                paragraph = document.createElementNS(textns, "text:p");
                cell.appendChild(paragraph);
                row.appendChild(cell);
            }
            tableNode.appendChild(row);
        }
        return tableNode;
    }

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            domPosition = odtDocument.getTextNodeAtStep(position),
            rootNode = odtDocument.getRootNode(),
            previousSibling,
            tableNode;

        if (domPosition) {
            tableNode = createTableNode(odtDocument.getDOMDocument());
            // For now assume the table should be inserted after the current paragraph
            // or failing that, as the first element in the root node
            previousSibling = odfUtils.getParagraphElement(domPosition.textNode);
            rootNode.insertBefore(tableNode, previousSibling.nextSibling);
            // The parent table counts for 1 position, and 1 paragraph is added per cell
            odtDocument.emit(ops.OdtDocument.signalStepsInserted, {position: position});

            odtDocument.getOdfCanvas().refreshSize();
            odtDocument.emit(ops.OdtDocument.signalTableAdded, {
                tableElement: tableNode,
                memberId: memberid,
                timeStamp: timestamp
            });

            odtDocument.getOdfCanvas().rerenderAnnotations();
            return true;
        }
        return false;
    };

    /**
     * @return {!ops.OpInsertTable.Spec}
     */
    this.spec = function () {
        return {
            optype: "InsertTable",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            initialRows: initialRows,
            initialColumns: initialColumns,
            tableName: tableName,
            tableStyleName: tableStyleName,
            tableColumnStyleName: tableColumnStyleName,
            tableCellStyleMatrix: tableCellStyleMatrix
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    initialRows:number,
    initialColumns:number,
    tableName:string,
    tableStyleName:string,
    tableColumnStyleName:string,
    tableCellStyleMatrix:!Array.<!Array.<string>>
}}*/
ops.OpInsertTable.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    initialRows:number,
    initialColumns:number,
    tableName:string,
    tableStyleName:string,
    tableColumnStyleName:string,
    tableCellStyleMatrix:!Array.<!Array.<string>>
}}*/
ops.OpInsertTable.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpInsertText.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, odf, runtime*/

/**
 * This operation inserts the given text
 * at the specified position, and if
 * the moveCursor flag is specified and
 * is set as true, moves the cursor to
 * the end of the inserted text.
 * Otherwise, the cursor remains at the
 * same position as before.
 * @constructor
 * @implements ops.Operation
 */
ops.OpInsertText = function OpInsertText() {
    "use strict";

    var tab = "\t",
        memberid,
        timestamp,
        /**@type{number}*/
        position,
        /**@type{boolean}*/
        moveCursor,
        /**@type{string}*/
        text,
        odfUtils = odf.OdfUtils;

    /**
     * @param {!ops.OpInsertText.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        text = data.text;
        moveCursor = data.moveCursor === 'true' || data.moveCursor === true;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * This is a workaround for a bug where webkit forgets to relayout
     * the text when a new character is inserted at the beginning of a line in
     * a Text Node.
     * @param {!Node} textNode
     * @return {undefined}
     */
    function triggerLayoutInWebkit(textNode) {
        var parent = textNode.parentNode,
            next = textNode.nextSibling;

        parent.removeChild(textNode);
        parent.insertBefore(textNode, next);
    }

    /**
     * Returns true if the supplied character is a non-tab ODF whitespace character
     * @param {!string} character
     * @return {!boolean}
     */
    function isNonTabWhiteSpace(character) {
        return character !== tab && odfUtils.isODFWhitespace(character);
    }

    /**
     * Returns true if the particular character in the text string is a space character that is immediately
     * preceded by another space character (or is the first or last space in the text block).
     * Logic is based on http://docs.oasis-open.org/office/v1.2/os/OpenDocument-v1.2-os-part1.html#element-text_s
     * @param {!string} text
     * @param {!number} index
     * @return {boolean}
     */
    function requiresSpaceElement(text, index) {
        return isNonTabWhiteSpace(text[index]) && (index === 0 || index === text.length - 1 || isNonTabWhiteSpace(text[index - 1]));
    }

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            domPosition,
            previousNode,
            /**@type{!Element}*/
            parentElement,
            nextNode = null,
            ownerDocument = odtDocument.getDOMDocument(),
            paragraphElement,
            textns = "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
            toInsertIndex = 0,
            spaceElement,
            cursor = odtDocument.getCursor(memberid),
            i;

        /**
         * @param {string} toInsertText
         */
        function insertTextNode(toInsertText) {
            parentElement.insertBefore(ownerDocument.createTextNode(toInsertText), nextNode);
        }

        odtDocument.upgradeWhitespacesAtPosition(position);
        domPosition = odtDocument.getTextNodeAtStep(position);

        if (domPosition) {
            previousNode = domPosition.textNode;
            nextNode = previousNode.nextSibling;
            parentElement = /**@type{!Element}*/(previousNode.parentNode);
            paragraphElement = odfUtils.getParagraphElement(previousNode);

            // first do the insertion with any contained tabs or spaces
            for (i = 0; i < text.length; i += 1) {
                if (text[i] === tab || requiresSpaceElement(text, i)) {
                    // no nodes inserted yet?
                    if (toInsertIndex === 0) {
                        // if inserting in the middle the given text node needs to be split up
                        // if previousNode becomes empty, it will be cleaned up on finishing
                        if (domPosition.offset !== previousNode.length) {
                            nextNode = previousNode.splitText(domPosition.offset);
                        }
                        // normal text to insert before this space?
                        if (0 < i) {
                            previousNode.appendData(text.substring(0, i));
                        }
                    } else {
                        // normal text to insert before this space?
                        if (toInsertIndex < i) {
                            insertTextNode(text.substring(toInsertIndex, i));
                        }
                    }
                    toInsertIndex = i + 1;

                    // insert appropriate spacing element
                    if (text[i] === tab) {
                        spaceElement = ownerDocument.createElementNS(textns, "text:tab");
                        spaceElement.appendChild(ownerDocument.createTextNode("\t"));
                    } else {
                        if (text[i] !== " ") {
                            runtime.log("WARN: InsertText operation contains non-tab, non-space whitespace character (character code " + text.charCodeAt(i) + ")");
                        }
                        spaceElement = ownerDocument.createElementNS(textns, "text:s");
                        spaceElement.appendChild(ownerDocument.createTextNode(" "));
                    }
                    parentElement.insertBefore(spaceElement, nextNode);
                }
            }

            // then insert rest
            // text can be completely inserted, no spaces/tabs?
            if (toInsertIndex === 0) {
                previousNode.insertData(domPosition.offset, text);
            } else if (toInsertIndex < text.length) {
                insertTextNode(text.substring(toInsertIndex));
            }

            // FIXME A workaround.
            triggerLayoutInWebkit(previousNode);

            // Clean up the possibly created empty text node
            if (previousNode.length === 0) {
                previousNode.parentNode.removeChild(previousNode);
            }

            odtDocument.emit(ops.OdtDocument.signalStepsInserted, {position: position});

            if (cursor && moveCursor) {
                // Explicitly place the cursor in the desired position after insertion
                // TODO: At the moment the inserted text already appears before the
                // cursor, so the cursor is effectively at position + text.length
                // already. So this ought to be optimized, by perhaps removing
                // the textnode + cursor reordering logic from OdtDocument's
                // getTextNodeAtStep.
                odtDocument.moveCursor(memberid, position + text.length, 0);
                odtDocument.emit(ops.Document.signalCursorMoved, cursor);
            }

            odtDocument.downgradeWhitespacesAtPosition(position);
            odtDocument.downgradeWhitespacesAtPosition(position + text.length);

            odtDocument.getOdfCanvas().refreshSize();
            odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
                paragraphElement: paragraphElement,
                memberId: memberid,
                timeStamp: timestamp
            });

            odtDocument.getOdfCanvas().rerenderAnnotations();
            return true;
        }
        return false;
    };

    /**
     * @return {!ops.OpInsertText.Spec}
     */
    this.spec = function () {
        return {
            optype: "InsertText",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            text: text,
            moveCursor: moveCursor
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    text:string,
    moveCursor:boolean
}}*/
ops.OpInsertText.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    text:string,
    moveCursor:(string|boolean|undefined)
}}*/
ops.OpInsertText.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpMergeParagraph.js
========================================================================

/**
 * Copyright (C) 2010-2014 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime, odf, core, Node, NodeFilter*/

/**
 * Merges two adjacent paragraphs together into the first paragraph. The destination paragraph
 * is expected to always be the first paragraph in DOM order. No content (other than editinfo elements)
 * are removed as part of this operation. Once all child nodes have been shifted from the source paragraph,
 * the source paragraph and any collapsible parents will be cleaned up.
 *
 * @constructor
 * @implements ops.Operation
 */
ops.OpMergeParagraph = function OpMergeParagraph() {
    "use strict";

    var memberid, timestamp,
        /**@type {!boolean}*/
        moveCursor,
        /**@type{!string}*/
        paragraphStyleName,
        /**@type{!number}*/
        sourceStartPosition,
        /**@type{!number}*/
        destinationStartPosition,
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils,
        /**@const*/
        textns = odf.Namespaces.textns;

    /**
     * @param {!ops.OpMergeParagraph.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        moveCursor = data.moveCursor;
        paragraphStyleName = data.paragraphStyleName;
        sourceStartPosition = parseInt(data.sourceStartPosition, 10);
        destinationStartPosition = parseInt(data.destinationStartPosition, 10);
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * Returns true if the supplied node is an ODF grouping element with no content
     * @param {!Node} element
     * @return {!number}
     */
    function filterEmptyGroupingElementToRemove(element) {
        if (odf.OdfUtils.isInlineRoot(element)) {
            return NodeFilter.FILTER_SKIP;
        }
        return odfUtils.isGroupingElement(element) && odfUtils.hasNoODFContent(element) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;
    }

    /**
     * Merges the source paragraph into the destination paragraph.
     * @param {!Element} destination Paragraph to merge content into
     * @param {!Element} source Paragraph to merge content from
     * @return {undefined}
     */
    function mergeParagraphs(destination, source) {
        var child;

        child = source.firstChild;
        while (child) {
            if (child.localName === 'editinfo') {
                // TODO It should be the view's responsibility to clean these up. This would fix #431
                source.removeChild(child);
            } else {
                destination.appendChild(child);
                // Empty spans need to be cleaned up on merge, as remove text only removes things that contain text content
                // Child is moved across before collapsing so any foreign sub-elements are collapsed up the chain next to
                // the destination location
                domUtils.removeUnwantedNodes(child, filterEmptyGroupingElementToRemove);
            }
            child = source.firstChild;
        }
    }

    /**
     * Returns true if the specified node is insignificant whitespace
     * @param {!Node} node
     * @return {!boolean}
     */
    function isInsignificantWhitespace(node) {
        var textNode,
            badNodeDescription;
        if (node.nodeType === Node.TEXT_NODE) {
            textNode = /**@type{!Text}*/(node);
            if (textNode.length === 0) {
                // This is not a critical issue, but indicates an operation somewhere isn't correctly normalizing text nodes
                // after manipulation of the DOM.
                runtime.log("WARN: Empty text node found during merge operation");
                return true;
            }
            if (odfUtils.isODFWhitespace(textNode.data) && odfUtils.isSignificantWhitespace(textNode, 0) === false) {
                return true;
            }
            badNodeDescription = "#text";
        } else {
            badNodeDescription = (node.prefix ? (node.prefix + ":") : "") + node.localName;
        }
        runtime.log("WARN: Unexpected text element found near paragraph boundary [" + badNodeDescription + "]");
        return false;
    }

    /**
     * Remove all the text nodes within the supplied range. These are expected to be insignificant whitespace only.
     * Assertions will be thrown if this is not the case.
     *
     * @param {!Range} range
     * @return {undefined}
     */
    function removeTextNodes(range) {
        var emptyTextNodes;

        if (range.collapsed) {
            return;
        }

        domUtils.splitBoundaries(range);
        // getTextElements may return some unexpected text nodes if the step filters haven't correctly identified the
        // first/last step in the paragraph. Rather than failing completely in this case, simply log the unexpected
        // items and skip them.
        emptyTextNodes = odfUtils.getTextElements(range, false, true).filter(isInsignificantWhitespace);
        emptyTextNodes.forEach(function(node) {
            node.parentNode.removeChild(node);
        });
    }

    /**
     * Discard insignificant whitespace between the start of the paragraph node and the first step in the paragraph
     *
     * @param {!core.StepIterator} stepIterator
     * @param {!Element} paragraphElement
     * @return {undefined}
     */
    function trimLeadingInsignificantWhitespace(stepIterator, paragraphElement) {
        var range = paragraphElement.ownerDocument.createRange();
        stepIterator.setPosition(paragraphElement, 0);
        stepIterator.roundToNextStep();
        range.setStart(paragraphElement, 0);
        range.setEnd(stepIterator.container(), stepIterator.offset());
        removeTextNodes(range);
    }

    /**
     * Discard insignificant whitespace between the last step in the paragraph and the end of the paragraph node
     *
     * @param {!core.StepIterator} stepIterator
     * @param {!Element} paragraphElement
     * @return {undefined}
     */
    function trimTrailingInsignificantWhitespace(stepIterator, paragraphElement) {
        var range = paragraphElement.ownerDocument.createRange();
        stepIterator.setPosition(paragraphElement, paragraphElement.childNodes.length);
        stepIterator.roundToPreviousStep();
        range.setStart(stepIterator.container(), stepIterator.offset());
        range.setEnd(paragraphElement, paragraphElement.childNodes.length);
        removeTextNodes(range);
    }

    /**
     * Fetch the paragraph at the specified step. In addition, if a stepIterator is provided,
     * set the step iterator position to the exact DOM point of the requested step.
     *
     * @param {!ops.OdtDocument} odtDocument
     * @param {!number} steps
     * @param {!core.StepIterator=} stepIterator
     * @return {!Element}
     */
    function getParagraphAtStep(odtDocument, steps, stepIterator) {
        var domPoint = odtDocument.convertCursorStepToDomPoint(steps),
            paragraph = odfUtils.getParagraphElement(domPoint.node, domPoint.offset);
        runtime.assert(Boolean(paragraph), "Paragraph not found at step " + steps);
        if (stepIterator) {
            stepIterator.setPosition(domPoint.node, domPoint.offset);
        }
        return /**@type{!Element}*/(paragraph);
    }

    /**
     * @param {!ops.Document} document
     * @return {!boolean}
     */
    this.execute = function (document) {
        var odtDocument = /**@type{!ops.OdtDocument}*/(document),
            sourceParagraph,
            destinationParagraph,
            cursor = odtDocument.getCursor(memberid),
            rootNode = odtDocument.getRootNode(),
            collapseRules = new odf.CollapsingRules(rootNode),
            stepIterator = odtDocument.createStepIterator(rootNode, 0, [odtDocument.getPositionFilter()], rootNode),
            downgradeOffset;

        // Asserting a specific order for destination + source makes it easier to decide which ends to upgrade
        runtime.assert(destinationStartPosition < sourceStartPosition,
                        "Destination paragraph (" + destinationStartPosition + ") must be " +
                        "before source paragraph (" + sourceStartPosition + ")");

        destinationParagraph = getParagraphAtStep(odtDocument, destinationStartPosition);

        // Merging is not expected to be able to re-order document content. It is only ever removing a single paragraph
        // split and merging the content back into the previous paragraph. This helps ensure OT behaviour is straightforward
        sourceParagraph = getParagraphAtStep(odtDocument, sourceStartPosition, stepIterator);
        stepIterator.previousStep();
        runtime.assert(domUtils.containsNode(destinationParagraph, stepIterator.container()),
                        "Destination paragraph must be adjacent to the source paragraph");

        trimTrailingInsignificantWhitespace(stepIterator, destinationParagraph);
        downgradeOffset = destinationParagraph.childNodes.length;
        trimLeadingInsignificantWhitespace(stepIterator, sourceParagraph);

        mergeParagraphs(destinationParagraph, sourceParagraph);
        // All children have been migrated, now consume up the source parent chain
        runtime.assert(sourceParagraph.childNodes.length === 0, "Source paragraph should be empty before it is removed");
        // Merge into parent logic still necessary as the parent may have surrounding containers that collapse
        // (e.g., is now inside an empty list)
        collapseRules.mergeChildrenIntoParent(sourceParagraph);

        // Merging removes a single step between the boundary of the two paragraphs
        odtDocument.emit(ops.OdtDocument.signalStepsRemoved, {position: sourceStartPosition - 1});

        // Downgrade trailing spaces at the end of the destination paragraph, and the beginning of the source paragraph.
        // These are the only two places that might need downgrading as a result of the merge.
        // NB: if the destination paragraph was empty before the merge, this might actually check the
        // paragraph just prior to the destination. However, as the downgrade also checks 2 steps after the specified
        // one though, there is no harm caused by this.
        stepIterator.setPosition(destinationParagraph, downgradeOffset);
        stepIterator.roundToClosestStep();
        if (!stepIterator.previousStep()) {
            // If no previous step is found, round back up to the next available step
            stepIterator.roundToNextStep();
        }
        odtDocument.downgradeWhitespaces(stepIterator);

        if (paragraphStyleName) {
            destinationParagraph.setAttributeNS(textns, "text:style-name", paragraphStyleName);
        } else {
            destinationParagraph.removeAttributeNS(textns, "style-name");
        }

        if (cursor && moveCursor) {
            odtDocument.moveCursor(memberid, sourceStartPosition - 1, 0);
            odtDocument.emit(ops.Document.signalCursorMoved, cursor);
        }

        odtDocument.fixCursorPositions();
        odtDocument.getOdfCanvas().refreshSize();
        // TODO: signal also the deleted paragraphs, so e.g. SessionView can clean up the EditInfo
        odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
            paragraphElement: destinationParagraph,
            memberId: memberid,
            timeStamp: timestamp
        });

        odtDocument.getOdfCanvas().rerenderAnnotations();
        return true;
    };

    /**
     * @return {!ops.OpMergeParagraph.Spec}
     */
    this.spec = function () {
        return {
            optype: "MergeParagraph",
            memberid: memberid,
            timestamp: timestamp,
            moveCursor: moveCursor,
            paragraphStyleName: paragraphStyleName,
            sourceStartPosition: sourceStartPosition,
            destinationStartPosition: destinationStartPosition
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    moveCursor: !boolean,
    paragraphStyleName: !string,
    sourceStartPosition: !number,
    destinationStartPosition: !number
}}*/
ops.OpMergeParagraph.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    moveCursor: !boolean,
    paragraphStyleName: !string,
    sourceStartPosition: !number,
    destinationStartPosition: !number
}}*/
ops.OpMergeParagraph.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpMoveCursor.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global runtime, ops*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpMoveCursor = function OpMoveCursor() {
    "use strict";

    var memberid, timestamp, position, length, /**@type {!string}*/selectionType;

    /**
     * @param {!ops.OpMoveCursor.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        length = data.length || 0;
        selectionType = data.selectionType || ops.OdtCursor.RangeSelection;
    };

    this.isEdit = false;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            cursor = odtDocument.getCursor(memberid),
            selectedRange;

        if (!cursor) {
            return false;
        }

        selectedRange = odtDocument.convertCursorToDomRange(position, length);
        cursor.setSelectedRange(selectedRange, length >= 0);
        cursor.setSelectionType(selectionType);
        odtDocument.emit(ops.Document.signalCursorMoved, cursor);
        return true;
    };

    /**
     * @return {!ops.OpMoveCursor.Spec}
     */
    this.spec = function () {
        return {
            optype: "MoveCursor",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length,
            selectionType: selectionType
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number,
    selectionType:string
}}*/
ops.OpMoveCursor.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number,
    selectionType:(string|undefined)
}}*/
ops.OpMoveCursor.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveAnnotation.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime, odf, core*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveAnnotation = function OpRemoveAnnotation() {
    "use strict";
    var memberid, timestamp,
        /**@type{number}*/
        position,
        /**@type{number}*/
        length,
        domUtils = core.DomUtils;

    /**
     * @param {!ops.OpRemoveAnnotation.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = parseInt(data.position, 10);
        length = parseInt(data.length, 10);
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            iterator = odtDocument.getIteratorAtPosition(position),
            container = iterator.container(),
            annotationNode,
            annotationEnd;

        while (!(container.namespaceURI === odf.Namespaces.officens
            && container.localName === 'annotation')) {
            container = container.parentNode;
        }
        if (container === null) {
            return false;
        }

        annotationNode = /**@type{!odf.AnnotationElement}*/(container);
        annotationEnd = annotationNode.annotationEndElement;

        // Untrack and unwrap annotation
        odtDocument.getOdfCanvas().forgetAnnotation(annotationNode);

        /**
         * @param {!Node} node
         */
        function insert(node) {
            /**@type{!Node}*/(annotationNode).parentNode.insertBefore(node, annotationNode);
        }
        // Move all cursors - outside and before the annotation node
        domUtils.getElementsByTagNameNS(annotationNode, 'urn:webodf:names:cursor', 'cursor').forEach(insert);
        domUtils.getElementsByTagNameNS(annotationNode, 'urn:webodf:names:cursor', 'anchor').forEach(insert);

        // Delete start and end
        annotationNode.parentNode.removeChild(annotationNode);
        if (annotationEnd) {
            annotationEnd.parentNode.removeChild(annotationEnd);
        }
        // The specified position is the first walkable step in the annotation. The position is always just before the first point of change
        odtDocument.emit(ops.OdtDocument.signalStepsRemoved, {position: position > 0 ? position - 1 : position});

        odtDocument.getOdfCanvas().rerenderAnnotations();
        odtDocument.fixCursorPositions();
        return true;
    };

    /**
     * @return {!ops.OpRemoveAnnotation.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveAnnotation",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number
}}*/
ops.OpRemoveAnnotation.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number
}}*/
ops.OpRemoveAnnotation.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveBlob.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops */

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveBlob = function OpRemoveBlob() {
    "use strict";

    var memberid, timestamp, filename;

    /**
     * @param {!ops.OpRemoveBlob.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        filename = data.filename;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document);
        odtDocument.getOdfCanvas().odfContainer().removeBlob(filename);
        return true;
    };

    /**
     * @return {!ops.OpRemoveBlob.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveBlob",
            memberid: memberid,
            timestamp: timestamp,
            filename: filename
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    filename:string
}}*/
ops.OpRemoveBlob.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    filename:string
}}*/
ops.OpRemoveBlob.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveCursor.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveCursor = function OpRemoveCursor() {
    "use strict";

    var memberid, timestamp;

    /**
     * @param {!ops.OpRemoveCursor.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
    };

    this.isEdit = false;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document);
        if (!odtDocument.removeCursor(memberid)) {
            return false;
        }

        return true;
    };

    /**
     * @return {!ops.OpRemoveCursor.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveCursor",
            memberid: memberid,
            timestamp: timestamp
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number
}}*/
ops.OpRemoveCursor.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined)
}}*/
ops.OpRemoveCursor.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveHyperlink.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, odf, core, runtime */

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveHyperlink = function OpRemoveHyperlink() {
    "use strict";

    var memberid, timestamp, position, length,
        domUtils = core.DomUtils,
        odfUtils = odf.OdfUtils;

    /**
     * @param {!ops.OpRemoveHyperlink.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = data.position;
        length = data.length;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            range = odtDocument.convertCursorToDomRange(position, length),
            links = odfUtils.getHyperlinkElements(range),
            node;

        runtime.assert(links.length === 1, "The given range should only contain a single link.");
        node = domUtils.mergeIntoParent(/**@type{!Node}*/(links[0]));
        range.detach();

        odtDocument.fixCursorPositions();
        odtDocument.getOdfCanvas().refreshSize();
        odtDocument.getOdfCanvas().rerenderAnnotations();
        odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
            paragraphElement: odfUtils.getParagraphElement(node),
            memberId: memberid,
            timeStamp: timestamp
        });
        return true;
    };

    /**
     * @return {!ops.OpRemoveHyperlink.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveHyperlink",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number
}}*/
ops.OpRemoveHyperlink.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number
}}*/
ops.OpRemoveHyperlink.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveMember.js
========================================================================

/**
 * Copyright (C) 2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveMember = function OpRemoveMember() {
    "use strict";

    var memberid, timestamp;

    /**
     * @param {!ops.OpRemoveMember.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = parseInt(data.timestamp, 10);
    };

    this.isEdit = false;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document);
        if (!odtDocument.getMember(memberid)) {
            return false;
        }

        odtDocument.removeMember(memberid);
        odtDocument.emit(ops.Document.signalMemberRemoved, memberid);

        return true;
    };

    /**
     * @return {!ops.OpRemoveMember.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveMember",
            memberid: memberid,
            timestamp: timestamp
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number
}}*/
ops.OpRemoveMember.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined)
}}*/
ops.OpRemoveMember.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveStyle.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveStyle = function OpRemoveStyle() {
    "use strict";

    var memberid, timestamp, styleName, styleFamily;

    /**
     * @param {!ops.OpRemoveStyle.InitSpec} data
     */
    this.init = function (data) {
        memberid = data.memberid;
        timestamp = data.timestamp;
        styleName = data.styleName;
        styleFamily = data.styleFamily;
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            styleNode = odtDocument.getFormatting().getStyleElement(styleName, styleFamily);

        if (!styleNode) {
            return false;
        }

        styleNode.parentNode.removeChild(styleNode);

        odtDocument.getOdfCanvas().refreshCSS();
        odtDocument.emit(ops.OdtDocument.signalCommonStyleDeleted, {name: styleName, family: styleFamily});
        return true;
    };

    /**
     * @return {!ops.OpRemoveStyle.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveStyle",
            memberid: memberid,
            timestamp: timestamp,
            styleName: styleName,
            styleFamily: styleFamily
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    styleName:string,
    styleFamily:string
 }}*/
ops.OpRemoveStyle.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    styleName:string,
    styleFamily:string
 }}*/
ops.OpRemoveStyle.InitSpec;

========================================================================
FILE: C:\Users\techn\eclipse\workspace\TechnikTeam\src\main\webapp\vendor\webodf\lib\ops\OpRemoveText.js
========================================================================

/**
 * Copyright (C) 2012-2013 KO GmbH <copyright@kogmbh.com>
 *
 * @licstart
 * This file is part of WebODF.
 *
 * WebODF is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Affero General Public License (GNU AGPL)
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * WebODF is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with WebODF.  If not, see <http://www.gnu.org/licenses/>.
 * @licend
 *
 * @source: http://www.webodf.org/
 * @source: https://github.com/kogmbh/WebODF/
 */

/*global ops, runtime, odf, core*/

/**
 * @constructor
 * @implements ops.Operation
 */
ops.OpRemoveText = function OpRemoveText() {
    "use strict";

    var memberid, timestamp,
        /**@type {number}*/
        position,
        /**@type {number}*/
        length,
        odfUtils = odf.OdfUtils,
        domUtils = core.DomUtils;

    /**
     * @param {!ops.OpRemoveText.InitSpec} data
     */
    this.init = function (data) {
        runtime.assert(data.length >= 0, "OpRemoveText only supports positive lengths");
        memberid = data.memberid;
        timestamp = data.timestamp;
        position = parseInt(data.position, 10);
        length = parseInt(data.length, 10);
    };

    this.isEdit = true;
    this.group = undefined;

    /**
     * @param {!ops.Document} document
     */
    this.execute = function (document) {
        var odtDocument = /**@type{ops.OdtDocument}*/(document),
            range,
            textNodes,
            paragraph,
            cursor = odtDocument.getCursor(memberid),
            collapseRules = new odf.CollapsingRules(odtDocument.getRootNode());

        odtDocument.upgradeWhitespacesAtPosition(position);
        odtDocument.upgradeWhitespacesAtPosition(position + length);

        range = odtDocument.convertCursorToDomRange(position, length);
        domUtils.splitBoundaries(range);
        textNodes = odfUtils.getTextElements(range, false, true);
        paragraph = /**@type{!Element}*/(odfUtils.getParagraphElement(range.startContainer, range.startOffset));
        runtime.assert(paragraph !== undefined, "Attempting to remove text outside a paragraph element");
        range.detach();

        // Each character element is fully contained within the range, so will be completely removed
        textNodes.forEach(function (element) {
            if (element.parentNode) {
                // In order to guarantee OT-ability, this rule needs to be enforced, otherwise it's impossible to tell
                // which paragraph boundaries might be impacted by the remove op.
                runtime.assert(domUtils.containsNode(paragraph, element),
                    "RemoveText only supports removing elements within the same paragraph");

                collapseRules.mergeChildrenIntoParent(element);
            } else {
                // If this is an empty text node, it might have already been removed from it's container.
                // Although WebODF specifically avoids empty text nodes at all times, incorrect 3rd party
                // DOM manipulation (or undiscovered WebODF bugs) may leave these behind.
                runtime.log("WARN: text element has already been removed from it's container");
            }
        });

        odtDocument.emit(ops.OdtDocument.signalStepsRemoved, {position: position});
        odtDocument.downgradeWhitespacesAtPosition(position);
        odtDocument.fixCursorPositions();
        odtDocument.getOdfCanvas().refreshSize();
        odtDocument.emit(ops.OdtDocument.signalParagraphChanged, {
            paragraphElement: paragraph,
            memberId: memberid,
            timeStamp: timestamp
        });

        if (cursor) {
            cursor.resetSelectionType();
            odtDocument.emit(ops.Document.signalCursorMoved, cursor);
        }

        odtDocument.getOdfCanvas().rerenderAnnotations();
        return true;
    };

    /**
     * @return {!ops.OpRemoveText.Spec}
     */
    this.spec = function () {
        return {
            optype: "RemoveText",
            memberid: memberid,
            timestamp: timestamp,
            position: position,
            length: length
        };
    };
};
/**@typedef{{
    optype:string,
    memberid:string,
    timestamp:number,
    position:number,
    length:number
}}*/
ops.OpRemoveText.Spec;
/**@typedef{{
    memberid:string,
    timestamp:(number|undefined),
    position:number,
    length:number
}}*/
ops.OpRemoveText.InitSpec;
